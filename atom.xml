<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-05-21T06:29:27.328Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[数据库]数据库概论基础整理</title>
    <link href="http://qianyouyou.cn/2018/05/21/2018-05-21/"/>
    <id>http://qianyouyou.cn/2018/05/21/2018-05-21/</id>
    <published>2018-05-21T05:29:08.000Z</published>
    <updated>2018-05-21T06:29:27.328Z</updated>
    
    <content type="html"><![CDATA[<p>努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔</p><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><h4 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h4><p>数据(Data)：数据库中存储的基本对象。</p><p>定义：描述事物的符号记录</p><p>种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>数据与其语义是不可分的。</p><p>eg：</p><p>54是一个数据</p><p>语义1：学生某门课的成绩</p><p>语义2：某人的体重</p><p>语义3：计算机系2011级学生人数</p><p>eg:</p><p>学生档案中的学生记录</p><p>（张三，男，19941014，陕西西安市，计算机系，2011）</p><p>语义：学生姓名、性别、出生年月、籍贯、所在院系、入学时间</p><p>解释：张三是个大学生，1994年10月14日出生，陕西省西安市人，2011年考入计算机系</p><h4 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h4><p>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>数据按一定的数据模型组织、描述和储存</p><p>可为各种用户共享</p><p>冗余度较小</p><p>数据独立性较高</p><p>易扩展</p><h4 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>位于用户与操作系统之间的一层数据管理软件。</p><p>是基础软件，是一个大型复杂的软件系统</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>科学地组织和存储数据、高效地获取和维护数据。</p><h5 id="数据库在计算机系统中的位置"><a href="#数据库在计算机系统中的位置" class="headerlink" title="数据库在计算机系统中的位置"></a>数据库在计算机系统中的位置</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-DBMS.png" alt=""></p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><table><thead><tr><th><strong>数据定义功能</strong></th><th>提供数据定义语言(DDL)</th><th>定义数据库中的数据对象</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>数据组织、存储和管理</strong></td><td>分类组织、存储和管理各种数据</td><td>确定组织数据的文件结构和存取方式</td><td>实现数据之间的联系</td><td>提供多种存取方法提高存取效率</td><td></td></tr><tr><td><strong>数据操纵功能</strong></td><td>提供数据操纵语言(DML)</td><td>实现对数据库的基本操作  (增删改查)</td><td></td><td></td><td></td></tr><tr><td><strong>数据库的事务管理和运行管理</strong></td><td>数据库在建立、运行和维护时由DBMS统一管理和控制</td><td>保证数据的安全性、完整性、多用户对数据的并发使用</td><td>发生故障后的系统恢复</td><td></td><td></td></tr><tr><td><strong>数据库的建立和维护功能(实用程序和管理工具)</strong></td><td>数据库初始数据装载转换</td><td>数据库转储</td><td>介质故障恢复</td><td>数据库的重组织</td><td>性能监视分析等</td></tr><tr><td><strong>其它功能</strong></td><td>DBMS与网络中其它软件系统的通信</td><td>两个DBMS系统的数据转换</td><td>异构数据库之间的互访和互操作</td><td></td></tr></tbody></table><h4 id="数据库系统（DBS"><a href="#数据库系统（DBS" class="headerlink" title="数据库系统（DBS)"></a>数据库系统（DBS)</h4><p>Database System，在计算机系统中引入数据库后的系统。</p><h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>数据库</p><p>数据库管理系统（及其开发工具）</p><p>应用系统</p><p>数据库管理员</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-05-21-DBS.png" alt=""></p><h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><h4 id="什么是数据管理"><a href="#什么是数据管理" class="headerlink" title="什么是数据管理"></a>什么是数据管理</h4><p>对数据进行分类、组织、编码、存储、检索和维护</p><p>是数据处理的中心问题</p><p>数据处理：对各种数据进行收集、存储、加工和传播。</p><h4 id="数据管理技术的发展过程"><a href="#数据管理技术的发展过程" class="headerlink" title="数据管理技术的发展过程"></a>数据管理技术的发展过程</h4><p>人工管理阶段(20世纪40年代中–50年代中)</p><p>文件系统阶段(20世纪50年代末–60年代中)</p><p>数据库系统阶段(20世纪60年代末–现在)</p><h4 id="数据管理技术的发展动力"><a href="#数据管理技术的发展动力" class="headerlink" title="数据管理技术的发展动力"></a>数据管理技术的发展动力</h4><p>应用需求的推动</p><p>计算机硬件的发展</p><p>计算机软件的发展</p><h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><h4 id="数据结构化"><a href="#数据结构化" class="headerlink" title="数据结构化"></a>数据结构化</h4><p>整体数据的结构化是数据库的主要特征之一。</p><h5 id="整体结构化"><a href="#整体结构化" class="headerlink" title="整体结构化"></a>整体结构化</h5><p>不再仅仅针对某一个应用，而是面向全组织</p><p>不仅数据内部结构化，整体是结构化的，数据之间具有联系</p><h5 id="数据库中实现的是数据的真正结构化"><a href="#数据库中实现的是数据的真正结构化" class="headerlink" title="数据库中实现的是数据的真正结构化"></a>数据库中实现的是数据的真正结构化</h5><p>数据的结构用数据模型描述，无需程序定义和解释</p><p>数据可以变长</p><p>数据的最小存取单位是数据项</p><h4 id="数据的共享性高，冗余度低，易扩充"><a href="#数据的共享性高，冗余度低，易扩充" class="headerlink" title="数据的共享性高，冗余度低，易扩充"></a>数据的共享性高，冗余度低，易扩充</h4><p>数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。</p><h5 id="数据共享的好处"><a href="#数据共享的好处" class="headerlink" title="数据共享的好处"></a>数据共享的好处</h5><p>减少数据冗余，节约存储空间</p><p>避免数据之间的不相容性与不一致性</p><p>使系统易于扩充</p><h4 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h4><p>数据独立性是由DBMS的二级映像功能来保证的。</p><h5 id="物理独立性"><a href="#物理独立性" class="headerlink" title="物理独立性"></a>物理独立性</h5><p>指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</p><h5 id="逻辑独立性"><a href="#逻辑独立性" class="headerlink" title="逻辑独立性"></a>逻辑独立性</h5><p>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</p><h4 id="数据由DBMS统一管理和控制"><a href="#数据由DBMS统一管理和控制" class="headerlink" title="数据由DBMS统一管理和控制"></a>数据由DBMS统一管理和控制</h4><h5 id="DBMS提供的数据控制功能"><a href="#DBMS提供的数据控制功能" class="headerlink" title="DBMS提供的数据控制功能"></a>DBMS提供的数据控制功能</h5><p>(1)数据的安全性（Security）</p><p>保护保护数据，以防止不合法的使用造成的数据的泄密和破坏。</p><p>(2)数据的完整性（Integrity）</p><p>检查将数据控制在有效的范围内，或保证数据之间满足一定的关系。</p><p>(3)并发（Concurrency）</p><p>控制对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p><p>(4)数据库恢复（Recovery）</p><p>将数据库从错误状态恢复到某一已知的正确状态。</p><h5 id="应用程序与数据的对应关系-数据库系统"><a href="#应用程序与数据的对应关系-数据库系统" class="headerlink" title="应用程序与数据的对应关系(数据库系统)"></a>应用程序与数据的对应关系(数据库系统)</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-05-21-DBS2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔&lt;/p&gt;
&lt;h2 id=&quot;数据库系统概述&quot;&gt;&lt;a href=&quot;#数据库系统概述&quot; class=&quot;headerlink&quot; title=&quot;数据库系统概述&quot;&gt;&lt;/a&gt;数据库系统概述&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库概论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="数据库" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库基础" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
      <category term="[object Object]" scheme="http://qianyouyou.cn/tags/object-Object/"/>
    
  </entry>
  
  <entry>
    <title>ACM全国邀请赛热身赛题2并查集</title>
    <link href="http://qianyouyou.cn/2018/05/19/2018-05-19/"/>
    <id>http://qianyouyou.cn/2018/05/19/2018-05-19/</id>
    <published>2018-05-19T15:37:32.000Z</published>
    <updated>2018-05-19T15:45:48.164Z</updated>
    
    <content type="html"><![CDATA[<p>真是糟糕的一天，愿不要影响到明天邀请赛发挥。</p><p>题意：</p><p>有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可能叛徒数，否则输出-1，遇到第几条时判断是谎言。</p><p>例：</p><p>输入</p><p>3 3</p><p>1 2</p><p>2 3</p><p>3 1</p><p>输出</p><p>-1 3</p><p>输入</p><p>5 4</p><p>1 2</p><p>2 3</p><p>3 4</p><p>4 1</p><p>输出</p><p>1 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXX = 100010;</span><br><span class="line">int fa[MAXX], r[MAXX];</span><br><span class="line">int vis[MAXX];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if (fa[x] == x) return fa[x];</span><br><span class="line">int tmp = fa[x];</span><br><span class="line">fa[x] = find(fa[x]);</span><br><span class="line">r[x] = (r[tmp] + r[x]) % 2;</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void fun(int x, int y)&#123;</span><br><span class="line">int fx = find(x), fy = find(y);</span><br><span class="line">if (fx == fy)   return;</span><br><span class="line">fa[fy] = fx;</span><br><span class="line">r[fy] = (r[x] + 1 - r[y]) % 2;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">int N, M, x, y, flag = 0, cnt = 0;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;N, &amp;M);</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (int i = 0; i &lt;= N; i++)   fa[i] = i, r[i] = 0;</span><br><span class="line">for (int i = 1; i &lt;= M; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">if (!vis[x])</span><br><span class="line">cnt++;</span><br><span class="line">if (!vis[y])</span><br><span class="line">cnt++;</span><br><span class="line">vis[x] = vis[y] = 1;</span><br><span class="line">if (flag)</span><br><span class="line">continue;</span><br><span class="line">if (find(x) == find(y)) &#123;</span><br><span class="line">if (r[x] == r[y])</span><br><span class="line">flag = i;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">fun(x, y);</span><br><span class="line">&#125;</span><br><span class="line">if (flag)</span><br><span class="line">printf(&quot;-1 %d\n&quot;, flag);</span><br><span class="line">else &#123;</span><br><span class="line">int cnt2 = 0;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">find(i);</span><br><span class="line">if (r[i] == 1 || !vis[i])</span><br><span class="line">cnt2++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;1 %d\n&quot;, cnt - cnt2 &gt; cnt2 ? cnt - cnt2 : cnt2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真是糟糕的一天，愿不要影响到明天邀请赛发挥。&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://qianyouyou.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>牛客小白月赛&amp;&amp;艾教习题总结</title>
    <link href="http://qianyouyou.cn/2018/05/16/2018-05-16/"/>
    <id>http://qianyouyou.cn/2018/05/16/2018-05-16/</id>
    <published>2018-05-16T14:51:02.000Z</published>
    <updated>2018-05-17T05:19:32.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管道取珠"><a href="#管道取珠" class="headerlink" title="管道取珠"></a>管道取珠</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_1.jpg" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_2.jpg" alt=""></p><p><strong>输入</strong></p><p>第一行包含两个整数n, m，分别表示上下两个管道中球的数目。 第二行为一个AB字符串，长度为n，表示上管道中从左到右球的类型。其中A表示浅色球，B表示深色球。 第三行为一个AB字符串，长度为m，表示下管道中的情形。</p><p><strong>输出</strong></p><p>仅包含一行，即为 Sigma(Ai^2) i从1到k 除以1024523的余数。</p><p><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">AB</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>数据规模及约定</strong></p><p>约30%的数据满足 n, m ≤ 12；<br>约100%的数据满足n, m ≤ 500。</p><p><strong>题解</strong></p><p>这题思路比较妙，我们需要先想想 ∑ai2 有什么意义。如果我们构造出这样一个游戏场景，即两个人同时玩两份同样的如题目所述的管道取珠的游戏，那么这两个人游戏结束后取到的珠子颜色序列一模一样的方案数就是题目里要求的答案。</p><p>令这两个人分别是 p1 和 p2。于是设 f[i][j][k] 表示 p1 取了第二个管道中的前 i 个珠子，第一个管道中的前 j 个珠子；p2 取了第一个管道的前 k 个珠子，这个状态下颜色序列相同的方案数，转移显然。</p><p>注：n为12以内一般是阶乘的题，n为30以内可以考虑状态压缩，莫队，线段树等各种情况，50左右选择二分，100以上需要另想方法。</p><h2 id="问号猜数"><a href="#问号猜数" class="headerlink" title="问号猜数"></a>问号猜数</h2><p>有一堆数按照递增的顺序排列，然而这些数的某些位我们并不知道，我们知道的只是这些数是从小到大排列的，现在依次给出这些数，不知道的位用？表示。我们需要猜这个数能满足递增条件的最小数。例如：</p><p>??</p><p>1?</p><p>?1</p><p>???</p><p>?99</p><p>?9?</p><p>?4?5</p><p>第一个数是10，第2个11，第3个21，第4个100，第5个199，第6个290，第7个1405。</p><p><strong>题解</strong></p><p>用贪心虽然比较快，但代码不容易写，须考虑情况挺多。因此我们分析一下。首先n&lt;=6，代表最大位数是6，也就是说最大的数也就是百万位。因此直接从1枚举，另设指针指向第1个数，每枚举到某个数满足该指针指向的数，则将指针指向下一个数，然后继续枚举，因此扫描一遍之后就得到所有的答案了。</p><p>接下来，假如n&lt;=15，由于数是递增的，则将枚举用二分来完成。假如n&gt;=100，这时再考虑贪心。</p><h2 id="取牌去牌"><a href="#取牌去牌" class="headerlink" title="取牌去牌"></a>取牌去牌</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌ii.j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p><p><strong>题解</strong></p><p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p><h2 id="铁索连环"><a href="#铁索连环" class="headerlink" title="铁索连环"></a>铁索连环</h2><p>有n个数，现在有m次查询，每次查询[l,r]范围所有不同的数。假设n很大</p><p><strong>题解</strong></p><p>我的思路是打表记录上一个相同元素的位置，比如a[1-10]=1,2,4,3,2,4,5,6,3,4,那么b[1-10]=0,0,0,0,2,3,0,0,4,6。这样l，r的范围内只需扫描1遍即可，扫到0结果加1，扫到非0的数看该下标是否 &lt; l，是则加1，否则不处理。时间复杂度是0mn。</p><p>艾教的方法不是很懂，不过举了一个例子，假如(3(3(3(3(3)))))，查询范围为括号所示，那么只需将第5个3赋为1，其他3赋为0即可。看起来最后就像一条链子捆绑着相同的元素。</p><h2 id="狭路相逢"><a href="#狭路相逢" class="headerlink" title="狭路相逢"></a>狭路相逢</h2><p>有一个图，每条路上都有强盗，每个节点都有驴友，假如到某条路上，该路上的强盗抢劫你的条件是强盗人数大于等于你们人数。你们每经过一个节点可以拉驴友入伍结伴而行，问（忘记问什么了，尴尬~QAQ~）</p><p><strong>题解</strong></p><p>并查集</p><h2 id="区间gcd"><a href="#区间gcd" class="headerlink" title="区间gcd"></a>区间gcd</h2><p>给定l，r，问多少种gcd(l,r)==gcd(l2.r2)</p><p><strong>题解</strong></p><p>1、两个条件，从1到n，最大公约数呈递减阶梯式。</p><p>2、gcd(gcd（a,b）,gcd(c,d))==gcd(a,d)</p><p>根据性质2可以用st表列出范围内l，r的最大公约数，即1，n最大公约数</p><p>根据性质1，二分求解</p><h2 id="信号误差"><a href="#信号误差" class="headerlink" title="信号误差"></a>信号误差</h2><p>艾教给女朋友传情发信号，信号是01串（16位）组成的字母，但是有情敌的干扰，途中可能至多会有两位进制会发生改变。问如何设置01串才能无视干扰准确将信号传给女盆友。例如1111111111111111，那么该2个1也是比0多，所以无视干扰。但每次只能处理一个字母，效率太慢。</p><p><strong>题解</strong></p><p>图论。将距离2以内的所有结点全部连起来。贪心选取结点，可以直接选择第一个结点开始。</p><h2 id="牛客小白月赛"><a href="#牛客小白月赛" class="headerlink" title="牛客小白月赛"></a>牛客小白月赛</h2><h3 id="音标"><a href="#音标" class="headerlink" title="音标"></a><a href="https://www.nowcoder.com/acm/contest/87/A" target="_blank" rel="noopener">音标</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>  我们规定元音字母有a、e、i、o、u，并且规定半元音字母y也是元音字母。 </p><p>  Cwbc在学习英语，XHRlyb为了让Cwbc的记忆更加深刻，于是她让Cwbc把每个字符串的所有字母都变成一个<strong>恰好**</strong>不大于它本身的小写元音字母**。 </p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有一个仅包含小写字母的字符串。</span><br></pre></td></tr></table></figure><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，每行有一个变化后的字符串。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元音字母变为一个恰好不大于它本身的字母，也就是元音字母本身</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfjpv</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入样例是由元音字母a、e、i、o、u的后一个字母组成，每个字母变为一个恰好不大于它本身的字母，也就是a、e、i、o、u。</span><br></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>upper_bound的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">char s[210000];</span><br><span class="line">char a[]=&quot;aeiouy&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;s[i];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]=a[upper_bound(a,a+6,s[i])-a-1];</span><br><span class="line">        &#125;</span><br><span class="line">        puts(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="躲藏"><a href="#躲藏" class="headerlink" title="躲藏"></a><a href="https://www.nowcoder.com/acm/contest/87/B" target="_blank" rel="noopener">躲藏</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>XHRlyb和她的小伙伴Cwbc在玩捉迷藏游戏。<br> Cwbc藏在多个不区分大小写的字符串中。<br> 好奇的XHRlyb想知道，在每个字符串中Cwbc作为子序列分别出现了多少次。<br> 由于Cwbc可能出现的次数过多，你只需要输出每个答案对<strong>2000120420010122</strong>取模后的结果。<br> 聪明的你在仔细阅读题目后，一定可以顺利的解决这个问题！</p><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有一个字符串。</span><br></pre></td></tr></table></figure><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，每行表示一个答案取模后的结果。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc作为子序列仅出现了1次。</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acdcecfwgwhwibjbkblcmcnco</span><br></pre></td></tr></table></figure><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc作为子序列出现了34=81次。</span><br></pre></td></tr></table></figure><h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>一个memset导致超时，也是够无语。时间复杂度4 <em> On，加上memset是5 </em> On，就差1个On就超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">char str[200010];</span><br><span class="line">long long dp[5][200010];</span><br><span class="line">int main() &#123;</span><br><span class="line">int i;</span><br><span class="line">while (scanf(&quot;%s&quot;, str + 2) != EOF) &#123;</span><br><span class="line">dp[1][0] = &apos;c&apos;, dp[2][0] = &apos;w&apos;, dp[3][0] = &apos;b&apos;,dp[4][0] = &apos;c&apos;;</span><br><span class="line">for (i = 2; str[i]; i++) &#123;</span><br><span class="line">dp[0][i] = 1;</span><br><span class="line">str[i] = tolower(str[i]);</span><br><span class="line">for (int k = 1; k &lt; 5; k++) &#123;</span><br><span class="line">dp[k][i] = dp[k][i - 1];</span><br><span class="line">if (str[i] == dp[k][0]) &#123;</span><br><span class="line">dp[k][i] += dp[k - 1][i];</span><br><span class="line">dp[k][i] %= 2000120420010122;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[4][i - 1]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a><a href="https://www.nowcoder.com/acm/contest/87/C" target="_blank" rel="noopener">博弈</a></h3><p> 博弈双方都是绝顶聪明的，并且XHRlyb先手，请你来帮XHRlyb预测这一局游戏谁会获胜。 </p><p>  如果博弈双方谁也无法取胜，那么判定为平局。 </p><h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有三个正整数，l，r，k。</span><br></pre></td></tr></table></figure><h4 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，如果这一局XHRlyb获胜，那么请输出XHRlyb；如果Cwbc获胜，请输出Cwbc；如果两人平局，请输出Draw。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 2</span><br></pre></td></tr></table></figure><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XHRlyb</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure><h4 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ≤ l ≤ r ≤ 105。</span><br><span class="line">1 ≤ k ≤ 100。</span><br><span class="line">1 ≤ T ≤ 1000。</span><br></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>水dp，l，r写反了，一直报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[100005];</span><br><span class="line">int sum[100005];</span><br><span class="line">int main() &#123;</span><br><span class="line">int l, r, k;</span><br><span class="line">while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; k) &#123;</span><br><span class="line">memset(dp, 0, sizeof(dp));</span><br><span class="line">memset(sum, 0, sizeof(sum));</span><br><span class="line">if (k == 1) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">sum[i] = (sum[i - 1] + 1);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = k; i &lt;= r; i++) &#123;</span><br><span class="line">dp[i] = (dp[i / k] * k + 1);</span><br><span class="line">sum[i] = (sum[i - 1] + dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">if (abs(sum[r] - sum[l - 1]) % 2 == 1)</span><br><span class="line">cout &lt;&lt; &quot;XHRlyb&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;Cwbc&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;管道取珠&quot;&gt;&lt;a href=&quot;#管道取珠&quot; class=&quot;headerlink&quot; title=&quot;管道取珠&quot;&gt;&lt;/a&gt;管道取珠&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="线性dp" scheme="http://qianyouyou.cn/tags/%E7%BA%BF%E6%80%A7dp/"/>
    
  </entry>
  
  <entry>
    <title>陕西师范大学第七届程序设计竞赛题解</title>
    <link href="http://qianyouyou.cn/2018/05/14/2018-05-14/"/>
    <id>http://qianyouyou.cn/2018/05/14/2018-05-14/</id>
    <published>2018-05-14T08:42:18.000Z</published>
    <updated>2018-05-14T10:53:18.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WWX的520"><a href="#WWX的520" class="headerlink" title="WWX的520"></a><a href="https://www.nowcoder.com/acm/contest/121/A" target="_blank" rel="noopener">WWX的520</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>520，因为谐音为我爱你，所以也被称之为表白日。</p><p>这一天，人们借机把藏在心底的洪荒之力通过表白、撒娇、传情、送礼、结婚等形式释放出来，商家也会趁势开展各类优惠促销活动，掀起一波或浪漫或虐狗的节日热浪。</p><p>这一天，也是送男朋友礼物、送女朋友礼物、送自己礼物、送亲朋好友礼物的好时机。</p><p>在520即将到来之际，wwx准备为她的女朋友购买一批礼物。于是他列出了一份礼物清单，但由于预算有限，必须删掉一种礼物。经过深思熟虑，他决定删掉价格第k高的礼物，你能帮帮他，找出是哪一种礼物吗?</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行是一个整数T（1&lt;=T&lt;=80），表示有T组数据.</span><br><span class="line">对于每一组数据，首先一行输入N(3&lt;=N&lt;=1000)，接下来的N行每行输入一个字符串和一个整数，以空格间隔，分别作为每种礼物的名字和价格。</span><br><span class="line">接下来一行输入k，表示要删去第k(1&lt;=&lt;=N)高的礼物</span><br><span class="line">礼物的名字的长度不超过30，礼物的价格不超过1000，且均为整数。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于每组输入数据，依次输出它的组号和要删去的礼物的名字和价格,以空格间隔。</span><br><span class="line">若两种商品的价格相同，则比较礼物名字的字典序大小。即:两种礼物的价格相同时，字典序大者若为第k高，字典序小者则为第k+1高。</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Apple 18</span><br><span class="line">Book 30</span><br><span class="line">Milk 8000</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Apple 300</span><br><span class="line">Bananas  200</span><br><span class="line">Bracelet 200</span><br><span class="line">Candy 200</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1: Apple 18</span><br><span class="line">#2: Bracelet 200</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">可用strcmp(s1,s2)函数进行字符串的比较。</span><br><span class="line">2.</span><br><span class="line">对于样例一中第二组数据:Apple 300是价格第一大，Candy 200是价格第二高，Bracelet</span><br><span class="line">200是价格第三大。</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接按照价格从大到小排序，如果价格相同按照字母序从大到小排序。排完序之后直接输出第k位的礼物名称与价格即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">string str;</span><br><span class="line">int v;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">if (a.v == b.v) &#123;</span><br><span class="line">return a.str&gt;b.str;</span><br><span class="line">&#125;</span><br><span class="line">return a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">for (int z = 1; z &lt;= t; z++) &#123;</span><br><span class="line">int n, k;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i].str;</span><br><span class="line">cin &gt;&gt; a[i].v;</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + n, cmp);</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; &quot;#&quot; &lt;&lt; z &lt;&lt; &quot;: &quot; &lt;&lt; a[k - 1].str &lt;&lt; &quot; &quot; &lt;&lt; a[k - 1].v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配环境"><a href="#配环境" class="headerlink" title="配环境"></a><a href="https://www.nowcoder.com/acm/contest/121/B" target="_blank" rel="noopener">配环境</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      黑猫在给校赛配环境，结果被服务器的各种入站规则出站规则搞得头疼，想到自己要上传GVIM、EMACS、VSCODE、Jetbrain全家桶、Visual Studio、Gedit、Microsoft Office Word、Eclipse等等，完全不知道要要花费多少时间才能上传完校赛需要的环境。 </p><p>​      黑猫跑去问ddjing，谁知道ddjing说：“我要去实习了，没功夫解决这个问题，你去问问其他人吧。“ </p><p>​      于是黑猫想请你帮他解决这个问题。 </p><p>​      服务器总传输速度为每秒M个单位（本题出现的所有单位都统一），黑猫现在需要上传总共n个软件（按优先级顺序从高到低给出），每个软件的大小分别为v1、v2….vn，每个软件为保持稳定连接，上传需要一个最小的传输速度为m1、m2…mn。 </p><p>​      服务器带宽分配的策略是：按优先级满足每一个软件要求的传输速度。如果服务器剩余的带宽不能满足某个软件最小传输速度的话，服务器将继续寻找下去，直到找到能满足最小传输速度的软件。 </p><p>​      如果目前服务器的总传输速度不能满足所有还需要上传的软件的话，服务器将把传输速度全部给予当前优先级最高的（即使不能满足其最小传输速度）。 </p><p>​      如果目前对所有软件都满足了其最小传输速度的话，服务器将把剩余所有传输速度全部给予当前优先级最高的软件。 </p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行给出一个正整数，表示服务器总带宽M</span><br><span class="line">第二行给出整数n，表示需要上传的n个软件。</span><br><span class="line">第三行为n个正整数，第i个数表示vi。</span><br><span class="line">第四行为n个正整数，第i个数表示mi。</span><br><span class="line">( 1 &lt;= M &lt;= 1000,  1 &lt;= n &lt;= 100 , 1 &lt;=  vi &lt;= 1000 ,  1 &lt;= mi &lt;= 1000 )</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行，为上传完毕所有软件所需要的时间，保留两位小数。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">1 1 4 5 1 4 </span><br><span class="line">10 9 8 7 6 5</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.60</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">10 9 8 7 6 5</span><br><span class="line">1 1 4 5 1 4</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.50</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原本是一道水题，结果成功被题面绕进去了。其实只需要把所有软件的大小V加起来除以宽带大小M即可。所谓最小速度都是迷惑人的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int M, n;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;M, &amp;n);</span><br><span class="line">double tmp, ans = 0;</span><br><span class="line">for (int i = 0; i &lt; n;i++) &#123;</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">ans += tmp;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line">ans /= M;</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一段超时代码，成功将题面的过程给模拟了出来，当时没仔细看数据是怎么得到的，一直超时很不可思议。因此总结出了经验，以后做题一定得分析出数据是怎么得到的，有时候就很容易找到规律或者发现玄机。另外下面的代码总结出了一个新的方法，就是利用滚动数组实现删除元素，虽然vector有删除功能，但删除效率低。以下的方法是利用滚动数组，将未删除的元素重新压入数组，删除的元素不进行操作，然后清空数组，这样循环操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int M, n;</span><br><span class="line">struct node&#123;</span><br><span class="line">double v;</span><br><span class="line">int m;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int vis[1005];</span><br><span class="line">vector&lt;int&gt;vv[2];</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; n;</span><br><span class="line">double ans = 0, wei;</span><br><span class="line">int ff[2] = &#123; 0,1 &#125;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; a[i].v;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i].m;</span><br><span class="line">vv[ff[0]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while (flag &gt;= 0) &#123;</span><br><span class="line">flag = -1;</span><br><span class="line">wei = M;</span><br><span class="line">double mint = inf;</span><br><span class="line">vv[ff[1]].clear();</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">for (it = vv[ff[0]].begin(); it != vv[ff[0]].end(); it++) &#123;</span><br><span class="line">if (a[*it].v &lt;= 0) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;vis[*it] = 0;</span><br><span class="line">vv[ff[1]].push_back(*it);</span><br><span class="line">if (flag &lt; 0)</span><br><span class="line">flag = *it;</span><br><span class="line">if (a[*it].v &lt;= wei) &#123;</span><br><span class="line">vis[*it] = 1;</span><br><span class="line">wei -= a[*it].m;</span><br><span class="line">if (*it != flag)</span><br><span class="line">mint = min(mint, a[*it].v / a[*it].m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag &lt; 0)</span><br><span class="line">break;</span><br><span class="line">mint = min(mint, a[flag].v / (vis[flag] ? a[flag].m + wei : wei));</span><br><span class="line">for (it = vv[ff[1]].begin(); it != vv[ff[1]].end(); it++) &#123;</span><br><span class="line">if (a[*it].v &lt;= 0 || !vis[*it] || flag == *it)</span><br><span class="line">continue;</span><br><span class="line">a[*it].v -= a[*it].m*mint;</span><br><span class="line">&#125;</span><br><span class="line">a[flag].v -= (vis[flag] ? a[flag].m + wei : wei)*mint;</span><br><span class="line">ans += mint;</span><br><span class="line">ff[0] = ff[0] ^ ff[1];</span><br><span class="line">ff[1] = ff[0] ^ ff[1];</span><br><span class="line">ff[0] = ff[0] ^ ff[1];</span><br><span class="line">//cout &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; mint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iko和她的糖"><a href="#iko和她的糖" class="headerlink" title="iko和她的糖"></a><a href="https://www.nowcoder.com/acm/contest/121/C" target="_blank" rel="noopener">iko和她的糖</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      iko超级超级喜欢吃糖，有一天iko想出去玩，她计划从1点走到N点（按1,2,3，…，n的顺序走），每个点都有一个补给站，第i点的补给站有a[i]颗糖，从i点走到i+1点会消耗掉b[i]颗糖，iko在出游的途中可以选择三个补给站，iko想知道她走完全程到达N点时口袋里最多还能剩下几颗糖（初始时iko的口袋里一颗糖都没有）。 </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入N（3&lt;=N&lt;=1000）</span><br><span class="line">第二行输入N个数代表a[1].......a[N]  (0&lt;=a[i]&lt;=1000 )</span><br><span class="line">第三行输入N-1个数代表b[1]......b[N-1]  ( 1&lt;=b[i]&lt;=1000 )</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出一个数字表示iko到达n点时口袋里最多剩下的糖，</span><br><span class="line">若不能到达N点输出-1。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 5 2 4</span><br><span class="line">3 2 2 2</span><br></pre></td></tr></table></figure><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先，3个补给站必须得选择第1个，因为一开始没有糖，而每条路都需要消耗糖，所以必须拿起点的糖。之后就很好理解了，每走一条路记录当前走过的补给站最大的两个，如果哪一条路糖果不够了，就把最大的补给站加上，如果还不够就把次大的也加上。每次记录走到这条路经过的最大补给站记录下来，然后现有糖果减去消耗的糖果，如果为负就把之前的最大补给站的糖果加上。例如第2组数据，初始是3，走到第1条路剩余糖果为0，此时记录的最大补给站是4，然后走到下一条路糖果变成了-2，那就把最大补给站的加上，现在剩余糖果是2。此时最大补给站记录5，再往下走是2，剩余糖果是0，继续走，消耗2个为-2，则加上最大补给站的糖5。最终就是3。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int N, cur, MAX1, MAX2, flag, a[maxn];</span><br><span class="line">void check(int &amp;cnt) &#123;</span><br><span class="line">while (cnt&amp;&amp;cur &lt; 0) &#123;</span><br><span class="line">cur += MAX1;</span><br><span class="line">MAX1 = MAX2;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fun(int i) &#123;</span><br><span class="line">if (MAX1 &lt;= a[i]) &#123;</span><br><span class="line">MAX2 = MAX1;</span><br><span class="line">MAX1 = a[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (MAX2 &lt; a[i]) &#123;</span><br><span class="line">MAX2 = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N) &#123;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">MAX1 = -1, MAX2 = -1, flag = 0;</span><br><span class="line">int tmp, cnt = 3;</span><br><span class="line">cur = 0;</span><br><span class="line">for (int i = 0; i &lt; N; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">for (int i = 0; i &lt; N - 1; i++) &#123;</span><br><span class="line">fun(i);</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">cur -= tmp;</span><br><span class="line">if (cur &lt; 0) &#123;</span><br><span class="line">check(cnt);</span><br><span class="line">&#125;</span><br><span class="line">if (cur &lt; 0)</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">fun(N - 1);</span><br><span class="line">if (flag)</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">else &#123;</span><br><span class="line">if (cnt == 2)</span><br><span class="line">cur += MAX1 + MAX2;</span><br><span class="line">else if (cnt == 1)</span><br><span class="line">cur += MAX1;</span><br><span class="line">printf(&quot;%d\n&quot;, cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZQ的睡前故事"><a href="#ZQ的睡前故事" class="headerlink" title="ZQ的睡前故事"></a><a href="https://www.nowcoder.com/acm/contest/121/D" target="_blank" rel="noopener">ZQ的睡前故事</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      ZQ是一个拥有n女朋友的万人迷，她的每一个女朋友每天晚上都会挨个给他打电话，要他讲了睡前故事才能睡觉。可是，每次他的女朋友都会挑他在吃鸡的时候打电话，ZQ总是因为挂机被舍友赶出宿舍，于是，ZQ告诉他的女朋友们，别打电话了，他会主动打过去给他们讲故事，再打电话就分手！ </p><p>​      于是，ZQ把他的女朋友名字写在纸上，画成一圈，顺时针编号为1~n，然后从1开始顺时针数。在每一次数数中，ZQ数k个就停下来，然后给选中的女朋友打电话讲故事。   </p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先输入一个t，然后t组数据，每行包含两个数字n,k，n&lt;20,k&gt;0</span><br></pre></td></tr></table></figure><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按顺序输出每轮被选中的女朋友的编号。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">5 2</span><br><span class="line">11 4</span><br></pre></td></tr></table></figure><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br><span class="line">2 4 1 5 3</span><br><span class="line">4 8 1 6 11 7 3 2 5 10 9</span><br></pre></td></tr></table></figure><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>约瑟夫环。由于数据比较水，所以多种方法求解，这里不介绍了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, k, t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">int i = 0;</span><br><span class="line">int cnt = n;</span><br><span class="line">int vis[20] = &#123; 0 &#125;;</span><br><span class="line">while (cnt) &#123;</span><br><span class="line">int kk = k;</span><br><span class="line">while (vis[i%n])</span><br><span class="line">i++;</span><br><span class="line">for (int j = 1; j &lt; kk; j++) &#123;</span><br><span class="line">i++;</span><br><span class="line">while (vis[i%n])</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">vis[i%n] = 1;</span><br><span class="line">cnt--;</span><br><span class="line">cnt ? printf(&quot;%d &quot;, i%n + 1) : printf(&quot;%d\n&quot;, i%n + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加：hdu5135-Little-Zu-Chongzhi’s-Triangles"><a href="#附加：hdu5135-Little-Zu-Chongzhi’s-Triangles" class="headerlink" title="附加：hdu5135 Little Zu Chongzhi’s Triangles"></a>附加：hdu5135 Little Zu Chongzhi’s Triangles</h2><p>题意：</p><p>有n条边组三角形，每个三角形必须由3条边组成，三角形边不可以重复利用，不可以共线，只能是分开的三角形。问这n条边组成的所有三角形的面积和最大为多少。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>原本状压dp求解，但数据比较水，因此递归还没有记忆化搜索直接就过了。每次从n条边里面选择3条边组成三角形，方程maxx[i],[j] = max(maxx[i-1],[j],[1~n] );由于状态是集合，因此需要状压以下。这里主要说的是一个常犯的错误。我没找到vis是当前状态是否已经选过，尤其是搜索时vis的作用非常重要。但本题用深搜时犯了一个错误，就是在vis=1,与vis=0之间多了一个continue，即vis=1，continue，dfs，vis=0，导致状态更改，数据一直错误。正确顺序应该是continue，vis=1，dfs，vis=0。因此之后比赛时一定要注意此细节。在vis=1与vis=0之间一定要注意是否有其他条件导致循环结束而状态还未还原。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int vis[15];</span><br><span class="line">double a[15];</span><br><span class="line">double dfs(int x) &#123;</span><br><span class="line">double ans = 0, maxx = 0;</span><br><span class="line">for (int i = x; i&lt;n; i++) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">continue;</span><br><span class="line">vis[i] = 1;</span><br><span class="line">for (int j = i + 1; j&lt; n; j++) &#123;</span><br><span class="line">if (vis[j])</span><br><span class="line">continue;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">for (int k = j + 1; k&lt;n; k++) &#123;</span><br><span class="line">if (vis[k])</span><br><span class="line">continue;</span><br><span class="line">if (a[k] &gt;= a[i] + a[j] || a[j] &gt;= a[i] + a[k] || a[i] &gt;= a[j] + a[k])</span><br><span class="line">continue;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">double c = (a[i] + a[k] + a[j]) / 2.0;</span><br><span class="line">ans = sqrt(c*(c - a[i])*(c - a[j])*(c - a[k]));</span><br><span class="line">ans += dfs(i + 1);</span><br><span class="line">maxx = max(maxx, ans);</span><br><span class="line"></span><br><span class="line">vis[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">vis[j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">vis[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">return maxx;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">if (!n)</span><br><span class="line">break;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">double ans = dfs(0);</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WWX的520&quot;&gt;&lt;a href=&quot;#WWX的520&quot; class=&quot;headerlink&quot; title=&quot;WWX的520&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/121/A&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018计蒜之道初赛第一场A题百度无人车</title>
    <link href="http://qianyouyou.cn/2018/05/12/2018-05-12/"/>
    <id>http://qianyouyou.cn/2018/05/12/2018-05-12/</id>
    <published>2018-05-12T14:53:29.000Z</published>
    <updated>2018-05-12T15:20:58.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百度无人车"><a href="#百度无人车" class="headerlink" title="百度无人车"></a><a href="https://nanti.jisuanke.com/t/26980" target="_blank" rel="noopener">百度无人车</a></h2><p>百度一共制造了 n 辆无人车，其中第 ii 辆车的重量为 a_i\ \mathrm{kg}ai kg。</p><p>由于车辆过重会增大轮胎的磨损程度，现在要给这 n 辆车减轻重量。每将一辆车减轻 1\ \mathrm{kg}1 kg需要消耗 p 万百度币，总预算为 s 万百度币。</p><p>现在希望你设计一种最优的减重方案，使得最重的车辆的重量是所有减重方案中最小的。任何时候，每辆车的重量必须大于等于 1\ \mathrm{kg}1 kg。并且减重方案只能减轻整数 \mathrm{kg}kg。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个整数 n，表示百度无人车的数量。</p><p>接下来一行输入 n 个整数，其中第 ii 个整数 a_iai表示第 ii 辆车的重量。</p><p>接着一行输入两个整数 p,s，分别表示把一辆车减重 1\ \mathrm{kg}1 kg 需要花费 p 万百度币，总的预算是 s 万百度币。</p><p>保证 1 \le n \le 200001≤n≤20000，1 \le a_i \le 200001≤ai≤20000，1 \le p \le 200001≤p≤20000，1 \le s \le 10^{18}1≤s≤1018。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示经过你设计的最优减重方案后，最重的车辆的重量是多少 \mathrm{kg}kg。</p><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6 7 8 9</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">11 14 6 13 11</span><br><span class="line">4 68</span><br></pre></td></tr></table></figure><h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每1kg消耗p元，一共s元，因此一共可以减s/p（kg），直接s=s/p就行了。先对整个数组进行排序，然后再进行操作。一开始用二分，时间复杂度Onlogn，通不过，因此换了一种线性的方法，时间复杂度On。首先建一个差分数组，储存该元素和前一个元素的差值。以1， 2， 4， 6， 9为例，差分数组为1,1,2,2,3。然后从后往前操作。假设s=s/p之后s为10，首先s与第n个元素差分数组比较，如果大，则s-3=7。再和第n-1比较，由于该位置后面还有一个元素，因此若要改变该元素使最大值变小，需同时改变这两个数，后面以此类推三个四个数等等。s和b[n-1]<em>2即2 </em> 2比较，大，则s=7-2<em>2=3。再和b[n-2] </em> 3比较。比它小，则证明最大部分再该部分。b[n-2]=b[n-2]-s/3即1，结束循环。现在的差分数组为1,1,1,0,0，现在依次从从b[1]加到b[n就好了，即3。另外由于最小值为1，因此需要对第一个元素特判一下，如果小于1需改为1。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200007;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">ll p, s, n;</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">a[0] = 0;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a + 1, a + n + 1);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">b[i] = a[i] - a[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; p &gt;&gt; s;</span><br><span class="line">s /= p;</span><br><span class="line">ll ans = 0;</span><br><span class="line">for (int i = n; i&gt;0; i--) &#123;</span><br><span class="line">if (s &gt;= b[i] * (n - i + 1)) &#123;</span><br><span class="line">s -= b[i] * (n - i + 1);</span><br><span class="line">b[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">b[i] -= s / (n - i + 1);</span><br><span class="line">for (int j = 2; j &lt;= i; j++)</span><br><span class="line">ans += b[j];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i == 1 &amp;&amp; b[i] &lt;= 1)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (b[1] &lt;= 1)</span><br><span class="line">b[1] = 1;</span><br><span class="line">ans += b[1];</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百度无人车&quot;&gt;&lt;a href=&quot;#百度无人车&quot; class=&quot;headerlink&quot; title=&quot;百度无人车&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/26980&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="差分数组" scheme="http://qianyouyou.cn/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Wannafly挑战赛15</title>
    <link href="http://qianyouyou.cn/2018/05/11/2018-05-11/"/>
    <id>http://qianyouyou.cn/2018/05/11/2018-05-11/</id>
    <published>2018-05-11T15:55:45.000Z</published>
    <updated>2018-05-11T17:55:19.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小化价格"><a href="#最小化价格" class="headerlink" title="最小化价格"></a>最小化价格</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  要求一种方式，使得每组人都到一个各不相同的地点，最小化选择的价格 </p><p>  每个队伍的人都要在同一个地方每个地方只能有一个队伍</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行n,m</span><br><span class="line">第二行n个数，表示每组的人数</span><br><span class="line">接下来m行，每行两个数，表示可容纳的最大人数和选择的价格</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出最小化选择的价格，无解输出-1</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">2 3 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有数据小于1e5</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先对地点以价格从小到大排序，如果相同按容量从小到大排序。由于集合每次插入自动排序，而且可以执行删除操作，因此我们可以用集合储存队伍。然后将队伍放入集合中。对排完序的地点进行遍历，每个地点对容量进行判断，直接对集合up_bound-1操作，就是能被该地点容纳的人数最多的队伍。若存在该队伍，将该队伍从集合中删除，意为该队伍匹配到该地点。然后将总价格加上该地点所需的价格。否则不执行操作，意为当前没有队伍能和该地点匹配。最后对集合判断是否为空，若为空，则证明队伍已经匹配完毕，输出总价格即可，否则意为不是所有队伍都能被容纳，输出-1。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int const maxn = 100020;</span><br><span class="line">struct node &#123;</span><br><span class="line">int pri;</span><br><span class="line">int num;</span><br><span class="line">&#125;loc[maxn];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">if (a.pri == b.pri)</span><br><span class="line">return a.num &lt; b.num;</span><br><span class="line">else</span><br><span class="line">return a.pri &lt; b.pri;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, tmp, ans = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">multiset&lt;int&gt;a;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">a.insert(tmp);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; loc[i].num &gt;&gt; loc[i].pri;</span><br><span class="line">&#125;</span><br><span class="line">sort(loc, loc + m, cmp);</span><br><span class="line">multiset&lt;int&gt;::iterator it;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">if (a.empty())</span><br><span class="line">break;</span><br><span class="line">it = a.upper_bound(loc[i].num);</span><br><span class="line">if (it == a.begin())</span><br><span class="line">continue;</span><br><span class="line">it--;</span><br><span class="line">ans += loc[i].pri;</span><br><span class="line">a.erase(it);</span><br><span class="line">&#125;</span><br><span class="line">if (a.empty())</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="车辆安排"><a href="#车辆安排" class="headerlink" title="车辆安排"></a>车辆安排</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个队伍，每个队伍的人数小于等于5，每辆车最多坐5个人，要求一个队伍的人都在一辆车上，求最少的车数</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行n</span><br><span class="line">第二行n个数，表示每个队伍的人数</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出最少车数</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n≤1e5</span><br><span class="line">每个数小于等于5</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>设置一个数组，分别储存1,2,3,4,5人队伍的个数。总车数=人数为5的队伍数+（人数为4+1或4的队伍数）+（人数为3+2或3+1+1或3的队伍数）+（人数为2+2+1或2+1+1+1或2的队伍数）+（人数为1*5或1的队伍数），（组合方式按优先级排列）。时间复杂度O(1)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, tmp;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">int a[6] = &#123; 0 &#125;, sum = 0;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">a[tmp]++;</span><br><span class="line">&#125;</span><br><span class="line">sum += a[5] + a[4] + a[3];</span><br><span class="line">a[1] = a[1] - a[4];</span><br><span class="line">if (a[3] - a[2] &gt; 0)</span><br><span class="line">a[1] -= 2 * (a[3] - a[2]);</span><br><span class="line">a[2] -= a[3];</span><br><span class="line">if (a[2] &lt; 0)</span><br><span class="line">a[2] = 0;</span><br><span class="line">a[1] -= a[2] / 2;</span><br><span class="line">if (a[2] % 2 == 0) &#123;</span><br><span class="line">sum += a[2] / 2;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sum += a[2] / 2 + 1;</span><br><span class="line">a[1] -= 3;</span><br><span class="line">&#125;</span><br><span class="line">if (a[1] &lt; 0)</span><br><span class="line">a[1] = 0;</span><br><span class="line">a[1] % 5 == 0 ? sum += a[1] / 5 : sum += a[1] / 5 + 1;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>约瑟夫问题(约瑟夫问题)，n个人，1 2报数 1出队( 就是体育课的时候1 2报数 1出队，2留下)，q次询问，每次求第x个人是第几个出队的</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行两个数n,q</span><br><span class="line">接下来q行，每行一个数x，表示询问</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行输出一个询问的答案</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4围成一圈，第一轮：1 2报数，1出队，2留下，3出队，4留下，第二轮，2出队，4留下</span><br></pre></td></tr></table></figure><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q≤500000</span><br><span class="line">n和x≤1e18</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll unsigned long long int</span><br><span class="line">map&lt;ll, ll&gt;ma;</span><br><span class="line">vector&lt;ll&gt;v;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, q , cnt;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">ma[1] = 1;</span><br><span class="line">cnt = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">if (i % 2 == 0)</span><br><span class="line">v.push_back(i);</span><br><span class="line">else &#123;</span><br><span class="line">ma[i] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll it = 0;</span><br><span class="line">if (n % 2)</span><br><span class="line">it++;</span><br><span class="line">while (!v.empty()) &#123;</span><br><span class="line">if (it == v.size())</span><br><span class="line">it = 0;</span><br><span class="line">ma[*(v.begin() + it)] = ++cnt;</span><br><span class="line">v.erase(v.begin() + it);</span><br><span class="line">if (v.empty())</span><br><span class="line">break;</span><br><span class="line">if (it == v.size())</span><br><span class="line">it = 0;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">while (q--) &#123;</span><br><span class="line">int x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; ma[x] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小化价格&quot;&gt;&lt;a href=&quot;#最小化价格&quot; class=&quot;headerlink&quot; title=&quot;最小化价格&quot;&gt;&lt;/a&gt;最小化价格&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>[计算几何]二维计算几何基础</title>
    <link href="http://qianyouyou.cn/2018/05/09/2018-05-09/"/>
    <id>http://qianyouyou.cn/2018/05/09/2018-05-09/</id>
    <published>2018-05-09T13:42:37.000Z</published>
    <updated>2018-05-12T06:16:14.200Z</updated>
    
    <content type="html"><![CDATA[<p>三寸青笺，写不尽对你的思念。——随笔</p><p>用解析几何借助计算机处理几何问题存在着两大缺陷：</p><p>1）方程解的情况复杂，例如Ax+By+C=0；</p><p>2）存在着浮点误差积累。</p><p>计算几何采用了介于代数与几何之间的方式解决几何问题。它利用几何特性辅助简单的代数运算解决几何问题，既能精确求解，有提高了算法效率，并且不失几何的优美特性。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量-1"><a href="#向量-1" class="headerlink" title="向量"></a>向量</h3><p>向量：既有大小又有方向的量。</p><h4 id="向量的比较"><a href="#向量的比较" class="headerlink" title="向量的比较"></a>向量的比较</h4><p>在平面坐标系下，某点的坐标用（x，y）表示，向量和点一样，也可以用x,y表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;//点</span><br><span class="line">    double x,y;</span><br><span class="line">    Point(double x=0,double y=0):x(x),y(y) &#123;&#125;//构造函数方便代码编写</span><br><span class="line">&#125;;</span><br><span class="line">typedef Point Vector;//向量。从程序实现上，Vector只是Point的别名</span><br></pre></td></tr></table></figure><h4 id="向量的加减乘除"><a href="#向量的加减乘除" class="headerlink" title="向量的加减乘除"></a>向量的加减乘除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//向量+向量=向量，点+向量=点</span><br><span class="line">Vector operator + (Vector A, Vector B) &#123;</span><br><span class="line">return Vector(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br><span class="line">//点-点=向量</span><br><span class="line">Vector operator - (Point A, Point B) &#123;</span><br><span class="line">return Vector(A.x - B.x, A.y - B.y);</span><br><span class="line">&#125;</span><br><span class="line">//向量*数=向量</span><br><span class="line">Vector operator * (Vector A, double p) &#123;</span><br><span class="line">return Vector(A.x * p, A.y * p);</span><br><span class="line">&#125;</span><br><span class="line">//向量/数=向量</span><br><span class="line">Vector operator / (Vector A, double p) &#123;</span><br><span class="line">return Vector(A.x / p, A.y / p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向量的比较-1"><a href="#向量的比较-1" class="headerlink" title="向量的比较"></a>向量的比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool operator &lt; (const Point&amp; a, const Point&amp; b) &#123;</span><br><span class="line">return a.x &lt; b.x || (a.x == b.x&amp;&amp;a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line">//减下误差的必要比较</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">int dcmp(double x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fabs(x)&lt;eps) return 0;</span><br><span class="line">    if(x&gt;0) return 1;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">bool operator ==(const point&amp; a,const point&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的“相等”函数用到“三态函数”dcmp,减少了精度问题。另外，向量有一个所谓的“极角”，即从x轴正半轴旋转到该向量方向所需要的角度。C标注库里的atan2函数就是用来求极角的。如向量（x,y）的极角就是atan2（y，x）（单位：弧度）</p><h3 id="向量內积（点积）"><a href="#向量內积（点积）" class="headerlink" title="向量內积（点积）"></a>向量內积（点积）</h3><p>点积，向量α和β的点积等于二者长度的乘积再乘上它们夹角的余弦。当夹角大于90°时点积为负。两向量的点积为一个标量 α·β，它的大小为α·β=|α||β|cosθ，其中θ是&lt;α,β&gt;</p><p>余弦为偶函数，因此点积满足交换率。如果两向量垂直，点积为0。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%82%B9%E7%A7%AF%E5%85%AC%E5%BC%8F.png" alt=""></p><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>α在β的投影α’与β的长度乘积</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%82%B9%E7%A7%AF%E5%9B%BE%E7%A4%BA.png" alt=""></p><p>由定义易知当两向量夹角为锐角时点积值为正，夹角钝角为负，垂直为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double dot(Vector A,Vector B)&#123;    //向量点积</span><br><span class="line">    return A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br><span class="line">double Length(Vector A)&#123;    //向量A长度</span><br><span class="line">    return sqrt(dot(A,A));</span><br><span class="line">&#125;</span><br><span class="line">double angle(Vector A,Vector B)&#123;    //向量A和B夹角</span><br><span class="line">    return acos(dot(A,B)/Length(A)/Length(B));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向量外积（叉积）"><a href="#向量外积（叉积）" class="headerlink" title="向量外积（叉积）"></a>向量外积（叉积）</h3><p>简单地说，两个向量u和w得叉积等于u和w组成的三角形的有向面积的两倍。</p><p>叉积的二维意义—-有向面积：外积大小为由u，w这两个向量围成的平行四边形有向面积。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%8F%89%E7%A7%AF%E5%9B%BE%E7%A4%BA.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%8F%89%E7%A7%AF%E5%85%AC%E5%BC%8F.png" alt=""></p><p>两向量的叉积为一个矢量 a×b，设向量 P(x1,y1),Q(x2,y2)，向量 a 和向量 b 的叉积还是一个向量，长度为|PQ|=x1y2-x2y1;即为向量 P,Q 围成的四边形的面积。它的方向与向量PQ 垂直，并且使(P,Q,P×Q)成右手系。 </p><h4 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%8F%89%E7%A7%AF%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" alt=""></p><p>不难发现，叉积不满足交换率，cross（u，w）=-corss（w，u）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double cross(Vector A,Vector B)  //叉积</span><br><span class="line">&#123;</span><br><span class="line">    return A.x*B.y-A.y*B.x;</span><br><span class="line">&#125;</span><br><span class="line">double area(point A,point B,point C)//已知三个点 p0,p1,p2 的叉积函数</span><br><span class="line">&#123;</span><br><span class="line">    return cross(B-A,C-A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叉积的一个重要性质，判断两向量互相之间的顺逆时针关系。<br>若 P×Q&gt;0，则P在Q 的顺时针方向；<br>若 P×Q&lt;0，则P在Q 的逆时针方向；<br>若 P×Q=0，则P和Q 共线，但可能同向也可能反向；</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-9-1.png" alt=""></p><p>利用这一性质，可以将一个多边形的顶点按照顺时针或者逆时针方向排序，这就是极角排序。利用 sort 或者 qsort 函数，自己定义 cmp 函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//逆时针极角排序比较函数(double) </span><br><span class="line">bool cmp(const point &amp;a, const point &amp;b) &#123; </span><br><span class="line">double x = atan2(a.y, a.x), y = atan2(b.y, b.x); </span><br><span class="line">return x &lt; y; </span><br><span class="line">&#125; </span><br><span class="line">//象限极角排序比较函数(int)，不失精度 </span><br><span class="line">int cross(point p1,point p2,point p0)&#123; </span><br><span class="line">return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y); </span><br><span class="line">&#125; </span><br><span class="line">sort(p+1,p+n,cmp);</span><br></pre></td></tr></table></figure><h3 id="两向量的位置关系"><a href="#两向量的位置关系" class="headerlink" title="两向量的位置关系"></a>两向量的位置关系</h3><p>把叉积和点积组合在一起，很容易判断两向量的位置关系。如图所示，括号第一个数是点积的符号，第二个是叉积的符号。第一个向量u总是向右，另一个向量w的各种情况都包含在了图中。比如当w的中点在下图左上方的第二象限时点积为负担叉积均为正，用（-，+）表示。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-9-2.png" alt=""></p><h2 id="点和直线"><a href="#点和直线" class="headerlink" title="点和直线"></a>点和直线</h2><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>点到直线的距离是一个常用函数，可以用叉积求出，即用平行四边形的面积除以底。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double DistoLine(point P,point A,point B) //点p到直线AB距离</span><br><span class="line">&#123;</span><br><span class="line">    Vector v1=B-A,v2=P-A;</span><br><span class="line">    return fabs(cross(v1,v2))/Length(v1);//如果不取绝对值，得到的是有向距离</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h3><p>点到线段有两种可能：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E7%82%B9%E5%88%B0%E7%BA%BF%E6%AE%B5%E8%B7%9D%E7%A6%BB.png" alt=""></p><p>简单地说，设投影点为Q，如果Q在线段AB上，则所求距离就是P点直线AB的距离（右）。如果Q在射线BA上，则所求为PA距离；否则为PB距离。判断Q的位置可以用点积进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double DistoSegment(point P,point A,point B)&#123;</span><br><span class="line">    if(A==B) return Length(P-A);</span><br><span class="line">    Vector v1=B-A,v2=P-A,v3=P-B;</span><br><span class="line">    if(dcmp(dot(v1,v2))&lt;0) return Length(v2);</span><br><span class="line">    if(dcmp(dot(v1,v3))&gt;0) return Length(v3);</span><br><span class="line">    return fabs(cross(v1,v2))/Length(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a>判断点是否在线段上</h4><p>判断点 Q 在线段 P1P2 上的两条依据：<br>①(Q-P1)*(P2-P1)=0;<br>②Q 在以 P1,P2 为对角顶点的矩形内。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool onSegment(point p1,point p2,point Q)&#123;</span><br><span class="line">if( (Q.x-p1.x)*(p2.y-p1.y)==(p2.x-p1.x)*(Q.y-p1.y)&amp;&amp;min(p1.x,p2.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(p1.x,p2.x)&amp;&amp;min(p1.y,p2.y)&lt;=Q.y&amp;&amp;Q.y&lt;= max(p1.y,p2.y) )</span><br><span class="line">return 1;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段相交"><a href="#线段相交" class="headerlink" title="线段相交"></a>线段相交</h3><p>最为直观的想法：解析几何法</p><p>弊端：运算误差大，运算次数多</p><p>误差来源：浮点运算</p><p>另外，编程难度事实上也很大（区域判断）</p><p>计算几何做法：运用叉积点积和位置关系</p><h4 id="线段规范相交"><a href="#线段规范相交" class="headerlink" title="线段规范相交"></a>线段规范相交</h4><p>定义线段规范相交为两线段相交恰好有一个公共点且不是任一线段的端点</p><p>充要条件：每条线段的两个端点都在另一条线段的两侧</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E8%A7%84%E8%8C%83%E7%9B%B8%E4%BA%A4%E4%B8%8E%E9%9D%9E%E8%A7%84%E8%8C%83%E7%9B%B8%E4%BA%A4.png" alt=""></p><p>只有（1）是规范相交，其它是非规范相交。非规范相交的情况还有很多。</p><h5 id="跨立实验"><a href="#跨立实验" class="headerlink" title="跨立实验"></a>跨立实验</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C.png" alt=""></p><h5 id="规范相交"><a href="#规范相交" class="headerlink" title="规范相交"></a>规范相交</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool SegmentItersection(point a1, point a2, point b1, point b2)</span><br><span class="line">&#123;</span><br><span class="line">    double c1 = cross(a2-a1, b1-a1), c2 = cross(a2-a1, b2-a1),</span><br><span class="line">    c3 = cross(b2-b1, a1-b1), c4 = cross(b2-b1, a2-b1);</span><br><span class="line">    return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线段相交-1"><a href="#线段相交-1" class="headerlink" title="线段相交"></a>线段相交</h5><p>如果允许在端点处相交怎么办？</p><p>首先可能共线重叠</p><p>其次就是交点是端点</p><p>如果交点是端点</p><p>就判断几次点是否在线段上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断点p是否在线段a1 a2上</span><br><span class="line">bool OnSegment(point p,point a1,point a2)</span><br><span class="line">&#123;</span><br><span class="line">  return dcmp(cross(a1-p,a2-p))==0&amp;&amp;dcmp(dot(a1-p,a2-p))&lt;0; //线段包含端点时改成&lt;=</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形问题"><a href="#多边形问题" class="headerlink" title="多边形问题"></a>多边形问题</h2><h3 id="多边形面积"><a href="#多边形面积" class="headerlink" title="多边形面积"></a>多边形面积</h3><p>两向量的叉积的几何意义是以这两个向量为邻边的平行四边形的有向面积，我们可以利用这一点来求简单多边形的面积。所谓简单多边形就是任何不相邻的两条边都没有交点，包括凸多边形和凹多边形。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%87%B8.png" alt=""><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%87%B9.png" alt=""></p><p>求下面多边形的面积，已知个顶点的坐标。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" alt=""></p><p>注意：在引入叉积后，面积就可以为负值，就有了“负面积”的概念。“负面积”方便了我们的运算。</p><p>可以取p[0]点为划分顶点，一方面可以少算两个叉积（0和任何向量的叉积都等于0），另一方面也减少乘法溢出的可能性，还不用特殊处理（i=n-1时，下一个顶点p[0]而不是p[n]，因为p[n]不存在）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//取p[0]为划分顶点</span><br><span class="line">double PolygonArea(vector&lt;Point&gt; p) &#123;</span><br><span class="line">  int n = p.size();</span><br><span class="line">  double area = 0;</span><br><span class="line">  for(int i = 1; i &lt; n-1; i++)</span><br><span class="line">    area += Cross(p[i]-p[0], p[i+1]-p[0]);</span><br><span class="line">  return area/2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以取坐标原点为划分点，乘法次数减少。</p><h3 id="点在多边形内外判断"><a href="#点在多边形内外判断" class="headerlink" title="点在多边形内外判断"></a>点在多边形内外判断</h3><h4 id="判断点是否在三角形内"><a href="#判断点是否在三角形内" class="headerlink" title="判断点是否在三角形内"></a>判断点是否在三角形内</h4><p>点 P 在三角形 ABC 内部常用的又两种方法，面积法和叉积法，面积法即为 </p><p>S△PAB+S△PAC+S△PBC=S△ABC </p><p>其中三角形面积计算公式为 S=1/2×|cross(a,b)| </p><p>叉积法 </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E7%82%B9%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt=""></p><p>利用叉积的正负号判断，如图所示，AP 在向量 AC 的顺时针方向，CP 在向量 BC 的顺时针方向，BP 在向量 BC 的顺时针方向，利用这一性质推广，那么可以利用叉积的正负号来判断一个点是否在一个凸多边形内部。</p><h4 id="判断点是否在多边形内"><a href="#判断点是否在多边形内" class="headerlink" title="判断点是否在多边形内"></a>判断点是否在多边形内</h4><p>一般而言，该问题有射线法和转角法两种处理手段</p><p>射线法：从这个点出发引向无穷远点一条直线，根据交点情况确定点的位置</p><p>转角法：计算多边形每条边的转角，若最后相消为0则在外部，否则在内部</p><p>射线法：特殊情况不易处理</p><p>转角法：三角运算时间开销大</p><h5 id="射线法"><a href="#射线法" class="headerlink" title="射线法"></a>射线法</h5><p>以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。</p><p>若有偶数个交点则在形外，否则在形内。</p><p>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p><h5 id="转角法"><a href="#转角法" class="headerlink" title="转角法"></a>转角法</h5><p>把多边形每条边的转角加起来，如果是360度，就在多边形内，如果是0度就在外面，180度则是在边界上</p><p>直接最要求角度用到反三角函数精度差且费时</p><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>假设有一条向右的射线，统计多边形穿过这条射线正反多少次，把这个数记为绕数wn，逆时针穿过时，wn加1，顺时针穿过时，wn减1。</p><p>注意在程序实现时，判断是否穿过，以及穿过方向时，需要用叉积判断输入点在左边还是右边。</p><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int isPointinPolygon(point p,vector&lt;point&gt;poly)</span><br><span class="line">&#123;</span><br><span class="line">    int wn=0;</span><br><span class="line">    int n=poly.size();</span><br><span class="line">    for (int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (OnSegment(p,poly[i],poly[(i+1)%n])) return -1;    //边界</span><br><span class="line">        int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));</span><br><span class="line">        int d1=dcmp(poly[i].y-p.y);</span><br><span class="line">        int d2=dcmp(poly[(i+1)%n].y - p.y);</span><br><span class="line">        if (k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++;</span><br><span class="line">        if (k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (wn!=0) return 1;  //内部</span><br><span class="line">    return 0;   //外部</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点在凸多边形内的判定更简单，只需判断是否在所有边的左边（假设各个顶点按照逆时针顺序排列）</p><h3 id="多边形重心"><a href="#多边形重心" class="headerlink" title="多边形重心"></a>多边形重心</h3><h4 id="三角形重心"><a href="#三角形重心" class="headerlink" title="三角形重心"></a>三角形重心</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83.png" alt=""></p><h4 id="多边形重心-1"><a href="#多边形重心-1" class="headerlink" title="多边形重心"></a>多边形重心</h4><p>将多边形拆分为N个三角形，分别求其重心和面积，可以想象，原来的质量均匀分布在内部的区域上，而现在质量仅分布在这N个重心点上（等价变换），这时就可以利用刚才猜想的公式了。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%87%8D%E5%BF%83.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">point PolyGravity(point *p,int n)</span><br><span class="line">&#123;</span><br><span class="line">    point ans=point(0,0);</span><br><span class="line">    double sumArea=0,area;</span><br><span class="line">    for(int i=2;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        area=cross(p[i-1]-p[0],p[i]-p[0]);</span><br><span class="line">        sumArea+=area;</span><br><span class="line">        ans.x+=(p[0].x+p[i-1].x+p[i].x)*area;</span><br><span class="line">        ans.y+=(p[0].y+p[i-1].y+p[i].y)*area;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans/(sumArea*3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析几何"><a href="#解析几何" class="headerlink" title="解析几何"></a>解析几何</h2><p>交点的计算：求两线段，两直线，线段和直线的交点<br>①判断两线段是否相交：<br>我们分两步确定两条线段是否相交：<br>(1)快速排斥试验<br>设以线段 P1P2 为对角线的矩形为 R， 设以线段 Q1Q2 为对角线的矩形为 T，如果R和T不相交，显然两线段不会相交。<br>(2)跨立试验<br>如果两线段相交，则两线段必然相互跨立对方。若 P1P2 跨立 Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，即 ( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( P2 - Q1 ) × ( Q2 - Q1 ) &lt; 0。<br>上式可改写成 ( P1 - Q1 ) × ( Q2 - Q1 ) </em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt; 0。<br>当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2 上；同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2 上。所以判断 P1P2 跨立 Q1Q2 的依据是： </p><p>( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。<br>同理判断 Q1Q2 跨立 P1P2 的依据是：<br>( Q1 - P1 ) × ( P2 - P1 ) </em> ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%AE%9E%E9%AA%8C.png" alt=""></p><p>另外，“规范相交”指的是两条线段恰有唯一一个不是端点的公共点；而如果一条线段的一个端点在另一条线段上，或者两条线段部分重合，则视为“非规范相交”，以下代码是“非规范相交”。 </p><p>结合 poj2653 练习，代码可参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const double eps = 1e-10;</span><br><span class="line">struct point &#123; double x, y; &#125;;</span><br><span class="line">struct Line &#123; point begin, end; &#125;line[100001];</span><br><span class="line">double min(double a, double b) &#123; return a&lt;b ? a : b; &#125;</span><br><span class="line">double max(double a, double b) &#123; return a&gt;b ? a : b; &#125;</span><br><span class="line">bool inter(const Line &amp; M, const Line &amp; N) &#123;</span><br><span class="line">point a = M.begin; point b = M.end;</span><br><span class="line">point c = N.begin; point d = N.end;</span><br><span class="line">if (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y)&gt;max(c.y, d.y) || min(c.x, d.x)&gt;max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y)) return 0;</span><br><span class="line">double h, i, j, k;</span><br><span class="line">h = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);</span><br><span class="line">i = (b.x - a.x)*(d.y - a.y) - (b.y - a.y)*(d.x - a.x);</span><br><span class="line">j = (d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x);</span><br><span class="line">k = (d.x - c.x)*(b.y - c.y) - (d.y - c.y)*(b.x - c.x);</span><br><span class="line">return h*i &lt;= eps&amp;&amp;j*k &lt;= eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②判断两直线是否相交：<br>首先判断两条直线是否在一条直线上，或者两条直线平行，否则一定相交，不平行且不在一条直线上则相交并且求出交点。<br>可结合 hrbustoj1104 练习，代码可参考： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">double x1, x2, x3, x4, y1, y2, y3, y4, x, y;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x3, &amp;y3, &amp;x4, &amp;y4);</span><br><span class="line">if ((x2 - x1)*(y4 - y3) == (x4 - x3)*(y2 - y1)) &#123;</span><br><span class="line">if ((x3 - x1)*(y4 - y2) == (x4 - x2)*(y3 - y1) &amp;&amp; (y4 - y3) != 0)</span><br><span class="line">puts(&quot;LINE&quot;);//在一条直线的情况 </span><br><span class="line">else</span><br><span class="line">puts(&quot;NONE&quot;);//平行的情况 </span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">x = ((y1*(x2 - x1) - x1*(y2 - y1))*(x4 - x3) - (y3*(x4 - x3) - x3*(y4 -</span><br><span class="line">y3))*(x2 - x1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3));</span><br><span class="line">y = ((y1*(x2 - x1) - x1*(y2 - y1))*(y4 - y3) - (y3*(x4 - x3) - x3*(y4 -</span><br><span class="line">y3))*(y2 - y1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3));</span><br><span class="line">printf(&quot;POINT %.2f %.2f\n&quot;, x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③判断线段和直线的交点：<br>poj1039 判断直线和线段是否相交并求出交点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#define eps 1.0e-8 </span><br><span class="line">struct Point &#123;</span><br><span class="line">double x, y;</span><br><span class="line">&#125; point[25];</span><br><span class="line">int n;</span><br><span class="line">double ans;</span><br><span class="line">bool ok;</span><br><span class="line">double intersect(Point a1, Point b1, Point a2, Point b2) &#123;</span><br><span class="line">double x1 = a1.x, x2 = b1.x, x3 = a2.x, x4 = b2.x;</span><br><span class="line">double y1 = a1.y, y2 = b1.y, y3 = a2.y, y4 = b2.y;</span><br><span class="line">double x = (y3 - y1 + x1*(y2 - y1) / (x2 - x1) - x3*(y4 - y3) / (x4 - x3)) / ((y2 -</span><br><span class="line">y1) / (x2 - x1) - (y4 - y3) / (x4 - x3));</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">void work(Point a, Point b) &#123;</span><br><span class="line">b.y -= 1;</span><br><span class="line">for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">Point p, q1, q2;</span><br><span class="line">p.x = point[i].x;</span><br><span class="line">p.y = a.y - (b.y - a.y) / (b.x - a.x)*(a.x - p.x);</span><br><span class="line">if ((p.y + eps&lt;point[i].y&amp;&amp;p.y - eps&gt;point[i].y - 1) ||</span><br><span class="line">abs(p.y - point[i].y)&lt;eps || abs(p.y - point[i].y + 1)&lt;eps)</span><br><span class="line">continue;</span><br><span class="line">if (i == 0) return;</span><br><span class="line">if (p.y - eps&gt;point[i].y)</span><br><span class="line">ans = max(ans, intersect(a, b, point[i - 1], point[i]));</span><br><span class="line">else &#123;</span><br><span class="line">q1 = point[i - 1];</span><br><span class="line">q1.y -= 1;</span><br><span class="line">q2 = point[i];</span><br><span class="line">q2.y -= 1;</span><br><span class="line">ans = max(ans, intersect(a, b, q1, q2));</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">ok = true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n), n) &#123;</span><br><span class="line">for (int i = 0; i&lt;n; i++)</span><br><span class="line">scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">ans = point[0].x;</span><br><span class="line">ok = false;</span><br><span class="line">for (int i = 0; i&lt;n; i++)</span><br><span class="line">for (int j = 0; j&lt;n; j++)</span><br><span class="line">if (i != j&amp;&amp;!ok)</span><br><span class="line">work(point[i], point[j]);</span><br><span class="line">if (ok)</span><br><span class="line">printf(&quot;Through all the pipe.\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%.2f\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三寸青笺，写不尽对你的思念。——随笔&lt;/p&gt;
&lt;p&gt;用解析几何借助计算机处理几何问题存在着两大缺陷：&lt;/p&gt;
&lt;p&gt;1）方程解的情况复杂，例如Ax+By+C=0；&lt;/p&gt;
&lt;p&gt;2）存在着浮点误差积累。&lt;/p&gt;
&lt;p&gt;计算几何采用了介于代数与几何之间的方式解决几何问题。它利
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="计算几何" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="计算几何" scheme="http://qianyouyou.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="点积/叉积" scheme="http://qianyouyou.cn/tags/%E7%82%B9%E7%A7%AF-%E5%8F%89%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[博弈论]博弈论基本题型及5大常见博弈论原理</title>
    <link href="http://qianyouyou.cn/2018/05/08/2018-05-08/"/>
    <id>http://qianyouyou.cn/2018/05/08/2018-05-08/</id>
    <published>2018-05-08T14:20:44.000Z</published>
    <updated>2018-05-08T16:17:14.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><h3 id="巴什博奕（Bash-Game）"><a href="#巴什博奕（Bash-Game）" class="headerlink" title="巴什博奕（Bash Game）"></a>巴什博奕（Bash Game）</h3><p>有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。</p><p>假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。</p><p>胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int iCase;</span><br><span class="line">cin &gt;&gt; iCase;</span><br><span class="line">while (iCase--) &#123;</span><br><span class="line">int n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="威佐夫博奕（Wythoff-Game）"><a href="#威佐夫博奕（Wythoff-Game）" class="headerlink" title="威佐夫博奕（Wythoff Game）"></a>威佐夫博奕（Wythoff Game）</h3><p>有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p><p>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 </p><p> 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质：</p><p>1。任何自然数都包含在一个且仅有一个奇异局势中。</p><p>2。任意操作都可将奇异局势变为非奇异局势。</p><p>3。采用适当的方法，可以将非奇异局势变为奇异局势。</p><p>两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。</p><p>如何判定是否是奇异局势呢？</p><p>有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) </p><p>其中（1+√5）/2 = 1.618…,即为黄金分割数。因此,由 ak，bk 组成的矩形近似为黄金矩形，由于 2/（1+√5）=（√5-1）/2，可以先求出 j=[a（√5-1）/2]，若a=[ j（1+√5）/2]，那么 a = aj，bj = aj + j，若不等于，那么 a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;math.h&gt; </span><br><span class="line">const double ep1 = (sqrt(5.0) - 1.0) / 2.0;</span><br><span class="line">const double ep2 = (sqrt(5.0) + 1.0) / 2.0;</span><br><span class="line">int main() &#123;</span><br><span class="line">int m, n;</span><br><span class="line">while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123;</span><br><span class="line">if (m &gt; n) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">tmp = m, m = n, n = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int id = m * ep1;</span><br><span class="line">int tmp1 = ep2 * id, tmp2 = id + tmp1;</span><br><span class="line">int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3;</span><br><span class="line">if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;);</span><br><span class="line">else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;);</span><br><span class="line">else printf(&quot;1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契博弈（Fibonacci-Nim）"><a href="#斐波那契博弈（Fibonacci-Nim）" class="headerlink" title="斐波那契博弈（Fibonacci Nim）"></a>斐波那契博弈（Fibonacci Nim）</h3><p>有一堆个数为 n 的石子，游戏双方轮流取石子，满足</p><p>1)先手不能在第一次把所有的石子取完； </p><p>2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。</p><p>约定取走最后一个石子的人为赢家，求必败态。</p><p>这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 </p><p>胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 </p><p>证明：</p><p>这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 </p><p> FIB 数列的必败证明：</p><p>1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 </p><p>2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">long long int f[50];</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, i;</span><br><span class="line">f[0] = f[1] = 1;</span><br><span class="line">for (i = 2; i &lt; 50; i++) &#123;</span><br><span class="line">f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">if (n == 0) break;</span><br><span class="line">for (i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">if (f[i] == n) break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K倍博弈"><a href="#K倍博弈" class="headerlink" title="K倍博弈"></a>K倍博弈</h3><p>共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。</p><p>当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1，然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 </p><p>当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。</p><p>当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。</p><p>设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2000000;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k;</span><br><span class="line">int cas = 0, cass;</span><br><span class="line">for (scanf(&quot;%d&quot;, &amp;cass); cass--;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">++cas;</span><br><span class="line">printf(&quot;Case %d: &quot;, cas);</span><br><span class="line">int i = 0, j = 0;</span><br><span class="line">a[0] = b[0] = 1;</span><br><span class="line">while (a[i]&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">a[i] = b[i - 1] + 1;</span><br><span class="line">while (a[j + 1] * k&lt;a[i])</span><br><span class="line">j++;</span><br><span class="line">if (a[j] * k&lt;a[i])</span><br><span class="line">b[i] = a[i] + b[j];</span><br><span class="line">else</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">if (a[i] == n)</span><br><span class="line">puts(&quot;lose&quot;);</span><br><span class="line">else puts(&quot;win&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SG函数的求解-SG博弈）"><a href="#SG函数的求解-SG博弈）" class="headerlink" title="ＳＧ函数的求解(SG博弈）"></a>ＳＧ函数的求解(SG博弈）</h3><p>给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。</p><p>这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。</p><p>首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 </p><p>对于一个给定的有向无环图，定义关于图的每个顶点的 Sprague-Grundy 函数 g如下：g(x)=mex{ g(y) | y 是 x 的后继 }。</p><p>SG 函数的性质。首先，所有的 terminal position 所对应的顶点，也就是没有出边的顶点，其 SG 值为 0，因为它的后继集合是空集。然后对于一个 g(x)=0 的顶点 x，它的所有后继 y 都满足 g(y)!=0。对于一个 g(x)!=0 的顶点，必定存在一个后继 y 满足 g(y)=0。 </p><p>以上这三句话表明，顶点 x 所代表的 postion 是 P-position 当且仅当 g(x)=0。我们通过计算有向无环图的每个顶点的 SG 值，就可以对每种局面找到必胜策略了。</p><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>假设不是一枚棋子，而是n枚棋子，如何获胜</p><p>让我们再来考虑一下顶点的 SG 值的意义。当 g(x)=k 时，表明对于任意一个0&lt;=i&lt;k，都存在 x 的一个后继 y 满足 g(y)=i。也 就是说，当某枚棋子的 SG 值是 k 时，我们可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k 不变。</p><p> Nim 游戏的规则就是：每次选择 一堆数量为 k 的石子，可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k不变。这表明，如果将 n 枚棋子所在的顶 点的 SG 值看作 n 堆相应数量的石子，那么这个 Nim 游戏的每个必胜策略都对应于原来这 n 枚棋子的必胜策略！</p><p>对于 n 个棋子，设它们对应的顶点的 SG 值分别为(a1,a2,…,an)，再设局面(a1,a2,…,an)时的 Nim 游戏的一种必胜策略是把 ai 变成 k，那么原游戏的一种必胜策略就是把第 i 枚棋子移动到一个 SG 值为 k 的顶点。</p><p>其实我们还是只要证明这种多棋子的有向图游戏的局面是 P-position 当且仅当所有棋子所在的位置的 SG 函数的异或为 0。这个证明与上节的 Bouton’s Theorem 几乎是完全相同的，只需要适当的改几个名词就行了。</p><p>SG 函数与“游戏的和”的概念不是让我们去组合、制造稀奇古怪的游戏，而是把遇到的看上去有些复杂的游戏试图分成若干个子游戏，对于每个比原游戏简化很多的子游戏找出它的 SG 函数，然后全部异或起来就得到了原游戏的 SG 函数，就可以解决原游戏了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int iCase;</span><br><span class="line">cin &gt;&gt; iCase;</span><br><span class="line">while (iCase--) &#123;</span><br><span class="line">int n, cnt = 0, num;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">if (num % 4 == 0) num--;</span><br><span class="line">else if (num % 4 == 3) num++;</span><br><span class="line">cnt ^= num;</span><br><span class="line">&#125;</span><br><span class="line">if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找必败态"><a href="#寻找必败态" class="headerlink" title="寻找必败态"></a>寻找必败态</h2><p>必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。</p><p>必败态和胜态有着如下性质： </p><p>1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 </p><p>2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 </p><p>3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 </p><p>这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;取石子游戏&quot;&gt;&lt;a href=&quot;#取石子游戏&quot; class=&quot;headerlink&quot; title=&quot;取石子游戏&quot;&gt;&lt;/a&gt;取石子游戏&lt;/h2&gt;&lt;h3 id=&quot;巴什博奕（Bash-Game）&quot;&gt;&lt;a href=&quot;#巴什博奕（Bash-Game）&quot; class=&quot;he
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[数论]数论与组合数学中的常用算法总结</title>
    <link href="http://qianyouyou.cn/2018/05/07/2018-05-07/"/>
    <id>http://qianyouyou.cn/2018/05/07/2018-05-07/</id>
    <published>2018-05-07T10:08:16.000Z</published>
    <updated>2018-05-08T14:15:54.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="欧几里得算法（gcd）"><a href="#欧几里得算法（gcd）" class="headerlink" title="欧几里得算法（gcd）"></a>欧几里得算法（gcd）</h3><p>欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b)</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b)</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">return b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">//非递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">if (!a)</span><br><span class="line">return b;</span><br><span class="line">while (b) &#123;</span><br><span class="line">int temp = b;</span><br><span class="line">b = a%b;</span><br><span class="line">a = temp;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h3><p>若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb<br>对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1<em>a+0</em>b,因为 gcd(a,b)=gcd(b,a%b)则有 x<em>a+y</em>b=x1<em>b+y1</em>(a%b) 。将等式右边变形，b<em>x1+(a%b)</em>y1=b<em>x1+(a-(a/b)</em>b)<em>y1=a</em>y1+b<em>(x1-(a/b)</em>y1)<br>则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)<em>t,y-y0-a/gcd(a,b)</em>t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int exgcd(int a, int b, int &amp;x, int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">if (b == 0)</span><br><span class="line">&#123;</span><br><span class="line">x = 1;</span><br><span class="line">y = 0;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int d = exgcd(b, a%b, x, y);</span><br><span class="line">int t = x;</span><br><span class="line">x = y;</span><br><span class="line">y = t - a / b*y;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><p>筛素数的基本方法是用来筛选出一定范围内的素数</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool isprime[N];//N 表示范围</span><br><span class="line">int prime[N], cnt;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">cnt = 0;</span><br><span class="line">memset(isprime, true, sizeof(isprime));</span><br><span class="line">isprime[1] = false;</span><br><span class="line">for (i = 2; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (isprime[i])</span><br><span class="line">&#123;</span><br><span class="line">prime[cnt++] = i;//记录素数</span><br><span class="line">for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了</span><br><span class="line">isprime[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0<em>a2^1</em>a2^3，也就是a1 <em> a2 </em> a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int poww(int a, int b) &#123;</span><br><span class="line">    int ans = 1, base = a;</span><br><span class="line">    while (b != 0) &#123;</span><br><span class="line">        if (b &amp; 1 != 0)</span><br><span class="line">            ans *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)<em>a^(2^1)</em>a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。</p><p>　　其中要理解base <em> =base这一步：因为 base </em> base==base2，下一步再乘，就是base2 <em> base2==base4，然后同理  base4 </em> base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1<em>a2</em>a8，这三项就可以完美解决了</p><h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p><strong>矩阵乘法</strong></p><p>简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C</p><p><strong><img src="http://p7woygi8q.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="img"></strong></p><p>其中c[i][j]为A的第i行与B的第j列对应乘积的和，即:<img src="http://p7woygi8q.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int N=100;  </span><br><span class="line">int c[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(c,0,sizeof c);  </span><br><span class="line">    for(int i=1;i&lt;=n;i++)  </span><br><span class="line">        for(int j=1;j&lt;=n;j++)  </span><br><span class="line">        for(int k=1;k&lt;=n;k++)  </span><br><span class="line">        c[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放一个求斐波那契数列的矩阵快速幂模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 10000;</span><br><span class="line">const int maxn = 35;</span><br><span class="line">int N;</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    int mat[maxn][maxn];</span><br><span class="line">    int x, y;</span><br><span class="line">    Matrix() &#123;</span><br><span class="line">        memset(mat, 0, sizeof(mat));</span><br><span class="line">        for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123;</span><br><span class="line">    memset(c.mat, 0, sizeof(c.mat));</span><br><span class="line">    c.x = a.x; c.y = b.y;</span><br><span class="line">    for (int i = 1; i &lt;= c.x; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= c.y; j++) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= a.y; k++) &#123;</span><br><span class="line">                c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod;</span><br><span class="line">                c.mat[i][j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">inline void mat_pow(Matrix &amp;a, int z) &#123;</span><br><span class="line">    Matrix ans, base = a;</span><br><span class="line">    ans.x = a.x; ans.y = a.y;</span><br><span class="line">    while (z) &#123;</span><br><span class="line">        if (z &amp; 1 == 1) mat_mul(ans, base, ans);</span><br><span class="line">        mat_mul(base, base, base);</span><br><span class="line">        z &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    a = ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        switch (N) &#123;</span><br><span class="line">            case -1: return 0;</span><br><span class="line">            case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Matrix A, B;</span><br><span class="line">        A.x = 2; A.y = 2;</span><br><span class="line">        A.mat[1][1] = 1; A.mat[1][2] = 1;</span><br><span class="line">        A.mat[2][1] = 1; A.mat[2][2] = 0;</span><br><span class="line">        B.x = 2; B.y = 1;</span><br><span class="line">        B.mat[1][1] = 1; B.mat[2][1] = 1;</span><br><span class="line">        mat_pow(A, N - 1);</span><br><span class="line">        mat_mul(A, B, B);</span><br><span class="line">        cout &lt;&lt; B.mat[1][1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。</p><p>设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n <em> sum(1-1/pi)/</em>pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><h4 id="基本的模运算"><a href="#基本的模运算" class="headerlink" title="基本的模运算"></a>基本的模运算</h4><p>(a + b)mod n=((a mod n) + (b mod n))mod n;</p><p>(a - b)mod n=((a mod n) - (b mod n))mod n;</p><p>(a <em> b)mod n=((a mod n) </em> (b mod n))mod n;</p><h3 id="数论4大定理"><a href="#数论4大定理" class="headerlink" title="数论4大定理"></a>数论4大定理</h3><h4 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h4><p>若p为质数，则p可整除(p-1)!+1。</p><h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)</p><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。</p><p>于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n），</p><p>所以a^φ(n) ≡ 1 (mod n)。</p><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。</p><p>若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。</p><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a><strong>证明</strong></h5><p>因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。</p><h4 id="孙子定理（中国剩余定理）"><a href="#孙子定理（中国剩余定理）" class="headerlink" title="孙子定理（中国剩余定理）"></a>孙子定理（中国剩余定理）</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt=""></p><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。</p><p>要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。</p><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><h4 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h4><p>加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。</p><p>分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏）</p><h4 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h4><p>乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。</p><p>合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 </p><p>组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) </p><p>其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。</p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|<br>这个定理，常称作包含排斥原理，也就是容斥原理。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86.png" alt=""></p><p>对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数论&quot;&gt;&lt;a href=&quot;#数论&quot; class=&quot;headerlink&quot; title=&quot;数论&quot;&gt;&lt;/a&gt;数论&lt;/h2&gt;&lt;h3 id=&quot;欧几里得算法（gcd）&quot;&gt;&lt;a href=&quot;#欧几里得算法（gcd）&quot; class=&quot;headerlink&quot; title=&quot;欧几里
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高斯消元" scheme="http://qianyouyou.cn/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>[图论]最短路三大算法——Dijkstra算法，Bellman-ford，floyed</title>
    <link href="http://qianyouyou.cn/2018/05/06/2018-05-06-1/"/>
    <id>http://qianyouyou.cn/2018/05/06/2018-05-06-1/</id>
    <published>2018-05-06T14:35:34.000Z</published>
    <updated>2018-05-07T10:10:35.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法（单源最短路径）"><a href="#Dijkstra算法（单源最短路径）" class="headerlink" title="Dijkstra算法（单源最短路径）"></a>Dijkstra算法（单源最短路径）</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。</li><li>从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。</li><li>重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">const int maxn=1200;</span><br><span class="line"></span><br><span class="line">int dist[maxn],g[maxn][maxn],N;</span><br><span class="line">bool vis[maxn];</span><br><span class="line"></span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        dist[i]=(i==1)?0:INF;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mark=-1,mindis=INF;</span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[j]&amp;&amp;dist[j]&lt;mindis)</span><br><span class="line">            &#123;</span><br><span class="line">                mindis=dist[j];</span><br><span class="line">                mark=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[mark]=1;</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=min(dist[j],dist[mark]+g[mark][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-ford（单元最短路径，可带负环）"><a href="#Bellman-ford（单元最短路径，可带负环）" class="headerlink" title="Bellman-ford（单元最短路径，可带负环）"></a>Bellman-ford（单元最短路径，可带负环）</h2><p>为了能够求解边上带有负值的单源最短路径问题，Bellman(贝尔曼，动态规划提出者)和Ford(福特)提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度的方法。Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellman-ford算法有一个小优化：每次松弛先设一个flag，初值为FALSE，若有边更新则赋值为TRUE，最终如果还是FALSE则直接成功退出。Bellman-ford算法浪费了许多时间做无必要的松弛，所以SPFA算法用队列进行了优化，效果十分显著，高效难以想象。SPFA还有SLF，LLL，滚动数组等优化。</p><p>递推公式(求顶点u到源点v的最短路径)：<br>$$<br>dist 1 [u] = Edge[v][u]<br>$$</p><p>$$<br>dist k [u] = min{ dist k-1 [u], min{ dist k-1 [j] + Edge[j][u] } }, j=0,1,…,n-1,j≠u<br>$$</p><p>Dijkstra算法和Bellman算法思想有很大的区别：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改  的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>单源最短路径(从源点s到其它所有顶点v)</li><li>有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图)</li><li>边权可正可负(如有负权回路输出错误提示)</li><li>差分约束系统(至今貌似只看过一道题)</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ol><li>初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0</li><li>迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次，看下面的描述性证明(当做树)）</li><li>检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在d[v]中</li></ol><p>Bellman-Ford算法是否一定要循环n-1次么？未必！其实只要在某次循环过程中，考虑每条边后，都没能改变当前源点到所有顶点的最短路径长度，那么Bellman-Ford算法就可以提前结束了(开篇提出的小优化就是这个)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bool Bellman_Ford()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= nodenum; ++i) //初始化</span><br><span class="line"></span><br><span class="line">    dis[i] = (i == original ? 0 : MAX);</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= nodenum - 1; ++i)</span><br><span class="line"></span><br><span class="line">    for(int j = 1; j &lt;= edgenum; ++j)</span><br><span class="line"></span><br><span class="line">      if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost) //松弛（顺序一定不能反~）</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;</span><br><span class="line"></span><br><span class="line">        pre[edge[j].v] = edge[j].u;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bool flag = 1; //判断是否含有负权回路</span><br><span class="line"></span><br><span class="line">      for(int i = 1; i &lt;= edgenum; ++i)</span><br><span class="line"></span><br><span class="line">        if(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          flag = 0;</span><br><span class="line"></span><br><span class="line">          break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyed（全源最短路径）"><a href="#floyed（全源最短路径）" class="headerlink" title="floyed（全源最短路径）"></a>floyed（全源最短路径）</h2><p>Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int k=0; k&lt;n; ++k)</span><br><span class="line">  for (int i=0; i&lt;n; ++i)</span><br><span class="line">    for (int j=0; j&lt;n; ++j)</span><br><span class="line">            /*</span><br><span class="line">            实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j]</span><br><span class="line">            都不是Inf ，只要一个是Inf，那么就肯定不必更新。 </span><br><span class="line">            */</span><br><span class="line">      if (dist[i][k] + dist[k][j] &lt; dist[i][j] )</span><br><span class="line">        dist[i][j] = dist[i][k] + dist[k][j];</span><br></pre></td></tr></table></figure><p>Floyd算法另一种理解DP，为理论爱好者准备的，上面这个形式的算法其实是Floyd算法的精简版，而真正的Floyd算法是一种基于DP(Dynamic Programming)的最短路径算法。设图G中n 个顶点的编号为1到n。令c [i, j, k]表示从i 到j 的最短路径的长度，其中k 表示该路径中的最大顶点，也就是说c[i,j,k]这条最短路径所通过的中间顶点最大不超过k。因此，如果G中包含边&lt;i, j&gt;，则c[i, j, 0] =边&lt;i, j&gt; 的长度；若i= j ，则c[i,j,0]=0；如果G中不包含边&lt;i, j&gt;，则c (i, j, 0)= +∞。c[i, j, n] 则是从i 到j 的最短路径的长度。对于任意的k&gt;0，通过分析可以得到：中间顶点不超过k 的i 到j 的最短路径有两种可能：该路径含或不含中间顶点k。若不含，则该路径长度应为c[i, j, k-1]，否则长度为 c[i, k, k-1] +c [k, j, k-1]。c[i, j, k]可取两者中的最小值。状态转移方程：c[i, j, k]=min{c[i, j, k-1], c [i, k, k-1]+c [k, j, k-1]}，k＞0。这样，问题便具有了最优子结构性质，可以用动态规划方法来求解。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/U%29M71YPUFV4WE17DG%5B%28X$$K.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dijkstra算法（单源最短路径）&quot;&gt;&lt;a href=&quot;#Dijkstra算法（单源最短路径）&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra算法（单源最短路径）&quot;&gt;&lt;/a&gt;Dijkstra算法（单源最短路径）&lt;/h2&gt;&lt;h3 id=&quot;步
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Dijkstra算法" scheme="http://qianyouyou.cn/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[图论]二分图匹配基本算法之KM算法解析</title>
    <link href="http://qianyouyou.cn/2018/05/06/2018-05-06/"/>
    <id>http://qianyouyou.cn/2018/05/06/2018-05-06/</id>
    <published>2018-05-06T12:57:15.000Z</published>
    <updated>2018-05-07T10:10:19.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最佳匹配"><a href="#最佳匹配" class="headerlink" title="最佳匹配"></a>最佳匹配</h2><p>如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。</p><p>如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，或者Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。</p><p><strong>带权</strong>二分图的<strong>权值最大</strong>的<strong>完备匹配</strong>称为最佳匹配。二分图的最佳匹配不一定是二分图的最大权匹配。 可以添加一些权值为0的边，使得最佳匹配和最大权匹配统一起来。 如图所示：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/a.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/b.png" alt=""></p><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。</p><p>1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。</p><p>2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。</p><p>3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。</p><h3 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h3><p>因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。</p><h3 id="相等子图性质"><a href="#相等子图性质" class="headerlink" title="相等子图性质"></a>相等子图性质</h3><ol><li>在任意时刻，相等子图上的最大权匹配一定小于等于相等子图的顶标和。</li><li>在任意时刻，相等子图的顶标和即为所有顶点的顶标和。</li><li>扩充相等子图后，相等子图的顶标和将会减小。</li><li>当相等子图的最大匹配为原图的完备匹配时，匹配边的权值和等于所有顶点的顶标和，此匹配即为最佳匹配。</li></ol><h3 id="演示过程"><a href="#演示过程" class="headerlink" title="演示过程"></a>演示过程</h3><p>1.如图所示，1与a匹配权值为3，与c为4。2与a权值为2，与b权值为1，与c权值为3。3与c权值为5。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/1.png" alt=""></p><p>2.首先对每个顶点赋值，将左边的顶点赋值为<strong>最大权重</strong>，右边的顶点赋值为0。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2.png" alt=""></p><p>3.进行匹配，我们匹配的原则是：只与权重相同的边匹配，若是找不到边匹配，对此条路径的所有左边顶点-1，右边顶点+1，再进行匹配，若还是匹配不到，重复+1和-1操作。对1进行匹配，符合匹配条件的边只有1-c边。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/3.png" alt=""></p><p>4.接着对2匹配，顶点2值为3，2-c边权重为3，但是，1已经匹配c了，发生了冲突，我们这时候第一时间应该想到的是，让2换个工作，但根据匹配原则，只有2-c边 3+0=0 满足要求，于是2不能换边了，那1能不能换边呢？对1来说，也是只有1-c边满足4+0=4的要求，于是1也不能换边，走投无路了，怎么办？</p><p><img src="http://p7woygi8q.bkt.clouddn.com/4.png" alt=""></p><p>5.从常识的角度思考：其实我们寻找<strong>最优匹配</strong>的过程，也就是<strong>帮每个X顶点找到他们权值最高的Y顶点</strong>，但是，有些顶点会冲突，比如现在，1，2和c的权值都是最高，这时我们应该让1或者3换顶点，但是这时候换的话我们只能换到降低权值的Y顶点，也就是说，如果令R=左边顶点所有值相加，若发生了冲突，则最终权值一定小于R，但是，我们现在只要求最优匹配，所以，如果1换顶点降低的权值比较少的话，<strong>我们是能接受的</strong>（对2同样如此）。</p><p>在KM算法中如何体现呢？</p><p>现在参与到这个冲突的顶点是1,2和c，令所有左边顶点值-1，右边顶点值+1，即 1-1,2-1. c+1。</p><p>我们进行了上述操作后会发现，若是左边有n个顶点参与运算，则右边就有n-1个顶点参与运算，整体效率值下降了1*（n-（n-1））=1，而对于1来说，1-c本来为可匹配的边，现在仍为可匹配边（3+1=4），对于2来说，2-c本来为可匹配的边，现在仍为可匹配的边（2+1=4），我们通过上述操作，为1增加了一条可匹配的边1-a，为B增加了一条可匹配的边2-a。</p><p>现在我们再来匹配，对2来说，2-a边 2+0=2，满足条件，所以2换边，a现在为未匹配状态，2-a匹配！</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5.png" alt=""></p><p>6.我们现在匹配最后一条边3，3-c 5+1！=5，3边无边能匹配，所以3-1。现在3-c边 4+1=5，可以匹配，但是c已匹配了，发生冲突，3此时不能换边，于是便去找1，对于1来说，1-a此时也为可匹配边，但是a已匹配，1又去找2。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/6.png" alt=""></p><p>7.2现在无边可以匹配了，2+0！=1 ，现在的路径是3→c→1→a→2，所以1-1,2-1,3-1,a+1，c+1。如下图所示。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/7.png" alt=""></p><p>8.对于2来说，现在2-b 1+0=1 可匹配！使用匈牙利算法，对此条路径上的边取反。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/8.png" alt=""></p><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int s) //匈牙利算法找增广路径</span><br><span class="line">&#123;</span><br><span class="line">    visx[s]=1;</span><br><span class="line">    for(int i=1;i&lt;=cnty;i++) </span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t=wx[s]+wy[i]-dis[s][i];</span><br><span class="line">            if(t==0) &#123;</span><br><span class="line">                visy[i]=1;</span><br><span class="line">                if(linky[i]==0||dfs(linky[i]))&#123;</span><br><span class="line">                    linkx[s]=i,linky[i]=s;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t&gt;0)  //找出边权与顶标和的最小的差值</span><br><span class="line">            &#123;</span><br><span class="line">                if(t&lt;minz)minz=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void km()</span><br><span class="line">&#123;</span><br><span class="line">    memset(linkx,0,sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(linky,0,sizeof linky);</span><br><span class="line">    for(int i=1;i&lt;=cntx;i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minz=INF;</span><br><span class="line">            memset(visx,0,sizeof visx);</span><br><span class="line">            memset(visy,0,sizeof visy);</span><br><span class="line">            if(dfs(i))break;</span><br><span class="line">            for(int j=1;j&lt;=cntx;j++)  //将交错树中X部的点的顶标减去minz</span><br><span class="line">            if(visx[j])wx[j]-=minz;</span><br><span class="line">            for(int j=1;j&lt;=cnty;j++) //将交错树中Y部的点的顶标加上minz</span><br><span class="line">            if(visy[j])wy[j]+=minz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最佳匹配&quot;&gt;&lt;a href=&quot;#最佳匹配&quot; class=&quot;headerlink&quot; title=&quot;最佳匹配&quot;&gt;&lt;/a&gt;最佳匹配&lt;/h2&gt;&lt;p&gt;如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。&lt;/p&gt;
&lt;p&gt;如果一个二分
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="KM算法" scheme="http://qianyouyou.cn/tags/KM%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图匹配" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>[图论]二分图匹配基本算法之匈牙利算法解析</title>
    <link href="http://qianyouyou.cn/2018/05/05/2018-05-05/"/>
    <id>http://qianyouyou.cn/2018/05/05/2018-05-05/</id>
    <published>2018-05-05T14:38:39.000Z</published>
    <updated>2018-05-07T10:10:51.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图概念"><a href="#二分图概念" class="headerlink" title="二分图概念"></a>二分图概念</h2><p>二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（ i，j ）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p><p>简而言之，一个图所有的顶点被分成两部分，同一部分的顶点之间没有边。如图所示：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-5-1.png" alt=""></p><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。<br>极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。<br>如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。</p><h2 id="增广路经"><a href="#增广路经" class="headerlink" title="增广路经"></a>增广路经</h2><p>增广路径的定义：设M为二分图G已匹配边的集合，若P是图G中一条连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。<br>增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行,显然P有奇数条边</p><p>由增广路的定义可以推出下述三个结论：</p><ol><li>P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。</li><li>P经过取反操作可以得到一个更大的匹配M’。</li><li>M为G的最大匹配当且仅当不存在相对于M的增广路径。 </li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。</p><p>匈牙利算法基本模式：</p><hr><p>初始时最大匹配为空</p><p>​    while 找到增广路经</p><p>​        do 把增广路径加入到最大匹配中去</p><hr><p>具体过程如图所示：</p><p>1.如图所示，1可以与a，c匹配，2可以与a，b匹配，3可以与c匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-1.png" alt=""></p><p>2.首先将对1进行搜索，1可以与a匹配，则将1与a相连</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-2.png" alt=""></p><p>3.再对2进行搜索，2可以与a匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-3.png" alt=""></p><p>4.但是a已经与1匹配了，那么顺着a-&gt;1这条路找到1，再对1进行搜索，发现1还可以与c进行匹配，并且当前c还未与任何X区顶点匹配，则将1与c相连</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-4.png" alt=""></p><p>5.现在对3进行匹配，发现3可以与c匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-5.png" alt=""></p><p>6.这时发现c已经匹配了，则顺着c-&gt;1这条路找到1，再对1进行搜索，发现1还可以与a匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-6.png" alt=""></p><p>7.但a也已经匹配了，则顺着a-&gt;2这条路找到2，这时发现2还可以与b匹配，并且b当前还未与任何X顶点匹配，则将2与b匹配，之后得到的结果即为最大匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-7.png" alt=""></p><p>以下是实现代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool find(int x) &#123;//寻找增广路</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;//遍历Y部分顶点</span><br><span class="line">if (road[x][i] &amp;&amp; !vis[i]) &#123;//Y某顶点与X有路且未标记</span><br><span class="line">vis[i] = true;</span><br><span class="line">if (!link[i] || find(link[i])) &#123;//如果Y顶点当前未与其他X匹配则直接与该点匹配，否则寻找增广路，然后将Y顶点与该顶点匹配</span><br><span class="line">link[i] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt;= N; i++)&#123;//对每一个X部分顶点进行遍历</span><br><span class="line">  memset(vis,false,sizeof(vis));</span><br><span class="line">  if(find(i))&#123;//寻找增光路</span><br><span class="line">    ans++;//最大匹配数量加1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：POJ3041</p><p>给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍，</p><p>最少要几次。这里将每行x看成一个X结点，每列Y看成一个Y结点，障碍的坐标x,y看成X到Y的</p><p>一条边，构建出图后，就变成了找最少的点，使得这些点与所有的边相邻，即最小点覆盖问题。</p><p>又继续敲了一遍匈牙利算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N, K, ans;</span><br><span class="line">int road[520][520], head[520];</span><br><span class="line">bool vis[520];</span><br><span class="line">bool find(int x) &#123;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">if (road[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">vis[i] = true;</span><br><span class="line">if (!head[i] || find(head[i])) &#123;</span><br><span class="line">head[i] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">ans = 0;</span><br><span class="line">int x, y;</span><br><span class="line">memset(road, 0, sizeof(road));</span><br><span class="line">memset(head, 0, sizeof(head));</span><br><span class="line">for (int i = 1; i &lt;= K; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">road[x][y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">memset(vis, false, sizeof(vis));</span><br><span class="line">if (find(i)) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分图概念&quot;&gt;&lt;a href=&quot;#二分图概念&quot; class=&quot;headerlink&quot; title=&quot;二分图概念&quot;&gt;&lt;/a&gt;二分图概念&lt;/h2&gt;&lt;p&gt;二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图匹配" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
      <category term="匈牙利算法" scheme="http://qianyouyou.cn/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[C++实战qqHelper]C++打造qq消息一键群发工具</title>
    <link href="http://qianyouyou.cn/2018/05/03/2018-05-03/"/>
    <id>http://qianyouyou.cn/2018/05/03/2018-05-03/</id>
    <published>2018-05-03T09:42:24.000Z</published>
    <updated>2018-05-03T10:26:03.813Z</updated>
    
    <content type="html"><![CDATA[<p>物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此次借此小程序练习C++，用C++打造qq聊天一键群发功能。该小程序还在完善中。目前只能作用于电脑Windows操作系统，并且电脑聊天界面发送按钮需切换到按Enter直接发送，不要选择Ctrl+Enter。当前仅有发送功能，因此消息的对象是所有好友。之后有时间会陆续添加暂停，继续等操作。</p><p>具体代码以及实现过程在代码中逐条说明。这里就不具体说明了。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%5BHH@%29DN@ZX@RS53DTVQ1KZ8.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/YBFUJCK%29LL7%7B%5BO4OJ0Q$8$1.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/SB%7D%7DDL9H3VT9M@QQ$E%7DIK~2.png" alt=""></p><p>QQmessage.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class QQmessage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">QQmessage();</span><br><span class="line">~QQmessage();</span><br><span class="line"></span><br><span class="line">//类的入口 </span><br><span class="line">static QQmessage *Instance()</span><br><span class="line">&#123;</span><br><span class="line">static QQmessage object;</span><br><span class="line"></span><br><span class="line">return &amp;object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入口函数</span><br><span class="line">void Start(const wchar_t *msg);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">//开始线程</span><br><span class="line">static unsigned int WINAPI RunThreadproc(void* param);</span><br><span class="line"></span><br><span class="line">//发送主函数</span><br><span class="line">void SendAll();</span><br><span class="line"></span><br><span class="line">//找到QQ窗口</span><br><span class="line">HWND FindQQWindow();</span><br><span class="line"></span><br><span class="line">//模拟按键</span><br><span class="line">void PressKey(BYTE vkey);</span><br><span class="line"></span><br><span class="line">//发送消息</span><br><span class="line">void SendMsg();</span><br><span class="line"></span><br><span class="line">//添加文本到剪贴板</span><br><span class="line">void AddTextToClipboard();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">CString m_msg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>QQmessage.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQmessage.h&quot;</span><br><span class="line"></span><br><span class="line">QQmessage::QQmessage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQmessage::~QQmessage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入口函数</span><br><span class="line">void QQmessage::Start(const wchar_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">m_msg = CString(msg); //输入的文本</span><br><span class="line"></span><br><span class="line">_beginthreadex(NULL, 0, QQmessage::RunThreadproc, NULL, 0, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始线程</span><br><span class="line">unsigned int QQmessage::RunThreadproc(void* param)</span><br><span class="line">&#123;</span><br><span class="line">QQmessage::Instance()-&gt;SendAll();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送主函数</span><br><span class="line">void QQmessage::SendAll()</span><br><span class="line">&#123;</span><br><span class="line">int errorTimes = 0;  //打开对话框错误的次数!</span><br><span class="line">//把text复制到剪贴板</span><br><span class="line">AddTextToClipboard();</span><br><span class="line"></span><br><span class="line">//技术到家. 做项目能力.</span><br><span class="line">while (errorTimes&lt;= 4)</span><br><span class="line">&#123;</span><br><span class="line">HWND hQQWnd = FindQQWindow();</span><br><span class="line">HWND hFrontWnd = GetForegroundWindow(); </span><br><span class="line"></span><br><span class="line">if (hQQWnd != hFrontWnd)</span><br><span class="line">&#123;</span><br><span class="line">if (!SetForegroundWindow(hQQWnd))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(NULL, L&quot;没有找到QQ窗口&quot;, NULL, NULL);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (errorTimes == 0)</span><br><span class="line">&#123;</span><br><span class="line">PressKey(VK_TAB);</span><br><span class="line">PressKey(VK_TAB);</span><br><span class="line">&#125;</span><br><span class="line">PressKey(VK_DOWN);</span><br><span class="line">PressKey(VK_RETURN);</span><br><span class="line"></span><br><span class="line">HWND hCurFrontWnd = GetForegroundWindow();</span><br><span class="line">if (hCurFrontWnd == hQQWnd)  //</span><br><span class="line">&#123;</span><br><span class="line">++errorTimes;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errorTimes = 0;</span><br><span class="line">SendMsg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到QQ窗口</span><br><span class="line">HWND QQmessage::FindQQWindow()</span><br><span class="line">&#123;</span><br><span class="line">HWND hWnd = FindWindow(L&quot;TXGuiFoundation&quot;,L&quot;QQ&quot;);  //Find  Window //获取QQ的窗口!!!</span><br><span class="line"></span><br><span class="line">//辅助工具就是这么做的</span><br><span class="line">return hWnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟按键</span><br><span class="line">void QQmessage::PressKey(BYTE vkey)</span><br><span class="line">&#123;</span><br><span class="line">keybd_event(vkey, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">Sleep(100);</span><br><span class="line">keybd_event(vkey, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">Sleep(100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送消息  16GU盘</span><br><span class="line">void QQmessage::SendMsg()</span><br><span class="line">&#123;</span><br><span class="line">//粘贴  +  发送</span><br><span class="line">keybd_event(VK_CONTROL, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">Sleep(100);</span><br><span class="line">keybd_event(0x56, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">Sleep(100);</span><br><span class="line"></span><br><span class="line">keybd_event(0x56, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">Sleep(100);</span><br><span class="line">keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">Sleep(100); //你好 鲜花刷起来!</span><br><span class="line"></span><br><span class="line">//发送</span><br><span class="line">PressKey(VK_RETURN);</span><br><span class="line">PressKey(VK_ESCAPE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加文本到剪贴板</span><br><span class="line">void QQmessage::AddTextToClipboard()</span><br><span class="line">&#123;</span><br><span class="line">//1.把文本拷贝到全局变量!  </span><br><span class="line">int memLen = m_msg.GetLength() * sizeof(wchar_t) + 2;</span><br><span class="line"></span><br><span class="line">HANDLE hGloBal = GlobalAlloc(GHND,memLen);   //malloc  calloc  relloc </span><br><span class="line"></span><br><span class="line">void* memAddr = GlobalLock(hGloBal);</span><br><span class="line"></span><br><span class="line">ZeroMemory(memAddr, memLen);</span><br><span class="line"></span><br><span class="line">memcpy(memAddr, (const void*)m_msg.GetBuffer(), memLen);</span><br><span class="line"></span><br><span class="line">GlobalUnlock(hGloBal);</span><br><span class="line"></span><br><span class="line">//操作剪贴板!  怎么把大象装进冰箱!</span><br><span class="line">OpenClipboard(NULL);</span><br><span class="line">EmptyClipboard();</span><br><span class="line">SetClipboardData(CF_UNICODETEXT, hGloBal);</span><br><span class="line">CloseClipboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QQHelperDlg.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelperDlg.h : 头文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 对话框</span><br><span class="line">class CQQHelperDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">// 构造</span><br><span class="line">public:</span><br><span class="line">CQQHelperDlg(CWnd* pParent = NULL);// 标准构造函数</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_QQHELPER_DIALOG &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);// DDX/DDV 支持</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">protected:</span><br><span class="line">HICON m_hIcon;</span><br><span class="line"></span><br><span class="line">// 生成的消息映射函数</span><br><span class="line">virtual BOOL OnInitDialog();</span><br><span class="line">afx_msg void OnSysCommand(UINT nID, LPARAM lParam);</span><br><span class="line">afx_msg void OnPaint();</span><br><span class="line">afx_msg HCURSOR OnQueryDragIcon();</span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">CString m_Msg;</span><br><span class="line">afx_msg void OnBnClickedButton1();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>QQHelperDlg.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelperDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQHelper.h&quot;</span><br><span class="line">#include &quot;QQHelperDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;QQmessage.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define new DEBUG_NEW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用于应用程序“关于”菜单项的 CAboutDlg 对话框</span><br><span class="line"></span><br><span class="line">class CAboutDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CAboutDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_ABOUTBOX &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">protected:</span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CAboutDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::DoDataExchange(pDX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 对话框</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CQQHelperDlg::CQQHelperDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialogEx(IDD_QQHELPER_DIALOG, pParent)</span><br><span class="line">, m_Msg(_T(&quot;&quot;))</span><br><span class="line">&#123;</span><br><span class="line">m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::DoDataExchange(pDX);</span><br><span class="line">DDX_Text(pDX, IDC_EDIT1, m_Msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CQQHelperDlg, CDialogEx)</span><br><span class="line">ON_WM_SYSCOMMAND()</span><br><span class="line">ON_WM_PAINT()</span><br><span class="line">ON_WM_QUERYDRAGICON()</span><br><span class="line">ON_BN_CLICKED(IDC_BUTTON1, &amp;CQQHelperDlg::OnBnClickedButton1)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 消息处理程序</span><br><span class="line"></span><br><span class="line">BOOL CQQHelperDlg::OnInitDialog()</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">// 将“关于...”菜单项添加到系统菜单中。</span><br><span class="line"></span><br><span class="line">// IDM_ABOUTBOX 必须在系统命令范围内。</span><br><span class="line">ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);</span><br><span class="line">ASSERT(IDM_ABOUTBOX &lt; 0xF000);</span><br><span class="line"></span><br><span class="line">CMenu* pSysMenu = GetSystemMenu(FALSE);</span><br><span class="line">if (pSysMenu != NULL)</span><br><span class="line">&#123;</span><br><span class="line">BOOL bNameValid;</span><br><span class="line">CString strAboutMenu;</span><br><span class="line">bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);</span><br><span class="line">ASSERT(bNameValid);</span><br><span class="line">if (!strAboutMenu.IsEmpty())</span><br><span class="line">&#123;</span><br><span class="line">pSysMenu-&gt;AppendMenu(MF_SEPARATOR);</span><br><span class="line">pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span><br><span class="line">//  执行此操作</span><br><span class="line">SetIcon(m_hIcon, TRUE);// 设置大图标</span><br><span class="line">SetIcon(m_hIcon, FALSE);// 设置小图标</span><br><span class="line"></span><br><span class="line">// TODO: 在此添加额外的初始化代码</span><br><span class="line"></span><br><span class="line">return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::OnSysCommand(UINT nID, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">CAboutDlg dlgAbout;</span><br><span class="line">dlgAbout.DoModal();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::OnSysCommand(nID, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果向对话框添加最小化按钮，则需要下面的代码</span><br><span class="line">//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，</span><br><span class="line">//  这将由框架自动完成。</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">if (IsIconic())</span><br><span class="line">&#123;</span><br><span class="line">CPaintDC dc(this); // 用于绘制的设备上下文</span><br><span class="line"></span><br><span class="line">SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);</span><br><span class="line"></span><br><span class="line">// 使图标在工作区矩形中居中</span><br><span class="line">int cxIcon = GetSystemMetrics(SM_CXICON);</span><br><span class="line">int cyIcon = GetSystemMetrics(SM_CYICON);</span><br><span class="line">CRect rect;</span><br><span class="line">GetClientRect(&amp;rect);</span><br><span class="line">int x = (rect.Width() - cxIcon + 1) / 2;</span><br><span class="line">int y = (rect.Height() - cyIcon + 1) / 2;</span><br><span class="line"></span><br><span class="line">// 绘制图标</span><br><span class="line">dc.DrawIcon(x, y, m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::OnPaint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当用户拖动最小化窗口时系统调用此函数取得光标</span><br><span class="line">//显示。</span><br><span class="line">HCURSOR CQQHelperDlg::OnQueryDragIcon()</span><br><span class="line">&#123;</span><br><span class="line">return static_cast&lt;HCURSOR&gt;(m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//发送</span><br><span class="line">void CQQHelperDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此添加控件通知处理程序代码</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"></span><br><span class="line">QQmessage::Instance()-&gt;Start(m_Msg.GetBuffer());//m_Msg实例编辑框的变量  文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QQHelper.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelper.h : PROJECT_NAME 应用程序的主头文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifndef __AFXWIN_H__</span><br><span class="line">#error &quot;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &quot;resource.h&quot;// 主符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp: </span><br><span class="line">// 有关此类的实现，请参阅 QQHelper.cpp</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">class CQQHelperApp : public CWinApp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CQQHelperApp();</span><br><span class="line"></span><br><span class="line">// 重写</span><br><span class="line">public:</span><br><span class="line">virtual BOOL InitInstance();</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern CQQHelperApp theApp;</span><br></pre></td></tr></table></figure><p>QQHelper.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelper.cpp : 定义应用程序的类行为。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQHelper.h&quot;</span><br><span class="line">#include &quot;QQHelperDlg.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define new DEBUG_NEW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CQQHelperApp, CWinApp)</span><br><span class="line">ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp 构造</span><br><span class="line"></span><br><span class="line">CQQHelperApp::CQQHelperApp()</span><br><span class="line">&#123;</span><br><span class="line">// 支持重新启动管理器</span><br><span class="line">m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;</span><br><span class="line"></span><br><span class="line">// TODO: 在此处添加构造代码，</span><br><span class="line">// 将所有重要的初始化放置在 InitInstance 中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 唯一的一个 CQQHelperApp 对象</span><br><span class="line"></span><br><span class="line">CQQHelperApp theApp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp 初始化</span><br><span class="line"></span><br><span class="line">BOOL CQQHelperApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">// 如果一个运行在 Windows XP 上的应用程序清单指定要</span><br><span class="line">// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，</span><br><span class="line">//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。</span><br><span class="line">INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">InitCtrls.dwSize = sizeof(InitCtrls);</span><br><span class="line">// 将它设置为包括所有要在应用程序中使用的</span><br><span class="line">// 公共控件类。</span><br><span class="line">InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line">InitCommonControlsEx(&amp;InitCtrls);</span><br><span class="line"></span><br><span class="line">CWinApp::InitInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AfxEnableControlContainer();</span><br><span class="line"></span><br><span class="line">// 创建 shell 管理器，以防对话框包含</span><br><span class="line">// 任何 shell 树视图控件或 shell 列表视图控件。</span><br><span class="line">CShellManager *pShellManager = new CShellManager;</span><br><span class="line"></span><br><span class="line">// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题</span><br><span class="line">CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));</span><br><span class="line"></span><br><span class="line">// 标准初始化</span><br><span class="line">// 如果未使用这些功能并希望减小</span><br><span class="line">// 最终可执行文件的大小，则应移除下列</span><br><span class="line">// 不需要的特定初始化例程</span><br><span class="line">// 更改用于存储设置的注册表项</span><br><span class="line">// TODO: 应适当修改该字符串，</span><br><span class="line">// 例如修改为公司或组织名</span><br><span class="line">SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));</span><br><span class="line"></span><br><span class="line">CQQHelperDlg dlg;</span><br><span class="line">m_pMainWnd = &amp;dlg;</span><br><span class="line">INT_PTR nResponse = dlg.DoModal();</span><br><span class="line">if (nResponse == IDOK)</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此放置处理何时用</span><br><span class="line">//  “确定”来关闭对话框的代码</span><br><span class="line">&#125;</span><br><span class="line">else if (nResponse == IDCANCEL)</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此放置处理何时用</span><br><span class="line">//  “取消”来关闭对话框的代码</span><br><span class="line">&#125;</span><br><span class="line">else if (nResponse == -1)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);</span><br><span class="line">TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除上面创建的 shell 管理器。</span><br><span class="line">if (pShellManager != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete pShellManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifndef _AFXDLL</span><br><span class="line">ControlBarCleanUp();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，</span><br><span class="line">//  而不是启动应用程序的消息泵。</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stdafx.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// stdafx.h : 标准系统包含文件的包含文件，</span><br><span class="line">// 或是经常使用但不常更改的</span><br><span class="line">// 特定于项目的包含文件</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifndef VC_EXTRALEAN</span><br><span class="line">#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &quot;targetver.h&quot;</span><br><span class="line"></span><br><span class="line">#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的</span><br><span class="line"></span><br><span class="line">// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏</span><br><span class="line">#define _AFX_ALL_WARNINGS</span><br><span class="line"></span><br><span class="line">#include &lt;afxwin.h&gt;         // MFC 核心组件和标准组件</span><br><span class="line">#include &lt;afxext.h&gt;         // MFC 扩展</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;afxdisp.h&gt;        // MFC 自动化类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef _AFX_NO_OLE_SUPPORT</span><br><span class="line">#include &lt;afxdtctl.h&gt;           // MFC 对 Internet Explorer 4 公共控件的支持</span><br><span class="line">#endif</span><br><span class="line">#ifndef _AFX_NO_AFXCMN_SUPPORT</span><br><span class="line">#include &lt;afxcmn.h&gt;             // MFC 对 Windows 公共控件的支持</span><br><span class="line">#endif // _AFX_NO_AFXCMN_SUPPORT</span><br><span class="line"></span><br><span class="line">#include &lt;afxcontrolbars.h&gt;     // 功能区和控件条的 MFC 支持</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef _UNICODE</span><br><span class="line">#if defined _M_IX86</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;x86&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#elif defined _M_X64</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;amd64&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#else</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;*&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>stdafx.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// stdafx.cpp : 只包括标准包含文件的源文件</span><br><span class="line">// QQHelper.pch 将作为预编译头</span><br><span class="line">// stdafx.obj 将包含预编译类型信息</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br></pre></td></tr></table></figure><p>Resource.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="line">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="line">// 供 QQHelper.rc 使用</span><br><span class="line">//</span><br><span class="line">#define IDM_ABOUTBOX                    0x0010</span><br><span class="line">#define IDD_ABOUTBOX                    100</span><br><span class="line">#define IDS_ABOUTBOX                    101</span><br><span class="line">#define IDD_QQHELPER_DIALOG             102</span><br><span class="line">#define IDR_MAINFRAME                   128</span><br><span class="line">#define IDC_EDIT1                       1000</span><br><span class="line">#define IDC_BUTTON1                     1001</span><br><span class="line"></span><br><span class="line">// Next default values for new objects</span><br><span class="line">// </span><br><span class="line">#ifdef APSTUDIO_INVOKED</span><br><span class="line">#ifndef APSTUDIO_READONLY_SYMBOLS</span><br><span class="line">#define _APS_NEXT_RESOURCE_VALUE        130</span><br><span class="line">#define _APS_NEXT_COMMAND_VALUE         32771</span><br><span class="line">#define _APS_NEXT_CONTROL_VALUE         1002</span><br><span class="line">#define _APS_NEXT_SYMED_VALUE           101</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>targetver.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。</span><br><span class="line"></span><br><span class="line">// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将</span><br><span class="line">// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。</span><br><span class="line"></span><br><span class="line">#include &lt;SDKDDKVer.h&gt;</span><br></pre></td></tr></table></figure><p>资源文件</p><p><img src="http://p7woygi8q.bkt.clouddn.com/QQHelper.ico" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="项目实战" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）</title>
    <link href="http://qianyouyou.cn/2018/05/01/2018-05-01/"/>
    <id>http://qianyouyou.cn/2018/05/01/2018-05-01/</id>
    <published>2018-05-01T15:37:44.000Z</published>
    <updated>2018-05-01T16:21:11.527Z</updated>
    
    <content type="html"><![CDATA[<p>今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。</p><h2 id="Walking-in-the-Forest-（最大值最小化例题）"><a href="#Walking-in-the-Forest-（最大值最小化例题）" class="headerlink" title="Walking in the Forest （最大值最小化例题）"></a><a href="https://www.nowcoder.com/acm/contest/106/K" target="_blank" rel="noopener">Walking in the Forest</a> （最大值最小化例题）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  It’s universally acknowledged that there’re innumerable trees in the campus of HUST. </p><p>  Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step.  </p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The first line contains two integer N and K as described above.</span><br><span class="line">Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone.</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An integer, the minimum distance of the largest step.</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 3 2 2 5</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>题意：</p><p>有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。</p><p>题解：</p><p>典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">long long  a[100010];</span><br><span class="line">int n, k;</span><br><span class="line">bool check(long long ld,long long rd,long long mind) &#123;</span><br><span class="line">long long cnt = 0;</span><br><span class="line">int stemp = 1;</span><br><span class="line">for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">if (cnt + a[i] &lt;= mind) &#123;</span><br><span class="line">cnt += a[i];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cnt = a[i];</span><br><span class="line">stemp++;</span><br><span class="line">&#125;</span><br><span class="line">if (stemp &gt; k)</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (stemp &lt;= k)</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123;</span><br><span class="line">long long maxn = 0, sumn = 0;</span><br><span class="line">for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">sumn += a[i];</span><br><span class="line">if (maxn &lt; a[i])</span><br><span class="line">maxn = a[i];</span><br><span class="line">&#125;</span><br><span class="line">long long ld = maxn;</span><br><span class="line">long long rd = sumn;</span><br><span class="line">long long mind = (ld + rd) / 2;</span><br><span class="line">while (ld &lt;= rd) &#123;</span><br><span class="line">bool flag = check(ld, rd, mind);</span><br><span class="line">if (!flag) &#123;</span><br><span class="line">ld = mind + 1;</span><br><span class="line">mind = (ld + rd) / 2;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">rd = mind - 1;</span><br><span class="line">mind = (ld + rd) / 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, ld);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2456疯牛-（最小值最大化例题）"><a href="#POJ2456疯牛-（最小值最大化例题）" class="headerlink" title="POJ2456疯牛 （最小值最大化例题）"></a>POJ2456疯牛 （最小值最大化例题）</h2><p>时间限制：1000 ms  |  内存限制：65535 KB</p><p>难度：4</p><ul><li><p>描述</p><p>农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入<code>5 312849</code>样例输出<code>3</code></p></li></ul><p>题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。</p><p>题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int v[100005];  </span><br><span class="line">int n, c;  </span><br><span class="line">int check(int d) &#123;  </span><br><span class="line">    int tmp = v[0], cnt = 1;  </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;  </span><br><span class="line">        if (v[i] - tmp &gt;= d) &#123;  </span><br><span class="line">            cnt++;  </span><br><span class="line">            tmp = v[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (cnt &gt;= c)  </span><br><span class="line">        return 1;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; c) &#123;  </span><br><span class="line">        for (int i = 0; i &lt; n; i++)  </span><br><span class="line">            cin &gt;&gt; v[i];  </span><br><span class="line">        sort(v, v + n);  </span><br><span class="line">        int l = 0, r = v[n - 1], mid;  </span><br><span class="line">        while (l &lt;= r) &#123;  </span><br><span class="line">            mid = (l + r) / 2;  </span><br><span class="line">            if (check(mid))  </span><br><span class="line">                l = mid + 1;  </span><br><span class="line">            else  </span><br><span class="line">                r = mid - 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%d\n&quot;, r);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。&lt;/p&gt;
&lt;h2 id=&quot;Walking-in-the-Forest-（最大值最小化例题）&quot;&gt;&lt;a href=&quot;#Walking-in-the-Forest-
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="二分" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解</title>
    <link href="http://qianyouyou.cn/2018/04/29/2018-04-29/"/>
    <id>http://qianyouyou.cn/2018/04/29/2018-04-29/</id>
    <published>2018-04-29T12:26:44.000Z</published>
    <updated>2018-05-06T14:26:08.972Z</updated>
    
    <content type="html"><![CDATA[<p>4月29日，13:30-18:30，<a href="http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=378" target="_blank" rel="noopener">浙江大学程序设计校赛</a> </p><h2 id="A-Peak"><a href="#A-Peak" class="headerlink" title="A-Peak"></a>A-Peak</h2><p>题意：</p><p>有一串数字，问这串数字是否符合以下情况：</p><p>存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。</p><p>题解：</p><p>水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。</p><h2 id="B-King-of-Karaoke"><a href="#B-King-of-Karaoke" class="headerlink" title="B - King of Karaoke"></a>B - King of Karaoke</h2><p>题意：</p><p>两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k</p><p>题解：</p><p>只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。</p><h2 id="D-Sequence-Swapping"><a href="#D-Sequence-Swapping" class="headerlink" title="D - Sequence Swapping"></a>D - Sequence Swapping</h2><hr><p>Time Limit: 1 Second      Memory Limit: 65536 KB</p><hr><p>BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length  in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element  in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element  in the pair is an integer.</p><p>As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if ,  ‘(‘ and  ‘)’.</p><p>BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case:</p><p>The first line contains an integer  (), indicating the length of the sequence.</p><p>The second line contains a string  () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above.</p><p>The third line contains  integers  (). Their meanings are described above.</p><p>It’s guaranteed that the sum of  of all test cases will not exceed .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line containing one integer, indicating the maximum possible score BaoBao can get.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">)())()</span><br><span class="line">1 3 5 -1 3 2</span><br><span class="line">6</span><br><span class="line">)())()</span><br><span class="line">1 3 5 -100 3 2</span><br><span class="line">3</span><br><span class="line">())</span><br><span class="line">1 -1 -1</span><br><span class="line">3</span><br><span class="line">())</span><br><span class="line">-1 -1 -1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">24</span><br><span class="line">21</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>For the first sample test case, the optimal strategy is to select  in order.</p><p>For the second sample test case, the optimal strategy is to select  in order.</p><p>题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。</p><p>题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即cur<em>weight[i]。否则将cur和cur</em>weight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">int cur;</span><br><span class="line">int cnt;</span><br><span class="line">&#125;;</span><br><span class="line">char str[1010];</span><br><span class="line">int wei[1010];</span><br><span class="line">int main() &#123;</span><br><span class="line">int t, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%d%s&quot;, &amp;n, str);</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;wei[i]);</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;node&gt;st;</span><br><span class="line">int sum = 0;</span><br><span class="line">int cur = 0;</span><br><span class="line">int cnt = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">if (str[i] == &apos;(&apos;) &#123;</span><br><span class="line">if (cur == 0) &#123;</span><br><span class="line">cur = wei[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (abs(cur) &lt; abs(cur + wei[i])) &#123;</span><br><span class="line">cur = cur + wei[i];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cur = wei[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (str[i] == &apos;)&apos;) &#123;</span><br><span class="line">if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123;</span><br><span class="line">cnt = 0;</span><br><span class="line">do &#123;</span><br><span class="line">cur += st.top().cur;</span><br><span class="line">cnt += st.top().cnt;</span><br><span class="line">st.pop();</span><br><span class="line">&#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]);</span><br><span class="line">sum += cur*wei[i] + cnt;</span><br><span class="line">&#125;</span><br><span class="line">else if (cur*wei[i] &gt; 0) &#123;</span><br><span class="line">sum += wei[i] * cur;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123;</span><br><span class="line">cur += st.top().cur;</span><br><span class="line">sum += cur*wei[i] + st.top().cnt;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (!cur&amp;&amp;!st.empty()) &#123;</span><br><span class="line">st.top().cnt += st.top().cur*wei[i];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">node tmp;</span><br><span class="line">tmp.cnt = cur*wei[i];</span><br><span class="line">tmp.cur = cur;</span><br><span class="line">st.push(tmp);</span><br><span class="line">cur = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-CONTINUE…"><a href="#J-CONTINUE…" class="headerlink" title="J - CONTINUE…?"></a>J - CONTINUE…?</h2><hr><p>Time Limit: 1 Second      Memory Limit: 65536 KB      Special Judge</p><hr><p>DreamGrid has  classmates numbered from  to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has  gems.</p><p>DreamGrid would like to divide the classmates into four groups , ,  and  such that:</p><ul><li>Each classmate belongs to exactly one group.</li><li>Both  and  consist only of girls. Both  and  consist only of boys.</li><li>The total number of gems in  and  is equal to the total number of gems in  and .</li></ul><p>Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty.</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input is an integer  indicating the number of test cases. For each test case:</p><p>The first line contains an integer  () – the number of classmates.</p><p>The second line contains a string  () consisting of 0 and 1. Let  be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl.</p><p>It is guaranteed that the sum of all  does not exceed .</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">101</span><br><span class="line">4</span><br><span class="line">0000</span><br><span class="line">7</span><br><span class="line">1101001</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">314</span><br><span class="line">1221</span><br><span class="line">3413214</span><br></pre></td></tr></table></figure><p>题意：</p><p>有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可）</p><p>题解：</p><p>看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int a[100010], vis[100010];</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">long long int sum = 0, half = 0;</span><br><span class="line">while (t--) &#123;</span><br><span class="line">int n;</span><br><span class="line">sum = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%1d&quot;, &amp;a[i]);</span><br><span class="line">sum += i + 1;</span><br><span class="line">&#125;</span><br><span class="line">if (sum % 2 != 0) &#123;</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">half = sum / 2;</span><br><span class="line">sum = 0;</span><br><span class="line">for (int i = n; i &gt; 0; i--) &#123;</span><br><span class="line">if (sum + i &lt;= half) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">vis[i - 1] = 1;</span><br><span class="line">if (sum == half)</span><br><span class="line">break;</span><br><span class="line">else if (half - sum &lt; i) &#123;</span><br><span class="line">vis[half - sum - 1] = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">if (a[i]) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">printf(&quot;3&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (!a[i]) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">printf(&quot;1&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Doki-Doki-Literature-Club"><a href="#L-Doki-Doki-Literature-Club" class="headerlink" title="L - Doki Doki Literature Club"></a>L - Doki Doki Literature Club</h2><hr><p>Time Limit: 1 Second      Memory Limit: 65536 KB</p><hr><p><em>Doki Doki Literature Club!</em> is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story!</p><p>A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words.</p><p><img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=poem.jpg" alt="img"><em>The poem writing mini-game (from wikipedia)</em></p><p>BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of  words  is nothing more than a sequence of  strings, and the happiness of Sayori after reading the poem is calculated by the formula</p><p>Given a list of  words and Sayori’s preference to each word, please help BaoBao select  words from the list and finish the poem with these  words to maximize the happiness of Sayori.</p><p>Please note that each word can be used at most <strong>once</strong>!</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer  (about 100), indicating the number of test cases. For each test case:</p><p>The first line contains two integers  and  (), indicating the number of words and the length of the poem.</p><p>For the following  lines, the -th line contains a string consisting of lowercased English letters  () and an integer  (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that  for all .</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line containing an integer  and  strings  separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one.</p><p>Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!</p><p>A <strong>sequence</strong> of  strings  is lexicographically smaller than another <strong>sequence</strong> of  strings , if there exists a  () such that  for all  and  is lexicographically smaller than .</p><p>A <strong>string</strong>  is lexicographically smaller than another <strong>string</strong> , if there exists a  () such that  for all  and , or  for all  and .</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10 8</span><br><span class="line">hello 0</span><br><span class="line">world 0</span><br><span class="line">behind 0</span><br><span class="line">far 1</span><br><span class="line">be 2</span><br><span class="line">spring 10</span><br><span class="line">can 15</span><br><span class="line">comes 20</span><br><span class="line">winter 25</span><br><span class="line">if 200</span><br><span class="line">5 5</span><br><span class="line">collegiate 0</span><br><span class="line">programming -5</span><br><span class="line">zhejiang 10</span><br><span class="line">provincial 5</span><br><span class="line">contest -45</span><br><span class="line">3 2</span><br><span class="line">bcda 1</span><br><span class="line">bcd 1</span><br><span class="line">bbbbb 1</span><br><span class="line">3 2</span><br><span class="line">a 1</span><br><span class="line">aa 1</span><br><span class="line">aaa 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018 if winter comes can spring be far behind</span><br><span class="line">15 zhejiang provincial collegiate programming contest</span><br><span class="line">3 bbbbb bcd</span><br><span class="line">3 a aa</span><br></pre></td></tr></table></figure><p>题意：</p><p>有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。</p><p>题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string str;</span><br><span class="line">long long int weight;</span><br><span class="line">&#125;;</span><br><span class="line">node level[110];</span><br><span class="line">bool cmp(node a,node b) &#123;</span><br><span class="line">if (a.weight != b.weight)</span><br><span class="line">return a.weight &gt; b.weight;</span><br><span class="line">else &#123;</span><br><span class="line">return a.str &lt; b.str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t, n, m;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">long long int h = 0;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; level[i].str &gt;&gt; level[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">sort(level, level + n, cmp);</span><br><span class="line">for (int i = m; i &gt; 0; i--)</span><br><span class="line">h += level[m - i].weight*i;</span><br><span class="line">printf(&quot;%lld &quot;, h);</span><br><span class="line">for (int i = 0; i &lt; m - 1; i++)</span><br><span class="line">cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; level[m - 1].str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Lucky-7"><a href="#K-Lucky-7" class="headerlink" title="K - Lucky 7"></a>K - Lucky 7</h2><p>给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。</p><p>题解：</p><p>每输入一个数直接进行判断即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4月29日，13:30-18:30，&lt;a href=&quot;http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浙江大学程序设
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="ZOJ" scheme="http://qianyouyou.cn/tags/ZOJ/"/>
    
  </entry>
  
  <entry>
    <title>基于github搭建专属于自己的博客(高级篇)</title>
    <link href="http://qianyouyou.cn/2018/04/28/2018-04-28-3/"/>
    <id>http://qianyouyou.cn/2018/04/28/2018-04-28-3/</id>
    <published>2018-04-28T15:39:25.000Z</published>
    <updated>2018-05-02T15:18:26.478Z</updated>
    
    <content type="html"><![CDATA[<p>由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)&lt;/p&gt;

      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="node.js" scheme="http://qianyouyou.cn/tags/node-js/"/>
    
      <category term="html/css" scheme="http://qianyouyou.cn/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>基于github搭建专属于自己的博客(进阶篇)</title>
    <link href="http://qianyouyou.cn/2018/04/28/2018-04-28-2/"/>
    <id>http://qianyouyou.cn/2018/04/28/2018-04-28-2/</id>
    <published>2018-04-28T13:44:25.000Z</published>
    <updated>2018-05-02T15:17:54.319Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。</p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>1.安装主题</p><p>2.启用主题</p><p>3.验证主题</p><p>4.设置语言</p><p>5.设置菜单</p><p>6.侧栏设置</p><p>7.尾栏设置</p><p>8.附页</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。 </p><p>以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>即可获取最新版主题，后续更新只需输入指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>注意中间有空格。到此，NexT 主题安装完成。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>首先启动 Hexo 本地站点，并开启调试模式，整个命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p> 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.此时即可使用浏览器访问 <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><p>如果端口号被占用还是得先修改端口号，然后启动服务。即先输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure><p> 当命令行输出中提示出：INFO Hexo is running at <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000/</a>. Press Ctrl+C to stop.此时即可使用浏览器访问 <a href="http://localhost:5000/。" target="_blank" rel="noopener">http://localhost:5000/。</a></p><p>完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是：</p><p>Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白</p><p>Mist - Muse 的紧凑版本，整洁有序的单栏外观</p><p>Pisces - 双栏 Scheme，小家碧玉似的清新</p><p> Gemini - 双栏Scheme，简约淡雅的风尚</p><p>注释 # 即可。 以Pisce为例，选择 Pisce Scheme</p><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>在<strong>站点根目录</strong>下修改配置文件_cofig.yml中的language为zh-Hans（简体中文）</p><p>目前 NexT 支持的语言如以下表格所示：</p><table><thead><tr><th>语言</th><th>代码</th><th>设定实例</th></tr></thead><tbody><tr><td>English</td><td>en</td><td>language: en</td></tr><tr><td>简体中文</td><td>zh-Hans</td><td>language: zh-Hans</td></tr><tr><td>Français</td><td>fr-FR</td><td>language: fr-FR</td></tr><tr><td>Português</td><td>pt</td><td>language: pt</td></tr><tr><td>繁體中文</td><td>zh-hk 或者 zh-tw</td><td>language: zh-hk</td></tr><tr><td>Русский язык</td><td>ru</td><td>language: ru</td></tr><tr><td>Deutsch</td><td>de</td><td>language: de</td></tr><tr><td>日本語</td><td>ja</td><td>language: ja</td></tr><tr><td>Indonesian</td><td>id</td><td>language: id</td></tr></tbody></table><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><h4 id="菜单栏设置"><a href="#菜单栏设置" class="headerlink" title="菜单栏设置"></a>菜单栏设置</h4><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。</p><p>编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  #about: /about</span><br><span class="line">  #categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  #commonweal: /404.html</span><br></pre></td></tr></table></figure><p>若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）：</p><table><thead><tr><th>键值</th><th>设定值</th><th>显示文本（简体中文）</th></tr></thead><tbody><tr><td>home</td><td>home: /</td><td>主页</td></tr><tr><td>archives</td><td>archives: /archives</td><td>归档页</td></tr><tr><td>categories</td><td>categories: /categories</td><td>分类页</td></tr><tr><td>tags</td><td>tags: /tags</td><td>标签页</td></tr><tr><td>about</td><td>about: /about</td><td>关于页面</td></tr><tr><td>commonweal</td><td>commonweal: /404.html</td><td>公益 404</td></tr></tbody></table><p>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br></pre></td></tr></table></figure><p>设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure><h4 id="添加标签，分类"><a href="#添加标签，分类" class="headerlink" title="添加标签，分类"></a>添加标签，分类</h4><p>添加标签页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>在新建的index.md文件中添加type: “tags”</p><p>当要为某一篇文章添加标签，只需在b<code>log/source/_post</code>目录下的具体文章的tags中添加标签即可</p><p>添加分类页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>在新建的index.md文件中添加type: “categories”</p><p>当要为某一篇文章添加标签，只需在<code>blog/source/_post</code>目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。</p><p>添加关于我页面，步骤和以上差不多</p><p>在新建的index.md文件中添加内容</p><h3 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h3><p>设置侧栏位置，修改主题目录下sidebar的position值</p><p>设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p><h3 id="尾栏设置"><a href="#尾栏设置" class="headerlink" title="尾栏设置"></a>尾栏设置</h3><p>修改底部的官方logo，找到 <code>\themes\next\layout\_partials\</code>下面的<code>footer.swig</code>文件，打开会发现，如下的语句：</p><p>第一个框 是下面侧栏的“日期❤ XXX”</p><p>如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。</p><p>第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把<code>&lt;a&gt;...&lt;/a&gt;</code>标签这部分删除即可，留着两个单引号’’,否则会出错哦。</p><p>第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将<code>&lt;a&gt;..&lt;/a&gt;</code>都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。</p><p>接下来，处理剩余的中文信息。找到这个地方<code>\themes\next\languages\</code> 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）</p><p>看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。</p><h3 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h3><p>站点配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site 网站</span><br><span class="line">title: 浅悠悠的个人博客   #网站标题</span><br><span class="line">subtitle: 。。。   #网站副标题</span><br><span class="line">description: 。。。   #网站描述</span><br><span class="line">author: 王骏   #您的名字</span><br><span class="line">language: zh-CN   #网站使用的语言</span><br><span class="line">timezone:           #网站时区。Hexo 默认使用您电脑的时区</span><br><span class="line"></span><br><span class="line"># URL 网址</span><br><span class="line">## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="line">url: http://willxue.top</span><br><span class="line">permalink: :year/:month/:day/:title/    #生成文件名字的格式我改成blog/:title:year:month:day/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory 目录配置</span><br><span class="line">source_dir: source   #源文件夹，这个文件夹用来存放内容。</span><br><span class="line">public_dir: public   #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class="line">tag_dir: tags   #标签文件夹</span><br><span class="line">archive_dir: archives   #归档文件夹</span><br><span class="line">category_dir: categories   #分类文件夹</span><br><span class="line">code_dir: downloads/code    #nclude code 文件夹</span><br><span class="line">i18n_dir: :lang   #国际化（i18n）文件夹</span><br><span class="line">skip_render:   #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class="line"></span><br><span class="line"># Writing 文章</span><br><span class="line">new_post_name: :title.md   # 新建文章默认文件名</span><br><span class="line">default_layout: post   # 默认布局</span><br><span class="line">titlecase: false   # Transform title into titlecase</span><br><span class="line">external_link: true   # 在新标签中打开一个外部链接，默认为true</span><br><span class="line">filename_case: 0   #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</span><br><span class="line">render_drafts: false   #是否渲染_drafts目录下的文章，默认为false</span><br><span class="line">post_asset_folder: false   #启动 Asset 文件夹</span><br><span class="line">relative_link: false   #把链接改为与根目录的相对位址，默认false</span><br><span class="line">future: true   #显示未来的文章，默认false</span><br><span class="line">highlight:   #代码块的设置 </span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag   分类和标签的设置</span><br><span class="line">default_category: uncategorized   #默认分类</span><br><span class="line">category_map:   #分类别名</span><br><span class="line">tag_map:   #标签别名</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination 分页</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10   #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class="line">pagination_dir: page   #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom       #feed 类型 (atom/rss2)</span><br><span class="line">  path: atom.xml   #rss 路径</span><br><span class="line">  limit: 20        #在 rss 中最多生成的文章数(0显示所有)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">type: git </span><br><span class="line">  repository: https://github.com/imwillxue/imwillxue.github.com.git </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>主题配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Place your favicon.ico to /source directory.</span><br><span class="line">favicon: /favicon.ico   #站标  可以放在hexo文件夹下的/source里</span><br><span class="line"></span><br><span class="line"># Set default keywords (Use a comma to separate)</span><br><span class="line">keywords: &quot;为学,willxue,willxue.top&quot;  #网站关键字</span><br><span class="line"></span><br><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss:  #rss这里不设置 引文站点配置文件已经配置了 需要安装插件</span><br><span class="line"></span><br><span class="line"># Specify the date when the site was setup</span><br><span class="line">since: 1990  #网站时间 从xx开始 类似 1990-2016</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running hexo in a subdirectory (e.g. domain.tld/blog)</span><br><span class="line"># Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )</span><br><span class="line">menu: #菜单路径设置 如果hexo在二级目录放置要去掉/</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives #归档</span><br><span class="line">  tags: /tags #标签</span><br><span class="line">  categories: /categories  #分类</span><br><span class="line">  about: /about #关于我</span><br><span class="line">  commonweal: /404.html  #公益404</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line"># Icon Mapping:</span><br><span class="line">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="line">#   Key is the name of menu item and value is the name of FontAwsome icon.</span><br><span class="line">#   When an question mask icon presenting up means that the item has no mapping icon.</span><br><span class="line">menu_icons:  #icon图标</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes  #next的三个scheme</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Sidebar Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Social links   #社交链接</span><br><span class="line">social:</span><br><span class="line">  GitHub: </span><br><span class="line">  Weibo:</span><br><span class="line">  Others:</span><br><span class="line"></span><br><span class="line"># Social Icons  #社交的图标</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mappings</span><br><span class="line">  GitHub: github</span><br><span class="line">  Twitter: twitter</span><br><span class="line">  Weibo: weibo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.jpg</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</span><br><span class="line"># default : /images/default_avatar.jpg</span><br><span class="line">avatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># TOC in the Sidebar  #文章自动显示目录</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.  #目录是否自动显示数字序号</span><br><span class="line">  number: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http://creativecommons.org/  #自由协议</span><br><span class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">#creative_commons: by-nc-sa</span><br><span class="line">#creative_commons:</span><br><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Sidebar Display, available value:</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  Totally remove sidebar including sidebar toggle icon.</span><br><span class="line">  display: post</span><br><span class="line">  #display: always</span><br><span class="line">  #display: hide</span><br><span class="line">  #display: remove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Misc Theme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Custom Logo.</span><br><span class="line"># !!Only available for Default Scheme currently.</span><br><span class="line"># Options:</span><br><span class="line">#   enabled: [true/false] - Replace with specific image</span><br><span class="line">#   image: url-of-image   - Images&apos;s url</span><br><span class="line">custom_logo:</span><br><span class="line">  enabled: false</span><br><span class="line">  image:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Code Highlight theme</span><br><span class="line"># Available value:</span><br><span class="line">#    normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: night</span><br><span class="line"></span><br><span class="line"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span><br><span class="line">scroll_to_more: true</span><br><span class="line"></span><br><span class="line"># Automatically Excerpt</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br><span class="line"></span><br><span class="line"># Use Lato font</span><br><span class="line">use_font_lato: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Third Party Services Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Swiftype Search API Key</span><br><span class="line">#swiftype_key:</span><br><span class="line"></span><br><span class="line"># Baidu Analytics ID</span><br><span class="line">#baidu_analytics:</span><br><span class="line"></span><br><span class="line"># Duoshuo ShortName</span><br><span class="line">duoshuo_shortname: imwillxue</span><br><span class="line"></span><br><span class="line"># Disqus</span><br><span class="line">#disqus_shortname:</span><br><span class="line"></span><br><span class="line"># Baidu Share</span><br><span class="line"># Available value:</span><br><span class="line">#    button | slide</span><br><span class="line">#baidushare:</span><br><span class="line">##  type: button</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">#jiathis:</span><br><span class="line">#add_this_id:</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">duoshuo_share: true</span><br><span class="line"></span><br><span class="line"># Google Webmaster tools verification setting</span><br><span class="line"># See: https://www.google.com/webmasters/</span><br><span class="line">#google_site_verification:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">#google_analytics:</span><br><span class="line"></span><br><span class="line"># CNZZ count</span><br><span class="line">#cnzz_siteid:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Make duoshuo show UA</span><br><span class="line"># user_id must NOT be null when admin_enable is true!</span><br><span class="line"># you can visit http://dev.duoshuo.com get duoshuo user id.</span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: true</span><br><span class="line">  user_id: 6262178932196377345</span><br><span class="line">  admin_nickname: 神</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Facebook SDK Support.</span><br><span class="line"># https://github.com/iissnan/hexo-theme-next/pull/410</span><br><span class="line">facebook_sdk:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id:       #&lt;app_id&gt;</span><br><span class="line">  fb_admin:     #&lt;user_id&gt;</span><br><span class="line">  like_button:  #true</span><br><span class="line">  webmaster:    #true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz</span><br><span class="line">  app_key: AMcYaNHy9Y5OdH42k0d4uSED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Tencent analytics ID</span><br><span class="line"># tencent_analytics:</span><br><span class="line"></span><br><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br><span class="line"></span><br><span class="line">## 文章末尾是否显示打赏按钮</span><br><span class="line">donate: </span><br><span class="line">  enable: true</span><br><span class="line">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</span><br><span class="line">  alipay: </span><br><span class="line">  wechat: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line">#! DO NOT EDIT THE FOLLOWING SETTINGS</span><br><span class="line">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Motion</span><br><span class="line">use_motion: true</span><br><span class="line"></span><br><span class="line"># Fancybox</span><br><span class="line">fancybox: true</span><br><span class="line"></span><br><span class="line"># Static files</span><br><span class="line">vendors: vendors</span><br><span class="line">css: css</span><br><span class="line">js: js</span><br><span class="line">images: images</span><br><span class="line"></span><br><span class="line"># Theme version</span><br><span class="line">version: 0.5.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。&lt;/p&gt;
&lt;h2 id=&quot;基
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="node.js" scheme="http://qianyouyou.cn/tags/node-js/"/>
    
      <category term="html/css" scheme="http://qianyouyou.cn/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>基于github搭建专属于自己的博客（基础篇）</title>
    <link href="http://qianyouyou.cn/2018/04/28/2018-04-28-1/"/>
    <id>http://qianyouyou.cn/2018/04/28/2018-04-28-1/</id>
    <published>2018-04-28T09:11:28.000Z</published>
    <updated>2018-05-02T15:17:20.619Z</updated>
    
    <content type="html"><![CDATA[<p>以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程：</p><h2 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h2><p>1.搭建前的准备（包括node.js，git，github账户的配置）</p><p>2.安装hexo</p><p>3.配置hexo</p><p>4.连接hexo与github page</p><p>5.发布文章</p><h3 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h3><p>1.安装node.js</p><p>2.安装git</p><p>3.github账户管理</p><h4 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h4><p>下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>。根据自己电脑的配置自行安装。</p><p>安装完成后打开终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>进行是否安装成功测试。如不正确，回头检查哪一步错误。</p><h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>官网。自行安装。</p><p>安装完成后打开终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>以上步骤进行是否安装成功。如果安装失败自行面壁。</p><h4 id="github管理"><a href="#github管理" class="headerlink" title="github管理"></a>github管理</h4><p>已拥有账号可跳过注册此步</p><p>打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>进行注册。</p><p>登录后点击右上角加号，选择New repository新建代码库。</p><p>进入代码库创建页面：</p><p>在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。</p><p><strong>注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io</strong></p><p>建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹</p><p>在命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g   //进行安装</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v   //检验是否安装成功。</span><br></pre></td></tr></table></figure><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init   //初始化该文件夹</span><br></pre></td></tr></table></figure><p>看到后面的“Start blogging with Hexo！”证明正在执行。</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install   //安装所需要的组件</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g   //生成</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>开启服务器，访问该网址，正式体验Hexo</p><h3 id="连接hexo与github-page"><a href="#连接hexo与github-page" class="headerlink" title="连接hexo与github page"></a>连接hexo与github page</h3><p>设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。</p><p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p><p>输入ls，列出该文件下的内容</p><p>输入ssh-keygen -t rsa -C “<a href="mailto:xxxxxx@xx.com" target="_blank" rel="noopener">xxxxxx@xx.com</a>”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。</p><p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p><p>登录Github，点击头像下的settings，添加ssh</p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><p><strong>问题：</strong>假如ssh-key配置失败，那么只要以下步骤就能完全解决</p><p>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key</p><p>重新生成ssh密钥对<br>ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“</p><p>接下来正常操作<br>在github上添加公钥public-key:<br>1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板<br>2、在github上添加公钥时，直接复制即可<br>3、保存</p><p>测试：<br>在终端 ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><p>配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</p><p>repo值是你在github项目里的ssh（右下角）</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>新建一篇博客，在cmd执行命令：hexo new post “博客名”</p><p>这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件</p><p>在生成以及部署文章之前，需要安装一个扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   // 生成</span><br><span class="line">hexo d   // 部署</span><br></pre></td></tr></table></figure><p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d   //在部署前先生成</span><br></pre></td></tr></table></figure><p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。</p><p>到此为止，最基本的也是最全面的hexo+github搭建博客完结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程：&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="node.js" scheme="http://qianyouyou.cn/tags/node-js/"/>
    
      <category term="html/css" scheme="http://qianyouyou.cn/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://qianyouyou.cn/2018/04/24/2018-04-24/"/>
    <id>http://qianyouyou.cn/2018/04/24/2018-04-24/</id>
    <published>2018-04-24T01:22:39.624Z</published>
    <updated>2018-04-28T11:01:20.104Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://qianyouyou.cn/">My Blog</a>! This is my very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://qianyouyou.cn/&quot;&gt;My Blog&lt;/a&gt;! This is my very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="npm" scheme="http://qianyouyou.cn/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构]堆的基本操作</title>
    <link href="http://qianyouyou.cn/2018/04/23/2018-04-23/"/>
    <id>http://qianyouyou.cn/2018/04/23/2018-04-23/</id>
    <published>2018-04-23T14:42:25.000Z</published>
    <updated>2018-05-07T12:29:01.238Z</updated>
    
    <content type="html"><![CDATA[<p>堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p><p>1.堆总是一棵完全二叉树。</p><p>2.堆中某个节点的值总是不大于或不小于其父节点的值。</p><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p><p>本次操作具体以小根堆为例进行演示。</p><h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>一般采用树组存储，i结点的父结点下标为( i - 1 ) / 2。左子树的下标为2 <em> i + 1,右子树的下标为2 </em> i + 2。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/7-1.png" alt=""></p><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><h3 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h3><p>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于<strong>直接插入排序</strong>中将一个数据并入到有序区间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//  新加入i结点  其父结点为(i - 1) / 2  </span><br><span class="line">void MinHeapFixup(int a[], int i)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j, temp;  </span><br><span class="line">    </span><br><span class="line">    temp = a[i];  </span><br><span class="line">    j = (i - 1) / 2;      //父结点  </span><br><span class="line">    while (j &gt;= 0 &amp;&amp; i != 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (a[j] &lt;= temp)  </span><br><span class="line">            break;  </span><br><span class="line">          </span><br><span class="line">        a[i] = a[j];     //把较大的子结点往下移动,替换它的子结点  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = (i - 1) / 2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    a[i] = temp;</span><br></pre></td></tr></table></figure><p>插入时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MinHeapAddNumber(int a[], int n, int nNum)  </span><br><span class="line">&#123;  </span><br><span class="line">    a[n] = nNum;  </span><br><span class="line">    MinHeapFixup(a, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h3><p>堆中每次都只能删除根结点，即第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  </span><br><span class="line">void MinHeapFixdown(int a[], int i, int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j, temp;  </span><br><span class="line">  </span><br><span class="line">    temp = a[i];  </span><br><span class="line">    j = 2 * i + 1;  </span><br><span class="line">    while (j &lt; n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的  </span><br><span class="line">            j++;  </span><br><span class="line">  </span><br><span class="line">        if (a[j] &gt;= temp)  </span><br><span class="line">            break;  </span><br><span class="line">  </span><br><span class="line">        a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = 2 * i + 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    a[i] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">//在最小堆中删除数  </span><br><span class="line">void MinHeapDeleteNumber(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    Swap(a[0], a[n - 1]);  </span><br><span class="line">    MinHeapFixdown(a, 0, n - 1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h3><p>有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//建立最小堆  </span><br><span class="line">void MakeMinHeap(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (int i = n / 2 - 1; i &gt;= 0; i--)  </span><br><span class="line">        MinHeapFixdown(a, i, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p><p>由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void MinheapsortTodescendarray(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (int i = n - 1; i &gt;= 1; i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Swap(a[i], a[0]);  </span><br><span class="line">        MinHeapFixdown(a, 0, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：&lt;/p&gt;
&lt;p&gt;1.堆总是一棵完全二叉树。&lt;/p&gt;
&lt;p&gt;2.堆中某个节点的值总是不大于或不小于其父节点的值。&lt;/p&gt;
&lt;p&gt;将根节点最大的堆叫做最大堆或大根堆
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://qianyouyou.cn/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
