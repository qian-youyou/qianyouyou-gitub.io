<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2019-04-29T10:31:32.515Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机系统漫游——&quot;Hello,World&quot;的漫漫计算机旅程</title>
    <link href="http://qianyouyou.cn/2019/04/29/2019-04-29/"/>
    <id>http://qianyouyou.cn/2019/04/29/2019-04-29/</id>
    <published>2019-04-29T07:52:39.000Z</published>
    <updated>2019-04-29T10:31:32.515Z</updated>
    
    <content type="html"><![CDATA[<p>欲练Programmer，必先Coder。Coder+Programmer，方成Developer。</p><p>每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。</p><p>本文主要介绍一个简简单单的”Hello,World”程序是如何在计算机系统乃至网络跑起来的。（当然不会写的太复杂啦，毕竟这是一个漫长的过程）。</p><p>翠花，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;Hello,World\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>hello程序的生命周期是从一个hello.c的源文件开始的。而源程序实际是一个由0、1组成的位（比特）序列，8位一组，称为字节。每个字节表示程序中的某些文本字节。大多数系统以ASCII码表示文本字符。例如以上代码就可以ASII表示为：</p><table><thead><tr><th>#</th><th>i</th><th>n</th><th>c</th><th>l</th><th>u</th><th>d</th><th>e</th><th>SP</th><th>&lt;</th><th>s</th><th>t</th><th>d</th><th>i</th><th>o</th><th>.</th></tr></thead><tbody><tr><td>35</td><td>105</td><td>110</td><td>99</td><td>108</td><td>117</td><td>100</td><td>101</td><td>32</td><td>60</td><td>115</td><td>116</td><td>100</td><td>105</td><td>111</td><td>46</td></tr><tr><td>h</td><td>&gt;</td><td>\n</td><td>i</td><td>n</td><td>t</td><td>SP</td><td>m</td><td>a</td><td>i</td><td>n</td><td>(</td><td>）</td><td>{</td><td>\n</td><td>SP</td></tr><tr><td>104</td><td>62</td><td>10</td><td>105</td><td>110</td><td>116</td><td>32</td><td>109</td><td>97</td><td>105</td><td>110</td><td>40</td><td>41</td><td>123</td><td>10</td><td>32</td></tr><tr><td>SP</td><td>SP</td><td>SP</td><td>p</td><td>r</td><td>i</td><td>n</td><td>t</td><td>f</td><td>(</td><td>“</td><td>H</td><td>e</td><td>l</td><td>l</td><td>o</td></tr><tr><td>32</td><td>32</td><td>32</td><td>112</td><td>114</td><td>105</td><td>110</td><td>116</td><td>102</td><td>40</td><td>34</td><td>72</td><td>101</td><td>108</td><td>108</td><td>111</td></tr><tr><td>,</td><td>W</td><td>o</td><td>r</td><td>l</td><td>d</td><td>\</td><td>n</td><td>“</td><td>)</td><td>;</td><td>\n</td><td>SP</td><td>SP</td><td>SP</td><td>SP</td></tr><tr><td>44</td><td>87</td><td>111</td><td>114</td><td>108</td><td>100</td><td>92</td><td>110</td><td>34</td><td>41</td><td>59</td><td>10</td><td>32</td><td>32</td><td>32</td><td>32</td></tr><tr><td>r</td><td>e</td><td>t</td><td>u</td><td>r</td><td>n</td><td>SP</td><td>0</td><td>;</td><td>\n</td><td>}</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>114</td><td>101</td><td>116</td><td>117</td><td>114</td><td>110</td><td>32</td><td>48</td><td>59</td><td>10</td><td>125</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>hello.c是以字节序的方式存储在文件中的。系统中的所有信息（磁盘文件，用户信息，网络传输数据等）均由一串比特表示。区分不同数据对象的唯一方式是读这些数据对象时的上下文。比如不同的上下文中，一个同样的字节序列可能表示整数，浮点数，字符串或者机器指令。</p><h1 id="程序到可执行文件的过程"><a href="#程序到可执行文件的过程" class="headerlink" title="程序到可执行文件的过程"></a>程序到可执行文件的过程</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欲练Programmer，必先Coder。Coder+Programmer，方成Developer。&lt;/p&gt;
&lt;p&gt;每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。&lt;/p&gt;
&lt;p&gt;本文主要介绍一个简简
      
    
    </summary>
    
    
      <category term="修仙笔记" scheme="http://qianyouyou.cn/tags/%E4%BF%AE%E4%BB%99%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机系统" scheme="http://qianyouyou.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>大话存储器</title>
    <link href="http://qianyouyou.cn/2019/04/27/2019-04-27/"/>
    <id>http://qianyouyou.cn/2019/04/27/2019-04-27/</id>
    <published>2019-04-27T11:04:49.000Z</published>
    <updated>2019-04-28T07:39:18.813Z</updated>
    
    <content type="html"><![CDATA[<p>面试时总在这里吃亏，对此，本人花了两天时间彻彻底底把操作系统书进程与存储器部分看了一遍，废话不多说，直接进入正题吧。</p><h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>首先得声明，在引入虚拟存储器之前，存储器通常是将整个进程所有资源引入内存的。</p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27.png" alt=""></p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><ol><li><p>绝对装入方式</p><p>编译程序将产生绝对地址的目标代码根据地址将程序和数据存入内存。</p><ol><li>编程人员要熟悉内存。</li><li>程序在内存中不能移动。</li><li>不适用于多道程序设计环境。</li></ol></li><li><p>可重定位装入方式（静态）</p><p>编译程序将产生相对地址的目标代码，装入时需要地址映射，地址变换只在装入时一次性完成，以后不再改变。</p><ol><li>适用于多道程序环境。</li><li>程序在内存中不能移动。</li></ol></li><li><p><strong>动态运行时装入方式</strong></p><p>编译程序将产生相对地址的目标代码，装入时并不立即把相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时才运行。</p><ol><li>程序装入内存后可移动。</li></ol></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol><li><p>静态链接方式</p><p>程序运行前将各目标模块及所需库装配成一个完整模块且不再分开。</p></li><li><p>装入时动态链接</p><p>边装入边链接。（假如没有用到某一模块，也会装入内存，所有才有了方法3）</p></li><li><p><strong>运行时动态链接</strong></p><p>将链接推迟到程序运行时，如果链接到哪一模块，则再将该模块装入内存。（加快装入过程，节省空间）</p></li></ol><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol><li>单一连续分配</li><li>固定分区分配</li><li><strong>动态分区分配</strong></li></ol><h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><h4 id="首次适应算法-First-Fit"><a href="#首次适应算法-First-Fit" class="headerlink" title="首次适应算法(First Fit):"></a>首次适应算法(First Fit):</h4><p>从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</p><p>特点<br>该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。</p><p>缺点<br>低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销</p><h4 id="下次适应（next-fit）算法"><a href="#下次适应（next-fit）算法" class="headerlink" title="下次适应（next fit）算法"></a>下次适应（next fit）算法</h4><p>也称“临近适应”算法，其工作方式和最先适应算法相同（最先适应也称首次适应算法。它总是最先找到的、满足存储要求的那个空闲分区作为分配对象。），不同的是每次找到合适的空闲的分区时就记住它的位置，以便下次就从该位置开始往下查找，而不是每次都像最先适应算法那样从头开始查找。这种算法的总体结果通常要比最先适应算法差。由于它经常会在内存的末尾分配存储分区，使位于存储空间末尾的最大分区被撕裂称小的外部碎片，因此必须经常不断地进行存储紧凑。在该算法中应采取循环查找方式，即最后上个空闲区的大小仍不能满足要求时，应再从第一个空闲区开始查找，故又称为循环造就算法。</p><h4 id="最佳适应算法（Best-Fit）："><a href="#最佳适应算法（Best-Fit）：" class="headerlink" title="最佳适应算法（Best Fit）："></a>最佳适应算法（Best Fit）：</h4><p>它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</p><p>Best fit算法等价于装箱问题，举例如下：</p><p>装箱问题：有体积为V的箱子N个，体积为Vi的物品M个，求使得物品全部能够装入箱子，箱子数量的最小值。<br>假设 V=6 N=10，V1，V2，…,V10分别为：3 4 4 3 5 1 2 5 3 1。计算过程如下：<br>第一步按物品体积降序排序：5 5 4 4 3 3 3 2 1 1<br>第二步：取未装箱的最大值5装入第一个箱子。<br>第三步：判断第一个箱子是否已满，不满且剩余空间为1，搜寻剩下体积小于等于1的物品填入箱子1，箱子1填满。<br>第四步：重复第二，第三步，直到所有物品装入箱子为止，得到箱子数量为6.<br>6即时本例N的最小值。</p><h4 id="最坏适应算法（worst-fit）"><a href="#最坏适应算法（worst-fit）" class="headerlink" title="最坏适应算法（worst fit）"></a>最坏适应算法（worst fit）</h4><p>最坏适应分配算法要扫描整个空闲分区或链表，总是挑选一个最大的空闲分区分割给作业使用。该算法要求将所有的空闲分区按其容量从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。</p><p>优点：可使剩下的空闲分区不至于太小，产生碎片的几率最小，对中、小作业有利，同时该算法查找效率很高。</p><p>缺点：会使存储器中缺乏大的空闲分区。</p><p>最坏适应算法与首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。</p><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><h4 id="快速适应算法（分类搜索法）"><a href="#快速适应算法（分类搜索法）" class="headerlink" title="快速适应算法（分类搜索法）"></a>快速适应算法（分类搜索法）</h4><p>该算法就是将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样的系统中存在多个空闲分区链表。同时，在内存总设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。</p><p>该算法在搜索可分配的空闲分区时分为两步：第一步是根据进程的长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。另外，该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。优点是查找效率高。缺点是在分区归还时的算法复杂，系统开销大。此外，该算法在分配空闲分区时，是以进程为单位的，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少的存在一定的浪费。这是典型的以空间换时间的做法。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂，通常2的m次方是整个可分配内存的大小。假设系统的的可利用空间容量为2的m次方，则当系统开始运行时，整个内存区是一个大小为2的m次方的空闲分区。在系统运行过程中，由于不断地划分，将会形成若个个不连续的空闲分区，将这些分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。</p><p>当需要为进程分配一个长度大小为n的存储空间时，首先计算一个i值，使2的i-1次方小于n小于等于2的i次方，然后再空闲分区大小为2的i次方的空闲分区链表中查找。</p><p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法号。而其空间性能，由于对空闲分区进行合并，减少了空闲分区，提高了空间分区的可使用率，故由于快速适应算法，比顺序搜索法略差。</p><p>总结：虽然在当前的操作系统中，主要还是采用离散分配方式的分页和分段机制的虚拟内存机制，因为该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，目前仍然被广泛使用。</p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>由于分类搜索算法和伙伴系统算法中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在每一张管理索引表中查找到所需要的空间大小所对应的表项，从中得到对应的空间内分区链表表头指针，从而通过查找一个空闲分区。如果对空闲分区分类比较细，则相应索引表的表项也就较多，因此会显著的增加搜索索引表的表项的时间开销。</p><p>哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</p><p>当进行空闲分区分配时，根据所需要的空闲 分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol><li>紧凑</li><li>动态重定位</li><li>动态重定位分区分配算法</li></ol><h2 id="离散式存储管理方式"><a href="#离散式存储管理方式" class="headerlink" title="离散式存储管理方式"></a>离散式存储管理方式</h2><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><h4 id="连续分配存储管理方式产生的问题"><a href="#连续分配存储管理方式产生的问题" class="headerlink" title="连续分配存储管理方式产生的问题"></a><strong>连续分配存储管理方式产生的问题</strong></h4><p>在分区存储管理中，要求把进程放在一个连续的存储区中，因而会产生许多碎片。</p><h4 id="碎片问题的解决方法"><a href="#碎片问题的解决方法" class="headerlink" title="碎片问题的解决方法"></a>碎片问题的解决方法</h4><p>（1）拼接/紧凑技术—-代价较高。</p><p>（2）离散分配方式—允许将作业/进程离散放到多个不相邻接的分区中，就可以避免拼接。</p><h4 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h4><p>分页式存储管理：离散分配的基本单位是页</p><p>分段式存储管理：离散分配的基本单位是段</p><p>段页式存储管理：离散分配的基本单位是段、页</p><h4 id="什么是页"><a href="#什么是页" class="headerlink" title="什么是页"></a>什么是页</h4><p>将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面,页面大小由地址结构（逻辑）决定 ，并为各页从0开始编号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-1.png" alt=""></p><h4 id="什么是块"><a href="#什么是块" class="headerlink" title="什么是块"></a>什么是块</h4><p>内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（frame），同样从0开始编号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-2.png" alt=""></p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>在为进程分配内存时,以块为单位,将进程中若干页装入到多个不相邻的块中,最后一页常装不满一块而出现页内碎片。</p><h4 id="页表的出现"><a href="#页表的出现" class="headerlink" title="页表的出现"></a>页表的出现</h4><p>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。一个页表中包含若干个表目，1.表目的自然序号对应于用户程序中的页号。2.表目中的块号是该页对应的物理块号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-3.png" alt=""></p><h4 id="内存地址的获取"><a href="#内存地址的获取" class="headerlink" title="内存地址的获取"></a>内存地址的获取</h4><p>以页号查页表，得到对应页装入内存的块号。即可求出：<strong>内存地址＝物理块号×页大小＋页内地址</strong>。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-4.png" alt=""></p><p>例:在采用页式存储管理的系统中,某作业J的逻辑地址空间为4页(每页2048字节),且已知该作业的页面映像表如下:</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>4</td></tr><tr><td>2</td><td>6</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><p>试借助地址变换图求出有效逻辑地址4865所对应的物理地址.</p><p>解:页号  4865/2048=2   页内位移   4865%2048=769，过程如下：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-5.png" alt=""></p><p>从上面我们可以看出：CPU要想获取一个数据时，必须两次访问内存：</p><p>1、从内存中的页表中，寻找对应的物理块号，将物理块号与页内地址组合成物理地址。</p><p>2、根据组合成的物理地址，来获取数据。</p><p>为了提高效率呢，就引进了块表，什么是快表呢？</p><p>在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器”或“快表”。</p><p>在引入快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题，。总体上来说，还是减少了访问内存的时间。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-6.png" alt=""></p><h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><h4 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h4><p>引入分段存储管理方式，主要是为了满足用户和程序员的下述一系列需要：</p><p>1）<strong>方便编程</strong></p><p>通常，用户把自己的作业按照<strong>逻辑关系</strong>划分为若干个段，每个段都是<strong>从0开始</strong>编址，并有自己的<strong>名字</strong>和<strong>长度</strong>。</p><p>因此，希望要访问的逻辑地址是由<strong>段名</strong>（段号）和<strong>段内偏移量</strong>（段内地址）决定的。</p><p>2）<strong>信息共享</strong></p><p>在实现对<strong>程序和数据的共享</strong>时，是以<strong>信息的逻辑单位为基础的</strong>。比如共享某个例程和函数，分页系统中的“页”只是存放信息的<strong>物理单位</strong>（块），</p><p>并无完整的意义，不便于实现共享，然而<strong>段却是信息的逻辑单位</strong>。</p><p>3）<strong>信息保护</strong></p><p>信息保护同样是<strong>对信息的逻辑单位进行保护</strong>，因此，分段管理方式能更有效和方便的实现信息保护功能。</p><p>4）<strong>动态增长</strong></p><p>在实际应用中，往往有些段，特别是数据段，在使用过程中会<strong>不断地增长</strong>，而事先又无法确切地知道数据段会增长到多大。前面的几种存储</p><p>管理方式都难以应付这种动态增长的情况，分段存储管理方式能较好的解决这一问题。</p><p>5）<strong>动态链接</strong></p><p>动态链接是指<strong>在作业运行之前</strong>，并不把几个目标程序段链接起来。<strong>要运行时</strong>，先将<strong>主程序</strong>所对应的目标程序装入内存并启动运行，当运行过程</p><p>中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。<strong>可见，动态链接也要求以段作为管理的单位。</strong></p><h4 id="分段和段表"><a href="#分段和段表" class="headerlink" title="分段和段表"></a>分段和段表</h4><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，<strong>每个段</strong> 定义了一组<strong>逻辑信息</strong>。每个段都有自己的名字，通常可用一个<strong>段号</strong>来</p><p>代替<strong>段名</strong>，<strong>每个段都从0开始编址</strong>，并采用<strong>一段连续的地址空间</strong>。段的长度由相应的逻辑信息组的长度决定，因而<strong>各段长度不等</strong>。整个作业的</p><p>地址空间分成多个段，是<strong>二维的</strong>。</p><p>在<strong>动态分区</strong>（可变分区）分配方式中，系统为<strong>整个进程</strong>分配一个连续的内存空间。而在分段式存储管理系统中，则是为<strong>每个分段</strong>分配一个</p><p>连续的分区，而进程中的各个段可以离散地装入内存中不同的分区中。为使程序能正常运行，即能从物理内存中找出每个逻辑段所对应的位置，</p><p>应像分页系统那样，<strong>在系统中为每个进程建立一张段映射表</strong>，简称“<strong>段表</strong>”。</p><p>每个段在表中占有一个表项，其中记录了该段在内存中的<strong>起始地址</strong>（“基址”）和<strong>段长</strong>（字节）。段表一般放在内存中。在配置了段表后，</p><p>执行中的进程可通过查找段表找到每个段所对应的内存区。可见，段表是用于实现从<strong>逻辑段</strong>到<strong>物理内存区</strong>的映射。</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong>，用于存放<strong>段表始址</strong> 和<strong>段表长度TL</strong>。在进行地址变换时，</p><p>系统将逻辑地址中的<strong>段号S（0～TL-1）</strong>与<strong>段表长度TL</strong>进行比较。–  若S&gt;=TL，表示<strong>段号太大，</strong>是访问越界，于是产生越界中断信号；</p><p>若未越界，则根据段表的始址和该段的段号，计算出该段<strong>对应段表项的位置</strong>（段表的始址+段号x段表项的长度），从中读出该段在内存的</p><p>起始地址，然后再检查段内地址d是否超过该段的<strong>段长SL</strong>。若超过，即d&gt;SL,同样发出越界中断信号；若未越界，则将该段的<strong>基址</strong>与<strong>段内地址d</strong></p><p>相加，即可得到要访问的<strong>内存物理地址</strong>。</p><p>像分页系统一样，当段表放在内存中时，每当要访问一个数据，都需<strong>访问两次内存</strong>（第一次是得到物理地址，第二次是从地址中取数据），</p><p>从而极大地降低了计算机的速率。解决方法是再<strong>增设一个联想存储器</strong>（TLB），用于保存最近常用的段表项。一般情况下是段比页大，因而</p><p><strong>段表项</strong>的数目比页表项的数目少，需要的TLB也相对较小，可以显著的减少存取数据的时间。</p><h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><p>分页和分段系统都采用<strong>离散</strong>分配方式，且都要通过<strong>地址映射机构来</strong>实现地址变换。但在概念上两者完全不同，主要表现在3个方面：</p><p>– 1）页是信息的<strong>物理**</strong>单位<strong>，分页是为实现离散分配方式，消减外部碎片，提高内存的利用率。</strong>分页仅仅是由于系统管理的需要而不是用户的需要。**</p><p>段则是信息的<strong>逻辑单位</strong>，它含有一组其意义相对完整的信息。<strong>分段的目的是为了更好的满足用户的需要。</strong></p><p>– 2）页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；</p><p>而<strong>段的长度不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p><p>– 3）<strong>分页</strong>的作业地址空间是<strong>一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而<strong>分段</strong>的作业地址空间<strong>是二维的</strong>，</p><p>程序员在标识一个地址时，既需给出<strong>段名</strong>，又需给出<strong>段内地址</strong>。</p><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><p><strong>段的共享：即允许若干个进程共享一个或多个分段。</strong></p><p><strong>可重入代码</strong>（Reentrant Code）又称为“纯代码”（Pure Code），是一种<strong>允许多个进程同时访问的代码</strong>。为使各个进程所执行的代码完全相同，</p><p>绝对不允许可重入代码在执行中有任何改变。因此，<strong>可重入代码</strong>是一种<strong>不允许任何进程对它进行修改的代码</strong>。</p><p>—- 但事实上，大多数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量及数组等。为此，在每个进程中，都必</p><p>须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区，这样，程序在执行时，只需对该数据区（属于该进程私有）中的内容进行修改，并</p><p>不去改变共享的代码，这时的可共享代码即成为可重入码。</p><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>用户程序<strong>先分段</strong>，每个段内部<strong>再分页（内部原理同基本的分页、分段相同）</strong></p><p><strong><img src="http://img.blog.csdn.net/20131031091950640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></strong></p><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分三部分：段号、段内页号、页内地址</p><p><img src="http://img.blog.csdn.net/20131031091956234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h4 id="地址映射（逻辑地址—-gt-物理地址）"><a href="#地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="地址映射（逻辑地址—&gt;物理地址）"></a>地址映射（逻辑地址—&gt;物理地址）</h4><p>³ <strong>逻辑地址</strong>—– &gt;段号、段内页号、业内地址</p><p>³ 段表寄存器— &gt;段表始址</p><p>³ 段号+段表始址—- &gt;页表始址</p><p>³ 页表始址+段内页号—–&gt;存储块号</p><p>³ 块号+页内地址——&gt;<strong>物理地址</strong></p><p> <img src="http://img.blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h4 id="地址变换原理及步骤"><a href="#地址变换原理及步骤" class="headerlink" title="地址变换原理及步骤"></a>地址变换原理及步骤</h4><p><img src="http://img.blog.csdn.net/20131031092012156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>请看上图，给出逻辑地址的段号、页号、页内地址，开始进行地址变换：</p><p>1)       在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器</p><p>2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续</p><p>3)       由段号结合段表始址求出页表始址和页表大小</p><p>4)       页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续</p><p>5)       由页表始址结合段内页号求出存储块号</p><p>6)       存储块号&amp;页内地址，即得物理地址</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存。</p><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>常规存储器要求将一个作业全部装入内存方能执行。而虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配方式，则需将作业装入一个连续的内存区域中。所以，虚拟存储器抖毫无例外建立在离散分配管理方式之上。</p><ol><li>请求分页存储管理方式。</li><li>请求分段存储管理方式。</li></ol><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>请求分页系统是建立在基本分页系统的基础上，为了能支持虚拟存储器功能而</p><p>添加了请求调页功能和页面置换功能。</p><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>在请求分页系统中所须要的主要数据结构是<strong>页表</strong>。其基本作用仍然是<strong>将用户地址空间中的逻辑地址变换为内存空间中的物理地址</strong>。因为仅仅将应用程序的一部分调入内存，另一部分仍在盘上，故须在页表中再添加若干项，供程序(数据)在换进、换出时參考。在请求分页系统中的每个页表项例如以下所看到的： </p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-0.png" alt="img"></p><ul><li><p>状态位 P：指示该页是否已调入内存。 供程序访问时参考</p></li><li><p>访问字段 A：记录本页在一段时间内被访问的次数或最近未被访问的时间。 供选择页面换出时参考</p></li><li><p>修改位 M：表示该页在调入内存后是否被修改过。若修改过，则置换该页时需重写该页至外存。 供置换页面时参考</p></li><li><p>外存地址：指出该页在外存上的地址。供调入该页时参考</p></li></ul><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当所要訪问的页面不在内存时，<strong>便产生一缺页中断，请求OS将所缺之页调入内存</strong>。缺页中断作为中断，它们相同须要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的差别，主要表如今以下两个方面：<br>(1) 在指令运行期间产生和处理中断信号。通常，<strong>CPU都是在一条指令运行完后，才检查是否有中断请求到达</strong>。若有，便去响应，否则，继续运行下一条指令。然而，缺页中断是在指令运行期间，发现所要訪问的指令或数据不在内存时所产生和处理的。 </p><p>(2) 一条指令在运行期间，可能产生多次缺页中断。在下图中示出了一个样例。如在运行一条指令COPY A TO B时，可能要产生6次缺页中断，当中指令本身跨了两个页面，A和B又分别各是一个数据块，也都跨了两个页面。基于这些特征，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续运行。 </p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-7.png" alt="img"></p><h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，再为实现虚拟存储器而添加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。下图表示出了请求分页系统中的地址变换过程。在进行地址变换时，首先去检索快表，试图从中找出所要訪问的页。若找到，便改动页表项中的訪问位。对于写指令，还须将改动位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-8.png" alt="img"></p><h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3><p>例：一个采用请求分页存储管理的计算机系统，其内存（实存）容量为 256M 字节，虚拟内存容量（给用户的最大地址空间）为 4G 字节，页面大小为 4K 字节，试问：</p><p>实存物理地址应设为多少位？<br>256M = 2^28，所以为28位</p><p>实存中有多少物理块？<br>256M/4K = 64K</p><p>实存中最大块号是多少？<br>64K-1</p><p>虚存地址应设多少位？<br>4G = 2^32，所以为32位</p><p>虚拟地址空间最多可以有多少页？<br>4G/4K = 1M</p><p>页内最大偏移量是多少？ </p><p>4k-1 = 4*1024-1 = 4095</p><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数指能保证进程正常运行所需的最小的物理块数，最小物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。</p><p>采用直接寻址方式，所需的最少物理块数为 2。一块是用于存放指令，另一块用于存放数据。</p><p>间接寻址时，至少要求有三个物理块。 （间接寻址中一些物理块放的是其它物理块的块号）</p><h4 id="物理块的分配策略"><a href="#物理块的分配策略" class="headerlink" title="物理块的分配策略"></a>物理块的分配策略</h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每个进程分配固定数目 n 的物理块，在整个运行中都不改变。如出现缺页则从该进程的页面中置换一页。</p><p>每个进程分配多少个物理块难以确定.</p><p>若太少，会频繁地出现缺页中断，降低了系统的吞吐量。</p><p>若太多，内存中驻留的进程数目减少，可能造成 CPU空闲或其它资源空闲的情况。</p><h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>为每个进程分配一定数目的物理块，但 OS 自留一空闲块队列，若发现缺页，则从空闲块队列中分配一空闲块与该进程，并调入缺页于其中。当空闲块队列用完时，OS 才从内存中任选择一页置换。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每个进程分配一定数目的物理块，若发现缺页，则从该进程的页面中置换一页，不会影响其它进程的运行。根据进程缺页率高低，则可增加或减少分配给该进程的物理块。</p><h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>预调页：将预计在不久之后便会被访问的页面预先调入内存。</p><p>进程的页一般存放在外存的一个连续区域中。一次调入若干个相邻的页会比一次调入一页更高效。</p><p>但如果调入的一批页面中的大多数都未被访问，则浪费了内存。</p><h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。但这种策略每次仅调入一页，须花费较大的系统开销，增加了启动磁盘 I/O 的频率。</p><h5 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h5><p>在请求分页系统中，外存分成了按离散分配方式存放文件的文件区和按连续分配方式存放对换页的对换区。进程发出缺页请求时，从何处将缺页调入内存呢？</p><p>对换区：如果系统有足够的对换区空间，运行前可将与进程相关的文件从文件区复制至对换区，以后缺页时全部从对换区调页。</p><p>文件区：如果系统没有足够的对换区空间，凡是不会被修改的文件，直接从文件区调页，不必回写（换出） 。对可能会修改的文件第一次直接从文件区调页，换出时换至对换区，以后从对换区调页。</p><p>UNIX 方式：凡未运行过的页面均从文件区调页，运行过的页面和换出的页面均从对换区调页。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）（理想置换算法）"><a href="#最佳置换算法（OPT）（理想置换算法）" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 </p><p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：<br>    7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1<br>进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。<br>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td></td><td>7</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>4</td><td></td><td></td><td>0</td><td></td><td></td><td>0</td><td></td><td></td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td></td><td></td><td>3</td><td></td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td></td><td>√</td><td></td></tr></tbody></table><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 </p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td>2</td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>0</td><td>0</td><td></td><td></td><td>7</td><td>7</td><td>7</td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>1</td><td>1</td><td></td><td></td><td>1</td><td>0</td><td>0</td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>2</td><td></td><td></td><td>2</td><td>2</td><td>1</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。<br>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</p><table><thead><tr><th>访问页面</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>物理块1</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td><td>4</td><td>5</td><td></td><td></td><td>,5’</td><td>5</td><td></td></tr><tr><td>物理块2</td><td></td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td><td>1</td><td></td><td></td><td>3</td><td>3</td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td>4</td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td></tr><tr><td></td><td></td><td>1</td><td>1</td><td>1</td><td></td><td></td><td>5</td><td>5</td><td>5</td><td>5</td><td>4</td><td>4</td></tr><tr><td>物理块2*</td><td></td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td></tr><tr><td>物理块3*</td><td></td><td></td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>物理块4*</td><td></td><td></td><td></td><td>4</td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p><strong>注意：内存的页面中“最老“的页面，会被新的网页直接覆盖，而不是“最老“的页面先出队，然后新的网页从队尾入队。</strong></p><h4 id="最近最久未使用（LRU）算法"><a href="#最近最久未使用（LRU）算法" class="headerlink" title="最近最久未使用（LRU）算法"></a>最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 </p><p>再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>1</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td></td><td>0</td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td></td><td>2</td><td></td><td>7</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td></tr></tbody></table><p>实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。<br>***LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p><h4 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<br>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。<br>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p><ol><li>最近未被访问，也未被修改(u=0, m=0)。</li><li>最近被访问，但未被修改(u=1, m=0)。</li><li>最近未被访问，但被修改(u=0, m=1)。</li><li>最近被访问，被修改(u=1, m=1)。</li></ol><p>算法执行如下操作步骤：</p><ol><li>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</li><li>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</li><li>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</li></ol><p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p><p>例题：</p><p>在5个页框上使用LRU页面替换算法，当页框初始为空时，引用序列为0、1、7、8、6、2、3、7、2、9、8、1、0、2，系统将发生（C）次缺页</p><p>​    A、13            B、12           C、11          D、8</p><p>解析：内存中驻留5个页框：</p><table><thead><tr><th>访问页面</th><th>0</th><th>1</th><th>7</th><th>8</th><th>6</th><th>2</th><th>3</th><th>7</th><th>2</th><th>9</th><th>8</th><th>1</th><th>0</th><th>2</th></tr></thead><tbody><tr><td>页框1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>页框2</td><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>页框3</td><td></td><td></td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>0</td><td>0</td></tr><tr><td>页框4</td><td></td><td></td><td></td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr><td>页框5</td><td></td><td></td><td></td><td></td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>是否缺页</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y(换页)</td><td>Y(换页)</td><td>N</td><td>N</td><td>Y(换页)</td><td>Y(换页)</td><td>Y(换页)</td><td>Y(换页)</td><td>N</td></tr></tbody></table><p> LRU是堆栈类的算法，最后访问的页面放在栈顶，可以得到答案为C。</p><p>编程思路：</p><p>1,用结构体成员记录访问的顺序，换页时选取times最大的那个替换掉。</p><p>struct LRU { int data; </p><p>　　　　　　　int times;};记录访问次序</p><p>struct queue{  LRU *p; int front; int rear</p><p>}Qe;</p><p>(1)队列未满时，依次添加新访问的页面，并Qe.p[i++].times++</p><p>(2)队列满了 a, 新访问的页面在队列中，times设为0，之前在它前面的LRU.times++</p><p>​                b, 新访问的页面不在队列中，需替换掉times最大的页面，并设新页面times=0，对列中其它页面times++</p><p>2,用队列中存放的位置表示最后访问时间（用线性表涉及大量元素移动，用链表好些）</p><p>队列未满时，依次压入；队列满，则查看对列中是否存在，若存在，将其移动到队尾，若不存在，删除队首页面，并在队尾加入新页面。</p><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="页面抖动（颠簸）"><a href="#页面抖动（颠簸）" class="headerlink" title="页面抖动（颠簸）"></a>页面抖动（颠簸）</h3><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p><h3 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h3><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p><p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试时总在这里吃亏，对此，本人花了两天时间彻彻底底把操作系统书进程与存储器部分看了一遍，废话不多说，直接进入正题吧。&lt;/p&gt;
&lt;h1 id=&quot;存储器管理&quot;&gt;&lt;a href=&quot;#存储器管理&quot; class=&quot;headerlink&quot; title=&quot;存储器管理&quot;&gt;&lt;/a&gt;存储器管理
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="系统编程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟存储器" scheme="http://qianyouyou.cn/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
      <category term="分页" scheme="http://qianyouyou.cn/tags/%E5%88%86%E9%A1%B5/"/>
    
      <category term="分段" scheme="http://qianyouyou.cn/tags/%E5%88%86%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>向死而生，知菜而后勇</title>
    <link href="http://qianyouyou.cn/2019/04/24/2019-04-24/"/>
    <id>http://qianyouyou.cn/2019/04/24/2019-04-24/</id>
    <published>2019-04-24T03:46:37.000Z</published>
    <updated>2019-04-27T15:44:02.790Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。</p><p>回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)</p><p>回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起起伏伏，体验感极差。说到经历的话，可以一句话来形容，便是以腾讯起，以腾讯终。当然，不是以腾讯录用而终，而是以被腾讯pass为终QYQ</p><p>这一个月里，虽然各种面试东跑西跑面的身心疲惫，但总的来说还是有收获的，至少让自己认清自己很菜qyq，当然这是开玩笑的啦。首先现在的我已经清楚未来要去的敌方以及要走的路了，而且在其中收获的面试经验是无法替代的。</p><p>还记得三月初腾讯们各种投简历带的我还不明白为什么要找实习便也跟着一起投。还记得第一次收到腾讯的面试通知，既兴奋又恐惧，当时还很稚嫩的我（丢不丢脸啊）收面试官小哥哥的照顾竟然莫名其妙过了。还记得西山居经历四次面试本来以为稳了，结果因为没有什么面试经验导致实习时间上的问题最终被刷，之后好长一段时间恐惧面试，不想面试。直到前两天腾讯正式批二面结束后，状态变为了HR面试，当时那个兴奋与感激啊，结果没过两天就又由HR面试变成了初试（嘿嘿，面试本就是大起大落，大落最差不过从头再来，所以说只要没拿到offer就不存在稳不稳）。不过渐渐的，我也明白了实习的意义。其实当初找实习纯粹是被氛围带起的，经过这么多面试之后，一方面发现自己还有很多方面需要学习与总结，另一方面渐渐也发现其实实不实习都无关紧要，做项目的话自己也可以做嘛，只要自己实力够强。而找实习后反而有点浪费学习时间，反正暂时也找不到，不如静下心来好好学习，自己做项目积累经验吧，为秋招做好准备。毕竟这样就可以做自己想做的产品了（偷笑）</p><p>现在制定计划，并以今天为起点，抓紧学习，之后就不找实习了，直接面向秋招。</p><p>重点学习内容：C++，Linux系统编程与网络编程，操作系统，计算机网络，编译原理，数据库。</p><p>项目：聊天室项目，云盘项目，内存池项目，5V5游戏项目</p><p>目前的资源：C++primer，深入理解计算机系统，图解TCP/IP，图解HTTP，LINUX高性能服务器编程，HeadFirst设计模式，STL源码剖析等等。</p><p>计划：</p><p>4月末——Linux系统编程与网络编程，操作系统</p><p>5月——深入了解计算机系统（操作系统，网络与编译原理）</p><p>6月——C++primer</p><p>7月——8月——项目，二遍复习</p><p>附上这一个月的心路历程（我的三体的一首词）</p><p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p><p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p><p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p><p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p><p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p><p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。&lt;/p&gt;
&lt;p&gt;回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)&lt;/p&gt;
&lt;p&gt;回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>进程的描述与控制VS处理机调度与死锁</title>
    <link href="http://qianyouyou.cn/2019/04/22/2019-04-22/"/>
    <id>http://qianyouyou.cn/2019/04/22/2019-04-22/</id>
    <published>2019-04-22T13:20:04.000Z</published>
    <updated>2019-04-27T15:43:45.613Z</updated>
    
    <content type="html"><![CDATA[<p>成也进程，败也进程，不为成败，只为进程。这是一篇凉文，面试正挂于此。哎，不多说了，直接进入正题吧。</p><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p>每个结点可用来表示一个进程或进程段，乃至一条语句，结点间的有向边则表示两个结点间存在偏序或前趋关系。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22-1.png" alt=""></p><p>例如上图P1与P2之间有前趋关系，所以P1与P2只能顺序执行。再如P2与P3之间没有前趋关系，所以P2与P3可以并发执行。</p><p>说白了就是有向无环图，可以利用拓扑排序进行执行。</p><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>简单理解，进程就是程序段+数据段+PCB。</p><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>由于多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并且具有间断性，以及运行结果不可在现性的特征。由此决定了程序是不能参与并发执行的，否则，程序的运行便失去了意义。为了能使程序并发执行，并且对并发执行的程序加以描述和控制，人们引入了进程。</p><p>为使每个并发执行程序（含数据）都能独立运行，在操作系统中加入一个专门的数据结构——进程控制块（Process Control Block，PCB）</p><p>系统利用PCB描述进程的基本情况和活动过程。一般情况下，我们把进程实体简称为进程，所谓创建进程就是创建进程实体中的PCB；撤销进程就是撤销进程的PCB。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机尚顺序执行是所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上执行的过程，<strong>它是系统执行资源分配和调度的一个独立单位</strong>。</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><strong>动态性</strong>：进程是进程实体的执行过程，由创建而生，调度而执行，撤销而亡。进程实体具有生命周期，而程序仅是一组有序命令的集合，存在于某种介质之上，因而是静态的。</li><li><strong>并发性</strong>：多个进程实体同存于内存之中，且能在一段时间同时运行。程序没有PCB，因而不能并发。</li><li><strong>独立性</strong>：进程实体是一个能独立运行，独立获得资源，独立接受调度的基本单位。而程序没有PCB，固不能执行以上操作。</li><li><strong>异步性</strong>：进程是按异步方式运行的，即按各自独立的、不可预知的速度推进，因而结果不可再现。为此，OS中引入进程的概念，并配置相应的同步机制。</li></ul><h3 id="状态及转换"><a href="#状态及转换" class="headerlink" title="状态及转换"></a>状态及转换</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.png" alt=""></p><h4 id="三基态："><a href="#三基态：" class="headerlink" title="三基态："></a>三基态：</h4><ul><li><strong>就绪状态</strong>：进程已处于准备好运行的状态，只差CPU，在就绪队列等待调度。</li><li><strong>执行状态</strong>：进程已获得CPU，并立即执行。</li><li><strong>阻塞状态</strong>：正在运行的进程由于发生某种事件（I/O请求，申请缓冲区失败等）暂时无法继续执行，而让受阻进程处于暂停状态。进入阻塞队列。阻塞时进程自身的主动行为。</li></ul><h4 id="创建与终止状态："><a href="#创建与终止状态：" class="headerlink" title="创建与终止状态："></a>创建与终止状态：</h4><ul><li><strong>创建状态</strong>：申请空白PCB，并向PCB填写控制和管理进程的信息，然后分配资源，最后转入就绪队列中。</li><li><strong>终止状态</strong>：等待操作系统善后处理，然后PCB清零，返还系统。</li></ul><h4 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.jpg" alt=""></p><p>当操作作用于某个进程时，该进程处于静止状态。</p><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><ol><li>终端用户需要。例如运行时改bug。</li><li>父进程请求。</li><li>符合调节需要。</li><li>操作系统需要。例如检查运行情况。</li></ol><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><h4 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h4><ol><li><strong>进程描述符</strong>：进程标识符用于唯一标识进程。</li><li><strong>处理机状态</strong>：进程切换时保留现场以及现场恢复。</li><li><strong>进程调度信息</strong>：进程状态及相关进程调度信息。</li><li><strong>进程控制信息</strong>：用于进程控制所需信息。</li></ol><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制一般由OS原语实现。</p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ol><li>支撑功能<ul><li>中断处理。</li><li>始终处理。</li><li>原语操作。原语由若干指令组成，用于完成一定功能的过程。原子操作，一个操作中所有行动要么全做，要么不做。</li></ul></li><li>资源管理功能<ul><li>进程管理。</li><li>存储器管理。</li><li>设备管理。</li></ul></li></ol><h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p>创建原语：Creat</p><p>终止原语：Holt</p><h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><p>阻塞原语：block</p><p>唤醒原语：wakeup</p><h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><p>挂起原语：suspend</p><p>激活原语：active</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><ol><li>关中断</li><li>利用Test-and-Set指令实现互斥</li><li>利用Swap指令实现进程互斥</li></ol><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol><li>整型信号量</li><li>记录型信号量</li><li>AND型信号量</li><li>信号量集</li></ol><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 </p><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><p>生产者-消费者问题</p><p>读者-写者问题</p><p>哲学家进餐问题</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol><li><p>共享存储器系统</p></li><li><p>管道（pipe）通信系统</p></li><li><p>消息传递系统</p><ul><li><p>消息传递的实际功能以一对原语的形式提供：</p><ul><li>send(destination,message)</li><li>receive(source,message)</li></ul><p>这是进程间进程消息传递所需要的最小操作集。</p><p>一个进程以消息的形式给另一个指定的目标进程发送消息；</p><p>进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</p></li></ul></li><li><p>客户机-服务机系统</p><ul><li>套接字socket</li></ul></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>作为调度和分派的基本单位。</p><p>每个线程有一个线程控制块TCB。</p><h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h3 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h3><p><strong>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</strong></p><p>高级调度：(High-Level Scheduling)又称为作业调度，它决定把外存上后备作业调入内存运行；</p><p>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</p><p>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。把不能正常运行的进程调至外存等待。</p><h4 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a>处理机调度算法</h4><p>CPU利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间)</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>周转时间Ti = 完成时间 - 到达时间</p><p>平均周转时间T = 1/n( T1 + …… + Ti + …… + Tn )</p><p>带权周转时间为周转时间/运行时间（越小越好）</p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>响应时间快，均衡性好。</p><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>考虑截至时间，提高可预测性。</p><h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><h4 id="作业（Job）"><a href="#作业（Job）" class="headerlink" title="作业（Job）"></a>作业（Job）</h4><p>程序的集合+数据的集合+作业说明书+JCB。</p><p>三个状态：后备状态，运行状态，收容状态。</p><p>三个阶段：收容阶段（创建JCB），运行阶段，完成阶段（回收JCB）。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol><li>接纳多少作业</li><li>接纳哪些作业</li></ol><h4 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h4><h5 id="先来先服务算法（first-come-first-served，FCFS）"><a href="#先来先服务算法（first-come-first-served，FCFS）" class="headerlink" title="先来先服务算法（first-come first-served，FCFS）"></a>先来先服务算法（first-come first-served，FCFS）</h5><p>系统按照作业到达的优先顺序调度。</p><p>不利于短作业。</p><h5 id="短作业优先算法（short-job-first，SJF）"><a href="#短作业优先算法（short-job-first，SJF）" class="headerlink" title="短作业优先算法（short job first，SJF）"></a>短作业优先算法（short job first，SJF）</h5><p>系统以作业长短为优先级。</p><p>不利于长作业，容易出现进程饥饿现象。</p><h5 id="优先级调度算法（priority-scheduling-algorithm，PSA）"><a href="#优先级调度算法（priority-scheduling-algorithm，PSA）" class="headerlink" title="优先级调度算法（priority-scheduling algorithm，PSA）"></a>优先级调度算法（priority-scheduling algorithm，PSA）</h5><p>根据作业紧迫程度，由外界赋予优先级。</p><h5 id="高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）"><a href="#高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）" class="headerlink" title="高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）"></a>高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）</h5><p>动态优先级，根据长短赋初值，根据等待时间加权。作业越短，初值越大，等待时间越长，加权越大。</p><p>Rp = 响应时间/要求服务时间</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="剥夺方式"><a href="#剥夺方式" class="headerlink" title="剥夺方式"></a>剥夺方式</h5><p>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</p><h5 id="非剥夺方式"><a href="#非剥夺方式" class="headerlink" title="非剥夺方式"></a>非剥夺方式</h5><p>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</p><h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><ol><li>保存处理机现场信息。</li><li>按某种算法选取进程。</li><li>把处理器分配给进程。</li></ol><h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p>进程调度也称为低级调度，它所调度的对象为进程（或者内核级线程），而进程调度算法主要有以下几种：</p><h5 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h5><p>它的原理通俗来讲就是队列中每一个进程都获得了一定的执行时间，从几ms到几百ms，当一个执行时间结束，计时器会发出一个信号，此时正在执行的进程将被中断，同时此进程将被放在队列的末尾，然后执行这时候的队列的队首进程，因此队列中每一个进程都将获得一定时间执行。</p><h5 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h5><p>先来先服务调度算法是一种最简单的调度算法，可用于作业调度，也可用于进程调度。</p><h5 id="短作业优先调度算法（SJ-P-F）"><a href="#短作业优先调度算法（SJ-P-F）" class="headerlink" title="短作业优先调度算法（SJ(P)F）"></a>短作业优先调度算法（SJ(P)F）</h5><p>短作业（进程）优先调度算法是指短作业或者短进程的优先调度算法，它们分别作用于作业调度和进程调度，它是先来先服务调度算法的一种优化版本。</p><h5 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h5><p>为了解决在短作业优先调度算法中进程的紧迫程度问题，我们引入高优先权优先调度算法，高优先权调度算法的方法也很简单，就是在队列中选取优先权最高的进程装入内存，该算法又分为以下两类：</p><p>①非抢占式优先权算法<br>如果系统已经分配好一个优先权最高的进程，它会一直被执行，直到结束或者因为某事件放弃执行，此时系统才会选择另外一个优先权最高的进程，这种调度算法主要被用于批处理系统中。</p><p>②抢占式优先权算法<br>系统在队列中把一个优先权最高的进程执行，但如果在执行中又出现一个优先权更高的进程，此时当前进程被停止，换入另外一个优先权更高的进程，这种调度算法主要被用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统中。</p><p>优先权的类型：</p><p>优先权的类型被分为静态优先权和动态优先权。</p><p>静态优先权就是给定某个整形数字来表示进程的优先级，数字越小表示优先级越高，数字越大，进程优先级越低。</p><p>动态优先权随着进程的创建而被创建，可以随着进程的推进或者等待时间而变化。</p><h5 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h5><p>进程就绪队列由一个拆成多个，不同类型进程分配不同就绪队列，不同就绪队列采用不同算法。一个就绪队列可以设置不同优先级，不同就绪队列本身也可设优先级。</p><p>系统根据不同的用户选用不同的调度策略。</p><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>设置多个就绪队列，每个队列的优先级逐渐降低，同时每个队列的执行时间也各不相同，优先级越高的队列，执行时间越短，优先级越低的队列，执行时间越长。<br>当一个进程进入内存后，首先进入第一个队列的末尾，按照先来先服务的调度算法进行调度，如果在第一个队列的执行时间内未执行完成，此时把此进程放入第二个队列的末尾，按照之前的方法进行执行，直到在某一个队列的队首执行完成。</p><p>当第一个队列全部执行完成，此时系统才会执行第二个队列，但是如果此时又有新的进程进入，此时执行完毕这个时间段，立刻把此进程分配给新的作业。</p><h5 id="根据公平原则的调度算法"><a href="#根据公平原则的调度算法" class="headerlink" title="根据公平原则的调度算法"></a>根据公平原则的调度算法</h5><p>公平分配每个进程相同的处理机时间，或按进程比例公平分配用户相同的处理机时间。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="锁与信号量"><a href="#锁与信号量" class="headerlink" title="锁与信号量"></a>锁与信号量</h3><p>锁强调于资源，信号量强调于执行次序。</p><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>重用性资源与消耗性资源</p><p>可抢占性资源与不可抢占资源</p><h3 id="死锁起因"><a href="#死锁起因" class="headerlink" title="死锁起因"></a>死锁起因</h3><p>源于多个进程对资源的争夺，不仅对<strong>不可抢占资源</strong>金进行争夺时容易产生死锁，而且对<strong>消耗性资源</strong>抢夺也会产生死锁。还有就是进程推进不当引起死锁。</p><h3 id="死锁产生必要条件"><a href="#死锁产生必要条件" class="headerlink" title="死锁产生必要条件"></a>死锁产生必要条件</h3><ol><li>互斥条件（不能破坏该条件）</li><li>请求与保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ol><h3 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h3><p>以下四种方法从上往下防范程度逐渐减弱，但资源利用率与并发程度逐渐提高。</p><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏”请求保持条件“"><a href="#破坏”请求保持条件“" class="headerlink" title="破坏”请求保持条件“"></a>破坏”请求保持条件“</h5><ol><li>一次性分配所有需要的资源。</li><li>用到时再调用资源，用完即释放资源。</li></ol><h5 id="破坏”不可抢占条件“"><a href="#破坏”不可抢占条件“" class="headerlink" title="破坏”不可抢占条件“"></a>破坏”不可抢占条件“</h5><p>调用资源时如果资源被占用，则必须释放已有所有资源，用时再调用。</p><h5 id="破坏”循环等待条件“"><a href="#破坏”循环等待条件“" class="headerlink" title="破坏”循环等待条件“"></a>破坏”循环等待条件“</h5><p>先给进程编号并排序，再按照顺序分配资源。</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><strong>银行家算法的数据结构</strong><br>可利用资源向量（Available）：系统还可以分配的资源</p><p>最大需求矩阵（Max）：进程的最大资源需要</p><p>分配矩阵（Alloction）：进程已经获得的资源</p><p>需求矩阵（Need）：进程还需要获得的资源</p><p><strong>银行家算法</strong></p><p>假设 P1 进程提出请求 K 个资源</p><p>如果 K &lt;= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源</p><p>如果 K &lt;= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 </p><p>Available系统试探分配资源，并修改下列数据</p><p>Available = Available - K；表示分配给 P1 K 个资源后，还剩多少系统可分配资源</p><p>Allocation = Allocation + K；表示 P1 已经获得的资源</p><p>Need = Need - K；表示进程 P1 还需要获得的资源</p><p>此时系统执行安全性算法，计算进程是否处于安全性状态</p><p>PS：此时是执行的试探分配，为的是检查进程是否处于安全状态，不处于则试探分配作废</p><p><strong>安全性算法</strong></p><p>安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态</p><p>两个向量</p><p>工作向量（Work）：系统提供给进程的各类资源数目</p><p>Finish：表示系统是否有足够的资源分配给进程，这是一个布尔值。初始化为 false。</p><p><strong>算法描述</strong></p><p>在进程集合中找到下述条件的进程</p><p>Finish[ i ] = false;</p><p>Need &lt;= Work</p><p>进程执行完毕</p><p>Work = Work + Allocation</p><p>Finish [ i ] = true</p><p>返回继续执行 1 ，寻找其他的进程分配资源</p><p>若所有的 Finish 为 true 则安全</p><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>资源分配图。</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>杀死进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;成也进程，败也进程，不为成败，只为进程。这是一篇凉文，面试正挂于此。哎，不多说了，直接进入正题吧。&lt;/p&gt;
&lt;h1 id=&quot;进程的描述与控制&quot;&gt;&lt;a href=&quot;#进程的描述与控制&quot; class=&quot;headerlink&quot; title=&quot;进程的描述与控制&quot;&gt;&lt;/a&gt;进程的描述
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="系统编程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://qianyouyou.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁" scheme="http://qianyouyou.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="进程调度" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>[转]HashMap实现原理及源码分析</title>
    <link href="http://qianyouyou.cn/2019/04/20/2019-04-20-1/"/>
    <id>http://qianyouyou.cn/2019/04/20/2019-04-20-1/</id>
    <published>2019-04-20T11:55:55.000Z</published>
    <updated>2019-04-27T15:43:10.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p><h1 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h1><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p><p>　　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p><p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113180447499-1953916974.png" alt="img"></p><p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><p>　　<strong>哈希冲突</strong></p><p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p><h1 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h1><p>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><br><span class="line">transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p> Entry是HashMap中的一个静态内部类。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构</span><br><span class="line">    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span><br><span class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 所以，HashMap的整体结构如下</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="img">　　</p><p>　　<strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p><p>其他几个重要字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//实际存储的key-value键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span><br><span class="line">int threshold;</span><br><span class="line">//负载因子，代表了table的填充度有多少，默认是0.75</span><br><span class="line">final float loadFactor;</span><br><span class="line">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span><br><span class="line">transient int modCount;</span><br></pre></td></tr></table></figure><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>我们看下其中一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p><p>　　OK,接下来我们来看看put操作的实现吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果key为null，存储位置为table[0]或table[0]的冲突链上</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀</span><br><span class="line">    int i = indexFor(hash, table.length);//获取在table中的实际位置</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span><br><span class="line">    addEntry(hash, key, value, i);//新增一个entry</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先来看看inflateTable这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂</span><br><span class="line">        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">       // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">       return number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">   &#125;[​](javascript:void(0);)</span><br></pre></td></tr></table></figure><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><p>hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　/**</span><br><span class="line"> * 返回数组下标</span><br><span class="line"> */</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    1  0  0  1  0</span><br><span class="line">&amp;   0  1  1  1  1</span><br><span class="line">__________________</span><br><span class="line">    0  0  0  1  0    = 2</span><br></pre></td></tr></table></figure><p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p><p>所以最终存储位置的确定流程是这样的：</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115133556388-1098209938.png" alt="img"></p><p>再来看看addEntry的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115215812138-679881037.png" alt="img"></p><p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001404732-625340289.png" alt="img"></p><p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001717560-1455096254.png" alt="img"></p><p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><p>get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">　　　　 //如果key为null,则直接去table[0]处去检索即可。</span><br><span class="line">       if (key == null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">            </span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过key的hashcode值计算hash值</span><br><span class="line">        int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h1><p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chengxiao on 2016/11/15.</span><br><span class="line"> */</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    private static class Person&#123;</span><br><span class="line">        int idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(int idCard, String name) &#123;</span><br><span class="line">            this.idCard = idCard;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (this == o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (o == null || getClass() != o.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            //两个对象是否等值，通过idCard来确定</span><br><span class="line">            return this.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();</span><br><span class="line">        Person person = new Person(1234,&quot;乔峰&quot;);</span><br><span class="line">        //put到hashmap中去</span><br><span class="line">        map.put(person,&quot;天龙八部&quot;);</span><br><span class="line">        //get取出，从逻辑上讲应该能输出“天龙八部”</span><br><span class="line">        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：null</span><br></pre></td></tr></table></figure><p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
      <category term="HashMap" scheme="http://qianyouyou.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>C++常用知识点STL总结</title>
    <link href="http://qianyouyou.cn/2019/04/20/2019-04-20/"/>
    <id>http://qianyouyou.cn/2019/04/20/2019-04-20/</id>
    <published>2019-04-20T08:33:45.000Z</published>
    <updated>2019-04-27T15:42:33.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><h2 id="六大组件简介"><a href="#六大组件简介" class="headerlink" title="六大组件简介"></a>六大组件简介</h2><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p><p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p><p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p><p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p><p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p><p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p><h2 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h2><p>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</p><p>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</p><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><ul><li><p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p></li><li><p><strong>高性能</strong>：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</p></li><li><p><strong>高移植性</strong>：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p></li></ul><h1 id="STL常用三大组件"><a href="#STL常用三大组件" class="headerlink" title="STL常用三大组件"></a>STL常用三大组件</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>序列式容器强调值的排序，序列式容器中的<strong>每个元素均有固定的位置</strong>，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</p><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间<strong>没有严格的物理上的顺序关系</strong>，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="质变算法"><a href="#质变算法" class="headerlink" title="质变算法"></a>质变算法</h3><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。</p><h3 id="非质变算法"><a href="#非质变算法" class="headerlink" title="非质变算法"></a>非质变算法</h3><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等中会更改。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>提供一种方法，使之能够<strong>依序寻访某个容器所含的各个元素</strong>，而又无需暴露该容器的内部表示方式。</p><p>迭代器的种类:</p><table><thead><tr><th>输入迭代器</th><th>提供对数据的只读访问</th><th>只读，支持++、==、！=</th></tr></thead><tbody><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//STL 中的容器 算法 迭代器</span><br><span class="line">void test01()&#123;</span><br><span class="line">vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组</span><br><span class="line">v.push_back(1); //vector 容器提供的插入数据的方法</span><br><span class="line">v.push_back(5);</span><br><span class="line">v.push_back(3);</span><br><span class="line">v.push_back(7);</span><br><span class="line">//迭代器</span><br><span class="line">vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span><br><span class="line">vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//算法 count 算法 用于统计元素的个数</span><br><span class="line">int n = count(pStart, pEnd, 5);</span><br><span class="line">cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Teacher(int age) :age(age)&#123;&#125;;</span><br><span class="line">~Teacher()&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器</span><br><span class="line">Teacher t1(10), t2(20), t3(30);</span><br><span class="line">v.push_back(t1);</span><br><span class="line">v.push_back(t2);</span><br><span class="line">v.push_back(t3);</span><br><span class="line">vector&lt;Teacher&gt;::iterator pStart = v.begin();</span><br><span class="line">vector&lt;Teacher&gt;::iterator pEnd = v.end();</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//存储 Teacher 类型指针</span><br><span class="line">void test03()&#123;</span><br><span class="line">vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针</span><br><span class="line">Teacher* t1 = new Teacher(10);</span><br><span class="line">Teacher* t2 = new Teacher(20);</span><br><span class="line">Teacher* t3 = new Teacher(30);</span><br><span class="line">v.push_back(t1);</span><br><span class="line">v.push_back(t2);</span><br><span class="line">v.push_back(t3);</span><br><span class="line">//拿到容器迭代器</span><br><span class="line">vector&lt;Teacher*&gt;::iterator pStart = v.begin();</span><br><span class="line">vector&lt;Teacher*&gt;::iterator pEnd = v.end();</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//容器嵌套容器 难点(不理解，可以跳过)</span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt; vector&lt;int&gt; &gt; v;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5;i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i * 10);</span><br><span class="line">v3.push_back(i * 100);</span><br><span class="line">&#125;</span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line"></span><br><span class="line">for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">//test01();</span><br><span class="line">//test02();</span><br><span class="line">//test03();</span><br><span class="line">test04();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><ul><li><strong>String和char*</strong>：<ul><li>Char*是一个指针，String是一个类。</li><li>string封装了char*，管理这个字符串，是一个char*型的容器。</li></ul></li><li>String封装了很多实用的成员方法：<ul><li>查找find，拷贝copy，删除delete，替换replace，插入insert。</li></ul></li><li>不用考虑内存释放和越界：<ul><li>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li></ul></li></ul><h3 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string();//创建一个空的字符串 例如: string str;      </span><br><span class="line">string(const string&amp; str);//使用一个string对象初始化另一个string对象</span><br><span class="line">string(const string&amp; str, size_t pos, size_t n);//使用一个string对象的pos位及后n位初始化另一个对象</span><br><span class="line">string(const string&amp; str, size_t n);//使用一个string对象的前n位初始化另一个对象</span><br><span class="line">string(const char* s);//使用字符串s初始化</span><br><span class="line">string(size_t n, char c);//使用n个字符c初始化</span><br></pre></td></tr></table></figure><h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串</span><br><span class="line">string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; operator=(char c);//字符赋值给当前的字符串</span><br><span class="line">string&amp; assign(const char *s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串</span><br><span class="line">string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串</span><br><span class="line">string&amp; assign(int n, char c);//用n个字符c赋给当前字符串</span><br><span class="line">string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串</span><br></pre></td></tr></table></figure><h3 id="string获取字符操作"><a href="#string获取字符操作" class="headerlink" title="string获取字符操作"></a>string获取字符操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[](int n);//通过[]方式取字符</span><br><span class="line">char&amp; at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure><h3 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator+=(const string&amp; str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char* str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char c);//重载+=操作符</span><br><span class="line">string&amp; append(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line">string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(const string &amp;s);//同operator+=()</span><br><span class="line">string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c</span><br></pre></td></tr></table></figure><h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置</span><br><span class="line">int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置</span><br><span class="line">int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置</span><br><span class="line">int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</span><br><span class="line">string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</span><br><span class="line">string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s</span><br></pre></td></tr></table></figure><h3 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span><br><span class="line">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span><br><span class="line">大写的A比小写的a小。</span><br><span class="line">*/</span><br><span class="line">int compare(const string &amp;s) const;//与字符串s比较</span><br><span class="line">int compare(const char *s) const;//与字符串s比较</span><br></pre></td></tr></table></figure><h3 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure><h3 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; insert(int pos, const char* s); //插入字符串</span><br><span class="line">string&amp; insert(int pos, const string&amp; str); //插入字符串</span><br><span class="line">string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c</span><br><span class="line">string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符</span><br></pre></td></tr></table></figure><h3 id="string和c-type转换"><a href="#string和c-type转换" class="headerlink" title="string和c-type转换"></a>string和c-type转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//string 转 char*</span><br><span class="line">string str = &quot;itcast&quot;;</span><br><span class="line">const char* cstr = str.c_str();</span><br><span class="line">//char* 转 string </span><br><span class="line">char* s = &quot;itcast&quot;;</span><br><span class="line">string str(s);</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。</p><p>通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;abcdefg&quot;;</span><br><span class="line">char&amp; a = s[2];</span><br><span class="line">char&amp; b = s[3];</span><br><span class="line"></span><br><span class="line">a = &apos;1&apos;;</span><br><span class="line">b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = &quot;pppppppppppppppppppppppp&quot;;</span><br><span class="line"></span><br><span class="line">//a = &apos;1&apos;;</span><br><span class="line">//b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ab12efg</span><br><span class="line">0x6dfed4</span><br><span class="line">pppppppppppppppppppppppp</span><br><span class="line">0x1816b0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector与Array数组"><a href="#vector与Array数组" class="headerlink" title="vector与Array数组"></a>vector与Array数组</h3><p>Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p><p>Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-vector_1.png" alt=""></p><h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，所以vector提供的是随机访问迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a><strong>vector的数据结构</strong></h3><p>Vector所采用线性连续空间，它以两个迭代器Myfirst和Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这便是<strong>容量</strong>的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是分配一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数</span><br><span class="line">vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。</span><br><span class="line">vector(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">vector(const vector &amp;vec);//拷贝构造函数。</span><br><span class="line"></span><br><span class="line">//例子 使用第二个构造函数 我们可以...</span><br><span class="line">int arr[] = &#123;2,3,4,1,9&#125;;</span><br><span class="line">vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));</span><br></pre></td></tr></table></figure><h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">vector&amp; operator=(const vector  &amp;vec);//重载等号操作符</span><br><span class="line">swap(vec);// 将vec与本身的元素互换。</span><br></pre></td></tr></table></figure><h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span><br><span class="line">capacity();//容器的容量</span><br><span class="line">reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span><br></pre></td></tr></table></figure><h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span><br><span class="line">operator[];//返回索引idx所指的数据，越界时，运行直接报错</span><br><span class="line">front();//返回容器中第一个数据元素</span><br><span class="line">back();//返回容器中最后一个数据元素</span><br></pre></td></tr></table></figure><h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.</span><br><span class="line">push_back(ele); //尾部插入元素ele</span><br><span class="line">pop_back();//删除最后一个元素</span><br><span class="line">erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素</span><br><span class="line">erase(const_iterator pos);//删除迭代器指向的元素</span><br><span class="line">clear();//删除容器中所有元素</span><br></pre></td></tr></table></figure><h3 id="巧用swap收缩内存空间"><a href="#巧用swap收缩内存空间" class="headerlink" title="巧用swap收缩内存空间"></a>巧用swap收缩内存空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//此时 通过resize改变容器大小</span><br><span class="line">v.resize(10);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//容量没有改变</span><br><span class="line">vector&lt;int&gt;(v).swap(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reserve预留空间"><a href="#reserve预留空间" class="headerlink" title="reserve预留空间"></a>reserve预留空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">//预先开辟空间</span><br><span class="line">v.reserve(100000);</span><br><span class="line"></span><br><span class="line">int* pStart = NULL;</span><br><span class="line">int count = 0;</span><br><span class="line">for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">if (pStart != &amp;v[0])&#123;</span><br><span class="line">pStart = &amp;v[0];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque与vector"><a href="#deque与vector" class="headerlink" title="deque与vector"></a>deque与vector</h3><p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p><p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_1.png" alt=""></p><h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a><strong>deque容器实现原理</strong></h3><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p><p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_2.png" alt=""></p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;//默认构造形式</span><br><span class="line">deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">deque(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque &amp;deq);//拷贝构造函数。</span><br></pre></td></tr></table></figure><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator=(const deque &amp;deq); //重载等号操作符 </span><br><span class="line">swap(deq);// 将deq与本身的元素互换</span><br></pre></td></tr></table></figure><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.size();//返回容器中元素的个数</span><br><span class="line">deque.empty();//判断容器是否为空</span><br><span class="line">deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h4 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);//在容器尾部添加一个数据</span><br><span class="line">push_front(elem);//在容器头部插入一个数据</span><br><span class="line">pop_back();//删除容器最后一个数据</span><br><span class="line">pop_front();//删除容器第一个数据</span><br></pre></td></tr></table></figure><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span><br><span class="line">front();//返回第一个数据。</span><br><span class="line">back();//返回最后一个数据</span><br></pre></td></tr></table></figure><h4 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><h4 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><p>stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p><p>有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-stack_1.png" alt=""></p><h3 id="stack迭代器"><a href="#stack迭代器" class="headerlink" title="stack迭代器"></a>stack迭代器</h3><p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。</p><h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a><strong>stack常用API</strong></h3><h4 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a>stack构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： </span><br><span class="line">stack(const stack &amp;stk);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="stack赋值操作"><a href="#stack赋值操作" class="headerlink" title="stack赋值操作"></a>stack赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp; operator=(const stack &amp;stk);//重载等号操作符</span><br></pre></td></tr></table></figure><h4 id="stack数据存取操作"><a href="#stack数据存取操作" class="headerlink" title="stack数据存取操作"></a>stack数据存取操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(elem);//向栈顶添加元素</span><br><span class="line">pop();//从栈顶移除第一个元素</span><br><span class="line">top();//返回栈顶元素</span><br></pre></td></tr></table></figure><h4 id="stack大小操作"><a href="#stack大小操作" class="headerlink" title="stack大小操作"></a>stack大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断堆栈是否为空</span><br><span class="line">size();//返回堆栈的大小</span><br></pre></td></tr></table></figure><h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-queue_1.png" alt=""></p><h3 id="queue迭代器"><a href="#queue迭代器" class="headerlink" title="queue迭代器"></a>queue迭代器</h3><p>Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p><h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><h4 id="queue构造函数"><a href="#queue构造函数" class="headerlink" title="queue构造函数"></a>queue构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="queue存取、插入和删除操作"><a href="#queue存取、插入和删除操作" class="headerlink" title="queue存取、插入和删除操作"></a>queue存取、插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(elem);//往队尾添加元素</span><br><span class="line">pop();//从队头移除第一个元素</span><br><span class="line">back();//返回最后一个元素</span><br><span class="line">front();//返回第一个元素</span><br></pre></td></tr></table></figure><h4 id="queue赋值操作"><a href="#queue赋值操作" class="headerlink" title="queue赋值操作"></a>queue赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&amp; operator=(const queue &amp;que);//重载等号操作符</span><br></pre></td></tr></table></figure><h4 id="queue大小操作"><a href="#queue大小操作" class="headerlink" title="queue大小操作"></a>queue大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断队列是否为空</span><br><span class="line">size();//返回队列的大小</span><br></pre></td></tr></table></figure><h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><p>List容器是一个双向链表。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-list_1.png" alt=""></p><p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出。</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。</li><li>链表灵活，但是空间和时间额外耗费较大。</li></ul><h3 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h3><p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.</p><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p><h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a><strong>list容器的数据结构</strong></h3><p>list容器不仅是一个双向链表，而且还是一个循环的双向链表。</p><h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a><strong>list常用API</strong></h3><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：</span><br><span class="line">list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">list(n,elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">list(const list &amp;lst);//拷贝构造函数。</span><br></pre></td></tr></table></figure><h4 id="list数据元素插入和删除操作"><a href="#list数据元素插入和删除操作" class="headerlink" title="list数据元素插入和删除操作"></a>list数据元素插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);//在容器尾部加入一个元素</span><br><span class="line">pop_back();//删除容器中最后一个元素</span><br><span class="line">push_front(elem);//在容器开头插入一个元素</span><br><span class="line">pop_front();//从容器开头移除第一个元素</span><br><span class="line">insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br><span class="line">remove(elem);//删除容器中所有与elem值匹配的元素。</span><br></pre></td></tr></table></figure><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(num);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">list&amp; operator=(const list &amp;lst);//重载等号操作符</span><br><span class="line">swap(lst);//将lst与本身的元素互换。</span><br></pre></td></tr></table></figure><h4 id="list数据的存取"><a href="#list数据的存取" class="headerlink" title="list数据的存取"></a>list数据的存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front();//返回第一个元素。</span><br><span class="line">back();//返回最后一个元素。</span><br></pre></td></tr></table></figure><h4 id="list反转排序"><a href="#list反转排序" class="headerlink" title="list反转排序"></a>list反转排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span><br><span class="line">sort(); //list排序</span><br></pre></td></tr></table></figure><h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h2><h3 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h3><p>Set的特性是<strong>所有元素都会根据元素的键值自动被排序</strong>。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。</p><p>我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.</p><p>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p><h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p><h3 id="set-multiset数据结构"><a href="#set-multiset数据结构" class="headerlink" title="set/multiset数据结构"></a>set/multiset数据结构</h3><p>set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。</p><h3 id="set常用API"><a href="#set常用API" class="headerlink" title="set常用API"></a>set常用API</h3><h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; st;//set默认构造函数：</span><br><span class="line">mulitset&lt;T&gt; mst; //multiset默认构造函数: </span><br><span class="line">set(const set &amp;st);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&amp; operator=(const set &amp;st);//重载等号操作符</span><br><span class="line">swap(st);//交换两个集合容器</span><br></pre></td></tr></table></figure><h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><h4 id="set插入和删除操作"><a href="#set插入和删除操作" class="headerlink" title="set插入和删除操作"></a>set插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);//在容器中插入元素。</span><br><span class="line">clear();//清除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(elem);//删除容器中值为elem的元素。</span><br></pre></td></tr></table></figure><h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span><br><span class="line">count(key);//查找键key的元素个数</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure><p><strong>set的返回值    指定set排序规则:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">//插入操作返回值</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);</span><br><span class="line">if (ret.second)&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(10);</span><br><span class="line">if(ret.second)&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyCompare02&#123;</span><br><span class="line">bool operator()(int v1,int v2)&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//set从大到小</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span><br><span class="line">set&lt;int, MyCompare02&gt; s;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">s.insert(rand() % 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//set容器中存放对象</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name,int age)&#123;</span><br><span class="line">this-&gt;mName = name;</span><br><span class="line">this-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string mName;</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct MyCompare03&#123;</span><br><span class="line">bool operator()(const Person&amp; p1,const Person&amp; p2)&#123;</span><br><span class="line">return p1.mAge &gt; p2.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test03()&#123;</span><br><span class="line">set&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line">Person p1(&quot;aaa&quot;, 20);</span><br><span class="line">Person p2(&quot;bbb&quot;, 30);</span><br><span class="line">Person p3(&quot;ccc&quot;, 40);</span><br><span class="line">Person p4(&quot;ddd&quot;, 50);</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line">for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对组-pair"><a href="#对组-pair" class="headerlink" title="对组(pair)"></a>对组(pair)</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。</p><p>类模板：template \<class t1,="" class="" t2=""> struct pair.</class></p><p>如何创建对组?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法创建一个对组</span><br><span class="line">pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; //访问pair第一个值</span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;//访问pair第二个值</span><br><span class="line">//第二种</span><br><span class="line">pair&lt;string, int&gt; pair2 = make_pair(&quot;name&quot;, 30);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">//pair=赋值</span><br><span class="line">pair&lt;string, int&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a>map/multimap基本概念</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p><p>我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p><p>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p><p>Multimap和map的操作类似，唯一区别multimap键值可重复。</p><p>Map和multimap都是以红黑树为底层实现机制。</p><h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a>map/multimap常用API</h3><h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;//map默认构造函数: </span><br><span class="line">map(const map &amp;mp);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&amp; operator=(const map &amp;mp);//重载等号操作符</span><br><span class="line">swap(mp);//交换两个集合容器</span><br></pre></td></tr></table></figure><h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><h4 id="map插入数据元素操作"><a href="#map插入数据元素操作" class="headerlink" title="map插入数据元素操作"></a>map插入数据元素操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;</span><br><span class="line">map&lt;int, string&gt; mapStu;</span><br><span class="line">// 第一种 通过pair的方式插入对象</span><br><span class="line">mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));</span><br><span class="line">// 第二种 通过pair的方式插入对象</span><br><span class="line">mapStu.inset(make_pair(-1, &quot;校长&quot;));</span><br><span class="line">// 第三种 通过value_type的方式插入对象</span><br><span class="line">mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));</span><br><span class="line">// 第四种 通过数组的方式插入值</span><br><span class="line">mapStu[3] = &quot;小刘&quot;;</span><br><span class="line">mapStu[5] = &quot;小王&quot;;</span><br></pre></td></tr></table></figure><h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();//删除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(keyElem);//删除容器中key为keyElem的对组。</span><br></pre></td></tr></table></figure><h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span><br><span class="line">count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure><h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a>STL容器使用时机</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言：快</td><td>对key而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><ul><li>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</li><li>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li><li>vector与deque的比较：<ul><li>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置    却是不固定的。</li><li>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li><li>三：deque支持头部的快速插入与快速移除，这是deque的优点。</li></ul></li><li>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</li><li>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </li><li>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p><p>注意:</p><p>1.函数对象(仿函数)是一个类，不是一个函数。</p><p>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</p><p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p><p>函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//函数对象是重载了函数调用符号的类</span><br><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">m_Num = 0;</span><br><span class="line">&#125;</span><br><span class="line">int m_Num;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">void operator() (int num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">m_Num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数对象</span><br><span class="line">//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(20);</span><br><span class="line">myPrint(20);</span><br><span class="line">myPrint(20);</span><br><span class="line">cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doBusiness(MyPrint print,int num)</span><br><span class="line">&#123;</span><br><span class="line">print(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数对象作为参数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">//参数1：匿名函数对象</span><br><span class="line">doBusiness(MyPrint(),30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</p><p>2、函数对象超出普通函数的概念，函数对象可以有自己的状态</p><p>3、函数对象可内联编译，性能好。用函数指针几乎不可能</p><p>4、模版函数对象使函数对象具有通用性，这也是它的优势之一 </p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class GreaterThenFive</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num)</span><br><span class="line">&#123;</span><br><span class="line">return num &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//一元谓词</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i ++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());</span><br><span class="line"> if (it == v.end())</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; &quot;找到了: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(40);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(90);</span><br><span class="line">v.push_back(60);</span><br><span class="line"></span><br><span class="line">//默认从小到大</span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line">//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">sort(v.begin(), v.end(),MyCompare());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h2><p>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include\<functional>。</functional></p><ul><li><p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; T plus&lt;T&gt;//加法仿函数</span><br><span class="line">template&lt;class T&gt; T minus&lt;T&gt;//减法仿函数</span><br><span class="line">template&lt;class T&gt; T multiplies&lt;T&gt;//乘法仿函数</span><br><span class="line">template&lt;class T&gt; T divides&lt;T&gt;//除法仿函数</span><br><span class="line">template&lt;class T&gt; T modulus&lt;T&gt;//取模仿函数</span><br><span class="line">template&lt;class T&gt; T negate&lt;T&gt;//取反仿函数</span><br></pre></td></tr></table></figure></li><li><p>6个关系运算类函数对象,每一种都是二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; bool equal_to&lt;T&gt;//等于</span><br><span class="line">template&lt;class T&gt; bool not_equal_to&lt;T&gt;//不等于</span><br><span class="line">template&lt;class T&gt; bool greater&lt;T&gt;//大于</span><br><span class="line">template&lt;class T&gt; bool greater_equal&lt;T&gt;//大于等于</span><br><span class="line">template&lt;class T&gt; bool less&lt;T&gt;//小于</span><br><span class="line">template&lt;class T&gt; bool less_equal&lt;T&gt;//小于等于</span><br></pre></td></tr></table></figure></li><li><p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; bool logical_and&lt;T&gt;//逻辑与</span><br><span class="line">template&lt;class T&gt; bool logical_or&lt;T&gt;//逻辑或</span><br><span class="line">template&lt;class T&gt; bool logical_not&lt;T&gt;//逻辑非</span><br></pre></td></tr></table></figure></li></ul><p>内建函数对象举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//取反仿函数</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">negate&lt;int&gt; n;</span><br><span class="line">cout &lt;&lt; n(50) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加法仿函数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">plus&lt;int&gt; p;</span><br><span class="line">cout &lt;&lt; p(10, 20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//大于仿函数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(rand() % 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">sort(v.begin(), v.end(), greater&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">//函数适配器bind1st bind2nd</span><br><span class="line">//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？</span><br><span class="line">//我们直接给函数对象绑定参数 编译阶段就会报错</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd(myprint(),100));</span><br><span class="line">//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function</span><br><span class="line">//根据我们函数对象是一元函数对象 还是二元函数对象</span><br><span class="line">class MyPrint :public binary_function&lt;int,int,void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void operator()(int v1,int v2) const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1 = : &quot; &lt;&lt; v1 &lt;&lt; &quot; v2 = :&quot; &lt;&lt;v2  &lt;&lt; &quot; v1+v2 = :&quot; &lt;&lt; (v1 + v2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//1、函数适配器</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;请输入起始值：&quot; &lt;&lt; endl;</span><br><span class="line">int x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind1st(MyPrint(), x));</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span><br><span class="line">&#125;</span><br><span class="line">//总结：  bind1st和bind2nd区别?</span><br><span class="line">//bind1st ： 将参数绑定为函数对象的第一个参数</span><br><span class="line">//bind2nd ： 将参数绑定为函数对象的第二个参数</span><br><span class="line">//bind1st bind2nd将二元函数对象转为一元函数对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GreaterThenFive:public unary_function&lt;int,bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator ()(int v) const</span><br><span class="line">&#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//2、取反适配器</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span><br><span class="line">//vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span><br><span class="line">//自定义输入</span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;int&gt;(),5)));</span><br><span class="line">if (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//排序  二元函数对象</span><br><span class="line">sort(v.begin(), v.end(), not2(less&lt;int&gt;()));</span><br><span class="line">for_each(v.begin(), v.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//not1 对一元函数对象取反</span><br><span class="line">//not2 对二元函数对象取反</span><br><span class="line"></span><br><span class="line">void MyPrint03(int v,int v2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v + v2&lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3、函数指针适配器   ptr_fun</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">// ptr_fun( )把一个普通的函数指针适配成函数对象</span><br><span class="line">for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4、成员函数适配器</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印函数</span><br><span class="line">void ShowPerson()&#123;</span><br><span class="line">cout &lt;&lt; &quot;成员函数:&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; m_Name &lt;&lt; &quot; Age:&quot; &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Plus100()</span><br><span class="line">&#123;</span><br><span class="line">m_Age += 100;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void MyPrint04(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt;  p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;Person&gt;v;</span><br><span class="line">Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4(&quot;ddd&quot;, 40);</span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line">//for_each(v.begin(), v.end(), MyPrint04);</span><br><span class="line">//利用 mem_fun_ref 将Person内部成员函数适配</span><br><span class="line">for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span><br><span class="line">// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test05()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person*&gt; v1;</span><br><span class="line">//创建数据</span><br><span class="line">Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4(&quot;ddd&quot;, 40);</span><br><span class="line"></span><br><span class="line">v1.push_back(&amp;p1);</span><br><span class="line">v1.push_back(&amp;p2);</span><br><span class="line">v1.push_back(&amp;p3);</span><br><span class="line">v1.push_back(&amp;p4);</span><br><span class="line"></span><br><span class="line">for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果容器存放的是对象指针，  那么用mem_fun</span><br><span class="line">//如果容器中存放的是对象实体，那么用mem_fun_ref</span><br></pre></td></tr></table></figure><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法主要是由头文件\<algorithm> \<functional> \<numeric>组成。</numeric></functional></algorithm></p><p>\<algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找，遍历，复制，修改，反转，排序，合并等…</algorithm></p><p>\<numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</numeric></p><p>\<functional> 定义了一些模板类,用以声明函数对象。</functional></p><h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    遍历算法 遍历容器元素</span><br><span class="line">@param beg 开始迭代器</span><br><span class="line">@param end 结束迭代器</span><br><span class="line">@param _callback  函数回调或者函数对象</span><br><span class="line">@return 函数对象</span><br><span class="line">*/</span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">transform算法 将指定容器区间元素搬运到另一容器中</span><br><span class="line">注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span><br><span class="line">@param beg1 源容器开始迭代器</span><br><span class="line">@param end1 源容器结束迭代器</span><br><span class="line">@param beg2 目标容器开始迭代器</span><br><span class="line">@param _cakkback 回调函数或者函数对象</span><br><span class="line">@return 返回目标容器迭代器</span><br><span class="line">*/</span><br><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each:"></a>for_each:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt,class _Fn1&gt; inline</span><br><span class="line">void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line">for (; _First != _Last; ++_First)</span><br><span class="line">_Func(*_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//普通函数</span><br><span class="line">void print01(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//函数对象</span><br><span class="line">struct print001&#123;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each算法基本用法</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历算法</span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print001());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print02&#123;</span><br><span class="line">print02()&#123;</span><br><span class="line">mCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">mCount++;</span><br><span class="line">&#125;</span><br><span class="line">int mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each返回值</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print02 p = for_each(v.begin(), v.end(), print02());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.mCount &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print03 : public binary_function&lt;int, int, void&gt;&#123;</span><br><span class="line">void operator()(int val,int bindParam) const&#123;</span><br><span class="line">cout &lt;&lt; val + bindParam &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each绑定参数输出</span><br><span class="line">void test03()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind2nd(print03(),100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//transform 将一个容器中的值搬运到另一个容器中</span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span><br><span class="line">_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for (; _First != _Last; ++_First, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First);</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span><br><span class="line">_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span><br><span class="line">&#123;</span><br><span class="line">for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First1, *_First2);</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct transformTest01&#123;</span><br><span class="line">int operator()(int val)&#123;</span><br><span class="line">return val + 100;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct print01&#123;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vSource;</span><br><span class="line">for (int i = 0; i &lt; 10;i ++)&#123;</span><br><span class="line">vSource.push_back(i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//目标容器</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">//给vTarget开辟空间</span><br><span class="line">vTarget.resize(vSource.size());</span><br><span class="line">//将vSource中的元素搬运到vTarget</span><br><span class="line">vector&lt;int&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());</span><br><span class="line">//打印</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将容器1和容器2中的元素相加放入到第三个容器中</span><br><span class="line">struct transformTest02&#123;</span><br><span class="line">int operator()(int v1,int v2)&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vSource1;</span><br><span class="line">vector&lt;int&gt; vSource2;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">vSource1.push_back(i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//目标容器</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">//给vTarget开辟空间</span><br><span class="line">vTarget.resize(vSource1.size());</span><br><span class="line">transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());</span><br><span class="line">//打印</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">find算法 查找元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value 查找的元素</span><br><span class="line">@return 返回查找元素的位置</span><br><span class="line">*/</span><br><span class="line">find(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">find_if算法 条件查找</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">find_if(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">adjacent_find算法 查找相邻重复元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return 返回相邻元素的第一个位置的迭代器</span><br><span class="line">*/</span><br><span class="line">adjacent_find(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">binary_search算法 二分查找法</span><br><span class="line">注意: 在无序序列中不可用</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value 查找的元素</span><br><span class="line">@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">bool binary_search(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">count算法 统计元素出现次数</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  value回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">count算法 统计元素出现次数</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count_if(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">merge算法 容器元素合并，并存储到另一容器中</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">*/</span><br><span class="line">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">sort算法 容器元素排序</span><br><span class="line">注意:两个容器必须是有序的</span><br><span class="line">@param beg 容器1开始迭代器</span><br><span class="line">@param end 容器1结束迭代器</span><br><span class="line">@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">*/</span><br><span class="line">sort(iterator beg, iterator end, _callback)</span><br><span class="line">/*</span><br><span class="line">sort算法 对指定范围内的元素随机调整次序</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">random_shuffle(iterator beg, iterator end)</span><br><span class="line">/*</span><br><span class="line">reverse算法 反转指定范围的元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">reverse(iterator beg, iterator end)</span><br></pre></td></tr></table></figure><h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">copy算法 将容器内指定范围的元素拷贝到另一容器中</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param dest 目标起始迭代器</span><br><span class="line">*/</span><br><span class="line">copy(iterator beg, iterator end, iterator dest)</span><br><span class="line">/*</span><br><span class="line">replace算法 将容器内指定范围的旧元素修改为新元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param oldvalue 旧元素</span><br><span class="line">@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line">/*</span><br><span class="line">replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param callback函数回调或者谓词(返回Bool类型的函数对象)</span><br><span class="line">@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace_if(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line">/*</span><br><span class="line">swap算法 互换两个容器的元素</span><br><span class="line">@param c1容器1</span><br><span class="line">@param c2容器2</span><br><span class="line">*/</span><br><span class="line">swap(container c1, container c2)</span><br></pre></td></tr></table></figure><h2 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">accumulate算法 计算容器元素累计总和</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value累加值</span><br><span class="line">*/</span><br><span class="line">accumulate(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">fill算法 向容器中添加元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value t填充元素</span><br><span class="line">*/</span><br><span class="line">fill(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure><h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">set_intersection算法 求两个set集合的交集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">set_union算法 求两个set集合的并集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">set_difference算法 求两个set集合的差集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL标准模板库&quot;&gt;&lt;a href=&quot;#STL标准模板库&quot; class=&quot;headerlink&quot; title=&quot;STL标准模板库&quot;&gt;&lt;/a&gt;STL标准模板库&lt;/h1&gt;&lt;h2 id=&quot;六大组件简介&quot;&gt;&lt;a href=&quot;#六大组件简介&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题解及源码(C++完整版)</title>
    <link href="http://qianyouyou.cn/2019/04/13/2019-04-13/"/>
    <id>http://qianyouyou.cn/2019/04/13/2019-04-13/</id>
    <published>2019-04-13T11:31:35.000Z</published>
    <updated>2019-04-27T15:42:05.553Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub源码地址：<a href="https://github.com/qian-youyou/jzOffer" target="_blank" rel="noopener">https://github.com/qian-youyou/jzOffer</a></p><h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><p>　　例如，我们要在上述的二维数组中查找数字7的步骤如下图所示：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-003.png" alt="img"></p><p>　　（矩阵中加阴影背景的区域是下一步查找的范围）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int y = array.size();</span><br><span class="line">        int x = array[0].size();</span><br><span class="line">        int j = x - 1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(j &gt;=0 &amp;&amp; i &lt; y)&#123;</span><br><span class="line">            if(array[i][j] == target)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; array[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i &lt; y &amp;&amp; array[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>将长度为1的空格替换为长度为3的“%20”，字符差的产度变长。如果允许我们开辟一个新的数组来存放替换空格后的字符串，那么这道题目就非常简 单。设置两个指针分别指向新旧字符串首元素，遍历原字符串，如果碰到空格就在新字符串上填入“%20”，否则就复制元字符串上的内容。但是如果面试官要求在原先的字符串上操作，并且保证原字符串有足够长的空间来存放替换后的字符串，那么我们就得另想方法。如果从前往后替换字符串，那么保存在空格后面的字符串肯定会被覆盖，那么我们就考虑从后往前进行替换。首先遍历原字符串，找出字符串的长度以及其中的空格数量，根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度。设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置。如果point1指向内容不为空格，那么将内容赋值给point2指向的位置，如果point1指向为空格，那么从point2开始赋值“02%”直到point1==point2时表明字符串中的所有空格都已经替换完毕。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            if(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int j = length + cnt * 2;</span><br><span class="line">        for(int i = length; j&gt;=0 &amp;&amp; i &gt;= 0; i--)&#123;</span><br><span class="line">            if(str[i] != &apos; &apos;)&#123;</span><br><span class="line">                str[j--] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                str[j--] = &apos;0&apos;;</span><br><span class="line">                str[j--] = &apos;2&apos;;</span><br><span class="line">                str[j--] = &apos;%&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>遍历一遍链表，将每个结点value入栈。最后依次从栈中取出元素即可。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        stack&lt;int&gt;s;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            s.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            v.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><strong>在二叉树的前序遍历序列中，第一个数字总是树的根结点的值</strong>。但在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。</p><p>　　如下图所示，前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-004.png" alt="img"></p><p>　　同样，在前序遍历的序列中，根结点后面的3个数字就是3个左子树结点的值，再后面的所有数字都是右子树结点的值。这样我们就在前序遍历和中序遍历两个序列中，分别找到了左右子树对应的子序列。</p><p>　　既然我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列，我们可以用同样的方法分别去构建左右子树。也就是说，接下来的事情可以用递归的方法去完成。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.size() == 0 || vin.size() == 0)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* T;</span><br><span class="line">        int index = 0;</span><br><span class="line">        buildTree(T, pre, vin, 0, 0, pre.size(), index);</span><br><span class="line">        return T;</span><br><span class="line">    &#125;</span><br><span class="line">    void buildTree(TreeNode* &amp;T, vector&lt;int&gt; pre,vector&lt;int&gt; vin, int cur, int left, int right, int &amp;index)&#123;</span><br><span class="line">        T = new TreeNode(pre[cur]);</span><br><span class="line">        ++index;</span><br><span class="line">        int i;</span><br><span class="line">        for(i = left; i &lt; right; i++)&#123;</span><br><span class="line">            if(vin[i] == pre[cur])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &gt; left &amp;&amp; i &lt; right)&#123;</span><br><span class="line">            buildTree(T-&gt;left, pre, vin, cur + 1, left, i, index);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; right - 1)&#123;</span><br><span class="line">            buildTree(T-&gt;right, pre, vin, index, i + 1, right, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>用stack1来实现队列的push操作，用stack2来实现队列的pop操作，当stack2为空时，将stack1的数据全部压入stack2，等待队列的pop操作。 </p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        if(stack1.empty())&#123;</span><br><span class="line">            while(!stack2.empty())&#123;</span><br><span class="line">                stack1.push(stack2.top());</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!stack2.empty())&#123;</span><br><span class="line">            int ans =  stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>由于数组非递减，那么旋转后的除了最小元素以外其他元素一定大于等于上一个元素，最小元素小于等于它上一个元素。遍历一遍查找哪个元素比上一元素小即可。若遍历完也没有，就输出第一个元素。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int len = rotateArray.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (len == 1)&#123;</span><br><span class="line">            return rotateArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; len; i++)&#123;</span><br><span class="line">            if(rotateArray[i] &lt; rotateArray[i - 1])&#123;</span><br><span class="line">                return rotateArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>斐波那契数列。F(N) = F(N - 1) + F(N - 2)</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        int a[40];</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt; 40; i++)&#123;</span><br><span class="line">            a[i] = a[i-1] + a[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>斐波那契数列。假设青蛙在第N阶，且第N-1阶跳法与第N-2阶跳法已经求出，则第N阶就是N-1阶的跳法加上第N-2阶的跳法。F(N) = F(N - 1) + F(N - 2)。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;v(number + 1);</span><br><span class="line">        v[0] = 1;</span><br><span class="line">        v[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)&#123;</span><br><span class="line">            v[i] = v[i-1] + v[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return v[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>第N阶等于第1阶 + 第2阶 + …… + 第N-1阶。即2^(n-1)。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int quick_pow(int n)&#123;</span><br><span class="line">        int ans = 2, res = 1;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n &amp; 1)&#123;</span><br><span class="line">                res *= ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans *= ans;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        number = quick_pow(number - 1);</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>骨牌最最简单的问题。依旧是斐波那契数列。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">        if(number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;v(number + 1);</span><br><span class="line">        v[0] = 1;</span><br><span class="line">        v[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)&#123;</span><br><span class="line">            v[i] = v[i-1] + v[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return v[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>位运算。时间复杂度为有几个1就执行几次。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int cnt = 0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             cnt++;</span><br><span class="line">             n = n &amp; (n - 1);</span><br><span class="line">         &#125;</span><br><span class="line">         return cnt;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>快速幂。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quick_pow(double base, int n)&#123;</span><br><span class="line">        double ans = 1;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n&amp;1)&#123;</span><br><span class="line">                ans *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base*=base;</span><br><span class="line">            n&gt;&gt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        if(exponent &gt;= 0)&#123;</span><br><span class="line">            return quick_pow(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return pow(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>奇数储存于一个数组，偶数储存于一个数组。最后合并。</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        const int len = array.size();</span><br><span class="line">        int a[len], b[len];</span><br><span class="line">        int aa = 0;</span><br><span class="line">        int bb = 0;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            if(array[i]%2)&#123;</span><br><span class="line">                a[aa++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                b[bb++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; aa; i++)&#123;</span><br><span class="line">            array[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        bb = 0;</span><br><span class="line">        for(int i = aa; i &lt; len; i++)&#123;</span><br><span class="line">            array[i] = b[bb++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><p>两个指针，一个指针先走k步，然后两个指针同时走，这样第1个指针走到头，第2给个指针刚好剩k个结点。</p><h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        ListNode* p = pListHead;</span><br><span class="line">        ListNode* q = pListHead;</span><br><span class="line">        unsigned int cnt = 0;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            if(cnt &gt;= k)&#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="解析-14"><a href="#解析-14" class="headerlink" title="解析"></a>解析</h2><p>将前一个节点与后一个节点断开，然后让前一个节点指向后一个节点，这个过程就需要节点引用（可以理解为指针）来确定记录当前操作节点的前一个节点和后一个节点。 </p><h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* p = NULL;</span><br><span class="line">        ListNode* q = pHead;</span><br><span class="line">        while(q)&#123;</span><br><span class="line">            pHead = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            pHead-&gt;next = p;</span><br><span class="line">            p = pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="解析-15"><a href="#解析-15" class="headerlink" title="解析"></a>解析</h2><p>归并排序基本操作。</p><h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(ListNode *a, ListNode *b)&#123;</span><br><span class="line">        if(a == NULL || b == NULL)&#123;</span><br><span class="line">            if(a != NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a-&gt;val &lt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    void fun(ListNode* &amp;p, ListNode* &amp;pHead)&#123;</span><br><span class="line">        ListNode* tmp = pHead;</span><br><span class="line">        pHead = pHead-&gt;next;</span><br><span class="line">        p-&gt;next = tmp;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pHead = NULL;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        while(pHead1 != NULL || pHead2 != NULL)&#123;</span><br><span class="line">            if(check(pHead1, pHead2))&#123;</span><br><span class="line">                if(!pHead)&#123;</span><br><span class="line">                    pHead = pHead1;</span><br><span class="line">                    p = pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    fun(p, pHead1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!pHead)&#123;</span><br><span class="line">                    pHead = pHead2;</span><br><span class="line">                    p = pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    fun(p, pHead2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="解析-16"><a href="#解析-16" class="headerlink" title="解析"></a>解析</h2><p>递归设计思路：</p><p>A、判断子树根值是否相等。</p><p>A1、如果是相等，需要一个可以判断该根左右孩子结点是否相等的递归函数。</p><p>A2、如果不等，找大树的左右孩子结点当根结点，递归到A步骤。</p><h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">        if(pRoot1 == NULL || pRoot2 == NULL)&#123;</span><br><span class="line">            if(pRoot2 == NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            if(dfs(pRoot1-&gt;left, pRoot2-&gt;left))&#123;</span><br><span class="line">                if(dfs(pRoot1-&gt;right, pRoot2-&gt;right))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot1 == NULL || pRoot2 == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            if(dfs(pRoot1, pRoot2))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = HasSubtree(pRoot1-&gt;left, pRoot2)||HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      6   10</span><br><span class="line">     / \  / \</span><br><span class="line">    5  7 9 11</span><br><span class="line">    镜像二叉树</span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      10   6</span><br><span class="line">     / \  / \</span><br><span class="line">    11 9 7  5</span><br></pre></td></tr></table></figure><h2 id="解析-17"><a href="#解析-17" class="headerlink" title="解析"></a>解析</h2><p>递归：</p><p>A：遍历左子树。</p><p>B：遍历右子树。</p><p>C：左子树和右子树交换。</p><h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;left != NULL)&#123;</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;right != NULL)&#123;</span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *tmp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h2 id="解析-18"><a href="#解析-18" class="headerlink" title="解析"></a>解析</h2><p>用vis数组储存访问状态。每次直线走n-1个，如果vis已访问就改变方向。</p><h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt;ans;</span><br><span class="line">        const int len1 = matrix.size();</span><br><span class="line">        if(!len1)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        const int len2 = matrix[0].size();</span><br><span class="line">        vector&lt;bool&gt;vis(len1*len2, false);</span><br><span class="line">        int a[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        ans.push_back(matrix[x][y]);</span><br><span class="line">        vis[0] = true;</span><br><span class="line">        while(flag)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">                while(x + a[i][0] &gt;= 0 &amp;&amp; x + a[i][0] &lt; len1 &amp;&amp; y + a[i][1] &gt;= 0 &amp;&amp; y + a[i][1] &lt; len2 &amp;&amp; !vis[(x + a[i][0]) * len2 + y + a[i][1]])&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x += a[i][0];</span><br><span class="line">                    y += a[i][1];</span><br><span class="line">                    ans.push_back(matrix[x][y]);</span><br><span class="line">                    vis[x*len2 + y] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2 id="解析-19"><a href="#解析-19" class="headerlink" title="解析"></a>解析</h2><p>两个栈，一个储存最小值，一个储存源数据。弹出的话两个一起弹出。</p><h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        StackInt.push(value);</span><br><span class="line">        if(StackMin.empty())</span><br><span class="line">            StackMin.push(value);</span><br><span class="line">        else if(StackMin.top()&lt;value)</span><br><span class="line">            StackMin.push(StackMin.top());</span><br><span class="line">        else</span><br><span class="line">            StackMin.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(!StackInt.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            StackInt.pop();</span><br><span class="line">            StackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return StackInt.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return StackMin.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; StackInt;</span><br><span class="line">    stack&lt;int&gt; StackMin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="解析-20"><a href="#解析-20" class="headerlink" title="解析"></a>解析</h2><p>栈模拟一遍即可。</p><h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        int len = pushV.size(), i = 0, j = 0;</span><br><span class="line">        while(i &lt; len &amp;&amp; j &lt; len)&#123;</span><br><span class="line">            while(s.empty() || i &lt; len &amp;&amp; s.top() != popV[j])&#123;</span><br><span class="line">                s.push(pushV[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &lt; len &amp;&amp; !s.empty() &amp;&amp; s.top() == popV[j])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &lt; len)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h2 id="解析-21"><a href="#解析-21" class="headerlink" title="解析"></a>解析</h2><p>广度优先遍历。queue储存数据。</p><h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        if(root == NULL)&#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(tmp-&gt;val);</span><br><span class="line">            if(tmp-&gt;left != NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp-&gt;right != NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h2 id="解析-22"><a href="#解析-22" class="headerlink" title="解析"></a>解析</h2><p>对于一个二叉树的后序遍历序列来说，最后一个数一定是根节点，然后前面的数中，从最开始到第一个大于根节点的数都是左子树中的数，而后面到倒数第二个数应该都是大于根节点的，是右子树，如果后面的数中有小于根节点的，那么说明这个序列不是二叉搜索树的后序遍历序列。</p><h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(vector&lt;int&gt; &amp;sequence, int left, int right)&#123;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        if(left &gt;= right)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int mindle = left;</span><br><span class="line">        int cur = sequence[right];</span><br><span class="line">        for(int i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            if(!flag &amp;&amp; sequence[i] &gt; cur)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                mindle = i;</span><br><span class="line">            &#125;else if(flag &amp;&amp; sequence[i] &lt; cur)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = check(sequence, left, mindle - 1) &amp;&amp; check(sequence, mindle, right - 1);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        const int len = sequence.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return check(sequence, 0, len - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h2 id="解析-23"><a href="#解析-23" class="headerlink" title="解析"></a>解析</h2><p>首先思考节点值的和为输入的整数，<strong>每条路径都一定是从根节点到叶子节点</strong>，在数据结构中从根节点到叶子节点的遍历称之为深度优先遍历DFS。因此整个过程可以采用先序遍历方式的DFS，即<strong>根节点》左子树》右子树</strong>。随后考虑一次遍历完成后的处理，当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 </p><h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; buffer;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==NULL)&#123;</span><br><span class="line">            return buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        if((expectNumber-root-&gt;val)==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)&#123;</span><br><span class="line">            buffer.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(tmp.size()!=0)&#123;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h2 id="解析-24"><a href="#解析-24" class="headerlink" title="解析"></a>解析</h2><p>第一步仍然是根据原始链表的每个结点N创建对应的N’。（把N’链接在N的后面）</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-005.png" alt="img"></p><p>第二步设置复制出来的结点的Sibling。（把N’的Sibling指向N的Sibling）</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-006.png" alt="img"></p><p>第三步把这个长链表拆分成两个链表：把奇数位置的结点用Next链接起来就是原始链表，偶数数值的则是复制链表。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-007.png" alt="img"></p><h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode *pHead2 = pHead, *p2, *tmp = pHead;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            p2 = new RandomListNode(tmp-&gt;label);</span><br><span class="line">            p2-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = p2;</span><br><span class="line">            tmp = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pHead)&#123;</span><br><span class="line">            pHead2 = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(tmp-&gt;random)&#123;</span><br><span class="line">                tmp-&gt;next-&gt;random = tmp-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        p2 = pHead2;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            if(p2-&gt;next)&#123;</span><br><span class="line">                p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="解析-25"><a href="#解析-25" class="headerlink" title="解析"></a>解析</h2><p>步骤1：递归左子树，使左子树为有序双向链表。</p><p>步骤2：递归右子树，使右子树为有序双向链表。</p><p>步骤3：左子树尾节点和根节点连接，右子树头节点和根节点连接。返回左子树头节点或根节点。</p><h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">        if(pRootOfTree)&#123;</span><br><span class="line">            TreeNode* left = Convert(pRootOfTree-&gt;left);</span><br><span class="line">            TreeNode* right = Convert(pRootOfTree-&gt;right);</span><br><span class="line">            TreeNode* tail = left;</span><br><span class="line">            if(right)&#123;</span><br><span class="line">                right-&gt;left = pRootOfTree;</span><br><span class="line">                pRootOfTree-&gt;right = right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(left)&#123;</span><br><span class="line">                while(tail-&gt;right)&#123;</span><br><span class="line">                    tail = tail-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;right = pRootOfTree;</span><br><span class="line">                pRootOfTree-&gt;left = tail;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">            return pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure><h2 id="解析-26"><a href="#解析-26" class="headerlink" title="解析"></a>解析</h2><p>把一个字符串看成两部分组成：第一部分为第一个字符，第二部分为后面的所有字符。</p><p>求整个字符串的排列，可以看出两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；然后固定第一个字符，求后面所有字符的排序。此时仍把后面的字符看成两部分，第一个字符和后面的字符，然后重复上述步骤。（递归）</p><p>在后面的在线测试中，要求输入字符串可能有重复的字符，输出按照字典顺序，排序即可。</p><h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt;v;</span><br><span class="line">    void dfs(string str, int cur)&#123;</span><br><span class="line">        if(cur &lt; str.size() - 1)&#123;</span><br><span class="line">            for(int i = cur; i &lt; str.size(); ++i)&#123;</span><br><span class="line">                if(i == cur || str[i] != str[cur])&#123;</span><br><span class="line">                    swap(str[cur], str[i]);</span><br><span class="line">                    dfs(str, cur + 1);</span><br><span class="line">                    swap(str[cur], str[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            v.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        dfs(str, 0);</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h2 id="解析-27"><a href="#解析-27" class="headerlink" title="解析"></a>解析</h2><ul><li>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；</li><li>如果下一个数字和我们之前保存的数字不同，则次数减1。</li><li>如果次数为零，我们需要保存下一个数字，并把次数设为1。</li><li>最后遍历一遍，统计该数出现的次数。</li></ul><h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        const int len = numbers.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = numbers[0], cnt = 1;</span><br><span class="line">        for(int i = 1; i &lt; len; ++i)&#123;</span><br><span class="line">            if(numbers[i] == ans)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!cnt)&#123;</span><br><span class="line">                    ans = numbers[i];</span><br><span class="line">                    cnt = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            if(numbers[i] == ans)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt &lt;= len / 2)&#123;</span><br><span class="line">            ans = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h2 id="解析-28"><a href="#解析-28" class="headerlink" title="解析"></a>解析</h2><p>建一个容量k的大根堆。</p><h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        priority_queue&lt;int&gt;que;</span><br><span class="line">        int len = input.size();</span><br><span class="line">        if(len &lt; k)&#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            que.push(input[i]);</span><br><span class="line">            while(que.size() &gt; k)&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            v.push_back(que.top());</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h2 id="解析-29"><a href="#解析-29" class="headerlink" title="解析"></a>解析</h2><p>直接遍历，如果上一个数加上这个数变小了就不加，否则加上。</p><h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int len = array.size();</span><br><span class="line">        int ans = array[0];</span><br><span class="line">        for(int i = 1; i &lt; len; ++i)&#123;</span><br><span class="line">            array[i] = max(array[i], array[i] + array[i - 1]);</span><br><span class="line">            ans = max(ans, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><h2 id="解析-30"><a href="#解析-30" class="headerlink" title="解析"></a>解析</h2><p>总结一下以上的算法，可以看到，当计算右数第 i 位包含的 x 的个数时：</p><ul><li>取第 i位左边(高位)的数字，乘以 10i-1，得到基础值 a</li><li>取第 i 位数字，计算修正值</li><li>如果大于 x , 则结果为 a + 10i-1</li><li>如果小于 x，则结果为 a</li><li>如果等于 x，则取第 i 位右边(低位)数字，设为 b，最后结果为 a + b + 1</li></ul><h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = n, ans = 0, res = 1;</span><br><span class="line">        while(cnt)&#123;</span><br><span class="line">            if(cnt % 10)&#123;</span><br><span class="line">                if(cnt % 10 &gt; 1)&#123;</span><br><span class="line">                    ans += res;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ans += n % res + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            cnt /= 10;</span><br><span class="line">            ans += cnt * res;</span><br><span class="line">            res *= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="解析-31"><a href="#解析-31" class="headerlink" title="解析"></a>解析</h2><p>sort排序即可，cmp由我们写，可以转成字符串，然后利用字符串进行比较。</p><h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)&#123;</span><br><span class="line">        string str1 = to_string(a);</span><br><span class="line">        string str2 = to_string(b);</span><br><span class="line">        return str1 + str2 &lt; str2 + str1;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        string str;</span><br><span class="line">        int len = numbers.size();</span><br><span class="line">        sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            while(numbers[i] == 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            str += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h2 id="解析-32"><a href="#解析-32" class="headerlink" title="解析"></a>解析</h2><p>优先队列+集合+选择性插入</p><h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;</span><br><span class="line">        que.push(1);</span><br><span class="line">        int i = 0;</span><br><span class="line">        int MAXN = 0;</span><br><span class="line">        set&lt;int&gt;s;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int ans = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(s.count(ans)||ans &lt; 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(ans);</span><br><span class="line">            ++i;</span><br><span class="line">            s.insert(ans);</span><br><span class="line">            if(i == index)&#123;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            if(que.size() &lt; index)&#123;</span><br><span class="line">                que.push(ans*2);</span><br><span class="line">                que.push(ans*3);</span><br><span class="line">                que.push(ans*5);</span><br><span class="line">                MAXN = max(MAXN, ans * 5);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(ans*2&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*2);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans*3&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*3);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans*5&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h2 id="解析-33"><a href="#解析-33" class="headerlink" title="解析"></a>解析</h2><p>哈希表，可用map统计。</p><h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">        map&lt;char, int&gt;m;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            m[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            if(m[str[i]] == 1)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字数据范围：对于%50的数据,size&lt;=10^4对于%75的数据,size&lt;=10^5对于%100的数据,size&lt;=2*10^5</span><br></pre></td></tr></table></figure><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="解析-34"><a href="#解析-34" class="headerlink" title="解析"></a>解析</h2><p>归并排序。先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。 </p><h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const long long mod = 1e9 + 7;</span><br><span class="line">    int my_merge(vector&lt;int&gt; &amp;data, int left, int mindle, int right)&#123;</span><br><span class="line">        vector&lt;int&gt;A(mindle - left + 1);</span><br><span class="line">        vector&lt;int&gt;B(right - mindle);</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        for(int i = left; i &lt;= mindle; ++i)&#123;</span><br><span class="line">            A[i - left] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = mindle + 1; i &lt;= right; ++i)&#123;</span><br><span class="line">            B[i - mindle - 1] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        for(int i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            if(x &gt;= A.size())&#123;</span><br><span class="line">                data[i] = B[y++];</span><br><span class="line">            &#125;else if(y &gt;= B.size())&#123;</span><br><span class="line">                data[i] = A[x++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(A[x] &gt; B[y])&#123;</span><br><span class="line">                    data[i] = B[y++];</span><br><span class="line">                    ans += A.size() - x;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    data[i] = A[x++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int mergeSort(vector&lt;int&gt;&amp;data, int left, int right)&#123;</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        if(left &lt; right)&#123;</span><br><span class="line">            int mindle = (left + right) / 2;</span><br><span class="line">            ans += mergeSort(data, left, mindle);</span><br><span class="line">            ans += mergeSort(data, mindle + 1, right);</span><br><span class="line">            ans += my_merge(data, left, mindle, right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        int ans = mergeSort(data, 0, data.size() - 1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p><h2 id="解析-35"><a href="#解析-35" class="headerlink" title="解析"></a>解析</h2><p>如果两链表有交点，则必然是“Y”型或“V”型。</p><p>如何判断两个单向链表有没有公共结点？如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。</p><p>在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。</p><p>在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p><h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* fun(ListNode* &amp;pHead, ListNode* p)&#123;</span><br><span class="line">        ListNode* q = pHead;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        ListNode* p1 = pHead1;</span><br><span class="line">        ListNode* p2 = pHead2;</span><br><span class="line">        while(p1 != NULL &amp;&amp; p2 != NULL)&#123;</span><br><span class="line">            if(p1 == p2)&#123;</span><br><span class="line">                return p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p1 == NULL &amp;&amp; p2 == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(p1 != NULL)&#123;</span><br><span class="line">                p1 = fun(pHead1, p1);</span><br><span class="line">                p2 = pHead2;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p2 = fun(pHead2, p2);</span><br><span class="line">                p1 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return FindFirstCommonNode(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="解析-36"><a href="#解析-36" class="headerlink" title="解析"></a>解析</h2><p>我的方法直接遍历。更高效的方法是二分查找两遍，先找到该数字的左边界，再找到该数字的右边界，然后下标相减。</p><h2 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; data.size(); ++i)&#123;</span><br><span class="line">            if(data[i] == k)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h2 id="解析-37"><a href="#解析-37" class="headerlink" title="解析"></a>解析</h2><p>遍历一遍即可。</p><h2 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        if(pRoot != NULL)&#123;</span><br><span class="line">            cnt += max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h2 id="解析-38"><a href="#解析-38" class="headerlink" title="解析"></a>解析</h2><p>递归判断左子树深度和右子树深度差是否不大于1。</p><h2 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return true;</span><br><span class="line">        int leftDepth = getDepth(pRoot -&gt; left);</span><br><span class="line">        int rightDepth = getDepth(pRoot -&gt; right);</span><br><span class="line">        if(leftDepth &gt; rightDepth + 1 || leftDepth + 1 &lt; rightDepth)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return IsBalanced_Solution(pRoot -&gt; left) &amp;&amp; IsBalanced_Solution(pRoot -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    int getDepth(TreeNode* pRoot)&#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth = getDepth(pRoot -&gt; left);</span><br><span class="line">        int rightDepth = getDepth(pRoot -&gt; right);</span><br><span class="line">        return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h2 id="解析-39"><a href="#解析-39" class="headerlink" title="解析"></a>解析</h2><p>我用的map。可以用位运算。</p><h2 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        int len = data.size();</span><br><span class="line">        bool flag = false;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            m[data[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            if(m[data[i]] == 1)&#123;</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    *num2 = data[i];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    *num1 = data[i];</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h1><h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure><h2 id="解析-40"><a href="#解析-40" class="headerlink" title="解析"></a>解析</h2><p>在序列首部各定义指针left, right，如果和超过s，left往右移，如果和小于s，right往右移。 </p><h2 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;ans;</span><br><span class="line">        for(int i = 1; i &lt;= sum; ++i)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 1, right = 1;</span><br><span class="line">        int cnt = 1;</span><br><span class="line">        while(right &lt; sum &amp;&amp; left &lt; sum)&#123;</span><br><span class="line">            if(cnt == sum)&#123;</span><br><span class="line">                ans.push_back(vector&lt;int&gt;(v.begin() + left - 1, v.begin() + right));</span><br><span class="line">            &#125;</span><br><span class="line">            if(cnt &gt; sum)&#123;</span><br><span class="line">                cnt -= left;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;else if(cnt &lt;= sum)&#123;</span><br><span class="line">                ++right;</span><br><span class="line">                cnt += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h1><h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure><h2 id="解析-41"><a href="#解析-41" class="headerlink" title="解析"></a>解析</h2><p>在序列首尾各定义指针p1, p2，如果和超过s，p2往中间移，如果和小于s，p1往中间移。 </p><h2 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = array.size() - 1;</span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            if(array[left] + array[right] == sum)&#123;</span><br><span class="line">                v.push_back(array[left]);</span><br><span class="line">                v.push_back(array[right]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(array[left] + array[right] &gt; sum)&#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2 id="解析-42"><a href="#解析-42" class="headerlink" title="解析"></a>解析</h2><p>先取余，再字符串分割。</p><h2 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        unsigned int len = str.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        n %= len;</span><br><span class="line">        string str2 = str.substr(size_t(n)) + str.substr(0, n);</span><br><span class="line">        return str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h1><h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2 id="解析-43"><a href="#解析-43" class="headerlink" title="解析"></a>解析</h2><p>用栈储存单词，存完了再输出。</p><h2 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        stack&lt;string&gt;s;</span><br><span class="line">        istringstream istring;</span><br><span class="line">        istring.str(str);</span><br><span class="line">        string tmp;</span><br><span class="line">        while(istring &gt;&gt; tmp)&#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!s.empty())&#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(str.size())&#123;</span><br><span class="line">                return str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            tmp += &quot; &quot; + s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h1><h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2 id="解析-44"><a href="#解析-44" class="headerlink" title="解析"></a>解析</h2><p>暴力做的。</p><h2 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        if(numbers.empty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt = 0, cur = 0;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        for(int i = 0; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            if(numbers[i] == 0)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(cur)&#123;</span><br><span class="line">                    while(numbers[i] != cur + 1)&#123;</span><br><span class="line">                        cur += 1;</span><br><span class="line">                        --cnt;</span><br><span class="line">                        if(cnt &lt; 0)&#123;</span><br><span class="line">                            return false;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    cur = numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="孩子们的游戏-圆圈中最后剩下的数"><a href="#孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="孩子们的游戏(圆圈中最后剩下的数)"></a>孩子们的游戏(圆圈中最后剩下的数)</h1><h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h2 id="解析-45"><a href="#解析-45" class="headerlink" title="解析"></a>解析</h2><p>现在我们把他们的编号做一下转换：</p><p>k –&gt; 0<br>k+1 –&gt; 1<br>k+2 –&gt; 2<br>…<br>…<br>k-2 –&gt; n-2<br>k-1 –&gt; n-1<br>解x’ —-&gt; 解为x<br>注意&lt; x’就是最终的解 &gt;</p><p>变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k)%n</p><p>如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 —- 这显然就是一个倒推问题！下面举例说明：</p><p>假设现在是6个人（编号从0到5）报数，报到（2-1）的退出，即 &lt; m=2&gt;。那么第一次编号为1的人退出圈子，从他之后的人开始算起，序列变为2,3,4,5,0，即问题变成了这5个人报数的问题，将序号做一下转换：<br>2 –&gt;0<br>3 –&gt;1<br>4 –&gt;2<br>5 –&gt;3<br>0 –&gt;4<br>现在假设x为0,1,2,3,4的解，x’设为那么原问题的解（这里注意，2,3,4,5,0的解就是0,1,2,3,4,5的解，因为1出去了，结果还是一个），根据观察发现，x与x’关系为x’=(x+m)%n，因此只要求出x，就可以求x’。x怎么求出呢？继续推导吧。0,1,2,3,4,，同样是第二个1出列，变为（2,3,4,0），转换下为<br>2 –&gt;0<br>3 –&gt;1<br>4 –&gt;2<br>0 –&gt;3<br>很简单，同样的道理，公式又出来了，x=(x”+m)%5，这里变成5了。即求n-1个人的问题就是找出n-2的人的解，n-2就是要找出n-3，等等<br>因此，就可以回去看上面的推导过程了。</p><p>好了，思路出来了，下面写递推公式：<br>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]</p><p>递推公式<br>f[1]=0;<br>f[i]=(f[i-1]+m)%i; (i&gt;1)</p><p>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1<br>由于是逐级递推，不需要保存每个f[i]。</p><h2 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n + m == 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int s = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+…+n"></a>求1+2+3+…+n</h1><h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h2 id="解析-46"><a href="#解析-46" class="headerlink" title="解析"></a>解析</h2><p>利用逻辑运算符&amp;&amp;的性质。</p><h2 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return fun(n);</span><br><span class="line">    &#125;</span><br><span class="line">    int fun(int n)&#123;</span><br><span class="line">        n &amp;&amp; (n += fun(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h2 id="解析-47"><a href="#解析-47" class="headerlink" title="解析"></a>解析</h2><p>位运算，先异或，再右移。</p><h2 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        while(num2)&#123;</span><br><span class="line">            int a1 = num1 ^ num2;</span><br><span class="line">            int a2 = num1 &amp; num2;</span><br><span class="line">            a2 &lt;&lt;= 1;</span><br><span class="line">            num1 = a1;</span><br><span class="line">            num2 = a2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">    1a33</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure><h2 id="解析-48"><a href="#解析-48" class="headerlink" title="解析"></a>解析</h2><p>暴力</p><h2 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int StrToInt(string str) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            while(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str[i] &lt;= &apos;9&apos; &amp;&amp; str[i] &gt;= &apos;0&apos;)&#123;</span><br><span class="line">                ans *= 10;</span><br><span class="line">                ans += str[i] - &apos;0&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!flag)&#123;</span><br><span class="line">                    if(str[i] == &apos;-&apos;)&#123;</span><br><span class="line">                        flag = -1;</span><br><span class="line">                    &#125;else if(str[i] == &apos;+&apos;)&#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            ans *= flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="解析-49"><a href="#解析-49" class="headerlink" title="解析"></a>解析</h2><p>0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置；</p><p>从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i，</p><p>如果是，则继续扫描下一个数字；</p><p>如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置；</p><p>重复上述过程，直至找到一个重复的数字；</p><p>时间复杂度：O(n)，空间复杂度：O(1)</p><p>注：张氏排序法</p><h2 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        for(int i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">            while(numbers[i] != i)&#123;</span><br><span class="line">                if(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                    *duplication = numbers[i];</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><h2 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><h2 id="解析-50"><a href="#解析-50" class="headerlink" title="解析"></a>解析</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-002.png" alt=""></p><p>B[i]的值可以看做下图的矩阵中每行的乘积。</p><p>下三角用连乘可以很容易求得，先算下三角中的连乘，即先计算出B[i]中的一部分，然后将上三角中的数也乘进去。这样一来就只需要两个循环就可以解决这个问题。时间复杂度是O(n);</p><p>其实你只需要知道这个是形成一个矩阵，然后每一行是用来计算B[i],每一行的内容则是A[0]到A[n-1]。利用上三角和下三角进行计算。</p><h2 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt;B(A.size(), 1);</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        for(int i = 0; i &lt; A.size() - 1; ++i)&#123;</span><br><span class="line">            tmp *= A[i];</span><br><span class="line">            B[i + 1] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = 1;</span><br><span class="line">        for(int i = A.size() - 1; i &gt; 0; --i)&#123;</span><br><span class="line">            tmp *= A[i];</span><br><span class="line">            B[i - 1] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><h2 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h2 id="解析-51"><a href="#解析-51" class="headerlink" title="解析"></a>解析</h2><p>“.”按任意字符匹配。如果模式串遇到*字符则有两种状态，第一匹配字符，则字符串后移一位，模式串不变，第二，模式串后移俩位和字符串后移一位，第三，忽略星号。 </p><h2 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)&#123;</span><br><span class="line">        if(str[0] == 0 &amp;&amp; pattern[0] == 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(pattern[0] &amp;&amp; pattern[1] == &apos;*&apos; &amp;&amp; match(str, pattern + 2))&#123;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;else if(str[0] &amp;&amp; pattern[0] == &apos;.&apos; || str[0] == pattern[0])&#123;</span><br><span class="line">            if(match(str + 1, pattern + 1))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(pattern[1] == &apos;*&apos; &amp;&amp; match(str + 1, pattern))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><h2 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解析-52"><a href="#解析-52" class="headerlink" title="解析"></a>解析</h2><p>暴力</p><h2 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        int len = strlen(string);</span><br><span class="line">        int cur = 0;</span><br><span class="line">        bool a = false, b = false, c = false, ans = true;</span><br><span class="line">        while(string[cur] == &apos; &apos;)&#123;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for(; cur &lt; len; ++cur)&#123;</span><br><span class="line">            if(string[cur] &gt;= &apos;0&apos; &amp;&amp; string[cur] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                ans = true;</span><br><span class="line">                a = true;</span><br><span class="line">            &#125;else if(string[cur] == &apos;+&apos; || string[cur] == &apos;-&apos;)&#123;</span><br><span class="line">                if(a)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    a = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(string[cur] == &apos;e&apos; || string[cur] == &apos;E&apos;)&#123;</span><br><span class="line">                if(b)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    b = true;</span><br><span class="line">                    a = false;</span><br><span class="line">                    ans = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(string[cur] == &apos;.&apos;)&#123;</span><br><span class="line">                if(c || b)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    c = true;</span><br><span class="line">                    ans = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h1><h2 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure><h2 id="解析-53"><a href="#解析-53" class="headerlink" title="解析"></a>解析</h2><p>哈希表。</p><h2 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    Solution():cur(0)&#123;&#125;</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        str += ch;</span><br><span class="line">        ++mp[ch];</span><br><span class="line">        while(cur &lt; str.size() &amp;&amp; mp[str[cur]] &gt; 1)&#123;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur &gt;= str.size())&#123;</span><br><span class="line">            return &apos;#&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return str[cur];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    map&lt;char, int&gt;mp;</span><br><span class="line">    string str;</span><br><span class="line">    int cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2 id="解析-54"><a href="#解析-54" class="headerlink" title="解析"></a>解析</h2><p><a href="https://www.cnblogs.com/fankongkong/p/7007869.html" target="_blank" rel="noopener">转</a>：a、第一步，找环中相汇点。分别用fast，slow指向链表头部，slow每次走一步，fast每次走二步，直到fast==slow找到在环中的相汇点。</p><p>b、第二步，找环的入口。接上步，当fast==slow时，fast所经过节点数为2x,slow所经过节点数为x,设环中有n个节点，fast比slow<strong>多走r圈</strong>有<strong>2x=rn+x; x=rn;</strong>（r为圈数，n为一圈的结点数）</p><p>可以看出slow实际走了多个环的步数，再让fast指向链表头部，slow位置不变。</p><p>假设链表开头到环接口的距离是y，那么x-y表示slow指针走过的除链表开头y在环中走过的距离，那么slow再走y步，此时fast结点与slow结点相遇，fast == slow ，<strong>x-y+y=x = rn</strong>，即此时slow指向环的入口。</p><h2 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pFast = pHead;</span><br><span class="line">        ListNode* pSlow = pHead;</span><br><span class="line">        do&#123;</span><br><span class="line">            if(pSlow &amp;&amp; pSlow-&gt;next)&#123;</span><br><span class="line">                pSlow = pSlow-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pFast &amp;&amp; pFast-&gt;next &amp;&amp; pFast-&gt;next-&gt;next)&#123;</span><br><span class="line">                pFast = pFast-&gt;next-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(pFast != pSlow);</span><br><span class="line">        pFast = pHead;</span><br><span class="line">        while(pFast != pSlow)&#123;</span><br><span class="line">            pFast = pFast-&gt;next;</span><br><span class="line">            pSlow = pSlow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pSlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h1><h2 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解析-55"><a href="#解析-55" class="headerlink" title="解析"></a>解析</h2><p>不多说了，因为是排序的链表。</p><h2 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">if (pHead == NULL) &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* preNode = NULL;</span><br><span class="line">ListNode* node = pHead;</span><br><span class="line">while (node != NULL) &#123;</span><br><span class="line">if (node-&gt;next != NULL &amp;&amp; node-&gt;val == node-&gt;next-&gt;val) &#123;</span><br><span class="line">int value = node-&gt;val;</span><br><span class="line">while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;val == value) &#123;</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if (preNode == NULL) &#123;</span><br><span class="line">pHead = node-&gt;next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">preNode-&gt;next = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">preNode = node;</span><br><span class="line">&#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><h2 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解析-56"><a href="#解析-56" class="headerlink" title="解析"></a>解析</h2><p>我们可发现分成两大类：1、有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） 2、没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。  </p><h2 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pNode == NULL)&#123;</span><br><span class="line">            return pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* p = pNode-&gt;right;</span><br><span class="line">            while(p-&gt;left)&#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            TreeLinkNode* p = pNode-&gt;next;</span><br><span class="line">            while(p &amp;&amp; p-&gt;right == pNode)&#123;</span><br><span class="line">                pNode = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><h2 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解析-57"><a href="#解析-57" class="headerlink" title="解析"></a>解析</h2><p>【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。</p><p>【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。</p><p>【分析3】题目中并不是想让我们判断任意两棵二叉树是否相同，而是要求我们判断一棵二叉树和它的镜像二叉树是否相同。因此我们判断相同的条件不就很明显的变成了：根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到① 如果Root和Root’均为空，则返回true；② 如果Root为空或者Root’为空，则返回false；③ 如果Root对应的值与Root’对应的值不相等，则返回false。</p><h2 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123;</span><br><span class="line">        return pRoot_1-&gt;val == pRoot_2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123;</span><br><span class="line">        if(pRoot_1 == NULL || pRoot_2 == NULL)&#123;</span><br><span class="line">            if(pRoot_1 == NULL &amp;&amp; pRoot_2 == NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(check(pRoot_1, pRoot_2))&#123;</span><br><span class="line">            if(dfs(pRoot_1-&gt;left, pRoot_2-&gt;right))&#123;</span><br><span class="line">                return dfs(pRoot_1-&gt;right, pRoot_2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><h2 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解析-58"><a href="#解析-58" class="headerlink" title="解析"></a>解析</h2><p>广度优先遍历。两个栈代替队列储存数据。</p><h2 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;que;</span><br><span class="line">        stack&lt;TreeNode*&gt;stk;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;vv;</span><br><span class="line">        if(!pRoot)&#123;</span><br><span class="line">            return vv;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        while(!que.empty() || !stk.empty())&#123;</span><br><span class="line">            vector&lt;int&gt;v;</span><br><span class="line">            if(!que.empty())&#123;</span><br><span class="line">                while(!que.empty())&#123;</span><br><span class="line">                    TreeNode* tmp = que.top();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    v.push_back(tmp-&gt;val);</span><br><span class="line">                    if(tmp-&gt;left)&#123;</span><br><span class="line">                        stk.push(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(tmp-&gt;right)&#123;</span><br><span class="line">                        stk.push(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                while(!stk.empty())&#123;</span><br><span class="line">                    TreeNode* tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    v.push_back(tmp-&gt;val);</span><br><span class="line">                    if(tmp-&gt;right)&#123;</span><br><span class="line">                        que.push(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(tmp-&gt;left)&#123;</span><br><span class="line">                        que.push(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vv.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        return vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h1><h2 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解析-59"><a href="#解析-59" class="headerlink" title="解析"></a>解析</h2><p>带属性的广度优先遍历。</p><h2 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            vector&lt;vector&lt;int&gt; &gt; vv;</span><br><span class="line">            vector&lt;int&gt; ve;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            queue&lt;int&gt; dque;</span><br><span class="line">            int depth=0;</span><br><span class="line">            que.push(pRoot);</span><br><span class="line">            dque.push(depth);</span><br><span class="line">            TreeNode *node;</span><br><span class="line">            while(!que.empty())&#123;</span><br><span class="line">                node=que.front();</span><br><span class="line">                if(depth!=dque.front())&#123;</span><br><span class="line">                    vv.push_back(ve);</span><br><span class="line">                    ve.clear();</span><br><span class="line">                    depth=dque.front();</span><br><span class="line">                &#125;</span><br><span class="line">                que.pop();</span><br><span class="line">                dque.pop();</span><br><span class="line">                if(node)&#123;</span><br><span class="line">                    que.push(node-&gt;left);</span><br><span class="line">                    que.push(node-&gt;right);</span><br><span class="line">                    dque.push(depth+1);</span><br><span class="line">                    dque.push(depth+1);</span><br><span class="line">                    ve.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return vv;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="解析-60"><a href="#解析-60" class="headerlink" title="解析"></a>解析</h2><p> 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</p><p>序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过  某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>这里以先序遍历的方式进行序列化举例：</p><p>先序序列化二叉树==定义一个stringbuilder保存序列过程中的结果：<strong>按照先序遍历方式遍历二叉树，若结点非空则把 “结点值!” append到builder中；若结点空则把  “#!” append到builder中；</strong>最后用builder生成字符串就是序列化结果。    </p><h2 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            str = to_string(root-&gt;val);</span><br><span class="line">            str = str + &quot;,&quot; + Serialize(root-&gt;left);</span><br><span class="line">            str = str + &quot;,&quot; + Serialize(root-&gt;right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str = &quot;#&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char* ret = new char[str.size()];</span><br><span class="line">        strcpy(ret,str.c_str());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* dfs(char * &amp;str) &#123;</span><br><span class="line">        if(*str == &apos;,&apos;)&#123;</span><br><span class="line">            ++str;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str)&#123;</span><br><span class="line">            TreeNode* Tree = new TreeNode(0);</span><br><span class="line">            if(str &amp;&amp; *str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                while(*str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                    Tree-&gt;val *= 10;</span><br><span class="line">                    Tree-&gt;val += *str - &apos;0&apos;;</span><br><span class="line">                    ++str;</span><br><span class="line">                &#125;</span><br><span class="line">                Tree-&gt;left = dfs(str);</span><br><span class="line">                Tree-&gt;right = dfs(str);</span><br><span class="line">                return Tree;</span><br><span class="line">            &#125;else if(*str == &apos;#&apos;)&#123;</span><br><span class="line">                ++str;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char * str)&#123;</span><br><span class="line">        return dfs(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h1><h2 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2 id="解析-61"><a href="#解析-61" class="headerlink" title="解析"></a>解析</h2><p>搜索树按从小到大的顺序排列正好就是中序遍历； 所以按照中序遍历查找，第k个节点就是结果。 </p><h2 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cnt;</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = 0;</span><br><span class="line">        return dfs(pRoot, k);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* dfs(TreeNode* pRoot, int k)&#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;left)&#123;</span><br><span class="line">            TreeNode* tmp = dfs(pRoot-&gt;left, k);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        if(cnt == k)&#123;</span><br><span class="line">            return pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;right)&#123;</span><br><span class="line">            TreeNode* tmp = dfs(pRoot-&gt;right, k);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><h2 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2 id="解析-62"><a href="#解析-62" class="headerlink" title="解析"></a>解析</h2><p>最大堆和最小堆结合。最大堆储存前n/2个数，最小堆储存后n/2个数。偶数个数据，那么中位数可以由大小堆堆顶的数得到，如果数据的数目是奇数，那么输出最大堆堆顶。 </p><h2 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(max_que.size() == min_que.size())&#123;</span><br><span class="line">            if(max_que.empty() || max_que.top() &gt;= num || min_que.top() &gt;= num)&#123;</span><br><span class="line">                max_que.push(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                max_que.push(min_que.top());</span><br><span class="line">                min_que.pop();</span><br><span class="line">                min_que.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(max_que.top() &gt;= num)&#123;</span><br><span class="line">                min_que.push(max_que.top());</span><br><span class="line">                max_que.pop();</span><br><span class="line">                max_que.push(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                min_que.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        if(max_que.size() == min_que.size())&#123;</span><br><span class="line">            return (min_que.top() + max_que.top()) / 2.0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return max_que.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;min_que;</span><br><span class="line">    priority_queue&lt;int&gt;max_que;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><h2 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解析-63"><a href="#解析-63" class="headerlink" title="解析"></a>解析</h2><p>我们可以用STL中的deque，以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。</p><p>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。</p><p>第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</p><p>但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-001.png" alt=""></p><h2 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)&#123;</span><br><span class="line">        deque&lt;int&gt;dq, vis;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for(unsigned int i = 0; i &lt; num.size(); ++i)&#123;</span><br><span class="line">            if(!vis.empty() &amp;&amp; i - vis.front() &gt;= size)&#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                vis.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            while(!dq.empty() &amp;&amp; dq.back() &lt;= num[i])&#123;</span><br><span class="line">                    dq.pop_back();</span><br><span class="line">                    vis.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(num[i]);</span><br><span class="line">            vis.push_back(i);</span><br><span class="line">            if(i &gt;= size - 1)&#123;</span><br><span class="line">                v.push_back(dq.front());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2 id="解析-64"><a href="#解析-64" class="headerlink" title="解析"></a>解析</h2><p>dfs(回溯)。创建一个状态数组对访问的字符进行标记。首先，遍历这个矩阵，如果矩阵中某字符和目标字符首字母相等，则以该字符为起点dfs深搜，否则继续遍历。一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置。</p><h2 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(char* matrix, int x, int y, char* str, int cur, int rows, int cols)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] == true || str[cur] != matrix[x * cols + y])&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = true;</span><br><span class="line">        if(cur &gt;= len - 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            if(dfs(matrix, x + road[i][0], y + road[i][1], str, cur + 1, rows, cols) == true)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)&#123;</span><br><span class="line">        if(matrix[0] == 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        len = strlen(str);</span><br><span class="line">        vis.resize(cols * rows, false);</span><br><span class="line">        for(int i = 0; i &lt; rows; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; ++j)&#123;</span><br><span class="line">                if(matrix[i* cols + j] == str[0])&#123;</span><br><span class="line">                    if(dfs(matrix, i, j, str, 0, rows, cols) == true)&#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int len;</span><br><span class="line">    vector&lt;bool&gt;vis;</span><br><span class="line">    int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解析-65"><a href="#解析-65" class="headerlink" title="解析"></a>解析</h2><p>dfs(回溯)。创建一个状态数组对访问的格子进行标记，但是这里需要计算所有能够走的格子总数，实际上只需要对下一个进行访问的格子进行计算，进行从上、下、左、右四个方向进行递归，就可以计算出可以达到的格子总数了。 </p><h2 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)&#123;</span><br><span class="line">        vis.resize(rows * cols, false);</span><br><span class="line">        return dfs(threshold, rows, cols, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int dfs(int threshold, int rows, int cols, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] || threshold &lt; check(x) + check(y))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = true;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            ans += dfs(threshold, rows, cols, x + road[i][0], y + road[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int check(int num)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(num)&#123;</span><br><span class="line">            res += num % 10;</span><br><span class="line">            num /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;bool&gt;vis;</span><br><span class="line">    int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub源码地址：&lt;a href=&quot;https://github.com/qian-youyou/jzOffer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/qian-youyou/jzOffer&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="字符串" scheme="http://qianyouyou.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://qianyouyou.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="树" scheme="http://qianyouyou.cn/tags/%E6%A0%91/"/>
    
      <category term="剑指Offer" scheme="http://qianyouyou.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现Linux下读取指定目录下普通文件的个数</title>
    <link href="http://qianyouyou.cn/2019/03/16/2019-03-16-1/"/>
    <id>http://qianyouyou.cn/2019/03/16/2019-03-16-1/</id>
    <published>2019-03-16T14:05:44.000Z</published>
    <updated>2019-04-27T15:41:21.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开一个目录"><a href="#打开一个目录" class="headerlink" title="打开一个目录"></a>打开一个目录</h2><ul><li>DIR <em>opendir(const char </em>name);</li><li><ul><li>参数: 目录名</li><li>返回值: 指向目录的指针</li></ul></li><li>FILE* fp = fopen（）</li><li>fread（buf， len， len，fp）；</li></ul><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                         // 此目录进入点的inode</span><br><span class="line">    ff_t d_off;                             // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;      // d_name 所指的文件类型 </span><br><span class="line">    har d_name[256];       // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>d_type<ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软连接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知 </li></ul></li><li>struct dirent <em>readdir(DIR      </em>dirp);<ul><li>参数: opendir的返回值</li><li>返回值: 目录项结构体 </li></ul></li></ul><h2 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h2><ul><li>int closedir(DIR *dirp);</li></ul><p>独立完成递归读目录中指定类型文件个数的操作. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int get_file_num(char* root)&#123;</span><br><span class="line">int total = 0;</span><br><span class="line">DIR* dir = NULL;</span><br><span class="line">// 打开目录</span><br><span class="line">dir = opendir(root);</span><br><span class="line">// 循环从目录中读文件</span><br><span class="line"></span><br><span class="line">char path[1024];</span><br><span class="line">// 定义记录xiang指针</span><br><span class="line">struct dirent* ptr = NULL;</span><br><span class="line">while( (ptr = readdir(dir)) != NULL)&#123;</span><br><span class="line">// 跳过. he ..</span><br><span class="line">if(strcmp(ptr-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name, &quot;..&quot;) == 0)&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是不是目录</span><br><span class="line">if(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">sprintf(path, &quot;%s/%s&quot;, root, ptr-&gt;d_name);</span><br><span class="line">// 递归读目录</span><br><span class="line">total += get_file_num(path);</span><br><span class="line">&#125;</span><br><span class="line">// 如果是普通文件</span><br><span class="line">if(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">total ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">if(argc &lt; 2)&#123;</span><br><span class="line">printf(&quot;./a.out path&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int total = get_file_num(argv[1]);</span><br><span class="line">printf(&quot;%s has regfile number: %d\n&quot;, argv[1], total);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;打开一个目录&quot;&gt;&lt;a href=&quot;#打开一个目录&quot; class=&quot;headerlink&quot; title=&quot;打开一个目录&quot;&gt;&lt;/a&gt;打开一个目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DIR &lt;em&gt;opendir(const char &lt;/em&gt;name);&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Linux/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件和目录操作函数总结</title>
    <link href="http://qianyouyou.cn/2019/03/16/2019-03-16/"/>
    <id>http://qianyouyou.cn/2019/03/16/2019-03-16/</id>
    <published>2019-03-16T11:26:27.000Z</published>
    <updated>2019-04-27T15:41:06.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-文件IO"><a href="#01-文件IO" class="headerlink" title="01-文件IO"></a>01-文件IO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure><h2 id="open-close"><a href="#open-close" class="headerlink" title="open/close"></a>open/close</h2><ul><li><p>函数原型:</p><ul><li>int open(const char *pathname,        int flags);</li><li>int open(const char *pathname,        int flags, mode_t mode);</li></ul></li><li><p>参数:</p><ul><li><p>flags</p><ul><li><p>必选项 O_RDONLY, O_WRONLY, O_RDWR</p></li><li><p>可选项 </p><ul><li><p>创建文件: O_CREAT</p><ul><li>创建文件时检测文件是否存在: O_EXCL</li><li>如果文件存在, 返回-1</li><li>必须与O_CREAT一起使用</li></ul></li><li><p>追加文件:  O_APPEND</p></li><li><p>文件截断:  O_TRUNC</p></li><li><p>设置非阻塞: O_NONBLOCK</p></li></ul></li></ul></li><li><p>mode  – 指定0777</p><ul><li><p>八进制数</p></li><li><p>最终权限: mode &amp; ~umaks</p></li><li><p>umask 0002</p><ul><li>000000010</li><li>~</li><li>111111101</li><li>111111111</li><li>&amp;</li><li>111111101</li><li>775</li></ul></li></ul></li></ul></li></ul><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><ul><li><p>函数原型: ssize_t read(int fd, void *buf, size_t count);</p><ul><li><p>参数:</p><ul><li>fd – open的返回值</li><li>buf - 缓冲区, 存放读取的数据</li><li>count – 缓冲区的最大容量 sizeof(buf)</li></ul></li><li><p>返回值:</p><ul><li>-1: 失败</li><li>>0: 读出的字节数</li><li>=0: 文件读完了</li></ul></li></ul></li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><ul><li><p>函数原型: ssize_t write(int fd, const void *buf, size_t count);</p><ul><li><p>参数:</p><ul><li>fd: 文件描述符, open 返回值</li><li>buf: 要往文件中写的数据</li><li>count: 有效数据的长度</li></ul></li><li><p>返回值:</p><ul><li>-1: 失败</li><li>>0: 写入的字节数</li></ul></li></ul></li></ul><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><ul><li><p>函数原型: off_t lseek(int fd, off_t offset, int whence);</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul></li><li><p>使用:</p><ul><li>文件指针移动到头部:</li><li>lseek(fd, 0, SEEK_SET);</li></ul></li><li><p>获取文件指针当前的位置:</p><ul><li>int len = lseek(fd, 0, SEEK_CUR);</li></ul></li><li><p>获取文件长度:</p><ul><li>int len = lseek(fd, 0, SEEK_END);</li></ul></li><li><p>文件拓展</p><ul><li>文件原大小100k， 拓展为1100k</li><li><p>lseek(fd, 1000, SEE_END);</p></li><li><p>最后做一次写操作write(fd, “a”, 1);</p></li></ul></li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li><p>阻塞和非阻塞是文件的属性还是read函数的属性?</p><ul><li><p>文件的属性</p></li><li><p>普通文件：hello.c</p><ul><li>默认不阻塞</li></ul></li><li><p>终端设备：/dev/tty</p><ul><li>默认阻塞</li><li>管道</li><li>套接字</li></ul></li></ul></li></ul><h1 id="02-stat-lstat函数"><a href="#02-stat-lstat函数" class="headerlink" title="02-stat/lstat函数"></a>02-stat/lstat函数</h1><h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br></pre></td></tr></table></figure><ul><li><p>st_mode – 16位整数</p></li><li><p>0-2 bit – 其他人权限</p><ul><li>S_IROTH      00004  读权限</li><li>S_IWOTH    00002  写权限</li><li>S_IXOTH      00001  执行权限</li><li>S_IRWXO     00007         掩码, 过滤        st_mode中除其他人权限以外的信息</li><li>3-5 bit – 所属组权限<ul><li>S_IRGRP      00040  读权限</li><li>S_IWGRP    00020  写权限</li><li>S_IXGRP      00010   执行权限</li><li>S_IRWXG    00070  掩码, 过滤        st_mode中除所属组权限以外的信息</li></ul></li><li>6-8 bit – 文件所有者权限<ul><li>S_IRUSR      00400    读权限</li><li>S_IWUSR    00200    写权限</li><li>S_IXUSR      00100     执行权限</li><li>S_IRWXU   00700     掩码, 过滤        st_mode中除文件所有者权限以外的信息</li></ul></li><li>12-15 bit – 文件类型<ul><li>S_IFSOCK         0140000 套接字</li><li>S_IFLNK            0120000 符号链接（软链接）</li><li>S_IFREG            0100000 普通文件</li><li>S_IFBLK             0060000 块设备</li><li>S_IFDIR             0040000 目录</li><li>S_IFCHR           0020000 字符设备</li><li>S_IFIFO             0010000 管道</li><li>S_IFMT        0170000 掩码,过滤        st_mode中除文件类型以外的信息(st_mode &amp; S_IFMT) ==  S_IFREG</li></ul></li></ul></li><li><p>int stat(const char <em>path,      struct stat </em>buf);</p></li><li><p>int lstat(const char <em>path,      struct stat </em>buf);</p><ul><li>lstat读取的链接文件本身的属性</li><li><p>stat读取的是连接文件指向的文件的属性</p><ul><li>追踪，穿透</li></ul></li></ul></li></ul><h1 id="03-文件属性函数"><a href="#03-文件属性函数" class="headerlink" title="03-文件属性函数"></a>03-文件属性函数</h1><h2 id="测试当前用户指定文件是否具有某种属性"><a href="#测试当前用户指定文件是否具有某种属性" class="headerlink" title="测试当前用户指定文件是否具有某种属性"></a>测试当前用户指定文件是否具有某种属性</h2><ul><li><p>当前用户, 使用哪个用户调用这个函数, 这个用户就是当前用户</p></li><li><p>int access(const char *pathname,      int mode);</p></li><li><ul><li>参数:<ul><li>pathname: 文件名</li><li>mode: 4种权限</li><li>R_OK – 读 </li><li>W_OK – 写 </li><li>X_OK – 执行 </li><li>F_OK – 文件是否存在</li></ul></li></ul></li><li><ul><li>返回值:</li><li>0 - 有某种权限, 或者文件存在</li><li>1 - 没有, 或文件不存在</li></ul></li></ul><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><ul><li><p>int chmod(const char *filename,       int mode);</p><ul><li><ul><li><p>参数:</p></li><li><ul><li>filename: 文件名</li><li>mode: 文件权限, 八进制数</li></ul></li></ul></li></ul></li></ul><h2 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h2><ul><li><p>int chown(const char *path,       uid_t owner, gid_t group);</p><ul><li><p>函数参数:</p></li><li><ul><li><p>path – 文件路径</p></li><li><p>owner – 整形值, 用户ID </p></li><li><ul><li>/etc/passwd</li></ul></li><li><p>group – …..,        组ID                </p></li><li><ul><li>/etc/group</li></ul></li></ul></li></ul></li></ul><h2 id="修改文件大小"><a href="#修改文件大小" class="headerlink" title="修改文件大小"></a>修改文件大小</h2><ul><li><p>int truncate(const char *path,       off_t length);</p></li><li><p>参数: </p></li><li><ul><li>path – 文件名</li><li>length – 文件的最终大小<ul><li>\1. 比原来小, 删掉后边的部分</li><li>\2. 比原来大, 向后拓展</li></ul></li></ul></li></ul><h1 id="04-目录操作相关函数"><a href="#04-目录操作相关函数" class="headerlink" title="04-目录操作相关函数"></a>04-目录操作相关函数</h1><ol><li><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2></li></ol><ul><li>int rename(const char <em>oldpath, const char </em>newpath);</li></ul><ol start="2"><li><h2 id="修改当前进程-应用程序-的路径-cd"><a href="#修改当前进程-应用程序-的路径-cd" class="headerlink" title="修改当前进程(应用程序)的路径 cd"></a>修改当前进程(应用程序)的路径 cd</h2></li></ol><ul><li><p>int chdir(const char *path);</p><ul><li>参数: 切换的路径</li></ul></li></ul><ol start="3"><li><h2 id="获取当前进程的工作目录-pwd"><a href="#获取当前进程的工作目录-pwd" class="headerlink" title="获取当前进程的工作目录 pwd"></a>获取当前进程的工作目录 pwd</h2></li></ol><ul><li><p>char <em>getcwd(char </em>buf, size_t size);</p><ul><li><p>返回值:</p><ul><li>成功: 当前的工作目录</li><li>失败: NULL</li></ul></li><li><p>参数:</p><ul><li>buf: 缓冲区, 存储当前的工作目录</li><li>size: 缓冲区大小</li></ul></li></ul></li></ul><ol start="4"><li><h2 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 mkdir</h2></li></ol><ul><li><p>int mkdir(const char *pathname,       mode_t mode);</p><ul><li>参数:<ul><li>pathname: 创建的目录名</li><li>mode: 目录权限, 八进制的数, 实际权限: mode &amp; ~umask</li></ul></li></ul></li></ul><ol start="5"><li><h2 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h2></li></ol><ul><li><p>int rmdir(const char       *pathname);</p><ul><li>参数: 空目录的名字</li></ul></li></ul><h1 id="05-目录遍历相关函数"><a href="#05-目录遍历相关函数" class="headerlink" title="05-目录遍历相关函数"></a>05-目录遍历相关函数</h1><ol><li><h2 id="打开一个目录"><a href="#打开一个目录" class="headerlink" title="打开一个目录"></a>打开一个目录</h2><ul><li><p>DIR <em>opendir(const char </em>name);</p></li><li><ul><li>参数: 目录名</li><li>返回值: 指向目录的指针</li></ul></li><li><p>FILE* fp = fopen（）</p></li><li><p>fread（buf， len， len，fp）；</p></li></ul></li><li><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                         // 此目录进入点的inode</span><br><span class="line">    ff_t d_off;                             // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;      // d_name 所指的文件类型 </span><br><span class="line">    har d_name[256];       // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>d_type</p><ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软连接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知 </li></ul></li><li><p>struct dirent <em>readdir(DIR      </em>dirp);</p><ul><li>参数: opendir的返回值</li><li>返回值: 目录项结构体 </li></ul></li></ul><ol start="3"><li><h2 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h2><ul><li>int closedir(DIR *dirp);</li></ul></li><li><h2 id="独立完成递归读目录中指定类型文件个数的操作"><a href="#独立完成递归读目录中指定类型文件个数的操作" class="headerlink" title="独立完成递归读目录中指定类型文件个数的操作."></a>独立完成递归读目录中指定类型文件个数的操作.</h2></li></ol><h1 id="06-dup-dup2-fcntl"><a href="#06-dup-dup2-fcntl" class="headerlink" title="06-dup-dup2-fcntl"></a>06-dup-dup2-fcntl</h1><ol><li><p>复制文件描述符</p><ul><li><p>int dup(int oldfd);</p></li><li><ul><li><p>oldfd - 要复制的文件描述符</p></li><li><p>返回值: 新的文件描述符</p></li><li><p>dup调用成功:</p></li><li><ul><li>有两个文件描述符指向同一个文件</li></ul></li><li><p>返回值: 取最小的且没被占用的文件描述符</p></li></ul></li><li><p>int dup2(int oldfd, int newfd);</p></li><li><ul><li><p>oldfd -》hello</p></li><li><p>newfd -》world</p></li><li><ul><li><p>假设newfd已经指向了一个文件，首先断开close与那个文件的链接，newfd指向oldfd指向的文件</p></li><li><ul><li>文件描述符重定向</li></ul></li><li><ul><li>oldfd和newfd指向同一个文件</li></ul></li></ul></li><li><ul><li>newfd没有被占用，newfd指向oldfd指向的文件</li></ul></li></ul></li></ul></li><li><p>改变已经打开的文件的属性: fcntl</p></li></ol><ul><li><p>变参函数</p></li><li><p>复制一个已有的文件描述符</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ret = fcntl(fd, F_DUPFD);</span><br></pre></td></tr></table></figure><ul><li><p>获取/设置文件状态标志</p></li><li><ul><li>open 的flags参数</li></ul></li></ul><ol><li>获取文件状态标识</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flag = fcntl(fd, F_GETFL)</span><br></pre></td></tr></table></figure><ol start="2"><li>设置文件状态标识</li></ol><ul><li>flag = flag      | O_APPEND;</li><li><p>fcntl(fd,      F_SETFL, flag)</p></li><li><p>可以更改的几个标识: O_APPEND、O_NONBLOCK （常用）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01-文件IO&quot;&gt;&lt;a href=&quot;#01-文件IO&quot; class=&quot;headerlink&quot; title=&quot;01-文件IO&quot;&gt;&lt;/a&gt;01-文件IO&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Linux/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>春招面经（2019.3.15日起）</title>
    <link href="http://qianyouyou.cn/2019/03/15/2019-03-15/"/>
    <id>http://qianyouyou.cn/2019/03/15/2019-03-15/</id>
    <published>2019-03-15T11:12:50.000Z</published>
    <updated>2019-04-27T15:40:36.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-15腾讯提前批一面"><a href="#3-15腾讯提前批一面" class="headerlink" title="3.15腾讯提前批一面"></a>3.15腾讯提前批一面</h1><p>第一次电话面试，而且是腾讯的，真的感觉特别紧张。虽然面试官小哥哥人特别好，一直在缓解气氛，但总体还是感觉状态不是很好。不管结果怎么样，先记录下这次所涉及到的知识点吧。</p><h2 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h2><p>有点紧张，把大概经历说了一下。</p><h2 id="为什么投腾讯，以及企业文化："><a href="#为什么投腾讯，以及企业文化：" class="headerlink" title="为什么投腾讯，以及企业文化："></a>为什么投腾讯，以及企业文化：</h2><p>谈到了百度狼性文化，其实之前看过一些相关的企业文化，但没有太深入取看。整体感觉有点不好。</p><h2 id="问题1：C-和Python有什么区别-各有什么特点。"><a href="#问题1：C-和Python有什么区别-各有什么特点。" class="headerlink" title="问题1：C++和Python有什么区别?各有什么特点。"></a>问题1：C++和Python有什么区别?各有什么特点。</h2><p>答：有点记不太清楚怎么回答的了。总之答得很不专业。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>程序有两种执行方式，解释执行和编译执行。<br>PYTHON是一种脚本语言，是解释执行的，不需要经过编译，所以很方便快捷，且能够很好地跨平台，写一些小工具小程序特别合适。<br>而C++则是一种需要编译后运行语言，在特定的机器上编译后在特定的机上运行，运行效率高，安全稳定。但编译后的程序一般是不跨平台的。 </p><p>学习一种编程语言不能看它热不热。而是要看它在某个领域的作用。就像汇编，虽然现在不热了，但是它在某些行业内还是很吃香的。PYTHON确实很强大，但在三五年内，不会作为一种主流的编程语言。至少在Windows程序开发领域内不会。 </p><p>A、解释程序<br>所谓解释程序是高级语言翻译程序的一种，它将源语言(如BASIC)书写的源程序作为输入，解释一句后就提交计算机执行一句，并不形成目标程序。就像外语翻译中的“口译”一样，说一句翻一句，不产生全文的翻译文本。这种工作方式非常适合于人通过终端设备与计算机会话，如在终端上打一条命令或语句，解释程序就立即将此语句解释成一条或几条指令并提交硬件立即执行且将执行结果反映到终端，从终端把命令打入后，就能立即得到计算结果。这的确是很方便的，很适合于一些小型机的计算问题。但解释程序执行速度很慢，例如源程序中出现循环，则解释程序也重复地解释并提交执行这一组语句，这就造成很大浪费。<br>B、编译程序<br>这是一类很重要的语言处理程序，它把高级语言(如FORTRAN、COBOL、Pascal、C等)源程序作为输入，进行翻译转换，产生出机器语言的目标程序，然后再让计算机去执行这个目标程序，得到计算结果。<br>编译程序工作时，先分析，后综合，从而得到目标程序。所谓分析，是指词法分析和语法分析；所谓综合是指代码优化，存储分配和代码生成。为了完成这些分析综合任务，编译程序采用对源程序进行多次扫描的办法，每次扫描集中完成一项或几项任务，也有一项任务分散到几次扫描去完成的。下面举一个四遍扫描的例子：第一遍扫描做词法分析；第二遍扫描做语法分析；第三遍扫描做代码优化和存储分配；第四遍扫描做代码生成。<br>值得一提的是，大多数的编译程序直接产生机器语言的目标代码，形成可执行的目标文件，但也有的编译程序则先产生汇编语言一级的符号代码文件，然后再调用汇编程序进行翻译加工处理，最后产生可执行的机器语言目标文件。<br>在实际应用中，对于需要经常使用的有大量计算的大型题目，采用招待速度较快的编译型的高级语言较好，虽然编译过程本身较为复杂，但一旦形成目标文件，以后可多次使用。相反，对于小型题目或计算简单不太费机时的题目，则多选用解释型的会话式高级语言，如BASIC，这样可以大大缩短编程及调试的时</p><h4 id="简短概述"><a href="#简短概述" class="headerlink" title="简短概述"></a>简短概述</h4><p>解释执行:<br>由解释器根据输入的数据当场执行而不生成任何的目标程序<br>编译执行: </p><p>先将源代码编译成目标语言(如:机器语言)之后通过连接程序连接到生成的目标程序进行执行</p><h2 id="问题2：网络传输-层的协议，概述UDP与TCP。"><a href="#问题2：网络传输-层的协议，概述UDP与TCP。" class="headerlink" title="问题2：网络传输 层的协议，概述UDP与TCP。"></a>问题2：网络传输 层的协议，概述UDP与TCP。</h2><p>答：举了电话通话与邮件发送的例子，由于紧张有些语无伦次。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>1.TCP面向连接（如打电话前需拨号确认连接）；UDP是无连接的（发送数据前不需要建立连接）<br>2.TCP提供可靠服务（数据无差错，不流失，不重复，有重传机制，且按序到达）；UDP尽力最大交付（不保证可靠，无重传机制，无序）<br>3.TCP面向字节流（把数据看成一连串无结构的字符流，每次取多少由主机决定）；UDP面向报文（发送多少接收多少）<br>4.TCP无界（通过字节流传输，字节流太长会拆分，太短会等待，接收方确认才会删除缓冲区；如服务器缓冲区足够大，则多次传输一次接收，被认为无界）；<br>   UDP有界（不拆分不合并，几次传输几次接收，被认为有界）<br>5.TCP有流量控制和拥塞控制（接收方让发送方的速度调节）；UDP没有流量控制（不会改变）</p><p>6.TCP的头部（20bytes）比UDP大</p><h2 id="问题3：UDP与TCP协议应用举例"><a href="#问题3：UDP与TCP协议应用举例" class="headerlink" title="问题3：UDP与TCP协议应用举例"></a>问题3：UDP与TCP协议应用举例</h2><p>答：举了IP电话与在线传输文件的例子，感觉答得不是很好。</p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… </p><p>什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率</p><h2 id="项目相关："><a href="#项目相关：" class="headerlink" title="项目相关："></a>项目相关：</h2><p>问到是否做过web项目，谈到了项目，其实之前跟着网课做过一些小项目，但自我感觉不是什么大项目，就没敢说。后来说了一些爬虫时的经历，以及自己搭建的博客。</p><h2 id="问题4：git相关命令"><a href="#问题4：git相关命令" class="headerlink" title="问题4：git相关命令"></a>问题4：git相关命令</h2><p>答：好久没用过git，许多命令其实忘得差不多了。</p><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/git.png" alt=""></p><h2 id="ACM比赛相关："><a href="#ACM比赛相关：" class="headerlink" title="ACM比赛相关："></a>ACM比赛相关：</h2><p>一些比赛经历以及有什么帮助。</p><h2 id="问题5：快排与堆排"><a href="#问题5：快排与堆排" class="headerlink" title="问题5：快排与堆排"></a>问题5：快排与堆排</h2><p>答：数据结构部分还是比较擅长的，虽然优化部分由于紧张有点记不太清楚了。</p><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>快速排序使用了分治法的策略。它的基本思想是，选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。可以看出，快速排序很重要的一点就是对基准数的选择。影响快速排序性能的因素除了本身数组的有序程度，还和这个基准数有关。在下面的代码中，我们使用最经典的，选择数组的第一个数作为基准数。</p><p>快速排序流程如下：</p><p>(1)从数列中挑出一个基准值。</p><p>(2)将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。</p><p>(3)递归地把”基准值前面的子数列”和”基准值后面的子数列”进行排序。</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><h2 id="学习情况："><a href="#学习情况：" class="headerlink" title="学习情况："></a>学习情况：</h2><p>浏览CSDN博客，看网课，看书。</p><h1 id="3-18作业帮笔试"><a href="#3-18作业帮笔试" class="headerlink" title="3.18作业帮笔试"></a>3.18作业帮笔试</h1><h2 id="作业帮笔试"><a href="#作业帮笔试" class="headerlink" title="作业帮笔试"></a>作业帮笔试</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>1~2048有多少个1。</p><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p>千位上为1共有1000个（1000~1999）</p><p>百位上为1共有2 * 100 = 200个（100~199， 1100~1199）</p><p>十位上为1共有21 * 10 = 210个（XX10~XX19，XX∈[0，20]）</p><p>个位上为1共有205个（不多说了，自行脑补）</p><p>一共有1000+200+210+205 = 1615个</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>给出树的前序与中序遍历，求后序。</p><h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><p>不多说了，不会的话自行面壁。</p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>死锁产生的条件。</p><h4 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h4><p>互斥条件，请求与保持条件，不可抢夺条件，循环等待条件。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>0，2，3，5，9，17，31，57，___</p><h4 id="解法：-3"><a href="#解法：-3" class="headerlink" title="解法："></a>解法：</h4><p>105（17+31+57）</p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><p>2019！末尾有多少个0</p><h4 id="解法：-4"><a href="#解法：-4" class="headerlink" title="解法："></a>解法：</h4><p>重点在于质因数的运用，要点如下 </p><p>1、基本的一点，2<em>5=10，得到1个0 可以写成2^1</em>5^1=10^1 </p><p>2、进一步，4<em>25=100，得到2个0 可以写成2^2</em>5^2=10^2 </p><p>3、进一步，8<em>125=1000，得到3个0 可以写成2^3</em>5^3=10^3 </p><p>4、进一步，16<em>625=10000，得到4个0 可以写成2^4</em>5^4=10^4 </p><p>5、5^5=3125超过2015了，所以5次方以上不考虑 </p><p>6、不要担心双数的个数不够用，它会多出很多 </p><p>7、有了上面的1到4条，就可以计算了 (运算符<em>表示乘法，^表示乘方) </em></p><p>第一步，计算1到2015里多少个5,25,125,625 </p><p>1、2015÷5=403 记作A1；</p><p>2、2015÷25=80.6取整得80 记作A2； </p><p>3、2015÷125=16.12取整得16 记作A3； </p><p>4、2015÷625=3.224取整得3 记作A4； </p><p>第二步，计算上述A1到A4中重复的部分 </p><p>1、能被5整除的数里包含的能被25整除的数，记作B1 B1=A1-A2=403-80=323； </p><p>2、能被25整除的数里包含的能被125整除的数，记作B2 B2=A2-A3=80-16=64； </p><p>3、能被125整除的数里包含的能被625整除的数，记作B3 B3=A3-A4=16-3=13； </p><p>4、能被625整除的数里没有重复其它情况，直接计入结果，记作B4 B4=A4； </p><p>第三步，最终结果是 B1<em>1+B2</em>2+B3<em>3+B4</em>4=323+128+39+12=502………(1) </p><p>【答案】502个 最终结果也可以这样算： A1+A2+A3+A4=403+80+16+3=502 ………(2） 也就是 2015÷5+2015÷25+2015÷125+2015÷625 =403+80+16+3=502</p><h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><p>给出一列数，将其中所有的0放置末尾</p><p>例如1，2，0，3，0，4，则为1，2，3，4，0，0</p><h4 id="解法：-5"><a href="#解法：-5" class="headerlink" title="解法："></a>解法：</h4><p>两个指针，一个快指针，一个慢指针，如果快指针指向的数不为0，则快指针的值赋给慢指针，快指针慢指针均前进一步，否则快指针前进一步，慢指针不动。最后快指针指向尾了，如果慢指针没指向尾，之后的值全部为0。</p><h3 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h3><p>判断字符串是否为合法密码（长度大于8，含三类不同字符，且长度大于2的子串不能出现相同情况，例如A1abcdabc不合法，abc出现两次）</p><h4 id="解法：-6"><a href="#解法：-6" class="headerlink" title="解法："></a>解法：</h4><p>前两点太简单就不说了，第3点可以使用set每一次储存3个连续的字符，如果重复就不是合法的字符。</p><h3 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h3><p>5张牌斗牛，其中三张牌之和取余为0即为牛，剩余两张牌之和取余为几结果即为牛几。</p><h4 id="解法：-7"><a href="#解法：-7" class="headerlink" title="解法："></a>解法：</h4><p>5张牌只取个位数，然map记录下来，5张牌相加取余，然后依次减去其中一张牌，看得到的数字在map里存不存在，如果存在就说明有牛，牛就是5张牌相加的结果。也就是5张只和减两张看是不是0。相当于一层循环 ，On时间复杂度 </p><h1 id="3-19腾讯提前批二面"><a href="#3-19腾讯提前批二面" class="headerlink" title="3.19腾讯提前批二面"></a>3.19腾讯提前批二面</h1><h2 id="腾讯二面"><a href="#腾讯二面" class="headerlink" title="腾讯二面"></a>腾讯二面</h2><p>面试官好像是个技术总监，声音特别小，听的不是很清楚。总之10分钟结束，什么问题也没问，只留下一句之后等结果。然后就挂了，挂的莫名其妙。总结一下教训：</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>尽量2分钟左右。要提到很高兴参加贵公司的面试。结尾尽量要客气。</p><h3 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h3><p>千万不要说项目少，小项目也可以提及，不然对方真以为自己没项目了。（惨痛的教训）</p><h3 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h3><p>其实敲代码没什么不好的，我们实习生本来就是应该干底层的（qyq）</p><h3 id="岗位期望"><a href="#岗位期望" class="headerlink" title="岗位期望"></a>岗位期望</h3><p>后台研发，我期望做……当然具体还是听从部门的安排，如果部门安排我做哪一块那我会听从部门的安排，然后尽快学习相关技能，尽快融入其中。</p><h3 id="实习计划"><a href="#实习计划" class="headerlink" title="实习计划"></a>实习计划</h3><p>1.首先尽快了解企业文化，了解部门规章制度，以便争取未来尽快融入。</p><p>2.了解所在团队的成员情况，分工，自己的角色和职责，以便更好的配合。</p><p>3.了解岗前应会的内容，及团队当前的主要工作及进展。</p><p>4.拟定工作计划，经组长审阅后按照计划推进。</p><p>5.自己会不断学习，积极寻求同事和领导的帮助。以达成更好的业绩。</p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>切忌书生气，不能高谈阔论，一副兴趣广泛的样子。尽量要和职业贴近，否则就不要说的太多。</p><p>然后面试结束，没问任何专业相关问题，GG。</p><h1 id="3-20阿里一面"><a href="#3-20阿里一面" class="headerlink" title="3.20阿里一面"></a>3.20阿里一面</h1><h2 id="阿里首面"><a href="#阿里首面" class="headerlink" title="阿里首面"></a>阿里首面</h2><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>C++指针与引用的区别及内存情况</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h3><p>智能指针问题</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h3><p>hash_map与map的区别，底层构造，时间复杂度，选择</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题4-1"><a href="#问题4-1" class="headerlink" title="问题4"></a>问题4</h3><p>手写代码树的中序遍历</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题5-1"><a href="#问题5-1" class="headerlink" title="问题5"></a>问题5</h3><p>vector的机制</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题6-1"><a href="#问题6-1" class="headerlink" title="问题6"></a>问题6</h3><p>堆排序原理</p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题7-1"><a href="#问题7-1" class="headerlink" title="问题7"></a>问题7</h3><p>集合中，输出所有子集。</p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题8-1"><a href="#问题8-1" class="headerlink" title="问题8"></a>问题8</h3><p>红墨水蓝墨水问题</p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>一样多。</p><h3 id="问题9"><a href="#问题9" class="headerlink" title="问题9"></a>问题9</h3><p>智能指针</p><h3 id="现状及项目"><a href="#现状及项目" class="headerlink" title="现状及项目"></a>现状及项目</h3><h3 id="问题10"><a href="#问题10" class="headerlink" title="问题10"></a>问题10</h3><p>预处理以及#ifdef</p><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>选择性编译</p><h3 id="问题11"><a href="#问题11" class="headerlink" title="问题11"></a>问题11</h3><p>awk命令</p><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><h1 id="3-22西科"><a href="#3-22西科" class="headerlink" title="3.22西科"></a>3.22西科</h1><p>具体不多说了，培训班一样。</p><h1 id="3-25旷世笔试"><a href="#3-25旷世笔试" class="headerlink" title="3.25旷世笔试"></a>3.25旷世笔试</h1><h1 id="3-26虎牙笔试"><a href="#3-26虎牙笔试" class="headerlink" title="3.26虎牙笔试"></a>3.26虎牙笔试</h1><h1 id="3-27西山居笔试"><a href="#3-27西山居笔试" class="headerlink" title="3.27西山居笔试"></a>3.27西山居笔试</h1><h1 id="3-28西山居一面"><a href="#3-28西山居一面" class="headerlink" title="3.28西山居一面"></a>3.28西山居一面</h1><ol><li><p>类内const如何初始化</p></li><li><p>代码规范化问题，以及析构函数与构造函数调用问题</p><p>1、C++中, 构造函数和析构函数可以被显示调用. 显示调用默认构造函数的语法: a.A::A();(不能写成a.A();) , 显示调用非默认构造函数的语法: a.A::A(7);(不能写成a.A(7);); 显示调用析构函数的语法: a.A::~A();(可以写成a.~A();) .</p><p>2、显示调用构造函数和析构函数就像调用一般的函数一样, 并不意味着创建或销毁对象;</p><p>3、如果构造函数中动态分配了空间, 则显示调用构造函数会造成内存泄露. 创建对象时的隐式构造函数调用已经为对象分配了动态内存，当用创建好的对象显示调用构造函数时, 对象指向的动态内存更新为显示调用时所分配的, 对象生命周期结束时析构函数所释放掉的是后一次分配的动态内存, 也就是说创建对象时隐式构造函数调用所分配的那块内存泄漏了.</p><p>4、如果析构函数中释放动态分配的空间, 则会造成多次释放同一内存, 会出现严重错误. </p></li><li><p>三子棋问题</p></li><li><p>C++虚函数及底层实现</p><p>虚函数表</p></li><li><p>容器及各自底层实现</p></li><li><p>结构体对齐</p></li><li><p>C++11特性</p></li><li><p>内联函数与宏定义</p></li><li><p>连连看寻路问题</p></li><li><p>双属性排序问题</p></li><li><p>字符串最大值问题</p></li><li><p>找bug，野指针问题</p></li><li><p>研发岗难度在哪方面（哪些方向）</p></li></ol><h1 id="3-29西山居二三四面"><a href="#3-29西山居二三四面" class="headerlink" title="3.29西山居二三四面"></a>3.29西山居二三四面</h1><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>项目</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>笔试题</p><p>智能指针</p><h2 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h2><p>项目</p><p>比赛担当角色</p><p>虚函数表</p><p>模板</p><p>Dijkstra算法分析</p><p>Linux下两个pthread如何实现同步</p><p>socket编程IO多路复用</p><p>如何看待自己的组织能力</p><p>上岗时间</p><h1 id="4-1东方财富一面"><a href="#4-1东方财富一面" class="headerlink" title="4.1东方财富一面"></a>4.1东方财富一面</h1><p>使用过哪些API</p><p>知道哪些设计模式</p><p>单例设计模式讲解</p><p>101个数(0, 100]，只有一个数出现两次，找出这个数。</p><h1 id="4-4声网一面"><a href="#4-4声网一面" class="headerlink" title="4.4声网一面"></a>4.4声网一面</h1><h1 id="4-5腾讯笔试"><a href="#4-5腾讯笔试" class="headerlink" title="4.5腾讯笔试"></a>4.5腾讯笔试</h1><h1 id="4-9声网二面"><a href="#4-9声网二面" class="headerlink" title="4.9声网二面"></a>4.9声网二面</h1><p>项目</p><p>聊天室项目</p><p>找中位数</p><p>第k大数</p><p>矩阵n次方</p><h1 id="4-12阿里二面"><a href="#4-12阿里二面" class="headerlink" title="4.12阿里二面"></a>4.12阿里二面</h1><p>多态</p><p>调试</p><p>服务器正在运行程序如何调试</p><p>vector的reserve与resize区别</p><p>链表交叉结点</p><p>找中位数</p><p>n个硬盘每个损坏概率p，且m个硬盘坏掉概率——(p^m)*((1-p)^(n-m))</p><h1 id="4-14腾讯正式批一面"><a href="#4-14腾讯正式批一面" class="headerlink" title="4.14腾讯正式批一面"></a>4.14腾讯正式批一面</h1><p>爬虫项目介绍</p><p>如何反爬（不知道）</p><p>智能指针概述</p><p>遇到异常处理如何解决内存释放问题</p><p>如何处理未知异常（不知道）</p><p>仿函数（不知道）</p><p>用过stl哪些算法</p><p>A*搜索</p><p>Linux相关命令</p><p>如何判断某目录下某文件是否存在（find –name）</p><p>如何计算某目录下文件个数（C语言实现readdir）</p><p>多进程多线程相关</p><p>进程间通信方式</p><p>详细概述epoll</p><p>read返回值（返回值为长度。为0断开连接，-1为异常）</p><p>边沿触发（阻塞，非阻塞）</p><p>数据库了解多少</p><h1 id="4-21腾讯正式批二面"><a href="#4-21腾讯正式批二面" class="headerlink" title="4.21腾讯正式批二面"></a>4.21腾讯正式批二面</h1><p>操作系统部分基本没答上一个，答到最后都以为必挂了。真心感谢面试官小哥哥手下留情(^人^)</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>TCP与UDP概述</p><p>可靠的UDP协议（不知道）</p><p>四次挥手过程</p><p>timewait在第几次挥手</p><p>timewait作用</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>智能指针相关</p><p>STL容器用过哪些</p><p>vector机制</p><p>deque机制</p><p>delete数组（好久没怎么复习了）</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>集合求子集</p><p>输出数组中唯一只有一个不重复元素</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>分页与分段的区别（有点印象）</p><p>概述进程（经常使用，却不清楚概念QYQ）</p><p>进程调度算法（完全忘记了）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-15腾讯提前批一面&quot;&gt;&lt;a href=&quot;#3-15腾讯提前批一面&quot; class=&quot;headerlink&quot; title=&quot;3.15腾讯提前批一面&quot;&gt;&lt;/a&gt;3.15腾讯提前批一面&lt;/h1&gt;&lt;p&gt;第一次电话面试，而且是腾讯的，真的感觉特别紧张。虽然面试官小哥哥人特
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="面经" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://qianyouyou.cn/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>温习C++继承与多态之打造简易回合制5V5小游戏</title>
    <link href="http://qianyouyou.cn/2019/03/11/2019-03-11/"/>
    <id>http://qianyouyou.cn/2019/03/11/2019-03-11/</id>
    <published>2019-03-11T13:16:23.000Z</published>
    <updated>2019-04-27T15:40:07.217Z</updated>
    
    <content type="html"><![CDATA[<p>曾几何时，网页游戏风靡整个网络世界，然而手机游戏的出现，如今的网页游戏已经渐渐销声匿迹了。</p><p>还记得我玩的第一款时间较长的网页游戏——龙将，如今服务器已关闭了，包括代理商“风行”如今也鲜为人知。其实那款游戏很简单，两个玩家对弈，双方每人出场5个英雄，按回合制以英雄的速度为先后顺序，每个英雄普通攻击或使用技能，直到一方的所有英雄全部死亡为止。所有攻击操作都是自动的，不需要我们操作，我们只需选择英雄上阵即可。</p><p>曾经想着什么时候能自己编一款类似的游戏，以便属性按照自己的想法设定。如今就简简单单实现一下吧。（超级粗略哦）</p><p>首先，我们来分析一下，每个英雄都有攻击属性，防御属性，速度，生命值，还有一些特殊的效果（暴击，吸血什么的啦），英雄可以装备武器，可以对敌方英雄造成伤害。那么我们先创建一个Hero类，它包含上述所有属性及方法。然后，每个英雄不同之处在于技能与被动技能，那我们利用多态来实现不同的技能。</p><p>再来分析一下武器，武器有基础属性和特殊属性，不同的武器属性不同，那么我们先创建一个基类Weapon类，该类函数声明为纯虚类，不可被继承，由派生来来实现具体功能即可。</p><p>英雄和武器写完之后，再创建一个国家类。由于英雄以国家而划分，所以每个国家由许多英雄类指针组成。</p><p>每个玩家有5个英雄，具体实现同国家类。</p><p>图示如下</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-3-11.png" alt=""></p><p>由于本人比较懒，写着写着又犯懒了，所以技能方面还没实现，每次都是普通攻击触发各种效果。不过目前可以正常运行。等哪天有时间了再继续改进吧。以下是代码：</p><p><strong>Weapon.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//抽象类</span><br><span class="line">class Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage() = 0;</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef() = 0;</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood() = 0;</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold() = 0;</span><br><span class="line"></span><br><span class="line">static bool isTrigger(int rate);</span><br><span class="line"></span><br><span class="line">string m_WeaponName;//武器名</span><br><span class="line">int m_BaceDamage;//基础伤害</span><br><span class="line">int BaceDef;//基础防御</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Knife :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Knife();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DragonSword :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">DragonSword();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sword :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Sword();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int suckRate;</span><br><span class="line">int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shield :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Shield();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Spear :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Spear();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line">int suckRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bow :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Bow();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Book :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Book();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int suckRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Fan :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Fan();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int holdRate;</span><br><span class="line">int suckRate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Weapon.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Weapon.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Knife::Knife()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 10;</span><br><span class="line">this-&gt;BaceDef = 0;</span><br><span class="line">this-&gt;holdRate = 30;</span><br><span class="line">this-&gt;m_WeaponName = &quot;锋利匕首&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Knife::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Knife::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Knife::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Knife::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DragonSword::DragonSword()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 20;</span><br><span class="line">this-&gt;m_WeaponName = &quot;屠龙宝刀&quot;;</span><br><span class="line">this-&gt;BaceDef = 10;</span><br><span class="line">this-&gt;holdRate = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DragonSword::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DragonSword::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DragonSword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DragonSword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Weapon::isTrigger(int rate)</span><br><span class="line">&#123;</span><br><span class="line">if (rate &gt;= rand() % 100 + 1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sword::Sword()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 20;</span><br><span class="line">this-&gt;m_WeaponName = &quot;倚天神剑&quot;;</span><br><span class="line">this-&gt;BaceDef = 10;</span><br><span class="line">this-&gt;suckRate = 10;</span><br><span class="line">this-&gt;holdRate = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sword::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sword::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Sword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Sword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shield::Shield()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 0;</span><br><span class="line">this-&gt;m_WeaponName = &quot;刑天巨盾&quot;;</span><br><span class="line">this-&gt;BaceDef = 70;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Shield::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Shield::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Shield::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Shield::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Spear::Spear()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 10;</span><br><span class="line">this-&gt;m_WeaponName = &quot;亮银长枪&quot;;</span><br><span class="line">this-&gt;BaceDef =20;</span><br><span class="line">this-&gt;suckRate = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Spear::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Spear::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Spear::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Spear::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bow::Bow()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 70;</span><br><span class="line">this-&gt;m_WeaponName = &quot;射日神弓&quot;;</span><br><span class="line">this-&gt;BaceDef = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bow::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bow::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bow::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bow::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Book::Book()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 0;</span><br><span class="line">this-&gt;m_WeaponName = &quot;遁甲天书&quot;;</span><br><span class="line">this-&gt;BaceDef = 10;</span><br><span class="line">this-&gt;suckRate = 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Book::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Book::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Book::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Book::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fan::Fan()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 30;</span><br><span class="line">this-&gt;m_WeaponName = &quot;朱雀羽扇&quot;;</span><br><span class="line">this-&gt;BaceDef = 0;</span><br><span class="line">this-&gt;suckRate = 10;</span><br><span class="line">this-&gt;holdRate = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Fan::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Fan::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Fan::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Fan::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hero.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&quot;Weapon.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class Hero &#123;</span><br><span class="line">public:</span><br><span class="line">Hero();</span><br><span class="line">int getHP();</span><br><span class="line">int getMP();</span><br><span class="line">int getAtk();</span><br><span class="line">int getDef();</span><br><span class="line">string getName();</span><br><span class="line">bool action();</span><br><span class="line">void getInf();</span><br><span class="line">void attack(Hero*hero);</span><br><span class="line">bool isRate(int rate);</span><br><span class="line">void init_property();</span><br><span class="line">virtual void skill(Hero * hero) = 0;</span><br><span class="line">virtual void passive_skill() = 0;</span><br><span class="line"></span><br><span class="line">bool isDeath;//是否死亡</span><br><span class="line"></span><br><span class="line">Weapon*weapon;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">int max_HP;</span><br><span class="line">int HP;//血量</span><br><span class="line">int MP;//蓝量</span><br><span class="line">int atk;//攻击力</span><br><span class="line">int def;//防御力</span><br><span class="line">int vel;//速度</span><br><span class="line"></span><br><span class="line">string name;//姓名</span><br><span class="line">string ctry;//国家</span><br><span class="line">int id;//编号</span><br><span class="line">string sex;//性别</span><br><span class="line">string skill_show;</span><br><span class="line">string skill_name;</span><br><span class="line"></span><br><span class="line">int wisdom;//智慧</span><br><span class="line">int strategy;//谋略</span><br><span class="line">int force;//力量</span><br><span class="line">int agility;//敏捷</span><br><span class="line"></span><br><span class="line">int crit;//暴击</span><br><span class="line">int stun;//重击</span><br><span class="line">int suckBlood;//回血</span><br><span class="line">int miss;//闪避</span><br><span class="line"></span><br><span class="line">bool isDiz;//眩晕</span><br><span class="line">bool isBleed;//流血</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Hero.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;hero.h&quot;</span><br><span class="line">#include &quot;Monster.h&quot;</span><br><span class="line">Hero::Hero()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_HP = 500;</span><br><span class="line">this-&gt;m_Atk = 50;</span><br><span class="line">this-&gt;m_Def = 50;</span><br><span class="line">this-&gt;m_Name = &quot;靓仔&quot;;</span><br><span class="line">this-&gt;weapon = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hero::EquipWeapon(Weapon * weapon)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;weapon = weapon;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;装备了&quot; &lt;&lt; this-&gt;weapon-&gt;m_WeaponName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hero::Attack(Monster * monster)</span><br><span class="line">&#123;</span><br><span class="line">int damage = 0;</span><br><span class="line">int addHP = 0;</span><br><span class="line">bool isHold = false;</span><br><span class="line">bool isCrit = false;</span><br><span class="line">if (this-&gt;weapon == NULL) &#123;</span><br><span class="line">damage = this-&gt;m_Atk;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">damage = this-&gt;m_Atk + this-&gt;weapon-&gt;getBaceDamage();</span><br><span class="line">addHP = this-&gt;weapon-&gt;getSuckBlood();</span><br><span class="line">isHold = this-&gt;weapon-&gt;getHold();</span><br><span class="line">isCrit = this-&gt;weapon-&gt;getCrit();</span><br><span class="line">if (addHP) &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄触发吸血效果，回血&quot; &lt;&lt; addHP &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if (isCrit) &#123;</span><br><span class="line">damage *= 2;</span><br><span class="line">cout &lt;&lt; &quot;英雄触发暴击效果，怪兽受到双倍伤害&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if (isHold) &#123;</span><br><span class="line">monster-&gt;m_Hold = isHold;</span><br><span class="line">cout &lt;&lt; &quot;英雄触发定身效果，怪兽停止行动一回合&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">damage = damage &gt; monster-&gt;m_Def ? damage - monster-&gt;m_Def : 1;</span><br><span class="line">monster-&gt;m_HP -= damage;</span><br><span class="line">this-&gt;m_HP += addHP;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;对怪兽&quot; &lt;&lt; monster-&gt;m_Name &lt;&lt; &quot;造成了&quot; &lt;&lt; damage &lt;&lt; &quot;点伤害。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Country.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line">#include&quot;Wei.h&quot;</span><br><span class="line">#include&quot;Shu.h&quot;</span><br><span class="line">#include&quot;Wu.h&quot;</span><br><span class="line">#include&quot;Qun.h&quot;</span><br><span class="line">#define NUM_HERO 12</span><br><span class="line">class Wei&#123;</span><br><span class="line">public:</span><br><span class="line">Wei() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">wei[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Wei() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete wei[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*wei[NUM_HERO] = &#123;</span><br><span class="line">new(CaoCao),</span><br><span class="line">new(DianWei),</span><br><span class="line">new(XuChu),</span><br><span class="line">new(GuoJia),</span><br><span class="line">new(XiaHouDun),</span><br><span class="line">new(XiaHouYuan),</span><br><span class="line">new(CaoRen),</span><br><span class="line">new(ZhangLiao),</span><br><span class="line">new(SiMaYi),</span><br><span class="line">new(XuHuang),</span><br><span class="line">new(ZhenJi),</span><br><span class="line">new(CaiWenJi)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shu&#123;</span><br><span class="line">public:</span><br><span class="line">Shu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">shu[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Shu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete shu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*shu[NUM_HERO] = &#123;</span><br><span class="line">new(LiuBei),</span><br><span class="line">new(GuanYu),</span><br><span class="line">new(ZhangFei),</span><br><span class="line">new(ZhuGeLiang),</span><br><span class="line">new(ZhaoYun),</span><br><span class="line">new(MaChao),</span><br><span class="line">new(HuangZhong),</span><br><span class="line">new(WeiYan),</span><br><span class="line">new(HuangYueYing),</span><br><span class="line">new(JiangWei),</span><br><span class="line">new(PangTong),</span><br><span class="line">new(SunShangXiang)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123;false&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Wu&#123;</span><br><span class="line">public:</span><br><span class="line">Wu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">wu[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Wu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete wu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*wu[NUM_HERO] = &#123;</span><br><span class="line">new(SunCe),</span><br><span class="line">new(ZhouYu),</span><br><span class="line">new(SunQuan),</span><br><span class="line">new(DaQiao),</span><br><span class="line">new(XiaoQiao),</span><br><span class="line">new(HuangGai),</span><br><span class="line">new(TaiShiCi),</span><br><span class="line">new(GanNing),</span><br><span class="line">new(LuSu),</span><br><span class="line">new(LvMeng),</span><br><span class="line">new(ZhangZhao),</span><br><span class="line">new(ZhouTai)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Qun &#123;</span><br><span class="line">public:</span><br><span class="line">Qun() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">qun[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Qun() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete qun[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*qun[NUM_HERO] = &#123;</span><br><span class="line">new(LvBu),</span><br><span class="line">new(DiaoChan),</span><br><span class="line">new(HuaTuo),</span><br><span class="line">new(YuanShao),</span><br><span class="line">new(YanLiang),</span><br><span class="line">new(WenChou),</span><br><span class="line">new(ZuoCi),</span><br><span class="line">new(HuaXiong),</span><br><span class="line">new(GongSunZan),</span><br><span class="line">new(ZhangJiao),</span><br><span class="line">new(YuJi),</span><br><span class="line">new(LingJu)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>User.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Country.h&quot;</span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">Hero * hero[5];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Play.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">play();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Play.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Country.h&quot;</span><br><span class="line">#include&quot;User.h&quot;</span><br><span class="line">void test();</span><br><span class="line">void play();</span><br><span class="line">void show(User &amp;user);</span><br><span class="line">bool isDeath(User &amp; user);</span><br></pre></td></tr></table></figure><p><strong>Play.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Play.h&quot;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">void test() &#123;</span><br><span class="line">Hero * hero_1 = new(ZhangFei);</span><br><span class="line">Hero *hero_2 = new(GuanYu);</span><br><span class="line"></span><br><span class="line">int round = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">getchar();</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl;</span><br><span class="line">hero_1-&gt;attack(hero_2);</span><br><span class="line">if (hero_2-&gt;getHP() &lt;= 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你赢了&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">hero_2-&gt;attack(hero_1);</span><br><span class="line">if (hero_1-&gt;getHP() &lt;= 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你输了&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_1-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_2-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(hero_1);</span><br><span class="line">delete(hero_2);</span><br><span class="line">&#125;</span><br><span class="line">void play() &#123;</span><br><span class="line">srand(time(NULL));</span><br><span class="line">User user_1;</span><br><span class="line">cout &lt;&lt; &quot;玩家一选择&quot; &lt;&lt; endl;</span><br><span class="line">show(user_1);</span><br><span class="line">User user_2;</span><br><span class="line">cout &lt;&lt; &quot;玩家二选择&quot; &lt;&lt; endl;</span><br><span class="line">show(user_2);</span><br><span class="line">int round = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">getchar();</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">if (!user_1.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">int Tmp = rand() % 5;</span><br><span class="line">while (user_2.hero[Tmp]-&gt;isDeath) &#123;</span><br><span class="line">if (isDeath(user_2)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">Tmp = rand() % 5;</span><br><span class="line">&#125;</span><br><span class="line">user_1.hero[i]-&gt;attack(user_2.hero[Tmp]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl;</span><br><span class="line">if (!user_2.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">int Tmp = rand() % 5;</span><br><span class="line">while (user_1.hero[Tmp]-&gt;isDeath) &#123;</span><br><span class="line">if (isDeath(user_1)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">Tmp = rand() % 5;</span><br><span class="line">&#125;</span><br><span class="line">user_2.hero[i]-&gt;attack(user_1.hero[Tmp]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if (isDeath(user_2)) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Victory！&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (isDeath(user_1)) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Defeat！&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">if (!user_1.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_1.hero[i]-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">if (!user_2.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_2.hero[i]-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isDeath(User &amp; user) &#123;</span><br><span class="line">int cnt;</span><br><span class="line">for (cnt = 0; cnt &lt; 5; cnt++) &#123;</span><br><span class="line">if (!user.hero[cnt]-&gt;isDeath) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (cnt &gt;= 5) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">void show(User &amp;user)</span><br><span class="line">&#123;</span><br><span class="line">int flag;</span><br><span class="line">cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;请选择您的阵营&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;---&quot; &lt;&lt; &quot;1.魏----2.蜀----3.吴----4.群&quot; &lt;&lt; &quot;---&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;--------------&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; flag;</span><br><span class="line">int tmp[5];</span><br><span class="line">Wei *wei;</span><br><span class="line">Shu *shu;</span><br><span class="line">Wu *wu;</span><br><span class="line">Qun *qun;</span><br><span class="line">switch (flag) &#123;</span><br><span class="line">case 1:</span><br><span class="line">cout &lt;&lt; &quot;您已加入魏国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">wei = new Wei;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = wei-&gt;wei[tmp[i]-1];</span><br><span class="line">wei-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete wei;</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">cout &lt;&lt; &quot;您已加入蜀国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">shu = new Shu;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = shu-&gt;shu[tmp[i]-1];</span><br><span class="line">shu-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete shu;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">cout &lt;&lt; &quot;您已加入吴国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">wu = new Wu;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = wu-&gt;wu[tmp[i]-1];</span><br><span class="line">wu-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete wu;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">cout &lt;&lt; &quot;您已加入群雄阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">qun = new Qun;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = qun-&gt;qun[tmp[i]-1];</span><br><span class="line">qun-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete qun;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wei.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class CaoCao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">CaoCao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DianWei :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">DianWei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XuChu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XuChu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GuoJia : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GuoJia();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaHouDun : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XiaHouDun();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaHouYuan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XiaHouYuan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CaoRen : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">CaoRen();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangLiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangLiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SiMaYi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SiMaYi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XuHuang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XuHuang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhenJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhenJi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CaiWenJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">CaiWenJi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Wei.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Wei.h&quot;</span><br><span class="line"></span><br><span class="line">CaoCao::CaoCao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;曹操&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 92;//谋略</span><br><span class="line">force = 55;//力量</span><br><span class="line">agility = 28;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;天下归心&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoCao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoCao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;force;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DianWei::DianWei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;典韦&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 54;//智慧</span><br><span class="line">strategy = 32;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;古之恶来&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DianWei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DianWei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP = ceil(this-&gt;HP*1.4);</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;def += floor(this-&gt;force*0.7);</span><br><span class="line">this-&gt;atk = ceil(this-&gt;atk * 0.9);</span><br><span class="line">this-&gt;suckBlood += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XuChu::XuChu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;许褚&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 50;//智慧</span><br><span class="line">strategy = 20;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;虎痴卸甲&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuChu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuChu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk = floor(this-&gt;atk*1.3);</span><br><span class="line">this-&gt;crit += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GuoJia::GuoJia()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;郭嘉&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 100;//智慧</span><br><span class="line">strategy = 98;//谋略</span><br><span class="line">force = 5;//力量</span><br><span class="line">agility = 10;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;鬼才&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuoJia::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuoJia::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel += this-&gt;wisdom;</span><br><span class="line">this-&gt;stun += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaHouDun::XiaHouDun()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;夏侯惇&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 78;//智慧</span><br><span class="line">strategy = 56;//谋略</span><br><span class="line">force = 85;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouDun::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouDun::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk += 20;</span><br><span class="line">this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaHouYuan::XiaHouYuan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;夏侯渊&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 72;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 95;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouYuan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouYuan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel = ceil(this-&gt;vel*1.3);</span><br><span class="line">this-&gt;atk += this-&gt;strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaoRen::CaoRen()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;曹仁&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 77;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 72;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;无懈可击&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoRen::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoRen::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += 2000;</span><br><span class="line">this-&gt;max_HP = HP;</span><br><span class="line">this-&gt;def = ceil(this-&gt;def*1.2);</span><br><span class="line">this-&gt;atk = floor(this-&gt;atk*0.4);</span><br><span class="line">this-&gt;suckBlood += 80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangLiao::ZhangLiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张辽&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 82;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 78;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangLiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangLiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;miss += 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SiMaYi::SiMaYi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;司马懿&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 99;//智慧</span><br><span class="line">strategy = 100;//谋略</span><br><span class="line">force = 34;//力量</span><br><span class="line">agility = 45;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;狼顾之相&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SiMaYi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SiMaYi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;agility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XuHuang::XuHuang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;徐晃&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 75;//智慧</span><br><span class="line">strategy = 82;//谋略</span><br><span class="line">force = 82;//力量</span><br><span class="line">agility = 75;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;兵粮寸断&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuHuang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuHuang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk += this-&gt;force;</span><br><span class="line">this-&gt;stun += 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhenJi::ZhenJi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;甄姬&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 25;//谋略</span><br><span class="line">force = 20;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;洛神降临&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhenJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhenJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;def += this-&gt;strategy * 0.5 + this-&gt;wisdom * 0.2;</span><br><span class="line">this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaiWenJi::CaiWenJi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;蔡文姬&quot;;//姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 95;//智慧</span><br><span class="line">strategy = 35;//谋略</span><br><span class="line">force = 25;//力量</span><br><span class="line">agility = 55;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;胡笳之音&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaiWenJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaiWenJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;stun += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shu.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class LiuBei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LiuBei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GuanYu :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GuanYu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangFei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangFei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhuGeLiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhuGeLiang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhaoYun : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhaoYun();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MaChao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">MaChao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangZhong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuangZhong();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WeiYan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">WeiYan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangYueYing : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuangYueYing();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class JiangWei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">JiangWei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class PangTong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">PangTong();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SunShangXiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SunShangXiang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Shu.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Shu.h&quot;</span><br><span class="line"></span><br><span class="line">LiuBei::LiuBei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;刘备&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 72;//智慧</span><br><span class="line">strategy = 62;//谋略</span><br><span class="line">force = 60;//力量</span><br><span class="line">agility = 25;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;唯贤唯德&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LiuBei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LiuBei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GuanYu::GuanYu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;关羽&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 60;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;春秋偃月&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuanYu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuanYu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangFei::ZhangFei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张飞&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 70;//智慧</span><br><span class="line">strategy = 77;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;雷霆咆哮&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangFei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangFei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk = floor(this-&gt;atk*0.9);</span><br><span class="line">this-&gt;crit += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZhuGeLiang::ZhuGeLiang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;诸葛亮&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 100;//智慧</span><br><span class="line">strategy = 100;//谋略</span><br><span class="line">force = 10;//力量</span><br><span class="line">agility = 32;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;卧龙啸天&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhuGeLiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhuGeLiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel += 50;</span><br><span class="line">this-&gt;atk += 50;</span><br><span class="line">this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhaoYun::ZhaoYun()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;赵云&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 75;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;七探蛇盘&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhaoYun::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhaoYun::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;miss += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MaChao::MaChao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;马超&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 42;//智慧</span><br><span class="line">strategy = 20;//谋略</span><br><span class="line">force = 95;//力量</span><br><span class="line">agility = 94;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;西凉铁骑&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MaChao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MaChao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel *= 2;</span><br><span class="line">this-&gt;crit += 30;</span><br><span class="line">this-&gt;stun += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangZhong::HuangZhong()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;黄忠&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 50;//智慧</span><br><span class="line">strategy = 45;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;百步穿杨&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangZhong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangZhong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk += 20;</span><br><span class="line">this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WeiYan::WeiYan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;魏延&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 25;//智慧</span><br><span class="line">strategy = 75;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 75;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;傲骨风凉&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WeiYan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WeiYan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk *= 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangYueYing::HuangYueYing()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;黄月英&quot;;//姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 99;//智慧</span><br><span class="line">strategy = 90;//谋略</span><br><span class="line">force = 5;//力量</span><br><span class="line">agility = 65;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;奇门遁甲&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangYueYing::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangYueYing::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;def += 50;</span><br><span class="line">this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JiangWei::JiangWei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;姜维&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 92;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;幼麟之风&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JiangWei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JiangWei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PangTong::PangTong()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;庞统&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 94;//谋略</span><br><span class="line">force = 5;//力量</span><br><span class="line">agility = 18;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;火凤燎原&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PangTong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PangTong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk *= 1.2;</span><br><span class="line">this-&gt;vel *= 1.2;</span><br><span class="line">this-&gt;def *= 1.2;</span><br><span class="line">this-&gt;miss += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SunShangXiang::SunShangXiang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;孙尚香&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 56;//智慧</span><br><span class="line">strategy = 42;//谋略</span><br><span class="line">force = 65;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;枭姬联姻&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunShangXiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunShangXiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;miss += 20;</span><br><span class="line">this-&gt;stun += 20;</span><br><span class="line">this-&gt;atk += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wu.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class SunCe : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SunCe();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhouYu :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhouYu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SunQuan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SunQuan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DaQiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">DaQiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaoQiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XiaoQiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangGai : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuangGai();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TaiShiCi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">TaiShiCi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GanNing : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GanNing();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LuSu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LuSu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LvMeng : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LvMeng();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangZhao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangZhao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhouTai : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhouTai();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Wu.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Wu.h&quot;</span><br><span class="line"></span><br><span class="line">SunCe::SunCe()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;孙策&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 78;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 85;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;力拔山河&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunCe::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunCe::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;wisdom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhouYu::ZhouYu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;周瑜&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 98;//谋略</span><br><span class="line">force = 70;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;业火焚天&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouYu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouYu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SunQuan::SunQuan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;孙权&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 50;//力量</span><br><span class="line">agility = 60;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;气势汹汹&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunQuan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunQuan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DaQiao::DaQiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;大乔&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 85;//智慧</span><br><span class="line">strategy = 45;//谋略</span><br><span class="line">force = 30;//力量</span><br><span class="line">agility = 75;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;国色天香&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DaQiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DaQiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaoQiao::XiaoQiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;小乔&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 40;//谋略</span><br><span class="line">force = 25;//力量</span><br><span class="line">agility = 85;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;玲珑之花&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaoQiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaoQiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangGai::HuangGai()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;黄盖&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 65;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 85;//力量</span><br><span class="line">agility = 35;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;苦肉之计&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangGai::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangGai::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaiShiCi::TaiShiCi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;太史慈&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 70;//智慧</span><br><span class="line">strategy = 50;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;受宠打击&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaiShiCi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaiShiCi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GanNing::GanNing()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;甘宁&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 65;//智慧</span><br><span class="line">strategy = 75;//谋略</span><br><span class="line">force = 76;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;百骑袭营&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GanNing::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GanNing::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LuSu::LuSu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;鲁肃&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 90;//谋略</span><br><span class="line">force = 40;//力量</span><br><span class="line">agility = 60;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;大智若愚&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LuSu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LuSu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LvMeng::LvMeng()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;吕蒙&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;白衣渡江&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvMeng::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvMeng::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangZhao::ZhangZhao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张昭&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 95;//谋略</span><br><span class="line">force = 25;//力量</span><br><span class="line">agility = 55;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;制衡之道&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangZhao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangZhao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhouTai::ZhouTai()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;周泰&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 45;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouTai::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouTai::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Qun.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class LvBu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LvBu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DiaoChan :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">DiaoChan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuaTuo : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuaTuo();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YuanShao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">YuanShao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YanLiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">YanLiang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WenChou : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">WenChou();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZuoCi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZuoCi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuaXiong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuaXiong();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GongSunZan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GongSunZan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangJiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangJiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YuJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">YuJi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LingJu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LingJu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Qun.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Qun.h&quot;</span><br><span class="line"></span><br><span class="line">LvBu::LvBu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;吕布&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 35;//智慧</span><br><span class="line">strategy = 10;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;方天画斩&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvBu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvBu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;agility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiaoChan::DiaoChan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;貂蝉&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 96;//智慧</span><br><span class="line">strategy = 60;//谋略</span><br><span class="line">force = 10;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;闭月羞花&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DiaoChan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DiaoChan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuaTuo::HuaTuo()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;华佗&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 37;//谋略</span><br><span class="line">force = 60;//力量</span><br><span class="line">agility = 60;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;妙手回天&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaTuo::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaTuo::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YuanShao::YuanShao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;袁绍&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 27;//智慧</span><br><span class="line">strategy = 20;//谋略</span><br><span class="line">force = 44;//力量</span><br><span class="line">agility = 55;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;万箭齐发&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuanShao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuanShao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YanLiang::YanLiang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;颜良&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 60;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;致命一击&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YanLiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YanLiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WenChou::WenChou()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;文丑&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 66;//智慧</span><br><span class="line">strategy = 66;//谋略</span><br><span class="line">force = 88;//力量</span><br><span class="line">agility = 88;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;暗箭难防&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WenChou::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WenChou::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZuoCi::ZuoCi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;左慈&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 100;//智慧</span><br><span class="line">strategy = 90;//谋略</span><br><span class="line">force = 55;//力量</span><br><span class="line">agility = 20;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;道法自然&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZuoCi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZuoCi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuaXiong::HuaXiong()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;华雄&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 67;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;豪情万丈&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaXiong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaXiong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GongSunZan::GongSunZan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;公孙瓒&quot;;//姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;白马义从&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GongSunZan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GongSunZan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangJiao::ZhangJiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张角&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 45;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 55;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;天公降雷&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangJiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangJiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YuJi::YuJi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;于吉&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 40;//力量</span><br><span class="line">agility = 10;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;太平要术&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LingJu::LingJu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;灵雎&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 40;//谋略</span><br><span class="line">force = 60;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;涅槃&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LingJu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LingJu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曾几何时，网页游戏风靡整个网络世界，然而手机游戏的出现，如今的网页游戏已经渐渐销声匿迹了。&lt;/p&gt;
&lt;p&gt;还记得我玩的第一款时间较长的网页游戏——龙将，如今服务器已关闭了，包括代理商“风行”如今也鲜为人知。其实那款游戏很简单，两个玩家对弈，双方每人出场5个英雄，按回合制以英
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="继承" scheme="http://qianyouyou.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="项目" scheme="http://qianyouyou.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="多态" scheme="http://qianyouyou.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>C++运算符重载之智能指针</title>
    <link href="http://qianyouyou.cn/2019/03/04/2019-03-04/"/>
    <id>http://qianyouyou.cn/2019/03/04/2019-03-04/</id>
    <published>2019-03-04T12:36:12.000Z</published>
    <updated>2019-04-27T15:39:41.127Z</updated>
    
    <content type="html"><![CDATA[<p>C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 </p><p>既然有了需求，对此，我们可以自行打造智能指针。</p><p>Person类有show_age()成员函数。</p><p>如果new出来的Person对象，那么必须由我们自行delete。</p><p>有了智能指针，就可以让智能指针托管这个对象，这个对象的释放就不用担心了，由智能指针自动进行管理。</p><p>为了让智能指针像普通指针一样方便实用，就要重载 -&gt; 与解引用 * 运算符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person():age(0)&#123;&#125;</span><br><span class="line">Person(int age):age(age)&#123;&#125;</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show_age() &#123;</span><br><span class="line">cout &lt;&lt; &quot;我的年龄是&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">SmartPointer():person(NULL)&#123;&#125;</span><br><span class="line">SmartPointer(Person*person) &#123;</span><br><span class="line">this-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">~SmartPointer() &#123;</span><br><span class="line">if (person != NULL) &#123;</span><br><span class="line">delete person;</span><br><span class="line">person = NULL;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;智能指针析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Person* operator -&gt;() &#123;</span><br><span class="line">return this-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; operator *() &#123;</span><br><span class="line">return *this-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">Person *person;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">//Person p1(10);</span><br><span class="line">//p1.show_age();</span><br><span class="line">//Person *p1 = new Person(10);</span><br><span class="line">//p1-&gt;show_age();</span><br><span class="line">//delete p1;</span><br><span class="line">SmartPointer sp(new Person(10));</span><br><span class="line">sp-&gt;show_age();</span><br><span class="line">(*sp).show_age();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="智能指针" scheme="http://qianyouyou.cn/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="重载" scheme="http://qianyouyou.cn/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://qianyouyou.cn/2019/02/28/2019-02-28/"/>
    <id>http://qianyouyou.cn/2019/02/28/2019-02-28/</id>
    <published>2019-02-28T09:58:51.000Z</published>
    <updated>2019-04-10T09:18:46.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="王-骏"><a href="#王-骏" class="headerlink" title="王    骏  "></a><center>王    骏</center><div style="float:right"> <img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E8%AF%81%E4%BB%B6%E7%85%A7.jpg" width="120"> </div></h3><center>邮箱：<a href="mailto:15249144478@163.com" target="_blank" rel="noopener">15249144478@163.com</a>        电话：152-0292-4489</center><h4 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h4><hr><div style="float:right">专  业：陕西科技大学/计算机科学与技术    </div>学  历：本科/2016.9<em>~</em>2020.6<br><br><div style="float:right">GitHub：<a href="http://github.com/qian-youyou" target="_blank" rel="noopener">http://github.com/qian-youyou</a></div>技术博客：<a href="http://qianyouyou.cn">http://qianyouyou.cn</a><br><br>#### 获奖经历<br><br>——<br><br>- 2018.11.25    <strong>亚洲区域赛铜奖</strong>    第43届ACM-ICPC国际大学生程序设计竞赛亚洲区域赛<br><br>     2018.06.10    全国邀请赛铜奖    第43届ACM-ICPC国际大学生程序设计竞赛全国邀请赛<br><br>     2018.04.01    省级二等奖        2018第九届蓝桥杯大赛<br><br>     2018.03.31    省级三等奖        团体程序设计天梯赛<br><br>     2018.03        校级二等奖        第4届陕西科技大学C语言大赛<br><br>     2018.11        校级三等奖         第5届陕西科技大学C语言大赛<br><br>#### 项目经验<br><br>——<br><br>##### 网络爬虫<div style="float:right">2017.11 ~ 2017.12</div><p>　　该项目主要建立中小型的文件分享站点，由学校外包项目小组负责。本人在项目小组内主要负责网络爬虫工作，利用Python的BeautifulSoup库抓取静态URL，爬取工标网上的信息到MySQL数据库。之后方便小组搭网站。</p><h4 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h4><hr><ul><li>语言：熟练使用C/C++进行项目开发，了解Python编程语言。<ul><li>熟悉C++封装，继承，多态等基础知识及应用，熟练使用STL库，掌握C++异常捕捉和处理。</li></ul></li><li>算法：擅长数据结构与算法优化，尤其擅长图论与数论算法分析。<ul><li>例如网络流(最大流，费用流等)，最短路SPFA+SLF与LLL优化，Dijkstra+heap优化，Tarjan算法，A*搜索，KM+slack优化，匈牙利算法+时间戳优化，KMP+Trie树，线段树，加权并查集，矩阵快速幂等。</li></ul></li><li>系统：熟悉Linux操作系统， 了解Linux环境下编程及进程间通信，多线程编程。 </li><li>网络：具有网络基础知识， 熟悉TCP/IP协议，了解Socket网络编程。 </li><li>前端：熟悉HTML5、CSS等前端语言，能够独立制作静态网页。</li><li>其他：了解MySQL基本操作。熟悉Git使用。</li></ul><h5 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h5><p>一个爱学习，知上进，善总结，重思考，懂感恩的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;王-骏&quot;&gt;&lt;a href=&quot;#王-骏&quot; class=&quot;headerlink&quot; title=&quot;王    骏  &quot;&gt;&lt;/a&gt;&lt;center&gt;王    骏&lt;/center&gt;&lt;div style=&quot;float:right&quot;&gt; &lt;img src=&quot;https://qiany
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[设计模式]单例模式案例之打印机案例</title>
    <link href="http://qianyouyou.cn/2019/02/27/2019-02-27/"/>
    <id>http://qianyouyou.cn/2019/02/27/2019-02-27/</id>
    <published>2019-02-27T10:41:14.000Z</published>
    <updated>2019-04-27T15:38:58.369Z</updated>
    
    <content type="html"><![CDATA[<p>当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模式的案例，比如一个国家只有一个主席，即使主席替换，依然只有一个主席。比如某个教室只有一台打印机，那么无论多少人需要使用打印机，都将只能使用这一台打印机。也就是说该对象有且只能创建一个。</p><p>接下来我们总结一下单例模式的流程：</p><p>1.目的让类中只有一个对象，对象不需要自己释放。</p><p>2.将默认构造函数与拷贝构造函数私有化。</p><p>3.内部维护一个对象指针。</p><p>4.私有化唯一指针。</p><p>5.对外提供方法访问该指针。</p><p>6.保证了类中只能实例化唯一对象。</p><p>我们以打印机为例，某教室只有一台打印机，该打印机一次只能供一个人使用。</p><p>我们先来分析打印机，打印机具有打印功能，具有启动功能，具有关闭功能。而且具有一次只能供一人使用的特性，因此创建类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">static PrintingPress*getInstance() &#123;</span><br><span class="line">return unique;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">void openPrinting() &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void closePrinting() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void usingPrinting(string str) &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress() &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">static PrintingPress* unique;</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br></pre></td></tr></table></figure><p>用户具有使用打印机打印内容的功能，具有关闭打印机的功能，具有打开打印机的功能。因此创建用户类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">void us() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void us(string str) &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void op() &#123;</span><br><span class="line">if (p-&gt;check() == false) &#123;</span><br><span class="line">p-&gt;openPrinting();</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cl() &#123;</span><br><span class="line">if (flag = true) &#123;</span><br><span class="line">p-&gt;closePrinting();</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下代码是用C++写的一个简单的打印机案例测试代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#define CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">static PrintingPress*getInstance() &#123;</span><br><span class="line">return unique;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">void openPrinting() &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void closePrinting() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void usingPrinting(string str) &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress() &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">static PrintingPress* unique;</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">void us() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void us(string str) &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void op() &#123;</span><br><span class="line">if (p-&gt;check() == false) &#123;</span><br><span class="line">p-&gt;openPrinting();</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cl() &#123;</span><br><span class="line">if (flag = true) &#123;</span><br><span class="line">p-&gt;closePrinting();</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">user tmp[3];</span><br><span class="line">tmp[1].op();</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[1].us(&quot;lalalalala&quot;);</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[1].cl();</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[2].us(&quot;22222222&quot;);</span><br><span class="line">tmp[2].cl();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="设计模式" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="设计模式" scheme="http://qianyouyou.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://qianyouyou.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[转]const指针与指向const的指针</title>
    <link href="http://qianyouyou.cn/2019/02/23/2019-02-23/"/>
    <id>http://qianyouyou.cn/2019/02/23/2019-02-23/</id>
    <published>2019-02-23T08:55:36.000Z</published>
    <updated>2019-04-27T15:38:37.455Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~</p><p><strong>const指针的定义：</strong></p><p>　　const指针是指针变量的值一经初始化，就不可以改变指向，初始化是必要的。其定义形式如下：</p><p>type *const 指针名称;</p><p>　　声明指针时，可以在类型前或后使用关键字const，也可在两个位置都使用。例如，下面都是合法的声明，但是含义大不同：</p><p>const int * pOne;    //指向<strong>整形常量</strong> 的指针，它指向的值不能修改</p><p>int * const pTwo;    //指向整形的<strong>常量指针</strong> ，它不能在指向别的变量，但指向（变量）的值可以修改。 </p><p>const int *const pThree;  //指向<strong>整形常量</strong> 的<strong>常量指针</strong> 。它既不能再指向别的常量，指向的值也不能修改。</p><p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。下面的代码有助于说明这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int *p1;  //the int pointed to is constant</span><br><span class="line"></span><br><span class="line">int * const p2; // p2 is constant, it can&apos;t point to anything else</span><br></pre></td></tr></table></figure><p><strong>const指针和const成员函数</strong></p><p>可以将关键字用于成员函数。例如：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pubilc:</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        void SetLength(int length)&#123;itslength = length;&#125;</span><br><span class="line"></span><br><span class="line">        int GetLength() const &#123;return itslength;&#125;  //成员函数声明为常量</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">     private:</span><br><span class="line"></span><br><span class="line">        int itslength;</span><br><span class="line"></span><br><span class="line">        int itswidth;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>当成员函数被声明为const时，如果试图修改对象的数据，编译器将视为错误。</p><p>如果声明了一个指向const对象的指针，则通过该指针只能调用const方法（成员函数）。</p><p>示例声明三个不同的Rectangle对象：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle* pRect = new Rectangle;</span><br><span class="line"></span><br><span class="line">const Rectangle * pConstRect = new Rectangle;     //指向const对象</span><br><span class="line"></span><br><span class="line">Rectangle* const pConstPtr = new Rectangle;</span><br><span class="line"></span><br><span class="line">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="const指针和指向const的指针"><a href="#const指针和指向const的指针" class="headerlink" title="const指针和指向const的指针"></a>const指针和指向const的指针</h1><p>当使用带有const的指针时其实有两种意思。一种指的是你不能修改指针本身的内容，另一种指的是你不能修改指针指向的内容。听起来有点混淆一会放个例子上来就明白了。<br>      先说指向const的指针，它的意思是指针指向的内容是不能被修改的。它有两种写法。<br>      const int<em> p; （推荐）<br>      int const</em> p;<br>      第一种可以理解为，p是一个指针，它指向的内容是const int 类型。p本身不用初始化它可以指向任何标示符，但它指向的内容是不能被改变的。<br>      第二种很容易被理解成是p是一个指向int的const指针（指针本身不能被修改），但这样理解是错误的，它也是表示的是指向const的指针（指针指向的内容是不能被修改的），它跟第一种表达的是一个意思。为了避免混淆推荐大家用第一种。<br>      再说const指针，它的意思是指针本身的值是不能被修改的。它只有一种写法<br>      int<em> const p=一个地址; (因为指针本身的值是不能被修改的所以它必须被初始化）<br>      这种形式可以被理解为，p是一个指针，这个指针是指向int 的const指针。它指向的值是可以被改变的如</em>p=3;<br>      还有一种情况是这个指针本身和它指向的内容都是不能被改变的，请往下看。<br>      const int<em> const p=一个地址;<br>      int const</em> const p=一个地址;<br>      看了上面的内容是不是有点晕，没关系，你不用去背它，用的多了就知道了，还有个技巧，通过上面的观察我们不难总结出一点规律，是什么呢？这个规律就是： 指向const的指针（指针指向的内容不能被修改）const关健字总是出现在<em>的左边而const指针（指针本身不能被修改）const关健字总是出现在</em>的右边，那不用说两个const中间加个*肯定是指针本身和它指向的内容都是不能被改变的。有了这个规则是不是就好记多了。</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Code highlighting produced by Actipro CodeHighlighter (freeware)http://www.CodeHighlighter.com/--&gt; 1 #include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a=3;</span><br><span class="line">    int b;</span><br><span class="line">    </span><br><span class="line">    /*定义指向const的指针（指针指向的内容不能被修改）*/ </span><br><span class="line">    const int* p1; </span><br><span class="line">    int const* p2; </span><br><span class="line">    </span><br><span class="line">    /*定义const指针(由于指针本身的值不能改变所以必须得初始化）*/ </span><br><span class="line">    int* const p3=&amp;a; </span><br><span class="line">    </span><br><span class="line">    /*指针本身和它指向的内容都是不能被改变的所以也得初始化*/</span><br><span class="line">    const int* const p4=&amp;a;</span><br><span class="line">    int const* const p5=&amp;b; </span><br><span class="line">    </span><br><span class="line">     p1=p2=&amp;a; //正确</span><br><span class="line">     *p1=*p2=8; //不正确（指针指向的内容不能被修改）</span><br><span class="line">    </span><br><span class="line">     *p3=5; //正确</span><br><span class="line">     p3=p1; //不正确（指针本身的值不能改变） </span><br><span class="line">    </span><br><span class="line">     p4=p5;//不正确 （指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     *p4=*p5=4; //不正确（指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>const用法小结：</strong><br>const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。<br>\1. const修饰函数的参数<br>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。<br>const 只能修饰输入参数：<br>如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。<br>将“const &amp;”修饰输入参数的用法总结如下：<br>(1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。<br>(2)对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。</p><p>\2. const 修饰函数的返回值<br>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数<br>const char <em> GetString(void);<br>如下语句将出现编译错误：<br>char </em>str = GetString();<br>正确的用法是<br>const char *str = GetString();<br>如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。<br>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。<br>例如：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">A &amp; operate = (const A &amp;other); // 赋值函数</span><br><span class="line">&#125;;</span><br><span class="line">A a, b, c; // a, b, c 为A 的对象</span><br><span class="line">a = b = c; // 正常的链式赋值</span><br><span class="line">(a = b) = c; // 不正常的链式赋值，但合法</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p><p>\3. const修饰成员函数<br>关于Const函数的几点规则：<br>a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.<br>b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.<br>c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.<br>d. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</p><p>　　版权所有，转载请注明转载地址：<a href="http://www.cnblogs.com/lihuidashen/p/4378884.html" target="_blank" rel="noopener">http://www.cnblogs.com/lihuidashen/p/4378884.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const指针的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　const指针是指针变量的值一经初始化，就不可以改变指向
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="const" scheme="http://qianyouyou.cn/tags/const/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[转]#pragma命令详解</title>
    <link href="http://qianyouyou.cn/2019/02/22/2019-02-22/"/>
    <id>http://qianyouyou.cn/2019/02/22/2019-02-22/</id>
    <published>2019-02-22T11:53:01.000Z</published>
    <updated>2019-04-27T15:38:10.132Z</updated>
    
    <content type="html"><![CDATA[<p>每种C和C++的实现支持对其宿主机或操作系统唯一的功能。例如，一些程序需要精确控制超出数据所在的储存空间，或着控制特定函数接受参数的方式。#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。编译指示被定义为机器或操作系统特定的，并且通常每种编译程序是不同的。</p><p>语法：</p><p>#pragma token_string</p><p>“token_string”是一系列字符用来给出所需的特定编译程序指令和参数。数字符号“#”必须是包含编译指令的行中第一个非空白字符；而空白字符可以隔开数字符号“#”和关键字“pragma”。在#pragma后面，写任何翻译程序能够作为预处理符号分析的文本。#pragma的参数类似于宏扩展。</p><p>如果编译程序发现它不认得一个编译指示，它将给出一个警告，可是编译会继续下去。</p><p>为了提供新的预处理功能，或者为编译程序提供由实现定义的信息，编译指示可以用在一个条件语句内。C和C++编译程序可以识别下列编译程序指令。</p><table><thead><tr><th>alloc_text</th><th>comment</th><th>init_seg*</th><th>optimize</th></tr></thead><tbody><tr><td>auto_inline</td><td>component</td><td>inline_depth</td><td>pack</td></tr><tr><td>bss_seg</td><td>data_seg</td><td>inline_recursion</td><td>pointers_to_members*</td></tr><tr><td>check_stack</td><td>function</td><td>intrinsic</td><td>setlocale</td></tr><tr><td>code_seg</td><td>hdrstop</td><td>message</td><td>vtordisp*</td></tr><tr><td>const_seg</td><td>include_alias</td><td>once</td><td>warning</td></tr></tbody></table><p>*仅用于C++编译程序。</p><p><strong>1 alloc_text</strong></p><p>#pragma alloc_text( “textsection”, function1, … )</p><p>命名特别定义的函数驻留的代码段。该编译指示必须出现在函数说明符和函数定义之间。</p><p>alloc_text编译指示不处理C++成员函数或重载函数。它仅能应用在以C连接方式说明的函数——就是说，函数是用extern “C”连接指示符说明的。如果你试图将这个编译指示应用于一个具有C++连接方式的函数时，将出现一个编译程序错误。</p><p>由于不支持使用__based的函数地址，需要使用alloc_text编译指示来指定段位置。由textsection指定的名字应该由双引号括起来。</p><p>alloc_text编译指示必须出现在任何需要指定的函数说明之后，以及这些函数的定义之前。</p><p>在alloc_text编译指示中引用的函数必须和该编译指示处于同一个模块中。如果不这样做，使以后一个未定义的函数被编译到一个不同的代码段时，错误会也可能不会被捕获。即使程序一般会正常运行，但是函数不会分派到应该在的段。</p><p>alloc_text的其它限制如下：</p><p>它不能用在一个函数内部。</p><p>它必须用于函数说明以后，函数定义以前。</p><p><strong>2 auto_inline</strong></p><p>#pragma auto_inline( [{on | off}] )</p><p>当指定off时将任何一个可以被考虑为作为自动嵌入扩展候选的函数排除出该范围。为了使用auto_inline编译指示，将其紧接着写在一个函数定义之前或之后（不是在其内部）。该编译指示将在其出现以后的第一个函数定义开始起作用。auto_inline编译指示对显式的inline函数不起作用。</p><p><strong>3 bss_seg</strong></p><p>#pragma data_seg( [“section-name”[, “section-class”] ] )</p><p>为未初始化数据指定缺省段。data_seg编译指示除了工作于已初始化数据而不是未初始化的以外具有一样的效果。在一些情况下，你能使用bss_seg将所有未初始化数据安排在一个段中来加速你的装载时间。</p><p>#pragma bss_seg( “MY_DATA” )</p><p>将导致把#pragma语句之后的未初始化的数据安排在一个叫做MY_DATA的段中。</p><p>用bss_seg编译指示分配的数据不包含任何关于其位置的信息。</p><p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p><p><strong>4 check_stack</strong></p><p>#pragma check_stack([ {on | off}] )</p><p>#pragma check_stack{+ | –}</p><p>如果指定off（或者“-”）指示编译程序关闭堆栈探测，或者指定on（或“+”）打开堆栈探测。如果没有给出参数，堆栈探测将根据默认设置决定。该编译指示将在出现该指示之后的第一个函数开始生效。堆栈探测既不是宏和能够生成嵌入代码函数的一部分。</p><p>如果你没有给出check­_stack编译指示的参数，堆栈检查将恢复到在命令行指定的行为。详细情况见编译程序参考。#pragma check_stack和/Gs选项的互相作用情况在表2.1中说明。</p><p>表 2.1 使用check_stack编译指示</p><table><thead><tr><th>编译指示</th><th>用/Gs选项编译？</th><th>行为</th></tr></thead><tbody><tr><td>#pragma check_stack()或#pragma check_stack</td><td>是</td><td>后续的函数关闭堆栈检查</td></tr><tr><td>#pragma check_stack()或#pragma check_stack</td><td>否</td><td>后续的函数打开堆栈检查</td></tr><tr><td>#pragma check_stack(on)或#pragma check_stack(+)</td><td>是或者否</td><td>后续的函数打开堆栈检查</td></tr><tr><td>#pragma check_stack(off)或#pragma check_stack(-)</td><td>是或者否</td><td>后续的函数关闭堆栈检查</td></tr></tbody></table><p><strong>5 code_seg</strong></p><p>#pragma code_seg( [“section-name”[,”section-class”] ] )</p><p>指定分配函数的代码段。code_seg编译指示为函数指定默认的段。你也能够像段名一样指定一个可选的类名。使用没有段名字符串的#pragma code_seg将恢复分配到编译开始时候的状态。</p><p><strong>6 const_seg</strong></p><p>#pragma const_seg( [“section-name”[, “section-class”] ] )</p><p>指定用于常量数据的默认段。data_seg编译指示除了可以工作于所有数据以外具有一样的效果。你能够使用该编译指示将你的常量数据保存在一个只读的段中。</p><p>#pragma const_seg( “MY_DATA” )</p><p>导致在#pragma语句后面的常量数据分配在一个叫做MY_DATA的段中。</p><p>用const_seg编译指示分配的数据不包含任何关于其位置的信息。</p><p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p><p><strong>7 comment</strong></p><p>#pragma comment( comment-type [, commentstring] )</p><p>将描述记录安排到目标文件或可执行文件中去。comment-type是下面说明的五个预定义标识符中的一个，用来指定描述记录的类型。可选的commentstring是一个字符串文字值用于为一些描述类型提供附加的信息。因为commentstring是一个字符串文字值，所以它遵从字符串文字值的所有规则，例如换码字符、嵌入的引号（”）和联接。</p><p><strong>7-1 compiler</strong></p><p>在目标文件中放置编译程序名和版本号。该描述记录被连接程序忽略。如果你为这个记录类型提供一个commentstring参数，编译程序将生成一个警告。</p><p><strong>7-2 exestr</strong></p><p>将commentstring放置到目标文件中去。在连结时，这个字符串再被放到可执行文件去中。当可执行文件被装载时这个字符串不会被装入内存，然而，它可以被一个能够在文件中搜索可打印字符串的程序找到。该描述记录的一个用处是在可执行文件中嵌入版本号或者类似的信息。</p><p><strong>7-3 lib</strong></p><p>将一个库搜索记录放置到目标文件中去。该描述类型必须有包含你要连接程序搜索的库名（和可能的路径）的commentstring参数。因为在目标文件中该库名先于默认的库搜索记录，所以连接程序将如同你在命令行输入这些库一样来搜索它们。你可以在一个源文件中放置多个库搜索记录，每个记录将按照它们出现在源文件中的顺序出现在目标文件中。</p><p><strong>7-4 linker</strong></p><p>在目标文件中放置连接程序选项。你可以用这个描述类型指定连接程序选项来代替在Project Setting对话框中Link页内的选项。例如，你可以指定/include选项以强迫包含一个符号：</p><p>#pragma comment(linker, “/include:__mySymbol”)</p><p><strong>7-5 user</strong></p><p>在目标文件中包含一个普通描述记录。commentstring参数包含描述的文本。该描述记录将被连接程序忽略。</p><p>下面的编译指示导致连接程序在连接时搜索EMAPI.LIB库。连接程序首先在当前工作目录然后在LIB环境变量指定的路径中搜索。</p><p>#pragma comment( lib, “emapi” )</p><p>下面的编译指示导致编译程序将其名字和版本号放置到目标文件中去。</p><p>The following pragma causes the compiler to place the name and version number of the compiler in the object file:</p><p>#pragma comment( compiler )</p><p>注意，对于具有commentstring参数的描述记录，你可以使用其它用作字符串文字量的宏来提供宏扩展为字符串文字量。你也能够联结任何字符串文字量和宏的组合来扩展成为一个字符串文字量。例如，下面的语句是可以接受的：</p><p>#pragma comment( user, “Compiled on “ <strong>DATE</strong> “ at “ <strong>TIME</strong> )</p><p><strong>8 component</strong></p><p>#pragma component( browser, { on | off }[, references [, name ]] )</p><p>#pragma component( minrebuild, on | off )</p><p>从源文件内控制浏览信息和依赖信息的收集。</p><p><strong>8-1 浏览信息（Browser）</strong></p><p>你可以将收集打开或关闭，你也可以指定收集时忽略特别的名字。</p><p>使用on或off在编译指示以后控制浏览信息的收集。例如：</p><p>#pragma component(browser, off)</p><p>终止编译程序收集浏览信息。</p><p>注意，为了用这个编译指示打开浏览信息的收集，必须先从Project Setting对话框或者命令行允许浏览信息。</p><p>references选项可以有也可以没有name参数。使用没有name参数的references选项将打开或者关闭引用信息的收集（然而继续收集其它浏览信息）。例如：</p><p>#pragma component(browser, off, references)</p><p>终止编译程序收集引用信息。</p><p>使用有name和off参数的references选项将阻止从浏览信息窗口中出现引用到的名字。用这个语法将忽略你不感兴趣的名字和类型从而减少浏览信息文件的大小。例如：</p><p>#pragma component(browser, off, references, DWORD)</p><p>从这一点以后忽略DWORD的引用。你能够用on恢复DWORD的引用收集：</p><p>#pragma component(browser, on, references, DWORD)</p><p>这是唯一的方法可以恢复收集指定名字的引用，你必须显式地打开任何你关闭的名字。</p><p>为了防止预处理程序扩展名字（就像扩展NULL到0），用引号括起来：</p><p>#pragma component(browser, off, references, “NULL”)</p><p><strong>8-2 最小化重建（Minimal Rebuild）</strong></p><p>Visual C++的最小化重建功能要求编译程序创建并保存需要大量磁盘空间的C++类依赖信息。为了节省磁盘空间，你能够在你不需要收集依赖信息时使用#pragma component(minrebuild,off)，例如，没有改变过头文件。在未修改过的类之后插入#pragma component(minrebuild,on)重新打开依赖信息。</p><p>详见Enable Minimal Rebuild(/Gm)编译程序选项。</p><p><strong>9 data_seg</strong></p><p>#pragma data_seg( [“section-name”[, “section-class”] ] )</p><p>指定数据的默认段。例如：</p><p>#pragma data_seg( “MY_DATA” )</p><p>导致在#pragma语句后分配的数据保存在一个叫做MY_DATA的段中。</p><p>用data_seg编译指示分配的数据不包含任何关于其位置的信息。</p><p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p><p><strong>10 function</strong></p><p>#pragma function( function1 [, function2, …] )</p><p>指定必须生成对编译指示中参数列表内函数的调用。如果你使用intrinsic编译指示（或者/Oi）来告诉编译程序生成内含函数（内含函数如同嵌入代码一样生成，不作为一个函数调用），你能够用function编译指示显式地强迫函数调用。当遇到一个function编译指示，它将在其后面遇到的第一个包含有内含函数的函数定义处生效。其持续作用到源文件的尾部或者出现对同一个内含函数指定intrinsic编译指示。function编译指示只能用于函数外——在全局层次。</p><p>为了列出具有内含形式的函数表，参见#pragma intrinsic。</p><p><strong>11 hdrstop</strong></p><p>#pragma hdrstop [( “filename” )]</p><p>控制预编译头文件的工作方式。filename是要使用或者创建（依赖于是否指定了/Yu或/Yc）预编译头文件的名字。如果 filename不包括一个指定路径，将假定预编译头文件和源文件处于同一个目录中。当指定自动预编译头文件选项/YX时，所有指定的文件名将被忽略。</p><p>如果有/YX或者/Yc选项，而且C或C++文件包含了一个hdrstop编译指示时，编译程序保存编译指示之前的编译状态。编译指示之后的编译状态不被保存。</p><p>hdrstop编译选项不能出现在一个头文件内。它只能出现在源文件的文件级，它也不能出现在任何数据或者函数的说明或定义之中。</p><p>注意，除非指定没有文件名的/YX选项或者/Yu或/Yc选项，否则hdrstop编译指示将被忽略。</p><p>用一个文件名命名要保存编译状态的预编译头文件。在hdrstop和filename之间的空格是可选的。在hdrstop编译指示中的文件名是一个字符串，这样它服从于C或C++的字符串规则。特别的，你必须像下面例子里面显示的用引号括起来。</p><p>#pragma hdrstop( “c:\projects\include\myinc.pch” )</p><p>预编译头文件的文件名按照如下规则决定，按照优先次序：</p><p>/Fp编译程序选项的参数；</p><p>由#pragma hdrstop的filename参数；</p><p>原文件名的基本文件名加上.PCH扩展名。</p><p><strong>12 include_alias</strong></p><p>#pragma include_alias( “long_filename”, “short_filename” )</p><p>#pragma include_alias( &lt;long_filename&gt;, &lt;short_filename&gt; )</p><p>指定作为long_filename别名的short_filename。一些文件系统允许超出8.3FAT文件系统限制的长头文件名。编译程序不能简单地将长文件名截断为8.3名字，因为长头文件名的前8个字符可能不是唯一的。无论何时编译程序遇到long_filename串，它代替short_filename，并且用short_filename搜索头文件。这个编译指示必须出现在相应的#include指示之前。例如：</p><p>// First eight characters of these two files not unique.</p><p>#pragma include_alias( “AppleSystemHeaderQuickdraw.h”, “quickdra.h” )</p><p>#pragma include_alias( “AppleSystemHeaderFruit.h”, “fruit.h” )</p><p>#pragma include_alias( “GraphicsMenu.h”, “gramenu.h” )</p><p>#include “AppleSystemHeaderQuickdraw.h”</p><p>#include “AppleSystemHeaderFruit.h”</p><p>#include “GraphicsMenu.h”</p><p>这个别名在搜索时精确匹配，包括拼写和双引号、尖括号。include_alias编译指示在文件名上执行简单的字符串匹配，不进行其它的文件名验证。例如，给出下列指示：</p><p>#pragma include_alias(“mymath.h”, “math.h”)</p><p>#include “./mymath.h”</p><p>#include “sys/mymath.h”</p><p>并不执行别名替代，因为头文件名字符串没有精确匹配。另外，在/Yu，/Yc和/YX编译程序选项，或hdrstop编译指示中作为参数的头文件名不被替换。例如，如果你的源文件包含下列指示：</p><p>#include &lt;AppleSystemHeaderStop.h&gt;</p><p>相应的编译程序选项必须是：</p><p>/YcAppleSystemHeaderStop.h</p><p>你能够用include­_alias编译指示将任何头文件映射到其它文件。例如：</p><p>#pragma include_alias( “api.h”, “c:\version1.0\api.h” )</p><p>#pragma include_alias( &lt;stdio.h&gt;, &lt;newstdio.h&gt; )</p><p>#include “api.h”</p><p>#include &lt;stdio.h&gt;</p><p>不要混淆用双引号和尖括号括起来的文件名。例如，给出上面的#pragma include_alias指示时，在下面的#include指示中编译程序不执行替换。</p><p>#include &lt;api.h&gt;</p><p>#include “stdio.h”</p><p>还有，下面的指示将产生一个错误：</p><p>#pragma include_alias(&lt;header.h&gt;, “header.h”) // Error</p><p>注意，在错误信息中报告的文件名，或者预定义宏<strong>FILE</strong>的值，是执行替换以后的文件名。例如，在下列指示之后：</p><p>#pragma include_alias( “VeryLongFileName.H”, “myfile.h” )</p><p>#include “VeryLongFileName.H”</p><p>文件VeryLongFileName.H产生下列错误信息：</p><p>myfile.h(15) : error C2059 : syntax error</p><p>还要注意的是不支持传递性。给出下面的指示：</p><p>#pragma include_alias( “one.h”, “two.h” )</p><p>#pragma include_alias( “two.h”, “three.h” )</p><p>#include “one.h”</p><p>编译程序将搜索two.h而不是three.h。</p><p><strong>13 init_seg</strong></p><p>C++特有</p><p>#pragma init_seg({ compiler | lib | user | “section-name” [, “func-name”]} )</p><p>指定影响启动代码执行的关键字或代码段。因为全局静态对象的初始化可以包含执行代码，所以你必须指定一个关键字来定义什么时候构造对象。在使用需要初始化的动态连接库（DLL）或程序库时使用init_seg编译指示是尤其重要的。</p><p>init_seg编译指示的选项有：</p><p>13-1 compiler</p><p>由Microsoft C运行时间库保留。在这个组中的对象将第一个构造。</p><p>13-2 lib</p><p>用于第三方类库开发者的初始化。在这个组中的对象将在标记为构造compiler的对象之后，其它对象之前构造。</p><p>13-3 user</p><p>用于任何其它用户。在这个组中的对象将最后构造。</p><p>13-4 section-name</p><p>允许显式地指定初始化段。在用户指定的section-name中的对象将不会隐式地构造，而它们的地址将会被放置在由section-name命名的段中。</p><p>13-5 func-name</p><p>指定当程序退出时，作为atexit函数调用的函数。这个函数必须具有和atexit函数相同的形式：</p><p>int funcname(void (__cdecl *)(void));</p><p>如果你需要延迟初始化，你能够选择指定显式的段名。随后你必须调用每个静态对象的构造函数。</p><p><strong>14 inline_depth</strong></p><p>#pragma inline_depth( [0… 255] )</p><p>通过控制能够被扩展的一系列函数调用（从0到255次）来控制嵌入函数扩展的发生次数，这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。</p><p>inline_depth编译指示控制能够被扩展的一系列函数调用。例如，如果嵌入深度是4，并且如果A调用B然后调用C，所有的3次调用都将做嵌入扩展。然而，如果设置的最近一次嵌入深度是2，则只有A和B被扩展，而C仍然作为函数调用。</p><p>为了使用这个编译指示，你必须设置编译程序选项/Ob为1或者2。用这个编译指示指定的深度设定在该指示后面的第一个函数开始生效。如果你在括号内不指定一个值，inline_depth设置嵌入深度到默认值8。</p><p>在扩展时，嵌入深度可以被减少而不能被增加。如果嵌入深度是6，同时在扩展过程中预处理程序遇到一个inline_depth编译指示设置为8，则深度保持为6。</p><p>嵌入深度0将拒绝嵌入扩展，深度255将设置在嵌入扩展时没有限制。如果用一个没有指定值的编译指示，则使用为默认值。</p><p><strong>15 inline_recursion</strong></p><p>#pragma inline_recursion( [{on | off}] )</p><p>控制直接或者相互间的递归函数调用式的嵌入扩展。用这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。使用这个编译指示需要设置编译程序选项/Ob为1或者2。默认的inline_recursion状态是off。这个编译指示在出现该编译指示之后第一个函数调用起作用，并不影响函数的定义。</p><p>inline_recursion编译指示控制如何扩展递归函数。如果inline_recursion是off，并且如果一个嵌入函数调用了它自己（直接的或者间接的），函数将仅仅扩展一次。如果inline_recursion是on,函数将扩展多次直到达到inline_depth的值或者容量限制。</p><p><strong>16 intrinsic</strong></p><p>#pragma intrinsic( function1 [, function2, …] )</p><p>指定对在编译指示参数表中函数调用是内含的。编译程序像嵌入代码一样生成内含函数，而不是函数调用。下面列出了具有内含形式的库函数。一旦遇到intrinsic编译指示，它从第一个包含指定内含函数的函数定义开始起作用。作用持续到源文件尾部或者出现包含相同内含函数的function编译指示。intrinsic编译指示只能用在函数定义外——在全局层次。</p><p>下列函数具有内含形式：</p><table><thead><tr><th>_disable</th><th>_enable</th><th>_inp</th><th>_inpw</th><th>_lrotl</th><th>_lrotr</th></tr></thead><tbody><tr><td>_outp</td><td>_outpw</td><td>_rotl</td><td>_rotr</td><td>_strset</td><td>abs</td></tr><tr><td>fabs</td><td>labs</td><td>memcmp</td><td>memcpy</td><td>memset</td><td>strcat</td></tr><tr><td>strcmp</td><td>strcpy</td><td>strlen</td><td></td><td></td></tr></tbody></table><p>使用内含函数的程序更快，因为它们没有函数调用的额外代价，然而因为有附加的代码生成，可能比较大。</p><p>注意，_alloca和setjmp函数总是内含的，这个行为不受intrinsic编译指示影响。</p><p>下列浮点函数没有内含形式。然而它们具有直接将参数通过浮点芯片传送而不是推入程序堆栈的版本。</p><table><thead><tr><th>acos</th><th>asin</th><th>cosh</th><th>fmod</th><th>pow</th><th>sinh</th></tr></thead><tbody><tr><td>tanh</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>当你同时指定/Oi和/Og编译程序选项（或者任何包含/Og，/Ox，/O1和/O2的选项）时下列浮点函数具有真正的内含形式。</p><table><thead><tr><th>atan</th><th>exp</th><th>log10</th><th>sqrt</th><th>atan2</th><th>log</th></tr></thead><tbody><tr><td>sin</td><td>tan</td><td>cos</td><td></td><td></td></tr></tbody></table><p>你可以用编译程序选项/Op或/Za来覆盖真内含浮点选项的生成。在这种情况下，函数会像一般库函数一样被生成，同时直接将参数通过浮点芯片传送而不是推入程序堆栈。</p><p><strong>17 message</strong></p><p>#pragma message( messagestring )</p><p>不中断编译，发送一个字符串文字量到标准输出。message编译指示的典型运用是在编译时显示信息。</p><p>下面的代码段用message编译指示在编译过程中显示一条信息：</p><p>#if _M_IX86 == 500</p><p>#pragma message( “Pentium processor build” )</p><p>#endif</p><p>messagestring参数可以是一个能够扩展成字符串文字量的宏，并且你能够用字符串文字量和宏的任何组合来构造。例如，下面的语句显示被编译文件的文件名和文件最后一次修改的日期和时间。</p><p>#pragma message( “Compiling “ <strong>FILE</strong> )</p><p>#pragma message( “Last modified on “ <strong>TIMESTAMP</strong> )</p><p><strong>18 once</strong></p><p>#pragma once</p><p>指定在创建过程中该编译指示所在的文件仅仅被编译程序包含（打开）一次。该编译指示的一种常见用法如下：</p><p>//header.h</p><p>#pragma once</p><p>// Your C or C++ code would follow:</p><p><strong>19 optimize</strong></p><p>仅在专业版和企业版中存在</p><p>#pragma optimize( “[optimization-list]”, {on | off} )</p><p>代码优化仅有Visual C++专业版和企业版支持。详见Visual C++ Edition。</p><p>指定在函数层次执行的优化。optimize编译选项必须在函数外出现，并且在该编译指示出现以后的第一个函数定义开始起作用。on和off参数打开或关闭在optimization-list指定的选项。</p><p>optimization-list能够是0或更多个在表2.2中给出的参数：</p><p>表 2.2   optimize编译指示的参数</p><table><thead><tr><th>参数</th><th>优化类型</th></tr></thead><tbody><tr><td>a</td><td>假定没有别名。</td></tr><tr><td>g</td><td>允许全局优化。</td></tr><tr><td>p</td><td>增强浮点一致性。</td></tr><tr><td>s 或 t</td><td>指定更短或者更快的机器代码序列。</td></tr><tr><td>w</td><td>假定在函数调用中没有别名。</td></tr><tr><td>y</td><td>在程序堆栈中生成框架指针。</td></tr></tbody></table><p>这些和在/O编译程序选项中使用的是相同的字母。例如：</p><p>#pragma optimize( “atp”, on )</p><p>用空字符串（””）的optimize编译指示是一种特别形式。它要么关闭所有的优化选项，要么恢复它们到原始（或默认）的设定。</p><p>#pragma optimize( “”, off )</p><p>#pragma optimize( “”, on )</p><p><strong>20 pack</strong></p><p>#pragma pack( [ n] )</p><p>指定结构和联合成员的紧缩对齐。尽管用/Zp选项设定整个翻译单元的结构和联合成员的紧缩对齐，可以用pack编译指示在<a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">数据说明</a>层次设定紧缩对齐。从出现该编译指示后的第一个结构或者联合说明开始生效。这个编译指示不影响定义。</p><p>当你使用#pragma pack(n)，其中n是1，2，4，8或者16，第一个以后的每个结构成员保存在较小的成员类型或者n字节边界上。如果你使用没有参数的#pragma pack，结构成员将被紧缩到由/Zp指定的值。默认的/Zp紧缩的大小是/Zp8。</p><p>编译程序还支持下面的增强语法：</p><p>#pragma pack( [ [ { push | pop}, ] [ identifier, ] ] [ n ] )</p><p>该语法允许你将使用不同紧缩编译指示的组件合并到同一个翻译单元内。</p><p>每次出现有push参数的pack编译指示将保存当前的紧缩对齐值到一个内部的编译程序堆栈。编译指示的参数列表从左向右读取。如果你使用了push，当前紧缩值被保存。如果你提供了一个n值，这个值将成为新的紧缩值。如果你指定了一个你选定的标示符，这个标示符将和新的紧缩值关联。</p><p>每次出现有pop参数的pack编译指示从内部编译程序堆栈顶部取出一个值并将那个值作为新的紧缩对齐。如果你用了pop，而内部编译程序堆栈是空的，对齐值将从命令行得到，同时给出一个警告。如果你用了pop并指定了n的值，那个值将成为新的紧缩值。如果你用了pop并指定了一个标示符，将移去所有保存在堆栈中的的值直到匹配的找到匹配的标示符，和该标示符关联的紧缩值也被从堆栈中移出来成为新的紧缩值。如果没有找到匹配的标示符，将从命令行获取紧缩值并产生一个1级警告。默认的紧缩对齐是8。</p><p>pack编译指示的新的增强功能允许你编写头文件保证在使用头文件之前和其后的紧缩值是一样的：</p><p>/* File name: include1.h</p><p>*/</p><p>#pragma pack( push, enter_include1 )</p><p>/<em> Your include-file code … </em>/</p><p>#pragma pack( pop, enter_include1 )</p><p>/<em> End of include1.h </em>/</p><p>在前面的例子中，进入头文件时将当前紧缩值和标示符enter_include1关联并推入，被记住。在头文件尾部的pack编译选项移去所有在头文件中可能遇到的紧缩值并移去和enter_include1关联的紧缩值。这样头文件保证了在使用头文件之前和其后的紧缩值是一样的。</p><p>新功能也允许你在你的代码内用pack编译指示为不同的代码，例如头文件设定不同的紧缩对齐。</p><p>#pragma pack( push, before_include1 )</p><p>#include “include1.h”</p><p>#pragma pack( pop, before_include1 )</p><p>在上一个例子中，你的代码受到保护，防止了在include.h中的任何紧缩值的改变。</p><p><strong>21 pointers_to_members</strong></p><p>C++特有</p><p>#pragma pointers_to_members(pointer-declaration, [most-general-representation] )</p><p>指定是否能够在相关类定义之前说明一个指向类成员的指针，并且用于控制指针的大小和解释指针的代码。你能够在你的源代码中使用pointers_to_members编译知识来代替/vmx编译程序选项。</p><p>pointer-declaration参数指出是否在相关函数定义之前或其后你已经说明了一个指向成员的指针。pointer-declaration参数是下面两个符号之一：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>full_generality</td><td>生成安全的，但是有时不能优化的代码。如果有一些指向成员的指针在相关类定义之前说明，你要用full_generality。这个参数总是使用由most-general-representation指定的指针表示方式。</td></tr><tr><td>best_case</td><td>对于所有指向成员的指针用最佳的表示方式生成安全的，优化的代码。需要在说明一个指向类成员指针之前定义类。默认是best_case。</td></tr></tbody></table><p>most-general-representaion参数指出在一个翻译单元中编译程序能够安全引用任何指向类成员指针的最小指针表示方式。这个参数可以是下列之一：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>single_inheritance</td><td>最普通的表示方式是单继承，指向成员函数。如果用于指向具有多重或者虚拟继承方式类成员的指针，将产生一个错误。</td></tr><tr><td>multi_inheritance</td><td>最普通的表示方式是多重继承，指向成员函数。如果用于指向具有虚拟继承方式类成员的指针，将产生一个错误。</td></tr><tr><td>virtual_inheritance</td><td>最普通的表示方式是虚拟继承，指向成员函数。不会产生错误。当使用#pragma pointers_to_members (full_generality)时这是默认的参数。</td></tr></tbody></table><p><strong>22 setlocale</strong></p><p>#pragma setlocale( “locale-string” )</p><p>定义用于翻译宽字符常数和字符串文字量时用的地区（国家和语言）。由于用于从多字节字符转换到宽字符的算法根据地区或者由于在运行可执行程序不同的地方进行编译而不同，这个编译指示提供一种在编译时指定目标地区的方式。这保证宽字符字符串将以正确的格式保存。默认的locale-string是“C”。“C”地区将字符串中的每个字符作为wchar_t（即unsigned int）映射其值。</p><p><strong>23 vtordisp</strong></p><p>C++特有</p><p>#pragma vtordisp({on | off} )</p><p>允许隐藏的附加vtordisp构造函数/析构函数替换成员。vtordisp编译指示仅能够用于具有虚拟基类的代码。如果派生类从一个虚拟基类重载了一个虚拟函数，并且如果派生类的构造函数或析构函数用指向虚拟基类的指针调用了这个函数，编译程序将根据虚拟基类在类中引入一个附加的隐藏“vtordisp”域。</p><p>vtodisp编译选项影响它后面的类布局。/vd0和/vd1选项为整个模块指定了相同的行为。指定off将禁止隐藏的vtordisp成员，指定on（默认）将在它们需要的时候允许vtordisp。仅在不可能出现类的构造函数和析构函数通过this指针调用其指向对象中的虚拟函数时才关闭vtordisp。</p><p>#pragma vtordisp( off )</p><p>class GetReal : virtual public { … };</p><p>#pragma vtordisp( on )</p><p><strong>24 warning</strong></p><p>#pragma warning( warning-specifier : warning-number-list [,warning-specifier : warning-number-list…] )</p><p>#pragma warning( push[ , n ] )</p><p>#pragma warning( pop )</p><p>允许有选择地修改编译程序警告信息的行为。</p><p>warning-specifier能够是下列值之一：</p><table><thead><tr><th>warning-specifier</th><th>含义</th></tr></thead><tbody><tr><td>once</td><td>只显示指定信息一次。</td></tr><tr><td>default</td><td>对指定信息应用默认的编译程序选项。</td></tr><tr><td>1,2,3,4</td><td>对指定信息引用给定的警告等级。</td></tr><tr><td>disable</td><td>不显示指定信息。</td></tr><tr><td>error</td><td>对指定信息作为错误显示。</td></tr></tbody></table><p>warning-number_list能够包含任何警告编号。如下，在一个编译指示中可以指定多个选项：</p><p>#pragma warning( disable : 4507 34; once : 4385; error : 164 )</p><p>这等价于：</p><p>#pragma warning( disable : 4507 34 ) // Disable warning messages</p><p>​                                             // 4507 and 34.</p><p>#pragma warning( once : 4385 )        // Issue warning 4385</p><p>​                                             // only once.</p><p>#pragma warning( error : 164 )        // Report warning 164</p><p>​                                             // as an error.</p><p>对于那些关于代码生成的，大于4699的警告标号，warning编译指示仅在函数定义外时有效。如果指定的警告编号大于4699并且用于函数内时被忽略。下面例子说明了用warning编译指示禁止、然后恢复有关代码生成警告信息的正确位置：</p><p>int a;</p><p>#pragma warning( disable : 4705 )</p><p>void func()</p><p>{</p><p>​    a;</p><p>}</p><p>#pragma warning( default : 4705 )</p><p>warning编译指示也支持下面语法：</p><p>#pragma warning( push [ ,n ] )</p><p>#pragma warning( pop )</p><p>这里n表示警告等级（1到4）。</p><p>warning(push)编译指示保存所有警告的当前警告状态。warning(push,n)保存所有警告的当前状态并将全局警告等级设置为n。</p><p>warning(pop)弹出最后一次推入堆栈中的警告状态。任何在push和pop之间改变的警告状态将被取消。考虑下面的例子：</p><p>#pragma warning( push )</p><p>#pragma warning( disable : 4705 )</p><p>#pragma warning( disable : 4706 )</p><p>#pragma warning( disable : 4707 )</p><p>// Some code</p><p>#pragma warning( pop )</p><p>在这些代码的结束，pop恢复了所有警告的状态（包括4705，4706和4707）到代码开始时候的样子。</p><p>当你编写头文件时，你能用push和pop来保证任何用户修改的警告状态不会影响正常编译你的头文件。在头文件开始的地方使用push，在结束地方使用pop。例如，假定你有一个不能顺利在4级警告下编译的头文件，下面的代码改变警告等级到3，然后在头文件的结束时恢复到原来的警告等级。</p><p>#pragma warning( push, 3 )</p><p>// Declarations/ definitions</p><p>#pragma warning( pop )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每种C和C++的实现支持对其宿主机或操作系统唯一的功能。例如，一些程序需要精确控制超出数据所在的储存空间，或着控制特定函数接受参数的方式。#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。编译指示被定义为机器或操作系统特定的
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="预处理" scheme="http://qianyouyou.cn/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试常用命令总结</title>
    <link href="http://qianyouyou.cn/2019/02/17/2019-02-17/"/>
    <id>http://qianyouyou.cn/2019/02/17/2019-02-17/</id>
    <published>2019-02-17T13:12:47.000Z</published>
    <updated>2019-04-27T15:37:42.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a><strong>1 简介</strong></h2><p>​     GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：     GDB主要帮忙你完成下面四个方面的功能：     1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。     2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）     3.当程序被停住时，可以检查此时你的程序中所发生的事。     4.动态的改变你程序的执行环境。</p><h2 id="2-生成调试信息"><a href="#2-生成调试信息" class="headerlink" title="2 生成调试信息"></a><strong>2 生成调试信息</strong></h2><p>​     一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p><p>​     gcc -g hello.c -o hello</p><p>​     g++ -g hello.cpp -o hello</p><p>​     如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。</p><h2 id="3-启动GDB的方法"><a href="#3-启动GDB的方法" class="headerlink" title="3 启动GDB的方法"></a><strong>3 启动GDB的方法</strong></h2><p>​     gdb program</p><p>​     program 也就是你的执行文件，一般在当前目录下。</p><h2 id="4-程序运行上下文"><a href="#4-程序运行上下文" class="headerlink" title="4 程序运行上下文"></a><strong>4 程序运行上下文</strong></h2><h3 id="4-1-程序运行参数"><a href="#4-1-程序运行参数" class="headerlink" title="4.1 程序运行参数"></a><strong>4.1 程序运行参数</strong></h3><p>​     set args 可指定运行时参数。（如：set args 10 20 30 40 50 ）</p><p>​     show args 命令可以查看设置好的运行参数。</p><p>​     run  启动程序</p><h3 id="4-2-工作目录"><a href="#4-2-工作目录" class="headerlink" title="4.2 工作目录"></a><strong>4.2 工作目录</strong></h3><p>​     cd 相当于shell的cd命令。</p><p>​     pwd 显示当前的所在目录。</p><h2 id="5-设置断点"><a href="#5-设置断点" class="headerlink" title="5 设置断点"></a><strong>5 设置断点</strong></h2><h3 id="5-1-简单断点"><a href="#5-1-简单断点" class="headerlink" title="5.1 简单断点"></a><strong>5.1 简单断点</strong></h3><p>​     break 设置断点，可以简写为b</p><p>​     b 10 设置断点，在源程序第10行</p><p>​     b func 设置断点，在func函数入口处</p><h3 id="5-2-多文件设置断点"><a href="#5-2-多文件设置断点" class="headerlink" title="5.2 多文件设置断点"></a><strong>5.2 多文件设置断点</strong></h3><p>​     在进入指定函数时停住:</p><p>​     C++中可以使用class::function或function(type,type)格式来指定函数名。如果有名称空间，可以使用namespace::class::function或者function(type,type)格式来指定函数名。</p><p>​     break filename:linenum – 在源文件filename的linenum行处停住</p><p>​     break filename:function – 在源文件filename的function函数的入口处停住</p><p>​     break class::function或function(type,type) – 在类class的function函数的入口处停住</p><p>​     break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住</p><h3 id="5-3-查询所有断点"><a href="#5-3-查询所有断点" class="headerlink" title="5.3 查询所有断点"></a><strong>5.3 查询所有断点</strong></h3><p>​     info b</p><h2 id="6条件断点"><a href="#6条件断点" class="headerlink" title="6条件断点"></a><strong>6条件断点</strong></h2><p>​     一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p><p>​     设置一个条件断点</p><p>​     b test.c:8 if intValue == 5</p><h2 id="7-维护停止点"><a href="#7-维护停止点" class="headerlink" title="7 维护停止点"></a><strong>7 维护停止点</strong></h2><p>​     delete [range…] 删除指定的断点，如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。</p><p>​          比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。</p><p>​     disable  [range…]</p><p>​          disable所指定的停止点，如果什么都不指定，表示disable所有的停止点。简写命令是dis.</p><p>​     enable [range…]</p><p>​          enable所指定的停止点，如果什么都不指定，表示enable所有的停止点。简写命令是ena.</p><h2 id="8-调试代码"><a href="#8-调试代码" class="headerlink" title="8 调试代码"></a><strong>8 调试代码</strong></h2><p>​     run 运行程序，可简写为r</p><p>​     next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</p><p>​     step 单步跟踪，函数调进入被调用函数体内，可简写为s</p><p>​     finish 退出进入的函数</p><p>​     until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。</p><p>​     continue 继续运行程序，可简写为c</p><h2 id="9-查看运行时数据"><a href="#9-查看运行时数据" class="headerlink" title="9 查看运行时数据"></a><strong>9 查看运行时数据</strong></h2><p>​     print 打印变量、字符串、表达式等的值，可简写为p</p><p>​     p count 打印count的值</p><h2 id="10-自动显示"><a href="#10-自动显示" class="headerlink" title="10 自动显示"></a><strong>10 自动显示</strong></h2><p>​     你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p><p>​     display 变量名</p><p>​     info display – 查看display设置的自动显示的信息。</p><p>​     undisplay num（info display时显示的编号）</p><p>​     delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p><p>​     disable display dnums…</p><p>​     enable display dnums…</p><p>​     disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p><h2 id="11-查看修改变量的值"><a href="#11-查看修改变量的值" class="headerlink" title="11. 查看修改变量的值"></a>11. 查看修改变量的值</h2><p>​     (gdb) ptype width – 查看变量width的类型</p><p>​          type = double</p><p>​     (gdb) p width  – 打印变量width 的值</p><p>​          $4 = 13</p><p>​     你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</p><p>​          (gdb) set var width=47</p><p>​     在你改变程序变量取值时，最好都使用set var格式的GDB命令。</p><h2 id="12-显示源代码"><a href="#12-显示源代码" class="headerlink" title="12 显示源代码"></a><strong>12 显示源代码</strong></h2><p>​     GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 –g 的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，</p><p>​     GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。默认打印10行，还是来看一看查看源代码的GDB命令吧。</p><p>​     list linenum</p><p>​          Print lines centered around line number linenum in the current source file.</p><p>​     list function</p><p>​          显示函数名为function的函数的源程序。</p><p>​     list</p><p>​          显示当前行后面的源程序。</p><p>​     list -</p><p>​          显示当前行前面的源程序。</p><p>​     一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p><p>​          set listsize count</p><p>​     设置一次显示源代码的行数。(unless the list argument explicitly specifies some other number)</p><p>​          show listsize</p><p>​     查看当前listsize的设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;1 简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;​     GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="gdb调试" scheme="http://qianyouyou.cn/tags/gdb%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>七牛云测试域名到期图片转移腾讯云COS过程</title>
    <link href="http://qianyouyou.cn/2019/02/16/2019-02-16-1/"/>
    <id>http://qianyouyou.cn/2019/02/16/2019-02-16-1/</id>
    <published>2019-02-16T08:41:21.000Z</published>
    <updated>2019-04-27T15:37:27.218Z</updated>
    
    <content type="html"><![CDATA[<p>今天终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用，希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ </p><h2 id="备份七牛云图片到本地"><a href="#备份七牛云图片到本地" class="headerlink" title="备份七牛云图片到本地"></a>备份七牛云图片到本地</h2><h3 id="批量下载七牛云图片到本地的步骤"><a href="#批量下载七牛云图片到本地的步骤" class="headerlink" title="批量下载七牛云图片到本地的步骤"></a><strong>批量下载七牛云图片到本地的步骤</strong></h3><p>1、下载以下工具包解压到当地硬盘，比如 D 盘，那么解压之后就获得一个 qiniu 文件夹，里面包含有两个文件，分别是 qshell.conf 和 qshell.exe 文件。</p><p> 批量下载七牛云图片到本地工具包（密码: xp1p）</p><p>2、用记事本或者 Notepad++ 软件打开 qshell.conf 文件，然后根据里面的要求填写相应的内容并保存。完成之后大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line">2.     &quot;dest_dir&quot;  :   &quot;//images&quot;,</span><br><span class="line">3.     &quot;bucket&quot;    :   &quot;blog&quot;,</span><br><span class="line">4.     &quot;domain&quot;    :   &quot;http://********.com&quot;,</span><br><span class="line">5.     &quot;access_key&quot;    :&quot;******************&quot;,</span><br><span class="line">6.     &quot;secret_key&quot;    :&quot;******************&quot;,</span><br><span class="line">7.     &quot;is_private&quot;    :false,</span><br><span class="line">8.     &quot;prefix&quot;    :   &quot;&quot;,</span><br><span class="line">9.     &quot;suffix&quot;    :   &quot;&quot;</span><br><span class="line">10. &#125;</span><br></pre></td></tr></table></figure><p>其中 access_key 和 secret_key 的值可以在七牛云后台中的个人中心的密钥管理中获得。</p><p>3、运行电脑的 CMD，比如刚才我们是解压在 D 盘，那么就在CMD 中分别输入 d:、cd qiniu 和 qshell qdownload 10 qshell.conf  命令后即可自动下载七牛云的图片到本地指定的文件夹中，其中最后一条命令的 10 就是 10 线程的意思，一般是越大越快。</p><p>一般情况下等待一段时间就会自动下载完毕，我这次下载了带有前缀 boke112 的图片，图片不多，所以很快就下载完了。</p><h3 id="申请腾讯云"><a href="#申请腾讯云" class="headerlink" title="申请腾讯云"></a>申请腾讯云</h3><p>自行申请。</p><h2 id="批量替换文章里的图片链接"><a href="#批量替换文章里的图片链接" class="headerlink" title="批量替换文章里的图片链接"></a>批量替换文章里的图片链接</h2><p>本人参考网上一篇<a href="https://blog.csdn.net/HuYingJie_1995/article/details/82355033" target="_blank" rel="noopener">批量修改文件内容的Python代码</a>，魔改后。成功实现了批量修改本地Markdown文章图片链接。下面把Python代码贴出来供大家参考，轻拍～（Python版本2.7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8#可加入中文注释</span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">#函数功能：将指定文件夹下所有文件和子文件夹下的文件遍历，并修改文件内容</span><br><span class="line">import os</span><br><span class="line">fpath =&quot;/Users/fsf/PycharmProjects/Python2_tencentcloud/test&quot;#这里是你的第一级文件夹的路径</span><br><span class="line">def filechanger(path):</span><br><span class="line">        filenames = os.listdir(path)#将path路径下的所有文件名存入列表filenames</span><br><span class="line">        for filename in filenames:#循环遍历每个文件</span><br><span class="line">                domain = os.path.abspath(path)#获取规范的路径</span><br><span class="line">                filename = os.path.join(domain,filename)#带路径的文件名</span><br><span class="line">                if os.path.isdir(filename):  # 如果是文件夹进入递归</span><br><span class="line">                        filechanger(filename)</span><br><span class="line">                        continue</span><br><span class="line">                fread = open(filename,&apos;r&apos;)</span><br><span class="line">                fwrite = open(&quot;%s.backup&quot;%filename,&apos;w&apos;)</span><br><span class="line"></span><br><span class="line">                for line in fread.readlines():</span><br><span class="line">                        src_str = line</span><br><span class="line"></span><br><span class="line">                        if src_str.find(&apos;![&apos;) != -1:</span><br><span class="line">                                start = src_str.index(&apos;![&apos;) + 2</span><br><span class="line">                                end = src_str.index(&apos;](&apos;)</span><br><span class="line">                                sub = src_str[start:end]</span><br><span class="line"></span><br><span class="line">                                start1 = end + 2</span><br><span class="line">                                end1 = src_str.index(&apos;)&apos;)</span><br><span class="line">                                sub1 = src_str[start1:end1]</span><br><span class="line"></span><br><span class="line">                                sub2 = src_str[(end1 - 4):end1]</span><br><span class="line"></span><br><span class="line">                                s1 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/&apos;</span><br><span class="line">                                s11 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7&apos;</span><br><span class="line"></span><br><span class="line">                                # sub3 = src_str[:start1] + &apos;../images/&apos; + sub + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line">                                s2 = sub + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line"></span><br><span class="line">                                if src_str[start:(start + 12)] == &apos;屏幕快照&apos;:</span><br><span class="line">                                    s22 = s11 + src_str[(start + 12):end] + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line">                                    sub3 = src_str[:start1] + s22.replace(&apos; &apos;, &apos;%20&apos;)</span><br><span class="line">                                else:</span><br><span class="line">                                    sub3 = src_str[:start1] + s1 + s2.replace(&apos; &apos;,&apos;%20&apos;)</span><br><span class="line">                                fwrite.write(sub3)  # 修改后写入新文件</span><br><span class="line">                                print(sub3)</span><br><span class="line">                        else:</span><br><span class="line">                                fwrite.write(src_str)</span><br><span class="line">                                print(src_str)</span><br><span class="line">                                continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                fread.close()</span><br><span class="line">                fwrite.close()</span><br><span class="line">                os.remove(filename)#如果想更改数据后想保留原文件以及修改文件名可屏蔽这一句和下一句</span><br><span class="line">                os.rename(&quot;%s.backup&quot; % filename, filename)#</span><br><span class="line">filechanger(fpath)</span><br></pre></td></tr></table></figure><p>自18年9月，终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用（发博文时免费额度：50 GB 标准存储容量，10 GB CDN 回源流量，100 万次读请求，100 万次写请求。费用实例），希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用，希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ &lt;/p&gt;
&lt;h2 id=&quot;备份七牛云图片
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Python" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>不蒜子统计失效问题解决</title>
    <link href="http://qianyouyou.cn/2019/02/16/2019-02-16/"/>
    <id>http://qianyouyou.cn/2019/02/16/2019-02-16/</id>
    <published>2019-02-16T04:21:23.000Z</published>
    <updated>2019-04-27T15:36:32.130Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>hexo想要开启站点统计，只需找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但近期，这个不蒜子的统计功能就失效了。查阅了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子官方</a>的说法，</p><blockquote><p>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</p></blockquote><p>由于七牛云9月底强行关闭测试域名，导致本博客在七牛云存的所有图片也无法正常加载了。</p><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>找到原来不蒜子的域名文件，并替换掉旧的域名。<br> 文件路径：\themes\next\layout_third-party\analytics\busuanzi-counter.swig，只需要替换src对应的域名即可，如下是替换后的域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h4&gt;&lt;p&gt;hexo想要开启站点统计，只需找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但近期，这
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>默剧</title>
    <link href="http://qianyouyou.cn/2018/12/11/2018-12-11/"/>
    <id>http://qianyouyou.cn/2018/12/11/2018-12-11/</id>
    <published>2018-12-11T06:28:29.000Z</published>
    <updated>2019-04-27T15:36:16.397Z</updated>
    
    <content type="html"><![CDATA[<p>默剧 </p><p>浅悠悠(摘星集)12.11 </p><p>1 </p><p>霏霏思雨， </p><p>雨里等你， </p><p>不念凄寂， </p><p>只念你。 </p><p>2 </p><p>借一方清水涟漪， </p><p>泛起眷恋的气息。 </p><p>你无声色的思绪， </p><p>是我解不开的迷。 </p><p>3 </p><p>你我此刻的局， </p><p>像演一出默剧。 </p><p>静静观戏的你， </p><p>从不发表建议。 </p><p>留下我， </p><p>也沉默在这孤单角色里。 </p><p>4 </p><p>一纸夙愿， </p><p>写进风里。 </p><p>青骢双骑， </p><p>想和你。 </p><p>5 </p><p>借一曲寂寥旋律， </p><p>点缀这孤独的戏。 </p><p>没有言语的默剧， </p><p>我用风雨吸引你。 </p><p>6 </p><p>说不出的千言万语， </p><p>丢在风里， </p><p>把这独角戏的结局， </p><p>寄在雨里。 </p><p>淋着雨， </p><p>盼着你储存温度的消息。 </p><p>7 </p><p>寒风十里， </p><p>我在等雨。 </p><p>风里雨里， </p><p>不见你。 </p><p>8 </p><p>借一道惊雷霹雳， </p><p>撕裂无言的默剧。 </p><p>期待下一场大雨， </p><p>洗刷过往的回忆。 </p><p>9 </p><p>将那洗不掉的泪痕， </p><p>淹没心底， </p><p>你我没有句点的剧， </p><p>绝口不提。 </p><p>留下你， </p><p>是我心口掩不住的秘密。 </p><p>10 </p><p>相逢似雨， </p><p>遥遥无期。 </p><p>从此， </p><p>只爱清酒， </p><p>不爱你。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默剧 &lt;/p&gt;
&lt;p&gt;浅悠悠(摘星集)12.11 &lt;/p&gt;
&lt;p&gt;1 &lt;/p&gt;
&lt;p&gt;霏霏思雨， &lt;/p&gt;
&lt;p&gt;雨里等你， &lt;/p&gt;
&lt;p&gt;不念凄寂， &lt;/p&gt;
&lt;p&gt;只念你。 &lt;/p&gt;
&lt;p&gt;2 &lt;/p&gt;
&lt;p&gt;借一方清水涟漪， &lt;/p&gt;
&lt;p&gt;泛起眷恋的气息。 &lt;/p
      
    
    </summary>
    
      <category term="诗词歌赋" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
      <category term="摘星集" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/%E6%91%98%E6%98%9F%E9%9B%86/"/>
    
    
      <category term="诗集" scheme="http://qianyouyou.cn/tags/%E8%AF%97%E9%9B%86/"/>
    
  </entry>
  
</feed>
