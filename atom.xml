<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-10-08T12:16:51.331Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ACM算法专用模板(持续更新中)</title>
    <link href="http://qianyouyou.cn/2018/10/05/2018-10-05/"/>
    <id>http://qianyouyou.cn/2018/10/05/2018-10-05/</id>
    <published>2018-10-05T06:16:34.000Z</published>
    <updated>2018-10-08T12:16:51.331Z</updated>
    
    <content type="html"><![CDATA[<p>标签：位运算，gcd，exgcd，欧拉筛，快速乘，快速幂，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，树链剖分，莫队，LCA，Trie树，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyed，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fa[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i = 0; i &lt; maxn; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x==fa[x] ? x : x=root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void Union(int px, int py)&#123;</span><br><span class="line">    px = root(px);</span><br><span class="line">    py = root(py);</span><br><span class="line">    if(px != py)&#123;</span><br><span class="line">        fa[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int head[maxn], cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u, w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*解释：</span><br><span class="line">belong[x]x属于分块后的哪一块，Q[i]每个询问</span><br><span class="line">modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析</span><br><span class="line">注意：</span><br><span class="line">最后也可以不对询问id排序，直接保存到一个数组里面输出即可</span><br><span class="line">*/</span><br><span class="line">int a[nmax], belong[nmax];</span><br><span class="line">ll ans = 0;</span><br><span class="line">struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];</span><br><span class="line">bool cmp(node a, node b) &#123;</span><br><span class="line">if (belong[a.l] != belong[b.l]) return a.l &lt; b.l;</span><br><span class="line">else return a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;</span><br><span class="line">void modify(int pos, int tag) &#123;</span><br><span class="line">// ......... 增删操作</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">int sz = sqrt(n);</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;</span><br><span class="line">belong[i] = (i - 1) / sz + 1;</span><br><span class="line">&#125;</span><br><span class="line">sort(Q + 1, Q + 1 + m, cmp);</span><br><span class="line">int l = 1, r = 0;</span><br><span class="line">for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">while (l &lt; Q[i].l) modify(l++, -1);</span><br><span class="line">while (l &gt; Q[i].l) modify(--l, 1);</span><br><span class="line">while (r &gt; Q[i].r) modify(r--, -1);</span><br><span class="line">while (r &lt; Q[i].r) modify(++r, 1);</span><br><span class="line">Q[i].ans = ans;</span><br><span class="line">&#125;</span><br><span class="line">sort(Q + 1, Q + 1 + m, cmpid);</span><br><span class="line">for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra-邻接矩阵"><a href="#Dijkstra-邻接矩阵" class="headerlink" title="Dijkstra(邻接矩阵)"></a>Dijkstra(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int road[maxn][maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(road, inf, sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int u = 1; u&lt;=n; u++)&#123;</span><br><span class="line">        int minD = inf, k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(k == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = dis[k] + road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        road[u][v] = min(road[u][v], w);</span><br><span class="line">        //road[v][u] = min(road[v][u], w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int cas = 1; cas&lt;=n; cas++)&#123;</span><br><span class="line">        int minD = inf, kk = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                kk = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(kk == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        //add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra-heap"><a href="#Dijkstra-heap" class="headerlink" title="Dijkstra+heap"></a>Dijkstra+heap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">    NODE(int x, int y) : u(x), dis(y)&#123;&#125;</span><br><span class="line">    bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    priority_queue&lt;NODE&gt;que;</span><br><span class="line">    que.push(NODE(sx, 0));</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        NODE tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        int kk = tmp.u;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                que.push(NODE(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">int SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(dis[v] &gt; dis[kk] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v] = true;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        sx = 1, ex = n;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            //add(v, u, w);   //双向边</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, SPFA(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="DINIC"><a href="#DINIC" class="headerlink" title="DINIC"></a>DINIC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DINIC优化"><a href="#DINIC优化" class="headerlink" title="DINIC优化"></a>DINIC优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn], cur[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        memcpy(cur, head, sizeof(head));</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DINIC-邻接矩阵"><a href="#DINIC-邻接矩阵" class="headerlink" title="DINIC(邻接矩阵)"></a>DINIC(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 307;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int f;</span><br><span class="line">&#125;;</span><br><span class="line">int sx,ex;</span><br><span class="line">int pre[maxn];</span><br><span class="line">NODE road[maxn][maxn];</span><br><span class="line">int n, m, N;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">    memset(pre,0,sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int d = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123;</span><br><span class="line">                pre[i] = pre[d] + 1;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex]!=0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int pos, int flow)&#123;</span><br><span class="line">    int f = flow;</span><br><span class="line">    if(pos==ex)</span><br><span class="line">        return flow;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123;</span><br><span class="line">            int a = road[pos][i].c - road[pos][i].f;</span><br><span class="line">            int t = dfs(i, min(a, flow));</span><br><span class="line">            road[pos][i].f += t;</span><br><span class="line">            road[i][pos].f -= t;</span><br><span class="line">            flow -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while(BFS())&#123;</span><br><span class="line">        sum+=dfs(sx,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = N;</span><br><span class="line">    memset(road,0,sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        road[u][v].c+=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,dinic());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm = 1e5+7;</span><br><span class="line">const int maxn = 1e4+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, cnt, sx, ex;</span><br><span class="line">int head[maxn], pre[maxn], dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int c;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void init()&#123;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = 1;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add_edge(int u, int v, int c, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c, int w)&#123;</span><br><span class="line">    add_edge(u, v, c, w);</span><br><span class="line">    add_edge(v, u, 0, -w);</span><br><span class="line">&#125;</span><br><span class="line">bool SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, -1, sizeof(pre));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            EDGE tmp = edge[i];</span><br><span class="line">            if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123;</span><br><span class="line">                dis[tmp.to] = dis[kk] + tmp.w;</span><br><span class="line">                pre[tmp.to] = i;</span><br><span class="line">                if(!vis[tmp.to])&#123;</span><br><span class="line">                    vis[tmp.to] = true;</span><br><span class="line">                    que.push(tmp.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != -1;</span><br><span class="line">&#125;</span><br><span class="line">int MCMF(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0, min_flow = inf, cost = 0;</span><br><span class="line">    while(SPFA(sx, ex))&#123;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            min_flow = min(min_flow, edge[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            edge[i].c -= min_flow;</span><br><span class="line">            edge[i^1].c += min_flow;</span><br><span class="line">            cost += min_flow * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += min_flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return cost;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, c, w;</span><br><span class="line">    ex = n+1;</span><br><span class="line">    for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w);</span><br><span class="line">        add(u,v,c, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(n+m==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,MCMF(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="匈牙利算法-邻接矩阵"><a href="#匈牙利算法-邻接矩阵" class="headerlink" title="匈牙利算法(邻接矩阵)"></a>匈牙利算法(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int N, K;</span><br><span class="line">int edge[maxn][maxn], head[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, 0, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x) &#123;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">if (edge[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">vis[i] = true;</span><br><span class="line">if (!head[i] || find_edge(head[i])) &#123;</span><br><span class="line">head[i] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">int x, y;</span><br><span class="line">for (int i = 1; i &lt;= K; i++)&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">edge[x][y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; Magyar(N) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int T, N, m;</span><br><span class="line">int head[maxn], link[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, u, to, w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(link, 0, sizeof(link));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x)&#123;</span><br><span class="line">    for(int i = head[x]; i!= -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v] = true;</span><br><span class="line">            if (!link[v] || find_edge(link[v])) &#123;</span><br><span class="line">link[v] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int ans = Magyar(N);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N, &amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">        add(x, y, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        memset(edge, 0, sizeof(edge));</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM算法最小权匹配"><a href="#KM算法最小权匹配" class="headerlink" title="KM算法最小权匹配"></a>KM算法最小权匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM算法最小权匹配优化版"><a href="#KM算法最小权匹配优化版" class="headerlink" title="KM算法最小权匹配优化版"></a>KM算法最小权匹配优化版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b)&#123;</span><br><span class="line">    return !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。</p><h3 id="O-logn-快速乘"><a href="#O-logn-快速乘" class="headerlink" title="O(logn)快速乘"></a>O(logn)快速乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline LL quick_mul(LL a,LL n,LL m)&#123;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-1-快速乘"><a href="#O-1-快速乘" class="headerlink" title="O(1)快速乘"></a>O(1)快速乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">#define MOL 123456789012345LL</span><br><span class="line">inline ll mul_mod_ll(ll a,ll b)&#123;</span><br><span class="line">    ll d=(ll)floor(a*(long double)b/MOL+0.5);</span><br><span class="line">    ll ret=a*b-d*MOL;</span><br><span class="line">    if(ret&lt;0)   ret+=MOL;</span><br><span class="line">    return   ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，使用浮点数计算 a<em>b/MOL 的值，关键在于第二句，显然  a</em>b -  d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。</p><p>考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline ll ksc(ll x,ll y,ll mod)&#123;</span><br><span class="line">    return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getid(int x)&#123;</span><br><span class="line">return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i&lt;=n;++i)&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    v.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end());</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="统计1的个数"><a href="#统计1的个数" class="headerlink" title="统计1的个数"></a>统计1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int NumberOfOne(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">    n &amp;= (n-1);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：位运算，gcd，exgcd，欧拉筛，快速乘，快速幂，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，树链剖分，莫队，LCA，Trie树，KMP，AC自
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="计算几何" scheme="http://qianyouyou.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NAIPC2016-F.Mountain Scenes</title>
    <link href="http://qianyouyou.cn/2018/10/02/2018-10-02/"/>
    <id>http://qianyouyou.cn/2018/10/02/2018-10-02/</id>
    <published>2018-10-02T07:55:38.000Z</published>
    <updated>2018-10-02T08:12:28.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1000ms</li><li>262144K</li></ul><p>An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various integral lengths, then aligns them with the bottom of a frame, rising vertically in columns, to form a mountain scene. A mountain scene must be uneven; if all columns are the same height, it’s a plain scene, not a mountain scene! It is possible that she may not use all of the ribbon.</p><p><a href="https://res.jisuanke.com/img/upload/20180914/0d311ad59ca6302ae44e05c553c59b205ecf2913.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/0d311ad59ca6302ae44e05c553c59b205ecf2913.png" alt="img"></a></p><p>If our artist has 44 inches of ribbon and a 2 \times 22×2 inch frame, she could form these scenes:</p><p><a href="https://res.jisuanke.com/img/upload/20180914/2e4d94cb5e3526193ec13f4402c8d7fbe533df16.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/2e4d94cb5e3526193ec13f4402c8d7fbe533df16.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/90ef24006d11e28c94eed98262a7ae555963c28d.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/90ef24006d11e28c94eed98262a7ae555963c28d.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/c43ed5f0716e4d776714586c04369d1299cccb7a.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/c43ed5f0716e4d776714586c04369d1299cccb7a.png" alt="img"></a> <a href="https://res.jisuanke.com/img/upload/20180914/474d838a889f76324ffecb940bd7bf5731cfca2d.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/474d838a889f76324ffecb940bd7bf5731cfca2d.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/116665c4b2c23c019afe8991e93f28786fc9c7dd.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/116665c4b2c23c019afe8991e93f28786fc9c7dd.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/5cc932933eb1b0c94e695090999f5b5cf88e7966.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/5cc932933eb1b0c94e695090999f5b5cf88e7966.png" alt="img"></a></p><p>She would not form these scenes, because they’re plains, not mountains!</p><p><a href="https://res.jisuanke.com/img/upload/20180914/61f02e20e1290a24e6e2bd70df3626df8d4b20de.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/61f02e20e1290a24e6e2bd70df3626df8d4b20de.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/8d83ffddd160ffd19a4a5522b9e73ef09bb02b39.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/8d83ffddd160ffd19a4a5522b9e73ef09bb02b39.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/100a7f671569edb6ba5decbc74cadcc130a56da4.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/100a7f671569edb6ba5decbc74cadcc130a56da4.png" alt="img"></a></p><p>Given the length of the ribbon and the width and height of the frame, all in inches, how many different mountain scenes can she create? Two scenes are different if the regions covered by ribbon are different. There’s no point in putting more than one piece of ribbon in any column.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input will consist of a single line with three space-separated integers nn, ww and hh, where nn (0 \le n \le 10,000)(0≤n≤10,000) is the length of the ribbon in inches, w (1 \le w \le 100)w(1≤w≤100) is the width and hh (1 \le h \le 100)(1≤h≤100)is the height of the frame, both in inches.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output a single integer, indicating the total number of mountain scenes our artist could possibly make, modulo 10^9 + 7109+7.</p><h4 id="样例输入1复制"><a href="#样例输入1复制" class="headerlink" title="样例输入1复制"></a>样例输入1复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 5 5</span><br></pre></td></tr></table></figure><h4 id="样例输出1复制"><a href="#样例输出1复制" class="headerlink" title="样例输出1复制"></a>样例输出1复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7770</span><br></pre></td></tr></table></figure><h4 id="样例输入2复制"><a href="#样例输入2复制" class="headerlink" title="样例输入2复制"></a>样例输入2复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 5 5</span><br></pre></td></tr></table></figure><h4 id="样例输出2复制"><a href="#样例输出2复制" class="headerlink" title="样例输出2复制"></a>样例输出2复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6050</span><br></pre></td></tr></table></figure><h4 id="样例输入3复制"><a href="#样例输入3复制" class="headerlink" title="样例输入3复制"></a>样例输入3复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 10 1</span><br></pre></td></tr></table></figure><h4 id="样例输出3复制"><a href="#样例输出3复制" class="headerlink" title="样例输出3复制"></a>样例输出3复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1022</span><br></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>问题可以转化为有n个物品，现有w个盘子，每个盘子的容量为[0,h]，所有盘子放的物品不能全部相同，n个物品选[0,n]个物品放进盘中，共有多少种方法。</p><p>首先，利用dp，第一层i为第i个盘子，第2层j为前i个盘子共放置j个物品共有多少种方法。这样<code>dp[i][j]+=dp[i-1][j-k]</code>，其中k[0,h]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxn = 1e4+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll dp[107][maxn];</span><br><span class="line">ll n,w,h;</span><br><span class="line">ll solve()&#123;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    if(n &gt; w * h)&#123;</span><br><span class="line">        n = w*h;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=w; i++)&#123;</span><br><span class="line">        for(int j = 0;j&lt;=n; j++)&#123;</span><br><span class="line">            for(int k = 0; k&lt;=h&amp;&amp;k&lt;=j; k++)&#123;</span><br><span class="line">                dp[i][j]+=dp[i-1][j-k];</span><br><span class="line">                dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (dp[w][n] - 1 - n/w + mod)%mod;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;w,&amp;h))&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;1000ms&lt;/li&gt;
&lt;li&gt;262144K&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various in
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>分时最短路+次小生成树+最小费用最大流题解</title>
    <link href="http://qianyouyou.cn/2018/09/29/2018-09-29/"/>
    <id>http://qianyouyou.cn/2018/09/29/2018-09-29/</id>
    <published>2018-09-29T07:54:04.000Z</published>
    <updated>2018-10-02T08:03:36.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-A-高速"><a href="#问题-A-高速" class="headerlink" title="问题 A: 高速"></a>问题 A: 高速</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 15  解决: 4<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1027&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1915" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1915&amp;cid=1027" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>教练开车去东北，因为比赛地点在东北。共有 n 座城，已知教练在 s 城，比赛地点在 t 城，n 座城之间共有 m 条高速，每条高速连接两座城市，每两座城市之间最多两条高速。每条高速都有权值 v，表示两个城市之间最快可以 v 小时到达。</p><p>然而高速不是永久开放的，每条高速都会有一段开放时间 [ a，b ]，表示该高速在 a ~ b 小时范围之间开放，其余时间处于关闭状态，不能通过任何车辆。例如 [ 24，27 ]表示该路在第 24 小时到 27 小时之间开放。</p><p>已知教练在 0 时刻出发，他最快多少小时可以到达 t 城。</p><p>（PS：由于刹车坏掉了，因此车一旦启动就不能停下来，也就是说车不能停于某点或某边，不过车可以来回无限次在两地之间穿梭）</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，首行输入 t，表示 t 组样例。</p><p>图为无向图，s 城固定为 1 点，t 城固定为 n 点。</p><p>每组样例第 1 行，输入n，m（1 &lt; n ≤ 100，0 &lt; m ≤ 1000）。</p><p>接下来 m 行，每行 5 个数值x，y，v，l，f。表示 x 与 y 有一条高速，耗时为 v。该路开放时间为[ l，f ]。</p><p>数据保证教练可以到达终点，只不过是时间问题。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一个数值，即最少耗时。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 4</span><br><span class="line">2 3 1 5 11</span><br><span class="line">2 5 1 3 18</span><br><span class="line">4 3 1 7 14</span><br><span class="line">1 4 1 0 15</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><blockquote><p>tag：图论、分时最短路</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">//最短路</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">int dis[maxn];  //当前该点到原点最短距离</span><br><span class="line">bool vis[maxn]; //是否访问过</span><br><span class="line">int head[maxn]; //点集</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next,to,w,l,r;  //上一条边，下一个点，权值，左值，右值</span><br><span class="line">&#125;edge[2*maxn];  //边集</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u,dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];  //点集加最短距离</span><br><span class="line">void add(int u, int v, int w, int l,int r)&#123; //构建边集</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].l = l;</span><br><span class="line">    edge[cnt].r = r;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;    //初始化</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;    //读入数据</span><br><span class="line">    int u,v,w,l,r;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,&amp;u,&amp;v,&amp;w,&amp;l,&amp;r);</span><br><span class="line">        add(u,v,w,l,r);</span><br><span class="line">        add(v,u,w,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init_data(int kk)&#123; //初始化数据</span><br><span class="line">    vis[kk] = false;</span><br><span class="line">    dis[kk] = maxx;</span><br><span class="line">&#125;</span><br><span class="line">int solve(int s)&#123;</span><br><span class="line">    priority_queue&lt;NODE&gt;q;  //储存最短距离</span><br><span class="line">    q.push(NODE(s,0));  //读入原点</span><br><span class="line">    while(!q.empty())&#123;  //队列为空则无法到达</span><br><span class="line">        int kk = q.top().u; //储存当前最短距离下标</span><br><span class="line">        int minD = q.top().dis; //储存当前最短距离</span><br><span class="line">        q.pop();</span><br><span class="line">        if(kk==n)   //若下标为目标值，return</span><br><span class="line">            return minD;</span><br><span class="line">        vis[kk] = true; //该点是否访问</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;   //松弛边</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD&lt;=edge[l].r&amp;&amp;minD&gt;=edge[l].l&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to]));   //将松弛后的边压入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        init_data(kk);  //初始化数据</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        init(); //初始化</span><br><span class="line">        read(); //读入</span><br><span class="line">        printf(&quot;%d\n&quot;,solve(1));    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-千年老二"><a href="#问题-C-千年老二" class="headerlink" title="问题 C: 千年老二"></a>问题 C: 千年老二</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 24  解决: 12<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1028&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1913" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1913&amp;cid=1028" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>雷婷与万钧是青梅竹马，无论是考试还是玩游戏，雷婷总是第一，而万钧总是第二，尽管万钧有做第一的实力，但他每次都会把第一让给雷婷，仅因为每次读榜单时雷霆万钧听起来是那么顺耳。这天，雷婷参加了 acm 选拔，万钧也跟着雷婷参加。题目是这样的：</p><p>有 n 个节点，编号为 1~n，有 m 条边，每条边都有一个距离。两点之间最多只有 1 条边。现在你需要选取 n-1 条边，使得所有点都连接起来都有通路。n-1 条边距离之和越小分数越高。</p><p>万钧立马意识到这道题是求最小生成树的，并且每个人的答案不能相同，万钧根据瞪眼法立马瞪出了答案，然而他还是等待雷婷先做完。现在雷婷已经找到了距离最短的1种方案，不过他俩太心有灵犀了，答案一模一样，万钧想获得第 2 名，请你帮万钧想一种方案，距离之和越短越好，但不能和雷婷的结果相同。一条边不同即可认为不同。如果找不到输出 -1。当然存在一种情况，如果雷婷的方案是没有方案求出最短距离，即表示该图没有最小生成树，即输出 -1。总之雷婷的方案是最优解的一种。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>存在多组数据，第一行一个正整数 t，表示有 t 组数据。</p><p>每组数据第一行有两个整数 n 和 m（2 ≤ n ≤ 100，1 ≤ m ≤ 1000)，之后 m 行，每行三个正整数 s，e，w，表示 s 到 e 的双向路的权值为 w。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出次小生成树的值（如果存在多个最小生成树或仅有一个树，则次小生成树就是最小生成树，输出-1），如果不存在输出 -1。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">3 1 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><blockquote><p>tag：图论、次小生成树</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//次小生成树</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int L=1e5+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int maxn=1000+7;</span><br><span class="line">int father[maxn],n,m,num[maxn],nPos;    //父节点（并查集），点数，边数，最小生成树点集，当前访问方位</span><br><span class="line">struct node&#123;</span><br><span class="line">    int s,y,w;</span><br><span class="line">&#125;edge[L];   //边集，左端点，右端点，权值</span><br><span class="line">void init()&#123;    //初始化并查集</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">        father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;    //并查集，构造父节点</span><br><span class="line">    return father[x]==x?x:father[x]=root(father[x]);</span><br><span class="line">&#125;</span><br><span class="line">void unite(int x,int y)&#123;    //并查集，合并两个联通图</span><br><span class="line">    x=root(x);</span><br><span class="line">    y=root(y);</span><br><span class="line">    if(x!=y)</span><br><span class="line">        father[y]=x;</span><br><span class="line">&#125;</span><br><span class="line">int alike(int x,int y)&#123; //并查集，判断是否为同一连通图</span><br><span class="line">    return root(x)==root(y);</span><br><span class="line">&#125;</span><br><span class="line">int cmp(node a,node b)&#123; //sort结构体排序</span><br><span class="line">    return a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">int secondTree(int pos) //次小生成树</span><br><span class="line">&#123;</span><br><span class="line">    init(); //初始化</span><br><span class="line">    int sum=0,cnt=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)    //对于删去边后的图进行最小生成树运算</span><br><span class="line">    &#123;</span><br><span class="line">        if(cnt==n-1)</span><br><span class="line">            break;</span><br><span class="line">        if(i==pos)</span><br><span class="line">            continue;</span><br><span class="line">        if(!alike(edge[i].s,edge[i].y))&#123;</span><br><span class="line">            unite(edge[i].s,edge[i].y);</span><br><span class="line">            sum+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt!=n-1?-1:sum; //判断删除边后是否能构成最小生成树</span><br><span class="line">&#125;</span><br><span class="line">int kruskal()&#123;  //最小生成树</span><br><span class="line">    init();</span><br><span class="line">    sort(edge,edge+m,cmp);  //对边进行权值排序</span><br><span class="line">    int sum=0,cnt=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)    //每次选择最小且未访问过的一条边</span><br><span class="line">    &#123;</span><br><span class="line">        if(cnt==n-1)</span><br><span class="line">            break;</span><br><span class="line">        if(!alike(edge[i].s,edge[i].y))&#123;</span><br><span class="line">            unite(edge[i].s,edge[i].y);</span><br><span class="line">            sum+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            num[++nPos]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt!=n-1?-1:sum; //判断边是否大于等于n-1，否则输出-1</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;    //读入数据</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;edge[i].s,&amp;edge[i].y,&amp;edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;   //解决方案</span><br><span class="line">    int Min=inf;</span><br><span class="line">    nPos=0;</span><br><span class="line">    int mst=kruskal();  //最小生成树值</span><br><span class="line">    if(mst==-1) &#123;   //没有最小生成树即输出-1</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=nPos;i++)&#123;   //对最小生成树的每条边进行遍历，选择删边后的最小值</span><br><span class="line">        int secmst=secondTree(num[i]);</span><br><span class="line">        if(secmst!=-1)  //若没有次小生成树输出-1</span><br><span class="line">            Min=min(Min,secmst);</span><br><span class="line">        &#125;</span><br><span class="line">    if(Min!=inf&amp;&amp;Min!=mst)</span><br><span class="line">        printf(&quot;%d\n&quot;,Min); //输出结果</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        read(); //读入数据</span><br><span class="line">        solve();    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-给力台球厅"><a href="#问题-F-给力台球厅" class="headerlink" title="问题 F: 给力台球厅"></a>问题 F: 给力台球厅</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 10  解决: 3<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1028&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1912" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1912&amp;cid=1028" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>教练爱打台球。这天偶遇一家台球厅，便进去看看。然而这家台球厅貌似和平常的台球厅不太一样，它的每张桌面上的洞都是随机分布在桌面上的，球也是随机摆放的。</p><p>教练立即意识到，此台球厅的桌面不符合正态分布之概率密度函数，而是呈离散分布，顿时患有强迫症的教练心里就不舒服了。为了平缓一下翻腾的内心，教练随机选取了一张球和洞数量一样的球桌，望着奇怪的桌面与奇怪的球，教练脑袋上不禁长出了大把大把的草：如果能求出所有球入洞的最短距离之和该有多好啊。</p><p>现有一个桌面面积为 n×m 的台球桌，将台球桌分成 n×m 个小格，台球桌上有许多的洞和许多的球，均匀分布在小格里，且每个小格只有三种状态，有球，有洞，空白。球用 @ 表示，洞用 # 表示，空白的地方用 * 表示。每个洞只能容纳一个球，球每次只能按照上下左右的方向移动，且每移动一格视为移动 1 个单位长度。当一个球被另一个球挡住时，它可以跳球，所以每一个球都可以完全无视其他球或洞的存在而继续前行，直到进自己心仪的洞。现求所有球进洞的距离之和最小是多少。如果你能帮教练解决这道题，恭喜你就是 ACM 队员了（每个球只能进一个洞，每个洞内有球的话就变成空白状态）</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，首行输入 m，n，即矩形台球桌面的边长。(2 ≤ m，n ≤ 20，球最多100个，洞最多100个，保证洞和球数量相等)</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，即所有球入洞的距离最短是多少。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">*#</span><br><span class="line">@*</span><br><span class="line">7 8</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">@@@@#@@@</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">28</span><br></pre></td></tr></table></figure><blockquote><p>tag：图论、最小费用最大流</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//网络流</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF = 0x3f3f3f3f; //无穷大</span><br><span class="line">const int maxn = 60007;</span><br><span class="line">const int maxm = 1000007;</span><br><span class="line">int vis[maxn],d[maxn],pre[maxn],a[maxn],m,n;    //是否访问，最短路，前置节点，流量，边集，点集</span><br><span class="line">char mp[107][107];  //台球地图</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int u, v, c, cost, next;</span><br><span class="line">&#125;edge[maxm];    //网络流边集</span><br><span class="line"></span><br><span class="line">int s[maxn], cnt;   //每个点流量</span><br><span class="line"></span><br><span class="line">void init()&#123;    //初始化</span><br><span class="line">cnt = 0;</span><br><span class="line">memset(s, -1, sizeof(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int u, int v, int c, int cost)&#123;    //对两点之间进行单向边建立</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].cost = cost;</span><br><span class="line">edge[cnt].c = c;</span><br><span class="line">edge[cnt].next = s[u];</span><br><span class="line">s[u] = cnt++;   //建立单向边</span><br><span class="line">edge[cnt].u = v;</span><br><span class="line">edge[cnt].v = u;</span><br><span class="line">edge[cnt].cost = -cost;</span><br><span class="line">edge[cnt].c = 0;</span><br><span class="line">edge[cnt].next = s[v];</span><br><span class="line">s[v] = cnt++;   //建立双向边</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool spfa(int ss, int ee,int &amp;flow,int &amp;cost)&#123;  //以距离为费用寻找最短路，以最短路为当前增广路</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">memset(d, INF, sizeof d);</span><br><span class="line">memset(vis, 0, sizeof vis); //初始化</span><br><span class="line">d[ss] = 0, vis[ss] = 1, pre[ss] = 0, a[ss] = INF;</span><br><span class="line">q.push(ss);</span><br><span class="line">while (!q.empty())&#123; //spfa以费用为距离寻找最短路</span><br><span class="line">int u = q.front();q.pop();</span><br><span class="line">vis[u] = 0;</span><br><span class="line">for (int i = s[u]; ~i; i = edge[i].next)&#123;   //和当前点相连所有边松弛过程</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">if (edge[i].c&gt;0&amp;&amp; d[v]&gt;d[u] + edge[i].cost)&#123;    //松弛过程</span><br><span class="line">d[v] = d[u] + edge[i].cost;</span><br><span class="line">pre[v] = i;</span><br><span class="line">a[v] = min(a[u], edge[i].c);    //取最小值</span><br><span class="line">if (!vis[v])&#123;</span><br><span class="line">vis[v] = 1;</span><br><span class="line">q.push(v);     //压入待松弛队列</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (d[ee] == INF) return 0; //判断是否有最短路，无说明最大流完成</span><br><span class="line">flow += a[ee];</span><br><span class="line">cost += d[ee]*a[ee];</span><br><span class="line">int u = ee;</span><br><span class="line">while (u != ss)&#123;    //求当前最短路下的流量和</span><br><span class="line">edge[pre[u]].c -= a[ee];</span><br><span class="line">edge[pre[u] ^ 1].c += a[ee];</span><br><span class="line">u = edge[pre[u]].u;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MCMF(int ss, int ee)&#123;   //最小费用最大流</span><br><span class="line">int cost = 0, flow=0;   //初始化</span><br><span class="line">while (spfa(ss, ee, flow, cost));   //寻找增广路径，直到没有增广路径为止</span><br><span class="line">return cost;    //返回最大流费用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct point&#123;</span><br><span class="line">    int x,y;    //球坐标，洞坐标</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    point H[107],P[107];    //建立球集与洞集</span><br><span class="line">    int h=0,p=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;   //输入地图</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;mp[i]);</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if(mp[i][j]==&apos;#&apos;)&#123;  //若为洞则坐标加入洞集</span><br><span class="line">                H[h].x=i;</span><br><span class="line">                H[h].y=j;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(mp[i][j]==&apos;@&apos;)&#123; //若为球则坐标加入球集</span><br><span class="line">                P[p].x=i;</span><br><span class="line">                P[p].y=j;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(); //初始化</span><br><span class="line">    for(int i=0;i&lt;h;i++)</span><br><span class="line">        for(int j=0;j&lt;p;j++)&#123;</span><br><span class="line">        int c=fabs(H[i].x-P[j].x)+fabs(H[i].y-P[j].y);</span><br><span class="line">             add(i+1,h+j+1,1,c);</span><br><span class="line">        &#125;   //建立球与洞之间的路径</span><br><span class="line">    for(int i=0;i&lt;h;i++)    //建立超级源点</span><br><span class="line">        add(0,i+1,1,0);</span><br><span class="line">    for(int i=0;i&lt;p;i++)    //建立超级汇点</span><br><span class="line">        add(h+1+i,h+p+1,1,0);</span><br><span class="line">    printf(&quot;%d\n&quot;,MCMF(0,h+p+1));   //最小费用最大流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(!(m||n))</span><br><span class="line">            break;</span><br><span class="line">        solve();    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题-A-高速&quot;&gt;&lt;a href=&quot;#问题-A-高速&quot; class=&quot;headerlink&quot; title=&quot;问题 A: 高速&quot;&gt;&lt;/a&gt;问题 A: 高速&lt;/h1&gt;&lt;p&gt;时间限制: 1 Sec  内存限制: 128 MB&lt;br&gt;提交: 15  解决: 4&lt;br&gt;[&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="最小费用最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="次小生成树" scheme="http://qianyouyou.cn/tags/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>利用容斥原理求解范围内互素数对数例题</title>
    <link href="http://qianyouyou.cn/2018/09/26/2018-09-26/"/>
    <id>http://qianyouyou.cn/2018/09/26/2018-09-26/</id>
    <published>2018-09-26T12:11:17.000Z</published>
    <updated>2018-09-26T12:30:10.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>Given 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs.<br>Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.<br><strong>Yoiu can assume that a = c = 1 in all test cases.</strong> </p><p>Input</p><p>The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.<br>Each case contains five integers: a, b, c, d, k, 0 &lt; a &lt;= b &lt;= 100,000, 0 &lt; c &lt;= d &lt;= 100,000, 0 &lt;= k &lt;= 100,000, as described above. </p><p>Output</p><p>For each test case, print the number of choices. Use the format in the example. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 3 1 5 1</span><br><span class="line">1 11014 1 14409 9</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 9</span><br><span class="line">Case 2: 736427</span><br></pre></td></tr></table></figure><p>Hint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5).</span><br></pre></td></tr></table></figure><p>题意：</p><p>求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数</p><p>题解：</p><p>gcd(a,b)=k，我们可以写成gcd(a/k,b/k)=1。因此我们只需求[1,b/k]和[1,d/k]范围内互素数的对数。首先利用欧拉函数很容易求解[1,min(a,b)]范围内互素数的对数，将φ(1~min(a,b))全部加起来，就求出1~min(a,b)所有互素对数，假设d永远＞=b,那么接下来我们只需求[1,b]范围内和[b+1,d]范围内互素的数，此时需用容斥原理。对于[1,b]范围内和x互素的数，最多为b个，而在这b个数中我们只需减去不互素的对数即可。我们需先求出x的所有质因数，然后这些质因数的倍数在[1,b]范围内的个数为b/g，因此只需减去这些对数即可，然而由于会有重复的情况出现，因此需用容斥原理处理一下。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll oula[maxn];</span><br><span class="line">int a,b,c,d,k;</span><br><span class="line">struct Number</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int prime[20];</span><br><span class="line">&#125; fac[maxn];</span><br><span class="line">void getLa( int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(fac,0,sizeof(fac));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">        oula[i] = i;</span><br><span class="line">    for(int i = 2; i &lt; n; ++i)</span><br><span class="line">        if( oula[i] == i )</span><br><span class="line">            for(int j = 1; j*i &lt; n; ++j)&#123;</span><br><span class="line">                oula[j*i] -= oula[j*i]/i;</span><br><span class="line">                fac[j*i].prime[fac[j*i].cnt++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inc(int index,int b,int m)</span><br><span class="line">&#123;</span><br><span class="line">    ll r=0,t;</span><br><span class="line">    for(int i=index; i&lt;fac[m].cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=b/fac[m].prime[i];//b范围内有多少个数和m的因数为prime[i]</span><br><span class="line">        r+=t-inc(i+1,t,m);//减去这些数就是b范围内和m互质的数的个数。</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">    b/=k;</span><br><span class="line">    d/=k;</span><br><span class="line">    if(b&gt;d)</span><br><span class="line">        swap(b,d);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= b; ++i)</span><br><span class="line">        ans+=oula[i];</span><br><span class="line">    for(int i=b+1; i&lt;=d; ++i)</span><br><span class="line">        ans+=b-inc(0,b,i);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    getLa(maxn);</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cas = 1; cas&lt;=t; ++cas)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        if(k==0)&#123;</span><br><span class="line">            printf(&quot;Case %d: 0\n&quot;,cas);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;,cas,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面那道和上面这道类似，稍微改一下就好。</p><h2 id="Visible-Trees"><a href="#Visible-Trees" class="headerlink" title="Visible Trees"></a>Visible Trees</h2><p>There are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see.<br>If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him.</p><p>Input</p><p>The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000)</p><p>Output</p><p>For each test case output one line represents the number of trees Farmer Sherlock can see.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>题意</p><p>求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数。当然和上面不同之处在于对数左右数不同也认为不同。(2,3)和(3,2)为不同的对数。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll oula[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">struct Number</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int prime[20];</span><br><span class="line">&#125; fac[maxn];</span><br><span class="line">void getLa( int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(fac,0,sizeof(fac));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">        oula[i] = i;</span><br><span class="line">    for(int i = 2; i &lt; n; ++i)</span><br><span class="line">        if( oula[i] == i )</span><br><span class="line">            for(int j = 1; j*i &lt; n; ++j)&#123;</span><br><span class="line">                oula[j*i] -= oula[j*i]/i;</span><br><span class="line">                fac[j*i].prime[fac[j*i].cnt++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inc(int index,int b,int m)</span><br><span class="line">&#123;</span><br><span class="line">    ll r=0,t;</span><br><span class="line">    for(int i=index; i&lt;fac[m].cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=b/fac[m].prime[i];</span><br><span class="line">        r+=t-inc(i+1,t,m);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">    if(m&gt;n)</span><br><span class="line">        swap(m,n);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; ++i)</span><br><span class="line">        ans+=oula[i];</span><br><span class="line">    ans=ans*2-1;</span><br><span class="line">    for(int i=m+1; i&lt;=n; ++i)</span><br><span class="line">        ans+=m-inc(0,m,i);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    getLa(maxn);</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳蚤"><a href="#跳蚤" class="headerlink" title="跳蚤"></a>跳蚤</h2><p>Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。<br>比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。<br>当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 </p><p>Input</p><p>两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。</p><p>Output</p><p>可以完成任务的卡片数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>Hint</p><p>这12张卡片分别是：<br>(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4),<br>(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define LL long long int</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005,maxm = 100005,INF = 1000000000;</span><br><span class="line"></span><br><span class="line">LL N,M;</span><br><span class="line">int fac[maxn],faci = 0;</span><br><span class="line"></span><br><span class="line">void Sp()&#123;</span><br><span class="line">LL e = M;</span><br><span class="line">for (LL i = 2; i * i &lt;= e; i++)&#123;</span><br><span class="line">if (e % i == 0)&#123;</span><br><span class="line">fac[++faci] = i;</span><br><span class="line">while (e % i == 0) e /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (e - 1) fac[++faci] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">LL ans = 1;</span><br><span class="line">for (; b; b &gt;&gt;= 1, a *= a)</span><br><span class="line">if (b &amp; 1) ans *= a;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL cal(int s)&#123;</span><br><span class="line">LL mult = 1,pos = 1;</span><br><span class="line">for (int i = 1; s; i++,s &gt;&gt;= 1)&#123;</span><br><span class="line">if (s &amp; 1)&#123;</span><br><span class="line">mult *= fac[i];</span><br><span class="line">pos *= -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return qpow(M/mult,N) * pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;p&gt;Given 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>容斥原理的三种运用方式</title>
    <link href="http://qianyouyou.cn/2018/09/25/2018-09-25-1/"/>
    <id>http://qianyouyou.cn/2018/09/25/2018-09-25-1/</id>
    <published>2018-09-25T11:25:41.000Z</published>
    <updated>2018-09-25T11:30:45.090Z</updated>
    
    <content type="html"><![CDATA[<p>在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 集合相交通常情况为奇加偶减，即加上重叠为奇次的，减去重叠为偶次的。</p><p>容斥原理是属于一种模板题目，一般简单的都是之间打模板，稍难的题目运用到了数学分析和数论的其他知识。</p><p>容斥原理分为三种实现：</p><p>1.位运算与二进制枚举（容易理解）</p><p>2.队列数组（耗时最短）</p><p>3.递归（代码最短但不容易理解）</p><p><a href="http://blog.csdn.net/deepseazbw/article/details/76187211" target="_blank" rel="noopener">http://blog.csdn.net/deepseazbw/article/details/76187211</a></p><p>HDU的一道题目用的三种方法实现，一般都是找出一个数字的素因子，然后用cnt（计算器）记录下来，然后分别三种方法实现.</p><p>实现容斥原理的时候</p><p>1.先计算出容斥部分，然后再用总数减去 <a href="http://blog.csdn.net/deepseazbw/article/details/76187211" target="_blank" rel="noopener">http://blog.csdn.net/deepseazbw/article/details/76187211</a></p><p>2.在容斥部分的时候，就将总数带入进去 <a href="http://blog.csdn.net/deepseazbw/article/details/76660935" target="_blank" rel="noopener">http://blog.csdn.net/deepseazbw/article/details/76660935</a></p><p>模板题目： HDU  4135  1695</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>求解逆元的3种方法</title>
    <link href="http://qianyouyou.cn/2018/09/25/2018-09-25/"/>
    <id>http://qianyouyou.cn/2018/09/25/2018-09-25/</id>
    <published>2018-09-25T11:15:39.000Z</published>
    <updated>2018-09-25T11:19:58.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述逆元"><a href="#简述逆元" class="headerlink" title="简述逆元"></a>简述逆元</h2><p>逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。<br> 比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p</p><p>观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在下面所有的算法中，最好先把除数取个模再运算。</p><h2 id="方法一：扩展欧几里得算法"><a href="#方法一：扩展欧几里得算法" class="headerlink" title="方法一：扩展欧几里得算法"></a>方法一：扩展欧几里得算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>a∗b≡1(modp)a∗b≡1(modp)<br> a∗b+k∗p=1a∗b+k∗p=1<br> 然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。</p><p>如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 </span><br><span class="line">&#123;</span><br><span class="line">    if(b==0)</span><br><span class="line">    &#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 </span><br><span class="line">&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL d=exgcd(a,mod,x,y);</span><br><span class="line">    return d==1?(x%mod+mod)%mod:-1;</span><br><span class="line">&#125;1234567891011121314151617</span><br></pre></td></tr></table></figure><p>注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大.</p><p>性能分析:</p><ul><li>时间复杂度:O(logn)（实际是斐波那契数列）</li><li>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</li></ul><h2 id="方法二-费马小定理-欧拉定理"><a href="#方法二-费马小定理-欧拉定理" class="headerlink" title="方法二:费马小定理/欧拉定理"></a>方法二:费马小定理/欧拉定理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp)<br>   ap−2∗a≡1(modp)ap−2∗a≡1(modp)<br>   ap−2ap−2就是a在mod p意义下的逆元啦。</p><p>欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式)<br>   aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp)<br>   aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL qkpow(LL a,LL p,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    LL t=1,tt=a%mod;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p&amp;1)t=t*tt%mod;</span><br><span class="line">        tt=tt*tt%mod;</span><br><span class="line">        p&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(LL a,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    return qkpow(a,mod-2,mod);</span><br><span class="line">&#125;123456789101112131415</span><br></pre></td></tr></table></figure><p>性能分析：</p><ul><li>O(logmod)</li><li>适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。</li><li>但是如果是合数，相信一般没人无聊到去算个欧拉函数。</li></ul><h2 id="方法三：递推求逆元"><a href="#方法三：递推求逆元" class="headerlink" title="方法三：递推求逆元"></a>方法三：递推求逆元</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值<br> p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i<br> k∗i+r≡0(modp)k∗i+r≡0(modp)<br> k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp)<br> i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp)<br> i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi]<br> 嗯。。好难看的公式<br> 说白了就是:inv[i]=-(mod/i)*inv[i%mod]<br> 然后边界是inv[1]=1<br> 这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LL inv[mod+5];</span><br><span class="line">void getInv(LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    inv[1]=1;</span><br><span class="line">    for(int i=2;i&lt;mod;i++)</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;1234567</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>调用前要先预处理</li><li>调用的时候要先对除数取mod</li></ul><p>性能分析：</p><ul><li>时间复杂度O(n)</li><li>适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。</li></ul><h4 id="递归求逆元"><a href="#递归求逆元" class="headerlink" title="递归求逆元"></a>递归求逆元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LL inv(LL i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i==1)return 1;</span><br><span class="line">    return (mod-mod/i)*inv(mod%i)%mod;</span><br><span class="line">&#125;12345</span><br></pre></td></tr></table></figure><p>性能分析</p><ul><li>时间复杂度:O(logmod)</li><li>好像找到了最简单的算法了！！</li><li>适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述逆元&quot;&gt;&lt;a href=&quot;#简述逆元&quot; class=&quot;headerlink&quot; title=&quot;简述逆元&quot;&gt;&lt;/a&gt;简述逆元&lt;/h2&gt;&lt;p&gt;逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。&lt;br&gt; 比如a∗b≡1(m
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="逆元" scheme="http://qianyouyou.cn/tags/%E9%80%86%E5%85%83/"/>
    
      <category term="exgcd" scheme="http://qianyouyou.cn/tags/exgcd/"/>
    
      <category term="费马小定理" scheme="http://qianyouyou.cn/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"/>
    
      <category term="欧拉函数" scheme="http://qianyouyou.cn/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>生成函数小结</title>
    <link href="http://qianyouyou.cn/2018/09/24/2018-09-24/"/>
    <id>http://qianyouyou.cn/2018/09/24/2018-09-24/</id>
    <published>2018-09-24T11:15:23.000Z</published>
    <updated>2018-09-25T11:18:20.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h1><p><strong>母函数是用于解决组合问题计数的一种方法。</strong><br> 在了解它之前我们先看看熟悉的杨辉三角。<br>  <img src="https://img-blog.csdn.net/20170611212741764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ0hOX0pa/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)n(1+x)n的展开式从低项到高项的各项系数，也可以表示为组合数的形式CinCni。如果将两者联系起来我们会发现，(1+x)(1+x)可以看成对于一件取舍，1=x01=x0就是不取，x就是取。这样在(1+x)n(1+x)n的展开式中xixi项的系数就是从n件物品选取i件的方案数。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定数列a0,a1,a2…ana0,a1,a2…an，构造函数G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x),其中G(x)G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)f0(x),f1(x),f2(x)…fn(x)为标志函数。<br> <strong>母函数主要有两种形式：普通型母函数和指数型母函数。</strong></p><h2 id="普通型母函数"><a href="#普通型母函数" class="headerlink" title="普通型母函数"></a>普通型母函数</h2><p>先看一个例题：<a href="http://blog.csdn.net/chn_jz/article/details/73064925" target="_blank" rel="noopener">HDU 1085</a><br> 普通型母函数的标志函数一般为x0，x1,x2…xnx0，x1,x2…xn<br> 因为每个硬币有个数限制，但是也不难构造出</p><p>G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5)G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5)</p><p>xixi</p><h2 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h2><p>再看一个例题：<a href="http://blog.csdn.net/chn_jz/article/details/73062222" target="_blank" rel="noopener">HDU 1521</a><br> 指数型母函数的标志函数一般为x00!,x11!,x22!…xnn!x00!,x11!,x22!…xnn!，对于xii!xii!表示在一个方案中某个元素出现了ii次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！i！。<br> 对于这道题就不难构造出母函数为</p><p>G(x)=(1/ 0!+X / 1!+X2 / 2!+…+Xa1 / a1!)(1 / 0!+X / 1!+X2 / 2!+…+Xa2 / a2!)( / 0!+X / 1!+X2 / 2!+…+Xan / an!)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;母函数&quot;&gt;&lt;a href=&quot;#母函数&quot; class=&quot;headerlink&quot; title=&quot;母函数&quot;&gt;&lt;/a&gt;母函数&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;母函数是用于解决组合问题计数的一种方法。&lt;/strong&gt;&lt;br&gt; 在了解它之前我们先看看熟悉的杨辉三角。&lt;br&gt; 
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="生成函数" scheme="http://qianyouyou.cn/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM/ICPC北京网络赛D题 80 Days（非暴力0(n)解法）</title>
    <link href="http://qianyouyou.cn/2018/09/22/2018-09-22-1/"/>
    <id>http://qianyouyou.cn/2018/09/22/2018-09-22-1/</id>
    <published>2018-09-22T14:18:21.000Z</published>
    <updated>2018-09-23T06:29:27.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><em>80 Days is an interesting game based on Jules Verne’s science fiction “Around the World in Eighty Days”.</em> In this game, you have to manage the limited money and time.</p><p>Now we simplified the game as below:</p><p>There are n cities on a circle around the world which are numbered from 1 to n by their order on the circle. When you reach the city i at the first time, you will get ai dollars (ai can even be negative), and if you want to go to the next city on the circle, you should pay bi dollars. At the beginning you have c dollars.</p><p>The goal of this game is to choose a city as start point, then go along the circle and visit all the city once, and finally return to the start point. During the trip, the money you have must be no less than zero.</p><p>Here comes a question: to complete the trip, which city will you choose to be the start city?</p><p>If there are multiple answers, please output the one with the smallest number.</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>The first line of the input is an integer T (T ≤ 100), the number of test cases.</p><p>For each test case, the first line contains two integers n and c (1 ≤ n ≤ 10^6, 0 ≤ c ≤ 10^9).  The second line contains n integers a1, …, an  (-10^9 ≤ ai ≤ 10^9), and the third line contains n integers b1, …, bn (0 ≤ bi ≤ 10^9).</p><p>It’s guaranteed that the sum of n of all test cases is less than 106</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case, output the start city you should choose.</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>For test case 1, both city 2 and 3 could be chosen as start point, 2 has smaller number. But if you start at city 1, you can’t go anywhere.</p><p>For test case 2, start from which city seems doesn’t matter, you just don’t have enough money to complete a trip.</p><p><strong>利用前缀和与后缀和优化dp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define LL long long</span><br><span class="line">const LL maxn = 1e6+7;</span><br><span class="line">LL a[maxn],b[maxn],cha[maxn],qian[maxn],qian2[maxn], hou[maxn], hou2[maxn];</span><br><span class="line">void init(LL n,LL c)&#123;</span><br><span class="line">    hou[n+1] = qian[0] = 0;</span><br><span class="line">    hou2[n] = hou[n] = cha[n];</span><br><span class="line">    qian2[1] = qian[1] = cha[1];</span><br><span class="line">    for(int i = 2;i&lt;=n;i++)&#123;</span><br><span class="line">        qian[i] = cha[i]+qian[i-1];</span><br><span class="line">        qian2[i] = min(qian[i],qian2[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = 0;</span><br><span class="line">    for(int i = n-1;i&gt;0;i--)&#123;</span><br><span class="line">        hou[i] = cha[i]+hou[i+1];</span><br><span class="line">        hou2[i] = min(hou[i]-sum,cha[i]);</span><br><span class="line">        if(hou2[i]&gt;=0)&#123;</span><br><span class="line">            sum=hou[i];</span><br><span class="line">            hou2[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int fun(LL n,LL c)&#123;</span><br><span class="line">    if(qian[n]+c&lt;0)</span><br><span class="line">        return -1;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(cha[i]+c&gt;=0&amp;&amp;cha[i]+c+hou2[i+1]&gt;=0)&#123;</span><br><span class="line">            if(hou[i]+c+qian2[i-1]&gt;=0)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    LL n,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;c);</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;b[i]);</span><br><span class="line">            cha[i] = a[i] - b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        init(n,c);</span><br><span class="line">        int tmp = fun(n,c);</span><br><span class="line">        printf(&quot;%d\n&quot;,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尺取法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define MAX 1000005</span><br><span class="line"> </span><br><span class="line">int p[MAX&lt;&lt;1],a[MAX],b[MAX];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">long long c;</span><br><span class="line">scanf(&quot;%d%lld&quot;,&amp;n,&amp;c);</span><br><span class="line">for(int i = 1;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = p[i + n] = a[i] - b[i];</span><br><span class="line">&#125;</span><br><span class="line">int l = 1,r = 1;</span><br><span class="line">while(l &lt;= n &amp;&amp; r - l + 1 &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">c = c + p[r];</span><br><span class="line">r ++;</span><br><span class="line">while(c &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">c = c - p[l];</span><br><span class="line">l ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(l &gt; n)</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%d\n&quot;,l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;&lt;em&gt;80 Days is an interesting game based on Jules Verne’s science fict
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="尺取法" scheme="http://qianyouyou.cn/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[组合数学]动态规划解决整数划分问题</title>
    <link href="http://qianyouyou.cn/2018/09/22/2018-09-22/"/>
    <id>http://qianyouyou.cn/2018/09/22/2018-09-22/</id>
    <published>2018-09-22T14:02:20.000Z</published>
    <updated>2018-09-23T06:16:20.350Z</updated>
    
    <content type="html"><![CDATA[<p>整数划分问题是将一个正整数n拆成一组数连加并等于n的形式，且这组数中的最大加数不大于n。</p><p>如6的整数划分为：    </p><p>6         6     </p><p>5        5 + 1     </p><p>4         4 + 2, 4 + 1 + 1     </p><p>3         3 + 3, 3 + 2 + 1, 3 + 1 + 1 + 1    </p><p>2        2 + 2 + 2, 2 + 2 + 1 + 1, 2 + 1 + 1 + 1 + 1     </p><p>1         1 + 1 + 1 + 1 + 1 + 1</p><p>设n为要划分的正整数，m是划分中的最大加数(当m &gt; n时，最大加数为n)，     </p><p>1 当n = 1或m = 1时，split的值为1，可根据上例看出，只有一个划分1 或 1 + 1 + 1 + 1 + 1 + 1     可用程序表示为if(n == 1 || m == 1) return 1;          </p><p>2 下面看一看m 和 n的关系。它们有三种关系     </p><p>(1) m &gt; n     在整数划分中实际上最大加数不能大于n，因此在这种情况可以等价为split(n, n);     可用程序表示为if(m &gt; n) return split(n, n); </p><p>(2) m = n     这种情况可用递归表示为split(n, m - 1) + 1，从以上例子中可以看出，就是最大加     数为6和小于6的划分之和     用程序表示为if(m == n) return (split(n, m - 1) + 1); </p><p>(3) m &lt; n     这是最一般的情况，在划分的大多数时都是这种情况。     从上例可以看出，设m = 4，那split(6, 4)的值是最大加数小于4划分数和整数2的划分数的和。</p><p>因此，split(n, m)可表示为split(n, m - 1) + split(n - m, m) </p><p><strong>hdu1028</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 121;</span><br><span class="line">int n, dp[maxn][maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    dp[0][0] = dp[1][0] = 1;</span><br><span class="line">    for(int i = 1;i&lt;maxn;i++)</span><br><span class="line">        dp[i][1] = 1;</span><br><span class="line">    for(int i = 2;i&lt;maxn;i++)</span><br><span class="line">        for(int j = 1;j&lt;=i;j++)</span><br><span class="line">            dp[i][j] = dp[i][j-1] + dp[i-j][min(i-j,j)];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,dp[n][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整数划分问题是将一个正整数n拆成一组数连加并等于n的形式，且这组数中的最大加数不大于n。&lt;/p&gt;
&lt;p&gt;如6的整数划分为：    &lt;/p&gt;
&lt;p&gt;6         6     &lt;/p&gt;
&lt;p&gt;5        5 + 1     &lt;/p&gt;
&lt;p&gt;4         4 +
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="划分" scheme="http://qianyouyou.cn/tags/%E5%88%92%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[容斥原理]Hard to prepare</title>
    <link href="http://qianyouyou.cn/2018/09/20/2018-09-20/"/>
    <id>http://qianyouyou.cn/2018/09/20/2018-09-20/</id>
    <published>2018-09-20T05:02:52.000Z</published>
    <updated>2018-09-20T05:37:52.008Z</updated>
    
    <content type="html"><![CDATA[<p>After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enjoy the show, every audience has to wear a Nogaku mask, and seat around as a circle.</p><p>There are N guests Reimu serves. Kokoro has 2^k2k masks numbered from 0,1,\cdots,0,1,⋯, 2^k - 12k−1, and every guest wears one of the masks. The masks have dark power of Dark Nogaku, and to prevent guests from being hurt by the power, two guests seating aside must ensure that if their masks are numbered ii and jj , then ii XNOR jj must be positive. (two guests can wear the same mask). XNOR means ~(ii^jj) and every number has kk bits. (11 XNOR 1 = 11=1, 00XNOR 0 = 10=1, 11 XNOR 0 = 00=0)</p><p>You may have seen 《A Summer Day’s dream》, a doujin Animation of Touhou Project. Things go like the anime, Suika activated her ability, and the feast will loop for infinite times. This really troubles Reimu: to not make her customers feel bored, she must prepare enough numbers of different Nogaku scenes. Reimu find that each time the same guest will seat on the same seat, and She just have to prepare a new scene for a specific mask distribution. Two distribution plans are considered different, if any guest wears different masks.</p><p>In order to save faiths for Shrine, Reimu have to calculate that to make guests not bored, how many different Nogaku scenes does Reimu and Kokoro have to prepare. Due to the number may be too large, Reimu only want to get the answer modules 1e9+71e9+7 . Reimu did never attend Terakoya, so she doesn’t know how to calculate in module. So Reimu wishes you to help her figure out the answer, and she promises that after you succeed she will give you a balloon as a gift.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line one number TT , the number of testcases; (T \le 20)(T≤20) .</p><p>Next TT lines each contains two numbers, NNand k(0&lt;N, k \le 1e6)k(0&lt;N,k≤1e6) .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each testcase output one line with a single number of scenes Reimu and Kokoro have to prepare, the answer modules 1e9+71e9+7 .</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">84</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p><p><strong>题目描述</strong></p><p>有n个位置围成一个圈，2^k个数，每个位置随便放置一个数，要求范围在1到2^k之间，然而每个数都有一个互斥的数，且互斥的两个数不会和其他的重复，要求相邻位置不能有互斥的数。</p><p><strong>题解</strong></p><p>首先用快速幂求出2^k然后赋给k，即k = 2^k。然后假设这n个数依次排开，那么每一个数不能是上一个元素的互斥数，那么第1个元素共k种，那么之后每一种为k-1种。即<code>k*(k-1)^(n-1)</code>，然而这样的话最后一个元素可以为第一个元素的互斥数，因此要减去相应的数，根据容斥原理最终列出实在为<code>k*(k-1)^(n-1)-k*(k-1)^(n-2)+k*(k-1)^(n-3)-k*(k-1)^(n-4)……</code>然而这样做会超时，因此我们可以合并，即加一次减一次合并到一起重新得到公式。</p><p>当然我们也可以换一种思考方式，很容易想到，第1个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek" alt="\small 2^k">种选择，第2个数到第n-1个数都有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-1" alt="\small 2^k-1">种选择，第n个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-2" alt="\small 2^k-2">种选择。</p><p>所以答案就是<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek%282%5Ek-2%29%282%5Ek-1%29%5E%7Bn-2%7D" alt="\small 2^k(2^k-2)(2^k-1)^{n-2}"></p><p>但是这样会出现漏算：在第1个数和第n-1个数相同的情况下，第n个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-1" alt="\small 2^k-1">种选择， 而并非<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-2" alt="\small 2^k-2">种</p><p>然后仔细分析可以发现，漏算的情况你可以把第1个数和第n-1个数当成同一个数，这样序列长度就变成n-2了，问题规模变小</p><p>递归或递推即可</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll quick_pow(ll ans, ll res, ll n)&#123;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">            ans = ans * res % mod;</span><br><span class="line">        res = res * res % mod;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll n, ll k)&#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    ll i = (n&amp;1)+2;</span><br><span class="line">    ll res = pow(k-1,i-2);</span><br><span class="line">    for(;i&lt;=n;i+=2)&#123;</span><br><span class="line">        ans = (ans + res) % mod;</span><br><span class="line">        res = res * (k - 1) % mod * (k - 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * k % mod * (k - 2) % mod;</span><br><span class="line">    ans = (ans + k) % mod;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t,n,k;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">        k = quick_pow(1,2,k);</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve(n,k));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enj
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2015 ACM-ICPC Asia Regional Contest Shanghai Site - Onsite Contest</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18-2/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18-2/</id>
    <published>2018-09-18T13:22:56.000Z</published>
    <updated>2018-09-18T13:43:53.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Friendship-of-Frog"><a href="#F-Friendship-of-Frog" class="headerlink" title="F - Friendship of Frog"></a>F - Friendship of Frog</h2><p> NN frogs from different countries are standing in a line. Each country is represented by a lowercase letter. The distance between adjacent frogs (e.g. the 1st1stand the 2nd2nd frog, the N−1thN−1th and the NthNth frog, etc) are exactly 11. Two frogs are friends if they come from the same country.<br>The closest friends are a pair of friends with the <strong>minimum</strong> distance. Help us find that distance.</p><p>Input</p><p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case only contains a string with length NN, and the ithith character of the string indicates the country of ithith frogs.<br>⋅⋅ 1≤T≤501≤T≤50.<br>⋅⋅ for 80% data, 1≤N≤1001≤N≤100.<br>⋅⋅ for 100% data, 1≤N≤10001≤N≤1000.<br>⋅⋅ the string only contains lowercase letters.</p><p>Output</p><p>For every test case, you should output “ <strong>Case #x: y</strong>“, where xx indicates the case number and counts from 11 and yy is the result. If there are no frogs in same country, output −1−1 instead.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">abcecba</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 2</span><br><span class="line">Case #2: -1</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>超级水题，一次性遍历，顺便设置一个字母表，记录上一个字母位置，初始值为0，每遇到一个字母，对该字母表进行更新。如果上一个该字母表不为0，则先用当前位置减去表中上一个位置，然后记录下最小值，然后再更新。最终如果最小值为初始值，则输出-1，否则输出该最小值。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e9+7;</span><br><span class="line">char str[1007];</span><br><span class="line">int a[26];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cc = 1;cc&lt;=t;cc++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;str);</span><br><span class="line">        int minD = maxx;</span><br><span class="line">        memset(a,0,sizeof(a));</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">            int num = str[i]-&apos;a&apos;;</span><br><span class="line">            if(a[num])</span><br><span class="line">                minD = min(minD,i - a[num] + 1);</span><br><span class="line">            a[num] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minD == maxx)</span><br><span class="line">            printf(&quot;Case #%d: -1\n&quot;,cc);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Case #%d: %d\n&quot;,cc,minD);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Kingdom-of-Black-and-White"><a href="#K-Kingdom-of-Black-and-White" class="headerlink" title="K - Kingdom of Black and White"></a>K - Kingdom of Black and White</h2><p>In the Kingdom of Black and White (KBW), there are two kinds of frogs: black frog and white frog.<br>Now NN frogs are standing in a line, some of them are black, the others are white. The total strength of those frogs are calculated by dividing the line into minimum parts, each part should still be continuous, and can only contain one kind of frog. Then the strength is the sum of the squared length for each part.<br>However, an old, evil witch comes, and tells the frogs that she will change the color of <strong>at most one</strong> frog and thus the strength of those frogs might change.<br>The frogs wonder the <strong>maximum</strong> possible strength after the witch finishes her job.</p><p>Input</p><p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case only contains a string with length NN, including only 00(representing<br>a black frog) and 11 (representing a white frog).<br>⋅⋅ 1≤T≤501≤T≤50.<br>⋅⋅ for 60% data, 1≤N≤10001≤N≤1000.<br>⋅⋅ for 100% data, 1≤N≤1051≤N≤105.<br>⋅⋅ the string only contains 0 and 1.</p><p>Output</p><p>For every test case, you should output “ <strong>Case #x: y</strong>“,where xx indicates the case number and counts from 11 and yy is the answer.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">000011</span><br><span class="line">0101</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 26</span><br><span class="line">Case #2: 10</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>解法有点偏暴力，首先将01分成m个联通块，一次性遍历，将m个联通块的长度储存起来，算出总值ans。然后对这m个联通块分别判断加1情况下是否变大，当然该值的计算要先用ans减去该联通块以及相邻左边或右边联通块的值，然后再加上更新的值。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cas=1;cas&lt;=t;cas++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        int flag = -1;</span><br><span class="line">        vector&lt;long long&gt; Q;</span><br><span class="line">        int len = 0;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]-&apos;0&apos;!=flag)</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push_back(len);</span><br><span class="line">                len = 1;</span><br><span class="line">                flag = s[i]-&apos;0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push_back(len);</span><br><span class="line">        Q.push_back(0);</span><br><span class="line">        long long res = 0;</span><br><span class="line">        for(int i=1;i&lt;Q.size()-1;i++)</span><br><span class="line">            res += Q[i]*Q[i];</span><br><span class="line">        long long ans = res;</span><br><span class="line">        for(int i=1;i&lt;Q.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            long long tmp = 0;</span><br><span class="line">            if(Q[i]==1)</span><br><span class="line">                ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]-Q[i+1]*Q[i+1]+(Q[i-1]+Q[i+1]+1)*(Q[i-1]+Q[i+1]+1));</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]+(Q[i-1]+1)*(Q[i-1]+1)+(Q[i]-1)*(Q[i]-1));</span><br><span class="line">                ans = max(ans,res-Q[i+1]*Q[i+1]-Q[i]*Q[i]+(Q[i+1]+1)*(Q[i+1]+1)+(Q[i]-1)*(Q[i]-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-LCM-Walk"><a href="#L-LCM-Walk" class="headerlink" title="L - LCM Walk"></a>L - LCM Walk</h2><p> A frog has just learned some number theory, and can’t wait to show his ability to his girlfriend.<br>Now the frog is sitting on a grid map of infinite rows and columns. Rows are numbered 1,2,⋯1,2,⋯ from the bottom, so are the columns. At first the frog is sitting at grid (sx,sy)(sx,sy), and begins his journey.<br>To show his girlfriend his talents in math, he uses a special way of jump. If currently the frog is at the grid (x,y)(x,y), first of all, he will find the minimum zzthat can be divided by both xx and yy, and jump exactly zz steps to the up, or to the right. So the next possible grid will be (x+z,y)(x+z,y), or (x,y+z)(x,y+z).<br>After a finite number of steps (perhaps zero), he finally finishes at grid (ex,ey)(ex,ey). However, he is too tired and he forgets the position of his starting grid!<br>It will be too stupid to check each grid one by one, so please tell the frog the number of possible starting grids that can reach (ex,ey)(ex,ey)!</p><p>Input</p><p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case contains two integers exex and eyey, which is the destination grid.<br>⋅⋅ 1≤T≤10001≤T≤1000.<br>⋅⋅ 1≤ex,ey≤1091≤ex,ey≤109.</p><p>Output</p><p>For every test case, you should output “ <strong>Case #x: y</strong>“, where xx indicates the case number and counts from 11 and yy is the number of possible starting grids. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6 10</span><br><span class="line">6 8</span><br><span class="line">2 8</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 2</span><br><span class="line">Case #3: 3</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>设当前位置为(x,y)，gcd(x,y) = g。则可设x = m1g，y=m2g，LCM（x,y） = m1m2g，则目标值为（m1g+m1m2g，m2g）或（m1g，m2g+m1m2g）。已知目标值，求x，y。我们设目标值为x2，y2，则可推出m1 = x2/(g+y2)或m2 = y2/(g+x2)。递归过程，直到m1或m2不为0则返回值，否则次数加1，再继续递归。</p><p>最终得到结果。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return a%b==0?b:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll g,ll x,ll y)&#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    if(!(x%(g+y)))&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        ll tmp = x*g/(g+y);</span><br><span class="line">        ans+=dfs(gcd(max(tmp,y),min(tmp,y)),tmp,y);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(y%(g+x)))&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        ll tmp = y*g/(g+x);</span><br><span class="line">        ans+=dfs(gcd(max(tmp,x),min(tmp,x)),x,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t,x,y;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    for(ll c = 1;c&lt;=t;c++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);</span><br><span class="line">        ll tmp = gcd(max(x,y),min(x,y));</span><br><span class="line">        ll ans = dfs(tmp,x,y);</span><br><span class="line">        printf(&quot;Case #%lld: %lld\n&quot;,c,++ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;F-Friendship-of-Frog&quot;&gt;&lt;a href=&quot;#F-Friendship-of-Frog&quot; class=&quot;headerlink&quot; title=&quot;F - Friendship of Frog&quot;&gt;&lt;/a&gt;F - Friendship of Frog&lt;/
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://qianyouyou.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>NOI手拉手问题</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18-1/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18-1/</id>
    <published>2018-09-18T07:08:24.000Z</published>
    <updated>2018-09-18T08:03:32.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成环的个数的期望。PS：一个人的左手和右手也可以拉起来构成一个环。</p><p>例如：n为2时，期望为4/3，假设从第一个人的左手开始，他的左手和右手和第2个人的左手和右手拉起来的概率都为1/3，其中自己的左手和右手拉起来构成环数为2，其他为1，则期望为<code>1/3*2+1/3*1+1/3*1</code></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>1+1/3+1/5+……1/(2n-1)</p><p>如果直接看公式很容易理解，每多一个人，就多了两只手，假设除了这个人以外其他人的期望都算出来了，假设期望为F(n)，那么对于这个人来说无非两种情况，要么和自己拉，要么和别人拉，和自己拉的概率为1/(2n-1)，和别人拉的概率为(2n-2)/(2n-1)。和自己拉的话很好理解，在之前的期望上加1就好了，和别人拉的话就可以把这两个人绑定起来当成一个人就好了，期望就是之前的期望。所以用公式的话就是<code>F(n+1)=F(n)*(2n-2)/(2n-1)+(F(n)+1)*1/(2n-1)</code>,化简就得<code>F(n+1)=F(n)+1/(2n-1)</code>，递归得F(n)=1+1/3+1/5+……1/(2n-1)</p><p>根据调和级数推到公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ld long double</span><br><span class="line">const int maxn = 1e7+7;</span><br><span class="line">ld a[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    a[0] = 0;</span><br><span class="line">    a[1]=1;</span><br><span class="line">    for(int i = 2;i&lt;maxn;i++)&#123;</span><br><span class="line">        a[i]=a[i-1]+1.0/(2*i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;head.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;head.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    long long tmp;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;tmp;</span><br><span class="line">    if(tmp*1.0&gt;=maxn)</span><br><span class="line">        cout&lt;&lt;log(2*tmp-1) - log(((2*tmp-1)-1)/2)/ 2 + 0.57721566490153286060651209 / 2&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;a[tmp]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="概率轮" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E8%BD%AE/"/>
    
    
      <category term="期望" scheme="http://qianyouyou.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>寻找距离最小点对</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18/</id>
    <published>2018-09-18T03:07:01.000Z</published>
    <updated>2018-09-18T03:08:31.951Z</updated>
    
    <content type="html"><![CDATA[<p>在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一。下面我们着重考虑平面上的最接近点对问题。</p><p>​    最接近点对问题的提法是:给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。</p><p>​    严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。</p><p><strong>参考解答</strong></p><p>​    这个问题很容易理解，似乎也不难解决。我们只要将每一点与其他n-1个点的距离算出，找出达到最小距离的两个点即可。然而，这样做效率太低，需要O(n2)的计算时间。在问题的计算复杂性中我们可以看到，该问题的计算时间下界为Ω(nlogn)。这个下界引导我们去找问题的一个θ(nlogn)<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>。</p><p>这个问题显然满足分治法的第一个和第二个适用条件，我们考虑将所给的平面上n个点的集合S分成2个子集S1和S2，每个子集中约有n/2个点，·然后在每个子集中递归地求其最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对，因为S1和S2的最接近点对未必就是S的最接近点对。如果组成S的最接近点对的2个点都在S1中或都在S2中，则问题很容易解决。但是，如果这2个点分别在S1和S2中，则对于S1中任一点p，S2中最多只有n/2个点与它构成最接近点对的候选者，仍需做n2/4次计算和比较才能确定S的最接近点对。因此，依此思路，合并步骤耗时为O(n2)。整个算法所需计算时间T(n)应满足:　</p><p>T(n)=2T(n/2)+O(n2)</p><p>​     它的解为T(n)=O(n2)，即与合并步骤的耗时同阶，显示不出比用穷举的方法好。从解递归方程的套用公式法，我们看到问题出在合并步骤耗时太多。这启发我们把注意力放在合并步骤上。</p><p>​    为了使问题易于理解和分析，我们先来考虑一维的情形。此时S中的n个点退化为x轴上的n个实数x1,x2,..,xn。最接近点对即为这n个实数中相差最小的2个实数。我们显然可以先将x1,x2,..,xn排好序，然后，用一次线性扫描就可以找出最接近点对。这种方法主要计算时间花在排序上，因此如在排序算法中所证明的，耗时为O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对这种一维的简单情形，我们还是尝试用分治法来求解，并希望能推广到二维的情形。</p><p>​    假设我们用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}。这样一来，对于所有p∈S1和q∈S2有p</p><p>​    递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设δ=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如图1所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_1_633579015612968750.gif" alt="img">图1 一维情形的分治法</p><p>我们注意到，如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;δ，则p3和q3两者与m的距离不超过δ，即|p3-m|&lt;δ，|q3-m|&lt;δ，也就是说，p3∈(m-δ,m]，q3∈(m,m+δ]。由于在S1中，每个长度为δ的半闭区间至多包含一个点（否则必有两点距离小于δ），并且m是S1和S2的分割点，因此(m-δ,m]中至多包含S中的一个点。同理，(m,m+δ]中也至多包含S中的一个点。由图1可以看出，如果(m-δ,m]中有S中的点，则此点就是S1中最大点。同理，如果(m,m+δ]中有S中的点，则此点就是S2中最小点。因此，我们用线性时间就能找到区间(m-δ,m]和(m,m+δ]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。也就是说，按这种分治策略，合并步可在O(n)时间内完成。这样是否就可以得到一个有效的算法了呢？还有一个问题需要认真考虑，即分割点m的选取，及S1和S2的划分。选取分割点m的一个基本要求是由此导出集合S的一个线性分割，即S=S1∪S2 ，S1∩S2=Φ，且S1{x|x≤m}；S2{x|x&gt;m}。容易看出，如果选取m=[max(S)+min(S)]/2，可以满足线性分割的要求。选取分割点后，再用O(n)时间即可将S划分成S1={x∈S|x≤m}和S2={x∈S|x&gt;m}。然而，这样选取分割点m，有可能造成划分出的子集S1和S2的不平衡。例如在最坏情况下，|S1|=1，|S2|=n-1，由此产生的分治法在最坏情况下所需的计算时间T(n)应满足递归方程:</p><p>T(n)=T(n-1)+O(n)</p><p>​    它的解是T(n)=O(n2)。这种效率降低的现象可以通过分治法中”平衡子问题”的方法加以解决。也就是说，我们可以通过适当选择分割点m，使S1和S2中有大致相等个数的点。自然地，我们会想到用S的n个点的坐标的中位数来作分割点。在选择算法中介绍的选取中位数的线性时间算法使我们可以在O(n)时间内确定一个平衡的分割点m。</p><p>​     至此，我们可以设计出一个求一维点集S中最接近点对的距离的算法CPAIR1如下。</p><p>function CPAIR1(S);</p><p>begin</p><p>if |S|=2</p><p>then δ=|x[2]-x[1]| // x[1..n]存放的是S中n个点的坐标</p><p>else if (|S|=1)</p><p>then δ:=∞</p><p>else</p><p>begin</p><p>m:=S中各点的坐标值的中位数;</p><p>构造S1和S2,使S1={x∈S|x≤m}，S2={x∈S|x&gt;m}; δ1:=CPAIRI(S1); δ2:=CPAIRI(S2);</p><p>p:=max(S1); q:=min(S2);</p><p>δ:=min(δ1,δ2,q-p);</p><p>end;</p><p>return(δ);</p><p>end;</p><p>由以上的分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程：</p><p>​     解此递归方程可得T(n)=O(nlogn)。</p><p>​    这个算法看上去比用排序加扫描的算法复杂，然而这个算法可以向二维推广。</p><p>​    下面我们来考虑二维的情形。此时S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。</p><p>​    递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min(δ1,δ1)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈P1，q∈P2，如图2所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_2.jpg" alt="img"></p><p>图2 距直线l的距离小于δ的所有点</p><p> 在一维的情形，距分割点距离为δ的2个区间(m-δ,m](m,m+δ]中最多各有S中一个点。因而这2点成为唯一的末检查过的最接近点对候选者。二维的情形则要复杂些，此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，如图3所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_3_633579015617343750.jpg" alt="img">图3 包含点q的δ×2δ的矩形R</p><p>​    由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。如图4(a)所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_4_633579015619375000.jpg" alt="img">图4 矩形R中点的稀疏性</p><p>​    若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个δ×2δ的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则</p><p>​     因此d(u,v)≤5δ/6&lt;δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。图4(b)是矩形R中含有S中的6个点的极端情形。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n2/4对候选者。这是否就意味着我们可以在O(n)时间内完成分治法的合并步骤呢？现在还不能作出这个结论，因为我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。</p><p>​    至此，我们可以给出用分治法求二维最接近点对的算法CPAIR2如下:</p><p>function CPAIR2(S);</p><p>begin</p><p>if |S|=2</p><p>then δ:=S中这2点的距离</p><p>else if |S|=0</p><p>then δ:=∞</p><p>else</p><p>begin</p><p>\1. m:=S中各点x坐标值的中位数; 构造S1和S2，使S1={p∈S|px≤m}和S2={p∈S|px&gt;m}</p><p>\2. δ1:=CPAIR2(S1);δ2:=CPAIR2(S2);</p><p>\3. δm:=min(δ1,δ2);</p><p>\4. 设P1是S1中距垂直分割线l的距离在δm之内的所有点组成的集合， P2是S2中距分割线l的距离在δm之内所有点组成的集合。将P1和P2中的点依其y坐标值从小到大排序，并设P1<em>和P2</em>是相应的已排好序的点列;</p><ol start="5"><li>通过扫描P1<em>以及对于P1</em>中每个点检查P2<em>中与其距离在δm之内的所有点(最多6个)可以完成合并。当P1</em>中的扫描指针逐次向上移动 时，P2*中的扫描指针可在宽为2δm的一个区间内移动。设δl是按 这种扫描方式找到的点对间的最小距离;</li></ol><p>\6. δ=min(δm,δl);</p><p>end;</p><p>return(δ);</p><p>end;</p><p>下面我们来分析一下算法CPAIR2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间，第3步和第6步用了常数时间，第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合我们的要求。因此，在这里我们要作一个技术上的处理。我们采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列为P<em>。在执行分治法的第4步时，只要对P</em>作一次线性扫描，即可抽取出我们所需要的排好序的点列P1<em>和P2</em>。然后，在第5步中再对P1*作一次线性扫描，即可求得δl。因此，第4步和第5步的两遍扫描合在一起只要用O(n)时间。这样一来，经过预排序处理后的算法CPAIR2所需的计算时间T(n)满足递归方程：</p><p>​    显而易见T(n)=O(nlogn)，预排序所需的计算时间为O(n1ogn)。因此，整个算法所需的计算时间为O(nlogn)。在渐近的意义下，此算法已是最优的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="分治" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="分治" scheme="http://qianyouyou.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后，如何快速搭建之前基于github的博客</title>
    <link href="http://qianyouyou.cn/2018/09/17/2018-09-17/"/>
    <id>http://qianyouyou.cn/2018/09/17/2018-09-17/</id>
    <published>2018-09-17T11:08:06.000Z</published>
    <updated>2018-09-18T08:18:56.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="声明：此文是针对于windows环境"><a href="#声明：此文是针对于windows环境" class="headerlink" title="声明：此文是针对于windows环境"></a>声明：此文是针对于windows环境</h3><p>前提：我需要说几个条件;</p><p>1.当初搭建博客时的ssh没有删除，如果删除那就再重新配置一个，配置方法参照我上一篇博客；</p><p>2.当初搭建博客的仓库没有删除，如果删除，那就再重新搭一个吧，剩下的教程几乎没有关系了</p><p>3.如果，当时搭建博客时，如果按照我的教程，或者说按照网上大多数教程，有建了一个文件夹（例如：git pages或者hexo），这个文件夹在重装系统后还有保留下来，那最好不过。</p><h4 id="先说第一种情况：如果那个文件夹在的情况下："><a href="#先说第一种情况：如果那个文件夹在的情况下：" class="headerlink" title="先说第一种情况：如果那个文件夹在的情况下："></a>先说第一种情况：如果那个文件夹在的情况下：</h4><p>不知道你们有没有按照其他的教程去配置静态页面，我按照那个方法有在github上新建了一个branch</p><p>那个gh-pages是我新建的branch，如果建了没关系</p><p>我们只需用点击master就好，回到原来的地方</p><p>然后再你原来的那个文件夹里打开git bash here</p><p>输入npm install hexo –save</p><p>然后可以试着输入hexo g 和hexo d</p><p>提示你需要重新配置邮箱和用户名，那么按照原来的邮箱和原来的用户名输入就好；</p><p>再次输入hexo g，如果有提示</p><p>就说明已经重新配置好了；</p><h4 id="如果没有保留当初在桌面配置的文件夹"><a href="#如果没有保留当初在桌面配置的文件夹" class="headerlink" title="如果没有保留当初在桌面配置的文件夹"></a>如果没有保留当初在桌面配置的文件夹</h4><p>首先先看看自己电脑上有没有ssh</p><p>在自己的一个盘里建一个文件夹，里面分别有三个文件夹（git，node，git pages）</p><p>分别在git和node里配置好git和node</p><p>然后再git pages里打开git bash here检查有没有ssh</p><p>cd ~/. ssh</p><p>如果有 No such file or directory</p><p>说明是第一次使用，那么按照上一篇博客配置，</p><p>如果提示有，那么你可以先试试这个ssh能用不，先别急着删；</p><p>按照刚刚的步骤再输入 npm install hexo –save</p><p>然后按照刚刚的步骤再来一次；</p><p>如果最后hexo d后，文章没有推上去，那么就说明没有成功，需要重新配置ssh</p><p>先删除原来的ssh<br>ssh-add -D<br>rm -r ~/.ssh</p><p>最好查看一下上一篇博客里，Deployment的config.yml文件里面的deploy值有没有改好（参照上一篇）</p><p>配置好了之后再按照刚刚的步骤再来一次（记得配置邮箱和用户名）</p><p>如果git bash在这儿没有起作用的话，</p><p>那么win+r打开cmd，安装一个类似刚刚操作的扩展</p><p>输入 npm install hexo-deployer-git –save</p><p>然后再输入</p><p>hexo g<br>hexo d</p><p>然后再进入自己的博客页面查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;声明：此文是针对于windows环境&quot;&gt;&lt;a href=&quot;#声明：此文是针对于windows环境&quot; class=&quot;headerlink&quot; title=&quot;声明：此文是针对于windows环境&quot;&gt;&lt;/a&gt;声明：此文是针对于windows环境&lt;/h3&gt;&lt;p&gt;前提：我需要
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>数论小问题</title>
    <link href="http://qianyouyou.cn/2018/09/16/2018-09-16/"/>
    <id>http://qianyouyou.cn/2018/09/16/2018-09-16/</id>
    <published>2018-09-16T08:23:17.000Z</published>
    <updated>2018-09-18T08:34:32.904Z</updated>
    
    <content type="html"><![CDATA[<p>输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？</p><p>答案：n = min( n*(n+1)/2&gt;=x+y )</p><p>当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状的管子，往里面灌水，x代表一定容量的水，y代表一定容量的水，然后管子每升高1个高度就会多1个容量，最终刚好为n<em>(n+1)/2或n</em>(n+1)/2+1，n<em>(n+1)/2即x+y=n</em>(n+1)/2，否则为n*(n+1)/2+1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？&lt;/p&gt;
&lt;p&gt;答案：n = min( n*(n+1)/2&amp;gt;=x+y )&lt;/p&gt;
&lt;p&gt;当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>质因数分解原创算法</title>
    <link href="http://qianyouyou.cn/2018/09/13/2018-09-13/"/>
    <id>http://qianyouyou.cn/2018/09/13/2018-09-13/</id>
    <published>2018-09-13T10:54:41.000Z</published>
    <updated>2018-09-18T08:18:21.764Z</updated>
    
    <content type="html"><![CDATA[<p>由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Prime()&#123;</span><br><span class="line">memset(tag,0,sizeof(tag));</span><br><span class="line">int cnt=0;</span><br><span class="line">for(int i = 2; i&lt;N; i++)&#123;</span><br><span class="line">if(tag[i])</span><br><span class="line">prime[cnt++]=i;</span><br><span class="line">for(int j=0;j&lt;cnt &amp;&amp; prime[j]*i&lt;N; j++)&#123;</span><br><span class="line">tag[i*prime[j]] = i;</span><br><span class="line">if(i % prime[j]==0)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打表时表中储存为该数最小质数，这样给一个数只需除以对应表中数，直到除到最后为1为止</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>路径规划总结之A*搜索</title>
    <link href="http://qianyouyou.cn/2018/09/10/2018-09-10/"/>
    <id>http://qianyouyou.cn/2018/09/10/2018-09-10/</id>
    <published>2018-09-10T12:59:37.000Z</published>
    <updated>2018-09-10T13:39:49.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h2><p>路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。机器人的路径规划应用场景极丰富，最常见如游戏中NPC及控制角色的位置移动，百度地图等导航问题，小到家庭扫地机器人、无人机大到各公司正争相开拓的无人驾驶汽车等。</p><p>目前路径规划算法分为：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-09-10-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png" alt=""></p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>首先，我们来看看<code>A*</code>算法的定义：<code>A*</code>（A-Star)算法是一种静态路网中求解最短路径最有效的<strong>直接</strong>搜索方法，也是解决许多搜索问题的有效算法。 采用广度优先搜索策略，在搜索过程中使用启发函数，即有大致方向的向前进虽然目标有时候不是很明确。 </p><p>在计算机科学中，A*算法作为Dijkstra算法的扩展，因其高效性而被广泛应用于寻路及图的遍历，如星际争霸等游戏中就大量使用。在理解算法前，我们需要知道几个概念：</p><ul><li>搜索区域（The Search Area）：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。　　</li><li>开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。</li><li>父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针。</li><li>路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销。</li><li>启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和。</li></ul><p>可能看定义不是很好理解，那么我们根据例子具体看看什么是A*算法吧。</p><p>详细讲解参考：</p><p><a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin" target="_blank" rel="noopener">启发式算法</a></p><p><a href="https://www.cnblogs.com/zhoug2020/p/3468167.html" target="_blank" rel="noopener">A*算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路径规划&quot;&gt;&lt;a href=&quot;#路径规划&quot; class=&quot;headerlink&quot; title=&quot;路径规划&quot;&gt;&lt;/a&gt;路径规划&lt;/h2&gt;&lt;p&gt;路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ACM-ICPC 2018 徐州赛区网络预赛</title>
    <link href="http://qianyouyou.cn/2018/09/09/2018-09-09/"/>
    <id>http://qianyouyou.cn/2018/09/09/2018-09-09/</id>
    <published>2018-09-09T14:04:18.000Z</published>
    <updated>2018-09-09T14:20:13.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Characters-with-Hash"><a href="#Characters-with-Hash" class="headerlink" title="Characters with Hash"></a>Characters with Hash</h2><p><a href="https://wenda.jisuanke.com/nanti/31461" target="_blank" rel="noopener">问答</a></p><ul><li>26.45%</li><li>1000ms</li><li>262144K</li></ul><p>Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”.</p><p>It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line a integer TT , the number of test cases (T \le 10)(T≤10).</p><p>For each test case:</p><p>First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000).</p><p>Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single number which gives the answer.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 z</span><br><span class="line">oMl</span><br><span class="line">6 Y</span><br><span class="line">YJSNPI</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char str[1000007],ch[2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%s%s&quot;,&amp;n,ch,str);</span><br><span class="line">        int ans = 2*n;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(str[i]==ch[0])</span><br><span class="line">                ans-=2;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(abs(str[i]-ch[0])&lt;10)</span><br><span class="line">                    ans-=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans==0)</span><br><span class="line">            ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Characters-with-Hash&quot;&gt;&lt;a href=&quot;#Characters-with-Hash&quot; class=&quot;headerlink&quot; title=&quot;Characters with Hash&quot;&gt;&lt;/a&gt;Characters with Hash&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛K题-Supreme Number</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08-1/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08-1/</id>
    <published>2018-09-08T14:28:16.000Z</published>
    <updated>2018-09-09T14:03:30.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Supreme-Number"><a href="#Supreme-Number" class="headerlink" title="Supreme Number"></a>Supreme Number</h3><p><a href="https://wenda.jisuanke.com/nanti/31452" target="_blank" rel="noopener">问答</a></p><ul><li>26.7%</li><li>1000ms</li><li>131072K</li></ul><p>A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers.</p><p>Now lets define a number NN as the <strong>supreme number</strong> if and only if each number made up of an non-empty <strong>subsequence</strong> of all the numeric digits of NN must be either a prime number or 11.</p><p>For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number.</p><p>Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal <em>supreme number</em> that does not exceed NN?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases.</p><p>In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case print <code>&quot;Case #x: y&quot;</code>, in which xx is the order number of the test case and yy is the answer.</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 5</span><br><span class="line">Case #2: 73</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;</span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    char ch=&apos; &apos;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ans&lt;100000)</span><br><span class="line">        ans=ans*10+ch-&apos;0&apos;;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int aaa=1;aaa&lt;=t;aaa++)&#123;</span><br><span class="line">        int ans = read();</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for(i = 0;i&lt;19;i++)&#123;</span><br><span class="line">            if(pri[i]&gt;ans)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==19)</span><br><span class="line">            cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000000</span><br><span class="line">int h=0;</span><br><span class="line">bool p[N];</span><br><span class="line">int prime[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    if(p[x]==false)</span><br><span class="line">        return false;</span><br><span class="line">    int c = 1;</span><br><span class="line">    while(c&lt;x)&#123;</span><br><span class="line">        c*=10;</span><br><span class="line">        if(p[x%c]==false)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        if(c&gt;x)</span><br><span class="line">            break;</span><br><span class="line">        int tmp = x;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(p[tmp]==false)</span><br><span class="line">                return false;</span><br><span class="line">            if(p[tmp%c]==false)</span><br><span class="line">                return false;</span><br><span class="line">            tmp/=c;</span><br><span class="line">            if(!tmp)</span><br><span class="line">                break;</span><br><span class="line">            if(dfs(tmp)==false)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void db()</span><br><span class="line">&#123;</span><br><span class="line">memset(p,true,sizeof(p));</span><br><span class="line">p[0] = false;</span><br><span class="line">for(int i=2;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[i]==false)</span><br><span class="line">            continue;</span><br><span class="line">for(int j=2;i*j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line">p[i*j]=false;</span><br><span class="line">&#125;</span><br><span class="line">if(!dfs(i))</span><br><span class="line">            p[i] = false;</span><br><span class="line">        if(p[i]==true)</span><br><span class="line">&#123;</span><br><span class="line">prime[h++]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">db();</span><br><span class="line">int n;  //打印前n个质数</span><br><span class="line">for(int i=0;i&lt;=h;i++)</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Supreme-Number&quot;&gt;&lt;a href=&quot;#Supreme-Number&quot; class=&quot;headerlink&quot; title=&quot;Supreme Number&quot;&gt;&lt;/a&gt;Supreme Number&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛D题-A*模板题</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08/</id>
    <published>2018-09-08T13:28:16.000Z</published>
    <updated>2018-09-09T14:03:51.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Made-In-Heaven"><a href="#Made-In-Heaven" class="headerlink" title="Made In Heaven"></a>Made In Heaven</h2><p><a href="https://wenda.jisuanke.com/nanti/31445" target="_blank" rel="noopener">问答</a></p><ul><li>14.67%</li><li>1000ms</li><li>131072K</li></ul><p>One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry.</p><p>JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are at most 5050 test cases.</p><p>The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN.</p><p>The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ).</p><p>Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW.</p><p>It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist.</p><p>All the test cases are generated randomly.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>One line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output <code>&quot;yareyaredawa&quot;</code> (without quote), else output <code>&quot;Whitesnake!&quot;</code> (without quote).</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 2 14</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yareyaredawa</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“<code>Whitesnake!</code>”，否则输出“<code>yareyaredawa</code>”</p><p>类似<a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ2449</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>A*+SPFA</p><h4 id="A-算法："><a href="#A-算法：" class="headerlink" title="A*算法："></a>A*算法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A*，启发式搜索，是一种较为有效的搜索方法。</span><br><span class="line">我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。</span><br><span class="line">我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。</span><br><span class="line">所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。</span><br></pre></td></tr></table></figure><h4 id="估价函数："><a href="#估价函数：" class="headerlink" title="估价函数："></a>估价函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。</span><br><span class="line">在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。</span><br><span class="line"></span><br><span class="line">估价函数需要满足：</span><br><span class="line">　　设当前状态state到目标函数所需代价的估计值为f(state)</span><br><span class="line">　　设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state)</span><br><span class="line">　　对于任意的state，应该有f(state)&lt;=g(state)</span><br><span class="line">也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。</span><br></pre></td></tr></table></figure><h4 id="第K短路："><a href="#第K短路：" class="headerlink" title="第K短路："></a>第K短路：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。</span><br><span class="line">实现过程：</span><br><span class="line">1.预处理f(x)，在反向图上以T为起点求到每个点的最短路</span><br><span class="line">2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问</span><br><span class="line">3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中</span><br><span class="line">4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路</span><br><span class="line"></span><br><span class="line">因为估价函数的作用，图中很多节点访问次数远小于K</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll x,y,z,s,t,k;</span><br><span class="line">    ll T;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T;</span><br><span class="line">        prepare();</span><br><span class="line">        for(ll i=1;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            add_edge(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(t);</span><br><span class="line">        ll ans=a_star(s,t,k);</span><br><span class="line">        if(ans&lt;=T&amp;&amp;ans!=-1)</span><br><span class="line">            cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k短路模板"><a href="#k短路模板" class="headerlink" title="k短路模板"></a>k短路模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Made-In-Heaven&quot;&gt;&lt;a href=&quot;#Made-In-Heaven&quot; class=&quot;headerlink&quot; title=&quot;Made In Heaven&quot;&gt;&lt;/a&gt;Made In Heaven&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/A-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
      <category term="k短路" scheme="http://qianyouyou.cn/tags/k%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
</feed>
