<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-05-08T15:11:31.780Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[博弈论]博弈论基本题型及5大常见博弈论原理</title>
    <link href="http://qianyouyou.cn/2018/05/08/2018-05-08/"/>
    <id>http://qianyouyou.cn/2018/05/08/2018-05-08/</id>
    <published>2018-05-08T14:20:44.000Z</published>
    <updated>2018-05-08T15:11:31.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><h3 id="巴什博奕（Bash-Game）"><a href="#巴什博奕（Bash-Game）" class="headerlink" title="巴什博奕（Bash Game）"></a>巴什博奕（Bash Game）</h3><p>有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。</p><p>假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。</p><p>胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int iCase;</span><br><span class="line">cin &gt;&gt; iCase;</span><br><span class="line">while (iCase--) &#123;</span><br><span class="line">int n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="威佐夫博奕（Wythoff-Game）"><a href="#威佐夫博奕（Wythoff-Game）" class="headerlink" title="威佐夫博奕（Wythoff Game）"></a>威佐夫博奕（Wythoff Game）</h3><p>有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p><p>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 </p><p> 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有 如下三条性质：</p><p>1。任何自然数都包含在一个且仅有一个奇异局势中。</p><p>2。任意操作都可将奇异局势变为非奇异局势。</p><p>3。采用适当的方法，可以将非奇异局势变为奇异局势。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;math.h&gt; </span><br><span class="line">const double ep1 = (sqrt(5.0) - 1.0) / 2.0;</span><br><span class="line">const double ep2 = (sqrt(5.0) + 1.0) / 2.0;</span><br><span class="line">int main() &#123;</span><br><span class="line">int m, n;</span><br><span class="line">while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123;</span><br><span class="line">if (m &gt; n) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">tmp = m, m = n, n = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int id = m * ep1;</span><br><span class="line">int tmp1 = ep2 * id, tmp2 = id + tmp1;</span><br><span class="line">int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3;</span><br><span class="line">if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;);</span><br><span class="line">else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;);</span><br><span class="line">else printf(&quot;1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契博弈（Fibonacci-Nim）"><a href="#斐波那契博弈（Fibonacci-Nim）" class="headerlink" title="斐波那契博弈（Fibonacci Nim）"></a>斐波那契博弈（Fibonacci Nim）</h3><p>有一堆个数为 n 的石子，游戏双方轮流取石子，满足</p><p>1)先手不能在第一次把所有的石子取完； </p><p>2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。</p><p>约定取走最后一个石子的人为赢家，求必败态。</p><p>这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 </p><p>胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 </p><p>证明：</p><p>这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 </p><p> FIB 数列的必败证明：</p><p>1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 </p><p>2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">long long int f[50];</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, i;</span><br><span class="line">f[0] = f[1] = 1;</span><br><span class="line">for (i = 2; i &lt; 50; i++) &#123;</span><br><span class="line">f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">if (n == 0) break;</span><br><span class="line">for (i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">if (f[i] == n) break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K倍博弈"><a href="#K倍博弈" class="headerlink" title="K倍博弈"></a>K倍博弈</h3><p>共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。</p><p>当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1.然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 </p><p>当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。</p><p>当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。</p><p>设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2000000;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k;</span><br><span class="line">int cas = 0, cass;</span><br><span class="line">for (scanf(&quot;%d&quot;, &amp;cass); cass--;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">++cas;</span><br><span class="line">printf(&quot;Case %d: &quot;, cas);</span><br><span class="line">int i = 0, j = 0;</span><br><span class="line">a[0] = b[0] = 1;</span><br><span class="line">while (a[i]&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">a[i] = b[i - 1] + 1;</span><br><span class="line">while (a[j + 1] * k&lt;a[i])</span><br><span class="line">j++;</span><br><span class="line">if (a[j] * k&lt;a[i])</span><br><span class="line">b[i] = a[i] + b[j];</span><br><span class="line">else</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">if (a[i] == n)</span><br><span class="line">puts(&quot;lose&quot;);</span><br><span class="line">else puts(&quot;win&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SG函数的求解-SG博弈）"><a href="#SG函数的求解-SG博弈）" class="headerlink" title="ＳＧ函数的求解(SG博弈）"></a>ＳＧ函数的求解(SG博弈）</h3><p>给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移 动者判负。</p><p>这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int iCase;</span><br><span class="line">cin &gt;&gt; iCase;</span><br><span class="line">while (iCase--) &#123;</span><br><span class="line">int n, cnt = 0, num;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">if (num % 4 == 0) num--;</span><br><span class="line">else if (num % 4 == 3) num++;</span><br><span class="line">cnt ^= num;</span><br><span class="line">&#125;</span><br><span class="line">if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找必败态"><a href="#寻找必败态" class="headerlink" title="寻找必败态"></a>寻找必败态</h2><p>必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。</p><p>必败态和胜态有着如下性质： </p><p>1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 </p><p>2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 </p><p>3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 </p><p>这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;取石子游戏&quot;&gt;&lt;a href=&quot;#取石子游戏&quot; class=&quot;headerlink&quot; title=&quot;取石子游戏&quot;&gt;&lt;/a&gt;取石子游戏&lt;/h2&gt;&lt;h3 id=&quot;巴什博奕（Bash-Game）&quot;&gt;&lt;a href=&quot;#巴什博奕（Bash-Game）&quot; class=&quot;he
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[数论]数论与组合数学中的常用算法总结</title>
    <link href="http://qianyouyou.cn/2018/05/07/2018-05-07/"/>
    <id>http://qianyouyou.cn/2018/05/07/2018-05-07/</id>
    <published>2018-05-07T10:08:16.000Z</published>
    <updated>2018-05-08T14:15:54.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="欧几里得算法（gcd）"><a href="#欧几里得算法（gcd）" class="headerlink" title="欧几里得算法（gcd）"></a>欧几里得算法（gcd）</h3><p>欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b)</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b)</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">return b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">//非递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">if (!a)</span><br><span class="line">return b;</span><br><span class="line">while (b) &#123;</span><br><span class="line">int temp = b;</span><br><span class="line">b = a%b;</span><br><span class="line">a = temp;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h3><p>若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb<br>对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1<em>a+0</em>b,因为 gcd(a,b)=gcd(b,a%b)则有 x<em>a+y</em>b=x1<em>b+y1</em>(a%b) 。将等式右边变形，b<em>x1+(a%b)</em>y1=b<em>x1+(a-(a/b)</em>b)<em>y1=a</em>y1+b<em>(x1-(a/b)</em>y1)<br>则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)<em>t,y-y0-a/gcd(a,b)</em>t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int exgcd(int a, int b, int &amp;x, int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">if (b == 0)</span><br><span class="line">&#123;</span><br><span class="line">x = 1;</span><br><span class="line">y = 0;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int d = exgcd(b, a%b, x, y);</span><br><span class="line">int t = x;</span><br><span class="line">x = y;</span><br><span class="line">y = t - a / b*y;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><p>筛素数的基本方法是用来筛选出一定范围内的素数</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool isprime[N];//N 表示范围</span><br><span class="line">int prime[N], cnt;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">cnt = 0;</span><br><span class="line">memset(isprime, true, sizeof(isprime));</span><br><span class="line">isprime[1] = false;</span><br><span class="line">for (i = 2; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (isprime[i])</span><br><span class="line">&#123;</span><br><span class="line">prime[cnt++] = i;//记录素数</span><br><span class="line">for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了</span><br><span class="line">isprime[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0<em>a2^1</em>a2^3，也就是a1 <em> a2 </em> a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int poww(int a, int b) &#123;</span><br><span class="line">    int ans = 1, base = a;</span><br><span class="line">    while (b != 0) &#123;</span><br><span class="line">        if (b &amp; 1 != 0)</span><br><span class="line">            ans *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)<em>a^(2^1)</em>a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。</p><p>　　其中要理解base <em> =base这一步：因为 base </em> base==base2，下一步再乘，就是base2 <em> base2==base4，然后同理  base4 </em> base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1<em>a2</em>a8，这三项就可以完美解决了</p><h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p><strong>矩阵乘法</strong></p><p>简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C</p><p><strong><img src="http://p7woygi8q.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="img"></strong></p><p>其中c[i][j]为A的第i行与B的第j列对应乘积的和，即:<img src="http://p7woygi8q.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int N=100;  </span><br><span class="line">int c[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(c,0,sizeof c);  </span><br><span class="line">    for(int i=1;i&lt;=n;i++)  </span><br><span class="line">        for(int j=1;j&lt;=n;j++)  </span><br><span class="line">        for(int k=1;k&lt;=n;k++)  </span><br><span class="line">        c[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放一个求斐波那契数列的矩阵快速幂模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 10000;</span><br><span class="line">const int maxn = 35;</span><br><span class="line">int N;</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    int mat[maxn][maxn];</span><br><span class="line">    int x, y;</span><br><span class="line">    Matrix() &#123;</span><br><span class="line">        memset(mat, 0, sizeof(mat));</span><br><span class="line">        for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123;</span><br><span class="line">    memset(c.mat, 0, sizeof(c.mat));</span><br><span class="line">    c.x = a.x; c.y = b.y;</span><br><span class="line">    for (int i = 1; i &lt;= c.x; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= c.y; j++) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= a.y; k++) &#123;</span><br><span class="line">                c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod;</span><br><span class="line">                c.mat[i][j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">inline void mat_pow(Matrix &amp;a, int z) &#123;</span><br><span class="line">    Matrix ans, base = a;</span><br><span class="line">    ans.x = a.x; ans.y = a.y;</span><br><span class="line">    while (z) &#123;</span><br><span class="line">        if (z &amp; 1 == 1) mat_mul(ans, base, ans);</span><br><span class="line">        mat_mul(base, base, base);</span><br><span class="line">        z &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    a = ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        switch (N) &#123;</span><br><span class="line">            case -1: return 0;</span><br><span class="line">            case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Matrix A, B;</span><br><span class="line">        A.x = 2; A.y = 2;</span><br><span class="line">        A.mat[1][1] = 1; A.mat[1][2] = 1;</span><br><span class="line">        A.mat[2][1] = 1; A.mat[2][2] = 0;</span><br><span class="line">        B.x = 2; B.y = 1;</span><br><span class="line">        B.mat[1][1] = 1; B.mat[2][1] = 1;</span><br><span class="line">        mat_pow(A, N - 1);</span><br><span class="line">        mat_mul(A, B, B);</span><br><span class="line">        cout &lt;&lt; B.mat[1][1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。</p><p>设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n <em> sum(1-1/pi)/</em>pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><h4 id="基本的模运算"><a href="#基本的模运算" class="headerlink" title="基本的模运算"></a>基本的模运算</h4><p>(a + b)mod n=((a mod n) + (b mod n))mod n;</p><p>(a - b)mod n=((a mod n) - (b mod n))mod n;</p><p>(a <em> b)mod n=((a mod n) </em> (b mod n))mod n;</p><h3 id="数论4大定理"><a href="#数论4大定理" class="headerlink" title="数论4大定理"></a>数论4大定理</h3><h4 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h4><p>若p为质数，则p可整除(p-1)!+1。</p><h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)</p><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。</p><p>于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n），</p><p>所以a^φ(n) ≡ 1 (mod n)。</p><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。</p><p>若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。</p><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a><strong>证明</strong></h5><p>因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。</p><h4 id="孙子定理（中国剩余定理）"><a href="#孙子定理（中国剩余定理）" class="headerlink" title="孙子定理（中国剩余定理）"></a>孙子定理（中国剩余定理）</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt=""></p><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。</p><p>要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。</p><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><h4 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h4><p>加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。</p><p>分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏）</p><h4 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h4><p>乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。</p><p>合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 </p><p>组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) </p><p>其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。</p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|<br>这个定理，常称作包含排斥原理，也就是容斥原理。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86.png" alt=""></p><p>对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数论&quot;&gt;&lt;a href=&quot;#数论&quot; class=&quot;headerlink&quot; title=&quot;数论&quot;&gt;&lt;/a&gt;数论&lt;/h2&gt;&lt;h3 id=&quot;欧几里得算法（gcd）&quot;&gt;&lt;a href=&quot;#欧几里得算法（gcd）&quot; class=&quot;headerlink&quot; title=&quot;欧几里
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高斯消元" scheme="http://qianyouyou.cn/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>[图论]最短路三大算法——Dijkstra算法，Bellman-ford，floyed</title>
    <link href="http://qianyouyou.cn/2018/05/06/2018-05-06-1/"/>
    <id>http://qianyouyou.cn/2018/05/06/2018-05-06-1/</id>
    <published>2018-05-06T14:35:34.000Z</published>
    <updated>2018-05-07T10:10:35.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法（单源最短路径）"><a href="#Dijkstra算法（单源最短路径）" class="headerlink" title="Dijkstra算法（单源最短路径）"></a>Dijkstra算法（单源最短路径）</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。</li><li>从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。</li><li>重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">const int maxn=1200;</span><br><span class="line"></span><br><span class="line">int dist[maxn],g[maxn][maxn],N;</span><br><span class="line">bool vis[maxn];</span><br><span class="line"></span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">        dist[i]=(i==1)?0:INF;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mark=-1,mindis=INF;</span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[j]&amp;&amp;dist[j]&lt;mindis)</span><br><span class="line">            &#123;</span><br><span class="line">                mindis=dist[j];</span><br><span class="line">                mark=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[mark]=1;</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=min(dist[j],dist[mark]+g[mark][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-ford（单元最短路径，可带负环）"><a href="#Bellman-ford（单元最短路径，可带负环）" class="headerlink" title="Bellman-ford（单元最短路径，可带负环）"></a>Bellman-ford（单元最短路径，可带负环）</h2><p>为了能够求解边上带有负值的单源最短路径问题，Bellman(贝尔曼，动态规划提出者)和Ford(福特)提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度的方法。Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellman-ford算法有一个小优化：每次松弛先设一个flag，初值为FALSE，若有边更新则赋值为TRUE，最终如果还是FALSE则直接成功退出。Bellman-ford算法浪费了许多时间做无必要的松弛，所以SPFA算法用队列进行了优化，效果十分显著，高效难以想象。SPFA还有SLF，LLL，滚动数组等优化。</p><p>递推公式(求顶点u到源点v的最短路径)：<br>$$<br>dist 1 [u] = Edge[v][u]<br>$$</p><p>$$<br>dist k [u] = min{ dist k-1 [u], min{ dist k-1 [j] + Edge[j][u] } }, j=0,1,…,n-1,j≠u<br>$$</p><p>Dijkstra算法和Bellman算法思想有很大的区别：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改  的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>单源最短路径(从源点s到其它所有顶点v)</li><li>有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图)</li><li>边权可正可负(如有负权回路输出错误提示)</li><li>差分约束系统(至今貌似只看过一道题)</li></ul><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ol><li>初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0</li><li>迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次，看下面的描述性证明(当做树)）</li><li>检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在d[v]中</li></ol><p>Bellman-Ford算法是否一定要循环n-1次么？未必！其实只要在某次循环过程中，考虑每条边后，都没能改变当前源点到所有顶点的最短路径长度，那么Bellman-Ford算法就可以提前结束了(开篇提出的小优化就是这个)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bool Bellman_Ford()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= nodenum; ++i) //初始化</span><br><span class="line"></span><br><span class="line">    dis[i] = (i == original ? 0 : MAX);</span><br><span class="line"></span><br><span class="line">  for(int i = 1; i &lt;= nodenum - 1; ++i)</span><br><span class="line"></span><br><span class="line">    for(int j = 1; j &lt;= edgenum; ++j)</span><br><span class="line"></span><br><span class="line">      if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost) //松弛（顺序一定不能反~）</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;</span><br><span class="line"></span><br><span class="line">        pre[edge[j].v] = edge[j].u;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bool flag = 1; //判断是否含有负权回路</span><br><span class="line"></span><br><span class="line">      for(int i = 1; i &lt;= edgenum; ++i)</span><br><span class="line"></span><br><span class="line">        if(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          flag = 0;</span><br><span class="line"></span><br><span class="line">          break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floyed（全源最短路径）"><a href="#floyed（全源最短路径）" class="headerlink" title="floyed（全源最短路径）"></a>floyed（全源最短路径）</h2><p>Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int k=0; k&lt;n; ++k)</span><br><span class="line">  for (int i=0; i&lt;n; ++i)</span><br><span class="line">    for (int j=0; j&lt;n; ++j)</span><br><span class="line">            /*</span><br><span class="line">            实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j]</span><br><span class="line">            都不是Inf ，只要一个是Inf，那么就肯定不必更新。 </span><br><span class="line">            */</span><br><span class="line">      if (dist[i][k] + dist[k][j] &lt; dist[i][j] )</span><br><span class="line">        dist[i][j] = dist[i][k] + dist[k][j];</span><br></pre></td></tr></table></figure><p>Floyd算法另一种理解DP，为理论爱好者准备的，上面这个形式的算法其实是Floyd算法的精简版，而真正的Floyd算法是一种基于DP(Dynamic Programming)的最短路径算法。设图G中n 个顶点的编号为1到n。令c [i, j, k]表示从i 到j 的最短路径的长度，其中k 表示该路径中的最大顶点，也就是说c[i,j,k]这条最短路径所通过的中间顶点最大不超过k。因此，如果G中包含边&lt;i, j&gt;，则c[i, j, 0] =边&lt;i, j&gt; 的长度；若i= j ，则c[i,j,0]=0；如果G中不包含边&lt;i, j&gt;，则c (i, j, 0)= +∞。c[i, j, n] 则是从i 到j 的最短路径的长度。对于任意的k&gt;0，通过分析可以得到：中间顶点不超过k 的i 到j 的最短路径有两种可能：该路径含或不含中间顶点k。若不含，则该路径长度应为c[i, j, k-1]，否则长度为 c[i, k, k-1] +c [k, j, k-1]。c[i, j, k]可取两者中的最小值。状态转移方程：c[i, j, k]=min{c[i, j, k-1], c [i, k, k-1]+c [k, j, k-1]}，k＞0。这样，问题便具有了最优子结构性质，可以用动态规划方法来求解。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/U%29M71YPUFV4WE17DG%5B%28X$$K.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dijkstra算法（单源最短路径）&quot;&gt;&lt;a href=&quot;#Dijkstra算法（单源最短路径）&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra算法（单源最短路径）&quot;&gt;&lt;/a&gt;Dijkstra算法（单源最短路径）&lt;/h2&gt;&lt;h3 id=&quot;步
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Dijkstra算法" scheme="http://qianyouyou.cn/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[图论]二分图匹配基本算法之KM算法解析</title>
    <link href="http://qianyouyou.cn/2018/05/06/2018-05-06/"/>
    <id>http://qianyouyou.cn/2018/05/06/2018-05-06/</id>
    <published>2018-05-06T12:57:15.000Z</published>
    <updated>2018-05-07T10:10:19.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最佳匹配"><a href="#最佳匹配" class="headerlink" title="最佳匹配"></a>最佳匹配</h2><p>如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。</p><p>如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，或者Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。</p><p><strong>带权</strong>二分图的<strong>权值最大</strong>的<strong>完备匹配</strong>称为最佳匹配。二分图的最佳匹配不一定是二分图的最大权匹配。 可以添加一些权值为0的边，使得最佳匹配和最大权匹配统一起来。 如图所示：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/a.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/b.png" alt=""></p><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。</p><p>1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。</p><p>2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。</p><p>3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。</p><h3 id="相等子图"><a href="#相等子图" class="headerlink" title="相等子图"></a>相等子图</h3><p>因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。</p><h3 id="相等子图性质"><a href="#相等子图性质" class="headerlink" title="相等子图性质"></a>相等子图性质</h3><ol><li>在任意时刻，相等子图上的最大权匹配一定小于等于相等子图的顶标和。</li><li>在任意时刻，相等子图的顶标和即为所有顶点的顶标和。</li><li>扩充相等子图后，相等子图的顶标和将会减小。</li><li>当相等子图的最大匹配为原图的完备匹配时，匹配边的权值和等于所有顶点的顶标和，此匹配即为最佳匹配。</li></ol><h3 id="演示过程"><a href="#演示过程" class="headerlink" title="演示过程"></a>演示过程</h3><p>1.如图所示，1与a匹配权值为3，与c为4。2与a权值为2，与b权值为1，与c权值为3。3与c权值为5。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/1.png" alt=""></p><p>2.首先对每个顶点赋值，将左边的顶点赋值为<strong>最大权重</strong>，右边的顶点赋值为0。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2.png" alt=""></p><p>3.进行匹配，我们匹配的原则是：只与权重相同的边匹配，若是找不到边匹配，对此条路径的所有左边顶点-1，右边顶点+1，再进行匹配，若还是匹配不到，重复+1和-1操作。对1进行匹配，符合匹配条件的边只有1-c边。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/3.png" alt=""></p><p>4.接着对2匹配，顶点2值为3，2-c边权重为3，但是，1已经匹配c了，发生了冲突，我们这时候第一时间应该想到的是，让2换个工作，但根据匹配原则，只有2-c边 3+0=0 满足要求，于是2不能换边了，那1能不能换边呢？对1来说，也是只有1-c边满足4+0=4的要求，于是1也不能换边，走投无路了，怎么办？</p><p><img src="http://p7woygi8q.bkt.clouddn.com/4.png" alt=""></p><p>5.从常识的角度思考：其实我们寻找<strong>最优匹配</strong>的过程，也就是<strong>帮每个X顶点找到他们权值最高的Y顶点</strong>，但是，有些顶点会冲突，比如现在，1，2和c的权值都是最高，这时我们应该让1或者3换顶点，但是这时候换的话我们只能换到降低权值的Y顶点，也就是说，如果令R=左边顶点所有值相加，若发生了冲突，则最终权值一定小于R，但是，我们现在只要求最优匹配，所以，如果1换顶点降低的权值比较少的话，<strong>我们是能接受的</strong>（对2同样如此）。</p><p>在KM算法中如何体现呢？</p><p>现在参与到这个冲突的顶点是1,2和c，令所有左边顶点值-1，右边顶点值+1，即 1-1,2-1. c+1。</p><p>我们进行了上述操作后会发现，若是左边有n个顶点参与运算，则右边就有n-1个顶点参与运算，整体效率值下降了1*（n-（n-1））=1，而对于1来说，1-c本来为可匹配的边，现在仍为可匹配边（3+1=4），对于2来说，2-c本来为可匹配的边，现在仍为可匹配的边（2+1=4），我们通过上述操作，为1增加了一条可匹配的边1-a，为B增加了一条可匹配的边2-a。</p><p>现在我们再来匹配，对2来说，2-a边 2+0=2，满足条件，所以2换边，a现在为未匹配状态，2-a匹配！</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5.png" alt=""></p><p>6.我们现在匹配最后一条边3，3-c 5+1！=5，3边无边能匹配，所以3-1。现在3-c边 4+1=5，可以匹配，但是c已匹配了，发生冲突，3此时不能换边，于是便去找1，对于1来说，1-a此时也为可匹配边，但是a已匹配，1又去找2。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/6.png" alt=""></p><p>7.2现在无边可以匹配了，2+0！=1 ，现在的路径是3→c→1→a→2，所以1-1,2-1,3-1,a+1，c+1。如下图所示。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/7.png" alt=""></p><p>8.对于2来说，现在2-b 1+0=1 可匹配！使用匈牙利算法，对此条路径上的边取反。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/8.png" alt=""></p><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int s) //匈牙利算法找增广路径</span><br><span class="line">&#123;</span><br><span class="line">    visx[s]=1;</span><br><span class="line">    for(int i=1;i&lt;=cnty;i++) </span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t=wx[s]+wy[i]-dis[s][i];</span><br><span class="line">            if(t==0) &#123;</span><br><span class="line">                visy[i]=1;</span><br><span class="line">                if(linky[i]==0||dfs(linky[i]))&#123;</span><br><span class="line">                    linkx[s]=i,linky[i]=s;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t&gt;0)  //找出边权与顶标和的最小的差值</span><br><span class="line">            &#123;</span><br><span class="line">                if(t&lt;minz)minz=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">void km()</span><br><span class="line">&#123;</span><br><span class="line">    memset(linkx,0,sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(linky,0,sizeof linky);</span><br><span class="line">    for(int i=1;i&lt;=cntx;i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minz=INF;</span><br><span class="line">            memset(visx,0,sizeof visx);</span><br><span class="line">            memset(visy,0,sizeof visy);</span><br><span class="line">            if(dfs(i))break;</span><br><span class="line">            for(int j=1;j&lt;=cntx;j++)  //将交错树中X部的点的顶标减去minz</span><br><span class="line">            if(visx[j])wx[j]-=minz;</span><br><span class="line">            for(int j=1;j&lt;=cnty;j++) //将交错树中Y部的点的顶标加上minz</span><br><span class="line">            if(visy[j])wy[j]+=minz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最佳匹配&quot;&gt;&lt;a href=&quot;#最佳匹配&quot; class=&quot;headerlink&quot; title=&quot;最佳匹配&quot;&gt;&lt;/a&gt;最佳匹配&lt;/h2&gt;&lt;p&gt;如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。&lt;/p&gt;
&lt;p&gt;如果一个二分
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图匹配" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
      <category term="KM算法" scheme="http://qianyouyou.cn/tags/KM%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[图论]二分图匹配基本算法之匈牙利算法解析</title>
    <link href="http://qianyouyou.cn/2018/05/05/2018-05-05/"/>
    <id>http://qianyouyou.cn/2018/05/05/2018-05-05/</id>
    <published>2018-05-05T14:38:39.000Z</published>
    <updated>2018-05-07T10:10:51.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分图概念"><a href="#二分图概念" class="headerlink" title="二分图概念"></a>二分图概念</h2><p>二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（ i，j ）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。</p><p>简而言之，一个图所有的顶点被分成两部分，同一部分的顶点之间没有边。如图所示：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-5-1.png" alt=""></p><h2 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h2><p>给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。<br>极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。<br>如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。</p><h2 id="增广路经"><a href="#增广路经" class="headerlink" title="增广路经"></a>增广路经</h2><p>增广路径的定义：设M为二分图G已匹配边的集合，若P是图G中一条连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。<br>增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行,显然P有奇数条边</p><p>由增广路的定义可以推出下述三个结论：</p><ol><li>P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。</li><li>P经过取反操作可以得到一个更大的匹配M’。</li><li>M为G的最大匹配当且仅当不存在相对于M的增广路径。 </li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。</p><p>匈牙利算法基本模式：</p><hr><p>初始时最大匹配为空</p><p>​    while 找到增广路经</p><p>​        do 把增广路径加入到最大匹配中去</p><hr><p>具体过程如图所示：</p><p>1.如图所示，1可以与a，c匹配，2可以与a，b匹配，3可以与c匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-1.png" alt=""></p><p>2.首先将对1进行搜索，1可以与a匹配，则将1与a相连</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-2.png" alt=""></p><p>3.再对2进行搜索，2可以与a匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-3.png" alt=""></p><p>4.但是a已经与1匹配了，那么顺着a-&gt;1这条路找到1，再对1进行搜索，发现1还可以与c进行匹配，并且当前c还未与任何X区顶点匹配，则将1与c相连</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-4.png" alt=""></p><p>5.现在对3进行匹配，发现3可以与c匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-5.png" alt=""></p><p>6.这时发现c已经匹配了，则顺着c-&gt;1这条路找到1，再对1进行搜索，发现1还可以与a匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-6.png" alt=""></p><p>7.但a也已经匹配了，则顺着a-&gt;2这条路找到2，这时发现2还可以与b匹配，并且b当前还未与任何X顶点匹配，则将2与b匹配，之后得到的结果即为最大匹配</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-6-7.png" alt=""></p><p>以下是实现代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool find(int x) &#123;//寻找增广路</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;//遍历Y部分顶点</span><br><span class="line">if (road[x][i] &amp;&amp; !vis[i]) &#123;//Y某顶点与X有路且未标记</span><br><span class="line">vis[i] = true;</span><br><span class="line">if (!link[i] || find(link[i])) &#123;//如果Y顶点当前未与其他X匹配则直接与该点匹配，否则寻找增广路，然后将Y顶点与该顶点匹配</span><br><span class="line">link[i] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 1; i &lt;= N; i++)&#123;//对每一个X部分顶点进行遍历</span><br><span class="line">  memset(vis,false,sizeof(vis));</span><br><span class="line">  if(find(i))&#123;//寻找增光路</span><br><span class="line">    ans++;//最大匹配数量加1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：POJ3041</p><p>给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍，</p><p>最少要几次。这里将每行x看成一个X结点，每列Y看成一个Y结点，障碍的坐标x,y看成X到Y的</p><p>一条边，构建出图后，就变成了找最少的点，使得这些点与所有的边相邻，即最小点覆盖问题。</p><p>又继续敲了一遍匈牙利算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N, K, ans;</span><br><span class="line">int road[520][520], head[520];</span><br><span class="line">bool vis[520];</span><br><span class="line">bool find(int x) &#123;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">if (road[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">vis[i] = true;</span><br><span class="line">if (!head[i] || find(head[i])) &#123;</span><br><span class="line">head[i] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">ans = 0;</span><br><span class="line">int x, y;</span><br><span class="line">memset(road, 0, sizeof(road));</span><br><span class="line">memset(head, 0, sizeof(head));</span><br><span class="line">for (int i = 1; i &lt;= K; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">road[x][y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">memset(vis, false, sizeof(vis));</span><br><span class="line">if (find(i)) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分图概念&quot;&gt;&lt;a href=&quot;#二分图概念&quot; class=&quot;headerlink&quot; title=&quot;二分图概念&quot;&gt;&lt;/a&gt;二分图概念&lt;/h2&gt;&lt;p&gt;二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分图匹配" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
      <category term="匈牙利算法" scheme="http://qianyouyou.cn/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[C++实战qqHelper]C++打造qq消息一键群发工具</title>
    <link href="http://qianyouyou.cn/2018/05/03/2018-05-03/"/>
    <id>http://qianyouyou.cn/2018/05/03/2018-05-03/</id>
    <published>2018-05-03T09:42:24.000Z</published>
    <updated>2018-05-03T10:26:03.813Z</updated>
    
    <content type="html"><![CDATA[<p>物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此次借此小程序练习C++，用C++打造qq聊天一键群发功能。该小程序还在完善中。目前只能作用于电脑Windows操作系统，并且电脑聊天界面发送按钮需切换到按Enter直接发送，不要选择Ctrl+Enter。当前仅有发送功能，因此消息的对象是所有好友。之后有时间会陆续添加暂停，继续等操作。</p><p>具体代码以及实现过程在代码中逐条说明。这里就不具体说明了。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%5BHH@%29DN@ZX@RS53DTVQ1KZ8.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/YBFUJCK%29LL7%7B%5BO4OJ0Q$8$1.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/SB%7D%7DDL9H3VT9M@QQ$E%7DIK~2.png" alt=""></p><p>QQmessage.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class QQmessage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">QQmessage();</span><br><span class="line">~QQmessage();</span><br><span class="line"></span><br><span class="line">//类的入口 </span><br><span class="line">static QQmessage *Instance()</span><br><span class="line">&#123;</span><br><span class="line">static QQmessage object;</span><br><span class="line"></span><br><span class="line">return &amp;object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入口函数</span><br><span class="line">void Start(const wchar_t *msg);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">//开始线程</span><br><span class="line">static unsigned int WINAPI RunThreadproc(void* param);</span><br><span class="line"></span><br><span class="line">//发送主函数</span><br><span class="line">void SendAll();</span><br><span class="line"></span><br><span class="line">//找到QQ窗口</span><br><span class="line">HWND FindQQWindow();</span><br><span class="line"></span><br><span class="line">//模拟按键</span><br><span class="line">void PressKey(BYTE vkey);</span><br><span class="line"></span><br><span class="line">//发送消息</span><br><span class="line">void SendMsg();</span><br><span class="line"></span><br><span class="line">//添加文本到剪贴板</span><br><span class="line">void AddTextToClipboard();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">CString m_msg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>QQmessage.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQmessage.h&quot;</span><br><span class="line"></span><br><span class="line">QQmessage::QQmessage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QQmessage::~QQmessage()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入口函数</span><br><span class="line">void QQmessage::Start(const wchar_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">m_msg = CString(msg); //输入的文本</span><br><span class="line"></span><br><span class="line">_beginthreadex(NULL, 0, QQmessage::RunThreadproc, NULL, 0, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始线程</span><br><span class="line">unsigned int QQmessage::RunThreadproc(void* param)</span><br><span class="line">&#123;</span><br><span class="line">QQmessage::Instance()-&gt;SendAll();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送主函数</span><br><span class="line">void QQmessage::SendAll()</span><br><span class="line">&#123;</span><br><span class="line">int errorTimes = 0;  //打开对话框错误的次数!</span><br><span class="line">//把text复制到剪贴板</span><br><span class="line">AddTextToClipboard();</span><br><span class="line"></span><br><span class="line">//技术到家. 做项目能力.</span><br><span class="line">while (errorTimes&lt;= 4)</span><br><span class="line">&#123;</span><br><span class="line">HWND hQQWnd = FindQQWindow();</span><br><span class="line">HWND hFrontWnd = GetForegroundWindow(); </span><br><span class="line"></span><br><span class="line">if (hQQWnd != hFrontWnd)</span><br><span class="line">&#123;</span><br><span class="line">if (!SetForegroundWindow(hQQWnd))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(NULL, L&quot;没有找到QQ窗口&quot;, NULL, NULL);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (errorTimes == 0)</span><br><span class="line">&#123;</span><br><span class="line">PressKey(VK_TAB);</span><br><span class="line">PressKey(VK_TAB);</span><br><span class="line">&#125;</span><br><span class="line">PressKey(VK_DOWN);</span><br><span class="line">PressKey(VK_RETURN);</span><br><span class="line"></span><br><span class="line">HWND hCurFrontWnd = GetForegroundWindow();</span><br><span class="line">if (hCurFrontWnd == hQQWnd)  //</span><br><span class="line">&#123;</span><br><span class="line">++errorTimes;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errorTimes = 0;</span><br><span class="line">SendMsg();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到QQ窗口</span><br><span class="line">HWND QQmessage::FindQQWindow()</span><br><span class="line">&#123;</span><br><span class="line">HWND hWnd = FindWindow(L&quot;TXGuiFoundation&quot;,L&quot;QQ&quot;);  //Find  Window //获取QQ的窗口!!!</span><br><span class="line"></span><br><span class="line">//辅助工具就是这么做的</span><br><span class="line">return hWnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟按键</span><br><span class="line">void QQmessage::PressKey(BYTE vkey)</span><br><span class="line">&#123;</span><br><span class="line">keybd_event(vkey, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">Sleep(100);</span><br><span class="line">keybd_event(vkey, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">Sleep(100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送消息  16GU盘</span><br><span class="line">void QQmessage::SendMsg()</span><br><span class="line">&#123;</span><br><span class="line">//粘贴  +  发送</span><br><span class="line">keybd_event(VK_CONTROL, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">Sleep(100);</span><br><span class="line">keybd_event(0x56, 0, 0, 0);  //按下(0)和弹起(KEYEVENTF_KEYUP)</span><br><span class="line">Sleep(100);</span><br><span class="line"></span><br><span class="line">keybd_event(0x56, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">Sleep(100);</span><br><span class="line">keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);  //敲击TAB</span><br><span class="line">Sleep(100); //你好 鲜花刷起来!</span><br><span class="line"></span><br><span class="line">//发送</span><br><span class="line">PressKey(VK_RETURN);</span><br><span class="line">PressKey(VK_ESCAPE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加文本到剪贴板</span><br><span class="line">void QQmessage::AddTextToClipboard()</span><br><span class="line">&#123;</span><br><span class="line">//1.把文本拷贝到全局变量!  </span><br><span class="line">int memLen = m_msg.GetLength() * sizeof(wchar_t) + 2;</span><br><span class="line"></span><br><span class="line">HANDLE hGloBal = GlobalAlloc(GHND,memLen);   //malloc  calloc  relloc </span><br><span class="line"></span><br><span class="line">void* memAddr = GlobalLock(hGloBal);</span><br><span class="line"></span><br><span class="line">ZeroMemory(memAddr, memLen);</span><br><span class="line"></span><br><span class="line">memcpy(memAddr, (const void*)m_msg.GetBuffer(), memLen);</span><br><span class="line"></span><br><span class="line">GlobalUnlock(hGloBal);</span><br><span class="line"></span><br><span class="line">//操作剪贴板!  怎么把大象装进冰箱!</span><br><span class="line">OpenClipboard(NULL);</span><br><span class="line">EmptyClipboard();</span><br><span class="line">SetClipboardData(CF_UNICODETEXT, hGloBal);</span><br><span class="line">CloseClipboard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QQHelperDlg.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelperDlg.h : 头文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 对话框</span><br><span class="line">class CQQHelperDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">// 构造</span><br><span class="line">public:</span><br><span class="line">CQQHelperDlg(CWnd* pParent = NULL);// 标准构造函数</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_QQHELPER_DIALOG &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);// DDX/DDV 支持</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">protected:</span><br><span class="line">HICON m_hIcon;</span><br><span class="line"></span><br><span class="line">// 生成的消息映射函数</span><br><span class="line">virtual BOOL OnInitDialog();</span><br><span class="line">afx_msg void OnSysCommand(UINT nID, LPARAM lParam);</span><br><span class="line">afx_msg void OnPaint();</span><br><span class="line">afx_msg HCURSOR OnQueryDragIcon();</span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">CString m_Msg;</span><br><span class="line">afx_msg void OnBnClickedButton1();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>QQHelperDlg.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelperDlg.cpp : 实现文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQHelper.h&quot;</span><br><span class="line">#include &quot;QQHelperDlg.h&quot;</span><br><span class="line">#include &quot;afxdialogex.h&quot;</span><br><span class="line">#include &quot;QQmessage.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define new DEBUG_NEW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用于应用程序“关于”菜单项的 CAboutDlg 对话框</span><br><span class="line"></span><br><span class="line">class CAboutDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CAboutDlg();</span><br><span class="line"></span><br><span class="line">// 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD = IDD_ABOUTBOX &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line">protected:</span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CAboutDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::DoDataExchange(pDX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 对话框</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CQQHelperDlg::CQQHelperDlg(CWnd* pParent /*=NULL*/)</span><br><span class="line">: CDialogEx(IDD_QQHELPER_DIALOG, pParent)</span><br><span class="line">, m_Msg(_T(&quot;&quot;))</span><br><span class="line">&#123;</span><br><span class="line">m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::DoDataExchange(CDataExchange* pDX)</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::DoDataExchange(pDX);</span><br><span class="line">DDX_Text(pDX, IDC_EDIT1, m_Msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CQQHelperDlg, CDialogEx)</span><br><span class="line">ON_WM_SYSCOMMAND()</span><br><span class="line">ON_WM_PAINT()</span><br><span class="line">ON_WM_QUERYDRAGICON()</span><br><span class="line">ON_BN_CLICKED(IDC_BUTTON1, &amp;CQQHelperDlg::OnBnClickedButton1)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperDlg 消息处理程序</span><br><span class="line"></span><br><span class="line">BOOL CQQHelperDlg::OnInitDialog()</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line">// 将“关于...”菜单项添加到系统菜单中。</span><br><span class="line"></span><br><span class="line">// IDM_ABOUTBOX 必须在系统命令范围内。</span><br><span class="line">ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);</span><br><span class="line">ASSERT(IDM_ABOUTBOX &lt; 0xF000);</span><br><span class="line"></span><br><span class="line">CMenu* pSysMenu = GetSystemMenu(FALSE);</span><br><span class="line">if (pSysMenu != NULL)</span><br><span class="line">&#123;</span><br><span class="line">BOOL bNameValid;</span><br><span class="line">CString strAboutMenu;</span><br><span class="line">bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);</span><br><span class="line">ASSERT(bNameValid);</span><br><span class="line">if (!strAboutMenu.IsEmpty())</span><br><span class="line">&#123;</span><br><span class="line">pSysMenu-&gt;AppendMenu(MF_SEPARATOR);</span><br><span class="line">pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span><br><span class="line">//  执行此操作</span><br><span class="line">SetIcon(m_hIcon, TRUE);// 设置大图标</span><br><span class="line">SetIcon(m_hIcon, FALSE);// 设置小图标</span><br><span class="line"></span><br><span class="line">// TODO: 在此添加额外的初始化代码</span><br><span class="line"></span><br><span class="line">return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::OnSysCommand(UINT nID, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">CAboutDlg dlgAbout;</span><br><span class="line">dlgAbout.DoModal();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::OnSysCommand(nID, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果向对话框添加最小化按钮，则需要下面的代码</span><br><span class="line">//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，</span><br><span class="line">//  这将由框架自动完成。</span><br><span class="line"></span><br><span class="line">void CQQHelperDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">if (IsIconic())</span><br><span class="line">&#123;</span><br><span class="line">CPaintDC dc(this); // 用于绘制的设备上下文</span><br><span class="line"></span><br><span class="line">SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);</span><br><span class="line"></span><br><span class="line">// 使图标在工作区矩形中居中</span><br><span class="line">int cxIcon = GetSystemMetrics(SM_CXICON);</span><br><span class="line">int cyIcon = GetSystemMetrics(SM_CYICON);</span><br><span class="line">CRect rect;</span><br><span class="line">GetClientRect(&amp;rect);</span><br><span class="line">int x = (rect.Width() - cxIcon + 1) / 2;</span><br><span class="line">int y = (rect.Height() - cyIcon + 1) / 2;</span><br><span class="line"></span><br><span class="line">// 绘制图标</span><br><span class="line">dc.DrawIcon(x, y, m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::OnPaint();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当用户拖动最小化窗口时系统调用此函数取得光标</span><br><span class="line">//显示。</span><br><span class="line">HCURSOR CQQHelperDlg::OnQueryDragIcon()</span><br><span class="line">&#123;</span><br><span class="line">return static_cast&lt;HCURSOR&gt;(m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//发送</span><br><span class="line">void CQQHelperDlg::OnBnClickedButton1()</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此添加控件通知处理程序代码</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"></span><br><span class="line">QQmessage::Instance()-&gt;Start(m_Msg.GetBuffer());//m_Msg实例编辑框的变量  文字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QQHelper.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelper.h : PROJECT_NAME 应用程序的主头文件</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifndef __AFXWIN_H__</span><br><span class="line">#error &quot;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &quot;resource.h&quot;// 主符号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp: </span><br><span class="line">// 有关此类的实现，请参阅 QQHelper.cpp</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">class CQQHelperApp : public CWinApp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CQQHelperApp();</span><br><span class="line"></span><br><span class="line">// 重写</span><br><span class="line">public:</span><br><span class="line">virtual BOOL InitInstance();</span><br><span class="line"></span><br><span class="line">// 实现</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern CQQHelperApp theApp;</span><br></pre></td></tr></table></figure><p>QQHelper.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// QQHelper.cpp : 定义应用程序的类行为。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;QQHelper.h&quot;</span><br><span class="line">#include &quot;QQHelperDlg.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define new DEBUG_NEW</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(CQQHelperApp, CWinApp)</span><br><span class="line">ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp 构造</span><br><span class="line"></span><br><span class="line">CQQHelperApp::CQQHelperApp()</span><br><span class="line">&#123;</span><br><span class="line">// 支持重新启动管理器</span><br><span class="line">m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;</span><br><span class="line"></span><br><span class="line">// TODO: 在此处添加构造代码，</span><br><span class="line">// 将所有重要的初始化放置在 InitInstance 中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 唯一的一个 CQQHelperApp 对象</span><br><span class="line"></span><br><span class="line">CQQHelperApp theApp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// CQQHelperApp 初始化</span><br><span class="line"></span><br><span class="line">BOOL CQQHelperApp::InitInstance()</span><br><span class="line">&#123;</span><br><span class="line">// 如果一个运行在 Windows XP 上的应用程序清单指定要</span><br><span class="line">// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，</span><br><span class="line">//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。</span><br><span class="line">INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">InitCtrls.dwSize = sizeof(InitCtrls);</span><br><span class="line">// 将它设置为包括所有要在应用程序中使用的</span><br><span class="line">// 公共控件类。</span><br><span class="line">InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line">InitCommonControlsEx(&amp;InitCtrls);</span><br><span class="line"></span><br><span class="line">CWinApp::InitInstance();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AfxEnableControlContainer();</span><br><span class="line"></span><br><span class="line">// 创建 shell 管理器，以防对话框包含</span><br><span class="line">// 任何 shell 树视图控件或 shell 列表视图控件。</span><br><span class="line">CShellManager *pShellManager = new CShellManager;</span><br><span class="line"></span><br><span class="line">// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题</span><br><span class="line">CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));</span><br><span class="line"></span><br><span class="line">// 标准初始化</span><br><span class="line">// 如果未使用这些功能并希望减小</span><br><span class="line">// 最终可执行文件的大小，则应移除下列</span><br><span class="line">// 不需要的特定初始化例程</span><br><span class="line">// 更改用于存储设置的注册表项</span><br><span class="line">// TODO: 应适当修改该字符串，</span><br><span class="line">// 例如修改为公司或组织名</span><br><span class="line">SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;));</span><br><span class="line"></span><br><span class="line">CQQHelperDlg dlg;</span><br><span class="line">m_pMainWnd = &amp;dlg;</span><br><span class="line">INT_PTR nResponse = dlg.DoModal();</span><br><span class="line">if (nResponse == IDOK)</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此放置处理何时用</span><br><span class="line">//  “确定”来关闭对话框的代码</span><br><span class="line">&#125;</span><br><span class="line">else if (nResponse == IDCANCEL)</span><br><span class="line">&#123;</span><br><span class="line">// TODO: 在此放置处理何时用</span><br><span class="line">//  “取消”来关闭对话框的代码</span><br><span class="line">&#125;</span><br><span class="line">else if (nResponse == -1)</span><br><span class="line">&#123;</span><br><span class="line">TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;);</span><br><span class="line">TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除上面创建的 shell 管理器。</span><br><span class="line">if (pShellManager != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete pShellManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifndef _AFXDLL</span><br><span class="line">ControlBarCleanUp();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，</span><br><span class="line">//  而不是启动应用程序的消息泵。</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stdafx.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// stdafx.h : 标准系统包含文件的包含文件，</span><br><span class="line">// 或是经常使用但不常更改的</span><br><span class="line">// 特定于项目的包含文件</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#ifndef VC_EXTRALEAN</span><br><span class="line">#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &quot;targetver.h&quot;</span><br><span class="line"></span><br><span class="line">#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的</span><br><span class="line"></span><br><span class="line">// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏</span><br><span class="line">#define _AFX_ALL_WARNINGS</span><br><span class="line"></span><br><span class="line">#include &lt;afxwin.h&gt;         // MFC 核心组件和标准组件</span><br><span class="line">#include &lt;afxext.h&gt;         // MFC 扩展</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;afxdisp.h&gt;        // MFC 自动化类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef _AFX_NO_OLE_SUPPORT</span><br><span class="line">#include &lt;afxdtctl.h&gt;           // MFC 对 Internet Explorer 4 公共控件的支持</span><br><span class="line">#endif</span><br><span class="line">#ifndef _AFX_NO_AFXCMN_SUPPORT</span><br><span class="line">#include &lt;afxcmn.h&gt;             // MFC 对 Windows 公共控件的支持</span><br><span class="line">#endif // _AFX_NO_AFXCMN_SUPPORT</span><br><span class="line"></span><br><span class="line">#include &lt;afxcontrolbars.h&gt;     // 功能区和控件条的 MFC 支持</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef _UNICODE</span><br><span class="line">#if defined _M_IX86</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;x86&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#elif defined _M_X64</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;amd64&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#else</span><br><span class="line">#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;*&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>stdafx.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// stdafx.cpp : 只包括标准包含文件的源文件</span><br><span class="line">// QQHelper.pch 将作为预编译头</span><br><span class="line">// stdafx.obj 将包含预编译类型信息</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br></pre></td></tr></table></figure><p>Resource.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="line">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="line">// 供 QQHelper.rc 使用</span><br><span class="line">//</span><br><span class="line">#define IDM_ABOUTBOX                    0x0010</span><br><span class="line">#define IDD_ABOUTBOX                    100</span><br><span class="line">#define IDS_ABOUTBOX                    101</span><br><span class="line">#define IDD_QQHELPER_DIALOG             102</span><br><span class="line">#define IDR_MAINFRAME                   128</span><br><span class="line">#define IDC_EDIT1                       1000</span><br><span class="line">#define IDC_BUTTON1                     1001</span><br><span class="line"></span><br><span class="line">// Next default values for new objects</span><br><span class="line">// </span><br><span class="line">#ifdef APSTUDIO_INVOKED</span><br><span class="line">#ifndef APSTUDIO_READONLY_SYMBOLS</span><br><span class="line">#define _APS_NEXT_RESOURCE_VALUE        130</span><br><span class="line">#define _APS_NEXT_COMMAND_VALUE         32771</span><br><span class="line">#define _APS_NEXT_CONTROL_VALUE         1002</span><br><span class="line">#define _APS_NEXT_SYMED_VALUE           101</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>targetver.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。</span><br><span class="line"></span><br><span class="line">// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将</span><br><span class="line">// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。</span><br><span class="line"></span><br><span class="line">#include &lt;SDKDDKVer.h&gt;</span><br></pre></td></tr></table></figure><p>资源文件</p><p><img src="http://p7woygi8q.bkt.clouddn.com/QQHelper.ico" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="项目实战" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）</title>
    <link href="http://qianyouyou.cn/2018/05/01/2018-05-01/"/>
    <id>http://qianyouyou.cn/2018/05/01/2018-05-01/</id>
    <published>2018-05-01T15:37:44.000Z</published>
    <updated>2018-05-01T16:21:11.527Z</updated>
    
    <content type="html"><![CDATA[<p>今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。</p><h2 id="Walking-in-the-Forest-（最大值最小化例题）"><a href="#Walking-in-the-Forest-（最大值最小化例题）" class="headerlink" title="Walking in the Forest （最大值最小化例题）"></a><a href="https://www.nowcoder.com/acm/contest/106/K" target="_blank" rel="noopener">Walking in the Forest</a> （最大值最小化例题）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  It’s universally acknowledged that there’re innumerable trees in the campus of HUST. </p><p>  Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step.  </p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The first line contains two integer N and K as described above.</span><br><span class="line">Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone.</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An integer, the minimum distance of the largest step.</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 3 2 2 5</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>题意：</p><p>有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。</p><p>题解：</p><p>典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">long long  a[100010];</span><br><span class="line">int n, k;</span><br><span class="line">bool check(long long ld,long long rd,long long mind) &#123;</span><br><span class="line">long long cnt = 0;</span><br><span class="line">int stemp = 1;</span><br><span class="line">for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">if (cnt + a[i] &lt;= mind) &#123;</span><br><span class="line">cnt += a[i];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cnt = a[i];</span><br><span class="line">stemp++;</span><br><span class="line">&#125;</span><br><span class="line">if (stemp &gt; k)</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (stemp &lt;= k)</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123;</span><br><span class="line">long long maxn = 0, sumn = 0;</span><br><span class="line">for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">sumn += a[i];</span><br><span class="line">if (maxn &lt; a[i])</span><br><span class="line">maxn = a[i];</span><br><span class="line">&#125;</span><br><span class="line">long long ld = maxn;</span><br><span class="line">long long rd = sumn;</span><br><span class="line">long long mind = (ld + rd) / 2;</span><br><span class="line">while (ld &lt;= rd) &#123;</span><br><span class="line">bool flag = check(ld, rd, mind);</span><br><span class="line">if (!flag) &#123;</span><br><span class="line">ld = mind + 1;</span><br><span class="line">mind = (ld + rd) / 2;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">rd = mind - 1;</span><br><span class="line">mind = (ld + rd) / 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, ld);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2456疯牛-（最小值最大化例题）"><a href="#POJ2456疯牛-（最小值最大化例题）" class="headerlink" title="POJ2456疯牛 （最小值最大化例题）"></a>POJ2456疯牛 （最小值最大化例题）</h2><p>时间限制：1000 ms  |  内存限制：65535 KB</p><p>难度：4</p><ul><li><p>描述</p><p>农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入<code>5 312849</code>样例输出<code>3</code></p></li></ul><p>题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。</p><p>题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int v[100005];  </span><br><span class="line">int n, c;  </span><br><span class="line">int check(int d) &#123;  </span><br><span class="line">    int tmp = v[0], cnt = 1;  </span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;  </span><br><span class="line">        if (v[i] - tmp &gt;= d) &#123;  </span><br><span class="line">            cnt++;  </span><br><span class="line">            tmp = v[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (cnt &gt;= c)  </span><br><span class="line">        return 1;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; c) &#123;  </span><br><span class="line">        for (int i = 0; i &lt; n; i++)  </span><br><span class="line">            cin &gt;&gt; v[i];  </span><br><span class="line">        sort(v, v + n);  </span><br><span class="line">        int l = 0, r = v[n - 1], mid;  </span><br><span class="line">        while (l &lt;= r) &#123;  </span><br><span class="line">            mid = (l + r) / 2;  </span><br><span class="line">            if (check(mid))  </span><br><span class="line">                l = mid + 1;  </span><br><span class="line">            else  </span><br><span class="line">                r = mid - 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;%d\n&quot;, r);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。&lt;/p&gt;
&lt;h2 id=&quot;Walking-in-the-Forest-（最大值最小化例题）&quot;&gt;&lt;a href=&quot;#Walking-in-the-Forest-
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="二分" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解</title>
    <link href="http://qianyouyou.cn/2018/04/29/2018-04-29/"/>
    <id>http://qianyouyou.cn/2018/04/29/2018-04-29/</id>
    <published>2018-04-29T12:26:44.000Z</published>
    <updated>2018-05-06T14:26:08.972Z</updated>
    
    <content type="html"><![CDATA[<p>4月29日，13:30-18:30，<a href="http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=378" target="_blank" rel="noopener">浙江大学程序设计校赛</a> </p><h2 id="A-Peak"><a href="#A-Peak" class="headerlink" title="A-Peak"></a>A-Peak</h2><p>题意：</p><p>有一串数字，问这串数字是否符合以下情况：</p><p>存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。</p><p>题解：</p><p>水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。</p><h2 id="B-King-of-Karaoke"><a href="#B-King-of-Karaoke" class="headerlink" title="B - King of Karaoke"></a>B - King of Karaoke</h2><p>题意：</p><p>两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k</p><p>题解：</p><p>只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。</p><h2 id="D-Sequence-Swapping"><a href="#D-Sequence-Swapping" class="headerlink" title="D - Sequence Swapping"></a>D - Sequence Swapping</h2><hr><p>Time Limit: 1 Second      Memory Limit: 65536 KB</p><hr><p>BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length  in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element  in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element  in the pair is an integer.</p><p>As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if ,  ‘(‘ and  ‘)’.</p><p>BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case:</p><p>The first line contains an integer  (), indicating the length of the sequence.</p><p>The second line contains a string  () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above.</p><p>The third line contains  integers  (). Their meanings are described above.</p><p>It’s guaranteed that the sum of  of all test cases will not exceed .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line containing one integer, indicating the maximum possible score BaoBao can get.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">)())()</span><br><span class="line">1 3 5 -1 3 2</span><br><span class="line">6</span><br><span class="line">)())()</span><br><span class="line">1 3 5 -100 3 2</span><br><span class="line">3</span><br><span class="line">())</span><br><span class="line">1 -1 -1</span><br><span class="line">3</span><br><span class="line">())</span><br><span class="line">-1 -1 -1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">24</span><br><span class="line">21</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>For the first sample test case, the optimal strategy is to select  in order.</p><p>For the second sample test case, the optimal strategy is to select  in order.</p><p>题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。</p><p>题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即cur<em>weight[i]。否则将cur和cur</em>weight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">int cur;</span><br><span class="line">int cnt;</span><br><span class="line">&#125;;</span><br><span class="line">char str[1010];</span><br><span class="line">int wei[1010];</span><br><span class="line">int main() &#123;</span><br><span class="line">int t, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%d%s&quot;, &amp;n, str);</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;wei[i]);</span><br><span class="line">&#125;</span><br><span class="line">stack&lt;node&gt;st;</span><br><span class="line">int sum = 0;</span><br><span class="line">int cur = 0;</span><br><span class="line">int cnt = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">if (str[i] == &apos;(&apos;) &#123;</span><br><span class="line">if (cur == 0) &#123;</span><br><span class="line">cur = wei[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (abs(cur) &lt; abs(cur + wei[i])) &#123;</span><br><span class="line">cur = cur + wei[i];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cur = wei[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (str[i] == &apos;)&apos;) &#123;</span><br><span class="line">if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123;</span><br><span class="line">cnt = 0;</span><br><span class="line">do &#123;</span><br><span class="line">cur += st.top().cur;</span><br><span class="line">cnt += st.top().cnt;</span><br><span class="line">st.pop();</span><br><span class="line">&#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]);</span><br><span class="line">sum += cur*wei[i] + cnt;</span><br><span class="line">&#125;</span><br><span class="line">else if (cur*wei[i] &gt; 0) &#123;</span><br><span class="line">sum += wei[i] * cur;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123;</span><br><span class="line">cur += st.top().cur;</span><br><span class="line">sum += cur*wei[i] + st.top().cnt;</span><br><span class="line">st.pop();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (!cur&amp;&amp;!st.empty()) &#123;</span><br><span class="line">st.top().cnt += st.top().cur*wei[i];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">node tmp;</span><br><span class="line">tmp.cnt = cur*wei[i];</span><br><span class="line">tmp.cur = cur;</span><br><span class="line">st.push(tmp);</span><br><span class="line">cur = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J-CONTINUE…"><a href="#J-CONTINUE…" class="headerlink" title="J - CONTINUE…?"></a>J - CONTINUE…?</h2><hr><p>Time Limit: 1 Second      Memory Limit: 65536 KB      Special Judge</p><hr><p>DreamGrid has  classmates numbered from  to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has  gems.</p><p>DreamGrid would like to divide the classmates into four groups , ,  and  such that:</p><ul><li>Each classmate belongs to exactly one group.</li><li>Both  and  consist only of girls. Both  and  consist only of boys.</li><li>The total number of gems in  and  is equal to the total number of gems in  and .</li></ul><p>Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty.</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input is an integer  indicating the number of test cases. For each test case:</p><p>The first line contains an integer  () – the number of classmates.</p><p>The second line contains a string  () consisting of 0 and 1. Let  be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl.</p><p>It is guaranteed that the sum of all  does not exceed .</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">101</span><br><span class="line">4</span><br><span class="line">0000</span><br><span class="line">7</span><br><span class="line">1101001</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">314</span><br><span class="line">1221</span><br><span class="line">3413214</span><br></pre></td></tr></table></figure><p>题意：</p><p>有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可）</p><p>题解：</p><p>看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int a[100010], vis[100010];</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">long long int sum = 0, half = 0;</span><br><span class="line">while (t--) &#123;</span><br><span class="line">int n;</span><br><span class="line">sum = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%1d&quot;, &amp;a[i]);</span><br><span class="line">sum += i + 1;</span><br><span class="line">&#125;</span><br><span class="line">if (sum % 2 != 0) &#123;</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">half = sum / 2;</span><br><span class="line">sum = 0;</span><br><span class="line">for (int i = n; i &gt; 0; i--) &#123;</span><br><span class="line">if (sum + i &lt;= half) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">vis[i - 1] = 1;</span><br><span class="line">if (sum == half)</span><br><span class="line">break;</span><br><span class="line">else if (half - sum &lt; i) &#123;</span><br><span class="line">vis[half - sum - 1] = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">if (a[i]) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">printf(&quot;3&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (!a[i]) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">printf(&quot;1&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-Doki-Doki-Literature-Club"><a href="#L-Doki-Doki-Literature-Club" class="headerlink" title="L - Doki Doki Literature Club"></a>L - Doki Doki Literature Club</h2><hr><p>Time Limit: 1 Second      Memory Limit: 65536 KB</p><hr><p><em>Doki Doki Literature Club!</em> is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story!</p><p>A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words.</p><p><img src="http://acm.zju.edu.cn/onlinejudge/showImage.do?name=poem.jpg" alt="img"><em>The poem writing mini-game (from wikipedia)</em></p><p>BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of  words  is nothing more than a sequence of  strings, and the happiness of Sayori after reading the poem is calculated by the formula</p><p>Given a list of  words and Sayori’s preference to each word, please help BaoBao select  words from the list and finish the poem with these  words to maximize the happiness of Sayori.</p><p>Please note that each word can be used at most <strong>once</strong>!</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>There are multiple test cases. The first line of input contains an integer  (about 100), indicating the number of test cases. For each test case:</p><p>The first line contains two integers  and  (), indicating the number of words and the length of the poem.</p><p>For the following  lines, the -th line contains a string consisting of lowercased English letters  () and an integer  (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that  for all .</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>For each test case output one line containing an integer  and  strings  separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one.</p><p>Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!</p><p>A <strong>sequence</strong> of  strings  is lexicographically smaller than another <strong>sequence</strong> of  strings , if there exists a  () such that  for all  and  is lexicographically smaller than .</p><p>A <strong>string</strong>  is lexicographically smaller than another <strong>string</strong> , if there exists a  () such that  for all  and , or  for all  and .</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">10 8</span><br><span class="line">hello 0</span><br><span class="line">world 0</span><br><span class="line">behind 0</span><br><span class="line">far 1</span><br><span class="line">be 2</span><br><span class="line">spring 10</span><br><span class="line">can 15</span><br><span class="line">comes 20</span><br><span class="line">winter 25</span><br><span class="line">if 200</span><br><span class="line">5 5</span><br><span class="line">collegiate 0</span><br><span class="line">programming -5</span><br><span class="line">zhejiang 10</span><br><span class="line">provincial 5</span><br><span class="line">contest -45</span><br><span class="line">3 2</span><br><span class="line">bcda 1</span><br><span class="line">bcd 1</span><br><span class="line">bbbbb 1</span><br><span class="line">3 2</span><br><span class="line">a 1</span><br><span class="line">aa 1</span><br><span class="line">aaa 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018 if winter comes can spring be far behind</span><br><span class="line">15 zhejiang provincial collegiate programming contest</span><br><span class="line">3 bbbbb bcd</span><br><span class="line">3 a aa</span><br></pre></td></tr></table></figure><p>题意：</p><p>有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。</p><p>题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string str;</span><br><span class="line">long long int weight;</span><br><span class="line">&#125;;</span><br><span class="line">node level[110];</span><br><span class="line">bool cmp(node a,node b) &#123;</span><br><span class="line">if (a.weight != b.weight)</span><br><span class="line">return a.weight &gt; b.weight;</span><br><span class="line">else &#123;</span><br><span class="line">return a.str &lt; b.str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t, n, m;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">long long int h = 0;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; level[i].str &gt;&gt; level[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">sort(level, level + n, cmp);</span><br><span class="line">for (int i = m; i &gt; 0; i--)</span><br><span class="line">h += level[m - i].weight*i;</span><br><span class="line">printf(&quot;%lld &quot;, h);</span><br><span class="line">for (int i = 0; i &lt; m - 1; i++)</span><br><span class="line">cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; level[m - 1].str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Lucky-7"><a href="#K-Lucky-7" class="headerlink" title="K - Lucky 7"></a>K - Lucky 7</h2><p>给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。</p><p>题解：</p><p>每输入一个数直接进行判断即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;4月29日，13:30-18:30，&lt;a href=&quot;http://acm.zju.edu.cn/onlinejudge/showContestProblems.do?contestId=378&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浙江大学程序设
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="ZOJ" scheme="http://qianyouyou.cn/tags/ZOJ/"/>
    
  </entry>
  
  <entry>
    <title>基于github搭建专属于自己的博客(高级篇)</title>
    <link href="http://qianyouyou.cn/2018/04/28/2018-04-28-3/"/>
    <id>http://qianyouyou.cn/2018/04/28/2018-04-28-3/</id>
    <published>2018-04-28T15:39:25.000Z</published>
    <updated>2018-05-02T15:18:26.478Z</updated>
    
    <content type="html"><![CDATA[<p>由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)&lt;/p&gt;

      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="node.js" scheme="http://qianyouyou.cn/tags/node-js/"/>
    
      <category term="html/css" scheme="http://qianyouyou.cn/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>基于github搭建专属于自己的博客(进阶篇)</title>
    <link href="http://qianyouyou.cn/2018/04/28/2018-04-28-2/"/>
    <id>http://qianyouyou.cn/2018/04/28/2018-04-28-2/</id>
    <published>2018-04-28T13:44:25.000Z</published>
    <updated>2018-05-02T15:17:54.319Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。</p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>1.安装主题</p><p>2.启用主题</p><p>3.验证主题</p><p>4.设置语言</p><p>5.设置菜单</p><p>6.侧栏设置</p><p>7.尾栏设置</p><p>8.附页</p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。 </p><p>以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>即可获取最新版主题，后续更新只需输入指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>注意中间有空格。到此，NexT 主题安装完成。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>首先启动 Hexo 本地站点，并开启调试模式，整个命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p> 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.此时即可使用浏览器访问 <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><p>如果端口号被占用还是得先修改端口号，然后启动服务。即先输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -p 5000</span><br></pre></td></tr></table></figure><p> 当命令行输出中提示出：INFO Hexo is running at <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000/</a>. Press Ctrl+C to stop.此时即可使用浏览器访问 <a href="http://localhost:5000/。" target="_blank" rel="noopener">http://localhost:5000/。</a></p><p>完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是：</p><p>Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白</p><p>Mist - Muse 的紧凑版本，整洁有序的单栏外观</p><p>Pisces - 双栏 Scheme，小家碧玉似的清新</p><p> Gemini - 双栏Scheme，简约淡雅的风尚</p><p>注释 # 即可。 以Pisce为例，选择 Pisce Scheme</p><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>在<strong>站点根目录</strong>下修改配置文件_cofig.yml中的language为zh-Hans（简体中文）</p><p>目前 NexT 支持的语言如以下表格所示：</p><table><thead><tr><th>语言</th><th>代码</th><th>设定实例</th></tr></thead><tbody><tr><td>English</td><td>en</td><td>language: en</td></tr><tr><td>简体中文</td><td>zh-Hans</td><td>language: zh-Hans</td></tr><tr><td>Français</td><td>fr-FR</td><td>language: fr-FR</td></tr><tr><td>Português</td><td>pt</td><td>language: pt</td></tr><tr><td>繁體中文</td><td>zh-hk 或者 zh-tw</td><td>language: zh-hk</td></tr><tr><td>Русский язык</td><td>ru</td><td>language: ru</td></tr><tr><td>Deutsch</td><td>de</td><td>language: de</td></tr><tr><td>日本語</td><td>ja</td><td>language: ja</td></tr><tr><td>Indonesian</td><td>id</td><td>language: id</td></tr></tbody></table><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><h4 id="菜单栏设置"><a href="#菜单栏设置" class="headerlink" title="菜单栏设置"></a>菜单栏设置</h4><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。</p><p>编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  #about: /about</span><br><span class="line">  #categories: /categories</span><br><span class="line">  tags: /tags</span><br><span class="line">  #commonweal: /404.html</span><br></pre></td></tr></table></figure><p>若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）：</p><table><thead><tr><th>键值</th><th>设定值</th><th>显示文本（简体中文）</th></tr></thead><tbody><tr><td>home</td><td>home: /</td><td>主页</td></tr><tr><td>archives</td><td>archives: /archives</td><td>归档页</td></tr><tr><td>categories</td><td>categories: /categories</td><td>分类页</td></tr><tr><td>tags</td><td>tags: /tags</td><td>标签页</td></tr><tr><td>about</td><td>about: /about</td><td>关于页面</td></tr><tr><td>commonweal</td><td>commonweal: /404.html</td><td>公益 404</td></tr></tbody></table><p>设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  commonweal: 公益404</span><br></pre></td></tr></table></figure><p>设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br></pre></td></tr></table></figure><h4 id="添加标签，分类"><a href="#添加标签，分类" class="headerlink" title="添加标签，分类"></a>添加标签，分类</h4><p>添加标签页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>在新建的index.md文件中添加type: “tags”</p><p>当要为某一篇文章添加标签，只需在b<code>log/source/_post</code>目录下的具体文章的tags中添加标签即可</p><p>添加分类页面，前面通过修改next主题下的<code>_config.yml</code>文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>在新建的index.md文件中添加type: “categories”</p><p>当要为某一篇文章添加标签，只需在<code>blog/source/_post</code>目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。</p><p>添加关于我页面，步骤和以上差不多</p><p>在新建的index.md文件中添加内容</p><h3 id="侧栏设置"><a href="#侧栏设置" class="headerlink" title="侧栏设置"></a>侧栏设置</h3><p>设置侧栏位置，修改主题目录下sidebar的position值</p><p>设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下）</p><h3 id="尾栏设置"><a href="#尾栏设置" class="headerlink" title="尾栏设置"></a>尾栏设置</h3><p>修改底部的官方logo，找到 <code>\themes\next\layout\_partials\</code>下面的<code>footer.swig</code>文件，打开会发现，如下的语句：</p><p>第一个框 是下面侧栏的“日期❤ XXX”</p><p>如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。</p><p>第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把<code>&lt;a&gt;...&lt;/a&gt;</code>标签这部分删除即可，留着两个单引号’’,否则会出错哦。</p><p>第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将<code>&lt;a&gt;..&lt;/a&gt;</code>都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。</p><p>接下来，处理剩余的中文信息。找到这个地方<code>\themes\next\languages\</code> 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可）</p><p>看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。</p><h3 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h3><p>站点配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site 网站</span><br><span class="line">title: 浅悠悠的个人博客   #网站标题</span><br><span class="line">subtitle: 。。。   #网站副标题</span><br><span class="line">description: 。。。   #网站描述</span><br><span class="line">author: 王骏   #您的名字</span><br><span class="line">language: zh-CN   #网站使用的语言</span><br><span class="line">timezone:           #网站时区。Hexo 默认使用您电脑的时区</span><br><span class="line"></span><br><span class="line"># URL 网址</span><br><span class="line">## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="line">url: http://willxue.top</span><br><span class="line">permalink: :year/:month/:day/:title/    #生成文件名字的格式我改成blog/:title:year:month:day/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory 目录配置</span><br><span class="line">source_dir: source   #源文件夹，这个文件夹用来存放内容。</span><br><span class="line">public_dir: public   #公共文件夹，这个文件夹用于存放生成的站点文件。</span><br><span class="line">tag_dir: tags   #标签文件夹</span><br><span class="line">archive_dir: archives   #归档文件夹</span><br><span class="line">category_dir: categories   #分类文件夹</span><br><span class="line">code_dir: downloads/code    #nclude code 文件夹</span><br><span class="line">i18n_dir: :lang   #国际化（i18n）文件夹</span><br><span class="line">skip_render:   #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</span><br><span class="line"></span><br><span class="line"># Writing 文章</span><br><span class="line">new_post_name: :title.md   # 新建文章默认文件名</span><br><span class="line">default_layout: post   # 默认布局</span><br><span class="line">titlecase: false   # Transform title into titlecase</span><br><span class="line">external_link: true   # 在新标签中打开一个外部链接，默认为true</span><br><span class="line">filename_case: 0   #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。</span><br><span class="line">render_drafts: false   #是否渲染_drafts目录下的文章，默认为false</span><br><span class="line">post_asset_folder: false   #启动 Asset 文件夹</span><br><span class="line">relative_link: false   #把链接改为与根目录的相对位址，默认false</span><br><span class="line">future: true   #显示未来的文章，默认false</span><br><span class="line">highlight:   #代码块的设置 </span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag   分类和标签的设置</span><br><span class="line">default_category: uncategorized   #默认分类</span><br><span class="line">category_map:   #分类别名</span><br><span class="line">tag_map:   #标签别名</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination 分页</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10   #每页显示的文章量 (0 = 关闭分页功能)</span><br><span class="line">pagination_dir: page   #分页目录</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom       #feed 类型 (atom/rss2)</span><br><span class="line">  path: atom.xml   #rss 路径</span><br><span class="line">  limit: 20        #在 rss 中最多生成的文章数(0显示所有)</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">type: git </span><br><span class="line">  repository: https://github.com/imwillxue/imwillxue.github.com.git </span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>主题配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Site Information Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Place your favicon.ico to /source directory.</span><br><span class="line">favicon: /favicon.ico   #站标  可以放在hexo文件夹下的/source里</span><br><span class="line"></span><br><span class="line"># Set default keywords (Use a comma to separate)</span><br><span class="line">keywords: &quot;为学,willxue,willxue.top&quot;  #网站关键字</span><br><span class="line"></span><br><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss:  #rss这里不设置 引文站点配置文件已经配置了 需要安装插件</span><br><span class="line"></span><br><span class="line"># Specify the date when the site was setup</span><br><span class="line">since: 1990  #网站时间 从xx开始 类似 1990-2016</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># When running hexo in a subdirectory (e.g. domain.tld/blog)</span><br><span class="line"># Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )</span><br><span class="line">menu: #菜单路径设置 如果hexo在二级目录放置要去掉/</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives #归档</span><br><span class="line">  tags: /tags #标签</span><br><span class="line">  categories: /categories  #分类</span><br><span class="line">  about: /about #关于我</span><br><span class="line">  commonweal: /404.html  #公益404</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Enable/Disable menu icons.</span><br><span class="line"># Icon Mapping:</span><br><span class="line">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="line">#   Key is the name of menu item and value is the name of FontAwsome icon.</span><br><span class="line">#   When an question mask icon presenting up means that the item has no mapping icon.</span><br><span class="line">menu_icons:  #icon图标</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mapping.</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: archive</span><br><span class="line">  commonweal: heartbeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Scheme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Schemes  #next的三个scheme</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Sidebar Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Social links   #社交链接</span><br><span class="line">social:</span><br><span class="line">  GitHub: </span><br><span class="line">  Weibo:</span><br><span class="line">  Others:</span><br><span class="line"></span><br><span class="line"># Social Icons  #社交的图标</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mappings</span><br><span class="line">  GitHub: github</span><br><span class="line">  Twitter: twitter</span><br><span class="line">  Weibo: weibo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sidebar Avatar</span><br><span class="line"># in theme directory(source/images): /images/avatar.jpg</span><br><span class="line"># in site  directory(source/uploads): /uploads/avatar.jpg</span><br><span class="line"># default : /images/default_avatar.jpg</span><br><span class="line">avatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># TOC in the Sidebar  #文章自动显示目录</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.  #目录是否自动显示数字序号</span><br><span class="line">  number: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http://creativecommons.org/  #自由协议</span><br><span class="line"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span><br><span class="line">#creative_commons: by-nc-sa</span><br><span class="line">#creative_commons:</span><br><span class="line"></span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Sidebar Display, available value:</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  Totally remove sidebar including sidebar toggle icon.</span><br><span class="line">  display: post</span><br><span class="line">  #display: always</span><br><span class="line">  #display: hide</span><br><span class="line">  #display: remove</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Misc Theme Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Custom Logo.</span><br><span class="line"># !!Only available for Default Scheme currently.</span><br><span class="line"># Options:</span><br><span class="line">#   enabled: [true/false] - Replace with specific image</span><br><span class="line">#   image: url-of-image   - Images&apos;s url</span><br><span class="line">custom_logo:</span><br><span class="line">  enabled: false</span><br><span class="line">  image:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Code Highlight theme</span><br><span class="line"># Available value:</span><br><span class="line">#    normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">highlight_theme: night</span><br><span class="line"></span><br><span class="line"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span><br><span class="line">scroll_to_more: true</span><br><span class="line"></span><br><span class="line"># Automatically Excerpt</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br><span class="line"></span><br><span class="line"># Use Lato font</span><br><span class="line">use_font_lato: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Third Party Services Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Swiftype Search API Key</span><br><span class="line">#swiftype_key:</span><br><span class="line"></span><br><span class="line"># Baidu Analytics ID</span><br><span class="line">#baidu_analytics:</span><br><span class="line"></span><br><span class="line"># Duoshuo ShortName</span><br><span class="line">duoshuo_shortname: imwillxue</span><br><span class="line"></span><br><span class="line"># Disqus</span><br><span class="line">#disqus_shortname:</span><br><span class="line"></span><br><span class="line"># Baidu Share</span><br><span class="line"># Available value:</span><br><span class="line">#    button | slide</span><br><span class="line">#baidushare:</span><br><span class="line">##  type: button</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">#jiathis:</span><br><span class="line">#add_this_id:</span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">duoshuo_share: true</span><br><span class="line"></span><br><span class="line"># Google Webmaster tools verification setting</span><br><span class="line"># See: https://www.google.com/webmasters/</span><br><span class="line">#google_site_verification:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">#google_analytics:</span><br><span class="line"></span><br><span class="line"># CNZZ count</span><br><span class="line">#cnzz_siteid:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Make duoshuo show UA</span><br><span class="line"># user_id must NOT be null when admin_enable is true!</span><br><span class="line"># you can visit http://dev.duoshuo.com get duoshuo user id.</span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: true</span><br><span class="line">  admin_enable: true</span><br><span class="line">  user_id: 6262178932196377345</span><br><span class="line">  admin_nickname: 神</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Facebook SDK Support.</span><br><span class="line"># https://github.com/iissnan/hexo-theme-next/pull/410</span><br><span class="line">facebook_sdk:</span><br><span class="line">  enable: false</span><br><span class="line">  app_id:       #&lt;app_id&gt;</span><br><span class="line">  fb_admin:     #&lt;user_id&gt;</span><br><span class="line">  like_button:  #true</span><br><span class="line">  webmaster:    #true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz</span><br><span class="line">  app_key: AMcYaNHy9Y5OdH42k0d4uSED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Tencent analytics ID</span><br><span class="line"># tencent_analytics:</span><br><span class="line"></span><br><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br><span class="line"></span><br><span class="line">## 文章末尾是否显示打赏按钮</span><br><span class="line">donate: </span><br><span class="line">  enable: true</span><br><span class="line">  text: Enjoy it ? Donate me !  欣赏此文？求鼓励，求支持！</span><br><span class="line">  alipay: </span><br><span class="line">  wechat: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line">#! DO NOT EDIT THE FOLLOWING SETTINGS</span><br><span class="line">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span><br><span class="line">#! ---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># Motion</span><br><span class="line">use_motion: true</span><br><span class="line"></span><br><span class="line"># Fancybox</span><br><span class="line">fancybox: true</span><br><span class="line"></span><br><span class="line"># Static files</span><br><span class="line">vendors: vendors</span><br><span class="line">css: css</span><br><span class="line">js: js</span><br><span class="line">images: images</span><br><span class="line"></span><br><span class="line"># Theme version</span><br><span class="line">version: 0.5.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。&lt;/p&gt;
&lt;h2 id=&quot;基
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="node.js" scheme="http://qianyouyou.cn/tags/node-js/"/>
    
      <category term="html/css" scheme="http://qianyouyou.cn/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>基于github搭建专属于自己的博客（基础篇）</title>
    <link href="http://qianyouyou.cn/2018/04/28/2018-04-28-1/"/>
    <id>http://qianyouyou.cn/2018/04/28/2018-04-28-1/</id>
    <published>2018-04-28T09:11:28.000Z</published>
    <updated>2018-05-02T15:17:20.619Z</updated>
    
    <content type="html"><![CDATA[<p>以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程：</p><h2 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h2><p>1.搭建前的准备（包括node.js，git，github账户的配置）</p><p>2.安装hexo</p><p>3.配置hexo</p><p>4.连接hexo与github page</p><p>5.发布文章</p><h3 id="搭建前的准备"><a href="#搭建前的准备" class="headerlink" title="搭建前的准备"></a>搭建前的准备</h3><p>1.安装node.js</p><p>2.安装git</p><p>3.github账户管理</p><h4 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h4><p>下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>。根据自己电脑的配置自行安装。</p><p>安装完成后打开终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>进行是否安装成功测试。如不正确，回头检查哪一步错误。</p><h4 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h4><p><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>官网。自行安装。</p><p>安装完成后打开终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><p>以上步骤进行是否安装成功。如果安装失败自行面壁。</p><h4 id="github管理"><a href="#github管理" class="headerlink" title="github管理"></a>github管理</h4><p>已拥有账号可跳过注册此步</p><p>打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>进行注册。</p><p>登录后点击右上角加号，选择New repository新建代码库。</p><p>进入代码库创建页面：</p><p>在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。</p><p><strong>注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io</strong></p><p>建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹</p><p>在命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g   //进行安装</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v   //检验是否安装成功。</span><br></pre></td></tr></table></figure><h3 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h3><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init   //初始化该文件夹</span><br></pre></td></tr></table></figure><p>看到后面的“Start blogging with Hexo！”证明正在执行。</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install   //安装所需要的组件</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g   //生成</span><br></pre></td></tr></table></figure><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>开启服务器，访问该网址，正式体验Hexo</p><h3 id="连接hexo与github-page"><a href="#连接hexo与github-page" class="headerlink" title="连接hexo与github page"></a>连接hexo与github page</h3><p>设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。</p><p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p><p>输入ls，列出该文件下的内容</p><p>输入ssh-keygen -t rsa -C “<a href="mailto:xxxxxx@xx.com" target="_blank" rel="noopener">xxxxxx@xx.com</a>”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。</p><p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p>再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p><p>登录Github，点击头像下的settings，添加ssh</p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p><p><strong>问题：</strong>假如ssh-key配置失败，那么只要以下步骤就能完全解决</p><p>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key</p><p>重新生成ssh密钥对<br>ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“</p><p>接下来正常操作<br>在github上添加公钥public-key:<br>1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板<br>2、在github上添加公钥时，直接复制即可<br>3、保存</p><p>测试：<br>在终端 ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><p>配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</p><p>repo值是你在github项目里的ssh（右下角）</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>新建一篇博客，在cmd执行命令：hexo new post “博客名”</p><p>这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件</p><p>在生成以及部署文章之前，需要安装一个扩展：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   // 生成</span><br><span class="line">hexo d   // 部署</span><br></pre></td></tr></table></figure><p>当然你也可以执行下面的命令，相当于上面两条命令的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d   //在部署前先生成</span><br></pre></td></tr></table></figure><p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。</p><p>到此为止，最基本的也是最全面的hexo+github搭建博客完结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程：&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="node.js" scheme="http://qianyouyou.cn/tags/node-js/"/>
    
      <category term="html/css" scheme="http://qianyouyou.cn/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://qianyouyou.cn/2018/04/24/hello-world/"/>
    <id>http://qianyouyou.cn/2018/04/24/hello-world/</id>
    <published>2018-04-24T01:22:39.624Z</published>
    <updated>2018-04-28T11:01:20.104Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://qianyouyou.cn/">My Blog</a>! This is my very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://qianyouyou.cn/&quot;&gt;My Blog&lt;/a&gt;! This is my very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="npm" scheme="http://qianyouyou.cn/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构]堆的基本操作</title>
    <link href="http://qianyouyou.cn/2018/04/23/2018-04-23/"/>
    <id>http://qianyouyou.cn/2018/04/23/2018-04-23/</id>
    <published>2018-04-23T14:42:25.000Z</published>
    <updated>2018-05-07T12:29:01.238Z</updated>
    
    <content type="html"><![CDATA[<p>堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p><p>1.堆总是一棵完全二叉树。</p><p>2.堆中某个节点的值总是不大于或不小于其父节点的值。</p><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p><p>本次操作具体以小根堆为例进行演示。</p><h2 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h2><p>一般采用树组存储，i结点的父结点下标为( i - 1 ) / 2。左子树的下标为2 <em> i + 1,右子树的下标为2 </em> i + 2。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/7-1.png" alt=""></p><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><h3 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h3><p>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于<strong>直接插入排序</strong>中将一个数据并入到有序区间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//  新加入i结点  其父结点为(i - 1) / 2  </span><br><span class="line">void MinHeapFixup(int a[], int i)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j, temp;  </span><br><span class="line">    </span><br><span class="line">    temp = a[i];  </span><br><span class="line">    j = (i - 1) / 2;      //父结点  </span><br><span class="line">    while (j &gt;= 0 &amp;&amp; i != 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (a[j] &lt;= temp)  </span><br><span class="line">            break;  </span><br><span class="line">          </span><br><span class="line">        a[i] = a[j];     //把较大的子结点往下移动,替换它的子结点  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = (i - 1) / 2;  </span><br><span class="line">    &#125;  </span><br><span class="line">    a[i] = temp;</span><br></pre></td></tr></table></figure><p>插入时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MinHeapAddNumber(int a[], int n, int nNum)  </span><br><span class="line">&#123;  </span><br><span class="line">    a[n] = nNum;  </span><br><span class="line">    MinHeapFixup(a, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h3><p>堆中每次都只能删除根结点，即第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  </span><br><span class="line">void MinHeapFixdown(int a[], int i, int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int j, temp;  </span><br><span class="line">  </span><br><span class="line">    temp = a[i];  </span><br><span class="line">    j = 2 * i + 1;  </span><br><span class="line">    while (j &lt; n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的  </span><br><span class="line">            j++;  </span><br><span class="line">  </span><br><span class="line">        if (a[j] &gt;= temp)  </span><br><span class="line">            break;  </span><br><span class="line">  </span><br><span class="line">        a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点  </span><br><span class="line">        i = j;  </span><br><span class="line">        j = 2 * i + 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    a[i] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">//在最小堆中删除数  </span><br><span class="line">void MinHeapDeleteNumber(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    Swap(a[0], a[n - 1]);  </span><br><span class="line">    MinHeapFixdown(a, 0, n - 1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h3><p>有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//建立最小堆  </span><br><span class="line">void MakeMinHeap(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (int i = n / 2 - 1; i &gt;= 0; i--)  </span><br><span class="line">        MinHeapFixdown(a, i, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。</p><p>由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void MinheapsortTodescendarray(int a[], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    for (int i = n - 1; i &gt;= 1; i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Swap(a[i], a[0]);  </span><br><span class="line">        MinHeapFixdown(a, 0, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：&lt;/p&gt;
&lt;p&gt;1.堆总是一棵完全二叉树。&lt;/p&gt;
&lt;p&gt;2.堆中某个节点的值总是不大于或不小于其父节点的值。&lt;/p&gt;
&lt;p&gt;将根节点最大的堆叫做最大堆或大根堆
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="堆" scheme="http://qianyouyou.cn/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>[爬虫]python自动调用浏览器访问网页增加访问量</title>
    <link href="http://qianyouyou.cn/2018/04/22/2018-04-22-1/"/>
    <id>http://qianyouyou.cn/2018/04/22/2018-04-22-1/</id>
    <published>2018-04-22T15:07:01.000Z</published>
    <updated>2018-05-02T12:00:23.950Z</updated>
    
    <content type="html"><![CDATA[<p>该程序主要是为了增长访问量而写的，主要针对一些访问量与用户信息无关的网页，比如CSDN。当然前提是python安装相应的库。原理很简单，没有用到什么高端的爬虫技术，没有用到正则表达式什么的。其实就是调用你的浏览器，然后程序自动帮你打开你的博客网页，隔一段时间自动关闭，以此循环，刷访问量。不多说了，直接贴代码吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import webbrowser as web  </span><br><span class="line">import time  </span><br><span class="line">import os  </span><br><span class="line">import random  </span><br><span class="line">  </span><br><span class="line">count = random.randint(1, 2)  </span><br><span class="line">j = 0  </span><br><span class="line">aa = [80042845,80025162,80035076,80025133,80025068,80024813,79986200,79935658,79933992,79783339,79747976,79747322,79734593,79734363,79706272,79700188,79725018,79724244]  </span><br><span class="line">while j &lt; count:  </span><br><span class="line">    i = 0  </span><br><span class="line">    while i &lt;= 8:  </span><br><span class="line">        k = random.randint(0,17)  </span><br><span class="line">        web.open_new_tab(&apos;https://blog.csdn.net/qian_youyou/article/details/&apos;+str(aa[k]))  </span><br><span class="line">        i = i + 1  </span><br><span class="line">        time.sleep(3)  </span><br><span class="line">    else:  </span><br><span class="line">        time.sleep(20)  </span><br><span class="line">        os.system(&apos;taskkill /F /IM chrome.exe&apos;)  </span><br><span class="line">        # print &apos;time webbrower closed&apos;  </span><br><span class="line">  </span><br><span class="line">    j = j + 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该程序主要是为了增长访问量而写的，主要针对一些访问量与用户信息无关的网页，比如CSDN。当然前提是python安装相应的库。原理很简单，没有用到什么高端的爬虫技术，没有用到正则表达式什么的。其实就是调用你的浏览器，然后程序自动帮你打开你的博客网页，隔一段时间自动关闭，以此循
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="python" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/python/"/>
    
      <category term="爬虫" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/python/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://qianyouyou.cn/tags/python/"/>
    
      <category term="爬虫" scheme="http://qianyouyou.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="前端" scheme="http://qianyouyou.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[杂项项目]C语言打造智能AI小游戏——三子棋</title>
    <link href="http://qianyouyou.cn/2018/04/22/2018-04-22/"/>
    <id>http://qianyouyou.cn/2018/04/22/2018-04-22/</id>
    <published>2018-04-22T13:51:38.000Z</published>
    <updated>2018-05-02T03:40:37.823Z</updated>
    
    <content type="html"><![CDATA[<p>三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3][3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。例如没有走时，9个格的权值为：</p><p>[][][]     3 2 3</p><p>[][][]     2 4 2</p><p>[][][]     3 2 3</p><p>角落有横竖斜三种获胜方法，边有横竖两种方法，中心有横竖两斜4种方法。假如某格有X阻挡，那么权值会相应变化，例如</p><p>[][][]     2 1 2</p><p>[]X[]     1 0 1</p><p>[][][]     2 1 2</p><p>由于有中心阻挡，那么角只有横竖两种方法赢，因此权值为2。但该AI还需继续优化。例如以下：</p><p>[]X[]     1 0 1</p><p>[]0[]     1 0 2</p><p>XX0     0 0 0</p><p>AI面对这种情况，本来下在第一个格子就赢了，但他会选择权值为2的格子。因此我们可以在现有权值条件的情况下，在附加个权值。假如某一格子的路线上已经有AI的子了，那么该条路线上未落子的所有格子权值再加1，如果有两个已落子的AI格子权值就加2。例如以下情况：</p><p>​            原权值       优化权值</p><p>[]X[]     2 0 2          5 0 3</p><p>[]0[]     2 0 2          3 0 4</p><p>[]X0     2 0 0          3 0 0</p><p>第一个格子5是由于斜路线上有两个子，那在原有的基础2上先加1，再加2，所以权值为2+1+2。第2行第3列权值为4，因为横竖两条路线均有1个子，因此权值为2+1+1，其余格子路线上均有1个子，因此权值为2+1。这样落在权值5那个格子上AI就赢了。</p><p>但是仅仅这些判断是不够的。例如：</p><p>​           初始         优化</p><p>X[]X     0 1 0       0 2 0</p><p>[]0[]     1 0 1       2 0 2</p><p>[][]0     1 2 0       2 4 0</p><p>AI会选择权值为4的格子。那此时AI选择权值为2的格子时，你只需要走一步就赢了，AI就输了，因此该AI算法还得继续。</p><p>那么AI可以逆向思考一番，AI可以考虑一下当前情况在计算AI权值的同时再计算一次我们的权值。例如上面例子：</p><p>​           AI权值       你的权值       优化AI      优化你</p><p>X[]X     0 1 0         0 1 0            0 2 0         0 4 0</p><p>[]0[]     1 0 1         1 0 0            2 0 2         2 0 0</p><p>[][]0     1 2 0         1 0 0            2 4 0         2 0 0</p><p>我们把两个权值相加（另外把AI的权值应该再加1，因为AI判断赢要优先于输或平，假如AI方有权值大的，代表一步能赢的，我方也有这种情况，那相加权值相同，AI既可以选择赢棋那一格，也可以选择堵你将要赢的那一格。但AI判断赢要优先于堵对方赢。例子就不举了）：</p><p>​           相加权值       再加1权值</p><p>X[]X     0 6 0            0 7 0</p><p>[]0[]     4 0 2            5 0 3</p><p>[][]0     4 4 0            5 4 0</p><p>因此AI判断到这里就会堵你了。</p><p>AI算法就介绍到这里，至于三子棋程序，由于过于简单，就不过多介绍了。主要介绍AI思想，Windows系统编译的程序。如果是Linux需要把以下代码改下。接下来我就贴上代码，供参考，如有不懂欢迎留言。</p><p>project.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma once  </span><br><span class="line">#define COLUMN 3  </span><br><span class="line">#define ROW 3  </span><br><span class="line">#define GOON 0  </span><br><span class="line">#define WIN -1  </span><br><span class="line">#define DEFEAT 1  </span><br><span class="line">void init(char(*MAP)[COLUMN]);  </span><br><span class="line">int victory(char(*MAP)[COLUMN]);  </span><br><span class="line">bool check(char(*MAP)[COLUMN]);  </span><br><span class="line">void show(char(*MAP)[COLUMN]);  </span><br><span class="line">void check_stemp(char(*MAP)[COLUMN], int *x, int *y);  </span><br><span class="line">void ai_auto(char(*MAP)[COLUMN]);  </span><br><span class="line">int menu();  </span><br><span class="line">int first_hand(char(*MAP)[COLUMN]);  </span><br><span class="line">int ai_hand(char(*MAP)[COLUMN]);  </span><br><span class="line">void play(char(*MAP)[COLUMN]);</span><br></pre></td></tr></table></figure><p>project.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&quot;project.h&quot;  </span><br><span class="line">int vis[ROW][COLUMN];  </span><br><span class="line">int weight[ROW][COLUMN];  </span><br><span class="line">int x, y;  </span><br><span class="line">void init(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; ROW; i++)  </span><br><span class="line">        for (int j = 0; j &lt; COLUMN; j++) &#123;  </span><br><span class="line">            MAP[i][j] = &apos; &apos;;  </span><br><span class="line">            vis[i][j] = 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int victory(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;  </span><br><span class="line">        if (MAP[i][0] == &apos;X&apos;&amp;&amp;MAP[i][1] == &apos;X&apos;&amp;&amp;MAP[i][2] == &apos;X&apos;)  </span><br><span class="line">            return WIN;  </span><br><span class="line">        else if (MAP[i][0] == &apos;O&apos;&amp;&amp;MAP[i][1] == &apos;O&apos;&amp;&amp;MAP[i][2] == &apos;O&apos;)  </span><br><span class="line">            return DEFEAT;  </span><br><span class="line">        if (MAP[0][i] == &apos;X&apos;&amp;&amp;MAP[1][i] == &apos;X&apos;&amp;&amp;MAP[2][i] == &apos;X&apos;)  </span><br><span class="line">            return WIN;  </span><br><span class="line">        else if (MAP[0][i] == &apos;O&apos;&amp;&amp;MAP[1][i] == &apos;O&apos;&amp;&amp;MAP[2][i] == &apos;O&apos;)  </span><br><span class="line">            return DEFEAT;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (MAP[0][0] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][2] == &apos;X&apos;)  </span><br><span class="line">        return WIN;  </span><br><span class="line">    else if (MAP[0][0] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][2] == &apos;O&apos;)  </span><br><span class="line">        return DEFEAT;  </span><br><span class="line">    if (MAP[0][2] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][0] == &apos;X&apos;)  </span><br><span class="line">        return WIN;  </span><br><span class="line">    else if (MAP[0][2] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][0] == &apos;O&apos;)  </span><br><span class="line">        return DEFEAT;  </span><br><span class="line">    return GOON;  </span><br><span class="line">&#125;  </span><br><span class="line">bool check(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; ROW; i++)  </span><br><span class="line">        for (int j = 0; j &lt; COLUMN; j++)  </span><br><span class="line">            if (!vis[i][j])  </span><br><span class="line">                return false;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">void show(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    printf(&quot;-------------\n&quot;);  </span><br><span class="line">    for (int i = 0; i &lt; ROW; i++) &#123;  </span><br><span class="line">        printf(&quot;|&quot;);  </span><br><span class="line">        for (int j = 0; j &lt; COLUMN; j++) &#123;  </span><br><span class="line">            printf(&quot; %c &quot;, MAP[i][j]);  </span><br><span class="line">            printf(&quot;|&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;-------------\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void check_stemp(char(*MAP)[COLUMN], int *x, int *y) &#123;  </span><br><span class="line">    while (*x &gt; 3 || *x &lt;= 0 || *y&gt;3 || *y &lt;= 0 || MAP[*y - 1][*x - 1] != &apos; &apos;) &#123;  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        show(MAP);  </span><br><span class="line">        printf(&quot;Input error, please reenter!\n&quot;);  </span><br><span class="line">        scanf(&quot;%d%d&quot;, x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    MAP[*y - 1][*x - 1] = &apos;X&apos;;  </span><br><span class="line">    vis[*y - 1][*x - 1] = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">void Empowerment(char(*MAP)[COLUMN], int(*weight)[COLUMN], char ai_X, char ai_0, int flag) &#123;  </span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;  </span><br><span class="line">        if (MAP[i][0] != ai_X&amp;&amp;MAP[i][1] != ai_X&amp;&amp;MAP[i][2] != ai_X) &#123;  </span><br><span class="line">            weight[i][0]++;  </span><br><span class="line">            weight[i][1]++;  </span><br><span class="line">            weight[i][2]++;  </span><br><span class="line">            int tmp = 1;  </span><br><span class="line">            for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">                if (MAP[i][j] == ai_0) &#123;  </span><br><span class="line">                    weight[i][0] += tmp+flag;  </span><br><span class="line">                    weight[i][1] += tmp+flag;  </span><br><span class="line">                    weight[i][2] += tmp+flag;  </span><br><span class="line">                    tmp += 10;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (MAP[0][i] != ai_X&amp;&amp;MAP[1][i] != ai_X&amp;&amp;MAP[2][i] != ai_X) &#123;  </span><br><span class="line">            weight[0][i]++;  </span><br><span class="line">            weight[1][i]++;  </span><br><span class="line">            weight[2][i]++;  </span><br><span class="line">            int tmp = 1;  </span><br><span class="line">            for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">                if (MAP[j][i] == ai_0) &#123;  </span><br><span class="line">                    weight[0][i] += tmp+flag;  </span><br><span class="line">                    weight[1][i] += tmp+flag;  </span><br><span class="line">                    weight[2][i] += tmp+flag;  </span><br><span class="line">                    tmp += 10;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (MAP[0][0] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][2] != ai_X) &#123;  </span><br><span class="line">        weight[0][0]++;  </span><br><span class="line">        weight[1][1]++;  </span><br><span class="line">        weight[2][2]++;  </span><br><span class="line">        int tmp = 1;  </span><br><span class="line">        for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">            if (MAP[j][j] == ai_0) &#123;  </span><br><span class="line">                weight[0][0] += tmp+flag;  </span><br><span class="line">                weight[1][1] += tmp+flag;  </span><br><span class="line">                weight[2][2] += tmp+flag;  </span><br><span class="line">                tmp += 10;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (MAP[0][2] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][0] != ai_X) &#123;  </span><br><span class="line">        weight[0][2]++;  </span><br><span class="line">        weight[1][1]++;  </span><br><span class="line">        weight[2][0]++;  </span><br><span class="line">        int tmp = 1;  </span><br><span class="line">        for (int j = 0; j &lt; 3; j++)  </span><br><span class="line">            if (MAP[j][2 - j] == ai_0) &#123;  </span><br><span class="line">                weight[0][2] += tmp+flag;  </span><br><span class="line">                weight[1][1] += tmp+flag;  </span><br><span class="line">                weight[2][0] += tmp+flag;  </span><br><span class="line">                tmp += 10;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void ai_auto(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    int weight[3][3] = &#123; 0 &#125;;  </span><br><span class="line">    Empowerment(MAP, weight, &apos;X&apos;, &apos;O&apos;, 1);  </span><br><span class="line">    Empowerment(MAP, weight, &apos;O&apos;, &apos;X&apos;, 0);  </span><br><span class="line">    int maxn = -1;  </span><br><span class="line">    int maxm = -1;  </span><br><span class="line">    for (int i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (int j = 0; j &lt; 3; j++) &#123;  </span><br><span class="line">            if (vis[i][j])  </span><br><span class="line">                weight[i][j] = -1;  </span><br><span class="line">            if (maxn &lt; weight[i][j]) &#123;  </span><br><span class="line">                maxn = weight[i][j];  </span><br><span class="line">                maxm = i * 3 + j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    MAP[maxm / 3][maxm % 3] = &apos;O&apos;;  </span><br><span class="line">    vis[maxm / 3][maxm % 3] = 1;  </span><br><span class="line">&#125;  </span><br><span class="line">int menu() &#123;  </span><br><span class="line">    int tmp;  </span><br><span class="line">    printf(&quot;*************************************************************\n&quot;);  </span><br><span class="line">    printf(&quot;* Please enter: * 1:First hand * 2.Back hand * Others:Close *\n&quot;);  </span><br><span class="line">    printf(&quot;*************************************************************\n&quot;);  </span><br><span class="line">    scanf(&quot;%d&quot;, &amp;tmp);  </span><br><span class="line">    return tmp;  </span><br><span class="line">&#125;  </span><br><span class="line">int first_hand(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP);  </span><br><span class="line">    printf(&quot;Please enter:x y\n&quot;);  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);  </span><br><span class="line">    check_stemp(MAP, &amp;x, &amp;y);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP);  </span><br><span class="line">    if (victory(MAP) == WIN) &#123;  </span><br><span class="line">        printf(&quot;Congratulations on your victory, you are as smart as Qianyouyou.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (check(MAP)) &#123;  </span><br><span class="line">        printf(&quot;Draw.As smart as me.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">int ai_hand(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    ai_auto(MAP);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP);  </span><br><span class="line">    if (victory(MAP) == DEFEAT) &#123;  </span><br><span class="line">        printf(&quot;You lose, you&apos;re as stupid as a pig.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (check(MAP)) &#123;  </span><br><span class="line">        printf(&quot;Draw.As smart as me.\n&quot;);  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void play(char(*MAP)[COLUMN]) &#123;  </span><br><span class="line">    while (!check(MAP) || victory(MAP) == GOON) &#123;  </span><br><span class="line">        if (first_hand(MAP))  </span><br><span class="line">            break;  </span><br><span class="line">        if (ai_hand(MAP))  </span><br><span class="line">            break;  </span><br><span class="line">    &#125;  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&quot;project.h&quot;  </span><br><span class="line">char MAP[ROW][COLUMN];  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    char str[2];  </span><br><span class="line">    do &#123;  </span><br><span class="line">        init(MAP);  </span><br><span class="line">        switch (menu()) &#123;  </span><br><span class="line">        case 1:  </span><br><span class="line">            first_hand(MAP);  </span><br><span class="line">        case 2: &#123;  </span><br><span class="line">            ai_hand(MAP);  </span><br><span class="line">            play(MAP);  </span><br><span class="line">        &#125;  </span><br><span class="line">        default: &#123;  </span><br><span class="line">            printf(&quot;Do you need to start again?(Y/N)&quot;);  </span><br><span class="line">            scanf(&quot;%s&quot;, str);  </span><br><span class="line">        &#125;break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; while (str[0] == &apos;Y&apos; || str[0] == &apos;y&apos;);  </span><br><span class="line">    printf(&quot;Thank you for using!\n&quot;);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3][3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="小程序" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="AI" scheme="http://qianyouyou.cn/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>[排序]求解第k大分值</title>
    <link href="http://qianyouyou.cn/2018/04/21/2018-04-21/"/>
    <id>http://qianyouyou.cn/2018/04/21/2018-04-21/</id>
    <published>2018-04-21T15:42:03.000Z</published>
    <updated>2018-05-02T12:07:43.468Z</updated>
    
    <content type="html"><![CDATA[<p>描述：</p><p>Arch0n老师is a rich man, 他靠自己的才华和智商年纪轻轻就赚了不少钱。为了训练自己的智商，他经常玩一些interesting的游戏来训练自己的智商，比如什么RGB游戏，还有和妹子一块玩Don’t Starve。</p><p>言归正传，今天他又发明了一个新的interesting game。Ar老师手上有一堆卡牌，然后卡牌上写了一个数字Ai(正整数)，当前他有n张牌，然后他总是随机取出两张来，然后他一眼就能看出这两牌中哪一张小（相同就取相同的，这操作好像对于Ar老师来说太简单了），作为这两张牌的有效分值，然后呢他陷入了沉思，对于n张牌取两张牌显然有确定的组合可能性，有n<em>(n-1)/2对组合，然后他想知道所有这些组合中第k大的分值是多少。输入描述:输入一个t表示数据组数；(0&lt;t&lt;=10)接下来一行是n,k,表示n张牌和最后第k大的分值；（1&lt;n&lt;2500,保证0&lt;k&lt;=n</em>(n-1)/2）接下来一行是n个值ai，表示第i张牌上的数字(0 &lt; ai &lt;= 10000000)。输出描述:每组数据输出一行，即第k大的分值为多少。</p><p>示例</p><p>输入</p><p>2</p><p>3 2</p><p>1 2 3</p><p>3 1</p><p>4 2 1</p><p>输出</p><p>1</p><p>2</p><p>题解：</p><p>首先将这n个数进行从大到小排序，a[0]储存第1大，a[1]储存第2大……第2个和第1个比较最小的是第2个，第3个和前两个比较较小的均是第3个，第4个和前3个比较均是第4个，以此递推，第n个数和n前n-1个比较均是n较小。将所有情况全排列很容易超时，因此我们可以从第k大这个k下手。由于a[0]最大，因此a[0]和任意比较都不会输出a[0]。那么首先k为1输出a[1],1&lt;k&lt;=1+2输出a[2],1+2&lt;k&lt;=1+2+3输出a[3]……现在应该很清楚了吧。可以设置一个变量cnt，和i,从1开始，cnt每次加1，i每次加cnt，直到i加到比k大或者等于时，那么此时的a[cnt]就是第k大的数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;algorithm&gt;  </span><br><span class="line">int cmp(int a, int b) &#123;  </span><br><span class="line">    return a &gt; b;  </span><br><span class="line">&#125;  </span><br><span class="line">int T, N, k, a[100010];  </span><br><span class="line">using namespace std;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    cin &gt;&gt; T;  </span><br><span class="line">    while (T--) &#123;  </span><br><span class="line">        cin &gt;&gt; N &gt;&gt; k;  </span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;  </span><br><span class="line">            cin &gt;&gt; a[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        sort(a, a + N, cmp);  </span><br><span class="line">        int cnt = 1, i = 1;  </span><br><span class="line">        for (int i = 1; i &lt; k; i += cnt) &#123;  </span><br><span class="line">            cnt++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        cout &lt;&lt; a[cnt] &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;Arch0n老师is a rich man, 他靠自己的才华和智商年纪轻轻就赚了不少钱。为了训练自己的智商，他经常玩一些interesting的游戏来训练自己的智商，比如什么RGB游戏，还有和妹子一块玩Don’t Starve。&lt;/p&gt;
&lt;p&gt;言归正传
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序" scheme="http://qianyouyou.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[杂项项目]C语言实现小游戏——控制台扫雷</title>
    <link href="http://qianyouyou.cn/2018/04/20/2018-04-20-3/"/>
    <id>http://qianyouyou.cn/2018/04/20/2018-04-20-3/</id>
    <published>2018-04-20T15:01:26.000Z</published>
    <updated>2018-05-02T03:56:32.620Z</updated>
    
    <content type="html"><![CDATA[<p>程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌。此处用到了dfs。仅供参考。</p><p>项目版：</p><p>mine.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma once  </span><br><span class="line">#define BOOM 10  </span><br><span class="line">#define SIZE 10  </span><br><span class="line">void init(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b);//初始化扫雷页面</span><br><span class="line">void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j);//如果展开面为0，通过深搜将周围所以为0的区域展开  </span><br><span class="line">int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//判断胜利条件  </span><br><span class="line">void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//展示扫雷页面</span><br></pre></td></tr></table></figure><p>mine.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&lt;time.h&gt;  </span><br><span class="line">#include&quot;mine.h&quot;  </span><br><span class="line">int stemp[8][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123; 1,1 &#125;,&#123; -1,-1 &#125;,&#123; 1,-1 &#125;,&#123; -1,1 &#125; &#125;;//深搜时上下左右四个方向搜索  </span><br><span class="line">void init(char (*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b) &#123;  </span><br><span class="line">    int x, y;  </span><br><span class="line">    visit[a][b] = 0;  </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">        do &#123;  </span><br><span class="line">            x = rand() % SIZE + 1;  </span><br><span class="line">            y = rand() % SIZE + 1;  </span><br><span class="line">        &#125; while (visit[x][y] == 0);  </span><br><span class="line">        if (visit[x][y] == -1) &#123;  </span><br><span class="line">            visit[x][y] == 0;  </span><br><span class="line">            MAP[x][y] = &apos;*&apos;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (MAP[i][j] != &apos;*&apos;) &#123;  </span><br><span class="line">                MAP[i][j] = &apos;0&apos;;  </span><br><span class="line">                for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">                    if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;)  </span><br><span class="line">                        MAP[i][j]++;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j) &#123;  </span><br><span class="line">    visit[i][j] = 1;  </span><br><span class="line">    for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">        if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            dfs(MAP, visit, i + stemp[k][0], j + stemp[k][1]);  </span><br><span class="line">        else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            visit[i + stemp[k][0]][j + stemp[k][1]] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123;  </span><br><span class="line">    if (MAP[x][y] == &apos;*&apos;) &#123;  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (MAP[x][y] == &apos;0&apos;) &#123;  </span><br><span class="line">        dfs(MAP, visit, x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">    int temp = 0;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++)  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == -1)  </span><br><span class="line">                temp++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    if (temp == BOOM)  </span><br><span class="line">        return 2;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123;  </span><br><span class="line">    printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    for (int i = 0; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        printf(&quot;|&quot;);  </span><br><span class="line">        for (int j = 0; j &lt;= SIZE + 1; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == 1) &#123;  </span><br><span class="line">                printf(&quot; %c &quot;, MAP[i][j]);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                printf(&quot;   &quot;);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&lt;time.h&gt;  </span><br><span class="line">#include&quot;mine.h&quot;  </span><br><span class="line">char MAP[SIZE + 2][SIZE + 2];  </span><br><span class="line">int visit[SIZE + 2][SIZE + 2];  </span><br><span class="line">int x, y;//坐标  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    srand(time(0));  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    MAP[0][0] = &apos; &apos;;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        MAP[0][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][0] = &apos;a&apos; + i - 1;  </span><br><span class="line">        MAP[SIZE + 1][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][SIZE + 1] = &apos;a&apos; + i - 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    show(MAP, visit, x, y);  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;y, &amp;x);  </span><br><span class="line">    init(MAP,visit, x, y);  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    check(MAP, visit, x, y);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show(MAP, visit, x, y);  </span><br><span class="line">    while (MAP[x][y] != &apos;*&apos;) &#123;  </span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;y, &amp;x);  </span><br><span class="line">        int res = check(MAP, visit, x, y);  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        show(MAP, visit, x, y);  </span><br><span class="line">        if (res == 2) &#123;  </span><br><span class="line">            printf(&quot;Win\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else if (res == 1) &#123;  </span><br><span class="line">            printf(&quot;Lose\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180422105418722" alt="img"></p><p>另附原始版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#include&lt;time.h&gt;  </span><br><span class="line">#define BOOM 10  </span><br><span class="line">#define SIZE 10  </span><br><span class="line">char MAP[SIZE + 2][SIZE + 2];  </span><br><span class="line">int visit[SIZE + 2][SIZE + 2];  </span><br><span class="line">int x, y;  </span><br><span class="line">int stemp[8][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;, &#123;-1,1&#125; &#125;;  </span><br><span class="line">void init(int a, int b) &#123;  </span><br><span class="line">    int x, y;  </span><br><span class="line">    visit[a][b] = 0;  </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;  </span><br><span class="line">        do &#123;  </span><br><span class="line">            x = rand() % SIZE + 1;  </span><br><span class="line">            y = rand() % SIZE + 1;  </span><br><span class="line">        &#125; while (visit[x][y] == 0);  </span><br><span class="line">        if (visit[x][y] == -1) &#123;  </span><br><span class="line">            visit[x][y] == 0;  </span><br><span class="line">            MAP[x][y] = &apos;*&apos;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (MAP[i][j] != &apos;*&apos;) &#123;  </span><br><span class="line">                MAP[i][j] = &apos;0&apos;;  </span><br><span class="line">                for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">                    if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;)  </span><br><span class="line">                        MAP[i][j]++;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void dfs(int i, int j) &#123;  </span><br><span class="line">    visit[i][j] = 1;  </span><br><span class="line">    for (int k = 0; k &lt; 8; k++) &#123;  </span><br><span class="line">        if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            dfs(i + stemp[k][0], j + stemp[k][1]);  </span><br><span class="line">        else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1)  </span><br><span class="line">            visit[i + stemp[k][0]][j + stemp[k][1]] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int check() &#123;  </span><br><span class="line">    if (MAP[x][y] == &apos;*&apos;) &#123;  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">        return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else if (MAP[x][y] == &apos;0&apos;) &#123;  </span><br><span class="line">        dfs(x, y);  </span><br><span class="line">    &#125;  </span><br><span class="line">    else  </span><br><span class="line">        visit[x][y] = 1;  </span><br><span class="line">    int temp = 0;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++)  </span><br><span class="line">        for (int j = 1; j &lt;= SIZE; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == -1)  </span><br><span class="line">                temp++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    if (temp == BOOM)  </span><br><span class="line">        return 2;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void show() &#123;  </span><br><span class="line">    printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    for (int i = 0; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        printf(&quot;|&quot;);  </span><br><span class="line">        for (int j = 0; j &lt;= SIZE + 1; j++) &#123;  </span><br><span class="line">            if (visit[i][j] == 1) &#123;  </span><br><span class="line">                printf(&quot; %c &quot;, MAP[i][j]);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                printf(&quot;   &quot;);  </span><br><span class="line">                printf(&quot;|&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;-------------------------------------------------\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    srand(time(0));  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    MAP[0][0] = &apos; &apos;;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE; i++) &#123;  </span><br><span class="line">        MAP[0][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][0] = &apos;a&apos; + i - 1;  </span><br><span class="line">        MAP[SIZE + 1][i] = &apos;A&apos; + i - 1;  </span><br><span class="line">        MAP[i][SIZE + 1] = &apos;a&apos; + i - 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    show();  </span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);  </span><br><span class="line">    init(x, y);  </span><br><span class="line">    memset(visit, -1, sizeof(visit));  </span><br><span class="line">    for (int i = 1; i &lt;= SIZE + 1; i++) &#123;  </span><br><span class="line">        visit[0][i] = 1;  </span><br><span class="line">        visit[i][0] = 1;  </span><br><span class="line">        visit[SIZE + 1][i] = 1;  </span><br><span class="line">        visit[i][SIZE + 1] = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    check();  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    show();  </span><br><span class="line">    while (MAP[x][y] != &apos;*&apos;) &#123;  </span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);  </span><br><span class="line">        int res = check();  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        show();  </span><br><span class="line">        if (res == 2) &#123;  </span><br><span class="line">            printf(&quot;Win\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else if (res == 1) &#123;  </span><br><span class="line">            printf(&quot;Lose\n&quot;);  </span><br><span class="line">            system(&quot;pause&quot;);  </span><br><span class="line">            return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="小程序" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[杂项项目]纯C语言实现随机生成数独九宫格</title>
    <link href="http://qianyouyou.cn/2018/04/20/2018-04-20-2/"/>
    <id>http://qianyouyou.cn/2018/04/20/2018-04-20-2/</id>
    <published>2018-04-20T14:53:45.000Z</published>
    <updated>2018-05-02T03:54:20.228Z</updated>
    
    <content type="html"><![CDATA[<p>一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">  </span><br><span class="line">void main()  </span><br><span class="line">&#123;  </span><br><span class="line">    int a[9][9] = &#123; 0 &#125;;  </span><br><span class="line">    int *p[3][3], *m[3][6], *n[3][6], *r[9][4], *aa[9][9];  </span><br><span class="line">    int **q[9];  </span><br><span class="line">    int i, j, k, l, h, t, s = 0;  </span><br><span class="line">    void rank(int *x, int *y);  </span><br><span class="line">    bool check(int a[9][9], int n);  </span><br><span class="line">    srand((int)time(0));  </span><br><span class="line">  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (j = 0; j &lt; 3; j++)  </span><br><span class="line">            p[i][j] = &amp;a[i * 3 + 1][j * 3 + 1];  </span><br><span class="line">    for (k = 0; k &lt; 9; k++)  </span><br><span class="line">        q[k] = &amp;p[k / 3][k % 3];  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (j = 0; j &lt; 6; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m[i][j] = &amp;a[i * 3 + 1][2 * j - j / 2];  </span><br><span class="line">            n[i][j] = &amp;a[2 * j - j / 2][i * 3 + 1];  </span><br><span class="line">        &#125;  </span><br><span class="line">    for (k = 0; k &lt; 9; k++)  </span><br><span class="line">        for (l = 0; l &lt; 4; l++)  </span><br><span class="line">            r[k][l] = &amp;a[(k / 3) * 3 + (l / 2) * 2][(k % 3) * 3 + (l % 2) * 2];  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">        for (j = 0; j &lt; 9; j++)  </span><br><span class="line">            aa[i][j] = &amp;a[i][j];  </span><br><span class="line">step1:  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">    next1:  </span><br><span class="line">        **q[i] = rand() % 10;  </span><br><span class="line">        if (**q[i] == 0)  </span><br><span class="line">            goto next1;  </span><br><span class="line">        for (j = 0; j &lt; i; j++)  </span><br><span class="line">            if (**q[j] == **q[i])  </span><br><span class="line">                goto next1;  </span><br><span class="line">    &#125;  </span><br><span class="line">step2:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">        for (j = 0; j &lt; 6; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">        next2:  </span><br><span class="line">            *m[i][j] = rand() % 10;  </span><br><span class="line">            if (*m[i][j] == 0)  </span><br><span class="line">                goto next2;  </span><br><span class="line">            for (k = 0; k &lt; 3; k++)  </span><br><span class="line">                if (*m[i][j] == *p[i][k])  </span><br><span class="line">                    goto next2;  </span><br><span class="line">            for (k = 0; k &lt; j; k++)  </span><br><span class="line">                if (*m[i][j] == *m[i][k])  </span><br><span class="line">                    goto next2;  </span><br><span class="line">            for (k = 0; k &lt; i; k++)  </span><br><span class="line">                if (*m[i][j] == *m[k][j])  </span><br><span class="line">                    goto step2;  </span><br><span class="line">        &#125;  </span><br><span class="line">step3:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">    next4:  </span><br><span class="line">        for (j = 0; j &lt; 6; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">        next3:  </span><br><span class="line">            *n[i][j] = rand() % 10;  </span><br><span class="line">            if (*n[i][j] == 0)  </span><br><span class="line">                goto next3;  </span><br><span class="line">            for (k = 0; k &lt; 3; k++)  </span><br><span class="line">                if (*n[i][j] == *p[k][i])  </span><br><span class="line">                    goto next3;  </span><br><span class="line">            for (k = 0; k &lt; j; k++)  </span><br><span class="line">                if (*n[i][j] == *n[i][k])  </span><br><span class="line">                    goto next3;  </span><br><span class="line">            for (l = 0; l &lt; 2; l++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                if (*n[i][j] == *m[j / 2][i * 2 + l])  </span><br><span class="line">                    goto next4;  </span><br><span class="line">            &#125;  </span><br><span class="line">            for (k = 0; k &lt; i; k++)  </span><br><span class="line">                if (*n[i][j] == *n[k][j])  </span><br><span class="line">                    goto step3;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">step4:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (h = 0; h &lt; 2; h++)  </span><br><span class="line">        &#123;  </span><br><span class="line">        next6:  </span><br><span class="line">            for (l = 0; l &lt; 3; l++)  </span><br><span class="line">                for (j = 0; j &lt; 2; j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                next5:  </span><br><span class="line">                    *r[i * 3 + l][h * 2 + j] = rand() % 10;  </span><br><span class="line">                    if (*r[i * 3 + l][h * 2 + j] == 0)  </span><br><span class="line">                        goto next5;  </span><br><span class="line">                    if (*r[i * 3 + l][h * 2 + j] == **q[i * 3 + l])  </span><br><span class="line">                        goto next5;  </span><br><span class="line">                    for (k = 0; k &lt; h * 2 + j; k++)  </span><br><span class="line">                        if (*r[i * 3 + l][h * 2 + j] == *r[i * 3 + l][k])  </span><br><span class="line">                            goto next5;  </span><br><span class="line">                    for (k = 0; k &lt; 2; k++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        if (*r[i * 3 + l][h * 2 + j] == *m[i][l * 2 + k])  </span><br><span class="line">                            goto next5;  </span><br><span class="line">                        if (*r[i * 3 + l][h * 2 + j] == *n[l][i * 2 + k])  </span><br><span class="line">                            goto next5;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    for (k = 0; k &lt;= l * 3 + j * 2; k++)  </span><br><span class="line">                        for (t = 0; t &lt; k; t++)  </span><br><span class="line">                            if (a[i * 3 + h * 2][k] == a[i * 3 + h * 2][t])  </span><br><span class="line">                                goto next6;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">step5:  </span><br><span class="line">    for (i = 0; i &lt; 3; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (j = 0; j &lt; 9; j++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                if (check(a, i) == false)  </span><br><span class="line">                    rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                else if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (j = 0; j &lt; 9; j++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (k = 8; k &gt; j; k--)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                    rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                    if (check(a, i) == false)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                        rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    else if (check(a, i) == true)  </span><br><span class="line">                        break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (l = 0; l &lt; 9; l++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (j = l + 1; j &lt; 9; j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    for (k = 8; k &gt; j; k--)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                        rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                        rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                        if (check(a, i) == false)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        else if (check(a, i) == true)  </span><br><span class="line">                            break;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (check(a, i) == true)  </span><br><span class="line">                        break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">        &#123;  </span><br><span class="line">            for (l = 0; l &lt; 6; l++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                for (h = l + 1; h &lt; 7; h++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    for (j = h + 1; j &lt; 8; j++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        for (k = 8; k &gt; j; k--)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[h][i * 3], aa[h][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                            rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                            if (check(a, i) == false)  </span><br><span class="line">                            &#123;  </span><br><span class="line">                                rank(aa[l][i * 3], aa[l][i * 3 + 2]);  </span><br><span class="line">                                rank(aa[h][i * 3], aa[h][i * 3 + 2]);  </span><br><span class="line">                                rank(aa[j][i * 3], aa[j][i * 3 + 2]);  </span><br><span class="line">                                rank(aa[k][i * 3], aa[k][i * 3 + 2]);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            else if (check(a, i) == true)  </span><br><span class="line">                                break;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        if (check(a, i) == true)  </span><br><span class="line">                            break;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (check(a, i) == true)  </span><br><span class="line">                        break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                if (check(a, i) == true)  </span><br><span class="line">                    break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (check(a, i) == false)  </span><br><span class="line">            goto step4;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    printf(&quot;+---------------+---------------+---------------+\n&quot;);  </span><br><span class="line">    printf(&quot;|               |               |               |\n&quot;);  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;|   &quot;);  </span><br><span class="line">        for (j = 0; j &lt; 9; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            printf(&quot;%-4d&quot;, a[i][j]);  </span><br><span class="line">            if ((j + 1) % 3 == 0)  </span><br><span class="line">                printf(&quot;|   &quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n&quot;);  </span><br><span class="line">        printf(&quot;|               |               |               |\n&quot;);  </span><br><span class="line">        if ((i + 1) % 3 == 0)  </span><br><span class="line">        &#123;  </span><br><span class="line">            printf(&quot;+---------------+---------------+---------------+\n&quot;);  </span><br><span class="line">            if (i &lt; 8)  </span><br><span class="line">                printf(&quot;|               |               |               |\n&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void rank(int *x, int *y)  </span><br><span class="line">&#123;  </span><br><span class="line">    int t;  </span><br><span class="line">    t = *x;  </span><br><span class="line">    *x = *y;  </span><br><span class="line">    *y = t;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">bool check(int a[9][9], int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i, j;  </span><br><span class="line">    for (i = 0; i &lt; 9; i++)  </span><br><span class="line">        for (j = 0; j &lt; i; j++)  </span><br><span class="line">            if (a[i][n * 3] == a[j][n * 3])  </span><br><span class="line">                return false;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="小程序" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[杂项项目]纯C语言实现控制台小游戏——数字拼图</title>
    <link href="http://qianyouyou.cn/2018/04/20/2018-04-20/"/>
    <id>http://qianyouyou.cn/2018/04/20/2018-04-20/</id>
    <published>2018-04-20T14:48:10.000Z</published>
    <updated>2018-05-02T03:53:47.153Z</updated>
    
    <content type="html"><![CDATA[<p>一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;math.h&gt;  </span><br><span class="line">#include &lt;time.h&gt;  </span><br><span class="line">#define max 10  </span><br><span class="line">int x, y, step, label = 0;  </span><br><span class="line">typedef struct score &#123;  </span><br><span class="line">    int steps, steps2;  </span><br><span class="line">    double times;  </span><br><span class="line">    char name[18];  </span><br><span class="line">&#125;score;  </span><br><span class="line">score sco[max + 1];  </span><br><span class="line">char ch, buff[3];  </span><br><span class="line">bool flag, flag1 = false;  </span><br><span class="line">clock_t start, finish;  </span><br><span class="line">bool over()&#123;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n\n\t\t\t您共用了 %d 步 ,耗时 %.3f 分钟\n&quot;, step, (double)(finish - start) / 40000);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n\n\n\n\n\n\t*******************  您是否重新开始游戏 (Y/N) ?  *******************\n\n&quot;);  </span><br><span class="line">    scanf(&quot;%s&quot;, buff);  </span><br><span class="line">    ch = buff[0];  </span><br><span class="line">    if (ch != &apos;n&apos;&amp;&amp;ch != &apos;N&apos;) &#123;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    else &#123;  </span><br><span class="line">        printf(&quot;\n\n\n\n\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n&quot;);  </span><br><span class="line">        printf(&quot;\t+++++++++++++++++++++++++   感谢您的使用   +++++++++++++++++++++++++\n&quot;, step);  </span><br><span class="line">                printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;);  </span><br><span class="line">        system(&quot;pause&quot;);  </span><br><span class="line">        exit(0);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">void rank(score sco[],int n) &#123;  </span><br><span class="line">    int i, j;  </span><br><span class="line">    sco[0] = sco[n];  </span><br><span class="line">    for (i = 0; i &lt; n; i++)  </span><br><span class="line">        if (sco[n].steps2&gt;sco[i].steps2) &#123;  </span><br><span class="line">            for (j = n; j &gt; i; j--)  </span><br><span class="line">                sco[j] = sco[j - 1];  </span><br><span class="line">            sco[i] = sco[0];  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    for (j = i - 1; j &gt; 0; j--)  </span><br><span class="line">        if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps &lt; sco[j].steps)  </span><br><span class="line">            sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j;  </span><br><span class="line">        else if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps == sco[j].steps)  </span><br><span class="line">            if (sco[i].times &lt; sco[j].times)  </span><br><span class="line">                sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j;  </span><br><span class="line">&#125;  </span><br><span class="line">int check2(int *p, int n) &#123;  </span><br><span class="line">    int i, j, flag2 = 0;  </span><br><span class="line">    for (i = 1; i &lt; n*n - 1; i++)   </span><br><span class="line">        for (j = 0; j &lt; i; j++)   </span><br><span class="line">            if (p[j] &gt; p[i])  </span><br><span class="line">                flag2++;  </span><br><span class="line">    if (!flag2)  </span><br><span class="line">        return 0;  </span><br><span class="line">    else if (flag2 % 2 == 0)  </span><br><span class="line">        return 2;  </span><br><span class="line">    else  </span><br><span class="line">        return 1;  </span><br><span class="line">&#125;  </span><br><span class="line">bool check(int *p,int n) &#123;  </span><br><span class="line">    int i;  </span><br><span class="line">    flag = true;  </span><br><span class="line">    for (i = 0; i&lt;n*n - 1; i++)  </span><br><span class="line">        if (p[i] != i + 1)  </span><br><span class="line">            flag = false;  </span><br><span class="line">    if (flag) &#123;  </span><br><span class="line">        flag1 = false;  </span><br><span class="line">        return false;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line">int operation(int *p,int n) &#123;  </span><br><span class="line">    scanf(&quot;%s&quot;, buff);  </span><br><span class="line">    ch = buff[0];  </span><br><span class="line">    if (ch &gt;= &apos;a&apos;&amp;&amp;ch &lt;= &apos;z&apos;)  </span><br><span class="line">        ch -= 32;  </span><br><span class="line">    switch (ch) &#123;  </span><br><span class="line">    case &apos;A&apos;: if (y == n - 1) return 1;  </span><br><span class="line">        p[x*n + y] = p[x*n + y + 1];  </span><br><span class="line">        p[x*n + y + 1] = 0;  </span><br><span class="line">        y++;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;W&apos;: if (x == n - 1) return 1;  </span><br><span class="line">        p[x*n + y] = p[(x + 1)*n + y];  </span><br><span class="line">        p[(x + 1)*n + y] = 0;  </span><br><span class="line">        x++;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;D&apos;: if (y == 0) return 1;  </span><br><span class="line">        p[x*n + y] = p[x*n + y - 1];  </span><br><span class="line">        p[x*n + y - 1] = 0;  </span><br><span class="line">        y--;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;S&apos;: if (x == 0) return 1;  </span><br><span class="line">        p[x*n + y] = p[(x - 1)*n + y];  </span><br><span class="line">        p[(x - 1)*n + y] = 0;  </span><br><span class="line">        x--;  </span><br><span class="line">        step++;  </span><br><span class="line">        return 1;  </span><br><span class="line">    case &apos;R&apos;: return 2;  </span><br><span class="line">    case &apos;M&apos;: return 3;  </span><br><span class="line">    case &apos;Q&apos;: printf(&quot;\n\n\t********************* 您是否要离开游戏 (Y/N) ? *********************\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%s&quot;, buff);  </span><br><span class="line">        ch = buff[0];  </span><br><span class="line">        if (ch == &apos;y&apos; || ch == &apos;Y&apos;)  </span><br><span class="line">            return 4;  </span><br><span class="line">        else  </span><br><span class="line">            return 1;  </span><br><span class="line">    default: return 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void map(int *p, int n) &#123;  </span><br><span class="line">    int i, j;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n&quot;);  </span><br><span class="line">    for (i = 0; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;\t&quot;);  </span><br><span class="line">        for (j = 0; j &lt; n; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            if (p[n*i + j] != 0)  </span><br><span class="line">                printf(&quot;%-4d&quot;, p[n*i + j]);  </span><br><span class="line">            else  </span><br><span class="line">                printf(&quot;    &quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        printf(&quot;\n\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;\n\t按方向键移动卡片至无卡片的地方  W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;);  </span><br><span class="line">    finish = clock();  </span><br><span class="line">    printf(&quot;\n\t\t\t\t步数: %d\t 使用时间: %.3f 分钟 \n\n&quot;, step, (double)(finish - start) / 40000);  </span><br><span class="line">&#125;  </span><br><span class="line">void reset(int *p, int n) &#123;  </span><br><span class="line">    int i, j, flag2;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    do &#123;  </span><br><span class="line">        for (i = 0; i &lt; n*n - 1; i++) &#123;  </span><br><span class="line">            do &#123;  </span><br><span class="line">                flag2 = 1;  </span><br><span class="line">                p[i] = rand() % (n*n - 1) + 1;  </span><br><span class="line">                for (j = 0; j &lt; i; j++)  </span><br><span class="line">                    if (p[i] == p[j])  </span><br><span class="line">                        flag2 = 0;  </span><br><span class="line">            &#125; while (!flag2);  </span><br><span class="line">        &#125;  </span><br><span class="line">        flag2 = check2(p, n);  </span><br><span class="line">        if (flag2 == 1) &#123;  </span><br><span class="line">            flag2 = p[n*n - 2];  </span><br><span class="line">            p[n*n - 2] = p[n*n - 3];  </span><br><span class="line">            p[n*n - 3] = flag2;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; while (!flag2);  </span><br><span class="line">    p[n*n - 1] = 0;  </span><br><span class="line">    for (i = 0; i&lt;n; i++)  </span><br><span class="line">        for (j = 0; j&lt;n; j++)  </span><br><span class="line">            if (p[i*n + j] == 0)&#123;  </span><br><span class="line">                x = i;  </span><br><span class="line">                y = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void help() &#123;  </span><br><span class="line">    int i = 0;  </span><br><span class="line">    system(&quot;cls&quot;);  </span><br><span class="line">    printf(&quot;\n\n\n\n\t--------------------------------+ 基本操作 +--------------------------------\n\n&quot;);  </span><br><span class="line">    printf(&quot;\n\n\t按方向键移动卡片至无卡片的地方  W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;);  </span><br><span class="line">    printf(&quot;\n\n\t---------------------------+ 浅悠悠（王骏）制作 +---------------------------\n\n&quot;);  </span><br><span class="line">    if (label == 0)  </span><br><span class="line">        printf(&quot;\n\n\t--------------------------+ 暂时没有任何游戏记录 +--------------------------\n\n&quot;);  </span><br><span class="line">    else  </span><br><span class="line">        for (i = 1; i &lt;= label; i++)  </span><br><span class="line">            printf(&quot;\n\n\t  第%02d名：%-18s  步数：%-5d   阶数：%-5d   时间：%-6.3lf分钟\n\n&quot;,  </span><br><span class="line">                i, sco[i].name, sco[i].steps, sco[i].steps2, sco[i].times);  </span><br><span class="line">    printf(&quot;\n\n\t----------------------------+ 按任意键返回菜单 +----------------------------\n\n&quot;);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">void game() &#123;  </span><br><span class="line">    int n, *p;  </span><br><span class="line">    int mark;  </span><br><span class="line">    do &#123;  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        printf(&quot;\n\n\n\n\t------------------+ 请输入阶数（推荐3——20阶） +------------------\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);  </span><br><span class="line">        if (n &gt; 1)  </span><br><span class="line">            p = (int*)calloc(n*n, sizeof(int));  </span><br><span class="line">        else  </span><br><span class="line">            printf(&quot;\t********************** 您输入有误，请重新输入 **********************\n\n&quot;), system(&quot;pause&quot;);  </span><br><span class="line">    &#125; while (n &lt;= 1);  </span><br><span class="line">next1:  </span><br><span class="line">    step = 0;  </span><br><span class="line">    start = clock();  </span><br><span class="line">    reset(p, n);  </span><br><span class="line">next2:  </span><br><span class="line">    map(p, n);  </span><br><span class="line">    if (check(p, n) == false) &#123;  </span><br><span class="line">        printf(&quot;\n\n\t=================+ 恭喜您完成游戏，请输入您的姓名 +=================\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%s&quot;, sco[++label].name);  </span><br><span class="line">        sco[label].steps = step;  </span><br><span class="line">        sco[label].steps2 = n;  </span><br><span class="line">        sco[label].times = (double)(finish - start) / 40000;  </span><br><span class="line">        rank(sco, label);  </span><br><span class="line">        if (over() == false)  </span><br><span class="line">            return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mark = operation(p, n);  </span><br><span class="line">    if (mark == 1)  </span><br><span class="line">        goto next2;  </span><br><span class="line">    else if (mark == 2)  </span><br><span class="line">        goto next1;  </span><br><span class="line">    else if (mark == 3)  </span><br><span class="line">        return;  </span><br><span class="line">    else if (mark == 4)  </span><br><span class="line">        if (over() == false)  </span><br><span class="line">            return;  </span><br><span class="line">    free(p);  </span><br><span class="line">&#125;  </span><br><span class="line">int main()&#123;  </span><br><span class="line">    srand((int)time(0));      </span><br><span class="line">    do &#123;  </span><br><span class="line">        system(&quot;cls&quot;);  </span><br><span class="line">        printf(&quot;\t-------------+ 欢迎来到浅悠悠数字拼图，请选择您的操作 +-------------\n\n&quot;);  </span><br><span class="line">        printf(&quot;\t-----+  1.开始游戏  +-----+  2.帮助  +-----+  0(或其他).退出  +-----\n\n&quot;);  </span><br><span class="line">        printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;);  </span><br><span class="line">        scanf(&quot;%s&quot;, buff);  </span><br><span class="line">        ch = buff[0];  </span><br><span class="line">        switch (ch)&#123;  </span><br><span class="line">        case&apos;1&apos;:  </span><br><span class="line">            game(); break;  </span><br><span class="line">        case&apos;2&apos;:  </span><br><span class="line">            help(); break;  </span><br><span class="line">        case&apos;0&apos;:  </span><br><span class="line">            exit(0);  </span><br><span class="line">        default:  </span><br><span class="line">            exit(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; while (ch != &apos;0&apos;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="小程序" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>[BFS]正向BFS+hash解决八码问题</title>
    <link href="http://qianyouyou.cn/2018/04/18/2018-04-18/"/>
    <id>http://qianyouyou.cn/2018/04/18/2018-04-18/</id>
    <published>2018-04-18T03:41:06.000Z</published>
    <updated>2018-05-02T12:15:20.171Z</updated>
    
    <content type="html"><![CDATA[<p>八数码问题，可以用单向广搜、双向广搜、A*、IDA等多种方法求解。具体可以参考：<a href="http://www.cnblogs.com/goodness/archive/2010/05/04/1727141.html" target="_blank" rel="noopener">八数码的八境界</a></p><p>Description</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 15  x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 1  2  3  4    1  2  3  4    1  2  3  4    1  2  3  4 </span><br><span class="line"></span><br><span class="line"> 5  6  7  8    5  6  7  8    5  6  7  8    5  6  7  8 </span><br><span class="line"></span><br><span class="line"> 9  x 10 12    9 10  x 12    9 10 11 12    9 10 11 12 </span><br><span class="line"></span><br><span class="line">13 14 11 15   13 14 11 15   13 14  x 15   13 14 15  x </span><br><span class="line"></span><br><span class="line">           r-&gt;           d-&gt;           r-&gt;</span><br></pre></td></tr></table></figure><p>Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  3 </span><br><span class="line"></span><br><span class="line">x  4  6 </span><br><span class="line"></span><br><span class="line">7  5  8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 x 4 6 7 5 8</span><br></pre></td></tr></table></figure><p>Output</p><p>You will print to standard output either the word <code></code>unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure><p>题解：</p><p>本题一共仅有9！种结果，因此求解方法很多。一开始采用stl进行存储，但一直超时，后来改用hash轻轻松松就过了。判重时9！个排列如果用数组直接保存，每一位保存一个维度，数组开不了那么大。因此可以根据康托展开进行判重，每一种排列对应成一个整形数字，9！种排列一共9！个数字，提高了hash效率。此外，对于x我们暂且当做9处理，而123456789的康托展开是1，因此bfs的终止条件就设为当前状态的康拓展开是否为1。此外，由于本次采用正向bfs，而输出结果时需要输出之前的状态，string储存太慢，queue队列会丢失之前的状态，因此用数组充当队列，用pre追溯上一个状态在队列中的下标。解决代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">#include&lt;cstdio&gt;  </span><br><span class="line">#include&lt;string&gt;  </span><br><span class="line">#include&lt;cstring&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">const int MAXN = 400000;  </span><br><span class="line">int fac[9] = &#123; 1, 1, 2, 6, 24, 120, 720, 5040, 40320&#125;;  </span><br><span class="line">int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;  </span><br><span class="line">int opp[4] = &#123; &apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos; &#125;;  </span><br><span class="line">bool vis[MAXN];  </span><br><span class="line">struct node &#123;  </span><br><span class="line">    int stadus;  </span><br><span class="line">    int cur[9];  </span><br><span class="line">    int loc;  </span><br><span class="line">    char path;  </span><br><span class="line">    int pre;  </span><br><span class="line">&#125;;  </span><br><span class="line">node qu[MAXN];  </span><br><span class="line">int cantor(int s[])  </span><br><span class="line">&#123;  </span><br><span class="line">    int sum = 0;  </span><br><span class="line">    for (int i = 0; i&lt;9; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int num = 0;  </span><br><span class="line">        for (int j = i + 1; j&lt;9; j++)  </span><br><span class="line">            if (s[j]&lt;s[i])  </span><br><span class="line">                num++;  </span><br><span class="line">        sum += num*fac[8 - i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    return sum + 1;  </span><br><span class="line">&#125;  </span><br><span class="line">int bfs(node now) &#123;  </span><br><span class="line">    memset(vis, false, sizeof(vis));  </span><br><span class="line">    int x, y;  </span><br><span class="line">    int front = 0, end = 0;  </span><br><span class="line">    node no = now;  </span><br><span class="line">    qu[end++] = no;  </span><br><span class="line">    vis[now.stadus] = true;  </span><br><span class="line">    while (front &lt; end) &#123;  </span><br><span class="line">        no = qu[front++];  </span><br><span class="line">        x = no.loc / 3;  </span><br><span class="line">        y = no.loc % 3;  </span><br><span class="line">        if (no.stadus == 1)  </span><br><span class="line">            return front - 1;  </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;  </span><br><span class="line">            node cc = no;  </span><br><span class="line">            int xx = x + dir[i][0];  </span><br><span class="line">            int yy = y + dir[i][1];  </span><br><span class="line">            if (xx &lt; 3 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; 3 &amp;&amp; yy &gt;= 0) &#123;  </span><br><span class="line">                cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy];  </span><br><span class="line">                cc.cur[xx * 3 + yy] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy];  </span><br><span class="line">                cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy];  </span><br><span class="line">                cc.stadus = cantor(cc.cur);  </span><br><span class="line">                if (!vis[cc.stadus]) &#123;  </span><br><span class="line">                    vis[cc.stadus] = true;  </span><br><span class="line">                    cc.loc = xx * 3 + yy;  </span><br><span class="line">                    cc.path = opp[i];  </span><br><span class="line">                    cc.pre = front - 1;  </span><br><span class="line">                    qu[end++] = cc;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return -1;  </span><br><span class="line">&#125;  </span><br><span class="line">void show(int a) &#123;  </span><br><span class="line">    if (qu[a].pre) &#123;  </span><br><span class="line">        show(qu[a].pre);  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;%c&quot;, qu[a].path);  </span><br><span class="line">&#125;  </span><br><span class="line">int main() &#123;  </span><br><span class="line">    string tmp;  </span><br><span class="line">    while (getline(cin, tmp)) &#123;  </span><br><span class="line">        int i = 0, cnt = 0;  </span><br><span class="line">        node temp;  </span><br><span class="line">        while (tmp[i]) &#123;  </span><br><span class="line">            if (tmp[i] == &apos; &apos;) &#123;  </span><br><span class="line">                i++;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else if (tmp[i] == &apos;x&apos;) &#123;  </span><br><span class="line">                temp.loc = cnt;  </span><br><span class="line">                temp.cur[cnt] = 9;  </span><br><span class="line">                cnt++;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                temp.cur[cnt] = tmp[i] - &apos;0&apos;;  </span><br><span class="line">                cnt++;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp.stadus = cantor(temp.cur);  </span><br><span class="line">        int ans = bfs(temp);  </span><br><span class="line">        ans != -1 ? show(ans) : printf(&quot;-1&quot;);  </span><br><span class="line">        cout &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;八数码问题，可以用单向广搜、双向广搜、A*、IDA等多种方法求解。具体可以参考：&lt;a href=&quot;http://www.cnblogs.com/goodness/archive/2010/05/04/1727141.html&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/BFS/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="http://qianyouyou.cn/tags/BFS/"/>
    
      <category term="康托展开" scheme="http://qianyouyou.cn/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    
      <category term="hash" scheme="http://qianyouyou.cn/tags/hash/"/>
    
  </entry>
  
</feed>
