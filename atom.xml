<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2019-05-10T05:51:14.750Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最少区间覆盖问题</title>
    <link href="http://qianyouyou.cn/2019/05/09/2019-05-09/"/>
    <id>http://qianyouyou.cn/2019/05/09/2019-05-09/</id>
    <published>2019-05-09T14:56:46.000Z</published>
    <updated>2019-05-10T05:51:14.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。</p><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>[2,3,1,1,1]</p><p>输出：</p><p>2</p><p>解释：</p><p>0-&gt;1-&gt;4</p><p>代码</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>动态规划，及数组记录当前最优值，类似于筛法求素数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int solve(vector&lt;int&gt;v)&#123;</span><br><span class="line">    int len = v.size();</span><br><span class="line">    vector&lt;int&gt;dp(len, inf);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 0; i &lt; len &amp;&amp; dp[i] != inf; ++i)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= v[i]; ++j)&#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[i] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len - 1] != inf ? dp[len - 1] : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>排序，下标为左界，值＋下标为右值，构成区域块，选最少的块覆盖全部区域，覆盖不了等于到不了终点。左值（右值）排序后右值（左值）贪心比较。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚拿到该题，以为是做过的题，之前做的是能否到达终点。结果忽略了求最少的步数，写完才发现理解错了。然后就慌了，思路就混乱了。就没有然后了。</p><p>还是比较适合笔试题，一个人自在，心里有了包袱就自乱阵脚，好水的题都能出错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。&lt;/p&gt;
&lt;h2 id=&quot;样例：&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[转]探索C++虚函数在g++中的实现</title>
    <link href="http://qianyouyou.cn/2019/05/07/2019-05-07/"/>
    <id>http://qianyouyou.cn/2019/05/07/2019-05-07/</id>
    <published>2019-05-07T15:23:56.000Z</published>
    <updated>2019-05-07T15:37:30.142Z</updated>
    
    <content type="html"><![CDATA[<p>为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：</p><p>C++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base1::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base2::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void h() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::h()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Derived ins;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"></span><br><span class="line">    b1.f();</span><br><span class="line">    b2.g();</span><br><span class="line">    d.f();</span><br><span class="line">    d.g();</span><br><span class="line">    d.h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码采用了多继承，是为了更多的分析出g++的实现本质，用UML简单的画一下继承关系：</p><p>示例代码UML图</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-3.png" alt=""></p><p>代码的输出结果和预期的一致，C++实现了虚函数覆盖功能，代码输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::h()</span><br></pre></td></tr></table></figure><h2 id="开始分析！"><a href="#开始分析！" class="headerlink" title="开始分析！"></a>开始分析！</h2><p>我写这篇文章的重点是尝试解释g++编译在底层是如何实现虚函数覆盖和动态绑定的，因此我假定你已经明白基本的虚函数概念以及虚函数表（vtbl）和虚函数表指针（vptr）的概念和在继承实现中所承担的作用，如果你还不清楚这些概念，建议你在继续阅读下面的分析前先补习一下相关知识，陈皓的 <a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="noopener">《C++虚函数表解析》</a> 系列是一个不错的选择。</p><p>通过本文，我将尝试解答下面这三个问题：</p><ol><li>g++如何实现虚函数的动态绑定？</li><li>vtbl在何时被创建？vptr又是在何时被初始化？</li><li>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</li></ol><p>首先是第一个问题：</p><h3 id="g-如何实现虚函数的动态绑定？"><a href="#g-如何实现虚函数的动态绑定？" class="headerlink" title="g++如何实现虚函数的动态绑定？"></a>g++如何实现虚函数的动态绑定？</h3><p>这个问题乍看简单，大家都知道是通过vptr和vtbl实现的，那就让我们刨根问底的看一看，g++是如何利用vptr和vtbl实现的。</p><p>第一步，使用 -fdump-class-hierarchy 参数导出g++生成的类内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Vtable for Base1</span><br><span class="line">Base1::_ZTV5Base1: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base1)</span><br><span class="line">8     Base1::f</span><br><span class="line"></span><br><span class="line">Class Base1</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base1 (0xb6acb438) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base1::_ZTV5Base1) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Base2</span><br><span class="line">Base2::_ZTV5Base2: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base2)</span><br><span class="line">8     Base2::g</span><br><span class="line"></span><br><span class="line">Class Base2</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base2 (0xb6acb474) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base2::_ZTV5Base2) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Derived</span><br><span class="line">Derived::_ZTV7Derived: 8u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">8     Derived::f</span><br><span class="line">12    Derived::g</span><br><span class="line">16    Derived::h</span><br><span class="line">20    (int (*)(...))-0x000000004</span><br><span class="line">24    (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">28    Derived::_ZThn4_N7Derived1gEv</span><br><span class="line"></span><br><span class="line">Class Derived</span><br><span class="line">   size=8 align=4</span><br><span class="line">   base size=8 base align=4</span><br><span class="line">Derived (0xb6b12780) 0</span><br><span class="line">    vptr=((&amp; Derived::_ZTV7Derived) + 8u)</span><br><span class="line">  Base1 (0xb6acb4b0) 0 nearly-empty</span><br><span class="line">      primary-for Derived (0xb6b12780)</span><br><span class="line">  Base2 (0xb6acb4ec) 4 nearly-empty</span><br><span class="line">      vptr=((&amp; Derived::_ZTV7Derived) + 28u)</span><br></pre></td></tr></table></figure><p>如果看不明白这些乱七八糟的输出，没关系（当然能看懂更好），把上面的输出转换成图的形式就清楚了：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-2.png" alt=""></p><p>vptr和vtbl</p><p>其中有几点尤其值得注意：</p><ol><li>我用来测试的机器是32位机，所有vptr占4个字节，每个vtbl中的函数指针也是4个字节</li><li>每个类的主要（primal）vptr放在类内存空间的起始位置（由于我没有声明任何成员变量，可能看不清楚）</li><li>在多继承中，对应各个基类的vptr按继承顺序依次放置在类内存空间中，且子类与第一个基类共用同一个vptr</li><li>子类中声明的虚函数除了覆盖各个基类对应函数的指针外，还额外添加一份到第一个基类的vptr中（体现了共用的意义）</li></ol><p>有了内存布局后，接下来观察g++是如何在这样的内存布局上进行动态绑定的。</p><p>g++对每个类的指针或引用对象，如果是其类声明中虚函数，使用位于其内存空间首地址上的vptr寻找找到vtbl进而得到函数地址。如果是父类声明而子类未覆盖的虚函数，使用对应父类的vptr进行寻址。</p><p>先来验证一下，使用 objdump -S 得到 b1.f() 的汇编指令：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b1.f();</span><br><span class="line"> 8048734:       8b 44 24 24             mov    0x24(%esp),%eax    # 得到Base1对象的地址</span><br><span class="line"> 8048738:       8b 00                   mov    (%eax),%eax        # 对对象首地址上的vptr进行解引用，得到vtbl地址</span><br><span class="line"> 804873a:       8b 10                   mov    (%eax),%edx        # 解引用vtbl上第一个虚函数的地址</span><br><span class="line"> 804873c:       8b 44 24 24             mov    0x24(%esp),%eax</span><br><span class="line"> 8048740:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048743:       ff d2                   call   *%edx              # 调用函数</span><br></pre></td></tr></table></figure><p>其过程和我们的分析完全一致，聪明的你可能发现了，b2怎么办呢？Derived类的实例内存首地址上的vptr并不是Base2类的啊！答案实际上是因为g++在引用赋值语句 Base2 &amp;b2 = ins 上动了手脚：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Derived ins;</span><br><span class="line"> 804870d:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048711:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048714:       e8 c3 01 00 00          call   80488dc &lt;_ZN7DerivedC1Ev&gt;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line"> 8048719:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 804871d:       89 44 24 24             mov    %eax,0x24(%esp)</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line"> 8048721:       8d 44 24 1c             lea    0x1c(%esp),%eax   # 获得ins实例地址</span><br><span class="line"> 8048725:       83 c0 04                add    $0x4,%eax         # 添加一个指针的偏移量</span><br><span class="line"> 8048728:       89 44 24 28             mov    %eax,0x28(%esp)   # 初始化引用</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"> 804872c:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048730:       89 44 24 2c             mov    %eax,0x2c(%esp)</span><br></pre></td></tr></table></figure><p>虽然是指向同一个实例的引用，根据引用类型的不同，g++编译器会为不同的引用赋予不同的地址。例如b2就获得一个指针的偏移量，因此才保证了vptr的正确性。</p><p>PS：我们顺便也证明了C++中的引用的真实身份就是指针…</p><p>接下来进入第二个问题：</p><h3 id="vtbl在何时被创建？vptr又是在何时被初始化？"><a href="#vtbl在何时被创建？vptr又是在何时被初始化？" class="headerlink" title="vtbl在何时被创建？vptr又是在何时被初始化？"></a>vtbl在何时被创建？vptr又是在何时被初始化？</h3><p>既然我们已经知道了g++是如何通过vptr和vtbl来实现虚函数魔法的，那么vptr和vtbl又是在什么时候被创建的呢？</p><p>vptr是一个相对容易思考的问题，因为vptr明确的属于一个实例，所以vptr的赋值理应放在类的构造函数中。 g++为每个有虚函数的类在构造函数末尾中隐式的添加了为vptr赋值的操作 。</p><p>同样通过生成的汇编代码验证：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line"> 80488dc:       55                      push   %ebp</span><br><span class="line"> 80488dd:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80488df:       83 ec 18                sub    $0x18,%esp</span><br><span class="line"> 80488e2:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488e5:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488e8:       e8 d3 ff ff ff          call   80488c0 &lt;_ZN5Base1C1Ev&gt;</span><br><span class="line"> 80488ed:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488f0:       83 c0 04                add    $0x4,%eax</span><br><span class="line"> 80488f3:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488f6:       e8 d3 ff ff ff          call   80488ce &lt;_ZN5Base2C1Ev&gt;</span><br><span class="line"> 80488fb:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488fe:       c7 00 48 8a 04 08       movl   $0x8048a48,(%eax)</span><br><span class="line"> 8048904:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 8048907:       c7 40 04 5c 8a 04 08    movl   $0x8048a5c,0x4(%eax)</span><br><span class="line"> 804890e:       c9                      leave</span><br><span class="line"> 804890f:       c3                      ret</span><br></pre></td></tr></table></figure><p>可以看到在代码中，Derived类的构造函数为实例的两个vptr赋初值，可是，这两个初值居然是立即数！立即数！立即数！ 这说明了vtbl的生成并不是运行时的，而是在编译期就已经确定了存放在这两个地址上的 ！</p><p>这个地址不出意料的属于.rodata（只读数据段），使用 objdump -s -j .rodata 提取出对应的内存观察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">80489e0 03000000 01000200 00000000 42617365  ............Base</span><br><span class="line"> 80489f0 313a3a66 28290042 61736532 3a3a6728  1::f().Base2::g(</span><br><span class="line"> 8048a00 29004465 72697665 643a3a66 28290044  ).Derived::f().D</span><br><span class="line"> 8048a10 65726976 65643a3a 67282900 44657269  erived::g().Deri</span><br><span class="line"> 8048a20 7665643a 3a682829 00000000 00000000  ved::h()........</span><br><span class="line"> 8048a30 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048a40 00000000 a08a0408 34880408 68880408  ........4...h...</span><br><span class="line"> 8048a50 94880408 fcffffff a08a0408 60880408  ............`...</span><br><span class="line"> 8048a60 00000000 c88a0408 08880408 00000000  ................</span><br><span class="line"> 8048a70 00000000 d88a0408 dc870408 37446572  ............7Der</span><br><span class="line"> 8048a80 69766564 00000000 00000000 00000000  ived............</span><br><span class="line"> 8048a90 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048aa0 889f0408 7c8a0408 00000000 02000000  ....|...........</span><br><span class="line"> 8048ab0 d88a0408 02000000 c88a0408 02040000  ................</span><br><span class="line"> 8048ac0 35426173 65320000 a89e0408 c08a0408  5Base2..........</span><br><span class="line"> 8048ad0 35426173 65310000 a89e0408 d08a0408  5Base1..........</span><br></pre></td></tr></table></figure><p>由于程序运行的机器是小端机，经过简单的转换就可以得到第一个vptr所指向的内存中的第一条数据为0x80488834，如果把这个数据解释为函数地址到汇编文件中查找，会得到：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">08048834 &lt;_ZN7Derived1fEv&gt;:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line"> 8048834:       55                      push   %ebp</span><br><span class="line"> 8048835:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048837:       83 ec 18                sub    $0x18,%esp</span><br></pre></td></tr></table></figure><p>Bingo！ g++在编译期就为每个类确定了vtbl的内容，并且在构造函数中添加相应代码使vptr能够指向已经填好的vtbl的地址 。</p><p>这也同时为我们解答了第三个问题：</p><p>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</p><p>直接看图：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-1.png" alt=""></p><p>虚函数在虚拟存储器中的位置</p><p>图中灰色部分应该是你已经熟悉的，彩色部分内容和相关联的箭头描述了虚函数调用的过程（图中展示的是通过new在堆区创建实例的情况，与示例代码有所区别，小失误，不要在意）： 当调用虚函数时，首先通过位于栈区的实例的指针找到位于堆区中的实例地址，然后通过实例内存开头处的vptr找到位于.rodata段的vtbl，再根据偏移量找到想要调用的函数地址，最后跳转到代码段中的函数地址执行目标函数 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>研究这些问题的起因是因为公司代码出现了非常奇葩的行为，经过追查定位到虚函数表出了问题，因此才有机会脚踏实地的对虚函数实现进行一番探索。</p><p>也许你会想，即使我不明白这些底层原理，也一样可以正常的使用虚函数，也一样可以写出很好的面相对象的代码啊？</p><p>这一点儿也没有错，但是，C++作为全宇宙最复杂的程序设计语言，它提供的功能异常强大，无异于武侠小说中锋利无比的屠龙宝刀。但武功不好的菜鸟如果胡乱舞弄宝刀，却很容易反被其所伤。只有了解了C++底层的原理和机制，才能让我们把C++这把屠龙宝刀使用的更加得心应手，变化出更加华丽的招式，成为真正的武林高手。</p><h1 id="转"><a href="#转" class="headerlink" title="转"></a>转</h1><p>本文转自<a href="http://blog.kongfy.com/2015/08/%E6%8E%A2%E7%B4%A2c%E8%99%9A%E5%87%BD%E6%95%B0%E5%9C%A8g%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.kongfy.com/2015/08/探索c虚函数在g中的实现/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：&lt;/p&gt;
&lt;p&gt;C++&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="多态" scheme="http://qianyouyou.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数表" scheme="http://qianyouyou.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>自顶向下语法分析指北</title>
    <link href="http://qianyouyou.cn/2019/05/05/2019-05-05/"/>
    <id>http://qianyouyou.cn/2019/05/05/2019-05-05/</id>
    <published>2019-05-05T03:43:44.000Z</published>
    <updated>2019-05-05T12:14:24.265Z</updated>
    
    <content type="html"><![CDATA[<ul><li>语法分析<ul><li>自顶向下语法分析<ul><li>确定分析</li><li>不确定分析</li></ul></li><li>自底向上语法分析<ul><li>算符优先分析</li><li>LR分析</li></ul></li></ul></li></ul><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="确定分析-LL-1-文法"><a href="#确定分析-LL-1-文法" class="headerlink" title="确定分析(LL(1)文法)"></a>确定分析(LL(1)文法)</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>G[S]:</p><p>S -&gt; pA | qB</p><p>A -&gt; cAd | a</p><p>B -&gt; dB | b</p><p>W = pccadd。</p><p>推导过程如下：S =&gt; pA =&gt; pcAd =&gt; pccAdd =&gt; pccadd。</p><ul><li>​          S                      S                          S                          S<br> ​        /    \                    /    \                        /    \                        /    \<br> ​       p      A    =&gt;          p      A        =&gt;          p      A        =&gt;          p      A<pre><code>/   |   \                       /   |   \                      /   |   \</code></pre>  ​                        c     A     d                c     A     d                c     A     d<pre><code>/   |   \                      /   |   \</code></pre>  ​                                            c     A     d                c     A     d<br>  ​                                                                       |<pre><code>a</code></pre></li></ul><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>G[S]：</p><p>S-&gt;Ap</p><p>S-&gt;Bq</p><p>A-&gt;a</p><p>A-&gt;cA</p><p>B-&gt;b</p><p>B-&gt;dB</p><p>W = ccap，推导过程：</p><p>S =&gt; aP =&gt; cAp =&gt; ccAp =&gt; ccap。</p><h3 id="FIRST-a"><a href="#FIRST-a" class="headerlink" title="FIRST(a)"></a>FIRST(a)</h3><p>a的开始符号集或首符号集。</p><p>例2：FIRST(Ap) = {a, c}。</p><p>FIRST(Bq) = {b, d}。</p><p>FIRST(S) = {a, b, c, d}。</p><p>###FOLLOW(A)</p><p>若Aa，a ∈ FOLLOW(A)。若a = ε，则# ∈ FOLLOW(A)。</p><h3 id="SELECT-A-gt-a"><a href="#SELECT-A-gt-a" class="headerlink" title="SELECT(A-&gt;a)"></a>SELECT(A-&gt;a)</h3><p>a不为ε，则SELECT(A-&gt;a) = FIRST(a)。</p><p>否则，SELECT(A-&gt;a) = FIRST(a) - ε + FOLLOW(A)。</p><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>第1个L表示从左往右扫描字符串。</p><p>第2个L表示采用最左推导。</p><p>1表示只需向右看1个字符即可选择哪个产生式。（为了提高效率，最多为2）。</p><h4 id="充要条件："><a href="#充要条件：" class="headerlink" title="充要条件："></a>充要条件：</h4><p>SELLECT(A-&gt;a) ∩ SELECT(A-&gt;b) = 空集。（a，b不能同时能ε）。</p><p>通俗理解就是a和b不能有相同前缀。</p><h4 id="LL-1-文法判别步骤"><a href="#LL-1-文法判别步骤" class="headerlink" title="LL(1)文法判别步骤"></a>LL(1)文法判别步骤</h4><p>求出能推出 ε 的非终结符。（未定，是，否）</p><p>计算FIRST集</p><p>计算FOLLOW集</p><p>计算SELECT集</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="递归子程序法"><a href="#递归子程序法" class="headerlink" title="递归子程序法"></a>递归子程序法</h4><p>对应文法中每个非终结符编写一个递归过程，每个过程的功能是识别由非终结符推出的串，当某非终结符的产生式有多个候选时能够按LL(1)形式可唯一确定地选择某个候选进行推导。</p><p>当文法满足LL(1)条件时，构造不带回溯的自上而下分析程序。</p><p>该分析程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>不是所有的aij的first集的交集都为空，仅针对一个VN的候选式有如此的约定。</p><h4 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征 :"></a>特征 :</h5><p>根据当前输入符号，为当前要处理的非终结符选择产生式。</p><p>表驱动的预测分析器包含：</p><ul><li>一个输入缓冲区</li><li>一个栈</li><li>一张分析表</li><li>一个输出流</li></ul><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-1.png" alt=""></p><h5 id="预测分析表M"><a href="#预测分析表M" class="headerlink" title="预测分析表M"></a>预测分析表M</h5><p>预测分析表是一个M[A，a]形式的矩阵。</p><p>其中： A为非终结符，a为终结符或#。</p><p>M[A，a]中存放着一条关于A的产生式，指出当A面临a时所应采取的候选；</p><p>M[A，a]中也可能存放一条“出错标志”，指出Ａ不应该面临a。</p><p>例：对于文法G       </p><ol><li>E→TE’</li><li>E’ → +TE’|ε</li><li>T →FT’</li><li>T’→*FT’| ε</li><li>F→(E)|id  </li></ol><p>其预测分析表为：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-2.png" alt="1557056948767"></p><p>解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FIRST(E)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(E’)=&#123;+, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T’)=&#123; *, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(F)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E) =&#123;#, )&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E’)=&#123;), #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T’)=&#123;+, ),  # &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T) =&#123;+, ),  #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(F) =&#123;id, ), *,  #&#125;</span><br></pre></td></tr></table></figure><h5 id="预测分析器"><a href="#预测分析器" class="headerlink" title="预测分析器"></a>预测分析器</h5><p>预测分析程序的算法：</p><ul><li><p>输入：串w和文法G的分析表M</p></li><li><p>输出：如果w属于L（G），则输出w的最左推导，否则报错</p></li><li><p>方法：开始时，#S在栈里，w#在输入缓冲区</p><p>令ip指向w #的第一个符号，令X是栈顶符号，a是ip指向的符号</p></li></ul><p>预测分析器的工作方式：当前栈顶符号X和当前输入符号为a，则语法分析器的动作为：</p><ol><li>如果X=a≠#，则POP，advance</li><li>如果X ∈VN,查M[X，a]表，若M[X，a]=X→UVW,则用WVU替换栈顶；若M[X，a]=error,则调用错误恢复程序。</li><li>如果X=a=#,分析成功。</li></ol><p>句子id+id*id的分析过程：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-3.png" alt="1557057317524"></p><h2 id="不确定分析（简）"><a href="#不确定分析（简）" class="headerlink" title="不确定分析（简）"></a>不确定分析（简）</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>匹配，匹配不了回溯继续匹配，直到全部匹配不了或匹配成功为止。（非常暴力）</p><ol><li><p>由于相同左部的产生式的右部FIRST集交集不为空而引起回溯。</p><p>S-&gt;xAy</p><p>S-&gt;ab|a</p></li><li><p>由于相同左部非终结符的右部可为 ε ，且非终结符的FOLLOW集中含有其他产生式右部FIRST集的元素。</p><p>S-&gt;aAS</p><p>S-&gt;b</p><p>A-&gt;bAS</p><p>A-&gt;ε</p></li><li><p>由于文法含有左递归。</p><p>S-&gt;Sa</p><p>S-&gt;b</p></li></ol><h2 id="部分不确定分析转确定分析"><a href="#部分不确定分析转确定分析" class="headerlink" title="部分不确定分析转确定分析"></a>部分不确定分析转确定分析</h2><h3 id="左递归消除"><a href="#左递归消除" class="headerlink" title="左递归消除"></a>左递归消除</h3><h4 id="直接左递归消除"><a href="#直接左递归消除" class="headerlink" title="直接左递归消除"></a>直接左递归消除</h4><p>采用下列变换公式消除直接左递归，把直接左递归改写为右递归。</p><p>如：G[S]： S→Sa | b</p><p>可改写为：</p><p>S→bS’</p><p>S’→aS’|ε </p><p>改写后的文法所描述的L(G)={ba^n| n&gt;=0}</p><p>一般而言，假定关于P的全部产生式是</p><p>P→Pa1 | Pa2 | … | Pam | b1 | b2|…|bn 其中，每个a都不等于ε，而每个都不以P开头，那么，消除P的直接左递归性就是改写这些规则：</p><p>P→b1P’ | b2P’ | … | bnP’</p><p>P’→a1P’ | a2P’ |… | amP’ | ε </p><h4 id="间接左递归消除"><a href="#间接左递归消除" class="headerlink" title="间接左递归消除"></a>间接左递归消除</h4><p>间接左递归的消除需先将间接左递归变为直接左递归，然后再按第1种方法消除直接左递归。</p><h5 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h5><p>将一个产生式规则右部的a中的Vn N替换为N的候选式。如果N有n个候选式，右边a重复n次，而且每一次重复都有N的不同候选式来代替N。</p><p>例如：N →a | Bc | ε  在S→Nq中的代入结果S→aq | Bcq | q。</p><h3 id="回溯消除"><a href="#回溯消除" class="headerlink" title="回溯消除"></a>回溯消除</h3><p>回溯产生的根源：头字符集合的问题。例如A-&gt;ab|a。</p><h4 id="提取公因子"><a href="#提取公因子" class="headerlink" title="提取公因子"></a>提取公因子</h4><p>经过反复提取左因子，就能够把每个非终结符（包括新引进者）的所有候选首符集变成为两两不相交。</p><p>例：考察文法G[S]:</p><p>S → iCtS | iCtSeS | aC → b </p><p>解：由于S的前两个候选项中含有左因子iCtS，提取左因子之后，等价文法G’如下：</p><p>S → iCtSS’ | a</p><p>S’ →eS |ε</p><p>C → b</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;语法分析&lt;ul&gt;
&lt;li&gt;自顶向下语法分析&lt;ul&gt;
&lt;li&gt;确定分析&lt;/li&gt;
&lt;li&gt;不确定分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上语法分析&lt;ul&gt;
&lt;li&gt;算符优先分析&lt;/li&gt;
&lt;li&gt;LR分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="语法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>语法分析与词法分析指北</title>
    <link href="http://qianyouyou.cn/2019/05/01/2019-05-01/"/>
    <id>http://qianyouyou.cn/2019/05/01/2019-05-01/</id>
    <published>2019-05-01T13:41:32.000Z</published>
    <updated>2019-05-05T11:38:29.554Z</updated>
    
    <content type="html"><![CDATA[<p>程序编译过程：</p><p>源程序 -&gt; 词法分析程序 -&gt; <strong>语法分析程序</strong> -&gt; <strong>语义分析程序</strong> -&gt; 中间代码生成程序 -&gt; 代码优化程序 -&gt; 目标代码生成程序 -&gt; 目标程序</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>例：</p><p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p><p>&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;</p><p>&lt;代词&gt; → 你 | 我 | 他</p><p>&lt;名词&gt; → 老王 | 大学生 | 英语</p><p>&lt;谓语&gt; → &lt;动词&gt;&lt;直接宾语&gt;</p><p>&lt;动词&gt; → 是 | 学习 | 热爱</p><p>&lt;直接宾语&gt; → &lt;代词&gt; | &lt;名词&gt;</p><p>“我是大学生”符合以上规则，是句子。“我大学生是”不符合上面规则，不是句子。</p><p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p><p>→ &lt;代词&gt;&lt;谓语&gt;</p><p>→ 我&lt;谓语&gt;</p><p>→ 我&lt;动词&gt;&lt;直接宾语&gt;</p><p>→ 我是&lt;直接宾语&gt;</p><p>→ 我是&lt;名词&gt;</p><p>→ 我是大学生</p><h2 id="符号和字符串"><a href="#符号和字符串" class="headerlink" title="符号和字符串"></a>符号和字符串</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表即符号集，例如汉字的字母表包括汉字，数字标点等，C语言包括if，while之类的保留字组成。</p><h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p>由字母表中的符号组成的任何又穷序列（顺序很重要）。例如A = {a, b, c}的符号串有a，b，ab，ba， aa等等。</p><h3 id="符号串的头尾，固有头固有尾"><a href="#符号串的头尾，固有头固有尾" class="headerlink" title="符号串的头尾，固有头固有尾"></a>符号串的头尾，固有头固有尾</h3><p>abc的头是 ε, a, ab, abc，除abc外均为固有头。尾是ε, c, bc, abc，除abc外均为固有尾。</p><h3 id="符号串方幂"><a href="#符号串方幂" class="headerlink" title="符号串方幂"></a>符号串方幂</h3><p>x = AB。x^0 = ε。x^1 = AB。x^2 = ABAB。x^3 = ABABAB。</p><h3 id="符号串的集合"><a href="#符号串的集合" class="headerlink" title="符号串的集合"></a>符号串的集合</h3><p>A = {a, b}。B = {c, d}。AB = {ac, ad, bc, bd}。</p><h2 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h2><p>G(VN, VT, P, S)。</p><p>VN为非终结符（例如&lt;谓语&gt;，可以继续转换。通常用大写字母表示，例如A）</p><p>VT为终结符（例如“老王”，可直接匹配，不能再向下转换。通常用小写字母表示，例如a）</p><p>P（规则，例如&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;。又例如S →Aa）。</p><p>S起点（例如&lt;句子&gt;就是起点）</p><h2 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h2><p>3型∈2型∈1型∈0型，3型最严谨，向右兼容。</p><h3 id="0型递归文法"><a href="#0型递归文法" class="headerlink" title="0型递归文法"></a>0型递归文法</h3><p>a→b，a至少含1个非终结符，b为任意。</p><p>凡是递归可枚举的都是0型，包括A→ε，aA→aa等情况。</p><h3 id="1型上下文有关文法"><a href="#1型上下文有关文法" class="headerlink" title="1型上下文有关文法"></a>1型上下文有关文法</h3><p>a→b，a至少含1个非终结符，b不为ε。</p><p>0型除去ε的情况就是1型。也就是非终结符不能为ε。</p><p>包括aA→aa等情况。</p><h3 id="2型上下文无关文法"><a href="#2型上下文无关文法" class="headerlink" title="2型上下文无关文法"></a>2型上下文无关文法</h3><p>a→b，a必须是非终结符（only one）。</p><p>不包括aA→aa等情况。</p><p>可以A→aa。</p><h3 id="3型正规文法"><a href="#3型正规文法" class="headerlink" title="3型正规文法"></a>3型正规文法</h3><p>非终结符转换时头必须有一个终结符。例如：</p><p>S→aB</p><p>S→bA</p><p>A→a</p><p>A→aS</p><p>A→bAA</p><p>B→b</p><p>B→bS</p><p>B→aBB</p><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01.png" alt=""></p><h2 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h2><ul><li>自顶向下语法分析（由S向句子推，最终和句子匹配，看能否得到句子）</li><li>自底向上语法分析（由句子向S推，最终看能否得到S）</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>输入源程序；扫描、分解字符串，识别出一个个单词（定义符、标识符、运算符、界符、常数）</p><h2 id="词法分析输出"><a href="#词法分析输出" class="headerlink" title="词法分析输出"></a>词法分析输出</h2><p>读入源程序，输出担此符号。单词符号可分为以下5种：</p><p>关键字（if，else，while，int等）</p><p>标识符（a，fun，val等自定义的变量名）</p><p>常数（1，1.2，true，“abc”）</p><p>运算符（+，-，=，&lt;=，==）</p><p>界符（，；’)’）等。</p><p>词法分析输出单词符号常常采用二元组形式（单词种别，单词自身值）。</p><h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>扫描阶段：从左向右扫描输入源程序，删除注释、压缩空白字符；</p><p>词法分析阶段：按照语言的词法规则识别各类单词，并产生相应的单词符号。</p><h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>&lt;标识符&gt; → l | l &lt;字母数字&gt;</p><p>&lt;字母数字&gt; → l | d |l &lt;字母数字&gt; | d&lt;字母数字&gt;</p><p>（l字母，d数字）</p><p>例如:</p><p>A→aB</p><p>A→a</p><h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>a            {a}</p><p>a|b            {a,b}</p><p>ab            {ab}</p><p>(a|b)(a|b)    {aa,ab,ba,bb}</p><p>a*            {ε,a,aa,aaa…}</p><p>(a|b)*        {ε,a,aab,abaa…所有a,b组成的串}</p><p>(a|b)*(aa|bb)(a|b)*        {aaabbaab……}</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="确定有穷自动机-DFA"><a href="#确定有穷自动机-DFA" class="headerlink" title="确定有穷自动机(DFA)"></a>确定有穷自动机(DFA)</h3><p>DFA M = （K, ∑, f, S, Z）</p><p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p><p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p><p>f：转换函数，一个节点通过某条边到另一个结点（或自身）。</p><p>S：唯一一个初态（起点）</p><p>Z：终态集。（就是终点的集合）</p><h3 id="不确定有穷自动机-NFA"><a href="#不确定有穷自动机-NFA" class="headerlink" title="不确定有穷自动机(NFA)"></a>不确定有穷自动机(NFA)</h3><p>NFA M = （K, ∑, f, S, Z）</p><p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p><p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p><p>f：转换函数，一个节点通过某一类边到另外许多结点的集合（或自身）。</p><p>S：初态集（多个起点）</p><p>Z：终态集。（就是终点的集合）</p><p>很容易发现，不确定有穷自动机和确定有穷自动机的区别就是DFA每个结点每类单向边只有一条，且起点只有一个，而NFA可以有多条，且起点可以有多个。例如NFA中S—a—&gt;A，S—a,b—&gt;S，S—a,b—&gt;D，但DFA不允许，a，b由S指向其他结点（或自身）的话只能存在一条。</p><h2 id="正则式转自动机"><a href="#正则式转自动机" class="headerlink" title="正则式转自动机"></a>正则式转自动机</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-1.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-2.png" alt=""></p><h2 id="正规文法转自动机"><a href="#正规文法转自动机" class="headerlink" title="正规文法转自动机"></a>正规文法转自动机</h2><p>正规文法由于为第3型文法，所以S→aA，S为起点，→为边，a为边名，A为下一个结点。</p><h2 id="NFA转DFA"><a href="#NFA转DFA" class="headerlink" title="NFA转DFA"></a>NFA转DFA</h2><p><a href="https://blog.csdn.net/dala_da/article/details/78704560" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序编译过程：&lt;/p&gt;
&lt;p&gt;源程序 -&amp;gt; 词法分析程序 -&amp;gt; &lt;strong&gt;语法分析程序&lt;/strong&gt; -&amp;gt; &lt;strong&gt;语义分析程序&lt;/strong&gt; -&amp;gt; 中间代码生成程序 -&amp;gt; 代码优化程序 -&amp;gt; 目标代码生成程序 -&amp;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="词法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="语法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统漫游——&quot;Hello,World&quot;的漫漫计算机旅程</title>
    <link href="http://qianyouyou.cn/2019/04/29/2019-04-29/"/>
    <id>http://qianyouyou.cn/2019/04/29/2019-04-29/</id>
    <published>2019-04-29T07:52:39.000Z</published>
    <updated>2019-05-05T03:40:46.659Z</updated>
    
    <content type="html"><![CDATA[<p>欲练Programmer，必先Coder。Coder+Programmer，方成Developer。</p><p>每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。</p><p>本文主要介绍一个简简单单的”Hello,World”程序是如何在计算机系统乃至网络跑起来的。（当然不会写的太复杂啦，毕竟这是一个漫长的过程）。</p><p>翠花，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;Hello,World\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>hello程序的生命周期是从一个hello.c的源文件开始的。而源程序实际是一个由0、1组成的位（比特）序列，8位一组，称为字节。每个字节表示程序中的某些文本字节。大多数系统以ASCII码表示文本字符。例如以上代码就可以ASII表示为：</p><table><thead><tr><th>#</th><th>i</th><th>n</th><th>c</th><th>l</th><th>u</th><th>d</th><th>e</th><th>SP</th><th>&lt;</th><th>s</th><th>t</th><th>d</th><th>i</th><th>o</th><th>.</th></tr></thead><tbody><tr><td>35</td><td>105</td><td>110</td><td>99</td><td>108</td><td>117</td><td>100</td><td>101</td><td>32</td><td>60</td><td>115</td><td>116</td><td>100</td><td>105</td><td>111</td><td>46</td></tr><tr><td>h</td><td>&gt;</td><td>\n</td><td>i</td><td>n</td><td>t</td><td>SP</td><td>m</td><td>a</td><td>i</td><td>n</td><td>(</td><td>）</td><td>{</td><td>\n</td><td>SP</td></tr><tr><td>104</td><td>62</td><td>10</td><td>105</td><td>110</td><td>116</td><td>32</td><td>109</td><td>97</td><td>105</td><td>110</td><td>40</td><td>41</td><td>123</td><td>10</td><td>32</td></tr><tr><td>SP</td><td>SP</td><td>SP</td><td>p</td><td>r</td><td>i</td><td>n</td><td>t</td><td>f</td><td>(</td><td>“</td><td>H</td><td>e</td><td>l</td><td>l</td><td>o</td></tr><tr><td>32</td><td>32</td><td>32</td><td>112</td><td>114</td><td>105</td><td>110</td><td>116</td><td>102</td><td>40</td><td>34</td><td>72</td><td>101</td><td>108</td><td>108</td><td>111</td></tr><tr><td>,</td><td>W</td><td>o</td><td>r</td><td>l</td><td>d</td><td>\</td><td>n</td><td>“</td><td>)</td><td>;</td><td>\n</td><td>SP</td><td>SP</td><td>SP</td><td>SP</td></tr><tr><td>44</td><td>87</td><td>111</td><td>114</td><td>108</td><td>100</td><td>92</td><td>110</td><td>34</td><td>41</td><td>59</td><td>10</td><td>32</td><td>32</td><td>32</td><td>32</td></tr><tr><td>r</td><td>e</td><td>t</td><td>u</td><td>r</td><td>n</td><td>SP</td><td>0</td><td>;</td><td>\n</td><td>}</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>114</td><td>101</td><td>116</td><td>117</td><td>114</td><td>110</td><td>32</td><td>48</td><td>59</td><td>10</td><td>125</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>hello.c是以字节序的方式存储在文件中的。系统中的所有信息（磁盘文件，用户信息，网络传输数据等）均由一串比特表示。区分不同数据对象的唯一方式是读这些数据对象时的上下文。比如不同的上下文中，一个同样的字节序列可能表示整数，浮点数，字符串或者机器指令。</p><h1 id="程序到可执行文件的过程"><a href="#程序到可执行文件的过程" class="headerlink" title="程序到可执行文件的过程"></a>程序到可执行文件的过程</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>cpp根据以字符#开头的命令，修改原始C程序。例如上例hello.c中#include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h中的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>ccl将文本文件hello.i翻译成汇编语言hello.s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">subq$8, %rsp</span><br><span class="line">movl$.LCO, %edi</span><br><span class="line">callputs</span><br><span class="line">movl$0, eax</span><br><span class="line">addq$8, %rsp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>as将hello.s翻译成机器语言指令，这些指令打包成hello.o中。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>hello程序调用了printf函数，存在于编译好的printf.o中，ld负责合并。它是一个可执行文件，可以被加载入内存，由系统执行。</p><h1 id="理解编译系统的好处"><a href="#理解编译系统的好处" class="headerlink" title="理解编译系统的好处"></a>理解编译系统的好处</h1><ul><li>优化程序性能。</li><li>理解链接时出现的错误。</li><li>避免安全漏洞。</li></ul><h1 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h1><p>Linux下，hello文件的执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ./hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure><p>第一行与第三行是shell，shell是一个命令行解释器，它输出一个提示符，等待输入一个命令。如果shell命令行第一个单词不是一个内置shell命令，那么shell会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以上面案例shell加载并执行了当前目录下hello程序，然后等待程序终止。程序完成后，又切换回shell。</p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ul><li><strong>总线</strong>：贯穿整个系统的是一组电子管道，即总线。携带信息负责在各个部件间传递。</li><li><strong>I/O设备</strong>：系统与外部的联系通道。</li><li><strong>主存</strong>：临时存储设备，存储数据共处理器调用或修改。</li><li><strong>处理器</strong>：执行存储在主存中指令的引擎。</li></ul><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt=""></p><h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%201.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%202.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%203.png" alt=""></p><h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>由上例可发现，系统花费了大量时间把信息从一个敌方搬到另一个地方。hello程序原本在磁盘上，加载时复制到主存，处理机运行时又由主存复杂到处理器。字符串原在主存上，后复制到内存，后复制到显示器。为了提高速度，便引入高速缓存。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.jpg" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt=""></p><h1 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h1><p>当shell加载和运行hello程序时，以及hello输出消息时，并没直接访问键盘，磁盘或主存，而是通过操作系统。所以说我们可以理解操作系统是应用程序与硬件之间插入的一层软件。</p><p>操作系统通过进程，虚拟内存和文件来实现硬件与应用程序间的交互。</p><p>进程（处理器+主存+I/O设备）</p><p>虚拟内存（主存+I/O设备）</p><p>文件（I/O设备）</p><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欲练Programmer，必先Coder。Coder+Programmer，方成Developer。&lt;/p&gt;
&lt;p&gt;每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。&lt;/p&gt;
&lt;p&gt;本文主要介绍一个简简
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="计算机系统" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="存储器" scheme="http://qianyouyou.cn/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>大话存储器</title>
    <link href="http://qianyouyou.cn/2019/04/27/2019-04-27/"/>
    <id>http://qianyouyou.cn/2019/04/27/2019-04-27/</id>
    <published>2019-04-27T11:04:49.000Z</published>
    <updated>2019-05-10T03:32:56.991Z</updated>
    
    <content type="html"><![CDATA[<p>面试时总在这里吃亏，对此，本人花了两天时间彻彻底底把操作系统书进程与存储器部分看了一遍，废话不多说，直接进入正题吧。</p><h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>首先得声明，在引入虚拟存储器之前，存储器通常是将整个进程所有资源引入内存的。</p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27.png" alt=""></p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><ol><li><p>绝对装入方式</p><p>编译程序将产生绝对地址的目标代码根据地址将程序和数据存入内存。</p><ol><li>编程人员要熟悉内存。</li><li>程序在内存中不能移动。</li><li>不适用于多道程序设计环境。</li></ol></li><li><p>可重定位装入方式（静态）</p><p>编译程序将产生相对地址的目标代码，装入时需要地址映射，地址变换只在装入时一次性完成，以后不再改变。</p><ol><li>适用于多道程序环境。</li><li>程序在内存中不能移动。</li></ol></li><li><p><strong>动态运行时装入方式</strong></p><p>编译程序将产生相对地址的目标代码，装入时并不立即把相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时才运行。</p><ol><li>程序装入内存后可移动。</li></ol></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol><li><p>静态链接方式</p><p>程序运行前将各目标模块及所需库装配成一个完整模块且不再分开。</p></li><li><p>装入时动态链接</p><p>边装入边链接。（假如没有用到某一模块，也会装入内存，所有才有了方法3）</p></li><li><p><strong>运行时动态链接</strong></p><p>将链接推迟到程序运行时，如果链接到哪一模块，则再将该模块装入内存。（加快装入过程，节省空间）</p></li></ol><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol><li>单一连续分配</li><li>固定分区分配</li><li><strong>动态分区分配</strong></li></ol><h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><h4 id="首次适应算法-First-Fit"><a href="#首次适应算法-First-Fit" class="headerlink" title="首次适应算法(First Fit):"></a>首次适应算法(First Fit):</h4><p>从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</p><p>特点<br>该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。</p><p>缺点<br>低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销</p><h4 id="下次适应（next-fit）算法"><a href="#下次适应（next-fit）算法" class="headerlink" title="下次适应（next fit）算法"></a>下次适应（next fit）算法</h4><p>也称“临近适应”算法，其工作方式和最先适应算法相同（最先适应也称首次适应算法。它总是最先找到的、满足存储要求的那个空闲分区作为分配对象。），不同的是每次找到合适的空闲的分区时就记住它的位置，以便下次就从该位置开始往下查找，而不是每次都像最先适应算法那样从头开始查找。这种算法的总体结果通常要比最先适应算法差。由于它经常会在内存的末尾分配存储分区，使位于存储空间末尾的最大分区被撕裂称小的外部碎片，因此必须经常不断地进行存储紧凑。在该算法中应采取循环查找方式，即最后上个空闲区的大小仍不能满足要求时，应再从第一个空闲区开始查找，故又称为循环造就算法。</p><h4 id="最佳适应算法（Best-Fit）："><a href="#最佳适应算法（Best-Fit）：" class="headerlink" title="最佳适应算法（Best Fit）："></a>最佳适应算法（Best Fit）：</h4><p>它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</p><p>Best fit算法等价于装箱问题，举例如下：</p><p>装箱问题：有体积为V的箱子N个，体积为Vi的物品M个，求使得物品全部能够装入箱子，箱子数量的最小值。<br>假设 V=6 N=10，V1，V2，…,V10分别为：3 4 4 3 5 1 2 5 3 1。计算过程如下：<br>第一步按物品体积降序排序：5 5 4 4 3 3 3 2 1 1<br>第二步：取未装箱的最大值5装入第一个箱子。<br>第三步：判断第一个箱子是否已满，不满且剩余空间为1，搜寻剩下体积小于等于1的物品填入箱子1，箱子1填满。<br>第四步：重复第二，第三步，直到所有物品装入箱子为止，得到箱子数量为6.<br>6即时本例N的最小值。</p><h4 id="最坏适应算法（worst-fit）"><a href="#最坏适应算法（worst-fit）" class="headerlink" title="最坏适应算法（worst fit）"></a>最坏适应算法（worst fit）</h4><p>最坏适应分配算法要扫描整个空闲分区或链表，总是挑选一个最大的空闲分区分割给作业使用。该算法要求将所有的空闲分区按其容量从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。</p><p>优点：可使剩下的空闲分区不至于太小，产生碎片的几率最小，对中、小作业有利，同时该算法查找效率很高。</p><p>缺点：会使存储器中缺乏大的空闲分区。</p><p>最坏适应算法与首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。</p><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><h4 id="快速适应算法（分类搜索法）"><a href="#快速适应算法（分类搜索法）" class="headerlink" title="快速适应算法（分类搜索法）"></a>快速适应算法（分类搜索法）</h4><p>该算法就是将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样的系统中存在多个空闲分区链表。同时，在内存总设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。</p><p>该算法在搜索可分配的空闲分区时分为两步：第一步是根据进程的长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。另外，该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。优点是查找效率高。缺点是在分区归还时的算法复杂，系统开销大。此外，该算法在分配空闲分区时，是以进程为单位的，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少的存在一定的浪费。这是典型的以空间换时间的做法。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂，通常2的m次方是整个可分配内存的大小。假设系统的的可利用空间容量为2的m次方，则当系统开始运行时，整个内存区是一个大小为2的m次方的空闲分区。在系统运行过程中，由于不断地划分，将会形成若个个不连续的空闲分区，将这些分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。</p><p>当需要为进程分配一个长度大小为n的存储空间时，首先计算一个i值，使2的i-1次方小于n小于等于2的i次方，然后再空闲分区大小为2的i次方的空闲分区链表中查找。</p><p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法号。而其空间性能，由于对空闲分区进行合并，减少了空闲分区，提高了空间分区的可使用率，故由于快速适应算法，比顺序搜索法略差。</p><p>总结：虽然在当前的操作系统中，主要还是采用离散分配方式的分页和分段机制的虚拟内存机制，因为该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，目前仍然被广泛使用。</p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>由于分类搜索算法和伙伴系统算法中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在每一张管理索引表中查找到所需要的空间大小所对应的表项，从中得到对应的空间内分区链表表头指针，从而通过查找一个空闲分区。如果对空闲分区分类比较细，则相应索引表的表项也就较多，因此会显著的增加搜索索引表的表项的时间开销。</p><p>哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</p><p>当进行空闲分区分配时，根据所需要的空闲 分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol><li>紧凑</li><li>动态重定位</li><li>动态重定位分区分配算法</li></ol><h2 id="离散式存储管理方式"><a href="#离散式存储管理方式" class="headerlink" title="离散式存储管理方式"></a>离散式存储管理方式</h2><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><h4 id="连续分配存储管理方式产生的问题"><a href="#连续分配存储管理方式产生的问题" class="headerlink" title="连续分配存储管理方式产生的问题"></a><strong>连续分配存储管理方式产生的问题</strong></h4><p>在分区存储管理中，要求把进程放在一个连续的存储区中，因而会产生许多碎片。</p><h4 id="碎片问题的解决方法"><a href="#碎片问题的解决方法" class="headerlink" title="碎片问题的解决方法"></a>碎片问题的解决方法</h4><p>（1）拼接/紧凑技术—-代价较高。</p><p>（2）离散分配方式—允许将作业/进程离散放到多个不相邻接的分区中，就可以避免拼接。</p><h4 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h4><p>分页式存储管理：离散分配的基本单位是页</p><p>分段式存储管理：离散分配的基本单位是段</p><p>段页式存储管理：离散分配的基本单位是段、页</p><h4 id="什么是页"><a href="#什么是页" class="headerlink" title="什么是页"></a>什么是页</h4><p>将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面,页面大小由地址结构（逻辑）决定 ，并为各页从0开始编号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-1.png" alt=""></p><h4 id="什么是块"><a href="#什么是块" class="headerlink" title="什么是块"></a>什么是块</h4><p>内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（frame），同样从0开始编号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-2.png" alt=""></p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>在为进程分配内存时,以块为单位,将进程中若干页装入到多个不相邻的块中,最后一页常装不满一块而出现页内碎片。</p><h4 id="页表的出现"><a href="#页表的出现" class="headerlink" title="页表的出现"></a>页表的出现</h4><p>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。一个页表中包含若干个表目，1.表目的自然序号对应于用户程序中的页号。2.表目中的块号是该页对应的物理块号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-3.png" alt=""></p><h4 id="内存地址的获取"><a href="#内存地址的获取" class="headerlink" title="内存地址的获取"></a>内存地址的获取</h4><p>以页号查页表，得到对应页装入内存的块号。即可求出：<strong>内存地址＝物理块号×页大小＋页内地址</strong>。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-4.png" alt=""></p><p>例:在采用页式存储管理的系统中,某作业J的逻辑地址空间为4页(每页2048字节),且已知该作业的页面映像表如下:</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>4</td></tr><tr><td>2</td><td>6</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><p>试借助地址变换图求出有效逻辑地址4865所对应的物理地址.</p><p>解:页号  4865/2048=2   页内位移   4865%2048=769，过程如下：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-5.png" alt=""></p><p>从上面我们可以看出：CPU要想获取一个数据时，必须两次访问内存：</p><p>1、从内存中的页表中，寻找对应的物理块号，将物理块号与页内地址组合成物理地址。</p><p>2、根据组合成的物理地址，来获取数据。</p><p>为了提高效率呢，就引进了块表，什么是快表呢？</p><p>在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器”或“快表”。</p><p>在引入快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题，。总体上来说，还是减少了访问内存的时间。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-6.png" alt=""></p><h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><h4 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h4><p>引入分段存储管理方式，主要是为了满足用户和程序员的下述一系列需要：</p><p>1）<strong>方便编程</strong></p><p>通常，用户把自己的作业按照<strong>逻辑关系</strong>划分为若干个段，每个段都是<strong>从0开始</strong>编址，并有自己的<strong>名字</strong>和<strong>长度</strong>。</p><p>因此，希望要访问的逻辑地址是由<strong>段名</strong>（段号）和<strong>段内偏移量</strong>（段内地址）决定的。</p><p>2）<strong>信息共享</strong></p><p>在实现对<strong>程序和数据的共享</strong>时，是以<strong>信息的逻辑单位为基础的</strong>。比如共享某个例程和函数，分页系统中的“页”只是存放信息的<strong>物理单位</strong>（块），</p><p>并无完整的意义，不便于实现共享，然而<strong>段却是信息的逻辑单位</strong>。</p><p>3）<strong>信息保护</strong></p><p>信息保护同样是<strong>对信息的逻辑单位进行保护</strong>，因此，分段管理方式能更有效和方便的实现信息保护功能。</p><p>4）<strong>动态增长</strong></p><p>在实际应用中，往往有些段，特别是数据段，在使用过程中会<strong>不断地增长</strong>，而事先又无法确切地知道数据段会增长到多大。前面的几种存储</p><p>管理方式都难以应付这种动态增长的情况，分段存储管理方式能较好的解决这一问题。</p><p>5）<strong>动态链接</strong></p><p>动态链接是指<strong>在作业运行之前</strong>，并不把几个目标程序段链接起来。<strong>要运行时</strong>，先将<strong>主程序</strong>所对应的目标程序装入内存并启动运行，当运行过程</p><p>中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。<strong>可见，动态链接也要求以段作为管理的单位。</strong></p><h4 id="分段和段表"><a href="#分段和段表" class="headerlink" title="分段和段表"></a>分段和段表</h4><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，<strong>每个段</strong> 定义了一组<strong>逻辑信息</strong>。每个段都有自己的名字，通常可用一个<strong>段号</strong>来</p><p>代替<strong>段名</strong>，<strong>每个段都从0开始编址</strong>，并采用<strong>一段连续的地址空间</strong>。段的长度由相应的逻辑信息组的长度决定，因而<strong>各段长度不等</strong>。整个作业的</p><p>地址空间分成多个段，是<strong>二维的</strong>。</p><p>在<strong>动态分区</strong>（可变分区）分配方式中，系统为<strong>整个进程</strong>分配一个连续的内存空间。而在分段式存储管理系统中，则是为<strong>每个分段</strong>分配一个</p><p>连续的分区，而进程中的各个段可以离散地装入内存中不同的分区中。为使程序能正常运行，即能从物理内存中找出每个逻辑段所对应的位置，</p><p>应像分页系统那样，<strong>在系统中为每个进程建立一张段映射表</strong>，简称“<strong>段表</strong>”。</p><p>每个段在表中占有一个表项，其中记录了该段在内存中的<strong>起始地址</strong>（“基址”）和<strong>段长</strong>（字节）。段表一般放在内存中。在配置了段表后，</p><p>执行中的进程可通过查找段表找到每个段所对应的内存区。可见，段表是用于实现从<strong>逻辑段</strong>到<strong>物理内存区</strong>的映射。</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong>，用于存放<strong>段表始址</strong> 和<strong>段表长度TL</strong>。在进行地址变换时，</p><p>系统将逻辑地址中的<strong>段号S（0～TL-1）</strong>与<strong>段表长度TL</strong>进行比较。–  若S&gt;=TL，表示<strong>段号太大，</strong>是访问越界，于是产生越界中断信号；</p><p>若未越界，则根据段表的始址和该段的段号，计算出该段<strong>对应段表项的位置</strong>（段表的始址+段号x段表项的长度），从中读出该段在内存的</p><p>起始地址，然后再检查段内地址d是否超过该段的<strong>段长SL</strong>。若超过，即d&gt;SL,同样发出越界中断信号；若未越界，则将该段的<strong>基址</strong>与<strong>段内地址d</strong></p><p>相加，即可得到要访问的<strong>内存物理地址</strong>。</p><p>像分页系统一样，当段表放在内存中时，每当要访问一个数据，都需<strong>访问两次内存</strong>（第一次是得到物理地址，第二次是从地址中取数据），</p><p>从而极大地降低了计算机的速率。解决方法是再<strong>增设一个联想存储器</strong>（TLB），用于保存最近常用的段表项。一般情况下是段比页大，因而</p><p><strong>段表项</strong>的数目比页表项的数目少，需要的TLB也相对较小，可以显著的减少存取数据的时间。</p><h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><p>分页和分段系统都采用<strong>离散</strong>分配方式，且都要通过<strong>地址映射机构来</strong>实现地址变换。但在概念上两者完全不同，主要表现在3个方面：</p><p>– 1）页是信息的<strong>物理**</strong>单位<strong>，分页是为实现离散分配方式，消减外部碎片，提高内存的利用率。</strong>分页仅仅是由于系统管理的需要而不是用户的需要。**</p><p>段则是信息的<strong>逻辑单位</strong>，它含有一组其意义相对完整的信息。<strong>分段的目的是为了更好的满足用户的需要。</strong></p><p>– 2）页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；</p><p>而<strong>段的长度不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p><p>– 3）<strong>分页</strong>的作业地址空间是<strong>一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而<strong>分段</strong>的作业地址空间<strong>是二维的</strong>，</p><p>程序员在标识一个地址时，既需给出<strong>段名</strong>，又需给出<strong>段内地址</strong>。</p><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><p><strong>段的共享：即允许若干个进程共享一个或多个分段。</strong></p><p><strong>可重入代码</strong>（Reentrant Code）又称为“纯代码”（Pure Code），是一种<strong>允许多个进程同时访问的代码</strong>。为使各个进程所执行的代码完全相同，</p><p>绝对不允许可重入代码在执行中有任何改变。因此，<strong>可重入代码</strong>是一种<strong>不允许任何进程对它进行修改的代码</strong>。</p><p>—- 但事实上，大多数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量及数组等。为此，在每个进程中，都必</p><p>须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区，这样，程序在执行时，只需对该数据区（属于该进程私有）中的内容进行修改，并</p><p>不去改变共享的代码，这时的可共享代码即成为可重入码。</p><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>用户程序<strong>先分段</strong>，每个段内部<strong>再分页（内部原理同基本的分页、分段相同）</strong></p><p><strong><img src="http://img.blog.csdn.net/20131031091950640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></strong></p><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分三部分：段号、段内页号、页内地址</p><p><img src="http://img.blog.csdn.net/20131031091956234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h4 id="地址映射（逻辑地址—-gt-物理地址）"><a href="#地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="地址映射（逻辑地址—&gt;物理地址）"></a>地址映射（逻辑地址—&gt;物理地址）</h4><p>³ <strong>逻辑地址</strong>—– &gt;段号、段内页号、业内地址</p><p>³ 段表寄存器— &gt;段表始址</p><p>³ 段号+段表始址—- &gt;页表始址</p><p>³ 页表始址+段内页号—–&gt;存储块号</p><p>³ 块号+页内地址——&gt;<strong>物理地址</strong></p><p> <img src="http://img.blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h4 id="地址变换原理及步骤"><a href="#地址变换原理及步骤" class="headerlink" title="地址变换原理及步骤"></a>地址变换原理及步骤</h4><p><img src="http://img.blog.csdn.net/20131031092012156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>请看上图，给出逻辑地址的段号、页号、页内地址，开始进行地址变换：</p><p>1)       在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器</p><p>2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续</p><p>3)       由段号结合段表始址求出页表始址和页表大小</p><p>4)       页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续</p><p>5)       由页表始址结合段内页号求出存储块号</p><p>6)       存储块号&amp;页内地址，即得物理地址</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存。</p><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>常规存储器要求将一个作业全部装入内存方能执行。而虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配方式，则需将作业装入一个连续的内存区域中。所以，虚拟存储器抖毫无例外建立在离散分配管理方式之上。</p><ol><li>请求分页存储管理方式。</li><li>请求分段存储管理方式。</li></ol><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>请求分页系统是建立在基本分页系统的基础上，为了能支持虚拟存储器功能而</p><p>添加了请求调页功能和页面置换功能。</p><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>在请求分页系统中所须要的主要数据结构是<strong>页表</strong>。其基本作用仍然是<strong>将用户地址空间中的逻辑地址变换为内存空间中的物理地址</strong>。因为仅仅将应用程序的一部分调入内存，另一部分仍在盘上，故须在页表中再添加若干项，供程序(数据)在换进、换出时參考。在请求分页系统中的每个页表项例如以下所看到的： </p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-0.png" alt="img"></p><ul><li><p>状态位 P：指示该页是否已调入内存。 供程序访问时参考</p></li><li><p>访问字段 A：记录本页在一段时间内被访问的次数或最近未被访问的时间。 供选择页面换出时参考</p></li><li><p>修改位 M：表示该页在调入内存后是否被修改过。若修改过，则置换该页时需重写该页至外存。 供置换页面时参考</p></li><li><p>外存地址：指出该页在外存上的地址。供调入该页时参考</p></li></ul><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当所要訪问的页面不在内存时，<strong>便产生一缺页中断，请求OS将所缺之页调入内存</strong>。缺页中断作为中断，它们相同须要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的差别，主要表如今以下两个方面：<br>(1) 在指令运行期间产生和处理中断信号。通常，<strong>CPU都是在一条指令运行完后，才检查是否有中断请求到达</strong>。若有，便去响应，否则，继续运行下一条指令。然而，缺页中断是在指令运行期间，发现所要訪问的指令或数据不在内存时所产生和处理的。 </p><p>(2) 一条指令在运行期间，可能产生多次缺页中断。在下图中示出了一个样例。如在运行一条指令COPY A TO B时，可能要产生6次缺页中断，当中指令本身跨了两个页面，A和B又分别各是一个数据块，也都跨了两个页面。基于这些特征，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续运行。 </p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-7.png" alt="img"></p><h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，再为实现虚拟存储器而添加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。下图表示出了请求分页系统中的地址变换过程。在进行地址变换时，首先去检索快表，试图从中找出所要訪问的页。若找到，便改动页表项中的訪问位。对于写指令，还须将改动位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-8.png" alt="img"></p><h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3><p>例：一个采用请求分页存储管理的计算机系统，其内存（实存）容量为 256M 字节，虚拟内存容量（给用户的最大地址空间）为 4G 字节，页面大小为 4K 字节，试问：</p><p>实存物理地址应设为多少位？<br>256M = 2^28，所以为28位</p><p>实存中有多少物理块？<br>256M/4K = 64K</p><p>实存中最大块号是多少？<br>64K-1</p><p>虚存地址应设多少位？<br>4G = 2^32，所以为32位</p><p>虚拟地址空间最多可以有多少页？<br>4G/4K = 1M</p><p>页内最大偏移量是多少？ </p><p>4k-1 = 4*1024-1 = 4095</p><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数指能保证进程正常运行所需的最小的物理块数，最小物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。</p><p>采用直接寻址方式，所需的最少物理块数为 2。一块是用于存放指令，另一块用于存放数据。</p><p>间接寻址时，至少要求有三个物理块。 （间接寻址中一些物理块放的是其它物理块的块号）</p><h4 id="物理块的分配策略"><a href="#物理块的分配策略" class="headerlink" title="物理块的分配策略"></a>物理块的分配策略</h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每个进程分配固定数目 n 的物理块，在整个运行中都不改变。如出现缺页则从该进程的页面中置换一页。</p><p>每个进程分配多少个物理块难以确定.</p><p>若太少，会频繁地出现缺页中断，降低了系统的吞吐量。</p><p>若太多，内存中驻留的进程数目减少，可能造成 CPU空闲或其它资源空闲的情况。</p><h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>为每个进程分配一定数目的物理块，但 OS 自留一空闲块队列，若发现缺页，则从空闲块队列中分配一空闲块与该进程，并调入缺页于其中。当空闲块队列用完时，OS 才从内存中任选择一页置换。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每个进程分配一定数目的物理块，若发现缺页，则从该进程的页面中置换一页，不会影响其它进程的运行。根据进程缺页率高低，则可增加或减少分配给该进程的物理块。</p><h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>预调页：将预计在不久之后便会被访问的页面预先调入内存。</p><p>进程的页一般存放在外存的一个连续区域中。一次调入若干个相邻的页会比一次调入一页更高效。</p><p>但如果调入的一批页面中的大多数都未被访问，则浪费了内存。</p><h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。但这种策略每次仅调入一页，须花费较大的系统开销，增加了启动磁盘 I/O 的频率。</p><h5 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h5><p>在请求分页系统中，外存分成了按离散分配方式存放文件的文件区和按连续分配方式存放对换页的对换区。进程发出缺页请求时，从何处将缺页调入内存呢？</p><p>对换区：如果系统有足够的对换区空间，运行前可将与进程相关的文件从文件区复制至对换区，以后缺页时全部从对换区调页。</p><p>文件区：如果系统没有足够的对换区空间，凡是不会被修改的文件，直接从文件区调页，不必回写（换出） 。对可能会修改的文件第一次直接从文件区调页，换出时换至对换区，以后从对换区调页。</p><p>UNIX 方式：凡未运行过的页面均从文件区调页，运行过的页面和换出的页面均从对换区调页。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）（理想置换算法）"><a href="#最佳置换算法（OPT）（理想置换算法）" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 </p><p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：<br>    7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1<br>进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。<br>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td></td><td>7</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>4</td><td></td><td></td><td>0</td><td></td><td></td><td>0</td><td></td><td></td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td></td><td></td><td>3</td><td></td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td></td><td>√</td><td></td></tr></tbody></table><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 </p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td>2</td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>0</td><td>0</td><td></td><td></td><td>7</td><td>7</td><td>7</td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>1</td><td>1</td><td></td><td></td><td>1</td><td>0</td><td>0</td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>2</td><td></td><td></td><td>2</td><td>2</td><td>1</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。<br>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</p><table><thead><tr><th>访问页面</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>物理块1</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td><td>4</td><td>5</td><td></td><td></td><td>,5’</td><td>5</td><td></td></tr><tr><td>物理块2</td><td></td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td><td>1</td><td></td><td></td><td>3</td><td>3</td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td>4</td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td></tr><tr><td></td><td></td><td>1</td><td>1</td><td>1</td><td></td><td></td><td>5</td><td>5</td><td>5</td><td>5</td><td>4</td><td>4</td></tr><tr><td>物理块2*</td><td></td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td></tr><tr><td>物理块3*</td><td></td><td></td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>物理块4*</td><td></td><td></td><td></td><td>4</td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p><strong>注意：内存的页面中“最老“的页面，会被新的网页直接覆盖，而不是“最老“的页面先出队，然后新的网页从队尾入队。</strong></p><h4 id="最近最久未使用（LRU）算法"><a href="#最近最久未使用（LRU）算法" class="headerlink" title="最近最久未使用（LRU）算法"></a>最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 </p><p>再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>1</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td></td><td>0</td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td></td><td>2</td><td></td><td>7</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td></tr></tbody></table><p>实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。<br>***LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p><h4 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<br>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。<br>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p><ol><li>最近未被访问，也未被修改(u=0, m=0)。</li><li>最近被访问，但未被修改(u=1, m=0)。</li><li>最近未被访问，但被修改(u=0, m=1)。</li><li>最近被访问，被修改(u=1, m=1)。</li></ol><p>算法执行如下操作步骤：</p><ol><li>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</li><li>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</li><li>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</li></ol><p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p><p>例题：</p><p>在5个页框上使用LRU页面替换算法，当页框初始为空时，引用序列为0、1、7、8、6、2、3、7、2、9、8、1、0、2，系统将发生（C）次缺页</p><p>​    A、13            B、12           C、11          D、8</p><p>解析：内存中驻留5个页框：</p><table><thead><tr><th>访问页面</th><th>0</th><th>1</th><th>7</th><th>8</th><th>6</th><th>2</th><th>3</th><th>7</th><th>2</th><th>9</th><th>8</th><th>1</th><th>0</th><th>2</th></tr></thead><tbody><tr><td>页框1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>页框2</td><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>页框3</td><td></td><td></td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>0</td><td>0</td></tr><tr><td>页框4</td><td></td><td></td><td></td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr><td>页框5</td><td></td><td></td><td></td><td></td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>是否缺页</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y(换页)</td><td>Y(换页)</td><td>N</td><td>N</td><td>Y(换页)</td><td>Y(换页)</td><td>Y(换页)</td><td>Y(换页)</td><td>N</td></tr></tbody></table><p> LRU是堆栈类的算法，最后访问的页面放在栈顶，可以得到答案为C。</p><p>编程思路：</p><p>1,用结构体成员记录访问的顺序，换页时选取times最大的那个替换掉。</p><p>struct LRU { int data; </p><p>　　　　　　　int times;};记录访问次序</p><p>struct queue{  LRU *p; int front; int rear</p><p>}Qe;</p><p>(1)队列未满时，依次添加新访问的页面，并Qe.p[i++].times++</p><p>(2)队列满了 a, 新访问的页面在队列中，times设为0，之前在它前面的LRU.times++</p><p>​                b, 新访问的页面不在队列中，需替换掉times最大的页面，并设新页面times=0，对列中其它页面times++</p><p>2,用队列中存放的位置表示最后访问时间（用线性表涉及大量元素移动，用链表好些）</p><p>队列未满时，依次压入；队列满，则查看对列中是否存在，若存在，将其移动到队尾，若不存在，删除队首页面，并在队尾加入新页面。</p><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="页面抖动（颠簸）"><a href="#页面抖动（颠簸）" class="headerlink" title="页面抖动（颠簸）"></a>页面抖动（颠簸）</h3><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p><h3 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h3><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p><p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试时总在这里吃亏，对此，本人花了两天时间彻彻底底把操作系统书进程与存储器部分看了一遍，废话不多说，直接进入正题吧。&lt;/p&gt;
&lt;h1 id=&quot;存储器管理&quot;&gt;&lt;a href=&quot;#存储器管理&quot; class=&quot;headerlink&quot; title=&quot;存储器管理&quot;&gt;&lt;/a&gt;存储器管理
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="操作系统" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟存储器" scheme="http://qianyouyou.cn/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
      <category term="分页" scheme="http://qianyouyou.cn/tags/%E5%88%86%E9%A1%B5/"/>
    
      <category term="分段" scheme="http://qianyouyou.cn/tags/%E5%88%86%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>向死而生，知菜而后勇</title>
    <link href="http://qianyouyou.cn/2019/04/24/2019-04-24/"/>
    <id>http://qianyouyou.cn/2019/04/24/2019-04-24/</id>
    <published>2019-04-24T03:46:37.000Z</published>
    <updated>2019-05-08T08:11:38.926Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。</p><p>回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)</p><p>回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起起伏伏，体验感极差。说到经历的话，可以一句话来形容，便是以腾讯起，以腾讯终。当然，不是以腾讯录用而终，而是以被腾讯pass为终QYQ</p><p>这一个月里，虽然各种面试东跑西跑面的身心疲惫，但总的来说还是有收获的，至少让自己认清自己很菜qyq，当然这是开玩笑的啦。首先现在的我已经清楚未来要去的敌方以及要走的路了，而且在其中收获的面试经验是无法替代的。</p><p>还记得三月初腾讯们各种投简历带的我还不明白为什么要找实习便也跟着一起投。还记得第一次收到腾讯的面试通知，既兴奋又恐惧，当时还很稚嫩的我（丢不丢脸啊）收面试官小哥哥的照顾竟然莫名其妙过了。还记得西山居经历四次面试本来以为稳了，结果因为没有什么面试经验导致实习时间上的问题最终被刷，之后好长一段时间恐惧面试，不想面试。直到前两天腾讯正式批二面结束后，状态变为了HR面试，当时那个兴奋与感激啊，结果没过两天就又由HR面试变成了初试（嘿嘿，面试本就是大起大落，大落最差不过从头再来，所以说只要没拿到offer就不存在稳不稳）。不过渐渐的，我也明白了实习的意义。其实当初找实习纯粹是被氛围带起的，经过这么多面试之后，一方面发现自己还有很多方面需要学习与总结，另一方面渐渐也发现其实实不实习都无关紧要，做项目的话自己也可以做嘛，只要自己实力够强。而找实习后反而有点浪费学习时间，反正暂时也找不到，不如静下心来好好学习，自己做项目积累经验吧，为秋招做好准备。毕竟这样就可以做自己想做的产品了（偷笑）</p><p>现在制定计划，并以今天为起点，抓紧学习，之后就不找实习了，直接面向秋招。</p><p>目标：C++，设计模式，Linux网络编程，操作系统，TCP/IP，编译原理，数据库，计算机组成原理。</p><p>重点学习内容：C++，Linux系统编程与网络编程，操作系统，计算机网络，编译原理，数据库。</p><p>项目：聊天室项目，云盘项目，内存池项目，5V5游戏项目</p><p>目前的资源：C++primer，Effictive C++，深入理解计算机系统，图解TCP/IP，图解HTTP，LINUX高性能服务器编程，HeadFirst设计模式，STL源码剖析，编程之美，Linux鸟哥的私房菜，UNIX环境高级编程，计算机网络，计算机操作系统，计算机组成原理等等。</p><p>计划：</p><p>4月末——计算机网络，计算机操作系统，黑马课程复习。</p><p>5月——EffictiveC++，HeadFirst设计模式，Linux高性能服务器编程，计算机网络，编译原理，计算机操作系统，计算机组成原理，黑马课程巩固。</p><p>6月——C++primer，STL源码剖析，深入了解计算机系统，编程之美。</p><p>7月——8月——项目，二遍课程复习</p><p>附上这一个月的心路历程（我的三体的一首词）</p><p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p><p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p><p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p><p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p><p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p><p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。&lt;/p&gt;
&lt;p&gt;回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)&lt;/p&gt;
&lt;p&gt;回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>进程的描述与控制VS处理机调度与死锁</title>
    <link href="http://qianyouyou.cn/2019/04/22/2019-04-22/"/>
    <id>http://qianyouyou.cn/2019/04/22/2019-04-22/</id>
    <published>2019-04-22T13:20:04.000Z</published>
    <updated>2019-05-10T03:32:15.304Z</updated>
    
    <content type="html"><![CDATA[<p>成也进程，败也进程，不为成败，只为进程。这是一篇凉文，面试正挂于此。哎，不多说了，直接进入正题吧。</p><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p>每个结点可用来表示一个进程或进程段，乃至一条语句，结点间的有向边则表示两个结点间存在偏序或前趋关系。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22-1.png" alt=""></p><p>例如上图P1与P2之间有前趋关系，所以P1与P2只能顺序执行。再如P2与P3之间没有前趋关系，所以P2与P3可以并发执行。</p><p>说白了就是有向无环图，可以利用拓扑排序进行执行。</p><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>简单理解，进程就是程序段+数据段+PCB。</p><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>由于多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并且具有间断性，以及运行结果不可在现性的特征。由此决定了程序是不能参与并发执行的，否则，程序的运行便失去了意义。为了能使程序并发执行，并且对并发执行的程序加以描述和控制，人们引入了进程。</p><p>为使每个并发执行程序（含数据）都能独立运行，在操作系统中加入一个专门的数据结构——进程控制块（Process Control Block，PCB）</p><p>系统利用PCB描述进程的基本情况和活动过程。一般情况下，我们把进程实体简称为进程，所谓创建进程就是创建进程实体中的PCB；撤销进程就是撤销进程的PCB。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机尚顺序执行是所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上执行的过程，<strong>它是系统执行资源分配和调度的一个独立单位</strong>。</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><strong>动态性</strong>：进程是进程实体的执行过程，由创建而生，调度而执行，撤销而亡。进程实体具有生命周期，而程序仅是一组有序命令的集合，存在于某种介质之上，因而是静态的。</li><li><strong>并发性</strong>：多个进程实体同存于内存之中，且能在一段时间同时运行。程序没有PCB，因而不能并发。</li><li><strong>独立性</strong>：进程实体是一个能独立运行，独立获得资源，独立接受调度的基本单位。而程序没有PCB，固不能执行以上操作。</li><li><strong>异步性</strong>：进程是按异步方式运行的，即按各自独立的、不可预知的速度推进，因而结果不可再现。为此，OS中引入进程的概念，并配置相应的同步机制。</li></ul><h3 id="状态及转换"><a href="#状态及转换" class="headerlink" title="状态及转换"></a>状态及转换</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.png" alt=""></p><h4 id="三基态："><a href="#三基态：" class="headerlink" title="三基态："></a>三基态：</h4><ul><li><strong>就绪状态</strong>：进程已处于准备好运行的状态，只差CPU，在就绪队列等待调度。</li><li><strong>执行状态</strong>：进程已获得CPU，并立即执行。</li><li><strong>阻塞状态</strong>：正在运行的进程由于发生某种事件（I/O请求，申请缓冲区失败等）暂时无法继续执行，而让受阻进程处于暂停状态。进入阻塞队列。阻塞时进程自身的主动行为。</li></ul><h4 id="创建与终止状态："><a href="#创建与终止状态：" class="headerlink" title="创建与终止状态："></a>创建与终止状态：</h4><ul><li><strong>创建状态</strong>：申请空白PCB，并向PCB填写控制和管理进程的信息，然后分配资源，最后转入就绪队列中。</li><li><strong>终止状态</strong>：等待操作系统善后处理，然后PCB清零，返还系统。</li></ul><h4 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.jpg" alt=""></p><p>当操作作用于某个进程时，该进程处于静止状态。</p><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><ol><li>终端用户需要。例如运行时改bug。</li><li>父进程请求。</li><li>符合调节需要。</li><li>操作系统需要。例如检查运行情况。</li></ol><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><h4 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h4><ol><li><strong>进程描述符</strong>：进程标识符用于唯一标识进程。</li><li><strong>处理机状态</strong>：进程切换时保留现场以及现场恢复。</li><li><strong>进程调度信息</strong>：进程状态及相关进程调度信息。</li><li><strong>进程控制信息</strong>：用于进程控制所需信息。</li></ol><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制一般由OS原语实现。</p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ol><li>支撑功能<ul><li>中断处理。</li><li>始终处理。</li><li>原语操作。原语由若干指令组成，用于完成一定功能的过程。原子操作，一个操作中所有行动要么全做，要么不做。</li></ul></li><li>资源管理功能<ul><li>进程管理。</li><li>存储器管理。</li><li>设备管理。</li></ul></li></ol><h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p>创建原语：Creat</p><p>终止原语：Holt</p><h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><p>阻塞原语：block</p><p>唤醒原语：wakeup</p><h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><p>挂起原语：suspend</p><p>激活原语：active</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><ol><li>关中断</li><li>利用Test-and-Set指令实现互斥</li><li>利用Swap指令实现进程互斥</li></ol><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol><li>整型信号量</li><li>记录型信号量</li><li>AND型信号量</li><li>信号量集</li></ol><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 </p><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><p>生产者-消费者问题</p><p>读者-写者问题</p><p>哲学家进餐问题</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol><li><p>共享存储器系统</p></li><li><p>管道（pipe）通信系统</p></li><li><p>消息传递系统</p><ul><li><p>消息传递的实际功能以一对原语的形式提供：</p><ul><li>send(destination,message)</li><li>receive(source,message)</li></ul><p>这是进程间进程消息传递所需要的最小操作集。</p><p>一个进程以消息的形式给另一个指定的目标进程发送消息；</p><p>进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</p></li></ul></li><li><p>客户机-服务机系统</p><ul><li>套接字socket</li></ul></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>作为调度和分派的基本单位。</p><p>每个线程有一个线程控制块TCB。</p><h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h3 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h3><p><strong>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</strong></p><p>高级调度：(High-Level Scheduling)又称为作业调度，它决定把外存上后备作业调入内存运行；</p><p>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</p><p>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。把不能正常运行的进程调至外存等待。</p><h4 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a>处理机调度算法</h4><p>CPU利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间)</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>周转时间Ti = 完成时间 - 到达时间</p><p>平均周转时间T = 1/n( T1 + …… + Ti + …… + Tn )</p><p>带权周转时间为周转时间/运行时间（越小越好）</p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>响应时间快，均衡性好。</p><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>考虑截至时间，提高可预测性。</p><h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><h4 id="作业（Job）"><a href="#作业（Job）" class="headerlink" title="作业（Job）"></a>作业（Job）</h4><p>程序的集合+数据的集合+作业说明书+JCB。</p><p>三个状态：后备状态，运行状态，收容状态。</p><p>三个阶段：收容阶段（创建JCB），运行阶段，完成阶段（回收JCB）。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol><li>接纳多少作业</li><li>接纳哪些作业</li></ol><h4 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h4><h5 id="先来先服务算法（first-come-first-served，FCFS）"><a href="#先来先服务算法（first-come-first-served，FCFS）" class="headerlink" title="先来先服务算法（first-come first-served，FCFS）"></a>先来先服务算法（first-come first-served，FCFS）</h5><p>系统按照作业到达的优先顺序调度。</p><p>不利于短作业。</p><h5 id="短作业优先算法（short-job-first，SJF）"><a href="#短作业优先算法（short-job-first，SJF）" class="headerlink" title="短作业优先算法（short job first，SJF）"></a>短作业优先算法（short job first，SJF）</h5><p>系统以作业长短为优先级。</p><p>不利于长作业，容易出现进程饥饿现象。</p><h5 id="优先级调度算法（priority-scheduling-algorithm，PSA）"><a href="#优先级调度算法（priority-scheduling-algorithm，PSA）" class="headerlink" title="优先级调度算法（priority-scheduling algorithm，PSA）"></a>优先级调度算法（priority-scheduling algorithm，PSA）</h5><p>根据作业紧迫程度，由外界赋予优先级。</p><h5 id="高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）"><a href="#高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）" class="headerlink" title="高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）"></a>高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）</h5><p>动态优先级，根据长短赋初值，根据等待时间加权。作业越短，初值越大，等待时间越长，加权越大。</p><p>Rp = 响应时间/要求服务时间</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="剥夺方式"><a href="#剥夺方式" class="headerlink" title="剥夺方式"></a>剥夺方式</h5><p>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</p><h5 id="非剥夺方式"><a href="#非剥夺方式" class="headerlink" title="非剥夺方式"></a>非剥夺方式</h5><p>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</p><h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><ol><li>保存处理机现场信息。</li><li>按某种算法选取进程。</li><li>把处理器分配给进程。</li></ol><h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p>进程调度也称为低级调度，它所调度的对象为进程（或者内核级线程），而进程调度算法主要有以下几种：</p><h5 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h5><p>它的原理通俗来讲就是队列中每一个进程都获得了一定的执行时间，从几ms到几百ms，当一个执行时间结束，计时器会发出一个信号，此时正在执行的进程将被中断，同时此进程将被放在队列的末尾，然后执行这时候的队列的队首进程，因此队列中每一个进程都将获得一定时间执行。</p><h5 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h5><p>先来先服务调度算法是一种最简单的调度算法，可用于作业调度，也可用于进程调度。</p><h5 id="短作业优先调度算法（SJ-P-F）"><a href="#短作业优先调度算法（SJ-P-F）" class="headerlink" title="短作业优先调度算法（SJ(P)F）"></a>短作业优先调度算法（SJ(P)F）</h5><p>短作业（进程）优先调度算法是指短作业或者短进程的优先调度算法，它们分别作用于作业调度和进程调度，它是先来先服务调度算法的一种优化版本。</p><h5 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h5><p>为了解决在短作业优先调度算法中进程的紧迫程度问题，我们引入高优先权优先调度算法，高优先权调度算法的方法也很简单，就是在队列中选取优先权最高的进程装入内存，该算法又分为以下两类：</p><p>①非抢占式优先权算法<br>如果系统已经分配好一个优先权最高的进程，它会一直被执行，直到结束或者因为某事件放弃执行，此时系统才会选择另外一个优先权最高的进程，这种调度算法主要被用于批处理系统中。</p><p>②抢占式优先权算法<br>系统在队列中把一个优先权最高的进程执行，但如果在执行中又出现一个优先权更高的进程，此时当前进程被停止，换入另外一个优先权更高的进程，这种调度算法主要被用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统中。</p><p>优先权的类型：</p><p>优先权的类型被分为静态优先权和动态优先权。</p><p>静态优先权就是给定某个整形数字来表示进程的优先级，数字越小表示优先级越高，数字越大，进程优先级越低。</p><p>动态优先权随着进程的创建而被创建，可以随着进程的推进或者等待时间而变化。</p><h5 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h5><p>进程就绪队列由一个拆成多个，不同类型进程分配不同就绪队列，不同就绪队列采用不同算法。一个就绪队列可以设置不同优先级，不同就绪队列本身也可设优先级。</p><p>系统根据不同的用户选用不同的调度策略。</p><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>设置多个就绪队列，每个队列的优先级逐渐降低，同时每个队列的执行时间也各不相同，优先级越高的队列，执行时间越短，优先级越低的队列，执行时间越长。<br>当一个进程进入内存后，首先进入第一个队列的末尾，按照先来先服务的调度算法进行调度，如果在第一个队列的执行时间内未执行完成，此时把此进程放入第二个队列的末尾，按照之前的方法进行执行，直到在某一个队列的队首执行完成。</p><p>当第一个队列全部执行完成，此时系统才会执行第二个队列，但是如果此时又有新的进程进入，此时执行完毕这个时间段，立刻把此进程分配给新的作业。</p><h5 id="根据公平原则的调度算法"><a href="#根据公平原则的调度算法" class="headerlink" title="根据公平原则的调度算法"></a>根据公平原则的调度算法</h5><p>公平分配每个进程相同的处理机时间，或按进程比例公平分配用户相同的处理机时间。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="锁与信号量"><a href="#锁与信号量" class="headerlink" title="锁与信号量"></a>锁与信号量</h3><p>锁强调于资源，信号量强调于执行次序。</p><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>重用性资源与消耗性资源</p><p>可抢占性资源与不可抢占资源</p><h3 id="死锁起因"><a href="#死锁起因" class="headerlink" title="死锁起因"></a>死锁起因</h3><p>源于多个进程对资源的争夺，不仅对<strong>不可抢占资源</strong>金进行争夺时容易产生死锁，而且对<strong>消耗性资源</strong>抢夺也会产生死锁。还有就是进程推进不当引起死锁。</p><h3 id="死锁产生必要条件"><a href="#死锁产生必要条件" class="headerlink" title="死锁产生必要条件"></a>死锁产生必要条件</h3><ol><li>互斥条件（不能破坏该条件）</li><li>请求与保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ol><h3 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h3><p>以下四种方法从上往下防范程度逐渐减弱，但资源利用率与并发程度逐渐提高。</p><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏”请求保持条件“"><a href="#破坏”请求保持条件“" class="headerlink" title="破坏”请求保持条件“"></a>破坏”请求保持条件“</h5><ol><li>一次性分配所有需要的资源。</li><li>用到时再调用资源，用完即释放资源。</li></ol><h5 id="破坏”不可抢占条件“"><a href="#破坏”不可抢占条件“" class="headerlink" title="破坏”不可抢占条件“"></a>破坏”不可抢占条件“</h5><p>调用资源时如果资源被占用，则必须释放已有所有资源，用时再调用。</p><h5 id="破坏”循环等待条件“"><a href="#破坏”循环等待条件“" class="headerlink" title="破坏”循环等待条件“"></a>破坏”循环等待条件“</h5><p>先给进程编号并排序，再按照顺序分配资源。</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><strong>银行家算法的数据结构</strong><br>可利用资源向量（Available）：系统还可以分配的资源</p><p>最大需求矩阵（Max）：进程的最大资源需要</p><p>分配矩阵（Alloction）：进程已经获得的资源</p><p>需求矩阵（Need）：进程还需要获得的资源</p><p><strong>银行家算法</strong></p><p>假设 P1 进程提出请求 K 个资源</p><p>如果 K &lt;= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源</p><p>如果 K &lt;= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 </p><p>Available系统试探分配资源，并修改下列数据</p><p>Available = Available - K；表示分配给 P1 K 个资源后，还剩多少系统可分配资源</p><p>Allocation = Allocation + K；表示 P1 已经获得的资源</p><p>Need = Need - K；表示进程 P1 还需要获得的资源</p><p>此时系统执行安全性算法，计算进程是否处于安全性状态</p><p>PS：此时是执行的试探分配，为的是检查进程是否处于安全状态，不处于则试探分配作废</p><p><strong>安全性算法</strong></p><p>安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态</p><p>两个向量</p><p>工作向量（Work）：系统提供给进程的各类资源数目</p><p>Finish：表示系统是否有足够的资源分配给进程，这是一个布尔值。初始化为 false。</p><p><strong>算法描述</strong></p><p>在进程集合中找到下述条件的进程</p><p>Finish[ i ] = false;</p><p>Need &lt;= Work</p><p>进程执行完毕</p><p>Work = Work + Allocation</p><p>Finish [ i ] = true</p><p>返回继续执行 1 ，寻找其他的进程分配资源</p><p>若所有的 Finish 为 true 则安全</p><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>资源分配图。</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>杀死进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;成也进程，败也进程，不为成败，只为进程。这是一篇凉文，面试正挂于此。哎，不多说了，直接进入正题吧。&lt;/p&gt;
&lt;h1 id=&quot;进程的描述与控制&quot;&gt;&lt;a href=&quot;#进程的描述与控制&quot; class=&quot;headerlink&quot; title=&quot;进程的描述与控制&quot;&gt;&lt;/a&gt;进程的描述
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="操作系统" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://qianyouyou.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁" scheme="http://qianyouyou.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="进程调度" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>[转]HashMap实现原理及源码分析</title>
    <link href="http://qianyouyou.cn/2019/04/20/2019-04-20-1/"/>
    <id>http://qianyouyou.cn/2019/04/20/2019-04-20-1/</id>
    <published>2019-04-20T11:55:55.000Z</published>
    <updated>2019-04-27T15:43:10.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p><h1 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h1><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p><p>　　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p><p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113180447499-1953916974.png" alt="img"></p><p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><p>　　<strong>哈希冲突</strong></p><p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p><h1 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h1><p>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><br><span class="line">transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p> Entry是HashMap中的一个静态内部类。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构</span><br><span class="line">    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span><br><span class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 所以，HashMap的整体结构如下</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="img">　　</p><p>　　<strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p><p>其他几个重要字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//实际存储的key-value键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span><br><span class="line">int threshold;</span><br><span class="line">//负载因子，代表了table的填充度有多少，默认是0.75</span><br><span class="line">final float loadFactor;</span><br><span class="line">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span><br><span class="line">transient int modCount;</span><br></pre></td></tr></table></figure><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>我们看下其中一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p><p>　　OK,接下来我们来看看put操作的实现吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果key为null，存储位置为table[0]或table[0]的冲突链上</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀</span><br><span class="line">    int i = indexFor(hash, table.length);//获取在table中的实际位置</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span><br><span class="line">    addEntry(hash, key, value, i);//新增一个entry</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先来看看inflateTable这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂</span><br><span class="line">        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">       // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">       return number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">   &#125;[​](javascript:void(0);)</span><br></pre></td></tr></table></figure><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><p>hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　/**</span><br><span class="line"> * 返回数组下标</span><br><span class="line"> */</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    1  0  0  1  0</span><br><span class="line">&amp;   0  1  1  1  1</span><br><span class="line">__________________</span><br><span class="line">    0  0  0  1  0    = 2</span><br></pre></td></tr></table></figure><p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p><p>所以最终存储位置的确定流程是这样的：</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115133556388-1098209938.png" alt="img"></p><p>再来看看addEntry的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115215812138-679881037.png" alt="img"></p><p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001404732-625340289.png" alt="img"></p><p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001717560-1455096254.png" alt="img"></p><p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><p>get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">　　　　 //如果key为null,则直接去table[0]处去检索即可。</span><br><span class="line">       if (key == null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">            </span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过key的hashcode值计算hash值</span><br><span class="line">        int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h1><p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chengxiao on 2016/11/15.</span><br><span class="line"> */</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    private static class Person&#123;</span><br><span class="line">        int idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(int idCard, String name) &#123;</span><br><span class="line">            this.idCard = idCard;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (this == o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (o == null || getClass() != o.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            //两个对象是否等值，通过idCard来确定</span><br><span class="line">            return this.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();</span><br><span class="line">        Person person = new Person(1234,&quot;乔峰&quot;);</span><br><span class="line">        //put到hashmap中去</span><br><span class="line">        map.put(person,&quot;天龙八部&quot;);</span><br><span class="line">        //get取出，从逻辑上讲应该能输出“天龙八部”</span><br><span class="line">        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：null</span><br></pre></td></tr></table></figure><p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
      <category term="HashMap" scheme="http://qianyouyou.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>C++常用知识点STL总结</title>
    <link href="http://qianyouyou.cn/2019/04/20/2019-04-20/"/>
    <id>http://qianyouyou.cn/2019/04/20/2019-04-20/</id>
    <published>2019-04-20T08:33:45.000Z</published>
    <updated>2019-04-27T15:42:33.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><h2 id="六大组件简介"><a href="#六大组件简介" class="headerlink" title="六大组件简介"></a>六大组件简介</h2><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p><p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p><p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p><p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p><p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p><p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p><h2 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h2><p>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</p><p>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</p><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><ul><li><p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p></li><li><p><strong>高性能</strong>：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</p></li><li><p><strong>高移植性</strong>：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p></li></ul><h1 id="STL常用三大组件"><a href="#STL常用三大组件" class="headerlink" title="STL常用三大组件"></a>STL常用三大组件</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>序列式容器强调值的排序，序列式容器中的<strong>每个元素均有固定的位置</strong>，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</p><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间<strong>没有严格的物理上的顺序关系</strong>，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="质变算法"><a href="#质变算法" class="headerlink" title="质变算法"></a>质变算法</h3><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。</p><h3 id="非质变算法"><a href="#非质变算法" class="headerlink" title="非质变算法"></a>非质变算法</h3><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等中会更改。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>提供一种方法，使之能够<strong>依序寻访某个容器所含的各个元素</strong>，而又无需暴露该容器的内部表示方式。</p><p>迭代器的种类:</p><table><thead><tr><th>输入迭代器</th><th>提供对数据的只读访问</th><th>只读，支持++、==、！=</th></tr></thead><tbody><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//STL 中的容器 算法 迭代器</span><br><span class="line">void test01()&#123;</span><br><span class="line">vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组</span><br><span class="line">v.push_back(1); //vector 容器提供的插入数据的方法</span><br><span class="line">v.push_back(5);</span><br><span class="line">v.push_back(3);</span><br><span class="line">v.push_back(7);</span><br><span class="line">//迭代器</span><br><span class="line">vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span><br><span class="line">vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//算法 count 算法 用于统计元素的个数</span><br><span class="line">int n = count(pStart, pEnd, 5);</span><br><span class="line">cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Teacher(int age) :age(age)&#123;&#125;;</span><br><span class="line">~Teacher()&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器</span><br><span class="line">Teacher t1(10), t2(20), t3(30);</span><br><span class="line">v.push_back(t1);</span><br><span class="line">v.push_back(t2);</span><br><span class="line">v.push_back(t3);</span><br><span class="line">vector&lt;Teacher&gt;::iterator pStart = v.begin();</span><br><span class="line">vector&lt;Teacher&gt;::iterator pEnd = v.end();</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//存储 Teacher 类型指针</span><br><span class="line">void test03()&#123;</span><br><span class="line">vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针</span><br><span class="line">Teacher* t1 = new Teacher(10);</span><br><span class="line">Teacher* t2 = new Teacher(20);</span><br><span class="line">Teacher* t3 = new Teacher(30);</span><br><span class="line">v.push_back(t1);</span><br><span class="line">v.push_back(t2);</span><br><span class="line">v.push_back(t3);</span><br><span class="line">//拿到容器迭代器</span><br><span class="line">vector&lt;Teacher*&gt;::iterator pStart = v.begin();</span><br><span class="line">vector&lt;Teacher*&gt;::iterator pEnd = v.end();</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//容器嵌套容器 难点(不理解，可以跳过)</span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt; vector&lt;int&gt; &gt; v;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5;i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i * 10);</span><br><span class="line">v3.push_back(i * 100);</span><br><span class="line">&#125;</span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line"></span><br><span class="line">for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">//test01();</span><br><span class="line">//test02();</span><br><span class="line">//test03();</span><br><span class="line">test04();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><ul><li><strong>String和char*</strong>：<ul><li>Char*是一个指针，String是一个类。</li><li>string封装了char*，管理这个字符串，是一个char*型的容器。</li></ul></li><li>String封装了很多实用的成员方法：<ul><li>查找find，拷贝copy，删除delete，替换replace，插入insert。</li></ul></li><li>不用考虑内存释放和越界：<ul><li>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li></ul></li></ul><h3 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string();//创建一个空的字符串 例如: string str;      </span><br><span class="line">string(const string&amp; str);//使用一个string对象初始化另一个string对象</span><br><span class="line">string(const string&amp; str, size_t pos, size_t n);//使用一个string对象的pos位及后n位初始化另一个对象</span><br><span class="line">string(const string&amp; str, size_t n);//使用一个string对象的前n位初始化另一个对象</span><br><span class="line">string(const char* s);//使用字符串s初始化</span><br><span class="line">string(size_t n, char c);//使用n个字符c初始化</span><br></pre></td></tr></table></figure><h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串</span><br><span class="line">string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; operator=(char c);//字符赋值给当前的字符串</span><br><span class="line">string&amp; assign(const char *s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串</span><br><span class="line">string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串</span><br><span class="line">string&amp; assign(int n, char c);//用n个字符c赋给当前字符串</span><br><span class="line">string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串</span><br></pre></td></tr></table></figure><h3 id="string获取字符操作"><a href="#string获取字符操作" class="headerlink" title="string获取字符操作"></a>string获取字符操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[](int n);//通过[]方式取字符</span><br><span class="line">char&amp; at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure><h3 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator+=(const string&amp; str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char* str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char c);//重载+=操作符</span><br><span class="line">string&amp; append(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line">string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(const string &amp;s);//同operator+=()</span><br><span class="line">string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c</span><br></pre></td></tr></table></figure><h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置</span><br><span class="line">int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置</span><br><span class="line">int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置</span><br><span class="line">int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</span><br><span class="line">string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</span><br><span class="line">string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s</span><br></pre></td></tr></table></figure><h3 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span><br><span class="line">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span><br><span class="line">大写的A比小写的a小。</span><br><span class="line">*/</span><br><span class="line">int compare(const string &amp;s) const;//与字符串s比较</span><br><span class="line">int compare(const char *s) const;//与字符串s比较</span><br></pre></td></tr></table></figure><h3 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure><h3 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; insert(int pos, const char* s); //插入字符串</span><br><span class="line">string&amp; insert(int pos, const string&amp; str); //插入字符串</span><br><span class="line">string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c</span><br><span class="line">string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符</span><br></pre></td></tr></table></figure><h3 id="string和c-type转换"><a href="#string和c-type转换" class="headerlink" title="string和c-type转换"></a>string和c-type转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//string 转 char*</span><br><span class="line">string str = &quot;itcast&quot;;</span><br><span class="line">const char* cstr = str.c_str();</span><br><span class="line">//char* 转 string </span><br><span class="line">char* s = &quot;itcast&quot;;</span><br><span class="line">string str(s);</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。</p><p>通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;abcdefg&quot;;</span><br><span class="line">char&amp; a = s[2];</span><br><span class="line">char&amp; b = s[3];</span><br><span class="line"></span><br><span class="line">a = &apos;1&apos;;</span><br><span class="line">b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = &quot;pppppppppppppppppppppppp&quot;;</span><br><span class="line"></span><br><span class="line">//a = &apos;1&apos;;</span><br><span class="line">//b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ab12efg</span><br><span class="line">0x6dfed4</span><br><span class="line">pppppppppppppppppppppppp</span><br><span class="line">0x1816b0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector与Array数组"><a href="#vector与Array数组" class="headerlink" title="vector与Array数组"></a>vector与Array数组</h3><p>Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p><p>Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-vector_1.png" alt=""></p><h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，所以vector提供的是随机访问迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a><strong>vector的数据结构</strong></h3><p>Vector所采用线性连续空间，它以两个迭代器Myfirst和Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这便是<strong>容量</strong>的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是分配一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数</span><br><span class="line">vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。</span><br><span class="line">vector(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">vector(const vector &amp;vec);//拷贝构造函数。</span><br><span class="line"></span><br><span class="line">//例子 使用第二个构造函数 我们可以...</span><br><span class="line">int arr[] = &#123;2,3,4,1,9&#125;;</span><br><span class="line">vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));</span><br></pre></td></tr></table></figure><h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">vector&amp; operator=(const vector  &amp;vec);//重载等号操作符</span><br><span class="line">swap(vec);// 将vec与本身的元素互换。</span><br></pre></td></tr></table></figure><h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span><br><span class="line">capacity();//容器的容量</span><br><span class="line">reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span><br></pre></td></tr></table></figure><h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span><br><span class="line">operator[];//返回索引idx所指的数据，越界时，运行直接报错</span><br><span class="line">front();//返回容器中第一个数据元素</span><br><span class="line">back();//返回容器中最后一个数据元素</span><br></pre></td></tr></table></figure><h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.</span><br><span class="line">push_back(ele); //尾部插入元素ele</span><br><span class="line">pop_back();//删除最后一个元素</span><br><span class="line">erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素</span><br><span class="line">erase(const_iterator pos);//删除迭代器指向的元素</span><br><span class="line">clear();//删除容器中所有元素</span><br></pre></td></tr></table></figure><h3 id="巧用swap收缩内存空间"><a href="#巧用swap收缩内存空间" class="headerlink" title="巧用swap收缩内存空间"></a>巧用swap收缩内存空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//此时 通过resize改变容器大小</span><br><span class="line">v.resize(10);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//容量没有改变</span><br><span class="line">vector&lt;int&gt;(v).swap(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reserve预留空间"><a href="#reserve预留空间" class="headerlink" title="reserve预留空间"></a>reserve预留空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">//预先开辟空间</span><br><span class="line">v.reserve(100000);</span><br><span class="line"></span><br><span class="line">int* pStart = NULL;</span><br><span class="line">int count = 0;</span><br><span class="line">for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">if (pStart != &amp;v[0])&#123;</span><br><span class="line">pStart = &amp;v[0];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque与vector"><a href="#deque与vector" class="headerlink" title="deque与vector"></a>deque与vector</h3><p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p><p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_1.png" alt=""></p><h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a><strong>deque容器实现原理</strong></h3><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p><p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_2.png" alt=""></p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;//默认构造形式</span><br><span class="line">deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">deque(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque &amp;deq);//拷贝构造函数。</span><br></pre></td></tr></table></figure><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator=(const deque &amp;deq); //重载等号操作符 </span><br><span class="line">swap(deq);// 将deq与本身的元素互换</span><br></pre></td></tr></table></figure><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.size();//返回容器中元素的个数</span><br><span class="line">deque.empty();//判断容器是否为空</span><br><span class="line">deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h4 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);//在容器尾部添加一个数据</span><br><span class="line">push_front(elem);//在容器头部插入一个数据</span><br><span class="line">pop_back();//删除容器最后一个数据</span><br><span class="line">pop_front();//删除容器第一个数据</span><br></pre></td></tr></table></figure><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span><br><span class="line">front();//返回第一个数据。</span><br><span class="line">back();//返回最后一个数据</span><br></pre></td></tr></table></figure><h4 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><h4 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><p>stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p><p>有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-stack_1.png" alt=""></p><h3 id="stack迭代器"><a href="#stack迭代器" class="headerlink" title="stack迭代器"></a>stack迭代器</h3><p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。</p><h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a><strong>stack常用API</strong></h3><h4 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a>stack构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： </span><br><span class="line">stack(const stack &amp;stk);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="stack赋值操作"><a href="#stack赋值操作" class="headerlink" title="stack赋值操作"></a>stack赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp; operator=(const stack &amp;stk);//重载等号操作符</span><br></pre></td></tr></table></figure><h4 id="stack数据存取操作"><a href="#stack数据存取操作" class="headerlink" title="stack数据存取操作"></a>stack数据存取操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(elem);//向栈顶添加元素</span><br><span class="line">pop();//从栈顶移除第一个元素</span><br><span class="line">top();//返回栈顶元素</span><br></pre></td></tr></table></figure><h4 id="stack大小操作"><a href="#stack大小操作" class="headerlink" title="stack大小操作"></a>stack大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断堆栈是否为空</span><br><span class="line">size();//返回堆栈的大小</span><br></pre></td></tr></table></figure><h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-queue_1.png" alt=""></p><h3 id="queue迭代器"><a href="#queue迭代器" class="headerlink" title="queue迭代器"></a>queue迭代器</h3><p>Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p><h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><h4 id="queue构造函数"><a href="#queue构造函数" class="headerlink" title="queue构造函数"></a>queue构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="queue存取、插入和删除操作"><a href="#queue存取、插入和删除操作" class="headerlink" title="queue存取、插入和删除操作"></a>queue存取、插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(elem);//往队尾添加元素</span><br><span class="line">pop();//从队头移除第一个元素</span><br><span class="line">back();//返回最后一个元素</span><br><span class="line">front();//返回第一个元素</span><br></pre></td></tr></table></figure><h4 id="queue赋值操作"><a href="#queue赋值操作" class="headerlink" title="queue赋值操作"></a>queue赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&amp; operator=(const queue &amp;que);//重载等号操作符</span><br></pre></td></tr></table></figure><h4 id="queue大小操作"><a href="#queue大小操作" class="headerlink" title="queue大小操作"></a>queue大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断队列是否为空</span><br><span class="line">size();//返回队列的大小</span><br></pre></td></tr></table></figure><h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><p>List容器是一个双向链表。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-list_1.png" alt=""></p><p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出。</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。</li><li>链表灵活，但是空间和时间额外耗费较大。</li></ul><h3 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h3><p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.</p><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p><h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a><strong>list容器的数据结构</strong></h3><p>list容器不仅是一个双向链表，而且还是一个循环的双向链表。</p><h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a><strong>list常用API</strong></h3><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：</span><br><span class="line">list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">list(n,elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">list(const list &amp;lst);//拷贝构造函数。</span><br></pre></td></tr></table></figure><h4 id="list数据元素插入和删除操作"><a href="#list数据元素插入和删除操作" class="headerlink" title="list数据元素插入和删除操作"></a>list数据元素插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);//在容器尾部加入一个元素</span><br><span class="line">pop_back();//删除容器中最后一个元素</span><br><span class="line">push_front(elem);//在容器开头插入一个元素</span><br><span class="line">pop_front();//从容器开头移除第一个元素</span><br><span class="line">insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br><span class="line">remove(elem);//删除容器中所有与elem值匹配的元素。</span><br></pre></td></tr></table></figure><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(num);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">list&amp; operator=(const list &amp;lst);//重载等号操作符</span><br><span class="line">swap(lst);//将lst与本身的元素互换。</span><br></pre></td></tr></table></figure><h4 id="list数据的存取"><a href="#list数据的存取" class="headerlink" title="list数据的存取"></a>list数据的存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front();//返回第一个元素。</span><br><span class="line">back();//返回最后一个元素。</span><br></pre></td></tr></table></figure><h4 id="list反转排序"><a href="#list反转排序" class="headerlink" title="list反转排序"></a>list反转排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span><br><span class="line">sort(); //list排序</span><br></pre></td></tr></table></figure><h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h2><h3 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h3><p>Set的特性是<strong>所有元素都会根据元素的键值自动被排序</strong>。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。</p><p>我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.</p><p>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p><h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p><h3 id="set-multiset数据结构"><a href="#set-multiset数据结构" class="headerlink" title="set/multiset数据结构"></a>set/multiset数据结构</h3><p>set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。</p><h3 id="set常用API"><a href="#set常用API" class="headerlink" title="set常用API"></a>set常用API</h3><h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; st;//set默认构造函数：</span><br><span class="line">mulitset&lt;T&gt; mst; //multiset默认构造函数: </span><br><span class="line">set(const set &amp;st);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&amp; operator=(const set &amp;st);//重载等号操作符</span><br><span class="line">swap(st);//交换两个集合容器</span><br></pre></td></tr></table></figure><h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><h4 id="set插入和删除操作"><a href="#set插入和删除操作" class="headerlink" title="set插入和删除操作"></a>set插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);//在容器中插入元素。</span><br><span class="line">clear();//清除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(elem);//删除容器中值为elem的元素。</span><br></pre></td></tr></table></figure><h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span><br><span class="line">count(key);//查找键key的元素个数</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure><p><strong>set的返回值    指定set排序规则:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">//插入操作返回值</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);</span><br><span class="line">if (ret.second)&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(10);</span><br><span class="line">if(ret.second)&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyCompare02&#123;</span><br><span class="line">bool operator()(int v1,int v2)&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//set从大到小</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span><br><span class="line">set&lt;int, MyCompare02&gt; s;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">s.insert(rand() % 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//set容器中存放对象</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name,int age)&#123;</span><br><span class="line">this-&gt;mName = name;</span><br><span class="line">this-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string mName;</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct MyCompare03&#123;</span><br><span class="line">bool operator()(const Person&amp; p1,const Person&amp; p2)&#123;</span><br><span class="line">return p1.mAge &gt; p2.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test03()&#123;</span><br><span class="line">set&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line">Person p1(&quot;aaa&quot;, 20);</span><br><span class="line">Person p2(&quot;bbb&quot;, 30);</span><br><span class="line">Person p3(&quot;ccc&quot;, 40);</span><br><span class="line">Person p4(&quot;ddd&quot;, 50);</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line">for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对组-pair"><a href="#对组-pair" class="headerlink" title="对组(pair)"></a>对组(pair)</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。</p><p>类模板：template \<class t1,="" class="" t2=""> struct pair.</class></p><p>如何创建对组?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法创建一个对组</span><br><span class="line">pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; //访问pair第一个值</span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;//访问pair第二个值</span><br><span class="line">//第二种</span><br><span class="line">pair&lt;string, int&gt; pair2 = make_pair(&quot;name&quot;, 30);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">//pair=赋值</span><br><span class="line">pair&lt;string, int&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a>map/multimap基本概念</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p><p>我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p><p>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p><p>Multimap和map的操作类似，唯一区别multimap键值可重复。</p><p>Map和multimap都是以红黑树为底层实现机制。</p><h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a>map/multimap常用API</h3><h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;//map默认构造函数: </span><br><span class="line">map(const map &amp;mp);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&amp; operator=(const map &amp;mp);//重载等号操作符</span><br><span class="line">swap(mp);//交换两个集合容器</span><br></pre></td></tr></table></figure><h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><h4 id="map插入数据元素操作"><a href="#map插入数据元素操作" class="headerlink" title="map插入数据元素操作"></a>map插入数据元素操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;</span><br><span class="line">map&lt;int, string&gt; mapStu;</span><br><span class="line">// 第一种 通过pair的方式插入对象</span><br><span class="line">mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));</span><br><span class="line">// 第二种 通过pair的方式插入对象</span><br><span class="line">mapStu.inset(make_pair(-1, &quot;校长&quot;));</span><br><span class="line">// 第三种 通过value_type的方式插入对象</span><br><span class="line">mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));</span><br><span class="line">// 第四种 通过数组的方式插入值</span><br><span class="line">mapStu[3] = &quot;小刘&quot;;</span><br><span class="line">mapStu[5] = &quot;小王&quot;;</span><br></pre></td></tr></table></figure><h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();//删除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(keyElem);//删除容器中key为keyElem的对组。</span><br></pre></td></tr></table></figure><h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span><br><span class="line">count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure><h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a>STL容器使用时机</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言：快</td><td>对key而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><ul><li>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</li><li>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li><li>vector与deque的比较：<ul><li>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置    却是不固定的。</li><li>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li><li>三：deque支持头部的快速插入与快速移除，这是deque的优点。</li></ul></li><li>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</li><li>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </li><li>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p><p>注意:</p><p>1.函数对象(仿函数)是一个类，不是一个函数。</p><p>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</p><p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p><p>函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//函数对象是重载了函数调用符号的类</span><br><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">m_Num = 0;</span><br><span class="line">&#125;</span><br><span class="line">int m_Num;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">void operator() (int num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">m_Num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数对象</span><br><span class="line">//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(20);</span><br><span class="line">myPrint(20);</span><br><span class="line">myPrint(20);</span><br><span class="line">cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doBusiness(MyPrint print,int num)</span><br><span class="line">&#123;</span><br><span class="line">print(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数对象作为参数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">//参数1：匿名函数对象</span><br><span class="line">doBusiness(MyPrint(),30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</p><p>2、函数对象超出普通函数的概念，函数对象可以有自己的状态</p><p>3、函数对象可内联编译，性能好。用函数指针几乎不可能</p><p>4、模版函数对象使函数对象具有通用性，这也是它的优势之一 </p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class GreaterThenFive</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num)</span><br><span class="line">&#123;</span><br><span class="line">return num &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//一元谓词</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i ++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());</span><br><span class="line"> if (it == v.end())</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; &quot;找到了: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(40);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(90);</span><br><span class="line">v.push_back(60);</span><br><span class="line"></span><br><span class="line">//默认从小到大</span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line">//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">sort(v.begin(), v.end(),MyCompare());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h2><p>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include\<functional>。</functional></p><ul><li><p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; T plus&lt;T&gt;//加法仿函数</span><br><span class="line">template&lt;class T&gt; T minus&lt;T&gt;//减法仿函数</span><br><span class="line">template&lt;class T&gt; T multiplies&lt;T&gt;//乘法仿函数</span><br><span class="line">template&lt;class T&gt; T divides&lt;T&gt;//除法仿函数</span><br><span class="line">template&lt;class T&gt; T modulus&lt;T&gt;//取模仿函数</span><br><span class="line">template&lt;class T&gt; T negate&lt;T&gt;//取反仿函数</span><br></pre></td></tr></table></figure></li><li><p>6个关系运算类函数对象,每一种都是二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; bool equal_to&lt;T&gt;//等于</span><br><span class="line">template&lt;class T&gt; bool not_equal_to&lt;T&gt;//不等于</span><br><span class="line">template&lt;class T&gt; bool greater&lt;T&gt;//大于</span><br><span class="line">template&lt;class T&gt; bool greater_equal&lt;T&gt;//大于等于</span><br><span class="line">template&lt;class T&gt; bool less&lt;T&gt;//小于</span><br><span class="line">template&lt;class T&gt; bool less_equal&lt;T&gt;//小于等于</span><br></pre></td></tr></table></figure></li><li><p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; bool logical_and&lt;T&gt;//逻辑与</span><br><span class="line">template&lt;class T&gt; bool logical_or&lt;T&gt;//逻辑或</span><br><span class="line">template&lt;class T&gt; bool logical_not&lt;T&gt;//逻辑非</span><br></pre></td></tr></table></figure></li></ul><p>内建函数对象举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//取反仿函数</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">negate&lt;int&gt; n;</span><br><span class="line">cout &lt;&lt; n(50) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加法仿函数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">plus&lt;int&gt; p;</span><br><span class="line">cout &lt;&lt; p(10, 20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//大于仿函数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(rand() % 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">sort(v.begin(), v.end(), greater&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">//函数适配器bind1st bind2nd</span><br><span class="line">//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？</span><br><span class="line">//我们直接给函数对象绑定参数 编译阶段就会报错</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd(myprint(),100));</span><br><span class="line">//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function</span><br><span class="line">//根据我们函数对象是一元函数对象 还是二元函数对象</span><br><span class="line">class MyPrint :public binary_function&lt;int,int,void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void operator()(int v1,int v2) const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1 = : &quot; &lt;&lt; v1 &lt;&lt; &quot; v2 = :&quot; &lt;&lt;v2  &lt;&lt; &quot; v1+v2 = :&quot; &lt;&lt; (v1 + v2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//1、函数适配器</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;请输入起始值：&quot; &lt;&lt; endl;</span><br><span class="line">int x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind1st(MyPrint(), x));</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span><br><span class="line">&#125;</span><br><span class="line">//总结：  bind1st和bind2nd区别?</span><br><span class="line">//bind1st ： 将参数绑定为函数对象的第一个参数</span><br><span class="line">//bind2nd ： 将参数绑定为函数对象的第二个参数</span><br><span class="line">//bind1st bind2nd将二元函数对象转为一元函数对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GreaterThenFive:public unary_function&lt;int,bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator ()(int v) const</span><br><span class="line">&#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//2、取反适配器</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span><br><span class="line">//vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span><br><span class="line">//自定义输入</span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;int&gt;(),5)));</span><br><span class="line">if (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//排序  二元函数对象</span><br><span class="line">sort(v.begin(), v.end(), not2(less&lt;int&gt;()));</span><br><span class="line">for_each(v.begin(), v.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//not1 对一元函数对象取反</span><br><span class="line">//not2 对二元函数对象取反</span><br><span class="line"></span><br><span class="line">void MyPrint03(int v,int v2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v + v2&lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3、函数指针适配器   ptr_fun</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">// ptr_fun( )把一个普通的函数指针适配成函数对象</span><br><span class="line">for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4、成员函数适配器</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印函数</span><br><span class="line">void ShowPerson()&#123;</span><br><span class="line">cout &lt;&lt; &quot;成员函数:&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; m_Name &lt;&lt; &quot; Age:&quot; &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Plus100()</span><br><span class="line">&#123;</span><br><span class="line">m_Age += 100;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void MyPrint04(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt;  p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;Person&gt;v;</span><br><span class="line">Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4(&quot;ddd&quot;, 40);</span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line">//for_each(v.begin(), v.end(), MyPrint04);</span><br><span class="line">//利用 mem_fun_ref 将Person内部成员函数适配</span><br><span class="line">for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span><br><span class="line">// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test05()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person*&gt; v1;</span><br><span class="line">//创建数据</span><br><span class="line">Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4(&quot;ddd&quot;, 40);</span><br><span class="line"></span><br><span class="line">v1.push_back(&amp;p1);</span><br><span class="line">v1.push_back(&amp;p2);</span><br><span class="line">v1.push_back(&amp;p3);</span><br><span class="line">v1.push_back(&amp;p4);</span><br><span class="line"></span><br><span class="line">for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果容器存放的是对象指针，  那么用mem_fun</span><br><span class="line">//如果容器中存放的是对象实体，那么用mem_fun_ref</span><br></pre></td></tr></table></figure><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法主要是由头文件\<algorithm> \<functional> \<numeric>组成。</numeric></functional></algorithm></p><p>\<algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找，遍历，复制，修改，反转，排序，合并等…</algorithm></p><p>\<numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</numeric></p><p>\<functional> 定义了一些模板类,用以声明函数对象。</functional></p><h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    遍历算法 遍历容器元素</span><br><span class="line">@param beg 开始迭代器</span><br><span class="line">@param end 结束迭代器</span><br><span class="line">@param _callback  函数回调或者函数对象</span><br><span class="line">@return 函数对象</span><br><span class="line">*/</span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">transform算法 将指定容器区间元素搬运到另一容器中</span><br><span class="line">注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span><br><span class="line">@param beg1 源容器开始迭代器</span><br><span class="line">@param end1 源容器结束迭代器</span><br><span class="line">@param beg2 目标容器开始迭代器</span><br><span class="line">@param _cakkback 回调函数或者函数对象</span><br><span class="line">@return 返回目标容器迭代器</span><br><span class="line">*/</span><br><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each:"></a>for_each:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt,class _Fn1&gt; inline</span><br><span class="line">void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line">for (; _First != _Last; ++_First)</span><br><span class="line">_Func(*_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//普通函数</span><br><span class="line">void print01(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//函数对象</span><br><span class="line">struct print001&#123;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each算法基本用法</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历算法</span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print001());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print02&#123;</span><br><span class="line">print02()&#123;</span><br><span class="line">mCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">mCount++;</span><br><span class="line">&#125;</span><br><span class="line">int mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each返回值</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print02 p = for_each(v.begin(), v.end(), print02());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.mCount &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print03 : public binary_function&lt;int, int, void&gt;&#123;</span><br><span class="line">void operator()(int val,int bindParam) const&#123;</span><br><span class="line">cout &lt;&lt; val + bindParam &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each绑定参数输出</span><br><span class="line">void test03()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind2nd(print03(),100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//transform 将一个容器中的值搬运到另一个容器中</span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span><br><span class="line">_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for (; _First != _Last; ++_First, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First);</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span><br><span class="line">_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span><br><span class="line">&#123;</span><br><span class="line">for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First1, *_First2);</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct transformTest01&#123;</span><br><span class="line">int operator()(int val)&#123;</span><br><span class="line">return val + 100;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct print01&#123;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vSource;</span><br><span class="line">for (int i = 0; i &lt; 10;i ++)&#123;</span><br><span class="line">vSource.push_back(i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//目标容器</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">//给vTarget开辟空间</span><br><span class="line">vTarget.resize(vSource.size());</span><br><span class="line">//将vSource中的元素搬运到vTarget</span><br><span class="line">vector&lt;int&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());</span><br><span class="line">//打印</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将容器1和容器2中的元素相加放入到第三个容器中</span><br><span class="line">struct transformTest02&#123;</span><br><span class="line">int operator()(int v1,int v2)&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vSource1;</span><br><span class="line">vector&lt;int&gt; vSource2;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">vSource1.push_back(i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//目标容器</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">//给vTarget开辟空间</span><br><span class="line">vTarget.resize(vSource1.size());</span><br><span class="line">transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());</span><br><span class="line">//打印</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">find算法 查找元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value 查找的元素</span><br><span class="line">@return 返回查找元素的位置</span><br><span class="line">*/</span><br><span class="line">find(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">find_if算法 条件查找</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">find_if(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">adjacent_find算法 查找相邻重复元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return 返回相邻元素的第一个位置的迭代器</span><br><span class="line">*/</span><br><span class="line">adjacent_find(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">binary_search算法 二分查找法</span><br><span class="line">注意: 在无序序列中不可用</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value 查找的元素</span><br><span class="line">@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">bool binary_search(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">count算法 统计元素出现次数</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  value回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">count算法 统计元素出现次数</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count_if(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">merge算法 容器元素合并，并存储到另一容器中</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">*/</span><br><span class="line">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">sort算法 容器元素排序</span><br><span class="line">注意:两个容器必须是有序的</span><br><span class="line">@param beg 容器1开始迭代器</span><br><span class="line">@param end 容器1结束迭代器</span><br><span class="line">@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">*/</span><br><span class="line">sort(iterator beg, iterator end, _callback)</span><br><span class="line">/*</span><br><span class="line">sort算法 对指定范围内的元素随机调整次序</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">random_shuffle(iterator beg, iterator end)</span><br><span class="line">/*</span><br><span class="line">reverse算法 反转指定范围的元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">reverse(iterator beg, iterator end)</span><br></pre></td></tr></table></figure><h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">copy算法 将容器内指定范围的元素拷贝到另一容器中</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param dest 目标起始迭代器</span><br><span class="line">*/</span><br><span class="line">copy(iterator beg, iterator end, iterator dest)</span><br><span class="line">/*</span><br><span class="line">replace算法 将容器内指定范围的旧元素修改为新元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param oldvalue 旧元素</span><br><span class="line">@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line">/*</span><br><span class="line">replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param callback函数回调或者谓词(返回Bool类型的函数对象)</span><br><span class="line">@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace_if(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line">/*</span><br><span class="line">swap算法 互换两个容器的元素</span><br><span class="line">@param c1容器1</span><br><span class="line">@param c2容器2</span><br><span class="line">*/</span><br><span class="line">swap(container c1, container c2)</span><br></pre></td></tr></table></figure><h2 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">accumulate算法 计算容器元素累计总和</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value累加值</span><br><span class="line">*/</span><br><span class="line">accumulate(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">fill算法 向容器中添加元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value t填充元素</span><br><span class="line">*/</span><br><span class="line">fill(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure><h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">set_intersection算法 求两个set集合的交集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">set_union算法 求两个set集合的并集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">set_difference算法 求两个set集合的差集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL标准模板库&quot;&gt;&lt;a href=&quot;#STL标准模板库&quot; class=&quot;headerlink&quot; title=&quot;STL标准模板库&quot;&gt;&lt;/a&gt;STL标准模板库&lt;/h1&gt;&lt;h2 id=&quot;六大组件简介&quot;&gt;&lt;a href=&quot;#六大组件简介&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题解及源码(C++完整版)</title>
    <link href="http://qianyouyou.cn/2019/04/13/2019-04-13/"/>
    <id>http://qianyouyou.cn/2019/04/13/2019-04-13/</id>
    <published>2019-04-13T11:31:35.000Z</published>
    <updated>2019-04-27T15:42:05.553Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub源码地址：<a href="https://github.com/qian-youyou/jzOffer" target="_blank" rel="noopener">https://github.com/qian-youyou/jzOffer</a></p><h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><p>　　例如，我们要在上述的二维数组中查找数字7的步骤如下图所示：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-003.png" alt="img"></p><p>　　（矩阵中加阴影背景的区域是下一步查找的范围）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int y = array.size();</span><br><span class="line">        int x = array[0].size();</span><br><span class="line">        int j = x - 1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while(j &gt;=0 &amp;&amp; i &lt; y)&#123;</span><br><span class="line">            if(array[i][j] == target)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; array[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i &lt; y &amp;&amp; array[i][j] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>将长度为1的空格替换为长度为3的“%20”，字符差的产度变长。如果允许我们开辟一个新的数组来存放替换空格后的字符串，那么这道题目就非常简 单。设置两个指针分别指向新旧字符串首元素，遍历原字符串，如果碰到空格就在新字符串上填入“%20”，否则就复制元字符串上的内容。但是如果面试官要求在原先的字符串上操作，并且保证原字符串有足够长的空间来存放替换后的字符串，那么我们就得另想方法。如果从前往后替换字符串，那么保存在空格后面的字符串肯定会被覆盖，那么我们就考虑从后往前进行替换。首先遍历原字符串，找出字符串的长度以及其中的空格数量，根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度。设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置。如果point1指向内容不为空格，那么将内容赋值给point2指向的位置，如果point1指向为空格，那么从point2开始赋值“02%”直到point1==point2时表明字符串中的所有空格都已经替换完毕。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            if(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int j = length + cnt * 2;</span><br><span class="line">        for(int i = length; j&gt;=0 &amp;&amp; i &gt;= 0; i--)&#123;</span><br><span class="line">            if(str[i] != &apos; &apos;)&#123;</span><br><span class="line">                str[j--] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                str[j--] = &apos;0&apos;;</span><br><span class="line">                str[j--] = &apos;2&apos;;</span><br><span class="line">                str[j--] = &apos;%&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>遍历一遍链表，将每个结点value入栈。最后依次从栈中取出元素即可。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        stack&lt;int&gt;s;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            s.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            v.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><strong>在二叉树的前序遍历序列中，第一个数字总是树的根结点的值</strong>。但在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。</p><p>　　如下图所示，前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-004.png" alt="img"></p><p>　　同样，在前序遍历的序列中，根结点后面的3个数字就是3个左子树结点的值，再后面的所有数字都是右子树结点的值。这样我们就在前序遍历和中序遍历两个序列中，分别找到了左右子树对应的子序列。</p><p>　　既然我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列，我们可以用同样的方法分别去构建左右子树。也就是说，接下来的事情可以用递归的方法去完成。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        if(pre.size() == 0 || vin.size() == 0)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* T;</span><br><span class="line">        int index = 0;</span><br><span class="line">        buildTree(T, pre, vin, 0, 0, pre.size(), index);</span><br><span class="line">        return T;</span><br><span class="line">    &#125;</span><br><span class="line">    void buildTree(TreeNode* &amp;T, vector&lt;int&gt; pre,vector&lt;int&gt; vin, int cur, int left, int right, int &amp;index)&#123;</span><br><span class="line">        T = new TreeNode(pre[cur]);</span><br><span class="line">        ++index;</span><br><span class="line">        int i;</span><br><span class="line">        for(i = left; i &lt; right; i++)&#123;</span><br><span class="line">            if(vin[i] == pre[cur])&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &gt; left &amp;&amp; i &lt; right)&#123;</span><br><span class="line">            buildTree(T-&gt;left, pre, vin, cur + 1, left, i, index);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &lt; right - 1)&#123;</span><br><span class="line">            buildTree(T-&gt;right, pre, vin, index, i + 1, right, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>用stack1来实现队列的push操作，用stack2来实现队列的pop操作，当stack2为空时，将stack1的数据全部压入stack2，等待队列的pop操作。 </p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        if(stack1.empty())&#123;</span><br><span class="line">            while(!stack2.empty())&#123;</span><br><span class="line">                stack1.push(stack2.top());</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!stack2.empty())&#123;</span><br><span class="line">            int ans =  stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>由于数组非递减，那么旋转后的除了最小元素以外其他元素一定大于等于上一个元素，最小元素小于等于它上一个元素。遍历一遍查找哪个元素比上一元素小即可。若遍历完也没有，就输出第一个元素。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        int len = rotateArray.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (len == 1)&#123;</span><br><span class="line">            return rotateArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; len; i++)&#123;</span><br><span class="line">            if(rotateArray[i] &lt; rotateArray[i - 1])&#123;</span><br><span class="line">                return rotateArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>斐波那契数列。F(N) = F(N - 1) + F(N - 2)</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        int a[40];</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        a[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt; 40; i++)&#123;</span><br><span class="line">            a[i] = a[i-1] + a[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>斐波那契数列。假设青蛙在第N阶，且第N-1阶跳法与第N-2阶跳法已经求出，则第N阶就是N-1阶的跳法加上第N-2阶的跳法。F(N) = F(N - 1) + F(N - 2)。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;v(number + 1);</span><br><span class="line">        v[0] = 1;</span><br><span class="line">        v[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)&#123;</span><br><span class="line">            v[i] = v[i-1] + v[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return v[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>第N阶等于第1阶 + 第2阶 + …… + 第N-1阶。即2^(n-1)。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int quick_pow(int n)&#123;</span><br><span class="line">        int ans = 2, res = 1;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n &amp; 1)&#123;</span><br><span class="line">                res *= ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans *= ans;</span><br><span class="line">            n &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        number = quick_pow(number - 1);</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>骨牌最最简单的问题。依旧是斐波那契数列。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">        if(number &lt; 1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt;v(number + 1);</span><br><span class="line">        v[0] = 1;</span><br><span class="line">        v[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= number; i++)&#123;</span><br><span class="line">            v[i] = v[i-1] + v[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return v[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>位运算。时间复杂度为有几个1就执行几次。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int cnt = 0;</span><br><span class="line">         while(n)&#123;</span><br><span class="line">             cnt++;</span><br><span class="line">             n = n &amp; (n - 1);</span><br><span class="line">         &#125;</span><br><span class="line">         return cnt;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>快速幂。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quick_pow(double base, int n)&#123;</span><br><span class="line">        double ans = 1;</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n&amp;1)&#123;</span><br><span class="line">                ans *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base*=base;</span><br><span class="line">            n&gt;&gt;=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        if(exponent &gt;= 0)&#123;</span><br><span class="line">            return quick_pow(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return pow(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>奇数储存于一个数组，偶数储存于一个数组。最后合并。</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        const int len = array.size();</span><br><span class="line">        int a[len], b[len];</span><br><span class="line">        int aa = 0;</span><br><span class="line">        int bb = 0;</span><br><span class="line">        for(int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">            if(array[i]%2)&#123;</span><br><span class="line">                a[aa++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                b[bb++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; aa; i++)&#123;</span><br><span class="line">            array[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        bb = 0;</span><br><span class="line">        for(int i = aa; i &lt; len; i++)&#123;</span><br><span class="line">            array[i] = b[bb++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><p>两个指针，一个指针先走k步，然后两个指针同时走，这样第1个指针走到头，第2给个指针刚好剩k个结点。</p><h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        ListNode* p = pListHead;</span><br><span class="line">        ListNode* q = pListHead;</span><br><span class="line">        unsigned int cnt = 0;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            if(cnt &gt;= k)&#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt &lt; k)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="解析-14"><a href="#解析-14" class="headerlink" title="解析"></a>解析</h2><p>将前一个节点与后一个节点断开，然后让前一个节点指向后一个节点，这个过程就需要节点引用（可以理解为指针）来确定记录当前操作节点的前一个节点和后一个节点。 </p><h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* p = NULL;</span><br><span class="line">        ListNode* q = pHead;</span><br><span class="line">        while(q)&#123;</span><br><span class="line">            pHead = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            pHead-&gt;next = p;</span><br><span class="line">            p = pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="解析-15"><a href="#解析-15" class="headerlink" title="解析"></a>解析</h2><p>归并排序基本操作。</p><h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(ListNode *a, ListNode *b)&#123;</span><br><span class="line">        if(a == NULL || b == NULL)&#123;</span><br><span class="line">            if(a != NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a-&gt;val &lt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    void fun(ListNode* &amp;p, ListNode* &amp;pHead)&#123;</span><br><span class="line">        ListNode* tmp = pHead;</span><br><span class="line">        pHead = pHead-&gt;next;</span><br><span class="line">        p-&gt;next = tmp;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pHead = NULL;</span><br><span class="line">        ListNode* p = pHead;</span><br><span class="line">        while(pHead1 != NULL || pHead2 != NULL)&#123;</span><br><span class="line">            if(check(pHead1, pHead2))&#123;</span><br><span class="line">                if(!pHead)&#123;</span><br><span class="line">                    pHead = pHead1;</span><br><span class="line">                    p = pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    fun(p, pHead1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!pHead)&#123;</span><br><span class="line">                    pHead = pHead2;</span><br><span class="line">                    p = pHead;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    fun(p, pHead2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="解析-16"><a href="#解析-16" class="headerlink" title="解析"></a>解析</h2><p>递归设计思路：</p><p>A、判断子树根值是否相等。</p><p>A1、如果是相等，需要一个可以判断该根左右孩子结点是否相等的递归函数。</p><p>A2、如果不等，找大树的左右孩子结点当根结点，递归到A步骤。</p><h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">        if(pRoot1 == NULL || pRoot2 == NULL)&#123;</span><br><span class="line">            if(pRoot2 == NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            if(dfs(pRoot1-&gt;left, pRoot2-&gt;left))&#123;</span><br><span class="line">                if(dfs(pRoot1-&gt;right, pRoot2-&gt;right))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot1 == NULL || pRoot2 == NULL)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot1-&gt;val == pRoot2-&gt;val)&#123;</span><br><span class="line">            if(dfs(pRoot1, pRoot2))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag = HasSubtree(pRoot1-&gt;left, pRoot2)||HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      6   10</span><br><span class="line">     / \  / \</span><br><span class="line">    5  7 9 11</span><br><span class="line">    镜像二叉树</span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      10   6</span><br><span class="line">     / \  / \</span><br><span class="line">    11 9 7  5</span><br></pre></td></tr></table></figure><h2 id="解析-17"><a href="#解析-17" class="headerlink" title="解析"></a>解析</h2><p>递归：</p><p>A：遍历左子树。</p><p>B：遍历右子树。</p><p>C：左子树和右子树交换。</p><h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;left != NULL)&#123;</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;right != NULL)&#123;</span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *tmp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h2 id="解析-18"><a href="#解析-18" class="headerlink" title="解析"></a>解析</h2><p>用vis数组储存访问状态。每次直线走n-1个，如果vis已访问就改变方向。</p><h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt;ans;</span><br><span class="line">        const int len1 = matrix.size();</span><br><span class="line">        if(!len1)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        const int len2 = matrix[0].size();</span><br><span class="line">        vector&lt;bool&gt;vis(len1*len2, false);</span><br><span class="line">        int a[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">        bool flag = true;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        ans.push_back(matrix[x][y]);</span><br><span class="line">        vis[0] = true;</span><br><span class="line">        while(flag)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">                while(x + a[i][0] &gt;= 0 &amp;&amp; x + a[i][0] &lt; len1 &amp;&amp; y + a[i][1] &gt;= 0 &amp;&amp; y + a[i][1] &lt; len2 &amp;&amp; !vis[(x + a[i][0]) * len2 + y + a[i][1]])&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    x += a[i][0];</span><br><span class="line">                    y += a[i][1];</span><br><span class="line">                    ans.push_back(matrix[x][y]);</span><br><span class="line">                    vis[x*len2 + y] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2 id="解析-19"><a href="#解析-19" class="headerlink" title="解析"></a>解析</h2><p>两个栈，一个储存最小值，一个储存源数据。弹出的话两个一起弹出。</p><h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        StackInt.push(value);</span><br><span class="line">        if(StackMin.empty())</span><br><span class="line">            StackMin.push(value);</span><br><span class="line">        else if(StackMin.top()&lt;value)</span><br><span class="line">            StackMin.push(StackMin.top());</span><br><span class="line">        else</span><br><span class="line">            StackMin.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(!StackInt.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            StackInt.pop();</span><br><span class="line">            StackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return StackInt.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return StackMin.top();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; StackInt;</span><br><span class="line">    stack&lt;int&gt; StackMin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="解析-20"><a href="#解析-20" class="headerlink" title="解析"></a>解析</h2><p>栈模拟一遍即可。</p><h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123;</span><br><span class="line">        stack&lt;int&gt; s;</span><br><span class="line">        int len = pushV.size(), i = 0, j = 0;</span><br><span class="line">        while(i &lt; len &amp;&amp; j &lt; len)&#123;</span><br><span class="line">            while(s.empty() || i &lt; len &amp;&amp; s.top() != popV[j])&#123;</span><br><span class="line">                s.push(pushV[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            while(j &lt; len &amp;&amp; !s.empty() &amp;&amp; s.top() == popV[j])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j &lt; len)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h2 id="解析-21"><a href="#解析-21" class="headerlink" title="解析"></a>解析</h2><p>广度优先遍历。queue储存数据。</p><h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        if(root == NULL)&#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* tmp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(tmp-&gt;val);</span><br><span class="line">            if(tmp-&gt;left != NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(tmp-&gt;right != NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h2 id="解析-22"><a href="#解析-22" class="headerlink" title="解析"></a>解析</h2><p>对于一个二叉树的后序遍历序列来说，最后一个数一定是根节点，然后前面的数中，从最开始到第一个大于根节点的数都是左子树中的数，而后面到倒数第二个数应该都是大于根节点的，是右子树，如果后面的数中有小于根节点的，那么说明这个序列不是二叉搜索树的后序遍历序列。</p><h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(vector&lt;int&gt; &amp;sequence, int left, int right)&#123;</span><br><span class="line">        bool flag = false;</span><br><span class="line">        if(left &gt;= right)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int mindle = left;</span><br><span class="line">        int cur = sequence[right];</span><br><span class="line">        for(int i = left; i &lt; right; ++i)&#123;</span><br><span class="line">            if(!flag &amp;&amp; sequence[i] &gt; cur)&#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                mindle = i;</span><br><span class="line">            &#125;else if(flag &amp;&amp; sequence[i] &lt; cur)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = check(sequence, left, mindle - 1) &amp;&amp; check(sequence, mindle, right - 1);</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123;</span><br><span class="line">        const int len = sequence.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return check(sequence, 0, len - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h2 id="解析-23"><a href="#解析-23" class="headerlink" title="解析"></a>解析</h2><p>首先思考节点值的和为输入的整数，<strong>每条路径都一定是从根节点到叶子节点</strong>，在数据结构中从根节点到叶子节点的遍历称之为深度优先遍历DFS。因此整个过程可以采用先序遍历方式的DFS，即<strong>根节点》左子树》右子树</strong>。随后考虑一次遍历完成后的处理，当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 </p><h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; buffer;</span><br><span class="line">    vector&lt;int&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123;</span><br><span class="line">        if(root==NULL)&#123;</span><br><span class="line">            return buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        if((expectNumber-root-&gt;val)==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)&#123;</span><br><span class="line">            buffer.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root-&gt;left,expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right,expectNumber-root-&gt;val);</span><br><span class="line">        if(tmp.size()!=0)&#123;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h2 id="解析-24"><a href="#解析-24" class="headerlink" title="解析"></a>解析</h2><p>第一步仍然是根据原始链表的每个结点N创建对应的N’。（把N’链接在N的后面）</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-005.png" alt="img"></p><p>第二步设置复制出来的结点的Sibling。（把N’的Sibling指向N的Sibling）</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-006.png" alt="img"></p><p>第三步把这个长链表拆分成两个链表：把奇数位置的结点用Next链接起来就是原始链表，偶数数值的则是复制链表。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-007.png" alt="img"></p><h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    struct RandomListNode *next, *random;</span><br><span class="line">    RandomListNode(int x) :</span><br><span class="line">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    RandomListNode* Clone(RandomListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        RandomListNode *pHead2 = pHead, *p2, *tmp = pHead;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            p2 = new RandomListNode(tmp-&gt;label);</span><br><span class="line">            p2-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = p2;</span><br><span class="line">            tmp = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pHead)&#123;</span><br><span class="line">            pHead2 = pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(tmp-&gt;random)&#123;</span><br><span class="line">                tmp-&gt;next-&gt;random = tmp-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = pHead;</span><br><span class="line">        p2 = pHead2;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            tmp-&gt;next = tmp-&gt;next-&gt;next;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            if(p2-&gt;next)&#123;</span><br><span class="line">                p2-&gt;next = p2-&gt;next-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><h2 id="解析-25"><a href="#解析-25" class="headerlink" title="解析"></a>解析</h2><p>步骤1：递归左子树，使左子树为有序双向链表。</p><p>步骤2：递归右子树，使右子树为有序双向链表。</p><p>步骤3：左子树尾节点和根节点连接，右子树头节点和根节点连接。返回左子树头节点或根节点。</p><h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* Convert(TreeNode* pRootOfTree)&#123;</span><br><span class="line">        if(pRootOfTree)&#123;</span><br><span class="line">            TreeNode* left = Convert(pRootOfTree-&gt;left);</span><br><span class="line">            TreeNode* right = Convert(pRootOfTree-&gt;right);</span><br><span class="line">            TreeNode* tail = left;</span><br><span class="line">            if(right)&#123;</span><br><span class="line">                right-&gt;left = pRootOfTree;</span><br><span class="line">                pRootOfTree-&gt;right = right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(left)&#123;</span><br><span class="line">                while(tail-&gt;right)&#123;</span><br><span class="line">                    tail = tail-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;right = pRootOfTree;</span><br><span class="line">                pRootOfTree-&gt;left = tail;</span><br><span class="line">                return left;</span><br><span class="line">            &#125;</span><br><span class="line">            return pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br></pre></td></tr></table></figure><h2 id="解析-26"><a href="#解析-26" class="headerlink" title="解析"></a>解析</h2><p>把一个字符串看成两部分组成：第一部分为第一个字符，第二部分为后面的所有字符。</p><p>求整个字符串的排列，可以看出两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；然后固定第一个字符，求后面所有字符的排序。此时仍把后面的字符看成两部分，第一个字符和后面的字符，然后重复上述步骤。（递归）</p><p>在后面的在线测试中，要求输入字符串可能有重复的字符，输出按照字典顺序，排序即可。</p><h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt;v;</span><br><span class="line">    void dfs(string str, int cur)&#123;</span><br><span class="line">        if(cur &lt; str.size() - 1)&#123;</span><br><span class="line">            for(int i = cur; i &lt; str.size(); ++i)&#123;</span><br><span class="line">                if(i == cur || str[i] != str[cur])&#123;</span><br><span class="line">                    swap(str[cur], str[i]);</span><br><span class="line">                    dfs(str, cur + 1);</span><br><span class="line">                    swap(str[cur], str[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            v.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; Permutation(string str) &#123;</span><br><span class="line">        dfs(str, 0);</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h2 id="解析-27"><a href="#解析-27" class="headerlink" title="解析"></a>解析</h2><ul><li>当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；</li><li>如果下一个数字和我们之前保存的数字不同，则次数减1。</li><li>如果次数为零，我们需要保存下一个数字，并把次数设为1。</li><li>最后遍历一遍，统计该数出现的次数。</li></ul><h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        const int len = numbers.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = numbers[0], cnt = 1;</span><br><span class="line">        for(int i = 1; i &lt; len; ++i)&#123;</span><br><span class="line">            if(numbers[i] == ans)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!cnt)&#123;</span><br><span class="line">                    ans = numbers[i];</span><br><span class="line">                    cnt = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            if(numbers[i] == ans)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt &lt;= len / 2)&#123;</span><br><span class="line">            ans = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h2 id="解析-28"><a href="#解析-28" class="headerlink" title="解析"></a>解析</h2><p>建一个容量k的大根堆。</p><h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        priority_queue&lt;int&gt;que;</span><br><span class="line">        int len = input.size();</span><br><span class="line">        if(len &lt; k)&#123;</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            que.push(input[i]);</span><br><span class="line">            while(que.size() &gt; k)&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            v.push_back(que.top());</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h2 id="解析-29"><a href="#解析-29" class="headerlink" title="解析"></a>解析</h2><p>直接遍历，如果上一个数加上这个数变小了就不加，否则加上。</p><h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        int len = array.size();</span><br><span class="line">        int ans = array[0];</span><br><span class="line">        for(int i = 1; i &lt; len; ++i)&#123;</span><br><span class="line">            array[i] = max(array[i], array[i] + array[i - 1]);</span><br><span class="line">            ans = max(ans, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><h2 id="解析-30"><a href="#解析-30" class="headerlink" title="解析"></a>解析</h2><p>总结一下以上的算法，可以看到，当计算右数第 i 位包含的 x 的个数时：</p><ul><li>取第 i位左边(高位)的数字，乘以 10i-1，得到基础值 a</li><li>取第 i 位数字，计算修正值</li><li>如果大于 x , 则结果为 a + 10i-1</li><li>如果小于 x，则结果为 a</li><li>如果等于 x，则取第 i 位右边(低位)数字，设为 b，最后结果为 a + b + 1</li></ul><h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = n, ans = 0, res = 1;</span><br><span class="line">        while(cnt)&#123;</span><br><span class="line">            if(cnt % 10)&#123;</span><br><span class="line">                if(cnt % 10 &gt; 1)&#123;</span><br><span class="line">                    ans += res;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ans += n % res + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            cnt /= 10;</span><br><span class="line">            ans += cnt * res;</span><br><span class="line">            res *= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h2 id="解析-31"><a href="#解析-31" class="headerlink" title="解析"></a>解析</h2><p>sort排序即可，cmp由我们写，可以转成字符串，然后利用字符串进行比较。</p><h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(int a, int b)&#123;</span><br><span class="line">        string str1 = to_string(a);</span><br><span class="line">        string str2 = to_string(b);</span><br><span class="line">        return str1 + str2 &lt; str2 + str1;</span><br><span class="line">    &#125;</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        string str;</span><br><span class="line">        int len = numbers.size();</span><br><span class="line">        sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            while(numbers[i] == 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            str += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h2 id="解析-32"><a href="#解析-32" class="headerlink" title="解析"></a>解析</h2><p>优先队列+集合+选择性插入</p><h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que;</span><br><span class="line">        que.push(1);</span><br><span class="line">        int i = 0;</span><br><span class="line">        int MAXN = 0;</span><br><span class="line">        set&lt;int&gt;s;</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int ans = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            if(s.count(ans)||ans &lt; 0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(ans);</span><br><span class="line">            ++i;</span><br><span class="line">            s.insert(ans);</span><br><span class="line">            if(i == index)&#123;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            if(que.size() &lt; index)&#123;</span><br><span class="line">                que.push(ans*2);</span><br><span class="line">                que.push(ans*3);</span><br><span class="line">                que.push(ans*5);</span><br><span class="line">                MAXN = max(MAXN, ans * 5);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(ans*2&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*2);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans*3&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*3);</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans*5&lt;MAXN)&#123;</span><br><span class="line">                    que.push(ans*5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h2 id="解析-33"><a href="#解析-33" class="headerlink" title="解析"></a>解析</h2><p>哈希表，可用map统计。</p><h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">        map&lt;char, int&gt;m;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            m[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            if(m[str[i]] == 1)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字数据范围：对于%50的数据,size&lt;=10^4对于%75的数据,size&lt;=10^5对于%100的数据,size&lt;=2*10^5</span><br></pre></td></tr></table></figure><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="解析-34"><a href="#解析-34" class="headerlink" title="解析"></a>解析</h2><p>归并排序。先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。 </p><h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    const long long mod = 1e9 + 7;</span><br><span class="line">    int my_merge(vector&lt;int&gt; &amp;data, int left, int mindle, int right)&#123;</span><br><span class="line">        vector&lt;int&gt;A(mindle - left + 1);</span><br><span class="line">        vector&lt;int&gt;B(right - mindle);</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        for(int i = left; i &lt;= mindle; ++i)&#123;</span><br><span class="line">            A[i - left] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = mindle + 1; i &lt;= right; ++i)&#123;</span><br><span class="line">            B[i - mindle - 1] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0, y = 0;</span><br><span class="line">        for(int i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            if(x &gt;= A.size())&#123;</span><br><span class="line">                data[i] = B[y++];</span><br><span class="line">            &#125;else if(y &gt;= B.size())&#123;</span><br><span class="line">                data[i] = A[x++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(A[x] &gt; B[y])&#123;</span><br><span class="line">                    data[i] = B[y++];</span><br><span class="line">                    ans += A.size() - x;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    data[i] = A[x++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int mergeSort(vector&lt;int&gt;&amp;data, int left, int right)&#123;</span><br><span class="line">        long long ans = 0;</span><br><span class="line">        if(left &lt; right)&#123;</span><br><span class="line">            int mindle = (left + right) / 2;</span><br><span class="line">            ans += mergeSort(data, left, mindle);</span><br><span class="line">            ans += mergeSort(data, mindle + 1, right);</span><br><span class="line">            ans += my_merge(data, left, mindle, right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans %= mod;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        int ans = mergeSort(data, 0, data.size() - 1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p><h2 id="解析-35"><a href="#解析-35" class="headerlink" title="解析"></a>解析</h2><p>如果两链表有交点，则必然是“Y”型或“V”型。</p><p>如何判断两个单向链表有没有公共结点？如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。</p><p>在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。</p><p>在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p><h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct ListNode *next;</span><br><span class="line">ListNode(int x) :</span><br><span class="line">val(x), next(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* fun(ListNode* &amp;pHead, ListNode* p)&#123;</span><br><span class="line">        ListNode* q = pHead;</span><br><span class="line">        while(p != NULL)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        ListNode* p1 = pHead1;</span><br><span class="line">        ListNode* p2 = pHead2;</span><br><span class="line">        while(p1 != NULL &amp;&amp; p2 != NULL)&#123;</span><br><span class="line">            if(p1 == p2)&#123;</span><br><span class="line">                return p1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p1 == NULL &amp;&amp; p2 == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(p1 != NULL)&#123;</span><br><span class="line">                p1 = fun(pHead1, p1);</span><br><span class="line">                p2 = pHead2;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p2 = fun(pHead2, p2);</span><br><span class="line">                p1 = pHead1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return FindFirstCommonNode(p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="解析-36"><a href="#解析-36" class="headerlink" title="解析"></a>解析</h2><p>我的方法直接遍历。更高效的方法是二分查找两遍，先找到该数字的左边界，再找到该数字的右边界，然后下标相减。</p><h2 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 0; i &lt; data.size(); ++i)&#123;</span><br><span class="line">            if(data[i] == k)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h2 id="解析-37"><a href="#解析-37" class="headerlink" title="解析"></a>解析</h2><p>遍历一遍即可。</p><h2 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">struct TreeNode *left;</span><br><span class="line">struct TreeNode *right;</span><br><span class="line">TreeNode(int x) :</span><br><span class="line">val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        if(pRoot != NULL)&#123;</span><br><span class="line">            cnt += max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h2 id="解析-38"><a href="#解析-38" class="headerlink" title="解析"></a>解析</h2><p>递归判断左子树深度和右子树深度差是否不大于1。</p><h2 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return true;</span><br><span class="line">        int leftDepth = getDepth(pRoot -&gt; left);</span><br><span class="line">        int rightDepth = getDepth(pRoot -&gt; right);</span><br><span class="line">        if(leftDepth &gt; rightDepth + 1 || leftDepth + 1 &lt; rightDepth)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return IsBalanced_Solution(pRoot -&gt; left) &amp;&amp; IsBalanced_Solution(pRoot -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    int getDepth(TreeNode* pRoot)&#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int leftDepth = getDepth(pRoot -&gt; left);</span><br><span class="line">        int rightDepth = getDepth(pRoot -&gt; right);</span><br><span class="line">        return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h2 id="解析-39"><a href="#解析-39" class="headerlink" title="解析"></a>解析</h2><p>我用的map。可以用位运算。</p><h2 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        int len = data.size();</span><br><span class="line">        bool flag = false;</span><br><span class="line">        map&lt;int, int&gt;m;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            m[data[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; len; ++i)&#123;</span><br><span class="line">            if(m[data[i]] == 1)&#123;</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    *num2 = data[i];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    flag = true;</span><br><span class="line">                    *num1 = data[i];</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h1><h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure><h2 id="解析-40"><a href="#解析-40" class="headerlink" title="解析"></a>解析</h2><p>在序列首部各定义指针left, right，如果和超过s，left往右移，如果和小于s，right往右移。 </p><h2 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;ans;</span><br><span class="line">        for(int i = 1; i &lt;= sum; ++i)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 1, right = 1;</span><br><span class="line">        int cnt = 1;</span><br><span class="line">        while(right &lt; sum &amp;&amp; left &lt; sum)&#123;</span><br><span class="line">            if(cnt == sum)&#123;</span><br><span class="line">                ans.push_back(vector&lt;int&gt;(v.begin() + left - 1, v.begin() + right));</span><br><span class="line">            &#125;</span><br><span class="line">            if(cnt &gt; sum)&#123;</span><br><span class="line">                cnt -= left;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;else if(cnt &lt;= sum)&#123;</span><br><span class="line">                ++right;</span><br><span class="line">                cnt += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h1><h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure><h2 id="解析-41"><a href="#解析-41" class="headerlink" title="解析"></a>解析</h2><p>在序列首尾各定义指针p1, p2，如果和超过s，p2往中间移，如果和小于s，p1往中间移。 </p><h2 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = array.size() - 1;</span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            if(array[left] + array[right] == sum)&#123;</span><br><span class="line">                v.push_back(array[left]);</span><br><span class="line">                v.push_back(array[right]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(array[left] + array[right] &gt; sum)&#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2 id="解析-42"><a href="#解析-42" class="headerlink" title="解析"></a>解析</h2><p>先取余，再字符串分割。</p><h2 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        unsigned int len = str.size();</span><br><span class="line">        if(!len)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        n %= len;</span><br><span class="line">        string str2 = str.substr(size_t(n)) + str.substr(0, n);</span><br><span class="line">        return str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h1><h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2 id="解析-43"><a href="#解析-43" class="headerlink" title="解析"></a>解析</h2><p>用栈储存单词，存完了再输出。</p><h2 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        stack&lt;string&gt;s;</span><br><span class="line">        istringstream istring;</span><br><span class="line">        istring.str(str);</span><br><span class="line">        string tmp;</span><br><span class="line">        while(istring &gt;&gt; tmp)&#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!s.empty())&#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(str.size())&#123;</span><br><span class="line">                return str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(!s.empty())&#123;</span><br><span class="line">            tmp += &quot; &quot; + s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h1><h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2 id="解析-44"><a href="#解析-44" class="headerlink" title="解析"></a>解析</h2><p>暴力做的。</p><h2 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        if(numbers.empty())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt = 0, cur = 0;</span><br><span class="line">        sort(numbers.begin(), numbers.end());</span><br><span class="line">        for(int i = 0; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            if(numbers[i] == 0)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(cur)&#123;</span><br><span class="line">                    while(numbers[i] != cur + 1)&#123;</span><br><span class="line">                        cur += 1;</span><br><span class="line">                        --cnt;</span><br><span class="line">                        if(cnt &lt; 0)&#123;</span><br><span class="line">                            return false;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    cur = numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="孩子们的游戏-圆圈中最后剩下的数"><a href="#孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="孩子们的游戏(圆圈中最后剩下的数)"></a>孩子们的游戏(圆圈中最后剩下的数)</h1><h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h2 id="解析-45"><a href="#解析-45" class="headerlink" title="解析"></a>解析</h2><p>现在我们把他们的编号做一下转换：</p><p>k –&gt; 0<br>k+1 –&gt; 1<br>k+2 –&gt; 2<br>…<br>…<br>k-2 –&gt; n-2<br>k-1 –&gt; n-1<br>解x’ —-&gt; 解为x<br>注意&lt; x’就是最终的解 &gt;</p><p>变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k)%n</p><p>如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 —- 这显然就是一个倒推问题！下面举例说明：</p><p>假设现在是6个人（编号从0到5）报数，报到（2-1）的退出，即 &lt; m=2&gt;。那么第一次编号为1的人退出圈子，从他之后的人开始算起，序列变为2,3,4,5,0，即问题变成了这5个人报数的问题，将序号做一下转换：<br>2 –&gt;0<br>3 –&gt;1<br>4 –&gt;2<br>5 –&gt;3<br>0 –&gt;4<br>现在假设x为0,1,2,3,4的解，x’设为那么原问题的解（这里注意，2,3,4,5,0的解就是0,1,2,3,4,5的解，因为1出去了，结果还是一个），根据观察发现，x与x’关系为x’=(x+m)%n，因此只要求出x，就可以求x’。x怎么求出呢？继续推导吧。0,1,2,3,4,，同样是第二个1出列，变为（2,3,4,0），转换下为<br>2 –&gt;0<br>3 –&gt;1<br>4 –&gt;2<br>0 –&gt;3<br>很简单，同样的道理，公式又出来了，x=(x”+m)%5，这里变成5了。即求n-1个人的问题就是找出n-2的人的解，n-2就是要找出n-3，等等<br>因此，就可以回去看上面的推导过程了。</p><p>好了，思路出来了，下面写递推公式：<br>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]</p><p>递推公式<br>f[1]=0;<br>f[i]=(f[i-1]+m)%i; (i&gt;1)</p><p>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1<br>由于是逐级递推，不需要保存每个f[i]。</p><h2 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n + m == 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int s = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)&#123;</span><br><span class="line">            s = (s + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+…+n"></a>求1+2+3+…+n</h1><h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h2 id="解析-46"><a href="#解析-46" class="headerlink" title="解析"></a>解析</h2><p>利用逻辑运算符&amp;&amp;的性质。</p><h2 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Sum_Solution(int n) &#123;</span><br><span class="line">        return fun(n);</span><br><span class="line">    &#125;</span><br><span class="line">    int fun(int n)&#123;</span><br><span class="line">        n &amp;&amp; (n += fun(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h2 id="解析-47"><a href="#解析-47" class="headerlink" title="解析"></a>解析</h2><p>位运算，先异或，再右移。</p><h2 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Add(int num1, int num2)</span><br><span class="line">    &#123;</span><br><span class="line">        while(num2)&#123;</span><br><span class="line">            int a1 = num1 ^ num2;</span><br><span class="line">            int a2 = num1 &amp; num2;</span><br><span class="line">            a2 &lt;&lt;= 1;</span><br><span class="line">            num1 = a1;</span><br><span class="line">            num2 = a2;</span><br><span class="line">        &#125;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串,包括数字字母符号,可以为空</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是合法的数值表达则返回该数字，否则返回0</span><br></pre></td></tr></table></figure><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">    1a33</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure><h2 id="解析-48"><a href="#解析-48" class="headerlink" title="解析"></a>解析</h2><p>暴力</p><h2 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int StrToInt(string str) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            while(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str[i] &lt;= &apos;9&apos; &amp;&amp; str[i] &gt;= &apos;0&apos;)&#123;</span><br><span class="line">                ans *= 10;</span><br><span class="line">                ans += str[i] - &apos;0&apos;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(!flag)&#123;</span><br><span class="line">                    if(str[i] == &apos;-&apos;)&#123;</span><br><span class="line">                        flag = -1;</span><br><span class="line">                    &#125;else if(str[i] == &apos;+&apos;)&#123;</span><br><span class="line">                        flag = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        return 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            ans *= flag;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="解析-49"><a href="#解析-49" class="headerlink" title="解析"></a>解析</h2><p>0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置；</p><p>从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i，</p><p>如果是，则继续扫描下一个数字；</p><p>如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置；</p><p>重复上述过程，直至找到一个重复的数字；</p><p>时间复杂度：O(n)，空间复杂度：O(1)</p><p>注：张氏排序法</p><h2 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an array of integers</span><br><span class="line">    //        length:      the length of array numbers</span><br><span class="line">    //        duplication: (Output) the duplicated number in the array number</span><br><span class="line">    // Return value:       true if the input is valid, and there are some duplications in the array number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool duplicate(int numbers[], int length, int* duplication) &#123;</span><br><span class="line">        for(int i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">            while(numbers[i] != i)&#123;</span><br><span class="line">                if(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                    *duplication = numbers[i];</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><h2 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><h2 id="解析-50"><a href="#解析-50" class="headerlink" title="解析"></a>解析</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-002.png" alt=""></p><p>B[i]的值可以看做下图的矩阵中每行的乘积。</p><p>下三角用连乘可以很容易求得，先算下三角中的连乘，即先计算出B[i]中的一部分，然后将上三角中的数也乘进去。这样一来就只需要两个循环就可以解决这个问题。时间复杂度是O(n);</p><p>其实你只需要知道这个是形成一个矩阵，然后每一行是用来计算B[i],每一行的内容则是A[0]到A[n-1]。利用上三角和下三角进行计算。</p><h2 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt;B(A.size(), 1);</span><br><span class="line">        int tmp = 1;</span><br><span class="line">        for(int i = 0; i &lt; A.size() - 1; ++i)&#123;</span><br><span class="line">            tmp *= A[i];</span><br><span class="line">            B[i + 1] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = 1;</span><br><span class="line">        for(int i = A.size() - 1; i &gt; 0; --i)&#123;</span><br><span class="line">            tmp *= A[i];</span><br><span class="line">            B[i - 1] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><h2 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h2 id="解析-51"><a href="#解析-51" class="headerlink" title="解析"></a>解析</h2><p>“.”按任意字符匹配。如果模式串遇到*字符则有两种状态，第一匹配字符，则字符串后移一位，模式串不变，第二，模式串后移俩位和字符串后移一位，第三，忽略星号。 </p><h2 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool match(char* str, char* pattern)&#123;</span><br><span class="line">        if(str[0] == 0 &amp;&amp; pattern[0] == 0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(pattern[0] &amp;&amp; pattern[1] == &apos;*&apos; &amp;&amp; match(str, pattern + 2))&#123;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;else if(str[0] &amp;&amp; pattern[0] == &apos;.&apos; || str[0] == pattern[0])&#123;</span><br><span class="line">            if(match(str + 1, pattern + 1))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(pattern[1] == &apos;*&apos; &amp;&amp; match(str + 1, pattern))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><h2 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h2 id="解析-52"><a href="#解析-52" class="headerlink" title="解析"></a>解析</h2><p>暴力</p><h2 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumeric(char* string)</span><br><span class="line">    &#123;</span><br><span class="line">        int len = strlen(string);</span><br><span class="line">        int cur = 0;</span><br><span class="line">        bool a = false, b = false, c = false, ans = true;</span><br><span class="line">        while(string[cur] == &apos; &apos;)&#123;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for(; cur &lt; len; ++cur)&#123;</span><br><span class="line">            if(string[cur] &gt;= &apos;0&apos; &amp;&amp; string[cur] &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                ans = true;</span><br><span class="line">                a = true;</span><br><span class="line">            &#125;else if(string[cur] == &apos;+&apos; || string[cur] == &apos;-&apos;)&#123;</span><br><span class="line">                if(a)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    a = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(string[cur] == &apos;e&apos; || string[cur] == &apos;E&apos;)&#123;</span><br><span class="line">                if(b)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    b = true;</span><br><span class="line">                    a = false;</span><br><span class="line">                    ans = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(string[cur] == &apos;.&apos;)&#123;</span><br><span class="line">                if(c || b)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    c = true;</span><br><span class="line">                    ans = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h1><h2 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前字符流没有存在出现一次的字符，返回#字符。</span><br></pre></td></tr></table></figure><h2 id="解析-53"><a href="#解析-53" class="headerlink" title="解析"></a>解析</h2><p>哈希表。</p><h2 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  //Insert one char from stringstream</span><br><span class="line">    Solution():cur(0)&#123;&#125;</span><br><span class="line">    void Insert(char ch)</span><br><span class="line">    &#123;</span><br><span class="line">        str += ch;</span><br><span class="line">        ++mp[ch];</span><br><span class="line">        while(cur &lt; str.size() &amp;&amp; mp[str[cur]] &gt; 1)&#123;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  //return the first appearence once char in current stringstream</span><br><span class="line">    char FirstAppearingOnce()</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur &gt;= str.size())&#123;</span><br><span class="line">            return &apos;#&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        return str[cur];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    map&lt;char, int&gt;mp;</span><br><span class="line">    string str;</span><br><span class="line">    int cur;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2 id="解析-54"><a href="#解析-54" class="headerlink" title="解析"></a>解析</h2><p><a href="https://www.cnblogs.com/fankongkong/p/7007869.html" target="_blank" rel="noopener">转</a>：a、第一步，找环中相汇点。分别用fast，slow指向链表头部，slow每次走一步，fast每次走二步，直到fast==slow找到在环中的相汇点。</p><p>b、第二步，找环的入口。接上步，当fast==slow时，fast所经过节点数为2x,slow所经过节点数为x,设环中有n个节点，fast比slow<strong>多走r圈</strong>有<strong>2x=rn+x; x=rn;</strong>（r为圈数，n为一圈的结点数）</p><p>可以看出slow实际走了多个环的步数，再让fast指向链表头部，slow位置不变。</p><p>假设链表开头到环接口的距离是y，那么x-y表示slow指针走过的除链表开头y在环中走过的距离，那么slow再走y步，此时fast结点与slow结点相遇，fast == slow ，<strong>x-y+y=x = rn</strong>，即此时slow指向环的入口。</p><h2 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pFast = pHead;</span><br><span class="line">        ListNode* pSlow = pHead;</span><br><span class="line">        do&#123;</span><br><span class="line">            if(pSlow &amp;&amp; pSlow-&gt;next)&#123;</span><br><span class="line">                pSlow = pSlow-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pFast &amp;&amp; pFast-&gt;next &amp;&amp; pFast-&gt;next-&gt;next)&#123;</span><br><span class="line">                pFast = pFast-&gt;next-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while(pFast != pSlow);</span><br><span class="line">        pFast = pHead;</span><br><span class="line">        while(pFast != pSlow)&#123;</span><br><span class="line">            pFast = pFast-&gt;next;</span><br><span class="line">            pSlow = pSlow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pSlow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h1><h2 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2 id="解析-55"><a href="#解析-55" class="headerlink" title="解析"></a>解析</h2><p>不多说了，因为是排序的链表。</p><h2 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplication(ListNode* pHead)</span><br><span class="line">    &#123;</span><br><span class="line">if (pHead == NULL) &#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* preNode = NULL;</span><br><span class="line">ListNode* node = pHead;</span><br><span class="line">while (node != NULL) &#123;</span><br><span class="line">if (node-&gt;next != NULL &amp;&amp; node-&gt;val == node-&gt;next-&gt;val) &#123;</span><br><span class="line">int value = node-&gt;val;</span><br><span class="line">while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;val == value) &#123;</span><br><span class="line">node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">if (preNode == NULL) &#123;</span><br><span class="line">pHead = node-&gt;next;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">preNode-&gt;next = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">preNode = node;</span><br><span class="line">&#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><h2 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解析-56"><a href="#解析-56" class="headerlink" title="解析"></a>解析</h2><p>我们可发现分成两大类：1、有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） 2、没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。  </p><h2 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeLinkNode *left;</span><br><span class="line">    struct TreeLinkNode *right;</span><br><span class="line">    struct TreeLinkNode *next;</span><br><span class="line">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeLinkNode* GetNext(TreeLinkNode* pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pNode == NULL)&#123;</span><br><span class="line">            return pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pNode-&gt;right)&#123;</span><br><span class="line">            TreeLinkNode* p = pNode-&gt;right;</span><br><span class="line">            while(p-&gt;left)&#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            TreeLinkNode* p = pNode-&gt;next;</span><br><span class="line">            while(p &amp;&amp; p-&gt;right == pNode)&#123;</span><br><span class="line">                pNode = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><h2 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解析-57"><a href="#解析-57" class="headerlink" title="解析"></a>解析</h2><p>【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。</p><p>【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。</p><p>【分析3】题目中并不是想让我们判断任意两棵二叉树是否相同，而是要求我们判断一棵二叉树和它的镜像二叉树是否相同。因此我们判断相同的条件不就很明显的变成了：根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到① 如果Root和Root’均为空，则返回true；② 如果Root为空或者Root’为空，则返回false；③ 如果Root对应的值与Root’对应的值不相等，则返回false。</p><h2 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool check(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123;</span><br><span class="line">        return pRoot_1-&gt;val == pRoot_2-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return dfs(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool dfs(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123;</span><br><span class="line">        if(pRoot_1 == NULL || pRoot_2 == NULL)&#123;</span><br><span class="line">            if(pRoot_1 == NULL &amp;&amp; pRoot_2 == NULL)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(check(pRoot_1, pRoot_2))&#123;</span><br><span class="line">            if(dfs(pRoot_1-&gt;left, pRoot_2-&gt;right))&#123;</span><br><span class="line">                return dfs(pRoot_1-&gt;right, pRoot_2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><h2 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解析-58"><a href="#解析-58" class="headerlink" title="解析"></a>解析</h2><p>广度优先遍历。两个栈代替队列储存数据。</p><h2 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;que;</span><br><span class="line">        stack&lt;TreeNode*&gt;stk;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt;vv;</span><br><span class="line">        if(!pRoot)&#123;</span><br><span class="line">            return vv;</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        while(!que.empty() || !stk.empty())&#123;</span><br><span class="line">            vector&lt;int&gt;v;</span><br><span class="line">            if(!que.empty())&#123;</span><br><span class="line">                while(!que.empty())&#123;</span><br><span class="line">                    TreeNode* tmp = que.top();</span><br><span class="line">                    que.pop();</span><br><span class="line">                    v.push_back(tmp-&gt;val);</span><br><span class="line">                    if(tmp-&gt;left)&#123;</span><br><span class="line">                        stk.push(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(tmp-&gt;right)&#123;</span><br><span class="line">                        stk.push(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                while(!stk.empty())&#123;</span><br><span class="line">                    TreeNode* tmp = stk.top();</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    v.push_back(tmp-&gt;val);</span><br><span class="line">                    if(tmp-&gt;right)&#123;</span><br><span class="line">                        que.push(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(tmp-&gt;left)&#123;</span><br><span class="line">                        que.push(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vv.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        return vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h1><h2 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解析-59"><a href="#解析-59" class="headerlink" title="解析"></a>解析</h2><p>带属性的广度优先遍历。</p><h2 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            vector&lt;vector&lt;int&gt; &gt; vv;</span><br><span class="line">            vector&lt;int&gt; ve;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            queue&lt;int&gt; dque;</span><br><span class="line">            int depth=0;</span><br><span class="line">            que.push(pRoot);</span><br><span class="line">            dque.push(depth);</span><br><span class="line">            TreeNode *node;</span><br><span class="line">            while(!que.empty())&#123;</span><br><span class="line">                node=que.front();</span><br><span class="line">                if(depth!=dque.front())&#123;</span><br><span class="line">                    vv.push_back(ve);</span><br><span class="line">                    ve.clear();</span><br><span class="line">                    depth=dque.front();</span><br><span class="line">                &#125;</span><br><span class="line">                que.pop();</span><br><span class="line">                dque.pop();</span><br><span class="line">                if(node)&#123;</span><br><span class="line">                    que.push(node-&gt;left);</span><br><span class="line">                    que.push(node-&gt;right);</span><br><span class="line">                    dque.push(depth+1);</span><br><span class="line">                    dque.push(depth+1);</span><br><span class="line">                    ve.push_back(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return vv;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="解析-60"><a href="#解析-60" class="headerlink" title="解析"></a>解析</h2><p> 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。</p><p>序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过  某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>这里以先序遍历的方式进行序列化举例：</p><p>先序序列化二叉树==定义一个stringbuilder保存序列过程中的结果：<strong>按照先序遍历方式遍历二叉树，若结点非空则把 “结点值!” append到builder中；若结点空则把  “#!” append到builder中；</strong>最后用builder生成字符串就是序列化结果。    </p><h2 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char* Serialize(TreeNode *root) &#123;</span><br><span class="line">        string str;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            str = to_string(root-&gt;val);</span><br><span class="line">            str = str + &quot;,&quot; + Serialize(root-&gt;left);</span><br><span class="line">            str = str + &quot;,&quot; + Serialize(root-&gt;right);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str = &quot;#&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        char* ret = new char[str.size()];</span><br><span class="line">        strcpy(ret,str.c_str());</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* dfs(char * &amp;str) &#123;</span><br><span class="line">        if(*str == &apos;,&apos;)&#123;</span><br><span class="line">            ++str;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str)&#123;</span><br><span class="line">            TreeNode* Tree = new TreeNode(0);</span><br><span class="line">            if(str &amp;&amp; *str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                while(*str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                    Tree-&gt;val *= 10;</span><br><span class="line">                    Tree-&gt;val += *str - &apos;0&apos;;</span><br><span class="line">                    ++str;</span><br><span class="line">                &#125;</span><br><span class="line">                Tree-&gt;left = dfs(str);</span><br><span class="line">                Tree-&gt;right = dfs(str);</span><br><span class="line">                return Tree;</span><br><span class="line">            &#125;else if(*str == &apos;#&apos;)&#123;</span><br><span class="line">                ++str;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* Deserialize(char * str)&#123;</span><br><span class="line">        return dfs(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h1><h2 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2 id="解析-61"><a href="#解析-61" class="headerlink" title="解析"></a>解析</h2><p>搜索树按从小到大的顺序排列正好就是中序遍历； 所以按照中序遍历查找，第k个节点就是结果。 </p><h2 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cnt;</span><br><span class="line">    TreeNode* KthNode(TreeNode* pRoot, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = 0;</span><br><span class="line">        return dfs(pRoot, k);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* dfs(TreeNode* pRoot, int k)&#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;left)&#123;</span><br><span class="line">            TreeNode* tmp = dfs(pRoot-&gt;left, k);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++cnt;</span><br><span class="line">        if(cnt == k)&#123;</span><br><span class="line">            return pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pRoot-&gt;right)&#123;</span><br><span class="line">            TreeNode* tmp = dfs(pRoot-&gt;right, k);</span><br><span class="line">            if(tmp)&#123;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h1><h2 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2 id="解析-62"><a href="#解析-62" class="headerlink" title="解析"></a>解析</h2><p>最大堆和最小堆结合。最大堆储存前n/2个数，最小堆储存后n/2个数。偶数个数据，那么中位数可以由大小堆堆顶的数得到，如果数据的数目是奇数，那么输出最大堆堆顶。 </p><h2 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if(max_que.size() == min_que.size())&#123;</span><br><span class="line">            if(max_que.empty() || max_que.top() &gt;= num || min_que.top() &gt;= num)&#123;</span><br><span class="line">                max_que.push(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                max_que.push(min_que.top());</span><br><span class="line">                min_que.pop();</span><br><span class="line">                min_que.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(max_que.top() &gt;= num)&#123;</span><br><span class="line">                min_que.push(max_que.top());</span><br><span class="line">                max_que.pop();</span><br><span class="line">                max_que.push(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                min_que.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123; </span><br><span class="line">        if(max_que.size() == min_que.size())&#123;</span><br><span class="line">            return (min_que.top() + max_que.top()) / 2.0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return max_que.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;min_que;</span><br><span class="line">    priority_queue&lt;int&gt;max_que;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><h2 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解析-63"><a href="#解析-63" class="headerlink" title="解析"></a>解析</h2><p>我们可以用STL中的deque，以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。</p><p>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。</p><p>第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</p><p>但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-13-001.png" alt=""></p><h2 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)&#123;</span><br><span class="line">        deque&lt;int&gt;dq, vis;</span><br><span class="line">        vector&lt;int&gt;v;</span><br><span class="line">        for(unsigned int i = 0; i &lt; num.size(); ++i)&#123;</span><br><span class="line">            if(!vis.empty() &amp;&amp; i - vis.front() &gt;= size)&#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                vis.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            while(!dq.empty() &amp;&amp; dq.back() &lt;= num[i])&#123;</span><br><span class="line">                    dq.pop_back();</span><br><span class="line">                    vis.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(num[i]);</span><br><span class="line">            vis.push_back(i);</span><br><span class="line">            if(i &gt;= size - 1)&#123;</span><br><span class="line">                v.push_back(dq.front());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2 id="解析-64"><a href="#解析-64" class="headerlink" title="解析"></a>解析</h2><p>dfs(回溯)。创建一个状态数组对访问的字符进行标记。首先，遍历这个矩阵，如果矩阵中某字符和目标字符首字母相等，则以该字符为起点dfs深搜，否则继续遍历。一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置。</p><h2 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool dfs(char* matrix, int x, int y, char* str, int cur, int rows, int cols)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] == true || str[cur] != matrix[x * cols + y])&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = true;</span><br><span class="line">        if(cur &gt;= len - 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            if(dfs(matrix, x + road[i][0], y + road[i][1], str, cur + 1, rows, cols) == true)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool hasPath(char* matrix, int rows, int cols, char* str)&#123;</span><br><span class="line">        if(matrix[0] == 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        len = strlen(str);</span><br><span class="line">        vis.resize(cols * rows, false);</span><br><span class="line">        for(int i = 0; i &lt; rows; ++i)&#123;</span><br><span class="line">            for(int j = 0; j &lt; cols; ++j)&#123;</span><br><span class="line">                if(matrix[i* cols + j] == str[0])&#123;</span><br><span class="line">                    if(dfs(matrix, i, j, str, 0, rows, cols) == true)&#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int len;</span><br><span class="line">    vector&lt;bool&gt;vis;</span><br><span class="line">    int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解析-65"><a href="#解析-65" class="headerlink" title="解析"></a>解析</h2><p>dfs(回溯)。创建一个状态数组对访问的格子进行标记，但是这里需要计算所有能够走的格子总数，实际上只需要对下一个进行访问的格子进行计算，进行从上、下、左、右四个方向进行递归，就可以计算出可以达到的格子总数了。 </p><h2 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int movingCount(int threshold, int rows, int cols)&#123;</span><br><span class="line">        vis.resize(rows * cols, false);</span><br><span class="line">        return dfs(threshold, rows, cols, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int dfs(int threshold, int rows, int cols, int x, int y)&#123;</span><br><span class="line">        if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] || threshold &lt; check(x) + check(y))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x * cols + y] = true;</span><br><span class="line">        int ans = 1;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            ans += dfs(threshold, rows, cols, x + road[i][0], y + road[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int check(int num)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(num)&#123;</span><br><span class="line">            res += num % 10;</span><br><span class="line">            num /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;bool&gt;vis;</span><br><span class="line">    int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GitHub源码地址：&lt;a href=&quot;https://github.com/qian-youyou/jzOffer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/qian-youyou/jzOffer&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="字符串" scheme="http://qianyouyou.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="http://qianyouyou.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="树" scheme="http://qianyouyou.cn/tags/%E6%A0%91/"/>
    
      <category term="剑指Offer" scheme="http://qianyouyou.cn/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>[转]STL四种智能指针</title>
    <link href="http://qianyouyou.cn/2019/03/30/2019-03-30/"/>
    <id>http://qianyouyou.cn/2019/03/30/2019-03-30/</id>
    <published>2019-03-30T09:35:07.000Z</published>
    <updated>2019-05-08T09:51:47.482Z</updated>
    
    <content type="html"><![CDATA[<p>STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr，auto_ptr是C++98提供的解决方案，C+11已将其摒弃，并提出了unique_ptr作为auto_ptr替代方案。虽然auto_ptr已被摒弃，但在实际项目中仍可使用，但建议使用较新的unique_ptr，因为unique_ptr比auto_ptr更加安全，后文会详细叙述。shared_ptr和weak_ptr则是C+11从准标准库Boost中引入的两种智能指针。此外，Boost库还提出了boost::scoped_ptr、boost::scoped_array、boost::intrusive_ptr 等智能指针，虽然尚未得到C++标准采纳，但是实际开发工作中可以使用。</p><p>#1.unique_ptr</p><p>unique_ptr由C++11引入，旨在替代不安全的auto_ptr。unique_ptr是一种定义在\&lt; memory&gt;中的智能指针。它持有对对象的独有权——两个unique_ptr不能指向一个对象，即unique_ptr不共享它的所管理的对象。它无法复制到其他unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。这意味着，内存资源所有权可以转移到另一个unique_ptr，并且原始 unique_ptr 不再拥有此资源。实际使用中，建议将对象限制为由一个所有者所有，因为多个所有权会使程序逻辑变得复杂。因此，当需要智能指针用于纯 C++ 对象时，可使用 unique_ptr，而当构造 unique_ptr 时，可使用 make_unique Helper 函数。</p><p>下图演示了两个 unique_ptr 实例之间的所有权转换。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-03-30.png" alt=""></p><p>unique_ptr与原始指针一样有效，并可用于 STL 容器。将 unique_ptr 实例添加到 STL 容器运行效率很高，因为通过 unique_ptr 的移动构造函数，不再需要进行复制操作。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权，unique_ptr还可能没有对象，这种情况被称为empty。</p><p>unique_ptr的基本操作有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//智能指针的创建  </span><br><span class="line">unique_ptr&lt;int&gt; u_i; //创建空智能指针</span><br><span class="line">u_i.reset(new int(3)); //&quot;绑定”动态对象  </span><br><span class="line">unique_ptr&lt;int&gt; u_i2(new int(4));//创建时指定动态对象</span><br><span class="line">unique_ptr&lt;T,D&gt; u(d);//创建空unique_ptr,执行类型为T的对象，用类型为D的对象d来替代默认的删除器delete</span><br><span class="line"></span><br><span class="line">//所有权的变化  </span><br><span class="line">int *p_i = u_i2.release(); //释放所有权  </span><br><span class="line">unique_ptr&lt;string&gt; u_s(new string(&quot;abc&quot;));  </span><br><span class="line">unique_ptr&lt;string&gt; u_s2 = std::move(u_s); //所有权转移(通过移动语义)，u_s所有权转移后，变成“空指针” </span><br><span class="line">u_s2.reset(u_s.release());//所有权转移</span><br><span class="line">u_s2=nullptr;//显式销毁所指对象，同时智能指针变为空指针。与u_s2.reset()等价</span><br></pre></td></tr></table></figure><h1 id="2-auto-ptr"><a href="#2-auto-ptr" class="headerlink" title="2.auto_ptr"></a>2.auto_ptr</h1><p>auto_ptr 同样是STL中智能指针家族的成员之一，由C++98引入，定义在头文件\<memory>。其功能和用法类似于unique_ptr，由 new expression 获得对象，在 auto_ptr 对象销毁时，他所管理的对象也会自动被 delete 掉。</memory></p><p>auto_ptr从C++98使用至今，为何从C++11开始，引入unique_ptr来替代auto_ptr呢？原因主要有如下几点：<br>（1）基于安全考虑<br>先来看下面的赋值语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt; string&gt; ps (new string (&quot;I reigned lonely as a cloud.”）;</span><br><span class="line">auto_ptr&lt;string&gt; vocation; </span><br><span class="line">vocaticn = ps;</span><br></pre></td></tr></table></figure><p>上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次，一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种：<br>（1）定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。<br>（2）建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的析构函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr 的策略，但unique_ptr的策略更严格。<br>（3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</p><p>当然，同样的策略也适用于复制构造函数，即auto_ptr\<string> vocation(ps)时也需要上面的策略。每种方法都有其用途，但为何要摒弃auto_ptr呢？</string></p><p>下面举个例子来说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;string&gt;</span><br><span class="line"># include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">auto_ptr&lt;string&gt; films[5] =&#123;</span><br><span class="line">auto_ptr&lt;string&gt; (new string(&quot;Fowl Balls&quot;)),</span><br><span class="line">auto_ptr&lt;string&gt; (new string(&quot;Duck Walks&quot;)),</span><br><span class="line">auto_ptr&lt;string&gt; (new string(&quot;Chicken Runs&quot;)),</span><br><span class="line">auto_ptr&lt;string&gt; (new string(&quot;Turkey Errors&quot;)),</span><br><span class="line">auto_ptr&lt;string&gt; (new string(&quot;Goose Eggs&quot;))</span><br><span class="line">&#125;;</span><br><span class="line">    auto_ptr&lt;string&gt; pwin;</span><br><span class="line">    pwin = films[2]; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;The nominees for best avian baseballl film are\n&quot;;</span><br><span class="line">for(int i = 0; i &lt; 5; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *films[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; &quot;The winner is &quot; &lt;&lt; *pwin &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下发现程序崩溃了，原因在上面注释已经说的很清楚，films[2]已经是空指针了，下面输出访问空指针当然会崩溃了。但这里如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下：</p><p>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。</p><p>使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译期因下述代码行出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; pwin;</span><br><span class="line">pwin = films[2]; //films[2] loses ownership</span><br></pre></td></tr></table></figure><p>指导你发现潜在的内存错误。这就是为何要摒弃auto_ptr的原因，一句话总结就是：避免因潜在的内存问题导致程序崩溃。</p><p>从上面可见，unique_ptr比auto_ptr更加安全，因为auto_ptr有拷贝语义，拷贝后原象变得无效，再次访问原对象时会导致程序崩溃；unique_ptr则禁止了拷贝语义，但提供了移动语义，即可以使用std::move()进行控制权限的转移，如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; upt(new string(&quot;lvlv&quot;));</span><br><span class="line">unique_ptr&lt;string&gt; upt1(upt);//编译出错，已禁止拷贝</span><br><span class="line">unique_ptr&lt;string&gt; upt1=upt;//编译出错，已禁止拷贝</span><br><span class="line">unique_ptr&lt;string&gt; upt1=std::move(upt);  //控制权限转移</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;string&gt; apt(new string(&quot;lvlv&quot;));</span><br><span class="line">auto_ptr&lt;string&gt; apt1(apt);//编译通过</span><br><span class="line">auto_ptr&lt;string&gt; apt1=apt;//编译通过</span><br></pre></td></tr></table></figure><p>这里要注意，在使用std::move将unique_ptr的控制权限转移后，不能够再通过unique_ptr来访问和控制资源了，否则同样会出现程序崩溃。我们可以在使用unique_ptr访问资源前，使用成员函数get()进行判空操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; upt1=std::move(upt);  //控制权限转移</span><br><span class="line">if(upt.get()!=nullptr)//判空操作更安全</span><br><span class="line">&#123;</span><br><span class="line">//do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）unique_ptr不仅安全，而且灵活<br>如果unique_ptr 是个临时右值，编译器允许拷贝语义。参考如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; demo(const char * s)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;string&gt; temp (new string (s))； </span><br><span class="line">    return temp；</span><br><span class="line">&#125;</span><br><span class="line">//假设编写了如下代码：</span><br><span class="line">unique_ptr&lt;string&gt; ps;</span><br><span class="line">ps = demo(&apos;Uniquely special&quot;)；</span><br></pre></td></tr></table></figure><p>demo()返回一个临时unique_ptr，然后ps接管了临时对象unique_ptr所管理的资源，而返回时临时的 unique_ptr 被销毁，也就是说没有机会使用 unique_ptr 来访问无效的数据，换句话来说，这种赋值是不会出现任何问题的，即没有理由禁止这种赋值。实际上，编译器确实允许这种赋值。相对于auto_ptr任何情况下都允许拷贝语义，这正是unique_ptr更加灵活聪明的地方。</p><p>（3）扩展auto_ptr不能完成的功能<br>（3.1）unique_ptr可放在容器中，弥补了auto_ptr不能作为容器元素的缺点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//方式一：</span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vs &#123; new string&#123;“Doug”&#125;, new string&#123;“Adams”&#125; &#125;;  </span><br><span class="line"></span><br><span class="line">//方式二：</span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt;v;  </span><br><span class="line">unique_ptr&lt;string&gt; p1(new string(&quot;abc&quot;));</span><br></pre></td></tr></table></figure><p>（3.2）管理动态数组，因为unique_ptr有unique_ptr&lt;X[]&gt;重载版本，销毁动态对象时调用delete[]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int[]&gt; p (new int[3]&#123;1,2,3&#125;);  </span><br><span class="line">p[0] = 0;// 重载了operator[]</span><br></pre></td></tr></table></figure><p>（3.3）自定义资源删除操作(Deleter)。unique_ptr默认的资源删除操作是delete/delete[]，若需要，可以进行自定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void end_connection(connection *p) &#123; disconnect(*p); &#125; //资源清理函数  </span><br><span class="line"></span><br><span class="line">//资源清理器的“类型” </span><br><span class="line">unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection);// 传入函数名，会自动转换为函数指针</span><br></pre></td></tr></table></figure><p>综上所述，基于unique_ptr的安全性和扩充的功能，unique_ptr成功的将auto_ptr取而代之。</p><h1 id="3-shared-ptr"><a href="#3-shared-ptr" class="headerlink" title="3.shared_ptr"></a>3.shared_ptr</h1><h2 id="3-1shared-ptr简介"><a href="#3-1shared-ptr简介" class="headerlink" title="3.1shared_ptr简介"></a>3.1shared_ptr简介</h2><p>shared_ptr 是一个标准的共享所有权的智能指针，允许多个指针指向同一个对象，定义在 memory 文件中，命名空间为 std。shared_ptr最初实现于Boost库中，后由C++11引入到C++ STL。shared_ptr利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个shared_ptr共同管理同一个对象。像shared_ptr这种智能指针，《Effective C++》称之为“引用计数型智能指针”（reference-counting smart pointer，RCSP）。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销：<br>（1）shared_ptr 对象除了包括一个所拥有对象的指针外，还必须包括一个引用计数代理对象的指针；<br>（2）时间上的开销主要在初始化和拷贝操作上， *和-&gt;操作符重载的开销跟auto_ptr是一样；<br>（3）开销并不是我们不使用shared_ptr的理由,，永远不要进行不成熟的优化，直到性能分析器告诉你这一点。</p><h2 id="3-2通过辅助类模拟实现shared-ptr"><a href="#3-2通过辅助类模拟实现shared-ptr" class="headerlink" title="3.2通过辅助类模拟实现shared_ptr"></a>3.2通过辅助类模拟实现shared_ptr</h2><p>（1）基础对象类<br>首先，我们来定义一个基础对象类Point类，为了方便后面我们验证智能指针是否有效，我们为Point类创建如下接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int x, y;</span><br><span class="line">public:</span><br><span class="line">    Point(int xVal = 0, int yVal = 0) :x(xVal), y(yVal) &#123; &#125;</span><br><span class="line">    int getX() const &#123; return x; &#125;</span><br><span class="line">    int getY() const &#123; return y; &#125;</span><br><span class="line">    void setX(int xVal) &#123; x = xVal; &#125;</span><br><span class="line">    void setY(int yVal) &#123; y = yVal; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）辅助类<br>在创建智能指针类之前，我们先创建一个辅助类。这个类的所有成员皆为私有类型，因为它不被普通用户所使用。为了只为智能指针使用，还需要把智能指针类声明为辅助类的友元。这个辅助类含有两个数据成员：计数count与基础对象指针。也即辅助类用以封装使用计数与基础对象指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class RefPtr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    friend class SmartPtr;      </span><br><span class="line">    RefPtr(Point *ptr):p(ptr),count(1)&#123; &#125;</span><br><span class="line">    ~RefPtr()&#123;delete p;&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">int count;   </span><br><span class="line">Point *p;                                                      </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（3）为基础对象类实现智能指针类<br>引用计数是实现智能指针的一种通用方法。智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针。它的具体做法如下：<br>（3.1）当创建智能指针类的新对象时，初始化指针，并将引用计数设置为1；<br>（3.2）当能智能指针类对象作为另一个对象的副本时，拷贝构造函数复制副本的指向辅助类对象的指针，并增加辅助类对象对基础类对象的引用计数（加1）；<br>（3.3）使用赋值操作符对一个智能指针类对象进行赋值时，处理复杂一点：先使左操作数的引用计数减1（为何减1：因为指针已经指向别的地方），如果减1后引用计数为0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）。<br>（3.4）完成析构函数：调用析构函数时，析构函数先使引用计数减1，如果减至0则delete对象。</p><p>做好前面的准备后，我们可以为基础对象类Point书写一个智能指针类了。根据引用计数实现关键点，我们可以写出如下智能指针类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class SmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SmartPtr(Point *ptr) :rp(new RefPtr(ptr))&#123;&#125; </span><br><span class="line">    SmartPtr(const SmartPtr &amp;sp):rp(sp.rp)&#123;++rp-&gt;count;&#125;</span><br><span class="line">    </span><br><span class="line">//重载赋值运算符</span><br><span class="line">SmartPtr&amp; operator=(const SmartPtr&amp; rhs) </span><br><span class="line">&#123;</span><br><span class="line">        ++rhs.rp-&gt;count;    </span><br><span class="line">        if (--rp-&gt;count == 0)    </span><br><span class="line">            delete rp;</span><br><span class="line">        rp = rhs.rp;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载-&gt;操作符</span><br><span class="line">    Point* operator-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">    return rp-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    //重载*操作符</span><br><span class="line">    Point&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">    return *(rp-&gt;p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">~SmartPtr()</span><br><span class="line">&#123;       </span><br><span class="line">    if (--rp-&gt;count == 0)   </span><br><span class="line">        delete rp;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;还有&quot; &lt;&lt; rp-&gt;count &lt;&lt; &quot;个指针指向基础对象&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RefPtr *rp;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（4）智能指针类的使用与测试<br>至此，我们的智能指针类就完成了，我们可以来看看如何使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个基础对象类指针</span><br><span class="line">    Point *pa = new Point(10, 20);</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>//定义三个智能指针类对象，对象都指向基础类对象pa<br>//使用花括号控制三个智能指针的生命周期，观察计数的变化<br>{<br>    SmartPtr sptr1(pa);//此时计数count=1<br>    cout &lt;&lt;”sptr1:”&lt;<sptr1->getX()&lt;&lt;”,”&lt;<sptr1->getY()&lt;&lt;endl;<br>    {<br>        SmartPtr sptr2(sptr1); //调用拷贝构造函数，此时计数为count=2<br>        cout&lt;&lt;”sptr2:” &lt;<sptr2->getX()&lt;&lt;”,”&lt;<sptr2->getY()&lt;&lt;endl;<br>        {<br>            SmartPtr sptr3=sptr1; //调用赋值操作符，此时计数为conut=3<br>            cout&lt;&lt;”sptr3:”&lt;&lt;(<em>sptr3).getX()&lt;&lt;”,”&lt;&lt;(</em>sptr3).getY()&lt;&lt;endl;<br>        }<br>        //此时count=2<br>    }<br>    //此时count=1；<br>}<br>//此时count=0；pa对象被delete掉<br>cout &lt;&lt; pa-&gt;getX ()&lt;&lt; endl;<br>system(“pause”);<br>return 0;<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sptr2-></sptr2-></sptr1-></sptr1-></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sptr1:10,20</span><br><span class="line">sptr2:10,20</span><br><span class="line">sptr3:10,20</span><br><span class="line">还有2个指针指向基础对象</span><br><span class="line">还有1个指针指向基础对象</span><br><span class="line">7244864</span><br></pre></td></tr></table></figure><p>如期，在离开大括号后，共享基础对象的指针从3-&gt;2-&gt;1-&gt;0变换，最后计数为0时，pa对象被delete，此时使用getX()已经获取不到原来的值。</p><p>（5）对智能指针的改进<br>目前这个智能指针只能用于管理Point类的基础对象，如果此时定义了个矩阵的基础对象类，那不是还得重新写一个属于矩阵类的智能指针类吗？但是矩阵类的智能指针类设计思想和Point类一样啊，就不能借用吗？答案当然是能，那就是使用模板技术。为了使我们的智能指针适用于更多的基础对象类，我们有必要把智能指针类通过模板来实现。这里贴上上面的智能指针类的模板版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//模板类作为友元时要先有声明</span><br><span class="line">template &lt;typename T&gt; class SmartPtr;</span><br><span class="line"></span><br><span class="line">//辅助类</span><br><span class="line">template &lt;typename T&gt; class RefPtr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    //该类成员访问权限全部为private，因为不想让用户直接使用该类</span><br><span class="line">    friend class SmartPtr&lt;T&gt;;      //定义智能指针类为友元，因为智能指针类需要直接操纵辅助类</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>//构造函数的参数为基础对象的指针<br>RefPtr(T *ptr) :p(ptr), count(1) { }</p><p>//析构函数<br>~RefPtr() { delete p; }<br>//引用计数<br>int count;   </p><p>//基础对象指针<br>T *p;<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//智能指针类</span><br><span class="line">template &lt;typename T&gt; class SmartPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SmartPtr(T *ptr) :rp(new RefPtr&lt;T&gt;(ptr)) &#123; &#125;      //构造函数</span><br><span class="line">    SmartPtr(const SmartPtr&lt;T&gt; &amp;sp) :rp(sp.rp) &#123; ++rp-&gt;count; &#125;  //复制构造函数</span><br><span class="line">    SmartPtr&amp; operator=(const SmartPtr&lt;T&gt;&amp; rhs)       //重载赋值操作符</span><br><span class="line">    &#123;</span><br><span class="line">        ++rhs.rp-&gt;count;        //首先将右操作数引用计数加1，</span><br><span class="line">        if (--rp-&gt;count == 0)   //然后将引用计数减1，可以应对自赋值</span><br><span class="line">            delete rp;</span><br><span class="line">        rp = rhs.rp;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>T &amp; operator <em>()        //重载</em>操作符<br>{<br>    return <em>(rp-&gt;p);<br>}<br>T</em> operator -&gt;()       //重载-&gt;操作符<br>{<br>    return rp-&gt;p;<br>}<br>~SmartPtr()            //析构函数<br>{<br>    if (–rp-&gt;count == 0)    //当引用计数减为0时，删除辅助类对象指针，从而删除基础对象<br>        delete rp;<br>    else<br>    {<br>        cout &lt;&lt; “还有” &lt;&lt; rp-&gt;count &lt;&lt; “个指针指向基础对象” &lt;&lt; endl;<br>    }<br>}<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RefPtr&lt;T&gt; *rp;  //辅助类对象指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>现在使用智能指针类模板来共享其它类型的基础对象，以int为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//定义一个基础对象类指针</span><br><span class="line">    int* ia = new int(10);</span><br><span class="line">    &#123;</span><br><span class="line">        SmartPtr&lt;int&gt; sptr1(ia);</span><br><span class="line">        cout &lt;&lt;&quot;sptr1:&quot;&lt;&lt;*sptr1&lt;&lt;endl;</span><br><span class="line">        &#123;</span><br><span class="line">            SmartPtr&lt;int&gt; sptr2(sptr1); </span><br><span class="line">            cout &lt;&lt;&quot;sptr2:&quot;&lt;&lt;*sptr2&lt;&lt;endl;</span><br><span class="line">*sptr2=5;</span><br><span class="line">            &#123;</span><br><span class="line">                SmartPtr&lt;int&gt; sptr3=sptr1; </span><br><span class="line">                cout &lt;&lt;&quot;sptr3:&quot;&lt;&lt;*sptr3&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //此时count=0；pa对象被delete掉</span><br><span class="line">    cout&lt;&lt;*ia&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sptr1:10</span><br><span class="line">sptr2:10</span><br><span class="line">sptr3:5</span><br><span class="line">还有2个指针指向基础对象</span><br><span class="line">还有1个指针指向基础对象</span><br><span class="line">3968064</span><br></pre></td></tr></table></figure><h1 id="4-weak-ptr"><a href="#4-weak-ptr" class="headerlink" title="4.weak_ptr"></a>4.weak_ptr</h1><h2 id="4-1weak-ptr简介"><a href="#4-1weak-ptr简介" class="headerlink" title="4.1weak_ptr简介"></a>4.1weak_ptr简介</h2><p>weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造而来。weak_ptr是为了配合shared_ptr而引入的一种智能指针，它更像是shared_ptr的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载operator*和-&gt;，因此取名为weak，表明其是功能较弱的智能指针。它的最大作用在于协助shared_ptr工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着weak_ptr只对shared_ptr 进行引用，而不改变其引用计数，当被观察的shared_ptr失效后，相应的weak_ptr也相应失效。</p><h2 id="4-2用法"><a href="#4-2用法" class="headerlink" title="4.2用法"></a>4.2用法</h2><p>使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0，但更快，表示被观测的资源(也就是shared_ptr管理的资源)已经不复存在。weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr管理的对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。总结来说，weak_ptr的基本用法总结如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w; //创建空weak_ptr,可以指向类型为T的对象。</span><br><span class="line">weak_ptr&lt;T&gt; w(sp);//与shared_ptr指向相同的对象，shared_ptr引用计数不变。T必须能转换为sp指向的类型。</span><br><span class="line">w=p;//p可以是shared_ptr或weak_ptr，赋值后w与p共享对象。</span><br><span class="line">w.reset();//将w置空。</span><br><span class="line">w.use_count();//返回与w共享对象的shared_ptr的数量。</span><br><span class="line">w.expired();//若w.use_count()为0，返回true，否则返回false。</span><br><span class="line">w.lock();//如果expired()为true，返回一个空shared_ptr，否则返回非空shared_ptr。</span><br></pre></td></tr></table></figure><p>下面是一个简单的使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># include &lt; assert.h&gt;</span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;memory&gt;</span><br><span class="line"># include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">assert(sp.use_count() == 1);</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp); //从shared_ptr创建weak_ptr</span><br><span class="line">assert(wp.use_count() == 1);</span><br><span class="line">if (!wp.expired())//判断weak_ptr观察的对象是否失效</span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;int&gt; sp2 = wp.lock();//获得一个shared_ptr</span><br><span class="line">*sp2 = 100;</span><br><span class="line">assert(wp.use_count() == 2);</span><br><span class="line">&#125;</span><br><span class="line">assert(wp.use_count()== 1);</span><br><span class="line">cout&lt;&lt;&quot;int:&quot;&lt;&lt;*sp&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int：100</span><br></pre></td></tr></table></figure><p>从上面可以看到，尽管以shared_ptr来构造weak_ptr，但是weak_ptr内部的引用计数并没有什么变化。</p><h2 id="4-3weak-ptr的作用"><a href="#4-3weak-ptr的作用" class="headerlink" title="4.3weak_ptr的作用"></a>4.3weak_ptr的作用</h2><p>现在要说的问题是，weak_ptr到底有什么作用呢？从上面那个例子看来，似乎没有任何作用。其实weak_ptr可用于打破循环引用。引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。一个简单的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class Woman;  </span><br><span class="line">class Man</span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    //std::weak_ptr&lt;Woman&gt; _wife;  </span><br><span class="line">    std::shared_ptr&lt;Woman&gt; _wife;  </span><br><span class="line">public:  </span><br><span class="line">    void setWife(std::shared_ptr&lt;Woman&gt; woman)</span><br><span class="line">    &#123;  </span><br><span class="line">        _wife = woman;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>void doSomthing()<br>{<br>    if(_wife.lock())<br>    {<br>    }<br>}  </p><p>~Man()<br>{<br>    std::cout &lt;&lt; “kill man\n”;<br>}<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">class Woman</span><br><span class="line">&#123;  </span><br><span class="line">private:  </span><br><span class="line">    //std::weak_ptr&lt;Man&gt; _husband;  </span><br><span class="line">    std::shared_ptr&lt;Man&gt; _husband;  </span><br><span class="line">public:  </span><br><span class="line">    void setHusband(std::shared_ptr&lt;Man&gt; man)</span><br><span class="line">    &#123;  </span><br><span class="line">        _husband = man;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~Woman()</span><br><span class="line">    &#123;  </span><br><span class="line">        std::cout &lt;&lt;&quot;kill woman\n&quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;  </span><br><span class="line">    std::shared_ptr&lt;Man&gt; m(new Man());  </span><br><span class="line">    std::shared_ptr&lt;Woman&gt; w(new Woman());  </span><br><span class="line">    if(m &amp;&amp; w)</span><br><span class="line">    &#123;  </span><br><span class="line">        m-&gt;setWife(w);  </span><br><span class="line">        w-&gt;setHusband(m);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Man类内部会引用一个Woman，Woman类内部也引用一个Man。当一个man和一个woman是夫妻的时候，他们直接就存在了相互引用问题。man内部有个用于管理wife生命期的shared_ptr变量，也就是说wife必定是在husband去世之后才能去世。同样的，woman内部也有一个管理husband生命期的shared_ptr变量，也就是说husband必须在wife去世之后才能去世。这就是循环引用存在的问题：husband的生命期由wife的生命期决定，wife的生命期由husband的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。</p><p>一般来讲，解除这种循环引用有下面三种可行的方法：<br>（1）当只剩下最后一个引用的时候需要手动打破循环引用释放对象。<br>（2）当parent的生存期超过children的生存期的时候，children改为使用一个普通指针指向parent。<br>（3）使用弱引用的智能指针打破这种循环引用。<br>虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。这里主要介绍一下第三种方法，使用弱引用的智能指针std:weak_ptr来打破循环引用。</p><p>weak_ptr对象引用资源时不会增加引用计数，但是它能够通过lock()方法来判断它所管理的资源是否被释放。做法就是上面的代码注释的地方取消注释，取消Woman类或者Man类的任意一个即可，也可同时取消注释，全部换成弱引用weak_ptr。</p><p>另外很自然地一个问题是：既然weak_ptr不增加资源的引用计数，那么在使用weak_ptr对象的时候，资源被突然释放了怎么办呢？不用担心，因为不能直接通过weak_ptr来访问资源。那么如何通过weak_ptr来间接访问资源呢？答案是在需要访问资源的时候weak_ptr为你生成一个shared_ptr，shared_ptr能够保证在shared_ptr没有被释放之前，其所管理的资源是不会被释放的。创建shared_ptr的方法就是lock()成员函数。</p><p>注意： shared_ptr实现了operator bool() const方法来判断一个管理的资源是否被释放。</p><p>5.如何选择智能指针<br>上文简单地介绍了C++标准模板库STL中四种智能指针，当然，除了STL中的智能指针，C++准标准库Boost中的智能指针，比如boost::scoped_ptr、boost::shared_array、boost:: intrusive_ptr也可以在实际编程实践中拿来使用，但这里不做进一步的介绍，有兴趣的读者可以参考：C++ 智能指针详解。</p><p>在了解STL中的四种智能指针后，大家可能会想另一个问题：在实际应用中，应使用哪种智能指针呢？</p><p>下面给出几个使用指南。<br>（1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：<br>（1.1）有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；<br>（1.2）两个对象都包含指向第三个对象的指针；<br>（1.3）STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。<br>（2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器中，只要不调用将一个unique_ptr复制或赋值给另一个的算法（如sort()）。例如，可在程序中使用类似于下面的代码段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; make_int(int n)</span><br><span class="line">&#123;</span><br><span class="line">    return unique_ptr&lt;int&gt;(new int(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(unique_ptr&lt;int&gt; &amp;p1)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *a &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    vector&lt;unique_ptr&lt;int&gt; &gt; vp(size);</span><br><span class="line">    for(int i = 0; i &lt; vp.size(); i++)</span><br><span class="line">vp[i] = make_int(rand() % 1000);       //copy temporary unique_ptr</span><br><span class="line">    vp.push_back(make_int(rand() % 1000));     //ok because arg is temporary</span><br><span class="line">    for_each(vp.begin(), vp.end(), show);      //use for_each()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化pi，而这是不允许的。前面说过，编译器将发现错误使用unique_ptr的企图。</p><p>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给另一个unique_ptr需要满足的条件相同，即unique_ptr必须是一个临时的对象。与前面一样，在下面的代码中，make_int()的返回类型为unique_ptr\&lt; int&gt;：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int&gt; pup(make_int(rand() % 1000));   // ok</span><br><span class="line">shared_ptr&lt;int&gt; spp(pup);                    // not allowed, pup as lvalue</span><br><span class="line">shared_ptr&lt;int&gt; spr(make_int(rand() % 1000));    // ok</span><br></pre></td></tr></table></figure><p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。</p><p>在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。</p><p>参考文献</p><p>[1]Stanley B.Lippman著,王刚，杨巨峰译.C++ Primer（第五版）.2013:400-422</p><p>[2]Scott Meyers著，侯捷译.Effective C++中文版（第三版）.2011：61-77</p><p>[3]C++智能指针简单剖析</p><p>[4]shared_ptr基于引用计数智能指针实现</p><p>[5] C++中智能指针的设计和使用</p><p>[6]C++11智能指针之unique_ptr</p><p>[7]Boost智能指针——weak_ptr</p><p>[8]std::shared_ptr 和 std::weak_ptr的用法以及引用计数的循环引用问题</p><p>作者：Dablelv<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/k346k346/article/details/81478223" target="_blank" rel="noopener">https://blog.csdn.net/k346k346/article/details/81478223</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr，auto_ptr是C++98提供的解决方案，C+11已将其摒弃，并提出了unique_ptr作为auto_ptr替代方案。虽然auto_ptr已被摒弃，但在实
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
      <category term="智能指针" scheme="http://qianyouyou.cn/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现Linux下读取指定目录下普通文件的个数</title>
    <link href="http://qianyouyou.cn/2019/03/16/2019-03-16-1/"/>
    <id>http://qianyouyou.cn/2019/03/16/2019-03-16-1/</id>
    <published>2019-03-16T14:05:44.000Z</published>
    <updated>2019-04-27T15:41:21.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打开一个目录"><a href="#打开一个目录" class="headerlink" title="打开一个目录"></a>打开一个目录</h2><ul><li>DIR <em>opendir(const char </em>name);</li><li><ul><li>参数: 目录名</li><li>返回值: 指向目录的指针</li></ul></li><li>FILE* fp = fopen（）</li><li>fread（buf， len， len，fp）；</li></ul><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                         // 此目录进入点的inode</span><br><span class="line">    ff_t d_off;                             // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;      // d_name 所指的文件类型 </span><br><span class="line">    har d_name[256];       // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>d_type<ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软连接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知 </li></ul></li><li>struct dirent <em>readdir(DIR      </em>dirp);<ul><li>参数: opendir的返回值</li><li>返回值: 目录项结构体 </li></ul></li></ul><h2 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h2><ul><li>int closedir(DIR *dirp);</li></ul><p>独立完成递归读目录中指定类型文件个数的操作. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int get_file_num(char* root)&#123;</span><br><span class="line">int total = 0;</span><br><span class="line">DIR* dir = NULL;</span><br><span class="line">// 打开目录</span><br><span class="line">dir = opendir(root);</span><br><span class="line">// 循环从目录中读文件</span><br><span class="line"></span><br><span class="line">char path[1024];</span><br><span class="line">// 定义记录xiang指针</span><br><span class="line">struct dirent* ptr = NULL;</span><br><span class="line">while( (ptr = readdir(dir)) != NULL)&#123;</span><br><span class="line">// 跳过. he ..</span><br><span class="line">if(strcmp(ptr-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name, &quot;..&quot;) == 0)&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是不是目录</span><br><span class="line">if(ptr-&gt;d_type == DT_DIR)&#123;</span><br><span class="line">sprintf(path, &quot;%s/%s&quot;, root, ptr-&gt;d_name);</span><br><span class="line">// 递归读目录</span><br><span class="line">total += get_file_num(path);</span><br><span class="line">&#125;</span><br><span class="line">// 如果是普通文件</span><br><span class="line">if(ptr-&gt;d_type == DT_REG)&#123;</span><br><span class="line">total ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">if(argc &lt; 2)&#123;</span><br><span class="line">printf(&quot;./a.out path&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int total = get_file_num(argv[1]);</span><br><span class="line">printf(&quot;%s has regfile number: %d\n&quot;, argv[1], total);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;打开一个目录&quot;&gt;&lt;a href=&quot;#打开一个目录&quot; class=&quot;headerlink&quot; title=&quot;打开一个目录&quot;&gt;&lt;/a&gt;打开一个目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DIR &lt;em&gt;opendir(const char &lt;/em&gt;name);&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Linux/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件和目录操作函数总结</title>
    <link href="http://qianyouyou.cn/2019/03/16/2019-03-16/"/>
    <id>http://qianyouyou.cn/2019/03/16/2019-03-16/</id>
    <published>2019-03-16T11:26:27.000Z</published>
    <updated>2019-04-27T15:41:06.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-文件IO"><a href="#01-文件IO" class="headerlink" title="01-文件IO"></a>01-文件IO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure><h2 id="open-close"><a href="#open-close" class="headerlink" title="open/close"></a>open/close</h2><ul><li><p>函数原型:</p><ul><li>int open(const char *pathname,        int flags);</li><li>int open(const char *pathname,        int flags, mode_t mode);</li></ul></li><li><p>参数:</p><ul><li><p>flags</p><ul><li><p>必选项 O_RDONLY, O_WRONLY, O_RDWR</p></li><li><p>可选项 </p><ul><li><p>创建文件: O_CREAT</p><ul><li>创建文件时检测文件是否存在: O_EXCL</li><li>如果文件存在, 返回-1</li><li>必须与O_CREAT一起使用</li></ul></li><li><p>追加文件:  O_APPEND</p></li><li><p>文件截断:  O_TRUNC</p></li><li><p>设置非阻塞: O_NONBLOCK</p></li></ul></li></ul></li><li><p>mode  – 指定0777</p><ul><li><p>八进制数</p></li><li><p>最终权限: mode &amp; ~umaks</p></li><li><p>umask 0002</p><ul><li>000000010</li><li>~</li><li>111111101</li><li>111111111</li><li>&amp;</li><li>111111101</li><li>775</li></ul></li></ul></li></ul></li></ul><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><ul><li><p>函数原型: ssize_t read(int fd, void *buf, size_t count);</p><ul><li><p>参数:</p><ul><li>fd – open的返回值</li><li>buf - 缓冲区, 存放读取的数据</li><li>count – 缓冲区的最大容量 sizeof(buf)</li></ul></li><li><p>返回值:</p><ul><li>-1: 失败</li><li>>0: 读出的字节数</li><li>=0: 文件读完了</li></ul></li></ul></li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><ul><li><p>函数原型: ssize_t write(int fd, const void *buf, size_t count);</p><ul><li><p>参数:</p><ul><li>fd: 文件描述符, open 返回值</li><li>buf: 要往文件中写的数据</li><li>count: 有效数据的长度</li></ul></li><li><p>返回值:</p><ul><li>-1: 失败</li><li>>0: 写入的字节数</li></ul></li></ul></li></ul><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><ul><li><p>函数原型: off_t lseek(int fd, off_t offset, int whence);</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul></li><li><p>使用:</p><ul><li>文件指针移动到头部:</li><li>lseek(fd, 0, SEEK_SET);</li></ul></li><li><p>获取文件指针当前的位置:</p><ul><li>int len = lseek(fd, 0, SEEK_CUR);</li></ul></li><li><p>获取文件长度:</p><ul><li>int len = lseek(fd, 0, SEEK_END);</li></ul></li><li><p>文件拓展</p><ul><li>文件原大小100k， 拓展为1100k</li><li><p>lseek(fd, 1000, SEE_END);</p></li><li><p>最后做一次写操作write(fd, “a”, 1);</p></li></ul></li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li><p>阻塞和非阻塞是文件的属性还是read函数的属性?</p><ul><li><p>文件的属性</p></li><li><p>普通文件：hello.c</p><ul><li>默认不阻塞</li></ul></li><li><p>终端设备：/dev/tty</p><ul><li>默认阻塞</li><li>管道</li><li>套接字</li></ul></li></ul></li></ul><h1 id="02-stat-lstat函数"><a href="#02-stat-lstat函数" class="headerlink" title="02-stat/lstat函数"></a>02-stat/lstat函数</h1><h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br></pre></td></tr></table></figure><ul><li><p>st_mode – 16位整数</p></li><li><p>0-2 bit – 其他人权限</p><ul><li>S_IROTH      00004  读权限</li><li>S_IWOTH    00002  写权限</li><li>S_IXOTH      00001  执行权限</li><li>S_IRWXO     00007         掩码, 过滤        st_mode中除其他人权限以外的信息</li><li>3-5 bit – 所属组权限<ul><li>S_IRGRP      00040  读权限</li><li>S_IWGRP    00020  写权限</li><li>S_IXGRP      00010   执行权限</li><li>S_IRWXG    00070  掩码, 过滤        st_mode中除所属组权限以外的信息</li></ul></li><li>6-8 bit – 文件所有者权限<ul><li>S_IRUSR      00400    读权限</li><li>S_IWUSR    00200    写权限</li><li>S_IXUSR      00100     执行权限</li><li>S_IRWXU   00700     掩码, 过滤        st_mode中除文件所有者权限以外的信息</li></ul></li><li>12-15 bit – 文件类型<ul><li>S_IFSOCK         0140000 套接字</li><li>S_IFLNK            0120000 符号链接（软链接）</li><li>S_IFREG            0100000 普通文件</li><li>S_IFBLK             0060000 块设备</li><li>S_IFDIR             0040000 目录</li><li>S_IFCHR           0020000 字符设备</li><li>S_IFIFO             0010000 管道</li><li>S_IFMT        0170000 掩码,过滤        st_mode中除文件类型以外的信息(st_mode &amp; S_IFMT) ==  S_IFREG</li></ul></li></ul></li><li><p>int stat(const char <em>path,      struct stat </em>buf);</p></li><li><p>int lstat(const char <em>path,      struct stat </em>buf);</p><ul><li>lstat读取的链接文件本身的属性</li><li><p>stat读取的是连接文件指向的文件的属性</p><ul><li>追踪，穿透</li></ul></li></ul></li></ul><h1 id="03-文件属性函数"><a href="#03-文件属性函数" class="headerlink" title="03-文件属性函数"></a>03-文件属性函数</h1><h2 id="测试当前用户指定文件是否具有某种属性"><a href="#测试当前用户指定文件是否具有某种属性" class="headerlink" title="测试当前用户指定文件是否具有某种属性"></a>测试当前用户指定文件是否具有某种属性</h2><ul><li><p>当前用户, 使用哪个用户调用这个函数, 这个用户就是当前用户</p></li><li><p>int access(const char *pathname,      int mode);</p></li><li><ul><li>参数:<ul><li>pathname: 文件名</li><li>mode: 4种权限</li><li>R_OK – 读 </li><li>W_OK – 写 </li><li>X_OK – 执行 </li><li>F_OK – 文件是否存在</li></ul></li></ul></li><li><ul><li>返回值:</li><li>0 - 有某种权限, 或者文件存在</li><li>1 - 没有, 或文件不存在</li></ul></li></ul><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><ul><li><p>int chmod(const char *filename,       int mode);</p><ul><li><ul><li><p>参数:</p></li><li><ul><li>filename: 文件名</li><li>mode: 文件权限, 八进制数</li></ul></li></ul></li></ul></li></ul><h2 id="修改文件所有者和所属组"><a href="#修改文件所有者和所属组" class="headerlink" title="修改文件所有者和所属组"></a>修改文件所有者和所属组</h2><ul><li><p>int chown(const char *path,       uid_t owner, gid_t group);</p><ul><li><p>函数参数:</p></li><li><ul><li><p>path – 文件路径</p></li><li><p>owner – 整形值, 用户ID </p></li><li><ul><li>/etc/passwd</li></ul></li><li><p>group – …..,        组ID                </p></li><li><ul><li>/etc/group</li></ul></li></ul></li></ul></li></ul><h2 id="修改文件大小"><a href="#修改文件大小" class="headerlink" title="修改文件大小"></a>修改文件大小</h2><ul><li><p>int truncate(const char *path,       off_t length);</p></li><li><p>参数: </p></li><li><ul><li>path – 文件名</li><li>length – 文件的最终大小<ul><li>\1. 比原来小, 删掉后边的部分</li><li>\2. 比原来大, 向后拓展</li></ul></li></ul></li></ul><h1 id="04-目录操作相关函数"><a href="#04-目录操作相关函数" class="headerlink" title="04-目录操作相关函数"></a>04-目录操作相关函数</h1><ol><li><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2></li></ol><ul><li>int rename(const char <em>oldpath, const char </em>newpath);</li></ul><ol start="2"><li><h2 id="修改当前进程-应用程序-的路径-cd"><a href="#修改当前进程-应用程序-的路径-cd" class="headerlink" title="修改当前进程(应用程序)的路径 cd"></a>修改当前进程(应用程序)的路径 cd</h2></li></ol><ul><li><p>int chdir(const char *path);</p><ul><li>参数: 切换的路径</li></ul></li></ul><ol start="3"><li><h2 id="获取当前进程的工作目录-pwd"><a href="#获取当前进程的工作目录-pwd" class="headerlink" title="获取当前进程的工作目录 pwd"></a>获取当前进程的工作目录 pwd</h2></li></ol><ul><li><p>char <em>getcwd(char </em>buf, size_t size);</p><ul><li><p>返回值:</p><ul><li>成功: 当前的工作目录</li><li>失败: NULL</li></ul></li><li><p>参数:</p><ul><li>buf: 缓冲区, 存储当前的工作目录</li><li>size: 缓冲区大小</li></ul></li></ul></li></ul><ol start="4"><li><h2 id="创建目录-mkdir"><a href="#创建目录-mkdir" class="headerlink" title="创建目录 mkdir"></a>创建目录 mkdir</h2></li></ol><ul><li><p>int mkdir(const char *pathname,       mode_t mode);</p><ul><li>参数:<ul><li>pathname: 创建的目录名</li><li>mode: 目录权限, 八进制的数, 实际权限: mode &amp; ~umask</li></ul></li></ul></li></ul><ol start="5"><li><h2 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h2></li></ol><ul><li><p>int rmdir(const char       *pathname);</p><ul><li>参数: 空目录的名字</li></ul></li></ul><h1 id="05-目录遍历相关函数"><a href="#05-目录遍历相关函数" class="headerlink" title="05-目录遍历相关函数"></a>05-目录遍历相关函数</h1><ol><li><h2 id="打开一个目录"><a href="#打开一个目录" class="headerlink" title="打开一个目录"></a>打开一个目录</h2><ul><li><p>DIR <em>opendir(const char </em>name);</p></li><li><ul><li>参数: 目录名</li><li>返回值: 指向目录的指针</li></ul></li><li><p>FILE* fp = fopen（）</p></li><li><p>fread（buf， len， len，fp）；</p></li></ul></li><li><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                         // 此目录进入点的inode</span><br><span class="line">    ff_t d_off;                             // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen; // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;      // d_name 所指的文件类型 </span><br><span class="line">    har d_name[256];       // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>d_type</p><ul><li>DT_BLK - 块设备</li><li>DT_CHR - 字符设备</li><li>DT_DIR - 目录</li><li>DT_LNK - 软连接</li><li>DT_FIFO - 管道</li><li>DT_REG - 普通文件</li><li>DT_SOCK - 套接字</li><li>DT_UNKNOWN - 未知 </li></ul></li><li><p>struct dirent <em>readdir(DIR      </em>dirp);</p><ul><li>参数: opendir的返回值</li><li>返回值: 目录项结构体 </li></ul></li></ul><ol start="3"><li><h2 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h2><ul><li>int closedir(DIR *dirp);</li></ul></li><li><h2 id="独立完成递归读目录中指定类型文件个数的操作"><a href="#独立完成递归读目录中指定类型文件个数的操作" class="headerlink" title="独立完成递归读目录中指定类型文件个数的操作."></a>独立完成递归读目录中指定类型文件个数的操作.</h2></li></ol><h1 id="06-dup-dup2-fcntl"><a href="#06-dup-dup2-fcntl" class="headerlink" title="06-dup-dup2-fcntl"></a>06-dup-dup2-fcntl</h1><ol><li><p>复制文件描述符</p><ul><li><p>int dup(int oldfd);</p></li><li><ul><li><p>oldfd - 要复制的文件描述符</p></li><li><p>返回值: 新的文件描述符</p></li><li><p>dup调用成功:</p></li><li><ul><li>有两个文件描述符指向同一个文件</li></ul></li><li><p>返回值: 取最小的且没被占用的文件描述符</p></li></ul></li><li><p>int dup2(int oldfd, int newfd);</p></li><li><ul><li><p>oldfd -》hello</p></li><li><p>newfd -》world</p></li><li><ul><li><p>假设newfd已经指向了一个文件，首先断开close与那个文件的链接，newfd指向oldfd指向的文件</p></li><li><ul><li>文件描述符重定向</li></ul></li><li><ul><li>oldfd和newfd指向同一个文件</li></ul></li></ul></li><li><ul><li>newfd没有被占用，newfd指向oldfd指向的文件</li></ul></li></ul></li></ul></li><li><p>改变已经打开的文件的属性: fcntl</p></li></ol><ul><li><p>变参函数</p></li><li><p>复制一个已有的文件描述符</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ret = fcntl(fd, F_DUPFD);</span><br></pre></td></tr></table></figure><ul><li><p>获取/设置文件状态标志</p></li><li><ul><li>open 的flags参数</li></ul></li></ul><ol><li>获取文件状态标识</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int flag = fcntl(fd, F_GETFL)</span><br></pre></td></tr></table></figure><ol start="2"><li>设置文件状态标识</li></ol><ul><li>flag = flag      | O_APPEND;</li><li><p>fcntl(fd,      F_SETFL, flag)</p></li><li><p>可以更改的几个标识: O_APPEND、O_NONBLOCK （常用）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01-文件IO&quot;&gt;&lt;a href=&quot;#01-文件IO&quot; class=&quot;headerlink&quot; title=&quot;01-文件IO&quot;&gt;&lt;/a&gt;01-文件IO&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Linux/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>春招面经（2019.3.15日起）</title>
    <link href="http://qianyouyou.cn/2019/03/15/2019-03-15/"/>
    <id>http://qianyouyou.cn/2019/03/15/2019-03-15/</id>
    <published>2019-03-15T11:12:50.000Z</published>
    <updated>2019-05-10T05:30:50.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-15腾讯提前批一面（35分钟）"><a href="#3-15腾讯提前批一面（35分钟）" class="headerlink" title="3.15腾讯提前批一面（35分钟）"></a>3.15腾讯提前批一面（35分钟）</h1><p>第一次电话面试，而且是腾讯的，真的感觉特别紧张。虽然面试官小哥哥人特别好，一直在缓解气氛，但总体还是感觉状态不是很好。不管结果怎么样，先记录下这次所涉及到的知识点吧。</p><h2 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h2><p>有点紧张，把大概经历说了一下。</p><h2 id="为什么投腾讯，以及企业文化："><a href="#为什么投腾讯，以及企业文化：" class="headerlink" title="为什么投腾讯，以及企业文化："></a>为什么投腾讯，以及企业文化：</h2><p>谈到了百度狼性文化，其实之前看过一些相关的企业文化，但没有太深入取看。整体感觉有点不好。</p><h2 id="问题1：C-和Python有什么区别-各有什么特点。"><a href="#问题1：C-和Python有什么区别-各有什么特点。" class="headerlink" title="问题1：C++和Python有什么区别?各有什么特点。"></a>问题1：C++和Python有什么区别?各有什么特点。</h2><p>答：有点记不太清楚怎么回答的了。总之答得很不专业。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>程序有两种执行方式，解释执行和编译执行。<br>PYTHON是一种脚本语言，是解释执行的，不需要经过编译，所以很方便快捷，且能够很好地跨平台，写一些小工具小程序特别合适。<br>而C++则是一种需要编译后运行语言，在特定的机器上编译后在特定的机上运行，运行效率高，安全稳定。但编译后的程序一般是不跨平台的。 </p><p>学习一种编程语言不能看它热不热。而是要看它在某个领域的作用。就像汇编，虽然现在不热了，但是它在某些行业内还是很吃香的。PYTHON确实很强大，但在三五年内，不会作为一种主流的编程语言。至少在Windows程序开发领域内不会。 </p><p>A、解释程序<br>所谓解释程序是高级语言翻译程序的一种，它将源语言(如BASIC)书写的源程序作为输入，解释一句后就提交计算机执行一句，并不形成目标程序。就像外语翻译中的“口译”一样，说一句翻一句，不产生全文的翻译文本。这种工作方式非常适合于人通过终端设备与计算机会话，如在终端上打一条命令或语句，解释程序就立即将此语句解释成一条或几条指令并提交硬件立即执行且将执行结果反映到终端，从终端把命令打入后，就能立即得到计算结果。这的确是很方便的，很适合于一些小型机的计算问题。但解释程序执行速度很慢，例如源程序中出现循环，则解释程序也重复地解释并提交执行这一组语句，这就造成很大浪费。<br>B、编译程序<br>这是一类很重要的语言处理程序，它把高级语言(如FORTRAN、COBOL、Pascal、C等)源程序作为输入，进行翻译转换，产生出机器语言的目标程序，然后再让计算机去执行这个目标程序，得到计算结果。<br>编译程序工作时，先分析，后综合，从而得到目标程序。所谓分析，是指词法分析和语法分析；所谓综合是指代码优化，存储分配和代码生成。为了完成这些分析综合任务，编译程序采用对源程序进行多次扫描的办法，每次扫描集中完成一项或几项任务，也有一项任务分散到几次扫描去完成的。下面举一个四遍扫描的例子：第一遍扫描做词法分析；第二遍扫描做语法分析；第三遍扫描做代码优化和存储分配；第四遍扫描做代码生成。<br>值得一提的是，大多数的编译程序直接产生机器语言的目标代码，形成可执行的目标文件，但也有的编译程序则先产生汇编语言一级的符号代码文件，然后再调用汇编程序进行翻译加工处理，最后产生可执行的机器语言目标文件。<br>在实际应用中，对于需要经常使用的有大量计算的大型题目，采用招待速度较快的编译型的高级语言较好，虽然编译过程本身较为复杂，但一旦形成目标文件，以后可多次使用。相反，对于小型题目或计算简单不太费机时的题目，则多选用解释型的会话式高级语言，如BASIC，这样可以大大缩短编程及调试的时</p><h4 id="简短概述"><a href="#简短概述" class="headerlink" title="简短概述"></a>简短概述</h4><p>解释执行:<br>由解释器根据输入的数据当场执行而不生成任何的目标程序<br>编译执行: </p><p>先将源代码编译成目标语言(如:机器语言)之后通过连接程序连接到生成的目标程序进行执行</p><h2 id="问题2：网络传输-层的协议，概述UDP与TCP。"><a href="#问题2：网络传输-层的协议，概述UDP与TCP。" class="headerlink" title="问题2：网络传输 层的协议，概述UDP与TCP。"></a>问题2：网络传输 层的协议，概述UDP与TCP。</h2><p>答：举了电话通话与邮件发送的例子，由于紧张有些语无伦次。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>1.TCP面向连接（如打电话前需拨号确认连接）；UDP是无连接的（发送数据前不需要建立连接）<br>2.TCP提供可靠服务（数据无差错，不流失，不重复，有重传机制，且按序到达）；UDP尽力最大交付（不保证可靠，无重传机制，无序）<br>3.TCP面向字节流（把数据看成一连串无结构的字符流，每次取多少由主机决定）；UDP面向报文（发送多少接收多少）<br>4.TCP无界（通过字节流传输，字节流太长会拆分，太短会等待，接收方确认才会删除缓冲区；如服务器缓冲区足够大，则多次传输一次接收，被认为无界）；<br>   UDP有界（不拆分不合并，几次传输几次接收，被认为有界）<br>5.TCP有流量控制和拥塞控制（接收方让发送方的速度调节）；UDP没有流量控制（不会改变）</p><p>6.TCP的头部（20bytes）比UDP大</p><h2 id="问题3：UDP与TCP协议应用举例"><a href="#问题3：UDP与TCP协议应用举例" class="headerlink" title="问题3：UDP与TCP协议应用举例"></a>问题3：UDP与TCP协议应用举例</h2><p>答：举了IP电话与在线传输文件的例子，感觉答得不是很好。</p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… </p><p>什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率</p><h2 id="项目相关："><a href="#项目相关：" class="headerlink" title="项目相关："></a>项目相关：</h2><p>问到是否做过web项目，谈到了项目，其实之前跟着网课做过一些小项目，但自我感觉不是什么大项目，就没敢说。后来说了一些爬虫时的经历，以及自己搭建的博客。</p><h2 id="问题4：git相关命令"><a href="#问题4：git相关命令" class="headerlink" title="问题4：git相关命令"></a>问题4：git相关命令</h2><p>答：好久没用过git，许多命令其实忘得差不多了。</p><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/git.png" alt=""></p><h2 id="ACM比赛相关："><a href="#ACM比赛相关：" class="headerlink" title="ACM比赛相关："></a>ACM比赛相关：</h2><p>一些比赛经历以及有什么帮助。</p><h2 id="问题5：快排与堆排"><a href="#问题5：快排与堆排" class="headerlink" title="问题5：快排与堆排"></a>问题5：快排与堆排</h2><p>答：数据结构部分还是比较擅长的，虽然优化部分由于紧张有点记不太清楚了。</p><h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>快速排序使用了分治法的策略。它的基本思想是，选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。可以看出，快速排序很重要的一点就是对基准数的选择。影响快速排序性能的因素除了本身数组的有序程度，还和这个基准数有关。在下面的代码中，我们使用最经典的，选择数组的第一个数作为基准数。</p><p>快速排序流程如下：</p><p>(1)从数列中挑出一个基准值。</p><p>(2)将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。</p><p>(3)递归地把”基准值前面的子数列”和”基准值后面的子数列”进行排序。</p><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><h2 id="学习情况："><a href="#学习情况：" class="headerlink" title="学习情况："></a>学习情况：</h2><p>浏览CSDN博客，看网课，看书。</p><h1 id="3-18作业帮笔试"><a href="#3-18作业帮笔试" class="headerlink" title="3.18作业帮笔试"></a>3.18作业帮笔试</h1><h2 id="作业帮笔试"><a href="#作业帮笔试" class="headerlink" title="作业帮笔试"></a>作业帮笔试</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>1~2048有多少个1。</p><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p>千位上为1共有1000个（1000~1999）</p><p>百位上为1共有2 * 100 = 200个（100~199， 1100~1199）</p><p>十位上为1共有21 * 10 = 210个（XX10~XX19，XX∈[0，20]）</p><p>个位上为1共有205个（不多说了，自行脑补）</p><p>一共有1000+200+210+205 = 1615个</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>给出树的前序与中序遍历，求后序。</p><h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><p>不多说了，不会的话自行面壁。</p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>死锁产生的条件。</p><h4 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h4><p>互斥条件，请求与保持条件，不可抢夺条件，循环等待条件。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>0，2，3，5，9，17，31，57，___</p><h4 id="解法：-3"><a href="#解法：-3" class="headerlink" title="解法："></a>解法：</h4><p>105（17+31+57）</p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><p>2019！末尾有多少个0</p><h4 id="解法：-4"><a href="#解法：-4" class="headerlink" title="解法："></a>解法：</h4><p>重点在于质因数的运用，要点如下 </p><p>1、基本的一点，2<em>5=10，得到1个0 可以写成2^1</em>5^1=10^1 </p><p>2、进一步，4<em>25=100，得到2个0 可以写成2^2</em>5^2=10^2 </p><p>3、进一步，8<em>125=1000，得到3个0 可以写成2^3</em>5^3=10^3 </p><p>4、进一步，16<em>625=10000，得到4个0 可以写成2^4</em>5^4=10^4 </p><p>5、5^5=3125超过2015了，所以5次方以上不考虑 </p><p>6、不要担心双数的个数不够用，它会多出很多 </p><p>7、有了上面的1到4条，就可以计算了 (运算符<em>表示乘法，^表示乘方) </em></p><p>第一步，计算1到2015里多少个5,25,125,625 </p><p>1、2015÷5=403 记作A1；</p><p>2、2015÷25=80.6取整得80 记作A2； </p><p>3、2015÷125=16.12取整得16 记作A3； </p><p>4、2015÷625=3.224取整得3 记作A4； </p><p>第二步，计算上述A1到A4中重复的部分 </p><p>1、能被5整除的数里包含的能被25整除的数，记作B1 B1=A1-A2=403-80=323； </p><p>2、能被25整除的数里包含的能被125整除的数，记作B2 B2=A2-A3=80-16=64； </p><p>3、能被125整除的数里包含的能被625整除的数，记作B3 B3=A3-A4=16-3=13； </p><p>4、能被625整除的数里没有重复其它情况，直接计入结果，记作B4 B4=A4； </p><p>第三步，最终结果是 B1<em>1+B2</em>2+B3<em>3+B4</em>4=323+128+39+12=502………(1) </p><p>【答案】502个 最终结果也可以这样算： A1+A2+A3+A4=403+80+16+3=502 ………(2） 也就是 2015÷5+2015÷25+2015÷125+2015÷625 =403+80+16+3=502</p><h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><p>给出一列数，将其中所有的0放置末尾</p><p>例如1，2，0，3，0，4，则为1，2，3，4，0，0</p><h4 id="解法：-5"><a href="#解法：-5" class="headerlink" title="解法："></a>解法：</h4><p>两个指针，一个快指针，一个慢指针，如果快指针指向的数不为0，则快指针的值赋给慢指针，快指针慢指针均前进一步，否则快指针前进一步，慢指针不动。最后快指针指向尾了，如果慢指针没指向尾，之后的值全部为0。</p><h3 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h3><p>判断字符串是否为合法密码（长度大于8，含三类不同字符，且长度大于2的子串不能出现相同情况，例如A1abcdabc不合法，abc出现两次）</p><h4 id="解法：-6"><a href="#解法：-6" class="headerlink" title="解法："></a>解法：</h4><p>前两点太简单就不说了，第3点可以使用set每一次储存3个连续的字符，如果重复就不是合法的字符。</p><h3 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h3><p>5张牌斗牛，其中三张牌之和取余为0即为牛，剩余两张牌之和取余为几结果即为牛几。</p><h4 id="解法：-7"><a href="#解法：-7" class="headerlink" title="解法："></a>解法：</h4><p>5张牌只取个位数，然map记录下来，5张牌相加取余，然后依次减去其中一张牌，看得到的数字在map里存不存在，如果存在就说明有牛，牛就是5张牌相加的结果。也就是5张只和减两张看是不是0。相当于一层循环 ，On时间复杂度 </p><h1 id="3-19腾讯提前批二面（10分钟）"><a href="#3-19腾讯提前批二面（10分钟）" class="headerlink" title="3.19腾讯提前批二面（10分钟）"></a>3.19腾讯提前批二面（10分钟）</h1><h2 id="腾讯二面"><a href="#腾讯二面" class="headerlink" title="腾讯二面"></a>腾讯二面</h2><p>面试官好像是个技术总监，声音特别小，听的不是很清楚。总之10分钟结束，什么问题也没问，只留下一句之后等结果。然后就挂了，挂的莫名其妙。总结一下教训：</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>尽量2分钟左右。要提到很高兴参加贵公司的面试。结尾尽量要客气。</p><h3 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h3><p>千万不要说项目少，小项目也可以提及，不然对方真以为自己没项目了。（惨痛的教训）</p><h3 id="比赛情况"><a href="#比赛情况" class="headerlink" title="比赛情况"></a>比赛情况</h3><p>其实敲代码没什么不好的，我们实习生本来就是应该干底层的（qyq）</p><h3 id="岗位期望"><a href="#岗位期望" class="headerlink" title="岗位期望"></a>岗位期望</h3><p>后台研发，我期望做……当然具体还是听从部门的安排，如果部门安排我做哪一块那我会听从部门的安排，然后尽快学习相关技能，尽快融入其中。</p><h3 id="实习计划"><a href="#实习计划" class="headerlink" title="实习计划"></a>实习计划</h3><p>1.首先尽快了解企业文化，了解部门规章制度，以便争取未来尽快融入。</p><p>2.了解所在团队的成员情况，分工，自己的角色和职责，以便更好的配合。</p><p>3.了解岗前应会的内容，及团队当前的主要工作及进展。</p><p>4.拟定工作计划，经组长审阅后按照计划推进。</p><p>5.自己会不断学习，积极寻求同事和领导的帮助。以达成更好的业绩。</p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>切忌书生气，不能高谈阔论，一副兴趣广泛的样子。尽量要和职业贴近，否则就不要说的太多。</p><p>然后面试结束，没问任何专业相关问题，GG。</p><h1 id="3-20阿里一面（50分钟）"><a href="#3-20阿里一面（50分钟）" class="headerlink" title="3.20阿里一面（50分钟）"></a>3.20阿里一面（50分钟）</h1><h2 id="阿里首面"><a href="#阿里首面" class="headerlink" title="阿里首面"></a>阿里首面</h2><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>C++指针与引用的区别及内存情况</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h3><p>智能指针问题</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h3><p>hash_map与map的区别，底层构造，时间复杂度，选择</p><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题4-1"><a href="#问题4-1" class="headerlink" title="问题4"></a>问题4</h3><p>手写代码树的中序遍历</p><h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题5-1"><a href="#问题5-1" class="headerlink" title="问题5"></a>问题5</h3><p>vector的机制</p><h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题6-1"><a href="#问题6-1" class="headerlink" title="问题6"></a>问题6</h3><p>堆排序原理</p><h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题7-1"><a href="#问题7-1" class="headerlink" title="问题7"></a>问题7</h3><p>集合中，输出所有子集。</p><h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><h3 id="问题8-1"><a href="#问题8-1" class="headerlink" title="问题8"></a>问题8</h3><p>红墨水蓝墨水问题</p><h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>一样多。</p><h3 id="现状及项目"><a href="#现状及项目" class="headerlink" title="现状及项目"></a>现状及项目</h3><h3 id="问题9"><a href="#问题9" class="headerlink" title="问题9"></a>问题9</h3><p>预处理以及#ifdef</p><h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>选择性编译</p><h3 id="问题10"><a href="#问题10" class="headerlink" title="问题10"></a>问题10</h3><p>awk命令</p><h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><h1 id="3-22西科"><a href="#3-22西科" class="headerlink" title="3.22西科"></a>3.22西科</h1><p>具体不多说了，培训班。</p><h1 id="3-27西山居笔试"><a href="#3-27西山居笔试" class="headerlink" title="3.27西山居笔试"></a>3.27西山居笔试</h1><p>空间换时间</p><p>改错</p><p>两个数组问题</p><p>三子棋</p><h1 id="3-28西山居一面（45分钟）"><a href="#3-28西山居一面（45分钟）" class="headerlink" title="3.28西山居一面（45分钟）"></a>3.28西山居一面（45分钟）</h1><ol><li><p>类内const如何初始化</p></li><li><p>代码规范化问题，以及析构函数与构造函数调用问题</p><p>1、C++中, 构造函数和析构函数可以被显示调用. 显示调用默认构造函数的语法: a.A::A();(不能写成a.A();) , 显示调用非默认构造函数的语法: a.A::A(7);(不能写成a.A(7);); 显示调用析构函数的语法: a.A::~A();(可以写成a.~A();) .</p><p>2、显示调用构造函数和析构函数就像调用一般的函数一样, 并不意味着创建或销毁对象;</p><p>3、如果构造函数中动态分配了空间, 则显示调用构造函数会造成内存泄露. 创建对象时的隐式构造函数调用已经为对象分配了动态内存，当用创建好的对象显示调用构造函数时, 对象指向的动态内存更新为显示调用时所分配的, 对象生命周期结束时析构函数所释放掉的是后一次分配的动态内存, 也就是说创建对象时隐式构造函数调用所分配的那块内存泄漏了.</p><p>4、如果析构函数中释放动态分配的空间, 则会造成多次释放同一内存, 会出现严重错误. </p></li><li><p>三子棋问题</p></li><li><p>C++虚函数及底层实现</p><p>虚函数表</p></li><li><p>容器及各自底层实现</p></li><li><p>结构体对齐</p></li><li><p>C++11特性</p></li><li><p>内联函数与宏定义</p></li><li><p>连连看寻路问题</p></li><li><p>双属性排序问题</p></li><li><p>字符串最大值问题</p></li><li><p>找bug，野指针问题</p></li><li><p>研发岗难度在哪方面（哪些方向）</p></li></ol><h1 id="3-29西山居二三四面"><a href="#3-29西山居二三四面" class="headerlink" title="3.29西山居二三四面"></a>3.29西山居二三四面</h1><h2 id="二面（30分钟）"><a href="#二面（30分钟）" class="headerlink" title="二面（30分钟）"></a>二面（30分钟）</h2><p>深挖项目</p><h2 id="三面（10分钟）"><a href="#三面（10分钟）" class="headerlink" title="三面（10分钟）"></a>三面（10分钟）</h2><p>笔试题</p><p>三子棋判断输赢</p><p>智能指针</p><h2 id="四面（45分钟）"><a href="#四面（45分钟）" class="headerlink" title="四面（45分钟）"></a>四面（45分钟）</h2><p>项目</p><p>比赛担当角色</p><p>虚函数表</p><p>模板</p><p>Dijkstra算法分析</p><p>Linux下两个pthread如何实现同步</p><p>socket编程IO多路复用及epoll</p><p>如何看待自己的组织能力</p><p>为何选择游戏开发</p><p>上岗时间及时间安排</p><h1 id="4-1东方财富一面（15分钟）"><a href="#4-1东方财富一面（15分钟）" class="headerlink" title="4.1东方财富一面（15分钟）"></a>4.1东方财富一面（15分钟）</h1><p>使用过哪些API</p><p>知道哪些设计模式</p><p>单例设计模式讲解</p><p>101个数(0, 100]，只有一个数出现两次，找出这个数。</p><h1 id="4-4声网一面（30分钟）"><a href="#4-4声网一面（30分钟）" class="headerlink" title="4.4声网一面（30分钟）"></a>4.4声网一面（30分钟）</h1><p>比赛相关</p><p>智能指针</p><p>shared于unique的区别</p><p>unique如何保证唯一性</p><p>unordered_map</p><p>map增删改查时间复杂度</p><p>splay伸展树</p><p>vector和list的区别</p><p>vector底层实现</p><p>项链染色问题</p><p>区间第k大查询（主席树）</p><p>dijkstra算法优化部分优化在哪里</p><p>优先队列的底层原理</p><p>斐波那契堆</p><p>虚函数表</p><p>何时必须用初始化列表(const类型，没有默认构造函数，引用)</p><p>编译时多态（模板，重载，宏函数）</p><p>运行时多态（虚函数）</p><h1 id="4-5腾讯笔试"><a href="#4-5腾讯笔试" class="headerlink" title="4.5腾讯笔试"></a>4.5腾讯笔试</h1><h1 id="4-9声网二面（30分钟）"><a href="#4-9声网二面（30分钟）" class="headerlink" title="4.9声网二面（30分钟）"></a>4.9声网二面（30分钟）</h1><p>项目</p><p>聊天室项目</p><p>找中位数</p><p>第k大数</p><p>矩阵n次方</p><h1 id="4-12阿里二面（25分钟）"><a href="#4-12阿里二面（25分钟）" class="headerlink" title="4.12阿里二面（25分钟）"></a>4.12阿里二面（25分钟）</h1><p>多态</p><p>调试</p><p>服务器正在运行程序如何调试</p><p>vector的reserve与resize区别</p><p>链表交叉结点</p><p>找中位数</p><p>n个硬盘每个损坏概率p，且m个硬盘坏掉概率——(p^m)*((1-p)^(n-m))</p><h1 id="4-14腾讯正式批一面（40分钟）"><a href="#4-14腾讯正式批一面（40分钟）" class="headerlink" title="4.14腾讯正式批一面（40分钟）"></a>4.14腾讯正式批一面（40分钟）</h1><p>爬虫项目介绍</p><p>如何反爬（不知道）</p><p>智能指针概述</p><p>遇到异常处理如何解决内存释放问题</p><p>如何处理未知异常（不知道）</p><p>仿函数（不知道）</p><p>用过stl哪些算法</p><p>A*搜索</p><p>Linux相关命令</p><p>如何判断某目录下某文件是否存在（find –name）</p><p>如何计算某目录下文件个数（C语言实现readdir）</p><p>多进程多线程相关</p><p>进程间通信方式</p><p>详细概述epoll</p><p>read返回值（返回值为长度。为0断开连接，-1为异常）</p><p>边沿触发（阻塞，非阻塞）</p><p>数据库了解多少</p><h1 id="4-21腾讯正式批二面（35分钟）"><a href="#4-21腾讯正式批二面（35分钟）" class="headerlink" title="4.21腾讯正式批二面（35分钟）"></a>4.21腾讯正式批二面（35分钟）</h1><p>答到最后都以为必挂了。真心感谢面试官手下留情(^人^)</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>TCP与UDP概述</p><p>可靠的UDP协议（不知道）</p><p>四次挥手过程</p><p>timewait在第几次挥手</p><p>timewait作用</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>智能指针相关</p><p>STL容器用过哪些</p><p>vector机制</p><p>deque机制</p><p>delete数组（好久没怎么复习了）</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>集合求子集</p><p>输出数组中唯一只有一个不重复元素</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>分页与分段的区别。</p><p>概述进程。</p><p>进程调度算法。</p><p>TCP拥塞算法。</p><h1 id="5-09字节跳动（45分钟）"><a href="#5-09字节跳动（45分钟）" class="headerlink" title="5.09字节跳动（45分钟）"></a>5.09字节跳动（45分钟）</h1><p>STL中各种set的底层实现</p><p>hashMap如何处理冲突</p><p>如何避免hashMap冲突</p><p>vector的push_back过程</p><p>vector的push_back插入平均时间复杂度及计算过程</p><p>python修饰器</p><p>tcp四次挥手过程</p><p>time_wait相关</p><p>http协议</p><p>tcp拥塞控制</p><p>编程题，数组中，每个数字为向后走的最大步数，至少需要几个数字到达最后一个位置。</p><p>进程间通信方式。</p><p>常用的信号。</p><p>socket的底层实现。</p><p>epoll与poll的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;3-15腾讯提前批一面（35分钟）&quot;&gt;&lt;a href=&quot;#3-15腾讯提前批一面（35分钟）&quot; class=&quot;headerlink&quot; title=&quot;3.15腾讯提前批一面（35分钟）&quot;&gt;&lt;/a&gt;3.15腾讯提前批一面（35分钟）&lt;/h1&gt;&lt;p&gt;第一次电话面试，而且
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="面经" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://qianyouyou.cn/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>温习C++继承与多态之打造简易回合制5V5小游戏</title>
    <link href="http://qianyouyou.cn/2019/03/11/2019-03-11/"/>
    <id>http://qianyouyou.cn/2019/03/11/2019-03-11/</id>
    <published>2019-03-11T13:16:23.000Z</published>
    <updated>2019-04-27T15:40:07.217Z</updated>
    
    <content type="html"><![CDATA[<p>曾几何时，网页游戏风靡整个网络世界，然而手机游戏的出现，如今的网页游戏已经渐渐销声匿迹了。</p><p>还记得我玩的第一款时间较长的网页游戏——龙将，如今服务器已关闭了，包括代理商“风行”如今也鲜为人知。其实那款游戏很简单，两个玩家对弈，双方每人出场5个英雄，按回合制以英雄的速度为先后顺序，每个英雄普通攻击或使用技能，直到一方的所有英雄全部死亡为止。所有攻击操作都是自动的，不需要我们操作，我们只需选择英雄上阵即可。</p><p>曾经想着什么时候能自己编一款类似的游戏，以便属性按照自己的想法设定。如今就简简单单实现一下吧。（超级粗略哦）</p><p>首先，我们来分析一下，每个英雄都有攻击属性，防御属性，速度，生命值，还有一些特殊的效果（暴击，吸血什么的啦），英雄可以装备武器，可以对敌方英雄造成伤害。那么我们先创建一个Hero类，它包含上述所有属性及方法。然后，每个英雄不同之处在于技能与被动技能，那我们利用多态来实现不同的技能。</p><p>再来分析一下武器，武器有基础属性和特殊属性，不同的武器属性不同，那么我们先创建一个基类Weapon类，该类函数声明为纯虚类，不可被继承，由派生来来实现具体功能即可。</p><p>英雄和武器写完之后，再创建一个国家类。由于英雄以国家而划分，所以每个国家由许多英雄类指针组成。</p><p>每个玩家有5个英雄，具体实现同国家类。</p><p>图示如下</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-3-11.png" alt=""></p><p>由于本人比较懒，写着写着又犯懒了，所以技能方面还没实现，每次都是普通攻击触发各种效果。不过目前可以正常运行。等哪天有时间了再继续改进吧。以下是代码：</p><p><strong>Weapon.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//抽象类</span><br><span class="line">class Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage() = 0;</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef() = 0;</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood() = 0;</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold() = 0;</span><br><span class="line"></span><br><span class="line">static bool isTrigger(int rate);</span><br><span class="line"></span><br><span class="line">string m_WeaponName;//武器名</span><br><span class="line">int m_BaceDamage;//基础伤害</span><br><span class="line">int BaceDef;//基础防御</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Knife :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Knife();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DragonSword :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">DragonSword();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Sword :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Sword();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int suckRate;</span><br><span class="line">int holdRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shield :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Shield();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Spear :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Spear();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line">int suckRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bow :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Bow();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Book :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Book();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int suckRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Fan :public Weapon &#123;</span><br><span class="line">public:</span><br><span class="line">Fan();</span><br><span class="line">//获取基础伤害</span><br><span class="line">virtual int getBaceDamage();</span><br><span class="line"></span><br><span class="line">//获取防御</span><br><span class="line">virtual int getBaceDef();</span><br><span class="line"></span><br><span class="line">//获取吸血</span><br><span class="line">virtual bool getSuckBlood();</span><br><span class="line"></span><br><span class="line">//获取流血</span><br><span class="line">virtual bool getHold();</span><br><span class="line"></span><br><span class="line">int holdRate;</span><br><span class="line">int suckRate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Weapon.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Weapon.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Knife::Knife()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 10;</span><br><span class="line">this-&gt;BaceDef = 0;</span><br><span class="line">this-&gt;holdRate = 30;</span><br><span class="line">this-&gt;m_WeaponName = &quot;锋利匕首&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Knife::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Knife::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Knife::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Knife::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DragonSword::DragonSword()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 20;</span><br><span class="line">this-&gt;m_WeaponName = &quot;屠龙宝刀&quot;;</span><br><span class="line">this-&gt;BaceDef = 10;</span><br><span class="line">this-&gt;holdRate = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DragonSword::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DragonSword::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DragonSword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool DragonSword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Weapon::isTrigger(int rate)</span><br><span class="line">&#123;</span><br><span class="line">if (rate &gt;= rand() % 100 + 1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sword::Sword()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 20;</span><br><span class="line">this-&gt;m_WeaponName = &quot;倚天神剑&quot;;</span><br><span class="line">this-&gt;BaceDef = 10;</span><br><span class="line">this-&gt;suckRate = 10;</span><br><span class="line">this-&gt;holdRate = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sword::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sword::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Sword::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Sword::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shield::Shield()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 0;</span><br><span class="line">this-&gt;m_WeaponName = &quot;刑天巨盾&quot;;</span><br><span class="line">this-&gt;BaceDef = 70;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Shield::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Shield::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Shield::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Shield::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Spear::Spear()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 10;</span><br><span class="line">this-&gt;m_WeaponName = &quot;亮银长枪&quot;;</span><br><span class="line">this-&gt;BaceDef =20;</span><br><span class="line">this-&gt;suckRate = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Spear::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Spear::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Spear::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Spear::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bow::Bow()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 70;</span><br><span class="line">this-&gt;m_WeaponName = &quot;射日神弓&quot;;</span><br><span class="line">this-&gt;BaceDef = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bow::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Bow::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bow::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bow::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Book::Book()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 0;</span><br><span class="line">this-&gt;m_WeaponName = &quot;遁甲天书&quot;;</span><br><span class="line">this-&gt;BaceDef = 10;</span><br><span class="line">this-&gt;suckRate = 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Book::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Book::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Book::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Book::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fan::Fan()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_BaceDamage = 30;</span><br><span class="line">this-&gt;m_WeaponName = &quot;朱雀羽扇&quot;;</span><br><span class="line">this-&gt;BaceDef = 0;</span><br><span class="line">this-&gt;suckRate = 10;</span><br><span class="line">this-&gt;holdRate = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Fan::getBaceDamage()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;m_BaceDamage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Fan::getBaceDef()</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;BaceDef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Fan::getSuckBlood()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;suckRate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Fan::getHold()</span><br><span class="line">&#123;</span><br><span class="line">return isTrigger(this-&gt;holdRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hero.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&quot;Weapon.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class Hero &#123;</span><br><span class="line">public:</span><br><span class="line">Hero();</span><br><span class="line">int getHP();</span><br><span class="line">int getMP();</span><br><span class="line">int getAtk();</span><br><span class="line">int getDef();</span><br><span class="line">string getName();</span><br><span class="line">bool action();</span><br><span class="line">void getInf();</span><br><span class="line">void attack(Hero*hero);</span><br><span class="line">bool isRate(int rate);</span><br><span class="line">void init_property();</span><br><span class="line">virtual void skill(Hero * hero) = 0;</span><br><span class="line">virtual void passive_skill() = 0;</span><br><span class="line"></span><br><span class="line">bool isDeath;//是否死亡</span><br><span class="line"></span><br><span class="line">Weapon*weapon;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">int max_HP;</span><br><span class="line">int HP;//血量</span><br><span class="line">int MP;//蓝量</span><br><span class="line">int atk;//攻击力</span><br><span class="line">int def;//防御力</span><br><span class="line">int vel;//速度</span><br><span class="line"></span><br><span class="line">string name;//姓名</span><br><span class="line">string ctry;//国家</span><br><span class="line">int id;//编号</span><br><span class="line">string sex;//性别</span><br><span class="line">string skill_show;</span><br><span class="line">string skill_name;</span><br><span class="line"></span><br><span class="line">int wisdom;//智慧</span><br><span class="line">int strategy;//谋略</span><br><span class="line">int force;//力量</span><br><span class="line">int agility;//敏捷</span><br><span class="line"></span><br><span class="line">int crit;//暴击</span><br><span class="line">int stun;//重击</span><br><span class="line">int suckBlood;//回血</span><br><span class="line">int miss;//闪避</span><br><span class="line"></span><br><span class="line">bool isDiz;//眩晕</span><br><span class="line">bool isBleed;//流血</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Hero.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;hero.h&quot;</span><br><span class="line">#include &quot;Monster.h&quot;</span><br><span class="line">Hero::Hero()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_HP = 500;</span><br><span class="line">this-&gt;m_Atk = 50;</span><br><span class="line">this-&gt;m_Def = 50;</span><br><span class="line">this-&gt;m_Name = &quot;靓仔&quot;;</span><br><span class="line">this-&gt;weapon = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hero::EquipWeapon(Weapon * weapon)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;weapon = weapon;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;装备了&quot; &lt;&lt; this-&gt;weapon-&gt;m_WeaponName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Hero::Attack(Monster * monster)</span><br><span class="line">&#123;</span><br><span class="line">int damage = 0;</span><br><span class="line">int addHP = 0;</span><br><span class="line">bool isHold = false;</span><br><span class="line">bool isCrit = false;</span><br><span class="line">if (this-&gt;weapon == NULL) &#123;</span><br><span class="line">damage = this-&gt;m_Atk;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">damage = this-&gt;m_Atk + this-&gt;weapon-&gt;getBaceDamage();</span><br><span class="line">addHP = this-&gt;weapon-&gt;getSuckBlood();</span><br><span class="line">isHold = this-&gt;weapon-&gt;getHold();</span><br><span class="line">isCrit = this-&gt;weapon-&gt;getCrit();</span><br><span class="line">if (addHP) &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄触发吸血效果，回血&quot; &lt;&lt; addHP &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if (isCrit) &#123;</span><br><span class="line">damage *= 2;</span><br><span class="line">cout &lt;&lt; &quot;英雄触发暴击效果，怪兽受到双倍伤害&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if (isHold) &#123;</span><br><span class="line">monster-&gt;m_Hold = isHold;</span><br><span class="line">cout &lt;&lt; &quot;英雄触发定身效果，怪兽停止行动一回合&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">damage = damage &gt; monster-&gt;m_Def ? damage - monster-&gt;m_Def : 1;</span><br><span class="line">monster-&gt;m_HP -= damage;</span><br><span class="line">this-&gt;m_HP += addHP;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;对怪兽&quot; &lt;&lt; monster-&gt;m_Name &lt;&lt; &quot;造成了&quot; &lt;&lt; damage &lt;&lt; &quot;点伤害。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Country.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line">#include&quot;Wei.h&quot;</span><br><span class="line">#include&quot;Shu.h&quot;</span><br><span class="line">#include&quot;Wu.h&quot;</span><br><span class="line">#include&quot;Qun.h&quot;</span><br><span class="line">#define NUM_HERO 12</span><br><span class="line">class Wei&#123;</span><br><span class="line">public:</span><br><span class="line">Wei() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">wei[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Wei() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete wei[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*wei[NUM_HERO] = &#123;</span><br><span class="line">new(CaoCao),</span><br><span class="line">new(DianWei),</span><br><span class="line">new(XuChu),</span><br><span class="line">new(GuoJia),</span><br><span class="line">new(XiaHouDun),</span><br><span class="line">new(XiaHouYuan),</span><br><span class="line">new(CaoRen),</span><br><span class="line">new(ZhangLiao),</span><br><span class="line">new(SiMaYi),</span><br><span class="line">new(XuHuang),</span><br><span class="line">new(ZhenJi),</span><br><span class="line">new(CaiWenJi)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Shu&#123;</span><br><span class="line">public:</span><br><span class="line">Shu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">shu[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Shu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete shu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*shu[NUM_HERO] = &#123;</span><br><span class="line">new(LiuBei),</span><br><span class="line">new(GuanYu),</span><br><span class="line">new(ZhangFei),</span><br><span class="line">new(ZhuGeLiang),</span><br><span class="line">new(ZhaoYun),</span><br><span class="line">new(MaChao),</span><br><span class="line">new(HuangZhong),</span><br><span class="line">new(WeiYan),</span><br><span class="line">new(HuangYueYing),</span><br><span class="line">new(JiangWei),</span><br><span class="line">new(PangTong),</span><br><span class="line">new(SunShangXiang)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123;false&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Wu&#123;</span><br><span class="line">public:</span><br><span class="line">Wu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">wu[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Wu() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete wu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*wu[NUM_HERO] = &#123;</span><br><span class="line">new(SunCe),</span><br><span class="line">new(ZhouYu),</span><br><span class="line">new(SunQuan),</span><br><span class="line">new(DaQiao),</span><br><span class="line">new(XiaoQiao),</span><br><span class="line">new(HuangGai),</span><br><span class="line">new(TaiShiCi),</span><br><span class="line">new(GanNing),</span><br><span class="line">new(LuSu),</span><br><span class="line">new(LvMeng),</span><br><span class="line">new(ZhangZhao),</span><br><span class="line">new(ZhouTai)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Qun &#123;</span><br><span class="line">public:</span><br><span class="line">Qun() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">qun[i]-&gt;getInf();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Qun() &#123;</span><br><span class="line">for (int i = 0; i &lt; NUM_HERO; i++) &#123;</span><br><span class="line">if (!vis[i]) &#123;</span><br><span class="line">delete qun[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero*qun[NUM_HERO] = &#123;</span><br><span class="line">new(LvBu),</span><br><span class="line">new(DiaoChan),</span><br><span class="line">new(HuaTuo),</span><br><span class="line">new(YuanShao),</span><br><span class="line">new(YanLiang),</span><br><span class="line">new(WenChou),</span><br><span class="line">new(ZuoCi),</span><br><span class="line">new(HuaXiong),</span><br><span class="line">new(GongSunZan),</span><br><span class="line">new(ZhangJiao),</span><br><span class="line">new(YuJi),</span><br><span class="line">new(LingJu)</span><br><span class="line">&#125;;</span><br><span class="line">int vis[NUM_HERO] = &#123; false &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>User.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Country.h&quot;</span><br><span class="line">class User &#123;</span><br><span class="line">public:</span><br><span class="line">Hero * hero[5];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Play.h&quot;</span><br><span class="line">int main() &#123;</span><br><span class="line">play();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Play.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;Country.h&quot;</span><br><span class="line">#include&quot;User.h&quot;</span><br><span class="line">void test();</span><br><span class="line">void play();</span><br><span class="line">void show(User &amp;user);</span><br><span class="line">bool isDeath(User &amp; user);</span><br></pre></td></tr></table></figure><p><strong>Play.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;Play.h&quot;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">void test() &#123;</span><br><span class="line">Hero * hero_1 = new(ZhangFei);</span><br><span class="line">Hero *hero_2 = new(GuanYu);</span><br><span class="line"></span><br><span class="line">int round = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">getchar();</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl;</span><br><span class="line">hero_1-&gt;attack(hero_2);</span><br><span class="line">if (hero_2-&gt;getHP() &lt;= 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你赢了&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">hero_2-&gt;attack(hero_1);</span><br><span class="line">if (hero_1-&gt;getHP() &lt;= 0) &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你输了&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_1-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_2-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete(hero_1);</span><br><span class="line">delete(hero_2);</span><br><span class="line">&#125;</span><br><span class="line">void play() &#123;</span><br><span class="line">srand(time(NULL));</span><br><span class="line">User user_1;</span><br><span class="line">cout &lt;&lt; &quot;玩家一选择&quot; &lt;&lt; endl;</span><br><span class="line">show(user_1);</span><br><span class="line">User user_2;</span><br><span class="line">cout &lt;&lt; &quot;玩家二选择&quot; &lt;&lt; endl;</span><br><span class="line">show(user_2);</span><br><span class="line">int round = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">getchar();</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">if (!user_1.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">int Tmp = rand() % 5;</span><br><span class="line">while (user_2.hero[Tmp]-&gt;isDeath) &#123;</span><br><span class="line">if (isDeath(user_2)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">Tmp = rand() % 5;</span><br><span class="line">&#125;</span><br><span class="line">user_1.hero[i]-&gt;attack(user_2.hero[Tmp]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl;</span><br><span class="line">if (!user_2.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">int Tmp = rand() % 5;</span><br><span class="line">while (user_1.hero[Tmp]-&gt;isDeath) &#123;</span><br><span class="line">if (isDeath(user_1)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">Tmp = rand() % 5;</span><br><span class="line">&#125;</span><br><span class="line">user_2.hero[i]-&gt;attack(user_1.hero[Tmp]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if (isDeath(user_2)) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Victory！&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (isDeath(user_1)) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Defeat！&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">if (!user_1.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_1.hero[i]-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">if (!user_2.hero[i]-&gt;isDeath) &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_2.hero[i]-&gt;getHP() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool isDeath(User &amp; user) &#123;</span><br><span class="line">int cnt;</span><br><span class="line">for (cnt = 0; cnt &lt; 5; cnt++) &#123;</span><br><span class="line">if (!user.hero[cnt]-&gt;isDeath) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (cnt &gt;= 5) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">void show(User &amp;user)</span><br><span class="line">&#123;</span><br><span class="line">int flag;</span><br><span class="line">cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;请选择您的阵营&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;---&quot; &lt;&lt; &quot;1.魏----2.蜀----3.吴----4.群&quot; &lt;&lt; &quot;---&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;--------------&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; flag;</span><br><span class="line">int tmp[5];</span><br><span class="line">Wei *wei;</span><br><span class="line">Shu *shu;</span><br><span class="line">Wu *wu;</span><br><span class="line">Qun *qun;</span><br><span class="line">switch (flag) &#123;</span><br><span class="line">case 1:</span><br><span class="line">cout &lt;&lt; &quot;您已加入魏国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">wei = new Wei;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = wei-&gt;wei[tmp[i]-1];</span><br><span class="line">wei-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete wei;</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">cout &lt;&lt; &quot;您已加入蜀国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">shu = new Shu;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = shu-&gt;shu[tmp[i]-1];</span><br><span class="line">shu-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete shu;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">cout &lt;&lt; &quot;您已加入吴国阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">wu = new Wu;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = wu-&gt;wu[tmp[i]-1];</span><br><span class="line">wu-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete wu;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">cout &lt;&lt; &quot;您已加入群雄阵营，请选择5位武将&quot; &lt;&lt; endl;</span><br><span class="line">qun = new Qun;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp[i];</span><br><span class="line">user.hero[i] = qun-&gt;qun[tmp[i]-1];</span><br><span class="line">qun-&gt;vis[tmp[i]-1] = true;</span><br><span class="line">&#125;</span><br><span class="line">delete qun;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wei.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class CaoCao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">CaoCao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DianWei :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">DianWei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XuChu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XuChu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GuoJia : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GuoJia();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaHouDun : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XiaHouDun();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaHouYuan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XiaHouYuan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CaoRen : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">CaoRen();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangLiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangLiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SiMaYi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SiMaYi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XuHuang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XuHuang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhenJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhenJi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CaiWenJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">CaiWenJi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Wei.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Wei.h&quot;</span><br><span class="line"></span><br><span class="line">CaoCao::CaoCao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;曹操&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 92;//谋略</span><br><span class="line">force = 55;//力量</span><br><span class="line">agility = 28;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;天下归心&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoCao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoCao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;force;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DianWei::DianWei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;典韦&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 54;//智慧</span><br><span class="line">strategy = 32;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;古之恶来&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DianWei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DianWei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP = ceil(this-&gt;HP*1.4);</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;def += floor(this-&gt;force*0.7);</span><br><span class="line">this-&gt;atk = ceil(this-&gt;atk * 0.9);</span><br><span class="line">this-&gt;suckBlood += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XuChu::XuChu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;许褚&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 50;//智慧</span><br><span class="line">strategy = 20;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;虎痴卸甲&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuChu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuChu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk = floor(this-&gt;atk*1.3);</span><br><span class="line">this-&gt;crit += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GuoJia::GuoJia()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;郭嘉&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 100;//智慧</span><br><span class="line">strategy = 98;//谋略</span><br><span class="line">force = 5;//力量</span><br><span class="line">agility = 10;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;鬼才&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuoJia::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuoJia::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel += this-&gt;wisdom;</span><br><span class="line">this-&gt;stun += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaHouDun::XiaHouDun()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;夏侯惇&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 78;//智慧</span><br><span class="line">strategy = 56;//谋略</span><br><span class="line">force = 85;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouDun::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouDun::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk += 20;</span><br><span class="line">this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaHouYuan::XiaHouYuan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;夏侯渊&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 72;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 95;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouYuan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaHouYuan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel = ceil(this-&gt;vel*1.3);</span><br><span class="line">this-&gt;atk += this-&gt;strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaoRen::CaoRen()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;曹仁&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 77;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 72;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;无懈可击&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoRen::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaoRen::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += 2000;</span><br><span class="line">this-&gt;max_HP = HP;</span><br><span class="line">this-&gt;def = ceil(this-&gt;def*1.2);</span><br><span class="line">this-&gt;atk = floor(this-&gt;atk*0.4);</span><br><span class="line">this-&gt;suckBlood += 80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangLiao::ZhangLiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张辽&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 82;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 78;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangLiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangLiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;miss += 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SiMaYi::SiMaYi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;司马懿&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 99;//智慧</span><br><span class="line">strategy = 100;//谋略</span><br><span class="line">force = 34;//力量</span><br><span class="line">agility = 45;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;狼顾之相&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SiMaYi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SiMaYi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;agility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XuHuang::XuHuang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;徐晃&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 75;//智慧</span><br><span class="line">strategy = 82;//谋略</span><br><span class="line">force = 82;//力量</span><br><span class="line">agility = 75;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;兵粮寸断&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuHuang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XuHuang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk += this-&gt;force;</span><br><span class="line">this-&gt;stun += 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhenJi::ZhenJi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;甄姬&quot;;  //姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 25;//谋略</span><br><span class="line">force = 20;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;洛神降临&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhenJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhenJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;def += this-&gt;strategy * 0.5 + this-&gt;wisdom * 0.2;</span><br><span class="line">this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CaiWenJi::CaiWenJi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;蔡文姬&quot;;//姓名</span><br><span class="line">ctry = &quot;魏&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 95;//智慧</span><br><span class="line">strategy = 35;//谋略</span><br><span class="line">force = 25;//力量</span><br><span class="line">agility = 55;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;胡笳之音&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaiWenJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CaiWenJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;stun += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shu.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class LiuBei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LiuBei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GuanYu :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GuanYu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangFei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangFei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhuGeLiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhuGeLiang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhaoYun : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhaoYun();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MaChao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">MaChao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangZhong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuangZhong();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WeiYan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">WeiYan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangYueYing : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuangYueYing();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class JiangWei : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">JiangWei();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class PangTong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">PangTong();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SunShangXiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SunShangXiang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Shu.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Shu.h&quot;</span><br><span class="line"></span><br><span class="line">LiuBei::LiuBei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;刘备&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 72;//智慧</span><br><span class="line">strategy = 62;//谋略</span><br><span class="line">force = 60;//力量</span><br><span class="line">agility = 25;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;唯贤唯德&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LiuBei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LiuBei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GuanYu::GuanYu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;关羽&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 60;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;春秋偃月&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuanYu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GuanYu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangFei::ZhangFei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张飞&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 70;//智慧</span><br><span class="line">strategy = 77;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;雷霆咆哮&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangFei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangFei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk = floor(this-&gt;atk*0.9);</span><br><span class="line">this-&gt;crit += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZhuGeLiang::ZhuGeLiang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;诸葛亮&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 100;//智慧</span><br><span class="line">strategy = 100;//谋略</span><br><span class="line">force = 10;//力量</span><br><span class="line">agility = 32;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;卧龙啸天&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhuGeLiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhuGeLiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel += 50;</span><br><span class="line">this-&gt;atk += 50;</span><br><span class="line">this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhaoYun::ZhaoYun()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;赵云&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 75;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;七探蛇盘&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhaoYun::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;MP = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhaoYun::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;miss += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MaChao::MaChao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;马超&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 42;//智慧</span><br><span class="line">strategy = 20;//谋略</span><br><span class="line">force = 95;//力量</span><br><span class="line">agility = 94;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;西凉铁骑&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MaChao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MaChao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;vel *= 2;</span><br><span class="line">this-&gt;crit += 30;</span><br><span class="line">this-&gt;stun += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangZhong::HuangZhong()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;黄忠&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 50;//智慧</span><br><span class="line">strategy = 45;//谋略</span><br><span class="line">force = 98;//力量</span><br><span class="line">agility = 72;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;百步穿杨&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangZhong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangZhong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk += 20;</span><br><span class="line">this-&gt;stun += 50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WeiYan::WeiYan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;魏延&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 25;//智慧</span><br><span class="line">strategy = 75;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 75;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;傲骨风凉&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WeiYan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WeiYan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk *= 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangYueYing::HuangYueYing()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;黄月英&quot;;//姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 99;//智慧</span><br><span class="line">strategy = 90;//谋略</span><br><span class="line">force = 5;//力量</span><br><span class="line">agility = 65;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;奇门遁甲&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangYueYing::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangYueYing::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;def += 50;</span><br><span class="line">this-&gt;miss += 30;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JiangWei::JiangWei()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;姜维&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 92;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;幼麟之风&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JiangWei::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JiangWei::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PangTong::PangTong()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;庞统&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 94;//谋略</span><br><span class="line">force = 5;//力量</span><br><span class="line">agility = 18;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;火凤燎原&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PangTong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PangTong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;atk *= 1.2;</span><br><span class="line">this-&gt;vel *= 1.2;</span><br><span class="line">this-&gt;def *= 1.2;</span><br><span class="line">this-&gt;miss += 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SunShangXiang::SunShangXiang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;孙尚香&quot;;  //姓名</span><br><span class="line">ctry = &quot;蜀&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 56;//智慧</span><br><span class="line">strategy = 42;//谋略</span><br><span class="line">force = 65;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;枭姬联姻&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunShangXiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunShangXiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;miss += 20;</span><br><span class="line">this-&gt;stun += 20;</span><br><span class="line">this-&gt;atk += 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Wu.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class SunCe : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SunCe();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhouYu :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhouYu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SunQuan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">SunQuan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DaQiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">DaQiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class XiaoQiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">XiaoQiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuangGai : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuangGai();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TaiShiCi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">TaiShiCi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GanNing : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GanNing();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LuSu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LuSu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LvMeng : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LvMeng();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangZhao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangZhao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhouTai : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhouTai();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Wu.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Wu.h&quot;</span><br><span class="line"></span><br><span class="line">SunCe::SunCe()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;孙策&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 78;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 85;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;力拔山河&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunCe::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunCe::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;wisdom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhouYu::ZhouYu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;周瑜&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 98;//谋略</span><br><span class="line">force = 70;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;业火焚天&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouYu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouYu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SunQuan::SunQuan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;孙权&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 50;//力量</span><br><span class="line">agility = 60;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;气势汹汹&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunQuan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SunQuan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DaQiao::DaQiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;大乔&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 85;//智慧</span><br><span class="line">strategy = 45;//谋略</span><br><span class="line">force = 30;//力量</span><br><span class="line">agility = 75;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;国色天香&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DaQiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DaQiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XiaoQiao::XiaoQiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;小乔&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 40;//谋略</span><br><span class="line">force = 25;//力量</span><br><span class="line">agility = 85;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;玲珑之花&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaoQiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void XiaoQiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuangGai::HuangGai()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;黄盖&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 65;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 85;//力量</span><br><span class="line">agility = 35;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;苦肉之计&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangGai::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuangGai::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaiShiCi::TaiShiCi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;太史慈&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 70;//智慧</span><br><span class="line">strategy = 50;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;受宠打击&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaiShiCi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaiShiCi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GanNing::GanNing()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;甘宁&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 65;//智慧</span><br><span class="line">strategy = 75;//谋略</span><br><span class="line">force = 76;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;百骑袭营&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GanNing::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GanNing::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LuSu::LuSu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;鲁肃&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 90;//谋略</span><br><span class="line">force = 40;//力量</span><br><span class="line">agility = 60;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;大智若愚&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LuSu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LuSu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LvMeng::LvMeng()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;吕蒙&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;白衣渡江&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvMeng::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvMeng::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangZhao::ZhangZhao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张昭&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 95;//谋略</span><br><span class="line">force = 25;//力量</span><br><span class="line">agility = 55;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;制衡之道&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangZhao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangZhao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhouTai::ZhouTai()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;周泰&quot;;  //姓名</span><br><span class="line">ctry = &quot;吴&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 45;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 80;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Shield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouTai::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhouTai::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Qun.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&quot;Hero.h&quot;</span><br><span class="line"></span><br><span class="line">class LvBu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LvBu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DiaoChan :public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">DiaoChan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuaTuo : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuaTuo();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YuanShao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">YuanShao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YanLiang : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">YanLiang();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WenChou : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">WenChou();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZuoCi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZuoCi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HuaXiong : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">HuaXiong();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GongSunZan : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">GongSunZan();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ZhangJiao : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">ZhangJiao();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class YuJi : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">YuJi();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LingJu : public Hero &#123;</span><br><span class="line">public:</span><br><span class="line">LingJu();</span><br><span class="line">void skill(Hero * hero);</span><br><span class="line">void passive_skill();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Qun.cpp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Qun.h&quot;</span><br><span class="line"></span><br><span class="line">LvBu::LvBu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;吕布&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 1;//编号</span><br><span class="line">wisdom = 35;//智慧</span><br><span class="line">strategy = 10;//谋略</span><br><span class="line">force = 100;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;方天画斩&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvBu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LvBu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10;</span><br><span class="line">this-&gt;max_HP = this-&gt;HP;</span><br><span class="line">this-&gt;atk += this-&gt;agility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DiaoChan::DiaoChan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;貂蝉&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 2;//编号</span><br><span class="line">wisdom = 96;//智慧</span><br><span class="line">strategy = 60;//谋略</span><br><span class="line">force = 10;//力量</span><br><span class="line">agility = 100;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;闭月羞花&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DiaoChan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DiaoChan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuaTuo::HuaTuo()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;华佗&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 3;//编号</span><br><span class="line">wisdom = 80;//智慧</span><br><span class="line">strategy = 37;//谋略</span><br><span class="line">force = 60;//力量</span><br><span class="line">agility = 60;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;妙手回天&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaTuo::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaTuo::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YuanShao::YuanShao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;袁绍&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 4;//编号</span><br><span class="line">wisdom = 27;//智慧</span><br><span class="line">strategy = 20;//谋略</span><br><span class="line">force = 44;//力量</span><br><span class="line">agility = 55;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;万箭齐发&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Sword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuanShao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuanShao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YanLiang::YanLiang()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;颜良&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 5;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 60;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;致命一击&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YanLiang::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YanLiang::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WenChou::WenChou()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;文丑&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 6;//编号</span><br><span class="line">wisdom = 66;//智慧</span><br><span class="line">strategy = 66;//谋略</span><br><span class="line">force = 88;//力量</span><br><span class="line">agility = 88;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;暗箭难防&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Bow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WenChou::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WenChou::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZuoCi::ZuoCi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;左慈&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 7;//编号</span><br><span class="line">wisdom = 100;//智慧</span><br><span class="line">strategy = 90;//谋略</span><br><span class="line">force = 55;//力量</span><br><span class="line">agility = 20;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;道法自然&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZuoCi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZuoCi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HuaXiong::HuaXiong()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;华雄&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 8;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 67;//谋略</span><br><span class="line">force = 90;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;豪情万丈&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new DragonSword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaXiong::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HuaXiong::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GongSunZan::GongSunZan()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;公孙瓒&quot;;//姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 9;//编号</span><br><span class="line">wisdom = 60;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 80;//力量</span><br><span class="line">agility = 90;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;白马义从&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Spear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GongSunZan::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GongSunZan::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZhangJiao::ZhangJiao()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;张角&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 10;//编号</span><br><span class="line">wisdom = 45;//智慧</span><br><span class="line">strategy = 65;//谋略</span><br><span class="line">force = 55;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;天公降雷&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Fan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangJiao::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ZhangJiao::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">YuJi::YuJi()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;于吉&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;男&quot;;//性别</span><br><span class="line">id = 11;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 80;//谋略</span><br><span class="line">force = 40;//力量</span><br><span class="line">agility = 10;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;太平要术&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Book;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuJi::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void YuJi::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LingJu::LingJu()</span><br><span class="line">&#123;</span><br><span class="line">name = &quot;灵雎&quot;;  //姓名</span><br><span class="line">ctry = &quot;群&quot;;//国家</span><br><span class="line">sex = &quot;女&quot;;//性别</span><br><span class="line">id = 12;//编号</span><br><span class="line">wisdom = 90;//智慧</span><br><span class="line">strategy = 40;//谋略</span><br><span class="line">force = 60;//力量</span><br><span class="line">agility = 70;//敏捷</span><br><span class="line"></span><br><span class="line">skill_name = &quot;涅槃&quot;;</span><br><span class="line">skill_show = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">this-&gt;init_property();</span><br><span class="line">this-&gt;passive_skill();</span><br><span class="line">this-&gt;weapon = new Knife;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LingJu::skill(Hero * hero)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void LingJu::passive_skill()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;曾几何时，网页游戏风靡整个网络世界，然而手机游戏的出现，如今的网页游戏已经渐渐销声匿迹了。&lt;/p&gt;
&lt;p&gt;还记得我玩的第一款时间较长的网页游戏——龙将，如今服务器已关闭了，包括代理商“风行”如今也鲜为人知。其实那款游戏很简单，两个玩家对弈，双方每人出场5个英雄，按回合制以英
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="继承" scheme="http://qianyouyou.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="项目" scheme="http://qianyouyou.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="多态" scheme="http://qianyouyou.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>C++运算符重载之智能指针</title>
    <link href="http://qianyouyou.cn/2019/03/04/2019-03-04/"/>
    <id>http://qianyouyou.cn/2019/03/04/2019-03-04/</id>
    <published>2019-03-04T12:36:12.000Z</published>
    <updated>2019-04-27T15:39:41.127Z</updated>
    
    <content type="html"><![CDATA[<p>C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 </p><p>既然有了需求，对此，我们可以自行打造智能指针。</p><p>Person类有show_age()成员函数。</p><p>如果new出来的Person对象，那么必须由我们自行delete。</p><p>有了智能指针，就可以让智能指针托管这个对象，这个对象的释放就不用担心了，由智能指针自动进行管理。</p><p>为了让智能指针像普通指针一样方便实用，就要重载 -&gt; 与解引用 * 运算符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person():age(0)&#123;&#125;</span><br><span class="line">Person(int age):age(age)&#123;&#125;</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show_age() &#123;</span><br><span class="line">cout &lt;&lt; &quot;我的年龄是&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">SmartPointer():person(NULL)&#123;&#125;</span><br><span class="line">SmartPointer(Person*person) &#123;</span><br><span class="line">this-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">~SmartPointer() &#123;</span><br><span class="line">if (person != NULL) &#123;</span><br><span class="line">delete person;</span><br><span class="line">person = NULL;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;智能指针析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Person* operator -&gt;() &#123;</span><br><span class="line">return this-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; operator *() &#123;</span><br><span class="line">return *this-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">Person *person;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">//Person p1(10);</span><br><span class="line">//p1.show_age();</span><br><span class="line">//Person *p1 = new Person(10);</span><br><span class="line">//p1-&gt;show_age();</span><br><span class="line">//delete p1;</span><br><span class="line">SmartPointer sp(new Person(10));</span><br><span class="line">sp-&gt;show_age();</span><br><span class="line">(*sp).show_age();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="智能指针" scheme="http://qianyouyou.cn/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="重载" scheme="http://qianyouyou.cn/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://qianyouyou.cn/2019/02/28/2019-02-28/"/>
    <id>http://qianyouyou.cn/2019/02/28/2019-02-28/</id>
    <published>2019-02-28T09:58:51.000Z</published>
    <updated>2019-04-10T09:18:46.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="王-骏"><a href="#王-骏" class="headerlink" title="王    骏  "></a><center>王    骏</center><div style="float:right"> <img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/%E8%AF%81%E4%BB%B6%E7%85%A7.jpg" width="120"> </div></h3><center>邮箱：<a href="mailto:15249144478@163.com" target="_blank" rel="noopener">15249144478@163.com</a>        电话：152-0292-4489</center><h4 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h4><hr><div style="float:right">专  业：陕西科技大学/计算机科学与技术    </div>学  历：本科/2016.9<em>~</em>2020.6<br><br><div style="float:right">GitHub：<a href="http://github.com/qian-youyou" target="_blank" rel="noopener">http://github.com/qian-youyou</a></div>技术博客：<a href="http://qianyouyou.cn">http://qianyouyou.cn</a><br><br>#### 获奖经历<br><br>——<br><br>- 2018.11.25    <strong>亚洲区域赛铜奖</strong>    第43届ACM-ICPC国际大学生程序设计竞赛亚洲区域赛<br><br>     2018.06.10    全国邀请赛铜奖    第43届ACM-ICPC国际大学生程序设计竞赛全国邀请赛<br><br>     2018.04.01    省级二等奖        2018第九届蓝桥杯大赛<br><br>     2018.03.31    省级三等奖        团体程序设计天梯赛<br><br>     2018.03        校级二等奖        第4届陕西科技大学C语言大赛<br><br>     2018.11        校级三等奖         第5届陕西科技大学C语言大赛<br><br>#### 项目经验<br><br>——<br><br>##### 网络爬虫<div style="float:right">2017.11 ~ 2017.12</div><p>　　该项目主要建立中小型的文件分享站点，由学校外包项目小组负责。本人在项目小组内主要负责网络爬虫工作，利用Python的BeautifulSoup库抓取静态URL，爬取工标网上的信息到MySQL数据库。之后方便小组搭网站。</p><h4 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h4><hr><ul><li>语言：熟练使用C/C++进行项目开发，了解Python编程语言。<ul><li>熟悉C++封装，继承，多态等基础知识及应用，熟练使用STL库，掌握C++异常捕捉和处理。</li></ul></li><li>算法：擅长数据结构与算法优化，尤其擅长图论与数论算法分析。<ul><li>例如网络流(最大流，费用流等)，最短路SPFA+SLF与LLL优化，Dijkstra+heap优化，Tarjan算法，A*搜索，KM+slack优化，匈牙利算法+时间戳优化，KMP+Trie树，线段树，加权并查集，矩阵快速幂等。</li></ul></li><li>系统：熟悉Linux操作系统， 了解Linux环境下编程及进程间通信，多线程编程。 </li><li>网络：具有网络基础知识， 熟悉TCP/IP协议，了解Socket网络编程。 </li><li>前端：熟悉HTML5、CSS等前端语言，能够独立制作静态网页。</li><li>其他：了解MySQL基本操作。熟悉Git使用。</li></ul><h5 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h5><p>一个爱学习，知上进，善总结，重思考，懂感恩的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;王-骏&quot;&gt;&lt;a href=&quot;#王-骏&quot; class=&quot;headerlink&quot; title=&quot;王    骏  &quot;&gt;&lt;/a&gt;&lt;center&gt;王    骏&lt;/center&gt;&lt;div style=&quot;float:right&quot;&gt; &lt;img src=&quot;https://qiany
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[设计模式]单例模式案例之打印机案例</title>
    <link href="http://qianyouyou.cn/2019/02/27/2019-02-27/"/>
    <id>http://qianyouyou.cn/2019/02/27/2019-02-27/</id>
    <published>2019-02-27T10:41:14.000Z</published>
    <updated>2019-04-27T15:38:58.369Z</updated>
    
    <content type="html"><![CDATA[<p>当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模式的案例，比如一个国家只有一个主席，即使主席替换，依然只有一个主席。比如某个教室只有一台打印机，那么无论多少人需要使用打印机，都将只能使用这一台打印机。也就是说该对象有且只能创建一个。</p><p>接下来我们总结一下单例模式的流程：</p><p>1.目的让类中只有一个对象，对象不需要自己释放。</p><p>2.将默认构造函数与拷贝构造函数私有化。</p><p>3.内部维护一个对象指针。</p><p>4.私有化唯一指针。</p><p>5.对外提供方法访问该指针。</p><p>6.保证了类中只能实例化唯一对象。</p><p>我们以打印机为例，某教室只有一台打印机，该打印机一次只能供一个人使用。</p><p>我们先来分析打印机，打印机具有打印功能，具有启动功能，具有关闭功能。而且具有一次只能供一人使用的特性，因此创建类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">static PrintingPress*getInstance() &#123;</span><br><span class="line">return unique;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">void openPrinting() &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void closePrinting() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void usingPrinting(string str) &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress() &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">static PrintingPress* unique;</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br></pre></td></tr></table></figure><p>用户具有使用打印机打印内容的功能，具有关闭打印机的功能，具有打开打印机的功能。因此创建用户类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">void us() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void us(string str) &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void op() &#123;</span><br><span class="line">if (p-&gt;check() == false) &#123;</span><br><span class="line">p-&gt;openPrinting();</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cl() &#123;</span><br><span class="line">if (flag = true) &#123;</span><br><span class="line">p-&gt;closePrinting();</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下代码是用C++写的一个简单的打印机案例测试代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#define CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">static PrintingPress*getInstance() &#123;</span><br><span class="line">return unique;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">void openPrinting() &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void closePrinting() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void usingPrinting(string str) &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress() &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">static PrintingPress* unique;</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">void us() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void us(string str) &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void op() &#123;</span><br><span class="line">if (p-&gt;check() == false) &#123;</span><br><span class="line">p-&gt;openPrinting();</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cl() &#123;</span><br><span class="line">if (flag = true) &#123;</span><br><span class="line">p-&gt;closePrinting();</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">user tmp[3];</span><br><span class="line">tmp[1].op();</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[1].us(&quot;lalalalala&quot;);</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[1].cl();</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[2].us(&quot;22222222&quot;);</span><br><span class="line">tmp[2].cl();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="设计模式" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="设计模式" scheme="http://qianyouyou.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://qianyouyou.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[转]const指针与指向const的指针</title>
    <link href="http://qianyouyou.cn/2019/02/23/2019-02-23/"/>
    <id>http://qianyouyou.cn/2019/02/23/2019-02-23/</id>
    <published>2019-02-23T08:55:36.000Z</published>
    <updated>2019-04-27T15:38:37.455Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~</p><p><strong>const指针的定义：</strong></p><p>　　const指针是指针变量的值一经初始化，就不可以改变指向，初始化是必要的。其定义形式如下：</p><p>type *const 指针名称;</p><p>　　声明指针时，可以在类型前或后使用关键字const，也可在两个位置都使用。例如，下面都是合法的声明，但是含义大不同：</p><p>const int * pOne;    //指向<strong>整形常量</strong> 的指针，它指向的值不能修改</p><p>int * const pTwo;    //指向整形的<strong>常量指针</strong> ，它不能在指向别的变量，但指向（变量）的值可以修改。 </p><p>const int *const pThree;  //指向<strong>整形常量</strong> 的<strong>常量指针</strong> 。它既不能再指向别的常量，指向的值也不能修改。</p><p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。下面的代码有助于说明这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int *p1;  //the int pointed to is constant</span><br><span class="line"></span><br><span class="line">int * const p2; // p2 is constant, it can&apos;t point to anything else</span><br></pre></td></tr></table></figure><p><strong>const指针和const成员函数</strong></p><p>可以将关键字用于成员函数。例如：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pubilc:</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        void SetLength(int length)&#123;itslength = length;&#125;</span><br><span class="line"></span><br><span class="line">        int GetLength() const &#123;return itslength;&#125;  //成员函数声明为常量</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">     private:</span><br><span class="line"></span><br><span class="line">        int itslength;</span><br><span class="line"></span><br><span class="line">        int itswidth;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>当成员函数被声明为const时，如果试图修改对象的数据，编译器将视为错误。</p><p>如果声明了一个指向const对象的指针，则通过该指针只能调用const方法（成员函数）。</p><p>示例声明三个不同的Rectangle对象：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle* pRect = new Rectangle;</span><br><span class="line"></span><br><span class="line">const Rectangle * pConstRect = new Rectangle;     //指向const对象</span><br><span class="line"></span><br><span class="line">Rectangle* const pConstPtr = new Rectangle;</span><br><span class="line"></span><br><span class="line">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="const指针和指向const的指针"><a href="#const指针和指向const的指针" class="headerlink" title="const指针和指向const的指针"></a>const指针和指向const的指针</h1><p>当使用带有const的指针时其实有两种意思。一种指的是你不能修改指针本身的内容，另一种指的是你不能修改指针指向的内容。听起来有点混淆一会放个例子上来就明白了。<br>      先说指向const的指针，它的意思是指针指向的内容是不能被修改的。它有两种写法。<br>      const int<em> p; （推荐）<br>      int const</em> p;<br>      第一种可以理解为，p是一个指针，它指向的内容是const int 类型。p本身不用初始化它可以指向任何标示符，但它指向的内容是不能被改变的。<br>      第二种很容易被理解成是p是一个指向int的const指针（指针本身不能被修改），但这样理解是错误的，它也是表示的是指向const的指针（指针指向的内容是不能被修改的），它跟第一种表达的是一个意思。为了避免混淆推荐大家用第一种。<br>      再说const指针，它的意思是指针本身的值是不能被修改的。它只有一种写法<br>      int<em> const p=一个地址; (因为指针本身的值是不能被修改的所以它必须被初始化）<br>      这种形式可以被理解为，p是一个指针，这个指针是指向int 的const指针。它指向的值是可以被改变的如</em>p=3;<br>      还有一种情况是这个指针本身和它指向的内容都是不能被改变的，请往下看。<br>      const int<em> const p=一个地址;<br>      int const</em> const p=一个地址;<br>      看了上面的内容是不是有点晕，没关系，你不用去背它，用的多了就知道了，还有个技巧，通过上面的观察我们不难总结出一点规律，是什么呢？这个规律就是： 指向const的指针（指针指向的内容不能被修改）const关健字总是出现在<em>的左边而const指针（指针本身不能被修改）const关健字总是出现在</em>的右边，那不用说两个const中间加个*肯定是指针本身和它指向的内容都是不能被改变的。有了这个规则是不是就好记多了。</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Code highlighting produced by Actipro CodeHighlighter (freeware)http://www.CodeHighlighter.com/--&gt; 1 #include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a=3;</span><br><span class="line">    int b;</span><br><span class="line">    </span><br><span class="line">    /*定义指向const的指针（指针指向的内容不能被修改）*/ </span><br><span class="line">    const int* p1; </span><br><span class="line">    int const* p2; </span><br><span class="line">    </span><br><span class="line">    /*定义const指针(由于指针本身的值不能改变所以必须得初始化）*/ </span><br><span class="line">    int* const p3=&amp;a; </span><br><span class="line">    </span><br><span class="line">    /*指针本身和它指向的内容都是不能被改变的所以也得初始化*/</span><br><span class="line">    const int* const p4=&amp;a;</span><br><span class="line">    int const* const p5=&amp;b; </span><br><span class="line">    </span><br><span class="line">     p1=p2=&amp;a; //正确</span><br><span class="line">     *p1=*p2=8; //不正确（指针指向的内容不能被修改）</span><br><span class="line">    </span><br><span class="line">     *p3=5; //正确</span><br><span class="line">     p3=p1; //不正确（指针本身的值不能改变） </span><br><span class="line">    </span><br><span class="line">     p4=p5;//不正确 （指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     *p4=*p5=4; //不正确（指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>const用法小结：</strong><br>const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。<br>\1. const修饰函数的参数<br>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。<br>const 只能修饰输入参数：<br>如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。<br>将“const &amp;”修饰输入参数的用法总结如下：<br>(1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。<br>(2)对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。</p><p>\2. const 修饰函数的返回值<br>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数<br>const char <em> GetString(void);<br>如下语句将出现编译错误：<br>char </em>str = GetString();<br>正确的用法是<br>const char *str = GetString();<br>如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。<br>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。<br>例如：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">A &amp; operate = (const A &amp;other); // 赋值函数</span><br><span class="line">&#125;;</span><br><span class="line">A a, b, c; // a, b, c 为A 的对象</span><br><span class="line">a = b = c; // 正常的链式赋值</span><br><span class="line">(a = b) = c; // 不正常的链式赋值，但合法</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p><p>\3. const修饰成员函数<br>关于Const函数的几点规则：<br>a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.<br>b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.<br>c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.<br>d. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</p><p>　　版权所有，转载请注明转载地址：<a href="http://www.cnblogs.com/lihuidashen/p/4378884.html" target="_blank" rel="noopener">http://www.cnblogs.com/lihuidashen/p/4378884.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const指针的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　const指针是指针变量的值一经初始化，就不可以改变指向
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="const" scheme="http://qianyouyou.cn/tags/const/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
