<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2020-01-23T05:16:15.391Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在山的那边，还是山</title>
    <link href="http://qianyouyou.cn/2020/01/23/2020-01-23/"/>
    <id>http://qianyouyou.cn/2020/01/23/2020-01-23/</id>
    <published>2020-01-23T04:22:37.000Z</published>
    <updated>2020-01-23T05:16:15.391Z</updated>
    
    <content type="html"><![CDATA[<p>人生天地间，忽如远行客。人从诞生起，便是一场走向死亡的旅程。，我们别无选择的被命运推着向前走，不能回头。虽然人生这场旅程中，我们没办法回头，但是上帝赋予了我们每个人选择的权利。尽管每个人会走向同样的终点，但每个人都身处不同的起点，拥有自己道路的选择权，这就注定了每个人在旅程中会遇到不一样的风景。</p><p>有人说，我们降临到世上，要么是疯子，要么是傻子。疯子风雨兼程，义无反顾；傻子知足常乐，安之若素。其实这话说的也不错，就像人生的分岔路口上，都会有崎岖的山路，也会有平稳的坦途。选择山路，比较辛苦，随时都有跌落山谷的危险，但沿途能欣赏广阔的风景；选择坦途，比较轻松，不用思考任何风险，但也失去了广阔的风景。就像每个人都会问自己，是想成为马云，还是想成为佛祖。每个人都会有自己的选择，谁也没有资格评论其他人的选择，唯一能做的，就是不忘初心，坚持自己的选择。</p><p>我时常会问自己，究竟是选择山路，还是选择坦途。很多时候，我都会犹豫不决，一方面是对挫折的恐惧，一方面又不甘于碌碌无为。但这个时候，上帝总会帮我寻找心中所向往的那片风景。秋招时，因为恐惧面试，而草草的签了三方协议。尽管薪资达不到自己的预期，但还是选择了安稳。本以为从此之后便再也没办法回头，但还是遇到了人生的伯乐，经过心理上克服面试的恐惧，最终成功签约自己心仪的公司。</p><p>当我们历经磨难，踏上山巅时，已经欣赏到了更远阔的风景，也收获了沿途克服崎岖的喜悦。但我们的人生没有暂停键，也没有后退键。这时候，我们依旧要向前走，但当我们到达一座山顶时，四周的路只能向下。而山那边，依然是山。我们别无选择继续跨越前方的山。就像我，因为签约了新的公司，必须想办法解约三方协议，而我们作为违约的一方，就必须承担责任，想获得学校一方的同意挺难，因为有很多流程，谁也不想自己太麻烦；以前的公司不会简简单单的帮助我们违约，违约不违约都是要交违约金，而且没违约成功，未来在旧公司里也会备受排挤。而此刻的我，没有回头路，只能继续向前。</p><p>当我们选择山路时，往往也会向往安稳的坦途，但身在山路，稍不留神便会跌落谷底。与其后悔，不妨继续享受这沿途的风景。我们之所以害怕山路，其实是对挫折的恐惧。就像我对与学校和公司违约谈判的恐惧，对这个过程中可能遇到的各种麻烦一样。但是任何没有打倒我们的力量，只能让我们的内心变得更强大。因此，此刻正望着另一座山的我，定要把挫折当做使自己变得强大的力量，战胜恐惧，欣赏风景，坚定向前。就像汪国真《热爱生命》中写的那样：</p><p>我不去想是否能够成功<br>既然选择了远方<br>便只顾风雨兼程</p><p>我不去想能否赢得爱情<br>既然钟情于玫瑰<br>就勇敢地吐露真诚</p><p>我不去想身后会不会袭来寒风冷雨<br>既然目标是地平线<br>留给世界的只能是背影</p><p>我不去想未来是平坦还是泥泞<br>只要热爱生命<br>一切，都在意料之中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人生天地间，忽如远行客。人从诞生起，便是一场走向死亡的旅程。，我们别无选择的被命运推着向前走，不能回头。虽然人生这场旅程中，我们没办法回头，但是上帝赋予了我们每个人选择的权利。尽管每个人会走向同样的终点，但每个人都身处不同的起点，拥有自己道路的选择权，这就注定了每个人在旅程
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>爱你所爱，行你所行，听从你心，无问西东</title>
    <link href="http://qianyouyou.cn/2019/12/17/2019-12-17/"/>
    <id>http://qianyouyou.cn/2019/12/17/2019-12-17/</id>
    <published>2019-12-17T13:34:08.000Z</published>
    <updated>2019-12-17T15:57:46.511Z</updated>
    
    <content type="html"><![CDATA[<p>对于这部电影，早有耳闻，毕竟王菲的《无问西东》与毛不易的《无问》都是我时常聆听的歌。只是不知何时起，被生活中的各种琐事困扰，渐渐地，失去了对美好世界的向往，以及静下心来欣赏好电影的热忱。正在迷茫之际，所幸遇到这部电影以及它所传达的救赎之道，又点亮了我内心所向往的那道光。</p><p>影片分为了四个小故事，背景分别在当代，文革时代，战火时代，以及那个咆哮的时代。通过职场，爱情，家国，自我救赎，四个主题，以救赎为牵引线，化作了一个故事，共同传达了爱与传承的主旨。</p><p>电影首先讲述的是生活在当代尔虞我诈的职场，每天愁眉苦脸的男主张果果，因为上司的设计而背黑锅被迫离职。在新的公司里，因为看到曾经能帮助而未尽力帮助的四胞胎家庭如今生活落魄，决定通过事业帮助这个家庭。在医院看望四胞胎婴儿时，他向婴儿家人承诺会争取四胞胎的手术费。而在对他们提供帮助后，前公司的老总告诉他一些过往的经历劝他小心。他开始怀疑四胞胎的家人从此以后赖上了他。而同时老总给男主提供了一个揭发曾经算计他的上司丑陋罪行的机会。面对心中善恶的审批，男主该如何回应呢。</p><p>第二个故事发生在文革前。黄晓明饰演的陈鹏是一个大学的优等生，章子怡饰演的王敏佳与铁政饰演的李想则是医学院的一个学生，三人从小便是相依相伴的孤儿。陈鹏一直喜欢着王敏佳，原本打算为爱放弃事业时，却看到王敏佳和李想两个人暧昧，选择了离开。王敏佳和李想看到师母殴打恩师，写信为恩师打抱不平，却遭到师母的告状。面对李想的前程，王敏佳选择独自承担，却遭到了各个阶级莫须有的罪名，李想自始至终选择沉默。最终在批判大会上含冤死去。</p><p>第三个故事讲述的是飞行家的故事，王力宏饰演的沈光耀原本是富家子弟，文武兼备，因为一腔热血，报名空军，却遭到家人的反对，最终选择放下功名，安之若素。之后却看着日军狂轰乱炸，在国与家的面前，他该何去何从。</p><p>第四个故事比较简单，由陈楚生饰演的吴岭澜国学与英语成绩优异，然而当时正值实业救国思潮，本是文科好苗子的他选择了理工科，然而却因物理成绩垫底被迫重新作出选择。对于自己所擅长的文科与实用的理科，他该如何选择。</p><p>最终，吴岭澜听了泰戈尔的演讲，明白了那些伟人以及引领时代的人其实不一定都是实业家，他们其实时时刻刻都在对生命的价值进行思索。最终他毅然遵从内心，选择了文科，从此当一名教师，传道受业解惑。</p><p>而正是吴岭澜的几句话，影响了沈光耀，在日军轰炸同胞，战火迷离之际，他选择了当一名飞行员，为保家卫国献上了自己最绚烂的青春。 在他执行飞行任务时，总不忘将食物从空中撒向贫民区。从自己的村子，到飞机途径的各个村子，都有他所传递的那份爱。</p><p>正因为沈光耀的选择，才救助了陈鹏他们所在的村子，造就了陈鹏一村人感恩的心。最终陈鹏为爱返乡，将濒死的王敏佳带回村子，托付给村子救助。因为陈鹏的守护，王敏佳才有了生的希望。</p><p>在陈鹏的感染下，李想最终在大雪纷飞的雪地里将食物留给了素不相识的张果果的父母，最终自己却冻死了。而每年，张果果一家不管多忙碌，总会在清明节那天去为李想扫墓。正是因为这份爱与传递，最终感染了张果果，他最终洗涤了心中世俗化的感染，无偿为四胞胎的父母提供了住所与工作，也主动选择放弃揭发曾经算计自己的上司。</p><p>满怀热忱的我们，无可避免都得经受现实的洗礼。</p><p>还记得王敏佳在批判大会上的那抹笑容。当她环顾四周，心中所盼望的两个男人统统不在，周围全是乌合之众的谩骂，她笑了。正是因为这一抹笑，引来了群众的不满，由谩骂变成了毒打，使王敏佳付出自己的生命。看到这里，我首先想到的是《鬼子来了》中，姜文最后人头落地时的仰天长笑。那三声长笑，看似荒诞，但正是在嘲讽这荒诞的世界，这没有正义，只有灰色的世界。</p><p>在理想与现实的十字路口上，我们该何去何从。</p><p>影片中，张果果和老总形成了鲜明的对比，是理想与现实的对比。老总在抱怨他曾经帮助过的孩子最终却向自己要房子要工作，而张果果听了老总的劝告，经历了思想斗争之后，却选择主动为四胞胎家庭提供住所与工作。看到这里，我想到了《我不是药神》中程勇由最初为了利益卖药到最后以德报怨主动倒贴钱卖药给穷人的转变。这是一种救赎。能力越大，责任就越大。张果果身为广告公司总监，主动选择将爱传递给那些需要帮助的人，这也是一种救赎。但我们也不能全怪老总，毕竟老总曾经也想过帮助别人，只是没有坚持下去，他所得到的是社会的一次鞭挞，从此被世俗同化，做一条狼。在理想与现实的十字路口，多少人因为社会的一次次的鞭挞而选择向现实妥协，将中心转向了自我，而又有几个人会像道成肉身的耶稣那样以德报怨，选择自己被钉上十字架来替世人赎罪呢。</p><p>当我们选择负重前行时，谁来为我们护航呢。</p><p>在王敏佳环顾四周，心中充满期盼，却又孤立无援的时候，我又想到了《闻香识女人》，查理在遭到同学的冷眼旁观与学校的威逼利诱之时，在自己的前途与心中的道义选择之时，遵从内心，坚守正义与准则。但不同于查理，查理在被勒令退学，心中充满迷茫之时，有老中校的保护，而王敏佳此刻却一无所有。这让我不禁感叹，其实我们每个人都曾满怀热忱选择拥抱这世界，但当我们被这灰色社会各种折磨之时，谁来像老中校那样保护我们的坚守呢。最终大部分人都被这社会所同化，变成了自己曾经最讨厌的那种人。影片毕竟不是悲剧，所幸剧情最终安排陈鹏回到了王敏佳身边，守护王敏佳对这世界最后的一丝好感。</p><p>每个人都认为自己是对的，因此我们需要成长。</p><p>沈光耀原本是富家子弟，却选择当一名飞行员保家卫国，同时救济贫民。但刚开始时，他每次都是擅自开飞机为自己学校所在的村子送食物。他的上司罚他，同时也道出了原因，他这样做，看似义举，但每次同样的路线，只会引来敌人的追踪，最终导致村子遭到敌人的狂轰乱炸。看到这里，我不仅揪起了心。我们每个人其实刚开始时都认为自己是对的，就像王敏佳只看到了师母殴打恩师的表象，却忽略了恩师对师母的冷落，因此她将师母抹黑，遭到师母的告发。而同样因为师母的一句话，群众们又谩骂变成毒打，险些让王敏佳丧命。显然，师母当时因为嫉妒与愤怒，导致一个人前程与生命被毁。她其实也是无心之过，也是被这世界摧残的遍体鳞伤，不然也不会在最后在内疚与绝望中选择跳井自杀。有时候，我们自己的一点点微不足道的私欲或自以为是的正义可能会给其他人带来不可弥补的伤害。</p><p>成长中的负重前行，方得始终。</p><p>最终沈光耀的故事算是最完美的结局。他后来不断改变路线，给村子驱赶饥饿的同时保证了村子的安全。同时，将小义变成了大义，所到之处都有他的带来的食物。人们亲切地称他为晃晃叔叔。</p><p>当影片《奇异恩典》想起，我便明白，正值迷茫之际，此电影以救赎之道，为我曾经人生十字路口的选择保驾护航。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于这部电影，早有耳闻，毕竟王菲的《无问西东》与毛不易的《无问》都是我时常聆听的歌。只是不知何时起，被生活中的各种琐事困扰，渐渐地，失去了对美好世界的向往，以及静下心来欣赏好电影的热忱。正在迷茫之际，所幸遇到这部电影以及它所传达的救赎之道，又点亮了我内心所向往的那道光。&lt;/
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="影评" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E5%BD%B1%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>中国没有汉尼拔</title>
    <link href="http://qianyouyou.cn/2019/12/09/2019-12-09/"/>
    <id>http://qianyouyou.cn/2019/12/09/2019-12-09/</id>
    <published>2019-12-09T12:01:10.000Z</published>
    <updated>2019-12-09T13:29:00.200Z</updated>
    
    <content type="html"><![CDATA[<p>每个人生下来便是羔羊，由牧民圈养着。牧民们为羊儿们提供丰厚的草料，但当它们的毛丰厚了便拔他们的毛，当它们的肉肥了便割他们的肉。有些羊不断提升自己的生产能力，逃出了羊圈，自力更生，从此遭到牧民以及其他羔羊的唾弃；有些羊努力进化成了野牛，起初野牛会保护羊群，但那些曾经意气风发的野牛们最终收获足够多的羔羊认同时，便会变成野牛比尔，同牧民合作，一起宰羊。而大部分的羊，为了一时安稳，看着同类的种种变化，不理不睬，久而久之便成了沉默的羔羊。</p><p>常常在耳边听到这样的说法：“如果每个人给我一毛，那我就是亿万富翁。”其实说到底，每个人都懂这一点，关键是如何让别人拔毛给你，而且是每个人。每当听到这样的话，我心中的暗自嘲讽，幸好有个如果，因为当你真的能让所有人给你一毛时，你变会想每人给你更多。</p><p>还记得《美国往事》中工人运动的领袖吉米掌权后的腐败嘴脸。那些曾经意气风发的企业家们，用各种福利拉拢用户，挽留用户，就像拼多多……然而不是所有私企都能挽留住用户，就像共享单车……最终收获足够多的用户量时，便同国企合作，让你们离不开他们，还得乖乖拔毛给他们，就像腾讯……</p><p>曾经意气风发的马云说过，他创立阿里巴巴就是让那些坐在移动、银行办公室里的人不得安宁。的确，他做到了，也成为了第一个汉尼拔。然而，伴随着的退休，谁也说不清楚什么情况。那个汉尼拔只剩传说了，每个想成为汉尼拔的人最终却变成了野牛比尔。</p><p>最近移动20周年庆典，然而却是变了花样的让用户交钱。当客服给用户打电话说庆典时，本以为是福利回馈，没想到又是变了花样的敲诈。这就是和某些私企的差别，私企通常庆典上各种福利回馈用户，国企反而再敲用户一下。</p><p>可笑的是每次私企出了问题用户各种骂，国企的话早已麻木了。就像曾经丰巢的1块钱事件。然而因1块钱声讨丰巢，却没人反映移动几十块的敲诈，这不是很讽刺吗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个人生下来便是羔羊，由牧民圈养着。牧民们为羊儿们提供丰厚的草料，但当它们的毛丰厚了便拔他们的毛，当它们的肉肥了便割他们的肉。有些羊不断提升自己的生产能力，逃出了羊圈，自力更生，从此遭到牧民以及其他羔羊的唾弃；有些羊努力进化成了野牛，起初野牛会保护羊群，但那些曾经意气风发的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈构造函数</title>
    <link href="http://qianyouyou.cn/2019/10/21/2019-10-21/"/>
    <id>http://qianyouyou.cn/2019/10/21/2019-10-21/</id>
    <published>2019-10-20T23:36:23.000Z</published>
    <updated>2019-10-20T23:57:43.089Z</updated>
    
    <content type="html"><![CDATA[<p>说道构造函数，大家可能都不陌生，但构造函数到底是什么作用呢。这个问题就好像我们大家都会用C++，但没几人敢说自己精通C++一样。我们先来看一看最简单的例子吧。</p><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><p>已知类a继承类b且包含类c，求a，b，c的构造顺序。</p><h3 id="answer"><a href="#answer" class="headerlink" title="answer"></a>answer</h3><p>b &gt; c &gt; a</p><p>这个答案大家肯定知道，但为什么呢，对于该问题一般那些资深C++开发者一眼就能看出你是有自己的理解还是书本式的记忆，因此不要试图用书本式的解释。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>其实构造函数也没那么神秘，就是用来初始化数据，为对象的创建做准备的。这不废话么。有了这个认识，那为什么上面是bca，而不是其他顺序呢。好像没什么必然的联系。但是，以初始化为主的构造函数，那没有数据的话怎么初始化数据呢。因此，a包含c，那么c就是a数据的一部分，没有c的话a就无法初始化。因此c &gt; a。a继承于b，子类和父类的关系根据名称也知道，子类继承了父类的数据，父类也是子类的一部分，因此b &gt; a。abc这三者的关系就好似儿子、父亲和儿子的细胞。没有父亲，就没有儿子的全部，自然也没有儿子的细胞。所以答案自然而然。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>直接初始化&gt;初始化列表&gt;构造函数</p><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>在C++11特性中，出现了RAII的思想，就是构造中分配内存，析构中释放内存。这也是智能指针保证安全性的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说道构造函数，大家可能都不陌生，但构造函数到底是什么作用呢。这个问题就好像我们大家都会用C++，但没几人敢说自己精通C++一样。我们先来看一看最简单的例子吧。&lt;/p&gt;
&lt;h2 id=&quot;question&quot;&gt;&lt;a href=&quot;#question&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="构造函数" scheme="http://qianyouyou.cn/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS分布式文件系统总结</title>
    <link href="http://qianyouyou.cn/2019/10/03/2019-10-03/"/>
    <id>http://qianyouyou.cn/2019/10/03/2019-10-03/</id>
    <published>2019-10-03T04:36:04.000Z</published>
    <updated>2019-10-03T07:35:21.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h1><p>首先，什么是分布式存储，简而言之，就是将数据存储到多个存储设备（服务器）上。</p><h2 id="分布式与传统网络存储系统区别"><a href="#分布式与传统网络存储系统区别" class="headerlink" title="分布式与传统网络存储系统区别"></a>分布式与传统网络存储系统区别</h2><p>传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-10-03-%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt=""></p><p>分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-10-03-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt=""></p><h1 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h1><p>FastDFS是一款开源的分布式文件系统，通过纯C实现，支持Linux, FreeBSD等Unix系统类Google FS, 不是通用的文件系统，只能够通过专有API访问，目前提供了C，Java和PHP API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性 FastDFS可以看做是基于文件的key-value存储系统，称为分布式文件存储服务更为合适。</p><p>功能包括：文件存储、文件同步、文件访问（文件上传、文件下载、文件删除）等，解决了大容量存储和负载均衡的问题。</p><ul><li><p>为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标</p></li><li><p>可以很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p><ul><li>图片服务器</li><li>图床</li></ul></li></ul><ol><li><p>fastDFS特点:</p></li><li><ul><li>应用层级的文件系统</li><li>不能挂载和卸载，也就是不能进行mount操作</li></ul></li><li><p>fastDFS框架中的三个角色</p></li><li><ul><li>追踪器 - tracker</li><li>存储节点 - storage</li></ul></li><li><ul><li>客户端 - client</li></ul></li><li><p>fastDFS三个角色之间的关系</p></li><li><ul><li><p>Client和Storage主动连接Tracker。</p></li><li><p>Storage主动向Tracker报告其状态信息</p><ul><li>磁盘剩余空间</li><li>文件同步状况</li><li>文件上传下载次数</li></ul></li><li><p>Storage会启动一个单独的线程来完成对一台Tracker的连接和定时报告。</p></li><li><p>一个组包含的Storage不是通过配置文件设定的，而是通过Tracker获取到的。</p></li></ul></li></ol><h2 id="FastDFS集群"><a href="#FastDFS集群" class="headerlink" title="FastDFS集群"></a>FastDFS集群</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-10-03-Fast%E9%9B%86%E7%BE%A4.png" alt=""></p><ol><li><p>Tracker集群</p></li><li><ul><li>Tracker server之间是相互平等关系同时提供服务</li><li>Tracker server不存在单点故障。</li><li>客户端请求Tracker       server采用轮询方式，如果请求的tracker无法提供服务则换另一个tracker。</li></ul></li><li><p>Storage集群</p></li><li><ul><li>Storage集群采用了分组存储方式, 由一个或多个组构成</li><li>集群存储总容量为集群中所有组的存储容量之和</li><li>一个组由一台或多台存储服务器组成，组内的Storage       server之间是平等关系</li><li>不同组的Storage       server之间不会相互通信，同组内的Storage server之间会相互连接进行文件同步，从而保证同组内每个storage上的文件完全一致的。</li><li>一个组的存储容量为该组内存储服务器容量最小的那个</li></ul></li><li><p>FastDFS的扩容分纵向扩容与横向扩容</p></li><li><ul><li>横向 扩容<ul><li>增加容量</li><li>添加group组</li></ul></li><li><p>纵向扩容</p><ul><li>数据备份</li><li><p>当前组的最大容量  </p><ul><li>存储节点中容量最小的那个</li></ul></li><li><p>所有存储节点组名必须一样</p></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式存储&quot;&gt;&lt;a href=&quot;#分布式存储&quot; class=&quot;headerlink&quot; title=&quot;分布式存储&quot;&gt;&lt;/a&gt;分布式存储&lt;/h1&gt;&lt;p&gt;首先，什么是分布式存储，简而言之，就是将数据存储到多个存储设备（服务器）上。&lt;/p&gt;
&lt;h2 id=&quot;分布式与传统网
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://qianyouyou.cn/tags/Linux/"/>
    
      <category term="大数据" scheme="http://qianyouyou.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="分布式" scheme="http://qianyouyou.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="FastDFS" scheme="http://qianyouyou.cn/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>原创位运算版算法解决24点问题</title>
    <link href="http://qianyouyou.cn/2019/09/26/2019-09-26/"/>
    <id>http://qianyouyou.cn/2019/09/26/2019-09-26/</id>
    <published>2019-09-26T02:21:49.000Z</published>
    <updated>2019-09-26T02:43:18.706Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下什么是24点吧。随机4个数，这四个数能否通过加减乘除得到24。比如1,2,3,3，就可以通过2 <em> 3 </em> (3 + 1) = 24。再比如3,8,8,3，就可以通过8 / (3 - 3 / 8)得到。而1,1,1,1永远无法得到24点。我们如今需要判断当前4个数能否得到24点（当然求具体步骤也可以的，只需要代码中稍微加点东西）</p><p>我的方法是采用位运算，也就是二进制表示状态，0001表示第1个数，0010表示第2个数，0100表示第3个数，1000表示第4个数，0011表示第1个数和第2个数间所有的操作，同理1111就表示4个数之间所有的操作，1111可以有1100与0011进行加减乘除操作得到，也可以通过1011和0100得到……我们最后只需看1111里面是否有24即可（保存步骤的话需要自定义结构体，既添加字符状态）。</p><p>我们用set容器来存储当前状态下的所有结果（去重），那么set[1]即0001就是保存第一个数，set[2]即0010就是保存第二个数，set[3]即0011就是保存第一个数和第二个数的所有结果……某set可由其他两set的数据得出（例如0011可由0010和0001得到），则每次依次遍历其他两个set中所有元素再将新的结果插入到当前set中，这样从1遍历到15即可。</p><p>通过列真值表，00=0,01=0,10=1,11=0，我们可以得到a与!b即可得到想要的结果c，例如1011与!0010得到1001，当然c必须保证c不等于a且c不为0。而为了剪枝，我们也可以让c小于b。因此可以添加以下条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k = (i &amp; (~j));</span><br><span class="line">if(k != 0 &amp;&amp; k != i &amp;&amp; k &lt; j)</span><br></pre></td></tr></table></figure><p>两个数之间加减乘除共有6种结果，a+b,a-b,b-a,a * b, a / b, b / a，因此我们将相应结果存入set（集合为了去重，如果需要详细步骤则可用其他容器，不必用set，因为步骤需要保存状态）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(it = m_set[j].begin(); it != m_set[j].end(); it++)&#123;</span><br><span class="line">    for(it2 = m_set[k].begin(); it2 != m_set[k].end(); it2++)&#123;</span><br><span class="line">        m_set[i].insert((*it) + (*it2));</span><br><span class="line">        m_set[i].insert((*it) * (*it2));</span><br><span class="line">        m_set[i].insert((*it) - (*it2));</span><br><span class="line">        m_set[i].insert((*it2) - (*it));</span><br><span class="line">        if((*it2) != 0) m_set[i].insert((*it) / (*it2));</span><br><span class="line">        if((*it) != 0) m_set[i].insert((*it2) / (*it));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过4层循环（因为只有4个数嘛，n范围也就是4）完成24点的判断了。以下是详细代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">set&lt;double&gt;m_set[1 &lt;&lt; 4];</span><br><span class="line">const double ens = 1e-10;</span><br><span class="line">double a[4];</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2] &gt;&gt; a[3])&#123;</span><br><span class="line">        for(int i = 0; i &lt; 16; ++i)&#123;</span><br><span class="line">            m_set[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">            m_set[1 &lt;&lt; i].insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; 16; ++i)&#123;</span><br><span class="line">            for(int j = 1; j &lt; i; ++j)&#123;</span><br><span class="line">                int k = (i &amp; (~j));</span><br><span class="line">                if(k != 0 &amp;&amp; k != i &amp;&amp; k &lt; j)&#123;</span><br><span class="line">                    //cout &lt;&lt; k &lt;&lt; &quot;&amp;~&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                    set&lt;double&gt;::iterator it, it2;</span><br><span class="line">                    for(it = m_set[j].begin(); it != m_set[j].end(); it++)&#123;</span><br><span class="line">                        for(it2 = m_set[k].begin(); it2 != m_set[k].end(); it2++)&#123;</span><br><span class="line">                            m_set[i].insert((*it) + (*it2));</span><br><span class="line">                            m_set[i].insert((*it) * (*it2));</span><br><span class="line">                            m_set[i].insert((*it) - (*it2));</span><br><span class="line">                            m_set[i].insert((*it2) - (*it));</span><br><span class="line">                            if((*it2) != 0) m_set[i].insert((*it) / (*it2));</span><br><span class="line">                            if((*it) != 0) m_set[i].insert((*it2) / (*it));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;double&gt;::iterator it;</span><br><span class="line">        for(it = m_set[15].begin(); it != m_set[15].end(); it++)&#123;</span><br><span class="line">            if(fabs(*it - 24) &lt; ens)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(it != m_set[15].end())&#123;</span><br><span class="line">            cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另附原始递归代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double ins = 0.0000001;</span><br><span class="line">double val[4];</span><br><span class="line">bool dfs(int cur, double res)&#123;</span><br><span class="line">  double ans = res;</span><br><span class="line">  if(fabs(ans - 24) &lt; ins &amp;&amp; cur == 4)&#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;else if (cur &gt;= 4)&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if(dfs(cur + 1, ans + val[cur])</span><br><span class="line">     || dfs(cur + 1, ans - val[cur])</span><br><span class="line">     || dfs(cur + 1, -ans + val[cur])</span><br><span class="line">     || (cur &gt; 0 &amp;&amp; dfs(cur + 1, ans * val[cur]))</span><br><span class="line">     || dfs(cur + 1, cur &gt; 0 ? ans / val[cur] : 1 / val[cur])</span><br><span class="line">     || (ans != 0 &amp;&amp; dfs(cur + 1, val[cur] / ans))</span><br><span class="line">    )&#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    double v[4];</span><br><span class="line">    for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">    cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    for(int i = 0; i &lt; 4; ++i)&#123;</span><br><span class="line">        for(int j = 0; j &lt; 4; ++j)&#123;</span><br><span class="line">            if(j == i)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int k = 0; k &lt; 4; ++k)&#123;</span><br><span class="line">                if(k == i || k == j)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                val[0] = v[i];</span><br><span class="line">                val[1] = v[j];</span><br><span class="line">                val[2] = v[k];</span><br><span class="line">                val[3] = v[6 - i - j - k];</span><br><span class="line">                flag = dfs(0, 0);</span><br><span class="line">                if(flag)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(flag)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先说一下什么是24点吧。随机4个数，这四个数能否通过加减乘除得到24。比如1,2,3,3，就可以通过2 &lt;em&gt; 3 &lt;/em&gt; (3 + 1) = 24。再比如3,8,8,3，就可以通过8 / (3 - 3 / 8)得到。而1,1,1,1永远无法得到24点。我们如今需要
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="位运算" scheme="http://qianyouyou.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>在任务跳转问题上，C#的委托delegate与工厂方法模式的异曲同工之妙</title>
    <link href="http://qianyouyou.cn/2019/08/28/2019-08-28/"/>
    <id>http://qianyouyou.cn/2019/08/28/2019-08-28/</id>
    <published>2019-08-28T12:56:41.000Z</published>
    <updated>2019-09-07T05:27:59.563Z</updated>
    
    <content type="html"><![CDATA[<p>在玩游戏时，常常会有任务跳转。但当跳转类型过多时，对游戏研发者来说，就是一件头疼的事了。之前在做游戏城镇等级模块时，就遇到了任务跳转过多的问题。刚接到任务跳转这个需求时，由于入门未深，便用if-else写的。可以想象一百多行的if-else或者switch是多么壮观啊。。。</p><p>但是当我们只为了完成当日任务，而不为长远维护考虑，那未来将是一件可怕的事情。而且那样的代码，像我这样的人看着也不舒服。</p><p>最近看了C#高级语法，赫然发现C#中的委托不就是C++中的函数指针嘛。于是，对于上述if-else，便有解了。</p><p>我们只需要写一个委托，对应创建一个数组对象，每个跳转类型封装一个方法，再用委托来回调，这样的代码，主方法里只需1行就搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class UICityRichLevelItem : ScreenBaseHandler</span><br><span class="line">&#123;</span><br><span class="line">    //public RawImage imgIcon;</span><br><span class="line">    public Text textProgress;</span><br><span class="line">    public Text textDegreeOfCompletion;</span><br><span class="line">    public Slider slideProgress;</span><br><span class="line">    public GameObject imgBg;</span><br><span class="line">    public GameObject imgCompleteFinish;</span><br><span class="line">    public GameObject imgCompleteGoto;</span><br><span class="line">    public UI_Event btnGoto;</span><br><span class="line">    public GameObject imgCompleteDelivery;</span><br><span class="line">    public UI_Event btnDelivery;</span><br><span class="line">    private int typeId;</span><br><span class="line">    private int taskId;</span><br><span class="line">    private bool isDelivery;</span><br><span class="line"></span><br><span class="line">    private string TaskDescription;</span><br><span class="line">    private int allNum;</span><br><span class="line">    private int submitId;   //需要提交的id</span><br><span class="line">    private const int NumOfTaskTypes = 9;   //任务种类数量</span><br><span class="line">    private const int DeliveryOfGoodsTaskId = 9;    //提交货物类型id</span><br><span class="line"></span><br><span class="line">    private delegate void JumpTask();</span><br><span class="line">    JumpTask [] jumpTask = new JumpTask[NumOfTaskTypes];</span><br><span class="line"></span><br><span class="line">    public override void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        isDelivery = false;</span><br><span class="line">        allNum = 0;</span><br><span class="line">        submitId = 0;</span><br><span class="line">        btnGoto.onClick = (eventData, ev) =&gt; BtnGotoOnClick();</span><br><span class="line">        btnDelivery.onClick = (eventData, ev) =&gt; BtnDeliveryOnClick();</span><br><span class="line"></span><br><span class="line">        jumpTask[0] = new JumpTask(JumpTaskType_0);</span><br><span class="line">        jumpTask[1] = new JumpTask(JumpTaskType_1);</span><br><span class="line">        jumpTask[2] = new JumpTask(JumpTaskType_2);</span><br><span class="line">        jumpTask[3] = new JumpTask(JumpTaskType_3);</span><br><span class="line">        jumpTask[4] = new JumpTask(JumpTaskType_4);</span><br><span class="line">        jumpTask[5] = new JumpTask(JumpTaskType_5);</span><br><span class="line">        jumpTask[6] = new JumpTask(JumpTaskType_6);</span><br><span class="line">        jumpTask[7] = new JumpTask(JumpTaskType_7);</span><br><span class="line">        jumpTask[8] = new JumpTask(JumpTaskType_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetItem (TableCityRichEvent.Data next)</span><br><span class="line">    &#123;</span><br><span class="line">        taskId = next.mId;</span><br><span class="line">        typeId = next.mFunctionType;</span><br><span class="line">        if (next.mFunctionParameter.Count == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            allNum = next.mFunctionParameter[0];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            submitId = next.mFunctionParameter[0];</span><br><span class="line">            allNum = next.mFunctionParameter[1];</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDescription = next.mEventsDes;</span><br><span class="line">        textDegreeOfCompletion.text = &quot;0/&quot; + allNum;</span><br><span class="line">        textProgress.text = JointStr(TaskDescription, textDegreeOfCompletion.text);</span><br><span class="line">        slideProgress.maxValue = allNum;</span><br><span class="line">        slideProgress.value = 0;</span><br><span class="line">        if (isDeliveryOfGoodsTask())</span><br><span class="line">        &#123;</span><br><span class="line">            int num = StorageManager.instance.GetAllCommodityUnlockNumById(submitId);</span><br><span class="line">            textDegreeOfCompletion.text = num + &quot;/&quot; + allNum;</span><br><span class="line">            textProgress.text = JointStr(TaskDescription, textDegreeOfCompletion.text);</span><br><span class="line">            slideProgress.value = num &gt; allNum ? allNum : num;</span><br><span class="line">        &#125;</span><br><span class="line">        isCompleted(allNum, (int)slideProgress.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int GetTypeItem()</span><br><span class="line">    &#123;</span><br><span class="line">        return typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool HasChecked()</span><br><span class="line">    &#123;</span><br><span class="line">        return isDelivery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool SetCurNum (int curNum)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!isDeliveryOfGoodsTask())</span><br><span class="line">        &#123;</span><br><span class="line">            slideProgress.value = curNum;</span><br><span class="line">            textDegreeOfCompletion.text = curNum + &quot;/&quot; + allNum;</span><br><span class="line">            textProgress.text = JointStr(TaskDescription, textDegreeOfCompletion.text);</span><br><span class="line">        &#125;</span><br><span class="line">        if (curNum &gt;= allNum)</span><br><span class="line">        &#123;</span><br><span class="line">            isDelivery = true;</span><br><span class="line">            slideProgress.value = curNum;</span><br><span class="line">        &#125;</span><br><span class="line">        isCompleted(allNum, curNum);</span><br><span class="line">        return curNum &gt;= allNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private string JointStr(string str1, string str2)</span><br><span class="line">    &#123;</span><br><span class="line">        return str1 + &quot;  &quot; + str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void isCompleted(int maxx, int cur)</span><br><span class="line">    &#123;</span><br><span class="line">        if (isDeliveryOfGoodsTask())</span><br><span class="line">        &#123;</span><br><span class="line">            imgCompleteDelivery.SetActive(!isDelivery);</span><br><span class="line">            imgCompleteGoto.SetActive(false);</span><br><span class="line">            imgCompleteFinish.SetActive(isDelivery);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            imgCompleteDelivery.SetActive(false);</span><br><span class="line">            imgCompleteGoto.SetActive(maxx &gt; cur);</span><br><span class="line">            imgCompleteFinish.SetActive(maxx &lt;= cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool isDeliveryOfGoodsTask()</span><br><span class="line">    &#123;</span><br><span class="line">        return TaskHash(typeId) == DeliveryOfGoodsTaskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void BtnGotoOnClick()</span><br><span class="line">    &#123;</span><br><span class="line">        jumpTask[TaskHash(typeId)]();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetBg(bool flag)</span><br><span class="line">    &#123;</span><br><span class="line">        imgBg.SetActive(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void BtnDeliveryOnClick()</span><br><span class="line">    &#123;</span><br><span class="line">        int num = StorageManager.instance.GetAllCommodityUnlockNumById(submitId);</span><br><span class="line">        if (isDelivery == false &amp;&amp; num &gt;= allNum)</span><br><span class="line">        &#123;</span><br><span class="line">            TCPNetworkAttribute.Instance.ReqRichlevelSubmit(taskId);</span><br><span class="line">            UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">            item.Init();</span><br><span class="line">            //isDelivery = true;</span><br><span class="line">            //SetCurNum(allNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int TaskHash(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        return id / 1000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_0()        //默认</span><br><span class="line">    &#123;</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.Init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_1()        //出航</span><br><span class="line">    &#123;</span><br><span class="line">        if (TaskHash(typeId) == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            int[] types = &#123;</span><br><span class="line">                (int)IntentionType.Fishing,</span><br><span class="line">                (int)IntentionType.Fishing,</span><br><span class="line">                (int)IntentionType.Merchant,</span><br><span class="line">                (int)IntentionType.Explore</span><br><span class="line">            &#125;;   //捕鱼，战峙，贸易，探索</span><br><span class="line">            UISetOut_MainPage.intentionType = (IntentionType)types[typeId % 1000 - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        UISetOut_MainPage config = MenuManager.instance.CreateMenu&lt;UISetOut_MainPage&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_2()        //建造</span><br><span class="line">    &#123;</span><br><span class="line">        UIBuildingHandle config = MenuManager.instance.CreateMenu&lt;UIBuildingHandle&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_3()        //更路簿</span><br><span class="line">    &#123;</span><br><span class="line">        UILinkDistrict config = MenuManager.instance.CreateMenu&lt;UILinkDistrict&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_4()        //易市</span><br><span class="line">    &#123;</span><br><span class="line">        UIMarketHandle config = MenuManager.instance.CreateMenu&lt;UIMarketHandle&gt;();</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_5()        //区域解锁</span><br><span class="line">    &#123;</span><br><span class="line">        UIUnLockZoneHandle handle = MenuManager.instance.CreateMenu&lt;UIUnLockZoneHandle&gt;();</span><br><span class="line">        TableLockZone.Data mTableData = null;</span><br><span class="line">        List&lt;TableLockZone.Data&gt; lst_zone_table = TableManager.instance.GetLockZoneAll();</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; i &lt; lst_zone_table.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mTableData = lst_zone_table[i];</span><br><span class="line">            int id = mTableData.mId;</span><br><span class="line">            if (LockZoneManager.instance.IsReadyZoneUnlock(id))</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; lst_zone_table.Count &amp;&amp; mTableData != null)</span><br><span class="line">        &#123;</span><br><span class="line">            handle.SetZone(mTableData);</span><br><span class="line">            handle.OpenScreen();</span><br><span class="line">        &#125;</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_6()        //船坞</span><br><span class="line">    &#123;</span><br><span class="line">        UIShipHouseHandle config = MenuManager.instance.CreateMenu&lt;UIShipHouseHandle&gt;();</span><br><span class="line">        //config.gameObject.transform.Find(&quot;Canvas&quot;).GetComponent&lt;Canvas&gt;().sortingOrder = 3;</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_7()        //广场</span><br><span class="line">    &#123;</span><br><span class="line">        UIPiazzaHandle config = MenuManager.instance.CreateMenu&lt;UIPiazzaHandle&gt;();</span><br><span class="line">        BuildingControl control = BuildingManager.instance.GetBuildingControlByTableId(12);</span><br><span class="line">        config.InitFactory(control);</span><br><span class="line">        config.OpenScreen();</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.CloseScreen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void JumpTaskType_8()        //人物等级</span><br><span class="line">    &#123;</span><br><span class="line">        UIPlayerInfo item = MenuManager.instance.FindMenu&lt;UIPlayerInfo&gt;();</span><br><span class="line">        item.Init();</span><br><span class="line">        item.OpenScreen(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现，和设计模式中的工厂方法模式有异曲同工之妙呢。日后维护起来也方便许多。</p><p>接下来我们详细介绍下C#中的委托吧。</p><h1 id="C-委托（Delegate）"><a href="#C-委托（Delegate）" class="headerlink" title="C# 委托（Delegate）"></a>C# 委托（Delegate）</h1><p>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类。</p><h2 id="声明委托（Delegate）"><a href="#声明委托（Delegate）" class="headerlink" title="声明委托（Delegate）"></a>声明委托（Delegate）</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><p>例如，假设有一个委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate int MyDelegate (string s);</span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的 <em>string</em> 参数的方法，并返回一个 <em>int</em> 类型变量。</p><p>声明委托的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;</span><br></pre></td></tr></table></figure><h2 id="实例化委托（Delegate）"><a href="#实例化委托（Delegate）" class="headerlink" title="实例化委托（Delegate）"></a>实例化委托（Delegate）</h2><p>一旦声明了委托类型，委托对象必须使用 <strong>new</strong> 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 <strong>new</strong> 语句的参数就像方法调用一样书写，但是不带有参数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public delegate void printString(string s);</span><br><span class="line">...</span><br><span class="line">printString ps1 = new printString(WriteToScreen);</span><br><span class="line">printString ps2 = new printString(WriteToFile);</span><br></pre></td></tr></table></figure><p>下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n);</span><br><span class="line">namespace DelegateAppl&#123;</span><br><span class="line">   class TestDelegate</span><br><span class="line">   &#123;  </span><br><span class="line">   static int num = 10;  </span><br><span class="line">   public static int AddNum(int p)  &#123; </span><br><span class="line">   num += p; return num;</span><br><span class="line">   &#125;</span><br><span class="line">   public static int MultNum(int q)  &#123;</span><br><span class="line">   num *= q; return num;</span><br><span class="line">   &#125;</span><br><span class="line">   public static int getNum()  &#123;</span><br><span class="line">   return num;</span><br><span class="line">   &#125;</span><br><span class="line">   static void Main(string[] args)  &#123; // 创建委托实例</span><br><span class="line">   NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">   NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法</span><br><span class="line">   nc1(25);</span><br><span class="line">   Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">   nc2(5);</span><br><span class="line">   Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 35</span><br><span class="line">Value of Num: 175</span><br></pre></td></tr></table></figure><h2 id="委托的多播（Multicasting-of-a-Delegate）"><a href="#委托的多播（Multicasting-of-a-Delegate）" class="headerlink" title="委托的多播（Multicasting of a Delegate）"></a>委托的多播（Multicasting of a Delegate）</h2><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。</p><p>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。下面的程序演示了委托的多播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n); namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">    class TestDelegate</span><br><span class="line">    &#123;</span><br><span class="line">        static int num = 10; public static int AddNum(int p) &#123; num += p; return num; &#125;</span><br><span class="line">        public static int MultNum(int q) &#123; num *= q; return num; &#125;</span><br><span class="line">        public static int getNum() &#123; return num; &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123; // 创建委托实例</span><br><span class="line">            NumberChanger nc;</span><br><span class="line">            NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = new NumberChanger(MultNum);</span><br><span class="line">            nc = nc1; nc += nc2; // 调用多播</span><br><span class="line">            nc(5);</span><br><span class="line">            Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 75</span><br></pre></td></tr></table></figure><h2 id="委托（Delegate）的用途"><a href="#委托（Delegate）的用途" class="headerlink" title="委托（Delegate）的用途"></a>委托（Delegate）的用途</h2><p>下面的实例演示了委托的用法。委托 <em>printString</em> 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。</p><p>我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">    class PrintString</span><br><span class="line">    &#123;</span><br><span class="line">        static FileStream fs; static StreamWriter sw;  // 委托声明</span><br><span class="line">        public delegate void printString(string s);  // 该方法打印到控制台</span><br><span class="line">        public static void WriteToScreen(string str) &#123;</span><br><span class="line">            Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str);</span><br><span class="line">        &#125;  // 该方法打印到文件</span><br><span class="line">        public static void WriteToFile(string s)  &#123;</span><br><span class="line">            fs = new FileStream(&quot;c:\\message.txt&quot;, FileMode.Append, FileAccess.Write);</span><br><span class="line">            sw = new StreamWriter(fs); sw.WriteLine(s); sw.Flush(); sw.Close(); fs.Close();</span><br><span class="line">        &#125;  // 该方法把委托作为参数，并使用它调用方法</span><br><span class="line">        public static void sendString(printString ps)  &#123;</span><br><span class="line">            ps(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)  &#123;</span><br><span class="line">            printString ps1 = new printString(WriteToScreen);</span><br><span class="line">            printString ps2 = new printString(WriteToFile);</span><br><span class="line">            sendString(ps1); sendString(ps2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The String is: Hello World</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在玩游戏时，常常会有任务跳转。但当跳转类型过多时，对游戏研发者来说，就是一件头疼的事了。之前在做游戏城镇等级模块时，就遇到了任务跳转过多的问题。刚接到任务跳转这个需求时，由于入门未深，便用if-else写的。可以想象一百多行的if-else或者switch是多么壮观啊。。。
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C#" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C/"/>
    
    
      <category term="Unity3D" scheme="http://qianyouyou.cn/tags/Unity3D/"/>
    
      <category term="Unity" scheme="http://qianyouyou.cn/tags/Unity/"/>
    
      <category term="C#" scheme="http://qianyouyou.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>宽敞的心态，宽敞的世界</title>
    <link href="http://qianyouyou.cn/2019/07/28/2019-07-28/"/>
    <id>http://qianyouyou.cn/2019/07/28/2019-07-28/</id>
    <published>2019-07-28T06:00:49.000Z</published>
    <updated>2019-08-28T12:56:10.925Z</updated>
    
    <content type="html"><![CDATA[<p>忽然发现，来上海也有一段时间了。</p><p>还记得没来上海时，身边回荡着各种声音，上了年纪的长辈们鼓励我年轻人就应该出去闯一闯；父母则是抱着忧虑的念头，总说大城市生活压力大，骗子多，无时无刻都得防备；朋友们相对而言更担心的是我一个人出远门的安全。那时候，心中荡漾的，不清楚是期待，还是恐惧。</p><p>初来上海时，东奔西跑的找房租房，生活上高昂的消费让自己不得不开始学会记录支出，还有工作上初来乍到的各种不适应，总弄得自己身心疲惫；那时候，为最后一个挤上公交地铁而庆幸，为了早起而不得不早睡的无奈。心中徘徊的，应该是厌倦，还有抱怨吧。</p><p>现在呢，发现人们口中的大城市，并没有像人们所描述的那么繁华，也没有人们所描述的那样让人苦不堪言。渐渐地，我发现自己爱上了这里。</p><p>其实啊，上海没变，世界也没变，只有我们的心态变了。</p><p>就像人们议论程序员这个行业，一提到程序员，最多的话题就是996，也就是朝九晚九，每周6天。听到这词，即使没有工作，也难免会让人感觉疲惫。但是，真的如此吗。就像我，工作一段时间，感觉每天都很充实。每周有两天双休，但每次到了双休，玩一天游戏，或者什么也不干，剩下的只有空虚，所以周末能加班就加班，因为加班使自己感到生活的充实与价值。</p><p>还记得刚来学校时，因为热爱编程，而报了计算机专业。那时候，没日没夜敲代码是我的快乐。快找实习时，也是没日没夜敲代码，只是感觉到的是苦涩。而工作一段时间后，当我又开始忙碌地敲代码时，感觉到的是充实。同样是敲代码，在学校时因为热爱，在找实习时因为迷茫和环境的影响而决定苦涩，现在，是找到了方向。所以，所谓的忙碌，只不过是旁观者的看法。当一个人真正热爱自己的工作时，别人不要求你加班，你也想自己去加班。</p><p>人们都说上海节奏快，但我坚信时代造英雄。</p><p>昨天父亲又给我打了个电话，尽管只是平常地问候，但我却草草结束了话题。我后来发现，渐渐地，我越来越不怎么和父亲说话了。因为每次父亲跟我洽谈，总是告诫我一些关于社会让人多么的无奈，或者大城市节奏太快压力太大，亦或是社会上到处都是坏人，即使同一屋檐下也要上一把锁。这并不是我父亲一个人的想法，而是我们那个小城镇普遍的想法。</p><p>受我父亲的影响，刚上大学时，因为父亲说西安是贼城，当时我坐个公交都得把包背到前面。但久而久之，我发现并不是所有人都是坏人，那些不美好只不过是世界的冰山一角，但更多地是世界的美好，许多人身上都是有光的。只是这冰山一角给人的心理带来了防备，但当我们以这冰山一角来定义世界时，将必定错过整个世界。</p><p>2G时代，将互联网带上中国，成就了搜狐、新浪、网易。3G时代，将互联网带到了生活，成就了百度、阿里、腾讯，号称BAT。4G时代，将互联网带到了人们随身携带的手机，成就了头条、美团、滴滴，号称TMD。如今5G时代的到来，一切皆有可能，如果还停留在旧时代的舒适圈，不肯加快脚步，那么城乡差距就会越来越大。</p><p>放宽心态，多看看世界好的一面，那么哪来那么多烦恼呢。</p><p>如今，我每周周末都会去公寓周围的大超市去逛逛，有时候什么也不买，仅仅是因为里面的音乐让自己舒心。感受了一周的充实，偶尔给自己放个小假，你会发现，生活并不单调。</p><p>追随时代的大步伐，难免会疲惫。偶尔停下脚步，慢下来，感受自己心中所聆听到的声音，你会发现，快节奏的生活，也会有慢下来的情调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忽然发现，来上海也有一段时间了。&lt;/p&gt;
&lt;p&gt;还记得没来上海时，身边回荡着各种声音，上了年纪的长辈们鼓励我年轻人就应该出去闯一闯；父母则是抱着忧虑的念头，总说大城市生活压力大，骗子多，无时无刻都得防备；朋友们相对而言更担心的是我一个人出远门的安全。那时候，心中荡漾的，不清
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>风往何处吹</title>
    <link href="http://qianyouyou.cn/2019/07/08/2019-07-08/"/>
    <id>http://qianyouyou.cn/2019/07/08/2019-07-08/</id>
    <published>2019-07-08T14:07:46.000Z</published>
    <updated>2019-07-08T14:09:51.832Z</updated>
    
    <content type="html"><![CDATA[<p>浅悠悠 7-8</p><p>我不知道，<br>风在往何处吹，<br>吹散了无根的枝叶，<br>还有七月的蔷薇。</p><p>我不知道，<br>风会往何处吹。<br>吹向那紫陌的寂寥，<br>还是霓虹的余辉。</p><p>我不知道，<br>风该往何处吹。<br>吹散那远方的清梦，<br>还是脚下的尘灰。</p><p>我不知道，<br>风向往何处吹。<br>吹向了温存的故事，<br>还有光阴的慈悲。</p><p>我不知道，<br>我什么也不知道。</p><p>也许只有风儿知道方向，<br>那我便化作海浪随风依洄。<br>也许风儿也不知道方向，<br>那我将像那尘埃何处可归。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浅悠悠 7-8&lt;/p&gt;
&lt;p&gt;我不知道，&lt;br&gt;风在往何处吹，&lt;br&gt;吹散了无根的枝叶，&lt;br&gt;还有七月的蔷薇。&lt;/p&gt;
&lt;p&gt;我不知道，&lt;br&gt;风会往何处吹。&lt;br&gt;吹向那紫陌的寂寥，&lt;br&gt;还是霓虹的余辉。&lt;/p&gt;
&lt;p&gt;我不知道，&lt;br&gt;风该往何处吹。&lt;br&gt;吹散那远
      
    
    </summary>
    
      <category term="诗词歌赋" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
      <category term="摘星集" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/%E6%91%98%E6%98%9F%E9%9B%86/"/>
    
    
      <category term="诗集" scheme="http://qianyouyou.cn/tags/%E8%AF%97%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>微信数据分析笔记</title>
    <link href="http://qianyouyou.cn/2019/06/24/2019-06-24/"/>
    <id>http://qianyouyou.cn/2019/06/24/2019-06-24/</id>
    <published>2019-06-24T00:48:36.000Z</published>
    <updated>2019-06-26T01:35:41.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6月24日"><a href="#6月24日" class="headerlink" title="6月24日"></a>6月24日</h1><h2 id="项目需求分析"><a href="#项目需求分析" class="headerlink" title="项目需求分析"></a>项目需求分析</h2><p>1、男女性别比例</p><p>2、各省好友数量</p><p>3、个性签名云图</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="pyecharts"><a href="#pyecharts" class="headerlink" title="pyecharts"></a>pyecharts</h3><p>一个商业级图表，纯Js图表库。用于生成Echarts图表的类库。</p><h3 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h3><p>中文分词组件。</p><h3 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h3><p>工程设计的Python工具包。包括统计、优化、整合、线性代数模块、傅里叶变换、信号和图像处理、长积分方程求解器等等。</p><h3 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h3><p>Python词云展示库，在一段文本中提取关键词进行扁平化的展示，更能吸引目标客户的眼球。</p><h3 id="wxpy"><a href="#wxpy" class="headerlink" title="wxpy"></a>wxpy</h3><p>微信个人API</p><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>Python的re模块提供了诸多正则表达式模块，使Python拥有了全部的正则表达式功能，库1方便检查一个字符串是否与某种模式匹配。</p><h2 id="登录并查看相关信息"><a href="#登录并查看相关信息" class="headerlink" title="登录并查看相关信息"></a>登录并查看相关信息</h2><p>1、登录</p><p>bot = Bot() #扫描二维码自动登录</p><p>2、获取登录账号的所有好友</p><p>bot.friends()</p><p>3、获取当前登录账号所关注的公众号</p><p>bot.mps()</p><p>4、获取当前登录账号群聊列表</p><p>bot.groups()</p><p>5、搜索好友：</p><p>bot.friends().search(‘好友备注名’)[0]</p><p>6、搜索好友并发送消息</p><p>bot.friends().search(‘好友备注名’)[0].send(‘str’)</p><p>7、向文件传输助手发送信息</p><p>bot.fle_helper.send(‘str’)</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>1、每个键值(key:value)对用冒号分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s = &#123;&apos;name&apos;:&apos;udbs&apos;, &apos;age&apos;:20&#125;</span><br><span class="line">&gt;&gt;&gt;a[&apos;age&apos;]</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt;print(a[&apos;age&apos;])</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><p>字典名[‘key’]</p><h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>字典名[‘key’] = ‘value’</p><h3 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h3><p>1、删除单一元素</p><p>格式：del 字典名[‘key’]</p><p>2、清空所有元素</p><p>格式：字典名.clear()</p><p>3、删除字典</p><p>格式：del 字典名</p><h1 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h1><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>open函数，必须先用Python内置的open()函数打开文件，创建一个file对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file object = open(file_name[, access_mode][, buffering])</span><br></pre></td></tr></table></figure><h2 id="with-as语句"><a href="#with-as语句" class="headerlink" title="with as语句"></a>with as语句</h2><p>try-finally语句可以处理异常。但较麻烦。</p><p>python提供了with语句语法，来构建对资源创建与释放方法，但功能与try相似。with语句后面跟着open方法，如果有返回值，可以使用as语句赋值给变量，退出时自动调用close。</p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>re.findall()方法</p><p>搜索整个字符串，返回匹配正则表达式的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern,string)</span><br></pre></td></tr></table></figure><p>re.compile()方法</p><p>将正则字符串编译成正则表达式对象，以便后期匹配中复用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(&apos;正则表达式&apos;)</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>.匹配除了换行符之外的所有字符。</li><li>d数字</li><li>w字母</li></ul><p>join()方法</p><p>用于将序列中的元素以指定的字符连接生成一个新的字符串</p><h1 id="6月26日"><a href="#6月26日" class="headerlink" title="6月26日"></a>6月26日</h1><h2 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h2><ol><li><p>精确模式：jieba.lcut(str)</p><p>试图将语句最精确切分，不存在冗余数据，适合文本分析。</p></li><li><p>全模式：jieba.lcut(str,cut_all=True)</p><p>将与句中所有可能是词的词语都切分出来，速度快，但存在冗余数据</p></li><li><p>搜索引擎模式：jieba.lcut_for_search(str)</p><p>在精确模式的基础上·，对长词再次进行切分。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;手持两把锟斤拷&apos;</span><br><span class="line">&gt;&gt;&gt; jieba.lcut(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;]</span><br><span class="line">&gt;&gt;&gt; str = &apos;手持两把锟斤拷，口中直呼烫烫烫。&apos;</span><br><span class="line">&gt;&gt;&gt; jieba.lcut(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;, &apos;，&apos;, &apos;口中&apos;, &apos;直呼&apos;, &apos;烫烫&apos;, &apos;烫&apos;, &apos;。&apos;]</span><br><span class="line">&gt;&gt;&gt; jieba.lcut_for_search(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;, &apos;，&apos;, &apos;口中&apos;, &apos;直呼&apos;, &apos;烫烫&apos;, &apos;烫&apos;, &apos;。&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="筛选函数isin-函数"><a href="#筛选函数isin-函数" class="headerlink" title="筛选函数isin()函数"></a>筛选函数isin()函数</h2><h3 id="isin"><a href="#isin" class="headerlink" title="isin()"></a>isin()</h3><p>功能：判断该列元素是否在某一个列表中。是True，否False。</p><h2 id="groupby函数和agg函数"><a href="#groupby函数和agg函数" class="headerlink" title="groupby函数和agg函数"></a>groupby函数和agg函数</h2><p>agg基于列的聚合操作</p><p>groupby基于行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6月24日&quot;&gt;&lt;a href=&quot;#6月24日&quot; class=&quot;headerlink&quot; title=&quot;6月24日&quot;&gt;&lt;/a&gt;6月24日&lt;/h1&gt;&lt;h2 id=&quot;项目需求分析&quot;&gt;&lt;a href=&quot;#项目需求分析&quot; class=&quot;headerlink&quot; title=&quot;项
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="大数据" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Python" scheme="http://qianyouyou.cn/tags/Python/"/>
    
      <category term="数据分析" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="大数据" scheme="http://qianyouyou.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb网上购物系统的设计与实现</title>
    <link href="http://qianyouyou.cn/2019/06/02/2019-06-02/"/>
    <id>http://qianyouyou.cn/2019/06/02/2019-06-02/</id>
    <published>2019-06-02T02:20:25.000Z</published>
    <updated>2019-06-09T14:23:55.780Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/qian-youyou/ShoppingNet" target="_blank" rel="noopener">GitHub源码</a></p><p>1 课题简介    </p><p>1.1 背景及研究现状</p><p>在互联网高速发展的时代背景下，网络正以一种前所未有的冲击力在影响着人类的活动，包括人类的生产和日常生活。网络的诞生和发展，颠覆了传统的信息传播方式，冲破了存在于传统交流方式中时间和空间的种种壁垒，极大地改变了人类从物质到精神、从形式到内容、从生产到生活的各种活动，并且给人类带来了新的机遇和挑战。网络购物作为电子商务的一种形式正以其高效、低成本的优势，逐步成为新兴的经营模式和理念，人们已经不再满足用途信息的浏览和发布，而是渴望着能够充分享受网络所带来的更加多的便利。网络购物正适应了当今社会快节奏地生活，使顾客足不出户便可以方便快捷轻松地选购自己喜欢的商品。</p><p>本次网上购物系统基于课程设计以专业综合设计I的设计成果，对其进行Web服务器端功能的扩展与开发，将其设计成一个具有服务器端交互功能的完整的Web应用系统，并完成系统的测试、服务器端的部署与发布。</p><p>1.2 设计内容与设计思路    </p><p>网上购物系统主要是对后台管理和前台操作。后台管理是管理员对本网站的维护，通过商品资料(商品添加、商品修改)，等功能达到对网站的管理。前台操作是用户登录到本网站，可以进行用户注册，通过网站的热门商品推荐或商品分类查找功能实现商品搜索，找到自己想要买的商品，装入购物车，提交定单进行购买。</p><p>网上购物平台的特点是客户和电子商品信息量很大，管理员需要整理的信息很多，为让管理员轻松、方便、快捷的管理，该平台采用符合购买电子商品基本的原则，满足广大客户的日益增长的数量，并达到操作过程中的直观、方便、实用、安全等要求。</p><p>1.3 设计目的及意义</p><p>网上购物系统，是在网络上建立一个虚拟的购物商场，使消费者的购物过程变得轻松、快捷、方便，很适合现代人快节奏的生活；同时又有效的控制“商场”运营的成本，开辟了一个新的销售渠道。 </p><p>网上购物相较于实体店铺有着其独特的优势，首先相较于实体店铺网上店铺所需要的成本很小很多，网上购物不需要考虑门店等等的费用其次网上购物系统不存在店铺打样的问题延长了经营的时间无需专人看店节约成本的同时还能使得效益更大化。</p><p>本系统利用现代化的电子及网络技术，为消费者和企业搭建一个良好的互动平台。让用户享受快捷的购物方式，为企业提供不同于传统销售的崭新的销售模式。 该购物系统是一个中小型的电子商务系统，可以为各类用户提供方便的在线购物环境。用户可以在系统中实现注册、登录、修改个人信息、分类查询商品信息、购物、管理购物车、支付等功能。管理员可以通过后台管理模块实现商品的增删改查、种类的增删改查等，从而实现对于该购物系统的管理。</p><p>2 系统分析与设计</p><p>2.1 可行性分析    </p><p>可行性研究是为了弄清楚系统开发的项目是不是可以实现和值得进行研究的过程，实际上是一次大大简化系统分析和系统设计的过程，所以，进行可执行性的分析是非常必要的，也是很重要的，可行性研究阶段通过对系统目标进行市场调研和技术分析，提出了初步的可行性方案并进行了论证。这里主要从技术可行性、经济可行性以及操作可行性三方面进行分析。</p><p>2.1.1 经济可行性</p><p>该系统硬件只需要一台PC机，而且配置要求不高。软件方面用到的MySQL是免费开源的，Eclipse也是免费使用的，所以开发成本并不高。而该系统若投入运行之后不仅减少了人力、物力而且可以推动电影行业的发展，所带来的收益是巨大的，因此在经济上也是可行的。</p><p>2.1.2 技术可行性</p><p>技术可行性要考虑到现有的技术手段和能力能不能完成系统的开发，以免开发到一半出现现有技术无法解决的问题。本系统主要采用的是JAVAWeb和JSP技术。JAVA语言和JSP都是很成熟的技术，也是世界范围内应用最广泛的技术，所以用它们作为后台和前台的语言是没有任何问题的。而且集成开发工具Eclipse可以解决很多方面的问题，创造了良好的开发环境。由于JSP功能强大，而MySQL灵活易维护在开发方面具有方便快捷、使用灵活的特点，以及目前的广泛实际应用，因此使用JAVAWed、MySQL是开发轻平台的最佳组合从而说明本系统在技术方面可行。</p><p>硬件方面，科技飞速发展的今天，硬件更新的速度越来越快，容量越来越大，可靠性越来越高，价格越来越低，其硬件平台完全能满足此系统的需要。</p><p>2.2 需求分析</p><p>2.2.1 系统设计目标</p><p>此网络购物平台系统旨在为用户提供一个简易的具备一些基本功能的购物系统，通过这个系统用户可以轻松的获得自己想要的商品。存在两种类型用户，普通用户和管理员用户。普通用户在这个系统中注册过后进行登陆此时可以在平台中进行自由的选购自己想要的商品，将选购好的商品加入购物车，如果需要修改可以在购物车中更改所需的商品数量，当选择完成过后可以确认购买，也可以让所选物品一直处在购物车中，等待下次登陆时依然有效。管理员用户可以对商品进行管理，包括商品上架，商品下架，商品查询，商品修改等。</p><p>2.2.2 系统功能需求分析</p><p>（1）用户管理：注册会员、登录、管理员用户校验、激活、退出；</p><p>（2）商品显示：按分类查询商品、通过首页推荐查询商品、展示热门商品、展示最新商品、提交商品到购物车中等；</p><p>（3）购物车管理：向购物车中添加商品、修改购物车中商品数量、删除购物车中商品、我的购物车；</p><p>（4）订单管理：通过购物车中商品生成订单、查看我的订单、查看某个订单的详细、订单支付、确认收货。</p><p>（5）管理员：订单查询、商品和类别的增删改查。</p><p>2.2.3 系统性能需求分析</p><p>用户注册部分需要实时检验用户信息是否合格，否则用户提交后才检验，若不合格需重新填写，用户很快会厌倦，因此Ajax是不错的选择。</p><p>商品部份应该给用户提供推荐，比如最新商品和最热商品，给用户提供访问便利。</p><p>此外，分类部分不常改，且使用频繁，但每次若从数据库中读取会影响效率，因此使用redis缓存数据是个不错的选择，因为大大加快了访问效率。</p><p>订单部分由于支付功能需要第三方平台，所以可不必实现。</p><p>管理员部分需要对订单具有全权访问权限。</p><p>2.3 系统总体设计</p><p>2.3.1 系统总体结构设计</p><p>本项目采取MVC设计模式，分为model，view，controler三层。本项目包含dao，domain，service，web，utils五打包。</p><p>其中web包中包含各种servlet类和前端jsp进行交互，及view层。</p><p>Service为业务逻辑层，控制信息的权限以及信息在数据库与前端的交互，及controler层。Dao中主要负责与数据库进行交互，通过各种sql获取或添加信息到数据库，及model层。</p><p>Domain为基本类，共三大层创建对象进行层与层间的信息交互，作为信息载体的集合而存在。</p><p>Utils包中包含各种工具，例如数据库中的date类型需要string进行转换，或者id的生成，这些工具均包含于utils包中。基本模式如下图：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps1.jpg" alt="img"> </p><p>图2-1 系统总体结构设计图</p><p>B/S系统架构，简单点就是用户通过访问浏览器输入域名后，转入对应的前端html或jsp，然后通过http或https协议将信息报文传送给服务端，服务端进行相应之后做出一系列对数据或页面的响应。以下是B/S系统架构图。</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps2.jpg" alt="img"> </p><p>图2-2 B/S系统框架图</p><p>2.3.2 系统功能模块设计</p><p>（1）用户注册功能：发送邮件、激活用户、表单的校验、用户的登录功能、自动登录、用户的注销功能</p><p>（2）商品模块：首页热门商品和最新商品功能、商品分类、商品的列表（分页）、商品详细信息、浏览记录功能</p><p>（3）购物车模块：将商品加入购物车、展示购物车功能</p><p>（4）订单模块（多表和事务）：提交订单、展示订单、在线支付</p><p>（5）后台的分类的模块：分类信息的增删改查</p><p>（6）后台的商品模块：商品的信息的增删改查（文件上传）</p><p>（7）后台的订单的模块：所有的订单的信息展示</p><p>2.3.3 主要业务流程</p><p>用户的注册过程：</p><p>是首先进入主界面，点击注册按钮，跳转到注册页面，填写注册信息，ajax判断信息是否合格，然后跳转到注册servlet层，把信息传递给service层，service层通过dao层获取数据库信息，反馈是否成功给servlet层，最终按是否插入成功而跳转到注册成功或失败界面。之后介绍的流程大致如此，及MVC三层模型的传输过程。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps3.jpg" alt="img"></td></tr></tbody></table><p>图</p><p>2-3 程序包结构图</p><p>主界面显示：</p><p>首先index.jsp加载head.jsp，然后获取最热商品信息与最新商品信息，并显示在主界面，最后加载footer.jsp。</p><p>Head.jsp界面显示：</p><p>首先加载首页，然后访问redis数据库判断是否有种类信息，有则读取，无则访问MySQL数据库，读取数据后放到redis中。</p><p>用户注册分析：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps4.jpg" alt="img"> </p><p>图2-4 用户注册详情</p><p>商品设计：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps5.jpg" alt="img"> </p><p>图2-5 商品详情</p><p>通过浏览器访问商城，就相当于超市访问商品，因此我们需要购物车来装载商品以便对所需物品增删改查。<img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps6.jpg" alt="img"></p><p>图2-6 购物车设计</p><p>订单业务设计：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps7.jpg" alt="img"> </p><p>图2-7 订单业务设计</p><p>管理员管理流程：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps8.jpg" alt="img"> </p><p>图2-8 管理员管理</p><p>2.4 系统数据库设计</p><p>2.4.1 数据库概念模型设计</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps9.jpg" alt="img"> </p><p>图2-9  E-R图</p><p>2.4.2数据库逻辑结构设计</p><p>表2-1 category表结构</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>Cid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>Cname</td><td>varChar</td><td>20</td><td>默认为空</td></tr></tbody></table><p>表2-2 orderitem表结构</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>itemid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>count</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>subtotal</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>pid</td><td>varchar</td><td>50</td><td>可为空</td></tr><tr><td>oid</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>表2-3 order表</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>oid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>ordertime</td><td>datetime</td><td>0</td><td>可为空</td></tr><tr><td>total</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>state</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>address</td><td>varchar</td><td>30</td><td>可为空</td></tr><tr><td>name</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>telephone</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>uid</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>表2-4 product表</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>pid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>pname</td><td>Varchar</td><td>20</td><td>可为空</td></tr><tr><td>Market_price</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>Shop_price</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>pimage</td><td>varchar</td><td>30</td><td>可为空</td></tr><tr><td>pdate</td><td>date</td><td>20</td><td>可为空</td></tr><tr><td>Is_hot</td><td>int</td><td>20</td><td>可为空</td></tr><tr><td>pdesc</td><td>varchar</td><td>255</td><td>可为空</td></tr><tr><td>pflag</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>cid</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>表2-5 user表</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>uid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>username</td><td>Varchar</td><td>20</td><td>可为空</td></tr><tr><td>password</td><td>Varchar</td><td>20</td><td>可为空</td></tr><tr><td>name</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>email</td><td>varchar</td><td>30</td><td>可为空</td></tr><tr><td>telephone</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>birthday</td><td>date</td><td>0</td><td>可为空</td></tr><tr><td>sex</td><td>varchar</td><td>10</td><td>可为空</td></tr><tr><td>state</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>code</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>2.4.3 数据库关系设计</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps10.jpg" alt="img"> </p><p>图2-10 数据库关系图</p><p>3  系统详细设计</p><p>3.1 系统开发及运行环境</p><p>3.1.1 软件环境    </p><p>运行环境：Windows操作系统下eclipse</p><p>开发语言：JavaWeb</p><p>数据库：MySQL，redis</p><p>3.1.2 硬件环境    </p><p>阿里云服务器。</p><p>3.2 系统采用的关键技术</p><p>3.2.1页面显示逻辑与业务逻辑相分离</p><p><a href="https://baike.baidu.com/item/MVC" target="_blank" rel="noopener">MVC</a>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p><p>3.2.2数据库连接与访问    </p><p>C3P0是一个开源的JDBC<a href="https://baike.baidu.com/item/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1699713" target="_blank" rel="noopener">连接池</a>，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。</p><p>3.2.3 Ajax异步校验</p><p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><p>3.3 系统框架的实现</p><p>本项目采取MVC设计模式，分为model，view，controler三层。本项目包含dao，domain，service，web，utils五大包。</p><p>其中web包中包含各种servlet类和前端jsp进行交互，及view层。</p><p>Service为业务逻辑层，控制信息的权限以及信息在数据库与前端的交互，及controler层。Dao中主要负责与数据库进行交互，通过各种sql获取或添加信息到数据库，及model层。</p><p>Domain为基本类，共三大层创建对象进行层与层间的信息交互，作为信息载体的集合而存在。</p><p>Utils包中包含各种工具，例如数据库中的date类型需要string进行转换，或者id的生成，这些工具均包含于utils包中。</p><p>3.3.1 主要的类与接口</p><p>表3-1 JSP清单</p><table><thead><tr><th>Jsp</th><th>说明</th></tr></thead><tbody><tr><td>admin/home.jsp</td><td>管理员界面</td></tr><tr><td>index.jsp</td><td>主界面</td></tr><tr><td>head.jsp</td><td>头界面</td></tr><tr><td>footer.jsp</td><td>尾界面</td></tr><tr><td>Product_list.jsp</td><td>商品栏界面</td></tr><tr><td>Product_info.jsp</td><td>单项商品信息界面</td></tr><tr><td>order_list.jsp</td><td>订单栏界面</td></tr><tr><td>order_info.jsp</td><td>订单项界面</td></tr><tr><td>cart.jsp</td><td>购物车界面</td></tr><tr><td>login.jsp</td><td>登陆界面</td></tr><tr><td>register.jsp</td><td>注册界面</td></tr></tbody></table><p>表3-2 MVC模式清单</p><table><thead><tr><th>Servlet</th><th>Service</th><th>Dao</th><th>Utils</th><th>Domain</th></tr></thead><tbody><tr><td>AutoLoginFilter</td><td>AdminService</td><td>AdminDao</td><td>BeanFactory</td><td>Cart</td></tr><tr><td>ActiveServlet</td><td>ProductService</td><td>ProductDao</td><td>CommonsUtils</td><td>CartItem</td></tr><tr><td>AdminServlet</td><td>UserService</td><td>UserDao</td><td>DataSourceUtils</td><td>Category</td></tr><tr><td>BaseServlet</td><td>AdminServiceImpl</td><td></td><td>JedisPoolUtils</td><td>Order</td></tr><tr><td>CallbackServlet</td><td></td><td></td><td>MailUtils</td><td>OrderItem</td></tr><tr><td>PrdocutServlet</td><td></td><td></td><td>MD5Utils</td><td>PageBean</td></tr><tr><td>RegisterServlet</td><td></td><td></td><td>PaymentUtil</td><td>Product</td></tr><tr><td>UserServlet</td><td></td><td></td><td></td><td>User</td></tr></tbody></table><p>3.3.2 系统主要配置文件</p><p>c3p0-config.xml负责数据库连接配置。</p><p>redis.properties负责redis端口属性配置。</p><p>Bean.xml配置AdminServiceImpl的清单。</p><p>Web.xml配置jsp清单。</p><p>3.4 具体功能模块的实现    </p><p>3.4.1前台分类信息展示</p><p>在head.jsp中有以下js代码：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps11.jpg" alt="img"> </p><p>图3-1 主页head栏</p><p>通过Ajax方式，首先访问CategoryServlet中的findCategory()方法，查询并以json格式返回Category的List集合db.cname即是最终导航栏显示的分类信息。</p><p>点击某一个分类后，会访问ProductServlet中的findPage()方法，传递当前页数：1和分类ID：cid。</p><p>3.4.2分类商品的分页展示</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps12.jpg" alt="img"> </p><p>图3-2 分类商品首页图</p><p>Dao层查询每页显示的数据（select * from product where cid = ? limit ?,?），Service层调用Dao后再进行条数页数的设置并封装进javabean，返回给servlet。</p><p>Servlet中的findPage()方法：</p><p>首先获取分类的ID：String cid = request.getParameter(“cid”);</p><p>然后获取当前页数：</p><p>int pageNumber =Integer.parseInt(request.getParameter(“pageNumber”));</p><p>之后设定每页显示的条数，带着参数调用service。将返回的PageBean对象和分类ID存储，供jsp页面使用。</p><p>Service层的findPage()方法：</p><p>List<product> list = pd.findPage(cid,pageNumber,pageSize);</product></p><p>封装的每页显示数据，按总条数和总页数进行封装。然后pageBean按每页显示的数据封装数据。</p><p>Servlet将pagebean存到request域中后，在jsp页面通过jstl遍历展示商品信息：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps13.jpg" alt="img"> </p><p>图3-3 产品分类显示</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps14.jpg" alt="img"> </p><p>图3-4 产品分类jsp代码</p><p>3.4.3单个商品详情</p><p>在商品列表页面有：</p><p>&lt;ahref=”${pageContext.request.contextPath}/product?method=productList&amp;cid=${cid }¤tPage=${currentPage}”&gt;</p><p>这是定义在每个商品图片上的超链接，点击后访问ProductServlet中的findBypid()方法，查询单个商品的详情。</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps15.jpg" alt="img"> </p><p>图3-5 产品单件商品信息页面</p><p>3.4.4最新和热门商品展示</p><p>首先，每个商品有一个是否热门属性和一个上架时间属性。加载主页面时，会从数据库中读取is_hot为1的所有商品作为热门商品，并加载时间最近的商品作为最新商品。href为${pageContext.request.contextPath}/product?method=productInfo&amp;pid=${hotPro.pid}。项目运行后直接访问ProductServlet中的findByNew()方法，查询最新最热商品信息，然后跳转到/jsp/index.jsp页面进行展示。</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps16.jpg" alt="img"> </p><p>图3-6 热门商品展示</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps17.jpg" alt="img"> </p><p>图3-7 最新商品展示</p><p>4 系统测试 </p><p>4.1 系统测试方法</p><p>测试方法采用了边界值，场景分析，等价类，用jmeter进行接测和压测。</p><p>4.2 系统测试用例</p><p>表4-1 系统测试</p><table><thead><tr><th>测试功能</th><th>测试用例序号</th><th>测试样例</th></tr></thead><tbody><tr><td>按类别查询商品首页</td><td>1</td><td>直接查询</td></tr><tr><td>分页展示分类商品</td><td>2</td><td>按种类添加删除商品信息</td></tr><tr><td>单个商品信息校验</td><td>3</td><td>修改部分商品信息</td></tr><tr><td>最热与最新商品展示</td><td>4</td><td>修改最热属性以及日期</td></tr></tbody></table><p>4.3 系统测试结果</p><p>表4-2 测试结果</p><table><thead><tr><th>测试用例序号</th><th>测试结果</th></tr></thead><tbody><tr><td>1</td><td>成功</td></tr><tr><td>2</td><td>成功</td></tr><tr><td>3</td><td>成功</td></tr><tr><td>4</td><td>成功</td></tr></tbody></table><p>5 总结</p><p>5.1 系统工作总结</p><p>​    我们这次首先应用到了MVC框架一开始使用的时候还有点生疏，但是在熟悉了以后，MVC框架的优点现了出来，它把前后台分开进行处理，我们在写后台逻辑的时候不需要考虑前端网页的布局，在写前端网页的时候也不需要在页面中插入后端的业务逻辑，这样让整个开发的过程变得十分明确，包括在查看源码的时候也不会眼花缭乱，当代码发生错误时，调试起来也能够快速的发现错误点，这是相较于之前没有框架使用的时候所没有的优越之处。同时，我们这次还用了C3P0的数据库池连接，它的优势之处就是比原本单纯的JDBC连接更加快捷，速度更快了。</p><p>5.2 存在的不足及改进</p><p>本系统由于涉及到支付功能，而支付又涉及到现金交易，因此该部分一直没有实现，经查阅资料了解到第三方支付平台的存在，但目前由于第三方支付平台账号问题目前支付功能具体还没有实现。之后会陆续对该部分进行改进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/qian-youyou/ShoppingNet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1 课题简介    &lt;/p&gt;
&lt;p&gt;1.1 背景及研究现状&lt;/p&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Java" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/"/>
    
    
      <category term="Java" scheme="http://qianyouyou.cn/tags/Java/"/>
    
      <category term="MVC" scheme="http://qianyouyou.cn/tags/MVC/"/>
    
      <category term="JavaWeb" scheme="http://qianyouyou.cn/tags/JavaWeb/"/>
    
      <category term="JSP" scheme="http://qianyouyou.cn/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>[转]unity pro 2019最新破解版 v2019.1.2f1</title>
    <link href="http://qianyouyou.cn/2019/05/29/2019-05-29/"/>
    <id>http://qianyouyou.cn/2019/05/29/2019-05-29/</id>
    <published>2019-05-29T13:58:15.000Z</published>
    <updated>2019-06-09T14:24:44.535Z</updated>
    
    <content type="html"><![CDATA[<p>由于unity更新，之前v2019.1.0a8破解版本更新为v2019.1.2f1，花了很长时间终于找到了破解方法。如下。</p><p>unity pro 2019破解版，其除了原程序还附带了破解补丁和许可文件，能够免费帮助用户破解得到一个可无限制免费使用所有功能的unity pro 2019，随后在下文会附上破解安装教程。</p><p>unity2019破解版安装说明</p><p>1、下载并解压本站提供的包，其包换了unity pro 2019原程序、破解补丁、许可文件。</p><p>2、先打开文件夹”addons”双击”UnityHubSetup-1.6.2.exe”依提示进行安装Unity Hub。</p><p>3、这里默认路径为【C:\Program Files\Unity Hub】</p><p>4、耐心等待安装完成后先不要运行该软件。</p><p>5、然后双击”UnitySetup64-2019.1.2f1.exe”依提示进行安装开始安装Unity。</p><p>6、这里默认路径为【C:\Program Files\Unity】</p><p>7、这里有点慢，请耐心等待安装。</p><p>8、安装完成后同样先不要运行该软件。</p><p>9、然后将本站提供的文件夹”crack”——“Hub”中的”app.asar”拖至【C:\Program Files\Unity Hub\resources】中并选择复制和替换即可。</p><p>10、接着选择”crack”进入到”Unity”选择用户自己需要的版本。</p><p>11、例如小编这里选择2019.1.0f2，那么就将文件夹里面的”Unity.exe”拖至【C:\Program Files\Unity\Editor】中并选择复制和替换即可。</p><p>12、然后将”2019.1.0f2”文件夹中的”Unity_lic.ulf”许可文件复制到【C:\ProgramData\Unity】中，如果C:驱动器没有ProgramData文件夹，则启用隐藏文件显示。是C:\ProgramData文件夹中没有Unity文件夹，那么就创建一个。</p><p>13、运行”Unity Hub”点击”Locate a Version”</p><p>14、找到unit.exe文件的路径即【C:\Program Files\Unity\Editor】点击”select sditor”</p><p>15、接着需要创建一个用于验证的新项目，点击”new”</p><p>16、安装所需的支持模块和附加组件。</p><p>17、耐心等待即可，到这里就已经全部破解完成了，用户就可以免费无限制使用unity pro 2019破解版了。</p><p><a href="https://pan.baidu.com/s/1Em7dYE8H8Q_EaUhqQIiv-Q?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=#list/path=%2F" target="_blank" rel="noopener">下载地址</a></p><p><a href="http://www.ddooo.com/softdown/144746.htm#dltab" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于unity更新，之前v2019.1.0a8破解版本更新为v2019.1.2f1，花了很长时间终于找到了破解方法。如下。&lt;/p&gt;
&lt;p&gt;unity pro 2019破解版，其除了原程序还附带了破解补丁和许可文件，能够免费帮助用户破解得到一个可无限制免费使用所有功能的uni
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Unity" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Unity/"/>
    
    
      <category term="Unity3D" scheme="http://qianyouyou.cn/tags/Unity3D/"/>
    
      <category term="Unity" scheme="http://qianyouyou.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb课程设计之网上商城</title>
    <link href="http://qianyouyou.cn/2019/05/25/2019-05-25/"/>
    <id>http://qianyouyou.cn/2019/05/25/2019-05-25/</id>
    <published>2019-05-25T04:19:27.000Z</published>
    <updated>2019-05-25T04:22:17.971Z</updated>
    
    <content type="html"><![CDATA[<p>最近一堆课设，总结随便写写吧。</p><h1 id="一、功能的演示"><a href="#一、功能的演示" class="headerlink" title="一、功能的演示"></a>一、功能的演示</h1><h3 id="1．用户模块"><a href="#1．用户模块" class="headerlink" title="1．用户模块"></a>1．用户模块</h3><p>用户注册功能</p><p>发送邮件</p><p>激活用户</p><p>表单的校验</p><p>用户的登录功能</p><p>自动登录</p><p>用户的注销功能</p><h3 id="2．商品模块"><a href="#2．商品模块" class="headerlink" title="2．商品模块"></a>2．商品模块</h3><p>首页热门商品和最新商品功能</p><p>商品分类</p><p>商品的列表（分页）</p><p>商品详细信息</p><p>浏览记录功能</p><h3 id="3．购物车模块"><a href="#3．购物车模块" class="headerlink" title="3．购物车模块"></a>3．购物车模块</h3><p>将商品加入购物车</p><p>展示购物车功能</p><h3 id="4．订单模块（多表和事务）"><a href="#4．订单模块（多表和事务）" class="headerlink" title="4．订单模块（多表和事务）"></a>4．订单模块（多表和事务）</h3><p>提交订单</p><p>展示订单</p><p>在线支付</p><h3 id="5．后台的分类的模块"><a href="#5．后台的分类的模块" class="headerlink" title="5．后台的分类的模块"></a>5．后台的分类的模块</h3><p>分类信息的增删改查</p><h3 id="6．后台的商品模块"><a href="#6．后台的商品模块" class="headerlink" title="6．后台的商品模块"></a>6．后台的商品模块</h3><p>商品的信息的增删改查（文件上传）</p><h3 id="7．后台的订单的模块"><a href="#7．后台的订单的模块" class="headerlink" title="7．后台的订单的模块"></a>7．后台的订单的模块</h3><p>所有的订单的信息展示</p><h1 id="二、一般项目开发流程（公司之间是有差异）"><a href="#二、一般项目开发流程（公司之间是有差异）" class="headerlink" title="二、一般项目开发流程（公司之间是有差异）"></a>二、一般项目开发流程（公司之间是有差异）</h1><p>1）确定项目需求—–拿下一个项目</p><p>2）编写《需求说明书》—-不涉及技术，只涉及业务需求</p><p>3）编写《概要设计说明书》—– 涉及技术的的宏观的内容，数据库设计，页面原型</p><p>4）编写《详细设计说明书》—– 相当于伪代码</p><p>5）编码阶段coding—-根据《详细设计说明书》— 单元测试</p><p>6）联测—–项目组内部的行为</p><p>7）测试组进行全面的专业测试—-《测试报告》</p><p>8）上线（测试阶段）</p><p>9）维护和二次开发</p><h1 id="三、网上商城项目的环境的搭建"><a href="#三、网上商城项目的环境的搭建" class="headerlink" title="三、网上商城项目的环境的搭建"></a>三、网上商城项目的环境的搭建</h1><p>(1) 创建项目Shop</p><p>(2) 创建项目的包结构</p><p>(3) 导入需要的jar/配置文件/工具/静态页面</p><p>(4) 编码</p><h1 id="四、业务分析与编码"><a href="#四、业务分析与编码" class="headerlink" title="四、业务分析与编码"></a>四、业务分析与编码</h1><h3 id="1．用户模块—注册"><a href="#1．用户模块—注册" class="headerlink" title="1．用户模块—注册"></a>1．用户模块—注册</h3><h4 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="(1)用户注册"></a>(1)用户注册</h4><p>基本点注册代码实现</p><p>分析：表单提交数据—-&gt;web层收集数据—-&gt;封装数据—–&gt;传递数据—&gt;三层架    构代码</p><h4 id="2-用户发送邮件"><a href="#2-用户发送邮件" class="headerlink" title="(2)用户发送邮件"></a>(2)用户发送邮件</h4><h4 id="3-用户激活"><a href="#3-用户激活" class="headerlink" title="(3)用户激活"></a>(3)用户激活</h4><p>邮箱中的链接</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml12844\wps1.jpg" alt="img"></td></tr></tbody></table><p>点击时 访问服务端进行激活功能的ActiveServlet</p><h4 id="4-表单校验"><a href="#4-表单校验" class="headerlink" title="(4)表单校验"></a>(4)表单校验</h4><h4 id="5-短信验证码"><a href="#5-短信验证码" class="headerlink" title="(5)短信验证码"></a>(5)短信验证码</h4><h4 id="6-图片验证码"><a href="#6-图片验证码" class="headerlink" title="(6)图片验证码"></a>(6)图片验证码</h4><p>前台对表单已经进行进行校验了，后台好需要对数据进行校验吗？—-需要！</p><h3 id="2．用户模块—登录"><a href="#2．用户模块—登录" class="headerlink" title="2．用户模块—登录"></a>2．用户模块—登录</h3><h3 id="3．关于servlet的抽取（重构）"><a href="#3．关于servlet的抽取（重构）" class="headerlink" title="3．关于servlet的抽取（重构）"></a>3．关于servlet的抽取（重构）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一堆课设，总结随便写写吧。&lt;/p&gt;
&lt;h1 id=&quot;一、功能的演示&quot;&gt;&lt;a href=&quot;#一、功能的演示&quot; class=&quot;headerlink&quot; title=&quot;一、功能的演示&quot;&gt;&lt;/a&gt;一、功能的演示&lt;/h1&gt;&lt;h3 id=&quot;1．用户模块&quot;&gt;&lt;a href=&quot;#1．用户
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>戳气球问题</title>
    <link href="http://qianyouyou.cn/2019/05/20/2019-05-20/"/>
    <id>http://qianyouyou.cn/2019/05/20/2019-05-20/</id>
    <published>2019-05-20T07:02:20.000Z</published>
    <updated>2019-05-20T11:45:25.733Z</updated>
    
    <content type="html"><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><p>输入: [3,1,5,8]<br>输出: 167<br>解释: nums = [3,1,5,8] –&gt; [3,5,8] –&gt;   [3,8]   –&gt;  [8]  –&gt; []<br>     coins =  315      +  358    +  138      + 181   = 167</p><p>思路：</p><p>可以利用区间动态规划，dp[i][j]表示i到j之间的最优解（不包括i，j），那么dp[i][j]就等于max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k])。</p><p>即我们假设求i到j之间的最优解，k为i和j之间的数，那么当前i到j之间以k为基准将要戳k（也就是k是i到j中最后一个戳的）的最优解就等于k左半部分最优解加k右半部分最优解加k、j、i的乘积，遍历k求出最大的一个就好了。当然dp初始值要为0，这样第一次戳i时dp[i-1][i+1]就理所当然等于0 + nums[i+1] <em> nums[i] </em> nums[i - 1] + 0。</p><p>nums首部先插入1，再在末尾补1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.insert(nums.begin(), 1);</span><br><span class="line">        nums.push_back(1);</span><br><span class="line">        dp.resize(nums.size(), vector&lt;int&gt;(nums.size(), 0));</span><br><span class="line">        for(int i = 2; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j + i &lt; nums.size(); ++j)&#123;</span><br><span class="line">                for(int k = j + 1; k &lt; j + i; ++k)&#123;</span><br><span class="line">                    dp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k][j + i] + nums[k] * nums[j] * nums[j + i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][nums.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间dp" scheme="http://qianyouyou.cn/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>日常笔记</title>
    <link href="http://qianyouyou.cn/2019/05/18/2019-05-18/"/>
    <id>http://qianyouyou.cn/2019/05/18/2019-05-18/</id>
    <published>2019-05-18T12:47:33.000Z</published>
    <updated>2019-05-20T12:12:44.847Z</updated>
    
    <content type="html"><![CDATA[<p>由于写一篇博客很很费劲，经常学习一天的内容写博客就得花费一天，费时费力。所以本篇博客主要记录一些日常琐碎的笔记。</p><h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><h2 id="面向过程C语言"><a href="#面向过程C语言" class="headerlink" title="面向过程C语言"></a>面向过程C语言</h2><h2 id="面向对象C"><a href="#面向对象C" class="headerlink" title="面向对象C++"></a>面向对象C++</h2><h3 id="C与C-的区别"><a href="#C与C-的区别" class="headerlink" title="C与C++的区别"></a>C与C++的区别</h3><p>C为面向过程语言，C++与C不是对立关系，而是包容关系。C++不仅包含面向过程的C，还可以面向对象，也可以泛型编程。简而言之，C++分为面向过程，面向对象，泛型编程模板，STL标准模板库四部分。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="::运算符"></a>::运算符</h3><p>作用域运算符，全局作用域直接加::</p><h3 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h3><p><strong>用途</strong> 解决名称冲突问题</p><ul><li>必须在全局作用域下声明</li><li>命名空间下可以放入 函数、变量、结构体、类等。</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时加入新的成员，添加并合并</li><li>匿名命名空间 static</li><li>可以起别名</li></ul><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h4><p>using std :: X，使用某变量或对象。如果该部分作用域已经存在同样的名称对象，则会产生二义性而报错。</p><h4 id="using编译命令"><a href="#using编译命令" class="headerlink" title="using编译命令"></a>using编译命令</h4><p>using namespace X，使用命名空间。跟编译器说的。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const int a = 10；不分配内存，只在编译器符号表中。</p><p>const int a = b；分配内存</p><p>C++默认const内链接，C外链接即默认extern。</p><h3 id="const与define"><a href="#const与define" class="headerlink" title="const与define"></a>const与define</h3><p>const有作用域，有类型。define无作用域，无类型</p><h2 id="泛型编程模板与STL"><a href="#泛型编程模板与STL" class="headerlink" title="泛型编程模板与STL"></a>泛型编程模板与STL</h2><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h2 id="系统编程"><a href="#系统编程" class="headerlink" title="系统编程"></a>系统编程</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="web编程"><a href="#web编程" class="headerlink" title="web编程"></a>web编程</h2><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于写一篇博客很很费劲，经常学习一天的内容写博客就得花费一天，费时费力。所以本篇博客主要记录一些日常琐碎的笔记。&lt;/p&gt;
&lt;h1 id=&quot;C-C&quot;&gt;&lt;a href=&quot;#C-C&quot; class=&quot;headerlink&quot; title=&quot;C/C++&quot;&gt;&lt;/a&gt;C/C++&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自底向上优先分析</title>
    <link href="http://qianyouyou.cn/2019/05/13/2019-05-13/"/>
    <id>http://qianyouyou.cn/2019/05/13/2019-05-13/</id>
    <published>2019-05-13T12:18:37.000Z</published>
    <updated>2019-05-13T14:16:02.695Z</updated>
    
    <content type="html"><![CDATA[<ul><li>优先分析法<ul><li>简单优先分析法<ul><li>按一定规则求出该文法所有符号即包括终结符和非终结符之间的优先关系。</li><li>实质是一种规范规约。</li><li>准确，规范，但效率低。</li><li>实用性不大。</li></ul></li><li>算符优先分析法<ul><li>只规定算符之间的优先关系，即仅终结符之间的优先关系。</li><li>不是规范规约。</li><li>不准确规范，但效率高。</li><li>采用适当方法加以弥补缺点。</li></ul></li></ul></li></ul><h1 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h1><h2 id="算符与普通-gt-lt-区别"><a href="#算符与普通-gt-lt-区别" class="headerlink" title="算符与普通=,&gt;,&lt;区别"></a>算符与普通=,&gt;,&lt;区别</h2><p>算符有顺序，例如a·=b和b·=a不一样。</p><p>普通算符无顺序，例如a&lt;b和b&gt;a一样。</p><h2 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h2><ul><li>X ·= Y(A→…XY…)<ul><li>S→bAa。b ·= A，A ·= a。</li></ul></li><li>X ·&lt; Y(A → …XB…, B ⇨ Y…)<ul><li>S→bAb，A +⇨ (B, A+⇨a。b ·&lt; (，b ·= a。</li></ul></li><li>X ·&gt; Y(A → …BD…,  B +⇨ …X，D *⇨ Y…)<ul><li>S→bAb，A +⇨ …), A+⇨B,A+⇨a。) ·&gt; b，a ·&gt; b， B ·&gt; b。</li></ul></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。</li><li>在文法中任意两个产生式没有相同的右部。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>将输入符号串a1a…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性·&gt;下一个带输入符号aj为止。</p><p>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;·ak，为止。</p><p>由句柄ak…ai在文法产生式中查找右部尾ak…ai的产生式，若找到则用左部代替句柄，若找不到则为出错，断定不合法。</p><p>重复1，2，3.直到只剩开始符为止。</p><h1 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h1><h2 id="优先关系-1"><a href="#优先关系-1" class="headerlink" title="优先关系"></a>优先关系</h2><p>和简单优先分析相比仅有终结符才能有优先级比较。其余优先符关系同于上式。</p><ul><li>a ·= b(A→…ab…或A→…aBb…)</li><li>a ·&lt; b(A → …aB…, B ⇨ b…或B ⇨ Cb…)</li><li>a ·&gt; b(A → …Bb…,  B ⇨ …a或B ⇨ …aC)</li></ul><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol><li>若一文法G中<strong>不存在</strong>A→…BC…，其中B,C为非终极符，则G为<strong>算符文法</strong>。</li><li>G为不含ε文法，满足算符优先关系。</li><li>若a与b之间只存在一种优先关系，则G为算符优先文法。</li></ol><h2 id="算符优先关系表构造"><a href="#算符优先关系表构造" class="headerlink" title="算符优先关系表构造"></a>算符优先关系表构造</h2><p>FIRSTVT(B) = {b | B +⇨ b…或B +⇨ Cb…}</p><p>LASTVT(B) = {a | B +⇨ …a 或B +⇨ …aC}</p><ol><li>·=：A→…ab…，若或A→…aBb…,则a·=b</li><li>·&lt;：A→…aB…，若b∈FIRSTVT(B)，则a·&lt;b</li><li>·&gt;：A→…Bb…，若a∈LASTVT(B)，则a·&gt;b</li></ol><h2 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/20190513_213009.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;优先分析法&lt;ul&gt;
&lt;li&gt;简单优先分析法&lt;ul&gt;
&lt;li&gt;按一定规则求出该文法所有符号即包括终结符和非终结符之间的优先关系。&lt;/li&gt;
&lt;li&gt;实质是一种规范规约。&lt;/li&gt;
&lt;li&gt;准确，规范，但效率低。&lt;/li&gt;
&lt;li&gt;实用性不大。&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>最少区间覆盖问题</title>
    <link href="http://qianyouyou.cn/2019/05/09/2019-05-09/"/>
    <id>http://qianyouyou.cn/2019/05/09/2019-05-09/</id>
    <published>2019-05-09T14:56:46.000Z</published>
    <updated>2019-05-11T13:01:54.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。</p><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>[2,3,1,1,1]</p><p>输出：</p><p>2</p><p>解释：</p><p>0-&gt;1-&gt;4</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>贪心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0, cnt = 0, maxn = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1 &amp;&amp; i &lt;= cnt; ++i)&#123;</span><br><span class="line">            if(nums[i] + i &gt; maxn)&#123;</span><br><span class="line">                maxn = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            if(maxn &gt;= nums.size() - 1)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i == cnt)&#123;</span><br><span class="line">                if(cnt != maxn)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>数组记录，及数组记录当前最优值，类似于筛法求素数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int solve(vector&lt;int&gt;v)&#123;</span><br><span class="line">    int len = v.size();</span><br><span class="line">    vector&lt;int&gt;dp(len, inf);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 0; i &lt; len &amp;&amp; dp[i] != inf; ++i)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= v[i]; ++j)&#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[i] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len - 1] != inf ? dp[len - 1] : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h2><p>排序，下标为左界，值＋下标为右值，构成区域块，选最少的块覆盖全部区域，覆盖不了等于到不了终点。左值（右值）排序后右值（左值）贪心比较。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚拿到该题，以为是做过的题，之前做的是能否到达终点。结果忽略了求最少的步数，写完才发现理解错了。然后就慌了，思路就混乱了。就没有然后了。</p><p>还是比较适合笔试题，一个人自在，心里有了包袱就自乱阵脚，好水的题都能出错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。&lt;/p&gt;
&lt;h2 id=&quot;样例：&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[转]探索C++虚函数在g++中的实现</title>
    <link href="http://qianyouyou.cn/2019/05/07/2019-05-07/"/>
    <id>http://qianyouyou.cn/2019/05/07/2019-05-07/</id>
    <published>2019-05-07T15:23:56.000Z</published>
    <updated>2019-05-07T15:37:30.142Z</updated>
    
    <content type="html"><![CDATA[<p>为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：</p><p>C++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base1::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base2::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void h() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::h()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Derived ins;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"></span><br><span class="line">    b1.f();</span><br><span class="line">    b2.g();</span><br><span class="line">    d.f();</span><br><span class="line">    d.g();</span><br><span class="line">    d.h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码采用了多继承，是为了更多的分析出g++的实现本质，用UML简单的画一下继承关系：</p><p>示例代码UML图</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-3.png" alt=""></p><p>代码的输出结果和预期的一致，C++实现了虚函数覆盖功能，代码输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::h()</span><br></pre></td></tr></table></figure><h2 id="开始分析！"><a href="#开始分析！" class="headerlink" title="开始分析！"></a>开始分析！</h2><p>我写这篇文章的重点是尝试解释g++编译在底层是如何实现虚函数覆盖和动态绑定的，因此我假定你已经明白基本的虚函数概念以及虚函数表（vtbl）和虚函数表指针（vptr）的概念和在继承实现中所承担的作用，如果你还不清楚这些概念，建议你在继续阅读下面的分析前先补习一下相关知识，陈皓的 <a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="noopener">《C++虚函数表解析》</a> 系列是一个不错的选择。</p><p>通过本文，我将尝试解答下面这三个问题：</p><ol><li>g++如何实现虚函数的动态绑定？</li><li>vtbl在何时被创建？vptr又是在何时被初始化？</li><li>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</li></ol><p>首先是第一个问题：</p><h3 id="g-如何实现虚函数的动态绑定？"><a href="#g-如何实现虚函数的动态绑定？" class="headerlink" title="g++如何实现虚函数的动态绑定？"></a>g++如何实现虚函数的动态绑定？</h3><p>这个问题乍看简单，大家都知道是通过vptr和vtbl实现的，那就让我们刨根问底的看一看，g++是如何利用vptr和vtbl实现的。</p><p>第一步，使用 -fdump-class-hierarchy 参数导出g++生成的类内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Vtable for Base1</span><br><span class="line">Base1::_ZTV5Base1: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base1)</span><br><span class="line">8     Base1::f</span><br><span class="line"></span><br><span class="line">Class Base1</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base1 (0xb6acb438) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base1::_ZTV5Base1) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Base2</span><br><span class="line">Base2::_ZTV5Base2: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base2)</span><br><span class="line">8     Base2::g</span><br><span class="line"></span><br><span class="line">Class Base2</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base2 (0xb6acb474) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base2::_ZTV5Base2) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Derived</span><br><span class="line">Derived::_ZTV7Derived: 8u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">8     Derived::f</span><br><span class="line">12    Derived::g</span><br><span class="line">16    Derived::h</span><br><span class="line">20    (int (*)(...))-0x000000004</span><br><span class="line">24    (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">28    Derived::_ZThn4_N7Derived1gEv</span><br><span class="line"></span><br><span class="line">Class Derived</span><br><span class="line">   size=8 align=4</span><br><span class="line">   base size=8 base align=4</span><br><span class="line">Derived (0xb6b12780) 0</span><br><span class="line">    vptr=((&amp; Derived::_ZTV7Derived) + 8u)</span><br><span class="line">  Base1 (0xb6acb4b0) 0 nearly-empty</span><br><span class="line">      primary-for Derived (0xb6b12780)</span><br><span class="line">  Base2 (0xb6acb4ec) 4 nearly-empty</span><br><span class="line">      vptr=((&amp; Derived::_ZTV7Derived) + 28u)</span><br></pre></td></tr></table></figure><p>如果看不明白这些乱七八糟的输出，没关系（当然能看懂更好），把上面的输出转换成图的形式就清楚了：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-2.png" alt=""></p><p>vptr和vtbl</p><p>其中有几点尤其值得注意：</p><ol><li>我用来测试的机器是32位机，所有vptr占4个字节，每个vtbl中的函数指针也是4个字节</li><li>每个类的主要（primal）vptr放在类内存空间的起始位置（由于我没有声明任何成员变量，可能看不清楚）</li><li>在多继承中，对应各个基类的vptr按继承顺序依次放置在类内存空间中，且子类与第一个基类共用同一个vptr</li><li>子类中声明的虚函数除了覆盖各个基类对应函数的指针外，还额外添加一份到第一个基类的vptr中（体现了共用的意义）</li></ol><p>有了内存布局后，接下来观察g++是如何在这样的内存布局上进行动态绑定的。</p><p>g++对每个类的指针或引用对象，如果是其类声明中虚函数，使用位于其内存空间首地址上的vptr寻找找到vtbl进而得到函数地址。如果是父类声明而子类未覆盖的虚函数，使用对应父类的vptr进行寻址。</p><p>先来验证一下，使用 objdump -S 得到 b1.f() 的汇编指令：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b1.f();</span><br><span class="line"> 8048734:       8b 44 24 24             mov    0x24(%esp),%eax    # 得到Base1对象的地址</span><br><span class="line"> 8048738:       8b 00                   mov    (%eax),%eax        # 对对象首地址上的vptr进行解引用，得到vtbl地址</span><br><span class="line"> 804873a:       8b 10                   mov    (%eax),%edx        # 解引用vtbl上第一个虚函数的地址</span><br><span class="line"> 804873c:       8b 44 24 24             mov    0x24(%esp),%eax</span><br><span class="line"> 8048740:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048743:       ff d2                   call   *%edx              # 调用函数</span><br></pre></td></tr></table></figure><p>其过程和我们的分析完全一致，聪明的你可能发现了，b2怎么办呢？Derived类的实例内存首地址上的vptr并不是Base2类的啊！答案实际上是因为g++在引用赋值语句 Base2 &amp;b2 = ins 上动了手脚：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Derived ins;</span><br><span class="line"> 804870d:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048711:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048714:       e8 c3 01 00 00          call   80488dc &lt;_ZN7DerivedC1Ev&gt;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line"> 8048719:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 804871d:       89 44 24 24             mov    %eax,0x24(%esp)</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line"> 8048721:       8d 44 24 1c             lea    0x1c(%esp),%eax   # 获得ins实例地址</span><br><span class="line"> 8048725:       83 c0 04                add    $0x4,%eax         # 添加一个指针的偏移量</span><br><span class="line"> 8048728:       89 44 24 28             mov    %eax,0x28(%esp)   # 初始化引用</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"> 804872c:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048730:       89 44 24 2c             mov    %eax,0x2c(%esp)</span><br></pre></td></tr></table></figure><p>虽然是指向同一个实例的引用，根据引用类型的不同，g++编译器会为不同的引用赋予不同的地址。例如b2就获得一个指针的偏移量，因此才保证了vptr的正确性。</p><p>PS：我们顺便也证明了C++中的引用的真实身份就是指针…</p><p>接下来进入第二个问题：</p><h3 id="vtbl在何时被创建？vptr又是在何时被初始化？"><a href="#vtbl在何时被创建？vptr又是在何时被初始化？" class="headerlink" title="vtbl在何时被创建？vptr又是在何时被初始化？"></a>vtbl在何时被创建？vptr又是在何时被初始化？</h3><p>既然我们已经知道了g++是如何通过vptr和vtbl来实现虚函数魔法的，那么vptr和vtbl又是在什么时候被创建的呢？</p><p>vptr是一个相对容易思考的问题，因为vptr明确的属于一个实例，所以vptr的赋值理应放在类的构造函数中。 g++为每个有虚函数的类在构造函数末尾中隐式的添加了为vptr赋值的操作 。</p><p>同样通过生成的汇编代码验证：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line"> 80488dc:       55                      push   %ebp</span><br><span class="line"> 80488dd:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80488df:       83 ec 18                sub    $0x18,%esp</span><br><span class="line"> 80488e2:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488e5:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488e8:       e8 d3 ff ff ff          call   80488c0 &lt;_ZN5Base1C1Ev&gt;</span><br><span class="line"> 80488ed:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488f0:       83 c0 04                add    $0x4,%eax</span><br><span class="line"> 80488f3:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488f6:       e8 d3 ff ff ff          call   80488ce &lt;_ZN5Base2C1Ev&gt;</span><br><span class="line"> 80488fb:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488fe:       c7 00 48 8a 04 08       movl   $0x8048a48,(%eax)</span><br><span class="line"> 8048904:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 8048907:       c7 40 04 5c 8a 04 08    movl   $0x8048a5c,0x4(%eax)</span><br><span class="line"> 804890e:       c9                      leave</span><br><span class="line"> 804890f:       c3                      ret</span><br></pre></td></tr></table></figure><p>可以看到在代码中，Derived类的构造函数为实例的两个vptr赋初值，可是，这两个初值居然是立即数！立即数！立即数！ 这说明了vtbl的生成并不是运行时的，而是在编译期就已经确定了存放在这两个地址上的 ！</p><p>这个地址不出意料的属于.rodata（只读数据段），使用 objdump -s -j .rodata 提取出对应的内存观察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">80489e0 03000000 01000200 00000000 42617365  ............Base</span><br><span class="line"> 80489f0 313a3a66 28290042 61736532 3a3a6728  1::f().Base2::g(</span><br><span class="line"> 8048a00 29004465 72697665 643a3a66 28290044  ).Derived::f().D</span><br><span class="line"> 8048a10 65726976 65643a3a 67282900 44657269  erived::g().Deri</span><br><span class="line"> 8048a20 7665643a 3a682829 00000000 00000000  ved::h()........</span><br><span class="line"> 8048a30 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048a40 00000000 a08a0408 34880408 68880408  ........4...h...</span><br><span class="line"> 8048a50 94880408 fcffffff a08a0408 60880408  ............`...</span><br><span class="line"> 8048a60 00000000 c88a0408 08880408 00000000  ................</span><br><span class="line"> 8048a70 00000000 d88a0408 dc870408 37446572  ............7Der</span><br><span class="line"> 8048a80 69766564 00000000 00000000 00000000  ived............</span><br><span class="line"> 8048a90 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048aa0 889f0408 7c8a0408 00000000 02000000  ....|...........</span><br><span class="line"> 8048ab0 d88a0408 02000000 c88a0408 02040000  ................</span><br><span class="line"> 8048ac0 35426173 65320000 a89e0408 c08a0408  5Base2..........</span><br><span class="line"> 8048ad0 35426173 65310000 a89e0408 d08a0408  5Base1..........</span><br></pre></td></tr></table></figure><p>由于程序运行的机器是小端机，经过简单的转换就可以得到第一个vptr所指向的内存中的第一条数据为0x80488834，如果把这个数据解释为函数地址到汇编文件中查找，会得到：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">08048834 &lt;_ZN7Derived1fEv&gt;:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line"> 8048834:       55                      push   %ebp</span><br><span class="line"> 8048835:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048837:       83 ec 18                sub    $0x18,%esp</span><br></pre></td></tr></table></figure><p>Bingo！ g++在编译期就为每个类确定了vtbl的内容，并且在构造函数中添加相应代码使vptr能够指向已经填好的vtbl的地址 。</p><p>这也同时为我们解答了第三个问题：</p><p>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</p><p>直接看图：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-1.png" alt=""></p><p>虚函数在虚拟存储器中的位置</p><p>图中灰色部分应该是你已经熟悉的，彩色部分内容和相关联的箭头描述了虚函数调用的过程（图中展示的是通过new在堆区创建实例的情况，与示例代码有所区别，小失误，不要在意）： 当调用虚函数时，首先通过位于栈区的实例的指针找到位于堆区中的实例地址，然后通过实例内存开头处的vptr找到位于.rodata段的vtbl，再根据偏移量找到想要调用的函数地址，最后跳转到代码段中的函数地址执行目标函数 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>研究这些问题的起因是因为公司代码出现了非常奇葩的行为，经过追查定位到虚函数表出了问题，因此才有机会脚踏实地的对虚函数实现进行一番探索。</p><p>也许你会想，即使我不明白这些底层原理，也一样可以正常的使用虚函数，也一样可以写出很好的面相对象的代码啊？</p><p>这一点儿也没有错，但是，C++作为全宇宙最复杂的程序设计语言，它提供的功能异常强大，无异于武侠小说中锋利无比的屠龙宝刀。但武功不好的菜鸟如果胡乱舞弄宝刀，却很容易反被其所伤。只有了解了C++底层的原理和机制，才能让我们把C++这把屠龙宝刀使用的更加得心应手，变化出更加华丽的招式，成为真正的武林高手。</p><h1 id="转"><a href="#转" class="headerlink" title="转"></a>转</h1><p>本文转自<a href="http://blog.kongfy.com/2015/08/%E6%8E%A2%E7%B4%A2c%E8%99%9A%E5%87%BD%E6%95%B0%E5%9C%A8g%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.kongfy.com/2015/08/探索c虚函数在g中的实现/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：&lt;/p&gt;
&lt;p&gt;C++&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="多态" scheme="http://qianyouyou.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数表" scheme="http://qianyouyou.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>自顶向下语法分析指北</title>
    <link href="http://qianyouyou.cn/2019/05/05/2019-05-05/"/>
    <id>http://qianyouyou.cn/2019/05/05/2019-05-05/</id>
    <published>2019-05-05T03:43:44.000Z</published>
    <updated>2019-05-05T12:14:24.265Z</updated>
    
    <content type="html"><![CDATA[<ul><li>语法分析<ul><li>自顶向下语法分析<ul><li>确定分析</li><li>不确定分析</li></ul></li><li>自底向上语法分析<ul><li>算符优先分析</li><li>LR分析</li></ul></li></ul></li></ul><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="确定分析-LL-1-文法"><a href="#确定分析-LL-1-文法" class="headerlink" title="确定分析(LL(1)文法)"></a>确定分析(LL(1)文法)</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>G[S]:</p><p>S -&gt; pA | qB</p><p>A -&gt; cAd | a</p><p>B -&gt; dB | b</p><p>W = pccadd。</p><p>推导过程如下：S =&gt; pA =&gt; pcAd =&gt; pccAdd =&gt; pccadd。</p><ul><li>​          S                      S                          S                          S<br> ​        /    \                    /    \                        /    \                        /    \<br> ​       p      A    =&gt;          p      A        =&gt;          p      A        =&gt;          p      A<pre><code>/   |   \                       /   |   \                      /   |   \</code></pre>  ​                        c     A     d                c     A     d                c     A     d<pre><code>/   |   \                      /   |   \</code></pre>  ​                                            c     A     d                c     A     d<br>  ​                                                                       |<pre><code>a</code></pre></li></ul><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>G[S]：</p><p>S-&gt;Ap</p><p>S-&gt;Bq</p><p>A-&gt;a</p><p>A-&gt;cA</p><p>B-&gt;b</p><p>B-&gt;dB</p><p>W = ccap，推导过程：</p><p>S =&gt; aP =&gt; cAp =&gt; ccAp =&gt; ccap。</p><h3 id="FIRST-a"><a href="#FIRST-a" class="headerlink" title="FIRST(a)"></a>FIRST(a)</h3><p>a的开始符号集或首符号集。</p><p>例2：FIRST(Ap) = {a, c}。</p><p>FIRST(Bq) = {b, d}。</p><p>FIRST(S) = {a, b, c, d}。</p><p>###FOLLOW(A)</p><p>若Aa，a ∈ FOLLOW(A)。若a = ε，则# ∈ FOLLOW(A)。</p><h3 id="SELECT-A-gt-a"><a href="#SELECT-A-gt-a" class="headerlink" title="SELECT(A-&gt;a)"></a>SELECT(A-&gt;a)</h3><p>a不为ε，则SELECT(A-&gt;a) = FIRST(a)。</p><p>否则，SELECT(A-&gt;a) = FIRST(a) - ε + FOLLOW(A)。</p><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>第1个L表示从左往右扫描字符串。</p><p>第2个L表示采用最左推导。</p><p>1表示只需向右看1个字符即可选择哪个产生式。（为了提高效率，最多为2）。</p><h4 id="充要条件："><a href="#充要条件：" class="headerlink" title="充要条件："></a>充要条件：</h4><p>SELLECT(A-&gt;a) ∩ SELECT(A-&gt;b) = 空集。（a，b不能同时能ε）。</p><p>通俗理解就是a和b不能有相同前缀。</p><h4 id="LL-1-文法判别步骤"><a href="#LL-1-文法判别步骤" class="headerlink" title="LL(1)文法判别步骤"></a>LL(1)文法判别步骤</h4><p>求出能推出 ε 的非终结符。（未定，是，否）</p><p>计算FIRST集</p><p>计算FOLLOW集</p><p>计算SELECT集</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="递归子程序法"><a href="#递归子程序法" class="headerlink" title="递归子程序法"></a>递归子程序法</h4><p>对应文法中每个非终结符编写一个递归过程，每个过程的功能是识别由非终结符推出的串，当某非终结符的产生式有多个候选时能够按LL(1)形式可唯一确定地选择某个候选进行推导。</p><p>当文法满足LL(1)条件时，构造不带回溯的自上而下分析程序。</p><p>该分析程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>不是所有的aij的first集的交集都为空，仅针对一个VN的候选式有如此的约定。</p><h4 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征 :"></a>特征 :</h5><p>根据当前输入符号，为当前要处理的非终结符选择产生式。</p><p>表驱动的预测分析器包含：</p><ul><li>一个输入缓冲区</li><li>一个栈</li><li>一张分析表</li><li>一个输出流</li></ul><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-1.png" alt=""></p><h5 id="预测分析表M"><a href="#预测分析表M" class="headerlink" title="预测分析表M"></a>预测分析表M</h5><p>预测分析表是一个M[A，a]形式的矩阵。</p><p>其中： A为非终结符，a为终结符或#。</p><p>M[A，a]中存放着一条关于A的产生式，指出当A面临a时所应采取的候选；</p><p>M[A，a]中也可能存放一条“出错标志”，指出Ａ不应该面临a。</p><p>例：对于文法G       </p><ol><li>E→TE’</li><li>E’ → +TE’|ε</li><li>T →FT’</li><li>T’→*FT’| ε</li><li>F→(E)|id  </li></ol><p>其预测分析表为：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-2.png" alt="1557056948767"></p><p>解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FIRST(E)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(E’)=&#123;+, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T’)=&#123; *, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(F)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E) =&#123;#, )&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E’)=&#123;), #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T’)=&#123;+, ),  # &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T) =&#123;+, ),  #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(F) =&#123;id, ), *,  #&#125;</span><br></pre></td></tr></table></figure><h5 id="预测分析器"><a href="#预测分析器" class="headerlink" title="预测分析器"></a>预测分析器</h5><p>预测分析程序的算法：</p><ul><li><p>输入：串w和文法G的分析表M</p></li><li><p>输出：如果w属于L（G），则输出w的最左推导，否则报错</p></li><li><p>方法：开始时，#S在栈里，w#在输入缓冲区</p><p>令ip指向w #的第一个符号，令X是栈顶符号，a是ip指向的符号</p></li></ul><p>预测分析器的工作方式：当前栈顶符号X和当前输入符号为a，则语法分析器的动作为：</p><ol><li>如果X=a≠#，则POP，advance</li><li>如果X ∈VN,查M[X，a]表，若M[X，a]=X→UVW,则用WVU替换栈顶；若M[X，a]=error,则调用错误恢复程序。</li><li>如果X=a=#,分析成功。</li></ol><p>句子id+id*id的分析过程：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-3.png" alt="1557057317524"></p><h2 id="不确定分析（简）"><a href="#不确定分析（简）" class="headerlink" title="不确定分析（简）"></a>不确定分析（简）</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>匹配，匹配不了回溯继续匹配，直到全部匹配不了或匹配成功为止。（非常暴力）</p><ol><li><p>由于相同左部的产生式的右部FIRST集交集不为空而引起回溯。</p><p>S-&gt;xAy</p><p>S-&gt;ab|a</p></li><li><p>由于相同左部非终结符的右部可为 ε ，且非终结符的FOLLOW集中含有其他产生式右部FIRST集的元素。</p><p>S-&gt;aAS</p><p>S-&gt;b</p><p>A-&gt;bAS</p><p>A-&gt;ε</p></li><li><p>由于文法含有左递归。</p><p>S-&gt;Sa</p><p>S-&gt;b</p></li></ol><h2 id="部分不确定分析转确定分析"><a href="#部分不确定分析转确定分析" class="headerlink" title="部分不确定分析转确定分析"></a>部分不确定分析转确定分析</h2><h3 id="左递归消除"><a href="#左递归消除" class="headerlink" title="左递归消除"></a>左递归消除</h3><h4 id="直接左递归消除"><a href="#直接左递归消除" class="headerlink" title="直接左递归消除"></a>直接左递归消除</h4><p>采用下列变换公式消除直接左递归，把直接左递归改写为右递归。</p><p>如：G[S]： S→Sa | b</p><p>可改写为：</p><p>S→bS’</p><p>S’→aS’|ε </p><p>改写后的文法所描述的L(G)={ba^n| n&gt;=0}</p><p>一般而言，假定关于P的全部产生式是</p><p>P→Pa1 | Pa2 | … | Pam | b1 | b2|…|bn 其中，每个a都不等于ε，而每个都不以P开头，那么，消除P的直接左递归性就是改写这些规则：</p><p>P→b1P’ | b2P’ | … | bnP’</p><p>P’→a1P’ | a2P’ |… | amP’ | ε </p><h4 id="间接左递归消除"><a href="#间接左递归消除" class="headerlink" title="间接左递归消除"></a>间接左递归消除</h4><p>间接左递归的消除需先将间接左递归变为直接左递归，然后再按第1种方法消除直接左递归。</p><h5 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h5><p>将一个产生式规则右部的a中的Vn N替换为N的候选式。如果N有n个候选式，右边a重复n次，而且每一次重复都有N的不同候选式来代替N。</p><p>例如：N →a | Bc | ε  在S→Nq中的代入结果S→aq | Bcq | q。</p><h3 id="回溯消除"><a href="#回溯消除" class="headerlink" title="回溯消除"></a>回溯消除</h3><p>回溯产生的根源：头字符集合的问题。例如A-&gt;ab|a。</p><h4 id="提取公因子"><a href="#提取公因子" class="headerlink" title="提取公因子"></a>提取公因子</h4><p>经过反复提取左因子，就能够把每个非终结符（包括新引进者）的所有候选首符集变成为两两不相交。</p><p>例：考察文法G[S]:</p><p>S → iCtS | iCtSeS | aC → b </p><p>解：由于S的前两个候选项中含有左因子iCtS，提取左因子之后，等价文法G’如下：</p><p>S → iCtSS’ | a</p><p>S’ →eS |ε</p><p>C → b</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;语法分析&lt;ul&gt;
&lt;li&gt;自顶向下语法分析&lt;ul&gt;
&lt;li&gt;确定分析&lt;/li&gt;
&lt;li&gt;不确定分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上语法分析&lt;ul&gt;
&lt;li&gt;算符优先分析&lt;/li&gt;
&lt;li&gt;LR分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="语法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>语法分析与词法分析指北</title>
    <link href="http://qianyouyou.cn/2019/05/01/2019-05-01/"/>
    <id>http://qianyouyou.cn/2019/05/01/2019-05-01/</id>
    <published>2019-05-01T13:41:32.000Z</published>
    <updated>2019-05-05T11:38:29.554Z</updated>
    
    <content type="html"><![CDATA[<p>程序编译过程：</p><p>源程序 -&gt; 词法分析程序 -&gt; <strong>语法分析程序</strong> -&gt; <strong>语义分析程序</strong> -&gt; 中间代码生成程序 -&gt; 代码优化程序 -&gt; 目标代码生成程序 -&gt; 目标程序</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>例：</p><p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p><p>&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;</p><p>&lt;代词&gt; → 你 | 我 | 他</p><p>&lt;名词&gt; → 老王 | 大学生 | 英语</p><p>&lt;谓语&gt; → &lt;动词&gt;&lt;直接宾语&gt;</p><p>&lt;动词&gt; → 是 | 学习 | 热爱</p><p>&lt;直接宾语&gt; → &lt;代词&gt; | &lt;名词&gt;</p><p>“我是大学生”符合以上规则，是句子。“我大学生是”不符合上面规则，不是句子。</p><p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p><p>→ &lt;代词&gt;&lt;谓语&gt;</p><p>→ 我&lt;谓语&gt;</p><p>→ 我&lt;动词&gt;&lt;直接宾语&gt;</p><p>→ 我是&lt;直接宾语&gt;</p><p>→ 我是&lt;名词&gt;</p><p>→ 我是大学生</p><h2 id="符号和字符串"><a href="#符号和字符串" class="headerlink" title="符号和字符串"></a>符号和字符串</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表即符号集，例如汉字的字母表包括汉字，数字标点等，C语言包括if，while之类的保留字组成。</p><h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p>由字母表中的符号组成的任何又穷序列（顺序很重要）。例如A = {a, b, c}的符号串有a，b，ab，ba， aa等等。</p><h3 id="符号串的头尾，固有头固有尾"><a href="#符号串的头尾，固有头固有尾" class="headerlink" title="符号串的头尾，固有头固有尾"></a>符号串的头尾，固有头固有尾</h3><p>abc的头是 ε, a, ab, abc，除abc外均为固有头。尾是ε, c, bc, abc，除abc外均为固有尾。</p><h3 id="符号串方幂"><a href="#符号串方幂" class="headerlink" title="符号串方幂"></a>符号串方幂</h3><p>x = AB。x^0 = ε。x^1 = AB。x^2 = ABAB。x^3 = ABABAB。</p><h3 id="符号串的集合"><a href="#符号串的集合" class="headerlink" title="符号串的集合"></a>符号串的集合</h3><p>A = {a, b}。B = {c, d}。AB = {ac, ad, bc, bd}。</p><h2 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h2><p>G(VN, VT, P, S)。</p><p>VN为非终结符（例如&lt;谓语&gt;，可以继续转换。通常用大写字母表示，例如A）</p><p>VT为终结符（例如“老王”，可直接匹配，不能再向下转换。通常用小写字母表示，例如a）</p><p>P（规则，例如&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;。又例如S →Aa）。</p><p>S起点（例如&lt;句子&gt;就是起点）</p><h2 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h2><p>3型∈2型∈1型∈0型，3型最严谨，向右兼容。</p><h3 id="0型递归文法"><a href="#0型递归文法" class="headerlink" title="0型递归文法"></a>0型递归文法</h3><p>a→b，a至少含1个非终结符，b为任意。</p><p>凡是递归可枚举的都是0型，包括A→ε，aA→aa等情况。</p><h3 id="1型上下文有关文法"><a href="#1型上下文有关文法" class="headerlink" title="1型上下文有关文法"></a>1型上下文有关文法</h3><p>a→b，a至少含1个非终结符，b不为ε。</p><p>0型除去ε的情况就是1型。也就是非终结符不能为ε。</p><p>包括aA→aa等情况。</p><h3 id="2型上下文无关文法"><a href="#2型上下文无关文法" class="headerlink" title="2型上下文无关文法"></a>2型上下文无关文法</h3><p>a→b，a必须是非终结符（only one）。</p><p>不包括aA→aa等情况。</p><p>可以A→aa。</p><h3 id="3型正规文法"><a href="#3型正规文法" class="headerlink" title="3型正规文法"></a>3型正规文法</h3><p>非终结符转换时头必须有一个终结符。例如：</p><p>S→aB</p><p>S→bA</p><p>A→a</p><p>A→aS</p><p>A→bAA</p><p>B→b</p><p>B→bS</p><p>B→aBB</p><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01.png" alt=""></p><h2 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h2><ul><li>自顶向下语法分析（由S向句子推，最终和句子匹配，看能否得到句子）</li><li>自底向上语法分析（由句子向S推，最终看能否得到S）</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>输入源程序；扫描、分解字符串，识别出一个个单词（定义符、标识符、运算符、界符、常数）</p><h2 id="词法分析输出"><a href="#词法分析输出" class="headerlink" title="词法分析输出"></a>词法分析输出</h2><p>读入源程序，输出担此符号。单词符号可分为以下5种：</p><p>关键字（if，else，while，int等）</p><p>标识符（a，fun，val等自定义的变量名）</p><p>常数（1，1.2，true，“abc”）</p><p>运算符（+，-，=，&lt;=，==）</p><p>界符（，；’)’）等。</p><p>词法分析输出单词符号常常采用二元组形式（单词种别，单词自身值）。</p><h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>扫描阶段：从左向右扫描输入源程序，删除注释、压缩空白字符；</p><p>词法分析阶段：按照语言的词法规则识别各类单词，并产生相应的单词符号。</p><h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>&lt;标识符&gt; → l | l &lt;字母数字&gt;</p><p>&lt;字母数字&gt; → l | d |l &lt;字母数字&gt; | d&lt;字母数字&gt;</p><p>（l字母，d数字）</p><p>例如:</p><p>A→aB</p><p>A→a</p><h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>a            {a}</p><p>a|b            {a,b}</p><p>ab            {ab}</p><p>(a|b)(a|b)    {aa,ab,ba,bb}</p><p>a*            {ε,a,aa,aaa…}</p><p>(a|b)*        {ε,a,aab,abaa…所有a,b组成的串}</p><p>(a|b)*(aa|bb)(a|b)*        {aaabbaab……}</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="确定有穷自动机-DFA"><a href="#确定有穷自动机-DFA" class="headerlink" title="确定有穷自动机(DFA)"></a>确定有穷自动机(DFA)</h3><p>DFA M = （K, ∑, f, S, Z）</p><p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p><p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p><p>f：转换函数，一个节点通过某条边到另一个结点（或自身）。</p><p>S：唯一一个初态（起点）</p><p>Z：终态集。（就是终点的集合）</p><h3 id="不确定有穷自动机-NFA"><a href="#不确定有穷自动机-NFA" class="headerlink" title="不确定有穷自动机(NFA)"></a>不确定有穷自动机(NFA)</h3><p>NFA M = （K, ∑, f, S, Z）</p><p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p><p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p><p>f：转换函数，一个节点通过某一类边到另外许多结点的集合（或自身）。</p><p>S：初态集（多个起点）</p><p>Z：终态集。（就是终点的集合）</p><p>很容易发现，不确定有穷自动机和确定有穷自动机的区别就是DFA每个结点每类单向边只有一条，且起点只有一个，而NFA可以有多条，且起点可以有多个。例如NFA中S—a—&gt;A，S—a,b—&gt;S，S—a,b—&gt;D，但DFA不允许，a，b由S指向其他结点（或自身）的话只能存在一条。</p><h2 id="正则式转自动机"><a href="#正则式转自动机" class="headerlink" title="正则式转自动机"></a>正则式转自动机</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-1.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-2.png" alt=""></p><h2 id="正规文法转自动机"><a href="#正规文法转自动机" class="headerlink" title="正规文法转自动机"></a>正规文法转自动机</h2><p>正规文法由于为第3型文法，所以S→aA，S为起点，→为边，a为边名，A为下一个结点。</p><h2 id="NFA转DFA"><a href="#NFA转DFA" class="headerlink" title="NFA转DFA"></a>NFA转DFA</h2><p><a href="https://blog.csdn.net/dala_da/article/details/78704560" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序编译过程：&lt;/p&gt;
&lt;p&gt;源程序 -&amp;gt; 词法分析程序 -&amp;gt; &lt;strong&gt;语法分析程序&lt;/strong&gt; -&amp;gt; &lt;strong&gt;语义分析程序&lt;/strong&gt; -&amp;gt; 中间代码生成程序 -&amp;gt; 代码优化程序 -&amp;gt; 目标代码生成程序 -&amp;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="语法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="词法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
