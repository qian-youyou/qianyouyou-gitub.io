<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2019-03-04T12:46:49.414Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++运算符重载之智能指针</title>
    <link href="http://qianyouyou.cn/2019/03/04/2019-03-04/"/>
    <id>http://qianyouyou.cn/2019/03/04/2019-03-04/</id>
    <published>2019-03-04T12:36:12.000Z</published>
    <updated>2019-03-04T12:46:49.414Z</updated>
    
    <content type="html"><![CDATA[<p>C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 </p><p>既然有了需求，对此，我们可以自行打造智能指针。</p><p>Person类有show_age()成员函数。</p><p>如果new出来的Person对象，那么必须由我们自行delete。</p><p>有了智能指针，就可以让智能指针托管这个对象，这个对象的释放就不用担心了，由智能指针自动进行管理。</p><p>为了让智能指针像普通指针一样方便实用，就要重载 -&gt; 与解引用 * 运算符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person():age(0)&#123;&#125;</span><br><span class="line">Person(int age):age(age)&#123;&#125;</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show_age() &#123;</span><br><span class="line">cout &lt;&lt; &quot;我的年龄是&quot; &lt;&lt; this-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">public:</span><br><span class="line">SmartPointer():person(NULL)&#123;&#125;</span><br><span class="line">SmartPointer(Person*person) &#123;</span><br><span class="line">this-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">~SmartPointer() &#123;</span><br><span class="line">if (person != NULL) &#123;</span><br><span class="line">delete person;</span><br><span class="line">person = NULL;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;智能指针析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Person* operator -&gt;() &#123;</span><br><span class="line">return this-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; operator *() &#123;</span><br><span class="line">return *this-&gt;person;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">Person *person;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">//Person p1(10);</span><br><span class="line">//p1.show_age();</span><br><span class="line">//Person *p1 = new Person(10);</span><br><span class="line">//p1-&gt;show_age();</span><br><span class="line">//delete p1;</span><br><span class="line">SmartPointer sp(new Person(10));</span><br><span class="line">sp-&gt;show_age();</span><br><span class="line">(*sp).show_age();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="C++基础" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="重载" scheme="http://qianyouyou.cn/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://qianyouyou.cn/2019/02/28/2019-02-28/"/>
    <id>http://qianyouyou.cn/2019/02/28/2019-02-28/</id>
    <published>2019-02-28T09:58:51.000Z</published>
    <updated>2019-03-06T10:53:17.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式  "></a>联系方式<div style="float:right"> <img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-02-28.jpg" width="200"> </div></h1><ul><li>手机1：152-0292-4489</li><li>手机2：152-4914-4478</li><li>Email：<a href="mailto:15249144478@163.com" target="_blank" rel="noopener">15249144478@163.com</a></li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li><strong>王骏</strong>/男/1998.10</li><li>陕西科技大学/计算机科学与技术</li><li>教育时间：本科/2016.8<em>-</em>2020.6</li><li>技术博客：<a href="http://qianyouyou.cn">http://qianyouyou.cn</a></li><li>GitHub：<a href="http://github.com/qian-youyou" target="_blank" rel="noopener">http://github.com/qian-youyou</a></li><li>期望职位：后端开发（实习），C/C++开发（实习）</li><li>期望城市：西安，杭州，成都，深圳，北京，南京，广州，苏州，武汉</li></ul><h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><h2 id="学校外包项目小组（-2017-11-2017-12-）"><a href="#学校外包项目小组（-2017-11-2017-12-）" class="headerlink" title="学校外包项目小组（ 2017.11 ~ 2017.12 ）"></a>学校外包项目小组（ 2017.11 ~ 2017.12 ）</h2><h3 id="狼王项目（负责网络爬虫）"><a href="#狼王项目（负责网络爬虫）" class="headerlink" title="狼王项目（负责网络爬虫）"></a>狼王项目（负责网络爬虫）</h3><p>在小组内主要负责爬虫工作，爬取静态网页URL。利用Python的BeautifulSoup库爬取工标网上的GB信息到MySQL数据库。之后方便小组搭建网站。</p><h1 id="获奖经历"><a href="#获奖经历" class="headerlink" title="获奖经历"></a>获奖经历</h1><p>ACM-ICPC国际大学生程序设计竞赛——亚洲区域赛焦作站——铜奖（2018.11.25）</p><p>ACM-ICPC国际大学生程序设计竞赛——亚洲区域赛青岛站——参与（2018.11.04）</p><p>ACM-ICPC国际大学生程序设计竞赛——全国邀请赛宁夏站——铜奖（2018.06.10）</p><p>ACM-ICPC国际大学生程序设计竞赛——全国邀请赛西安站——参与（2018.05.21）</p><p>2018第九届蓝桥杯大赛——省级二等奖（2018.04.01）</p><p>第4届陕西科技大学C语言大赛——校级二等奖（2018.03）</p><p>第5届陕西科技大学C语言大赛——校级三等奖（2018.11）</p><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><ul><li>熟练使用C/C++进行项目开发，熟悉Windows和Linux工作环境下C和C++开发。 </li><li>擅长数据结构与算法分析及优化，尤其擅长图论与数论算法，例如网络流（Dinic最大流，MCMF费用流等），最短路SPFA+SLF与LLL优化，Dijkstra+heap优化，Tarjan强连通算法，A*搜索，KM+slack优化，匈牙利算法+时间戳优化，KMP+Trie树，线段树，字符串hash，加权并查集，矩阵快速幂等等。</li><li>熟练使用Linux操作系统， 了解Linux环境下编程及进程间通信，多线程编程。 </li><li>具有网络基础知识， 熟悉TCP/IP协议，了解Socket网络编程。 </li><li>了解Python、Shell等脚本编程语言。</li><li>了解HTML5、CSS等前端语言，能够独立制作静态网页。</li><li>其他：数据库——MySQL，工具——Git</li></ul><h1 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h1><p>一个爱学习，知上进，善沟通，重思考，懂感恩的人。</p><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;联系方式&quot;&gt;&lt;a href=&quot;#联系方式&quot; class=&quot;headerlink&quot; title=&quot;联系方式  &quot;&gt;&lt;/a&gt;联系方式&lt;div style=&quot;float:right&quot;&gt; &lt;img src=&quot;https://qianyouyou-1258651414.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[设计模式]单例模式案例之打印机案例</title>
    <link href="http://qianyouyou.cn/2019/02/27/2019-02-27/"/>
    <id>http://qianyouyou.cn/2019/02/27/2019-02-27/</id>
    <published>2019-02-27T10:41:14.000Z</published>
    <updated>2019-02-27T11:05:36.164Z</updated>
    
    <content type="html"><![CDATA[<p>当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模式的案例，比如一个国家只有一个主席，即使主席替换，依然只有一个主席。比如某个教室只有一台打印机，那么无论多少人需要使用打印机，都将只能使用这一台打印机。也就是说该对象有且只能创建一个。</p><p>接下来我们总结一下单例模式的流程：</p><p>1.目的让类中只有一个对象，对象不需要自己释放。</p><p>2.将默认构造函数与拷贝构造函数私有化。</p><p>3.内部维护一个对象指针。</p><p>4.私有化唯一指针。</p><p>5.对外提供方法访问该指针。</p><p>6.保证了类中只能实例化唯一对象。</p><p>我们以打印机为例，某教室只有一台打印机，该打印机一次只能供一个人使用。</p><p>我们先来分析打印机，打印机具有打印功能，具有启动功能，具有关闭功能。而且具有一次只能供一人使用的特性，因此创建类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">static PrintingPress*getInstance() &#123;</span><br><span class="line">return unique;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">void openPrinting() &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void closePrinting() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void usingPrinting(string str) &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress() &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">static PrintingPress* unique;</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br></pre></td></tr></table></figure><p>用户具有使用打印机打印内容的功能，具有关闭打印机的功能，具有打开打印机的功能。因此创建用户类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">void us() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void us(string str) &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void op() &#123;</span><br><span class="line">if (p-&gt;check() == false) &#123;</span><br><span class="line">p-&gt;openPrinting();</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cl() &#123;</span><br><span class="line">if (flag = true) &#123;</span><br><span class="line">p-&gt;closePrinting();</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下代码是用C++写的一个简单的打印机案例测试代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#define CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class PrintingPress &#123;</span><br><span class="line">public:</span><br><span class="line">static PrintingPress*getInstance() &#123;</span><br><span class="line">return unique;</span><br><span class="line">&#125;</span><br><span class="line">bool check() &#123;</span><br><span class="line">return flag;</span><br><span class="line">&#125;</span><br><span class="line">void openPrinting() &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void closePrinting() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">flag = false;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void usingPrinting(string str) &#123;</span><br><span class="line">if (flag == false) &#123;</span><br><span class="line">cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress() &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">PrintingPress(const PrintingPress&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl;</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">static PrintingPress* unique;</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">PrintingPress* PrintingPress::unique = new PrintingPress;</span><br><span class="line">class user &#123;</span><br><span class="line">public:</span><br><span class="line">void us() &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void us(string str) &#123;</span><br><span class="line">if (flag == true) &#123;</span><br><span class="line">cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl;</span><br><span class="line">p-&gt;usingPrinting(str);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void op() &#123;</span><br><span class="line">if (p-&gt;check() == false) &#123;</span><br><span class="line">p-&gt;openPrinting();</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void cl() &#123;</span><br><span class="line">if (flag = true) &#123;</span><br><span class="line">p-&gt;closePrinting();</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">PrintingPress* p = PrintingPress::getInstance();</span><br><span class="line">bool flag = false;</span><br><span class="line">&#125;;</span><br><span class="line">void test() &#123;</span><br><span class="line">user tmp[3];</span><br><span class="line">tmp[1].op();</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[1].us(&quot;lalalalala&quot;);</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[1].cl();</span><br><span class="line">tmp[2].op();</span><br><span class="line">tmp[2].us(&quot;22222222&quot;);</span><br><span class="line">tmp[2].cl();</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="设计模式" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="设计模式" scheme="http://qianyouyou.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://qianyouyou.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[转]const指针与指向const的指针</title>
    <link href="http://qianyouyou.cn/2019/02/23/2019-02-23/"/>
    <id>http://qianyouyou.cn/2019/02/23/2019-02-23/</id>
    <published>2019-02-23T08:55:36.000Z</published>
    <updated>2019-02-23T09:04:57.683Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~</p><p><strong>const指针的定义：</strong></p><p>　　const指针是指针变量的值一经初始化，就不可以改变指向，初始化是必要的。其定义形式如下：</p><p>type *const 指针名称;</p><p>　　声明指针时，可以在类型前或后使用关键字const，也可在两个位置都使用。例如，下面都是合法的声明，但是含义大不同：</p><p>const int * pOne;    //指向<strong>整形常量</strong> 的指针，它指向的值不能修改</p><p>int * const pTwo;    //指向整形的<strong>常量指针</strong> ，它不能在指向别的变量，但指向（变量）的值可以修改。 </p><p>const int *const pThree;  //指向<strong>整形常量</strong> 的<strong>常量指针</strong> 。它既不能再指向别的常量，指向的值也不能修改。</p><p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。下面的代码有助于说明这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int *p1;  //the int pointed to is constant</span><br><span class="line"></span><br><span class="line">int * const p2; // p2 is constant, it can&apos;t point to anything else</span><br></pre></td></tr></table></figure><p><strong>const指针和const成员函数</strong></p><p>可以将关键字用于成员函数。例如：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     pubilc:</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        void SetLength(int length)&#123;itslength = length;&#125;</span><br><span class="line"></span><br><span class="line">        int GetLength() const &#123;return itslength;&#125;  //成员函数声明为常量</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">     private:</span><br><span class="line"></span><br><span class="line">        int itslength;</span><br><span class="line"></span><br><span class="line">        int itswidth;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>当成员函数被声明为const时，如果试图修改对象的数据，编译器将视为错误。</p><p>如果声明了一个指向const对象的指针，则通过该指针只能调用const方法（成员函数）。</p><p>示例声明三个不同的Rectangle对象：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle* pRect = new Rectangle;</span><br><span class="line"></span><br><span class="line">const Rectangle * pConstRect = new Rectangle;     //指向const对象</span><br><span class="line"></span><br><span class="line">Rectangle* const pConstPtr = new Rectangle;</span><br><span class="line"></span><br><span class="line">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="const指针和指向const的指针"><a href="#const指针和指向const的指针" class="headerlink" title="const指针和指向const的指针"></a>const指针和指向const的指针</h1><p>当使用带有const的指针时其实有两种意思。一种指的是你不能修改指针本身的内容，另一种指的是你不能修改指针指向的内容。听起来有点混淆一会放个例子上来就明白了。<br>      先说指向const的指针，它的意思是指针指向的内容是不能被修改的。它有两种写法。<br>      const int<em> p; （推荐）<br>      int const</em> p;<br>      第一种可以理解为，p是一个指针，它指向的内容是const int 类型。p本身不用初始化它可以指向任何标示符，但它指向的内容是不能被改变的。<br>      第二种很容易被理解成是p是一个指向int的const指针（指针本身不能被修改），但这样理解是错误的，它也是表示的是指向const的指针（指针指向的内容是不能被修改的），它跟第一种表达的是一个意思。为了避免混淆推荐大家用第一种。<br>      再说const指针，它的意思是指针本身的值是不能被修改的。它只有一种写法<br>      int<em> const p=一个地址; (因为指针本身的值是不能被修改的所以它必须被初始化）<br>      这种形式可以被理解为，p是一个指针，这个指针是指向int 的const指针。它指向的值是可以被改变的如</em>p=3;<br>      还有一种情况是这个指针本身和它指向的内容都是不能被改变的，请往下看。<br>      const int<em> const p=一个地址;<br>      int const</em> const p=一个地址;<br>      看了上面的内容是不是有点晕，没关系，你不用去背它，用的多了就知道了，还有个技巧，通过上面的观察我们不难总结出一点规律，是什么呢？这个规律就是： 指向const的指针（指针指向的内容不能被修改）const关健字总是出现在<em>的左边而const指针（指针本身不能被修改）const关健字总是出现在</em>的右边，那不用说两个const中间加个*肯定是指针本身和它指向的内容都是不能被改变的。有了这个规则是不是就好记多了。</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Code highlighting produced by Actipro CodeHighlighter (freeware)http://www.CodeHighlighter.com/--&gt; 1 #include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a=3;</span><br><span class="line">    int b;</span><br><span class="line">    </span><br><span class="line">    /*定义指向const的指针（指针指向的内容不能被修改）*/ </span><br><span class="line">    const int* p1; </span><br><span class="line">    int const* p2; </span><br><span class="line">    </span><br><span class="line">    /*定义const指针(由于指针本身的值不能改变所以必须得初始化）*/ </span><br><span class="line">    int* const p3=&amp;a; </span><br><span class="line">    </span><br><span class="line">    /*指针本身和它指向的内容都是不能被改变的所以也得初始化*/</span><br><span class="line">    const int* const p4=&amp;a;</span><br><span class="line">    int const* const p5=&amp;b; </span><br><span class="line">    </span><br><span class="line">     p1=p2=&amp;a; //正确</span><br><span class="line">     *p1=*p2=8; //不正确（指针指向的内容不能被修改）</span><br><span class="line">    </span><br><span class="line">     *p3=5; //正确</span><br><span class="line">     p3=p1; //不正确（指针本身的值不能改变） </span><br><span class="line">    </span><br><span class="line">     p4=p5;//不正确 （指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     *p4=*p5=4; //不正确（指针本身和它指向的内容都是不能被改变） </span><br><span class="line">     </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>const用法小结：</strong><br>const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。<br>\1. const修饰函数的参数<br>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。<br>const 只能修饰输入参数：<br>如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。<br>将“const &amp;”修饰输入参数的用法总结如下：<br>(1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。<br>(2)对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。</p><p>\2. const 修饰函数的返回值<br>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数<br>const char <em> GetString(void);<br>如下语句将出现编译错误：<br>char </em>str = GetString();<br>正确的用法是<br>const char *str = GetString();<br>如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。<br>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。<br>例如：</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">A &amp; operate = (const A &amp;other); // 赋值函数</span><br><span class="line">&#125;;</span><br><span class="line">A a, b, c; // a, b, c 为A 的对象</span><br><span class="line">a = b = c; // 正常的链式赋值</span><br><span class="line">(a = b) = c; // 不正常的链式赋值，但合法</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p><p>\3. const修饰成员函数<br>关于Const函数的几点规则：<br>a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.<br>b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.<br>c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.<br>d. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</p><p>　　版权所有，转载请注明转载地址：<a href="http://www.cnblogs.com/lihuidashen/p/4378884.html" target="_blank" rel="noopener">http://www.cnblogs.com/lihuidashen/p/4378884.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const指针的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　const指针是指针变量的值一经初始化，就不可以改变指向
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="C语言" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="const" scheme="http://qianyouyou.cn/tags/const/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[转]#pragma命令详解</title>
    <link href="http://qianyouyou.cn/2019/02/22/2019-02-22/"/>
    <id>http://qianyouyou.cn/2019/02/22/2019-02-22/</id>
    <published>2019-02-22T11:53:01.000Z</published>
    <updated>2019-02-23T10:51:10.341Z</updated>
    
    <content type="html"><![CDATA[<p>每种C和C++的实现支持对其宿主机或操作系统唯一的功能。例如，一些程序需要精确控制超出数据所在的储存空间，或着控制特定函数接受参数的方式。#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。编译指示被定义为机器或操作系统特定的，并且通常每种编译程序是不同的。</p><p>语法：</p><p>#pragma token_string</p><p>“token_string”是一系列字符用来给出所需的特定编译程序指令和参数。数字符号“#”必须是包含编译指令的行中第一个非空白字符；而空白字符可以隔开数字符号“#”和关键字“pragma”。在#pragma后面，写任何翻译程序能够作为预处理符号分析的文本。#pragma的参数类似于宏扩展。</p><p>如果编译程序发现它不认得一个编译指示，它将给出一个警告，可是编译会继续下去。</p><p>为了提供新的预处理功能，或者为编译程序提供由实现定义的信息，编译指示可以用在一个条件语句内。C和C++编译程序可以识别下列编译程序指令。</p><table><thead><tr><th>alloc_text</th><th>comment</th><th>init_seg*</th><th>optimize</th></tr></thead><tbody><tr><td>auto_inline</td><td>component</td><td>inline_depth</td><td>pack</td></tr><tr><td>bss_seg</td><td>data_seg</td><td>inline_recursion</td><td>pointers_to_members*</td></tr><tr><td>check_stack</td><td>function</td><td>intrinsic</td><td>setlocale</td></tr><tr><td>code_seg</td><td>hdrstop</td><td>message</td><td>vtordisp*</td></tr><tr><td>const_seg</td><td>include_alias</td><td>once</td><td>warning</td></tr></tbody></table><p>*仅用于C++编译程序。</p><p><strong>1 alloc_text</strong></p><p>#pragma alloc_text( “textsection”, function1, … )</p><p>命名特别定义的函数驻留的代码段。该编译指示必须出现在函数说明符和函数定义之间。</p><p>alloc_text编译指示不处理C++成员函数或重载函数。它仅能应用在以C连接方式说明的函数——就是说，函数是用extern “C”连接指示符说明的。如果你试图将这个编译指示应用于一个具有C++连接方式的函数时，将出现一个编译程序错误。</p><p>由于不支持使用__based的函数地址，需要使用alloc_text编译指示来指定段位置。由textsection指定的名字应该由双引号括起来。</p><p>alloc_text编译指示必须出现在任何需要指定的函数说明之后，以及这些函数的定义之前。</p><p>在alloc_text编译指示中引用的函数必须和该编译指示处于同一个模块中。如果不这样做，使以后一个未定义的函数被编译到一个不同的代码段时，错误会也可能不会被捕获。即使程序一般会正常运行，但是函数不会分派到应该在的段。</p><p>alloc_text的其它限制如下：</p><p>它不能用在一个函数内部。</p><p>它必须用于函数说明以后，函数定义以前。</p><p><strong>2 auto_inline</strong></p><p>#pragma auto_inline( [{on | off}] )</p><p>当指定off时将任何一个可以被考虑为作为自动嵌入扩展候选的函数排除出该范围。为了使用auto_inline编译指示，将其紧接着写在一个函数定义之前或之后（不是在其内部）。该编译指示将在其出现以后的第一个函数定义开始起作用。auto_inline编译指示对显式的inline函数不起作用。</p><p><strong>3 bss_seg</strong></p><p>#pragma data_seg( [“section-name”[, “section-class”] ] )</p><p>为未初始化数据指定缺省段。data_seg编译指示除了工作于已初始化数据而不是未初始化的以外具有一样的效果。在一些情况下，你能使用bss_seg将所有未初始化数据安排在一个段中来加速你的装载时间。</p><p>#pragma bss_seg( “MY_DATA” )</p><p>将导致把#pragma语句之后的未初始化的数据安排在一个叫做MY_DATA的段中。</p><p>用bss_seg编译指示分配的数据不包含任何关于其位置的信息。</p><p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p><p><strong>4 check_stack</strong></p><p>#pragma check_stack([ {on | off}] )</p><p>#pragma check_stack{+ | –}</p><p>如果指定off（或者“-”）指示编译程序关闭堆栈探测，或者指定on（或“+”）打开堆栈探测。如果没有给出参数，堆栈探测将根据默认设置决定。该编译指示将在出现该指示之后的第一个函数开始生效。堆栈探测既不是宏和能够生成嵌入代码函数的一部分。</p><p>如果你没有给出check­_stack编译指示的参数，堆栈检查将恢复到在命令行指定的行为。详细情况见编译程序参考。#pragma check_stack和/Gs选项的互相作用情况在表2.1中说明。</p><p>表 2.1 使用check_stack编译指示</p><table><thead><tr><th>编译指示</th><th>用/Gs选项编译？</th><th>行为</th></tr></thead><tbody><tr><td>#pragma check_stack()或#pragma check_stack</td><td>是</td><td>后续的函数关闭堆栈检查</td></tr><tr><td>#pragma check_stack()或#pragma check_stack</td><td>否</td><td>后续的函数打开堆栈检查</td></tr><tr><td>#pragma check_stack(on)或#pragma check_stack(+)</td><td>是或者否</td><td>后续的函数打开堆栈检查</td></tr><tr><td>#pragma check_stack(off)或#pragma check_stack(-)</td><td>是或者否</td><td>后续的函数关闭堆栈检查</td></tr></tbody></table><p><strong>5 code_seg</strong></p><p>#pragma code_seg( [“section-name”[,”section-class”] ] )</p><p>指定分配函数的代码段。code_seg编译指示为函数指定默认的段。你也能够像段名一样指定一个可选的类名。使用没有段名字符串的#pragma code_seg将恢复分配到编译开始时候的状态。</p><p><strong>6 const_seg</strong></p><p>#pragma const_seg( [“section-name”[, “section-class”] ] )</p><p>指定用于常量数据的默认段。data_seg编译指示除了可以工作于所有数据以外具有一样的效果。你能够使用该编译指示将你的常量数据保存在一个只读的段中。</p><p>#pragma const_seg( “MY_DATA” )</p><p>导致在#pragma语句后面的常量数据分配在一个叫做MY_DATA的段中。</p><p>用const_seg编译指示分配的数据不包含任何关于其位置的信息。</p><p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p><p><strong>7 comment</strong></p><p>#pragma comment( comment-type [, commentstring] )</p><p>将描述记录安排到目标文件或可执行文件中去。comment-type是下面说明的五个预定义标识符中的一个，用来指定描述记录的类型。可选的commentstring是一个字符串文字值用于为一些描述类型提供附加的信息。因为commentstring是一个字符串文字值，所以它遵从字符串文字值的所有规则，例如换码字符、嵌入的引号（”）和联接。</p><p><strong>7-1 compiler</strong></p><p>在目标文件中放置编译程序名和版本号。该描述记录被连接程序忽略。如果你为这个记录类型提供一个commentstring参数，编译程序将生成一个警告。</p><p><strong>7-2 exestr</strong></p><p>将commentstring放置到目标文件中去。在连结时，这个字符串再被放到可执行文件去中。当可执行文件被装载时这个字符串不会被装入内存，然而，它可以被一个能够在文件中搜索可打印字符串的程序找到。该描述记录的一个用处是在可执行文件中嵌入版本号或者类似的信息。</p><p><strong>7-3 lib</strong></p><p>将一个库搜索记录放置到目标文件中去。该描述类型必须有包含你要连接程序搜索的库名（和可能的路径）的commentstring参数。因为在目标文件中该库名先于默认的库搜索记录，所以连接程序将如同你在命令行输入这些库一样来搜索它们。你可以在一个源文件中放置多个库搜索记录，每个记录将按照它们出现在源文件中的顺序出现在目标文件中。</p><p><strong>7-4 linker</strong></p><p>在目标文件中放置连接程序选项。你可以用这个描述类型指定连接程序选项来代替在Project Setting对话框中Link页内的选项。例如，你可以指定/include选项以强迫包含一个符号：</p><p>#pragma comment(linker, “/include:__mySymbol”)</p><p><strong>7-5 user</strong></p><p>在目标文件中包含一个普通描述记录。commentstring参数包含描述的文本。该描述记录将被连接程序忽略。</p><p>下面的编译指示导致连接程序在连接时搜索EMAPI.LIB库。连接程序首先在当前工作目录然后在LIB环境变量指定的路径中搜索。</p><p>#pragma comment( lib, “emapi” )</p><p>下面的编译指示导致编译程序将其名字和版本号放置到目标文件中去。</p><p>The following pragma causes the compiler to place the name and version number of the compiler in the object file:</p><p>#pragma comment( compiler )</p><p>注意，对于具有commentstring参数的描述记录，你可以使用其它用作字符串文字量的宏来提供宏扩展为字符串文字量。你也能够联结任何字符串文字量和宏的组合来扩展成为一个字符串文字量。例如，下面的语句是可以接受的：</p><p>#pragma comment( user, “Compiled on “ <strong>DATE</strong> “ at “ <strong>TIME</strong> )</p><p><strong>8 component</strong></p><p>#pragma component( browser, { on | off }[, references [, name ]] )</p><p>#pragma component( minrebuild, on | off )</p><p>从源文件内控制浏览信息和依赖信息的收集。</p><p><strong>8-1 浏览信息（Browser）</strong></p><p>你可以将收集打开或关闭，你也可以指定收集时忽略特别的名字。</p><p>使用on或off在编译指示以后控制浏览信息的收集。例如：</p><p>#pragma component(browser, off)</p><p>终止编译程序收集浏览信息。</p><p>注意，为了用这个编译指示打开浏览信息的收集，必须先从Project Setting对话框或者命令行允许浏览信息。</p><p>references选项可以有也可以没有name参数。使用没有name参数的references选项将打开或者关闭引用信息的收集（然而继续收集其它浏览信息）。例如：</p><p>#pragma component(browser, off, references)</p><p>终止编译程序收集引用信息。</p><p>使用有name和off参数的references选项将阻止从浏览信息窗口中出现引用到的名字。用这个语法将忽略你不感兴趣的名字和类型从而减少浏览信息文件的大小。例如：</p><p>#pragma component(browser, off, references, DWORD)</p><p>从这一点以后忽略DWORD的引用。你能够用on恢复DWORD的引用收集：</p><p>#pragma component(browser, on, references, DWORD)</p><p>这是唯一的方法可以恢复收集指定名字的引用，你必须显式地打开任何你关闭的名字。</p><p>为了防止预处理程序扩展名字（就像扩展NULL到0），用引号括起来：</p><p>#pragma component(browser, off, references, “NULL”)</p><p><strong>8-2 最小化重建（Minimal Rebuild）</strong></p><p>Visual C++的最小化重建功能要求编译程序创建并保存需要大量磁盘空间的C++类依赖信息。为了节省磁盘空间，你能够在你不需要收集依赖信息时使用#pragma component(minrebuild,off)，例如，没有改变过头文件。在未修改过的类之后插入#pragma component(minrebuild,on)重新打开依赖信息。</p><p>详见Enable Minimal Rebuild(/Gm)编译程序选项。</p><p><strong>9 data_seg</strong></p><p>#pragma data_seg( [“section-name”[, “section-class”] ] )</p><p>指定数据的默认段。例如：</p><p>#pragma data_seg( “MY_DATA” )</p><p>导致在#pragma语句后分配的数据保存在一个叫做MY_DATA的段中。</p><p>用data_seg编译指示分配的数据不包含任何关于其位置的信息。</p><p>第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。</p><p><strong>10 function</strong></p><p>#pragma function( function1 [, function2, …] )</p><p>指定必须生成对编译指示中参数列表内函数的调用。如果你使用intrinsic编译指示（或者/Oi）来告诉编译程序生成内含函数（内含函数如同嵌入代码一样生成，不作为一个函数调用），你能够用function编译指示显式地强迫函数调用。当遇到一个function编译指示，它将在其后面遇到的第一个包含有内含函数的函数定义处生效。其持续作用到源文件的尾部或者出现对同一个内含函数指定intrinsic编译指示。function编译指示只能用于函数外——在全局层次。</p><p>为了列出具有内含形式的函数表，参见#pragma intrinsic。</p><p><strong>11 hdrstop</strong></p><p>#pragma hdrstop [( “filename” )]</p><p>控制预编译头文件的工作方式。filename是要使用或者创建（依赖于是否指定了/Yu或/Yc）预编译头文件的名字。如果 filename不包括一个指定路径，将假定预编译头文件和源文件处于同一个目录中。当指定自动预编译头文件选项/YX时，所有指定的文件名将被忽略。</p><p>如果有/YX或者/Yc选项，而且C或C++文件包含了一个hdrstop编译指示时，编译程序保存编译指示之前的编译状态。编译指示之后的编译状态不被保存。</p><p>hdrstop编译选项不能出现在一个头文件内。它只能出现在源文件的文件级，它也不能出现在任何数据或者函数的说明或定义之中。</p><p>注意，除非指定没有文件名的/YX选项或者/Yu或/Yc选项，否则hdrstop编译指示将被忽略。</p><p>用一个文件名命名要保存编译状态的预编译头文件。在hdrstop和filename之间的空格是可选的。在hdrstop编译指示中的文件名是一个字符串，这样它服从于C或C++的字符串规则。特别的，你必须像下面例子里面显示的用引号括起来。</p><p>#pragma hdrstop( “c:\projects\include\myinc.pch” )</p><p>预编译头文件的文件名按照如下规则决定，按照优先次序：</p><p>/Fp编译程序选项的参数；</p><p>由#pragma hdrstop的filename参数；</p><p>原文件名的基本文件名加上.PCH扩展名。</p><p><strong>12 include_alias</strong></p><p>#pragma include_alias( “long_filename”, “short_filename” )</p><p>#pragma include_alias( &lt;long_filename&gt;, &lt;short_filename&gt; )</p><p>指定作为long_filename别名的short_filename。一些文件系统允许超出8.3FAT文件系统限制的长头文件名。编译程序不能简单地将长文件名截断为8.3名字，因为长头文件名的前8个字符可能不是唯一的。无论何时编译程序遇到long_filename串，它代替short_filename，并且用short_filename搜索头文件。这个编译指示必须出现在相应的#include指示之前。例如：</p><p>// First eight characters of these two files not unique.</p><p>#pragma include_alias( “AppleSystemHeaderQuickdraw.h”, “quickdra.h” )</p><p>#pragma include_alias( “AppleSystemHeaderFruit.h”, “fruit.h” )</p><p>#pragma include_alias( “GraphicsMenu.h”, “gramenu.h” )</p><p>#include “AppleSystemHeaderQuickdraw.h”</p><p>#include “AppleSystemHeaderFruit.h”</p><p>#include “GraphicsMenu.h”</p><p>这个别名在搜索时精确匹配，包括拼写和双引号、尖括号。include_alias编译指示在文件名上执行简单的字符串匹配，不进行其它的文件名验证。例如，给出下列指示：</p><p>#pragma include_alias(“mymath.h”, “math.h”)</p><p>#include “./mymath.h”</p><p>#include “sys/mymath.h”</p><p>并不执行别名替代，因为头文件名字符串没有精确匹配。另外，在/Yu，/Yc和/YX编译程序选项，或hdrstop编译指示中作为参数的头文件名不被替换。例如，如果你的源文件包含下列指示：</p><p>#include &lt;AppleSystemHeaderStop.h&gt;</p><p>相应的编译程序选项必须是：</p><p>/YcAppleSystemHeaderStop.h</p><p>你能够用include­_alias编译指示将任何头文件映射到其它文件。例如：</p><p>#pragma include_alias( “api.h”, “c:\version1.0\api.h” )</p><p>#pragma include_alias( &lt;stdio.h&gt;, &lt;newstdio.h&gt; )</p><p>#include “api.h”</p><p>#include &lt;stdio.h&gt;</p><p>不要混淆用双引号和尖括号括起来的文件名。例如，给出上面的#pragma include_alias指示时，在下面的#include指示中编译程序不执行替换。</p><p>#include &lt;api.h&gt;</p><p>#include “stdio.h”</p><p>还有，下面的指示将产生一个错误：</p><p>#pragma include_alias(&lt;header.h&gt;, “header.h”) // Error</p><p>注意，在错误信息中报告的文件名，或者预定义宏<strong>FILE</strong>的值，是执行替换以后的文件名。例如，在下列指示之后：</p><p>#pragma include_alias( “VeryLongFileName.H”, “myfile.h” )</p><p>#include “VeryLongFileName.H”</p><p>文件VeryLongFileName.H产生下列错误信息：</p><p>myfile.h(15) : error C2059 : syntax error</p><p>还要注意的是不支持传递性。给出下面的指示：</p><p>#pragma include_alias( “one.h”, “two.h” )</p><p>#pragma include_alias( “two.h”, “three.h” )</p><p>#include “one.h”</p><p>编译程序将搜索two.h而不是three.h。</p><p><strong>13 init_seg</strong></p><p>C++特有</p><p>#pragma init_seg({ compiler | lib | user | “section-name” [, “func-name”]} )</p><p>指定影响启动代码执行的关键字或代码段。因为全局静态对象的初始化可以包含执行代码，所以你必须指定一个关键字来定义什么时候构造对象。在使用需要初始化的动态连接库（DLL）或程序库时使用init_seg编译指示是尤其重要的。</p><p>init_seg编译指示的选项有：</p><p>13-1 compiler</p><p>由Microsoft C运行时间库保留。在这个组中的对象将第一个构造。</p><p>13-2 lib</p><p>用于第三方类库开发者的初始化。在这个组中的对象将在标记为构造compiler的对象之后，其它对象之前构造。</p><p>13-3 user</p><p>用于任何其它用户。在这个组中的对象将最后构造。</p><p>13-4 section-name</p><p>允许显式地指定初始化段。在用户指定的section-name中的对象将不会隐式地构造，而它们的地址将会被放置在由section-name命名的段中。</p><p>13-5 func-name</p><p>指定当程序退出时，作为atexit函数调用的函数。这个函数必须具有和atexit函数相同的形式：</p><p>int funcname(void (__cdecl *)(void));</p><p>如果你需要延迟初始化，你能够选择指定显式的段名。随后你必须调用每个静态对象的构造函数。</p><p><strong>14 inline_depth</strong></p><p>#pragma inline_depth( [0… 255] )</p><p>通过控制能够被扩展的一系列函数调用（从0到255次）来控制嵌入函数扩展的发生次数，这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。</p><p>inline_depth编译指示控制能够被扩展的一系列函数调用。例如，如果嵌入深度是4，并且如果A调用B然后调用C，所有的3次调用都将做嵌入扩展。然而，如果设置的最近一次嵌入深度是2，则只有A和B被扩展，而C仍然作为函数调用。</p><p>为了使用这个编译指示，你必须设置编译程序选项/Ob为1或者2。用这个编译指示指定的深度设定在该指示后面的第一个函数开始生效。如果你在括号内不指定一个值，inline_depth设置嵌入深度到默认值8。</p><p>在扩展时，嵌入深度可以被减少而不能被增加。如果嵌入深度是6，同时在扩展过程中预处理程序遇到一个inline_depth编译指示设置为8，则深度保持为6。</p><p>嵌入深度0将拒绝嵌入扩展，深度255将设置在嵌入扩展时没有限制。如果用一个没有指定值的编译指示，则使用为默认值。</p><p><strong>15 inline_recursion</strong></p><p>#pragma inline_recursion( [{on | off}] )</p><p>控制直接或者相互间的递归函数调用式的嵌入扩展。用这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。使用这个编译指示需要设置编译程序选项/Ob为1或者2。默认的inline_recursion状态是off。这个编译指示在出现该编译指示之后第一个函数调用起作用，并不影响函数的定义。</p><p>inline_recursion编译指示控制如何扩展递归函数。如果inline_recursion是off，并且如果一个嵌入函数调用了它自己（直接的或者间接的），函数将仅仅扩展一次。如果inline_recursion是on,函数将扩展多次直到达到inline_depth的值或者容量限制。</p><p><strong>16 intrinsic</strong></p><p>#pragma intrinsic( function1 [, function2, …] )</p><p>指定对在编译指示参数表中函数调用是内含的。编译程序像嵌入代码一样生成内含函数，而不是函数调用。下面列出了具有内含形式的库函数。一旦遇到intrinsic编译指示，它从第一个包含指定内含函数的函数定义开始起作用。作用持续到源文件尾部或者出现包含相同内含函数的function编译指示。intrinsic编译指示只能用在函数定义外——在全局层次。</p><p>下列函数具有内含形式：</p><table><thead><tr><th>_disable</th><th>_enable</th><th>_inp</th><th>_inpw</th><th>_lrotl</th><th>_lrotr</th></tr></thead><tbody><tr><td>_outp</td><td>_outpw</td><td>_rotl</td><td>_rotr</td><td>_strset</td><td>abs</td></tr><tr><td>fabs</td><td>labs</td><td>memcmp</td><td>memcpy</td><td>memset</td><td>strcat</td></tr><tr><td>strcmp</td><td>strcpy</td><td>strlen</td><td></td><td></td></tr></tbody></table><p>使用内含函数的程序更快，因为它们没有函数调用的额外代价，然而因为有附加的代码生成，可能比较大。</p><p>注意，_alloca和setjmp函数总是内含的，这个行为不受intrinsic编译指示影响。</p><p>下列浮点函数没有内含形式。然而它们具有直接将参数通过浮点芯片传送而不是推入程序堆栈的版本。</p><table><thead><tr><th>acos</th><th>asin</th><th>cosh</th><th>fmod</th><th>pow</th><th>sinh</th></tr></thead><tbody><tr><td>tanh</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>当你同时指定/Oi和/Og编译程序选项（或者任何包含/Og，/Ox，/O1和/O2的选项）时下列浮点函数具有真正的内含形式。</p><table><thead><tr><th>atan</th><th>exp</th><th>log10</th><th>sqrt</th><th>atan2</th><th>log</th></tr></thead><tbody><tr><td>sin</td><td>tan</td><td>cos</td><td></td><td></td></tr></tbody></table><p>你可以用编译程序选项/Op或/Za来覆盖真内含浮点选项的生成。在这种情况下，函数会像一般库函数一样被生成，同时直接将参数通过浮点芯片传送而不是推入程序堆栈。</p><p><strong>17 message</strong></p><p>#pragma message( messagestring )</p><p>不中断编译，发送一个字符串文字量到标准输出。message编译指示的典型运用是在编译时显示信息。</p><p>下面的代码段用message编译指示在编译过程中显示一条信息：</p><p>#if _M_IX86 == 500</p><p>#pragma message( “Pentium processor build” )</p><p>#endif</p><p>messagestring参数可以是一个能够扩展成字符串文字量的宏，并且你能够用字符串文字量和宏的任何组合来构造。例如，下面的语句显示被编译文件的文件名和文件最后一次修改的日期和时间。</p><p>#pragma message( “Compiling “ <strong>FILE</strong> )</p><p>#pragma message( “Last modified on “ <strong>TIMESTAMP</strong> )</p><p><strong>18 once</strong></p><p>#pragma once</p><p>指定在创建过程中该编译指示所在的文件仅仅被编译程序包含（打开）一次。该编译指示的一种常见用法如下：</p><p>//header.h</p><p>#pragma once</p><p>// Your C or C++ code would follow:</p><p><strong>19 optimize</strong></p><p>仅在专业版和企业版中存在</p><p>#pragma optimize( “[optimization-list]”, {on | off} )</p><p>代码优化仅有Visual C++专业版和企业版支持。详见Visual C++ Edition。</p><p>指定在函数层次执行的优化。optimize编译选项必须在函数外出现，并且在该编译指示出现以后的第一个函数定义开始起作用。on和off参数打开或关闭在optimization-list指定的选项。</p><p>optimization-list能够是0或更多个在表2.2中给出的参数：</p><p>表 2.2   optimize编译指示的参数</p><table><thead><tr><th>参数</th><th>优化类型</th></tr></thead><tbody><tr><td>a</td><td>假定没有别名。</td></tr><tr><td>g</td><td>允许全局优化。</td></tr><tr><td>p</td><td>增强浮点一致性。</td></tr><tr><td>s 或 t</td><td>指定更短或者更快的机器代码序列。</td></tr><tr><td>w</td><td>假定在函数调用中没有别名。</td></tr><tr><td>y</td><td>在程序堆栈中生成框架指针。</td></tr></tbody></table><p>这些和在/O编译程序选项中使用的是相同的字母。例如：</p><p>#pragma optimize( “atp”, on )</p><p>用空字符串（””）的optimize编译指示是一种特别形式。它要么关闭所有的优化选项，要么恢复它们到原始（或默认）的设定。</p><p>#pragma optimize( “”, off )</p><p>#pragma optimize( “”, on )</p><p><strong>20 pack</strong></p><p>#pragma pack( [ n] )</p><p>指定结构和联合成员的紧缩对齐。尽管用/Zp选项设定整个翻译单元的结构和联合成员的紧缩对齐，可以用pack编译指示在<a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">数据说明</a>层次设定紧缩对齐。从出现该编译指示后的第一个结构或者联合说明开始生效。这个编译指示不影响定义。</p><p>当你使用#pragma pack(n)，其中n是1，2，4，8或者16，第一个以后的每个结构成员保存在较小的成员类型或者n字节边界上。如果你使用没有参数的#pragma pack，结构成员将被紧缩到由/Zp指定的值。默认的/Zp紧缩的大小是/Zp8。</p><p>编译程序还支持下面的增强语法：</p><p>#pragma pack( [ [ { push | pop}, ] [ identifier, ] ] [ n ] )</p><p>该语法允许你将使用不同紧缩编译指示的组件合并到同一个翻译单元内。</p><p>每次出现有push参数的pack编译指示将保存当前的紧缩对齐值到一个内部的编译程序堆栈。编译指示的参数列表从左向右读取。如果你使用了push，当前紧缩值被保存。如果你提供了一个n值，这个值将成为新的紧缩值。如果你指定了一个你选定的标示符，这个标示符将和新的紧缩值关联。</p><p>每次出现有pop参数的pack编译指示从内部编译程序堆栈顶部取出一个值并将那个值作为新的紧缩对齐。如果你用了pop，而内部编译程序堆栈是空的，对齐值将从命令行得到，同时给出一个警告。如果你用了pop并指定了n的值，那个值将成为新的紧缩值。如果你用了pop并指定了一个标示符，将移去所有保存在堆栈中的的值直到匹配的找到匹配的标示符，和该标示符关联的紧缩值也被从堆栈中移出来成为新的紧缩值。如果没有找到匹配的标示符，将从命令行获取紧缩值并产生一个1级警告。默认的紧缩对齐是8。</p><p>pack编译指示的新的增强功能允许你编写头文件保证在使用头文件之前和其后的紧缩值是一样的：</p><p>/* File name: include1.h</p><p>*/</p><p>#pragma pack( push, enter_include1 )</p><p>/<em> Your include-file code … </em>/</p><p>#pragma pack( pop, enter_include1 )</p><p>/<em> End of include1.h </em>/</p><p>在前面的例子中，进入头文件时将当前紧缩值和标示符enter_include1关联并推入，被记住。在头文件尾部的pack编译选项移去所有在头文件中可能遇到的紧缩值并移去和enter_include1关联的紧缩值。这样头文件保证了在使用头文件之前和其后的紧缩值是一样的。</p><p>新功能也允许你在你的代码内用pack编译指示为不同的代码，例如头文件设定不同的紧缩对齐。</p><p>#pragma pack( push, before_include1 )</p><p>#include “include1.h”</p><p>#pragma pack( pop, before_include1 )</p><p>在上一个例子中，你的代码受到保护，防止了在include.h中的任何紧缩值的改变。</p><p><strong>21 pointers_to_members</strong></p><p>C++特有</p><p>#pragma pointers_to_members(pointer-declaration, [most-general-representation] )</p><p>指定是否能够在相关类定义之前说明一个指向类成员的指针，并且用于控制指针的大小和解释指针的代码。你能够在你的源代码中使用pointers_to_members编译知识来代替/vmx编译程序选项。</p><p>pointer-declaration参数指出是否在相关函数定义之前或其后你已经说明了一个指向成员的指针。pointer-declaration参数是下面两个符号之一：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>full_generality</td><td>生成安全的，但是有时不能优化的代码。如果有一些指向成员的指针在相关类定义之前说明，你要用full_generality。这个参数总是使用由most-general-representation指定的指针表示方式。</td></tr><tr><td>best_case</td><td>对于所有指向成员的指针用最佳的表示方式生成安全的，优化的代码。需要在说明一个指向类成员指针之前定义类。默认是best_case。</td></tr></tbody></table><p>most-general-representaion参数指出在一个翻译单元中编译程序能够安全引用任何指向类成员指针的最小指针表示方式。这个参数可以是下列之一：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>single_inheritance</td><td>最普通的表示方式是单继承，指向成员函数。如果用于指向具有多重或者虚拟继承方式类成员的指针，将产生一个错误。</td></tr><tr><td>multi_inheritance</td><td>最普通的表示方式是多重继承，指向成员函数。如果用于指向具有虚拟继承方式类成员的指针，将产生一个错误。</td></tr><tr><td>virtual_inheritance</td><td>最普通的表示方式是虚拟继承，指向成员函数。不会产生错误。当使用#pragma pointers_to_members (full_generality)时这是默认的参数。</td></tr></tbody></table><p><strong>22 setlocale</strong></p><p>#pragma setlocale( “locale-string” )</p><p>定义用于翻译宽字符常数和字符串文字量时用的地区（国家和语言）。由于用于从多字节字符转换到宽字符的算法根据地区或者由于在运行可执行程序不同的地方进行编译而不同，这个编译指示提供一种在编译时指定目标地区的方式。这保证宽字符字符串将以正确的格式保存。默认的locale-string是“C”。“C”地区将字符串中的每个字符作为wchar_t（即unsigned int）映射其值。</p><p><strong>23 vtordisp</strong></p><p>C++特有</p><p>#pragma vtordisp({on | off} )</p><p>允许隐藏的附加vtordisp构造函数/析构函数替换成员。vtordisp编译指示仅能够用于具有虚拟基类的代码。如果派生类从一个虚拟基类重载了一个虚拟函数，并且如果派生类的构造函数或析构函数用指向虚拟基类的指针调用了这个函数，编译程序将根据虚拟基类在类中引入一个附加的隐藏“vtordisp”域。</p><p>vtodisp编译选项影响它后面的类布局。/vd0和/vd1选项为整个模块指定了相同的行为。指定off将禁止隐藏的vtordisp成员，指定on（默认）将在它们需要的时候允许vtordisp。仅在不可能出现类的构造函数和析构函数通过this指针调用其指向对象中的虚拟函数时才关闭vtordisp。</p><p>#pragma vtordisp( off )</p><p>class GetReal : virtual public { … };</p><p>#pragma vtordisp( on )</p><p><strong>24 warning</strong></p><p>#pragma warning( warning-specifier : warning-number-list [,warning-specifier : warning-number-list…] )</p><p>#pragma warning( push[ , n ] )</p><p>#pragma warning( pop )</p><p>允许有选择地修改编译程序警告信息的行为。</p><p>warning-specifier能够是下列值之一：</p><table><thead><tr><th>warning-specifier</th><th>含义</th></tr></thead><tbody><tr><td>once</td><td>只显示指定信息一次。</td></tr><tr><td>default</td><td>对指定信息应用默认的编译程序选项。</td></tr><tr><td>1,2,3,4</td><td>对指定信息引用给定的警告等级。</td></tr><tr><td>disable</td><td>不显示指定信息。</td></tr><tr><td>error</td><td>对指定信息作为错误显示。</td></tr></tbody></table><p>warning-number_list能够包含任何警告编号。如下，在一个编译指示中可以指定多个选项：</p><p>#pragma warning( disable : 4507 34; once : 4385; error : 164 )</p><p>这等价于：</p><p>#pragma warning( disable : 4507 34 ) // Disable warning messages</p><p>​                                             // 4507 and 34.</p><p>#pragma warning( once : 4385 )        // Issue warning 4385</p><p>​                                             // only once.</p><p>#pragma warning( error : 164 )        // Report warning 164</p><p>​                                             // as an error.</p><p>对于那些关于代码生成的，大于4699的警告标号，warning编译指示仅在函数定义外时有效。如果指定的警告编号大于4699并且用于函数内时被忽略。下面例子说明了用warning编译指示禁止、然后恢复有关代码生成警告信息的正确位置：</p><p>int a;</p><p>#pragma warning( disable : 4705 )</p><p>void func()</p><p>{</p><p>​    a;</p><p>}</p><p>#pragma warning( default : 4705 )</p><p>warning编译指示也支持下面语法：</p><p>#pragma warning( push [ ,n ] )</p><p>#pragma warning( pop )</p><p>这里n表示警告等级（1到4）。</p><p>warning(push)编译指示保存所有警告的当前警告状态。warning(push,n)保存所有警告的当前状态并将全局警告等级设置为n。</p><p>warning(pop)弹出最后一次推入堆栈中的警告状态。任何在push和pop之间改变的警告状态将被取消。考虑下面的例子：</p><p>#pragma warning( push )</p><p>#pragma warning( disable : 4705 )</p><p>#pragma warning( disable : 4706 )</p><p>#pragma warning( disable : 4707 )</p><p>// Some code</p><p>#pragma warning( pop )</p><p>在这些代码的结束，pop恢复了所有警告的状态（包括4705，4706和4707）到代码开始时候的样子。</p><p>当你编写头文件时，你能用push和pop来保证任何用户修改的警告状态不会影响正常编译你的头文件。在头文件开始的地方使用push，在结束地方使用pop。例如，假定你有一个不能顺利在4级警告下编译的头文件，下面的代码改变警告等级到3，然后在头文件的结束时恢复到原来的警告等级。</p><p>#pragma warning( push, 3 )</p><p>// Declarations/ definitions</p><p>#pragma warning( pop )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每种C和C++的实现支持对其宿主机或操作系统唯一的功能。例如，一些程序需要精确控制超出数据所在的储存空间，或着控制特定函数接受参数的方式。#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。编译指示被定义为机器或操作系统特定的
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="C++基础" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="预处理" scheme="http://qianyouyou.cn/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试常用命令总结</title>
    <link href="http://qianyouyou.cn/2019/02/17/2019-02-17/"/>
    <id>http://qianyouyou.cn/2019/02/17/2019-02-17/</id>
    <published>2019-02-17T13:12:47.000Z</published>
    <updated>2019-02-17T13:18:20.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a><strong>1 简介</strong></h2><p>​     GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：     GDB主要帮忙你完成下面四个方面的功能：     1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。     2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）     3.当程序被停住时，可以检查此时你的程序中所发生的事。     4.动态的改变你程序的执行环境。</p><h2 id="2-生成调试信息"><a href="#2-生成调试信息" class="headerlink" title="2 生成调试信息"></a><strong>2 生成调试信息</strong></h2><p>​     一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如：</p><p>​     gcc -g hello.c -o hello</p><p>​     g++ -g hello.cpp -o hello</p><p>​     如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。</p><h2 id="3-启动GDB的方法"><a href="#3-启动GDB的方法" class="headerlink" title="3 启动GDB的方法"></a><strong>3 启动GDB的方法</strong></h2><p>​     gdb program</p><p>​     program 也就是你的执行文件，一般在当前目录下。</p><h2 id="4-程序运行上下文"><a href="#4-程序运行上下文" class="headerlink" title="4 程序运行上下文"></a><strong>4 程序运行上下文</strong></h2><h3 id="4-1-程序运行参数"><a href="#4-1-程序运行参数" class="headerlink" title="4.1 程序运行参数"></a><strong>4.1 程序运行参数</strong></h3><p>​     set args 可指定运行时参数。（如：set args 10 20 30 40 50 ）</p><p>​     show args 命令可以查看设置好的运行参数。</p><p>​     run  启动程序</p><h3 id="4-2-工作目录"><a href="#4-2-工作目录" class="headerlink" title="4.2 工作目录"></a><strong>4.2 工作目录</strong></h3><p>​     cd 相当于shell的cd命令。</p><p>​     pwd 显示当前的所在目录。</p><h2 id="5-设置断点"><a href="#5-设置断点" class="headerlink" title="5 设置断点"></a><strong>5 设置断点</strong></h2><h3 id="5-1-简单断点"><a href="#5-1-简单断点" class="headerlink" title="5.1 简单断点"></a><strong>5.1 简单断点</strong></h3><p>​     break 设置断点，可以简写为b</p><p>​     b 10 设置断点，在源程序第10行</p><p>​     b func 设置断点，在func函数入口处</p><h3 id="5-2-多文件设置断点"><a href="#5-2-多文件设置断点" class="headerlink" title="5.2 多文件设置断点"></a><strong>5.2 多文件设置断点</strong></h3><p>​     在进入指定函数时停住:</p><p>​     C++中可以使用class::function或function(type,type)格式来指定函数名。如果有名称空间，可以使用namespace::class::function或者function(type,type)格式来指定函数名。</p><p>​     break filename:linenum – 在源文件filename的linenum行处停住</p><p>​     break filename:function – 在源文件filename的function函数的入口处停住</p><p>​     break class::function或function(type,type) – 在类class的function函数的入口处停住</p><p>​     break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住</p><h3 id="5-3-查询所有断点"><a href="#5-3-查询所有断点" class="headerlink" title="5.3 查询所有断点"></a><strong>5.3 查询所有断点</strong></h3><p>​     info b</p><h2 id="6条件断点"><a href="#6条件断点" class="headerlink" title="6条件断点"></a><strong>6条件断点</strong></h2><p>​     一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p><p>​     设置一个条件断点</p><p>​     b test.c:8 if intValue == 5</p><h2 id="7-维护停止点"><a href="#7-维护停止点" class="headerlink" title="7 维护停止点"></a><strong>7 维护停止点</strong></h2><p>​     delete [range…] 删除指定的断点，如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。</p><p>​          比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。</p><p>​     disable  [range…]</p><p>​          disable所指定的停止点，如果什么都不指定，表示disable所有的停止点。简写命令是dis.</p><p>​     enable [range…]</p><p>​          enable所指定的停止点，如果什么都不指定，表示enable所有的停止点。简写命令是ena.</p><h2 id="8-调试代码"><a href="#8-调试代码" class="headerlink" title="8 调试代码"></a><strong>8 调试代码</strong></h2><p>​     run 运行程序，可简写为r</p><p>​     next 单步跟踪，函数调用当作一条简单语句执行，可简写为n</p><p>​     step 单步跟踪，函数调进入被调用函数体内，可简写为s</p><p>​     finish 退出进入的函数</p><p>​     until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。</p><p>​     continue 继续运行程序，可简写为c</p><h2 id="9-查看运行时数据"><a href="#9-查看运行时数据" class="headerlink" title="9 查看运行时数据"></a><strong>9 查看运行时数据</strong></h2><p>​     print 打印变量、字符串、表达式等的值，可简写为p</p><p>​     p count 打印count的值</p><h2 id="10-自动显示"><a href="#10-自动显示" class="headerlink" title="10 自动显示"></a><strong>10 自动显示</strong></h2><p>​     你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</p><p>​     display 变量名</p><p>​     info display – 查看display设置的自动显示的信息。</p><p>​     undisplay num（info display时显示的编号）</p><p>​     delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p><p>​     disable display dnums…</p><p>​     enable display dnums…</p><p>​     disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p><h2 id="11-查看修改变量的值"><a href="#11-查看修改变量的值" class="headerlink" title="11. 查看修改变量的值"></a>11. 查看修改变量的值</h2><p>​     (gdb) ptype width – 查看变量width的类型</p><p>​          type = double</p><p>​     (gdb) p width  – 打印变量width 的值</p><p>​          $4 = 13</p><p>​     你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</p><p>​          (gdb) set var width=47</p><p>​     在你改变程序变量取值时，最好都使用set var格式的GDB命令。</p><h2 id="12-显示源代码"><a href="#12-显示源代码" class="headerlink" title="12 显示源代码"></a><strong>12 显示源代码</strong></h2><p>​     GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 –g 的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，</p><p>​     GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。默认打印10行，还是来看一看查看源代码的GDB命令吧。</p><p>​     list linenum</p><p>​          Print lines centered around line number linenum in the current source file.</p><p>​     list function</p><p>​          显示函数名为function的函数的源程序。</p><p>​     list</p><p>​          显示当前行后面的源程序。</p><p>​     list -</p><p>​          显示当前行前面的源程序。</p><p>​     一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。</p><p>​          set listsize count</p><p>​     设置一次显示源代码的行数。(unless the list argument explicitly specifies some other number)</p><p>​          show listsize</p><p>​     查看当前listsize的设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;1 简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;​     GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="gdb调试" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/gdb%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="gdb调试" scheme="http://qianyouyou.cn/tags/gdb%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>七牛云测试域名到期图片转移腾讯云COS过程</title>
    <link href="http://qianyouyou.cn/2019/02/16/2019-02-16-1/"/>
    <id>http://qianyouyou.cn/2019/02/16/2019-02-16-1/</id>
    <published>2019-02-16T08:41:21.000Z</published>
    <updated>2019-02-16T08:54:56.218Z</updated>
    
    <content type="html"><![CDATA[<p>今天终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用，希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ </p><h2 id="备份七牛云图片到本地"><a href="#备份七牛云图片到本地" class="headerlink" title="备份七牛云图片到本地"></a>备份七牛云图片到本地</h2><h3 id="批量下载七牛云图片到本地的步骤"><a href="#批量下载七牛云图片到本地的步骤" class="headerlink" title="批量下载七牛云图片到本地的步骤"></a><strong>批量下载七牛云图片到本地的步骤</strong></h3><p>1、下载以下工具包解压到当地硬盘，比如 D 盘，那么解压之后就获得一个 qiniu 文件夹，里面包含有两个文件，分别是 qshell.conf 和 qshell.exe 文件。</p><p> 批量下载七牛云图片到本地工具包（密码: xp1p）</p><p>2、用记事本或者 Notepad++ 软件打开 qshell.conf 文件，然后根据里面的要求填写相应的内容并保存。完成之后大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line">2.     &quot;dest_dir&quot;  :   &quot;//images&quot;,</span><br><span class="line">3.     &quot;bucket&quot;    :   &quot;blog&quot;,</span><br><span class="line">4.     &quot;domain&quot;    :   &quot;http://********.com&quot;,</span><br><span class="line">5.     &quot;access_key&quot;    :&quot;******************&quot;,</span><br><span class="line">6.     &quot;secret_key&quot;    :&quot;******************&quot;,</span><br><span class="line">7.     &quot;is_private&quot;    :false,</span><br><span class="line">8.     &quot;prefix&quot;    :   &quot;&quot;,</span><br><span class="line">9.     &quot;suffix&quot;    :   &quot;&quot;</span><br><span class="line">10. &#125;</span><br></pre></td></tr></table></figure><p>其中 access_key 和 secret_key 的值可以在七牛云后台中的个人中心的密钥管理中获得。</p><p>3、运行电脑的 CMD，比如刚才我们是解压在 D 盘，那么就在CMD 中分别输入 d:、cd qiniu 和 qshell qdownload 10 qshell.conf  命令后即可自动下载七牛云的图片到本地指定的文件夹中，其中最后一条命令的 10 就是 10 线程的意思，一般是越大越快。</p><p>一般情况下等待一段时间就会自动下载完毕，我这次下载了带有前缀 boke112 的图片，图片不多，所以很快就下载完了。</p><h3 id="申请腾讯云"><a href="#申请腾讯云" class="headerlink" title="申请腾讯云"></a>申请腾讯云</h3><p>自行申请。</p><h2 id="批量替换文章里的图片链接"><a href="#批量替换文章里的图片链接" class="headerlink" title="批量替换文章里的图片链接"></a>批量替换文章里的图片链接</h2><p>本人参考网上一篇<a href="https://blog.csdn.net/HuYingJie_1995/article/details/82355033" target="_blank" rel="noopener">批量修改文件内容的Python代码</a>，魔改后。成功实现了批量修改本地Markdown文章图片链接。下面把Python代码贴出来供大家参考，轻拍～（Python版本2.7）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8#可加入中文注释</span><br><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">#函数功能：将指定文件夹下所有文件和子文件夹下的文件遍历，并修改文件内容</span><br><span class="line">import os</span><br><span class="line">fpath =&quot;/Users/fsf/PycharmProjects/Python2_tencentcloud/test&quot;#这里是你的第一级文件夹的路径</span><br><span class="line">def filechanger(path):</span><br><span class="line">        filenames = os.listdir(path)#将path路径下的所有文件名存入列表filenames</span><br><span class="line">        for filename in filenames:#循环遍历每个文件</span><br><span class="line">                domain = os.path.abspath(path)#获取规范的路径</span><br><span class="line">                filename = os.path.join(domain,filename)#带路径的文件名</span><br><span class="line">                if os.path.isdir(filename):  # 如果是文件夹进入递归</span><br><span class="line">                        filechanger(filename)</span><br><span class="line">                        continue</span><br><span class="line">                fread = open(filename,&apos;r&apos;)</span><br><span class="line">                fwrite = open(&quot;%s.backup&quot;%filename,&apos;w&apos;)</span><br><span class="line"></span><br><span class="line">                for line in fread.readlines():</span><br><span class="line">                        src_str = line</span><br><span class="line"></span><br><span class="line">                        if src_str.find(&apos;![&apos;) != -1:</span><br><span class="line">                                start = src_str.index(&apos;![&apos;) + 2</span><br><span class="line">                                end = src_str.index(&apos;](&apos;)</span><br><span class="line">                                sub = src_str[start:end]</span><br><span class="line"></span><br><span class="line">                                start1 = end + 2</span><br><span class="line">                                end1 = src_str.index(&apos;)&apos;)</span><br><span class="line">                                sub1 = src_str[start1:end1]</span><br><span class="line"></span><br><span class="line">                                sub2 = src_str[(end1 - 4):end1]</span><br><span class="line"></span><br><span class="line">                                s1 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/&apos;</span><br><span class="line">                                s11 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7&apos;</span><br><span class="line"></span><br><span class="line">                                # sub3 = src_str[:start1] + &apos;../images/&apos; + sub + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line">                                s2 = sub + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line"></span><br><span class="line">                                if src_str[start:(start + 12)] == &apos;屏幕快照&apos;:</span><br><span class="line">                                    s22 = s11 + src_str[(start + 12):end] + sub2 + src_str[end1] + src_str[(end1+1):]</span><br><span class="line">                                    sub3 = src_str[:start1] + s22.replace(&apos; &apos;, &apos;%20&apos;)</span><br><span class="line">                                else:</span><br><span class="line">                                    sub3 = src_str[:start1] + s1 + s2.replace(&apos; &apos;,&apos;%20&apos;)</span><br><span class="line">                                fwrite.write(sub3)  # 修改后写入新文件</span><br><span class="line">                                print(sub3)</span><br><span class="line">                        else:</span><br><span class="line">                                fwrite.write(src_str)</span><br><span class="line">                                print(src_str)</span><br><span class="line">                                continue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                fread.close()</span><br><span class="line">                fwrite.close()</span><br><span class="line">                os.remove(filename)#如果想更改数据后想保留原文件以及修改文件名可屏蔽这一句和下一句</span><br><span class="line">                os.rename(&quot;%s.backup&quot; % filename, filename)#</span><br><span class="line">filechanger(fpath)</span><br></pre></td></tr></table></figure><p>自18年9月，终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用（发博文时免费额度：50 GB 标准存储容量，10 GB CDN 回源流量，100 万次读请求，100 万次写请求。费用实例），希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用，希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ &lt;/p&gt;
&lt;h2 id=&quot;备份七牛云图片
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不蒜子统计失效问题解决</title>
    <link href="http://qianyouyou.cn/2019/02/16/2019-02-16/"/>
    <id>http://qianyouyou.cn/2019/02/16/2019-02-16/</id>
    <published>2019-02-16T04:21:23.000Z</published>
    <updated>2019-02-16T04:38:59.756Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>hexo想要开启站点统计，只需找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但近期，这个不蒜子的统计功能就失效了。查阅了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子官方</a>的说法，</p><blockquote><p>“因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！”</p></blockquote><p>由于七牛云9月底强行关闭测试域名，导致本博客在七牛云存的所有图片也无法正常加载了。</p><h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p>找到原来不蒜子的域名文件，并替换掉旧的域名。<br> 文件路径：\themes\next\layout_third-party\analytics\busuanzi-counter.swig，只需要替换src对应的域名即可，如下是替换后的域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h4&gt;&lt;p&gt;hexo想要开启站点统计，只需找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但近期，这
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>默剧</title>
    <link href="http://qianyouyou.cn/2018/12/11/2018-12-11/"/>
    <id>http://qianyouyou.cn/2018/12/11/2018-12-11/</id>
    <published>2018-12-11T06:28:29.000Z</published>
    <updated>2019-02-16T04:29:36.582Z</updated>
    
    <content type="html"><![CDATA[<p>默剧 </p><p>浅悠悠(摘星集)12.11 </p><p>1 </p><p>霏霏思雨， </p><p>雨里等你， </p><p>不念凄寂， </p><p>只念你。 </p><p>2 </p><p>借一方清水涟漪， </p><p>泛起眷恋的气息。 </p><p>你无声色的思绪， </p><p>是我解不开的迷。 </p><p>3 </p><p>你我此刻的局， </p><p>像演一出默剧。 </p><p>静静观戏的你， </p><p>从不发表建议。 </p><p>留下我， </p><p>也沉默在这孤单角色里。 </p><p>4 </p><p>一纸夙愿， </p><p>写进风里。 </p><p>青骢双骑， </p><p>想和你。 </p><p>5 </p><p>借一曲寂寥旋律， </p><p>点缀这孤独的戏。 </p><p>没有言语的默剧， </p><p>我用风雨吸引你。 </p><p>6 </p><p>说不出的千言万语， </p><p>丢在风里， </p><p>把这独角戏的结局， </p><p>寄在雨里。 </p><p>淋着雨， </p><p>盼着你储存温度的消息。 </p><p>7 </p><p>寒风十里， </p><p>我在等雨。 </p><p>风里雨里， </p><p>不见你。 </p><p>8 </p><p>借一道惊雷霹雳， </p><p>撕裂无言的默剧。 </p><p>期待下一场大雨， </p><p>洗刷过往的回忆。 </p><p>9 </p><p>将那洗不掉的泪痕， </p><p>淹没心底， </p><p>你我没有句点的剧， </p><p>绝口不提。 </p><p>留下你， </p><p>是我心口掩不住的秘密。 </p><p>10 </p><p>相逢似雨， </p><p>遥遥无期。 </p><p>从此， </p><p>只爱清酒， </p><p>不爱你。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默剧 &lt;/p&gt;
&lt;p&gt;浅悠悠(摘星集)12.11 &lt;/p&gt;
&lt;p&gt;1 &lt;/p&gt;
&lt;p&gt;霏霏思雨， &lt;/p&gt;
&lt;p&gt;雨里等你， &lt;/p&gt;
&lt;p&gt;不念凄寂， &lt;/p&gt;
&lt;p&gt;只念你。 &lt;/p&gt;
&lt;p&gt;2 &lt;/p&gt;
&lt;p&gt;借一方清水涟漪， &lt;/p&gt;
&lt;p&gt;泛起眷恋的气息。 &lt;/p
      
    
    </summary>
    
      <category term="诗词歌赋" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
      <category term="摘星集" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/%E6%91%98%E6%98%9F%E9%9B%86/"/>
    
    
      <category term="原创诗词" scheme="http://qianyouyou.cn/tags/%E5%8E%9F%E5%88%9B%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>备战焦作日常小练之PrimeGame</title>
    <link href="http://qianyouyou.cn/2018/11/21/2018-11-21/"/>
    <id>http://qianyouyou.cn/2018/11/21/2018-11-21/</id>
    <published>2018-11-21T09:07:44.000Z</published>
    <updated>2018-11-21T09:18:50.340Z</updated>
    
    <content type="html"><![CDATA[<p>Given a suqence of nn integers a_iai.</p><p>Let \text{mul}(l, r) = \prod_{i = l}^{r} a_imul(l,r)=∏i=lrai and \text{fac}(l, r)fac(l,r) be the number of distinct prime factors of \text{mul}(l, r)mul(l,r).</p><p>Please calculate \sum_{i = 1}^{n}\sum_{j = i}^{n}\text{fac}(i, j)∑i=1n∑j=infac(i,j)</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line contains one integer nn (1 \le n \le 10^61≤n≤106) \text{—}— the length of the sequence.</p><p>The second line contains nn integers a_iai (1 \le i \le n, 1 \le a_i \le 10^61≤i≤n,1≤ai≤106) \text{—}— the sequence.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Print the answer to the equation.</p><h4 id="样例输入1复制"><a href="#样例输入1复制" class="headerlink" title="样例输入1复制"></a>样例输入1复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">99 62 10 47 53 9 83 33 15 24</span><br></pre></td></tr></table></figure><h4 id="样例输出1复制"><a href="#样例输出1复制" class="headerlink" title="样例输出1复制"></a>样例输出1复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">248</span><br></pre></td></tr></table></figure><h4 id="样例输入2复制"><a href="#样例输入2复制" class="headerlink" title="样例输入2复制"></a>样例输入2复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6 7 5 5 4 9 9 1 8 12</span><br></pre></td></tr></table></figure><h4 id="样例输出2复制"><a href="#样例输出2复制" class="headerlink" title="样例输出2复制"></a>样例输出2复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">134</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%20Nanjing%20Onsite%202018" target="_blank" rel="noopener">ACM-ICPC Nanjing Onsite 2018</a></p><p>题意</p><p>n个数，求所有[i,j]区间内每个数不重复的素数因素之和。</p><p>题解</p><p>将每个数分解成不同素数之积。例如例1，99分解成3和11，62分解成2和31，10分解成2和5，47分解成47，53为53，9为3，83为83，33为3和11，15为3和5，24为2和3。</p><p>第1个数出现次数为n次，第2个为(n-1) <em> 2次，第3个为(n-3) </em> 3次……则素数因数不重复的前提下和母数出现次数相同。但由于某些区间存在相同素数，所以我们规定假设某一位数的素数因数p所在位置为c,上一个这个素数p位置为b，则这次这个素数p出现次数为(n + 1 - c) * (c - b)。当然所以素数的初始位置为0，没出现一次就将该位置更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6+7;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int size;</span><br><span class="line">    ll prime[20];</span><br><span class="line">&#125;node[maxn];</span><br><span class="line">int n;</span><br><span class="line">int pos[maxn];</span><br><span class="line">bool isPrime[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(ll i = 2; i &lt; maxn; i++)&#123;</span><br><span class="line">        if(!isPrime[i])&#123;</span><br><span class="line">            node[i].prime[node[i].size++] = i;</span><br><span class="line">            for(ll j = i+i; j &lt; maxn; j+=i)&#123;</span><br><span class="line">                isPrime[j] = true;</span><br><span class="line">            node[j].prime[node[j].size++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        ll tmp;</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;tmp);</span><br><span class="line">        for(int j = 0; j &lt; node[tmp].size; j++)&#123;</span><br><span class="line">            ans += (ll)(n + 1 - i)*(i - pos[node[tmp].prime[j]]);</span><br><span class="line">            pos[node[tmp].prime[j]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a suqence of nn integers a_iai.&lt;/p&gt;
&lt;p&gt;Let \text{mul}(l, r) = \prod_{i = l}^{r} a_imul(l,r)=∏i=lrai and \text{fac}(l, r)fac(l,r) be
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>求最小的有2^(500500)个因子的数</title>
    <link href="http://qianyouyou.cn/2018/11/18/2018-11-18/"/>
    <id>http://qianyouyou.cn/2018/11/18/2018-11-18/</id>
    <published>2018-11-18T08:50:07.000Z</published>
    <updated>2018-11-18T09:07:04.975Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，120有16个因子(不信自己数一数)。事实上120也是最小的有16个因子的数。</p><p>请你找出最小的有2的500500次方个因子的数。</p><p>因为数据过大，可以结果对500500507取模。</p><p>思路：</p><p>以120为例，120的质因数分解为<code>2*2*2*3*5</code>。那么和16有什么关系呢？很明显，从这5个数中随机选[0-5]个数共有多少种方法呢。刚好16种。及<code>4*2*2</code>种。2有4种选法，3有2种（选或不选），5也2种。所以组合方式为16种。</p><p>现在看这道题，2^500500个因子，与2相关，1个素数p有2^1种，3个p有2^2种，7个有1^3种……</p><p>现在我们有500500个位置，那么1个p占1位，若p有多个，则剩下的2个占1位，然后剩下的4个1位，8个1位……而2^32已经超int范围了，所以次方最大为16。然后我们打表求出前500500个素数，对着500500个素数中分别插入2^2,2^4,2^8,2^16,3^2,3^4,3^8,5^2……插入的前提是p^n要小于500500个数中的最大数。最后求出这500500个数之后，只需相乘就是该数了。有了思路就可以写代码了。</p><p>答案取模500500507后为35407281</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod = 500500507;</span><br><span class="line">const ll mi = 500500+1;</span><br><span class="line">const ll maxn = 2e7;</span><br><span class="line">ll a[4] = &#123;2, 4, 8, 16&#125;;</span><br><span class="line">ll prime[mi+100];</span><br><span class="line">ll check[maxn], tot;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(check, 0, sizeof(check));</span><br><span class="line">    prime[tot++] = 1;</span><br><span class="line">    for (ll i = 2; i &lt; maxn; ++i)&#123;</span><br><span class="line">        if(!check[i])&#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tot == mi)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        for (ll j = 1; j &lt; tot; ++j)&#123;</span><br><span class="line">            if (i * prime[j] &gt; maxn)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            check[i*prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll Pow(ll a, ll b)&#123;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    for(ll i = 1; i &lt;= b; i++)&#123;</span><br><span class="line">        ans *= a;</span><br><span class="line">        if(ans &gt; prime[tot-1])&#123;</span><br><span class="line">            ans = prime[tot-1]+1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    priority_queue&lt;ll&gt;que;</span><br><span class="line">    que.push(1);</span><br><span class="line">    ll Size = 1;</span><br><span class="line">    ll Top = 4;</span><br><span class="line">    for(ll i = 1; i &lt; mi; i++)&#123;</span><br><span class="line">        if(Size &gt;= mi)&#123;</span><br><span class="line">            if(prime[i] &gt;= que.top())&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">                que.push(prime[i]);</span><br><span class="line">                for(ll j = 0; j &lt; Top; j++)&#123;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= que.top())&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        que.pop();</span><br><span class="line">                        que.push(Pow(prime[i], a[j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            que.push(prime[i]);</span><br><span class="line">            Size++;</span><br><span class="line">            for(ll j = 0; j &lt; Top; j++)&#123;</span><br><span class="line">                if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123;</span><br><span class="line">                    Top = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(Size &gt;= mi)&#123;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= que.top())&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        que.pop();</span><br><span class="line">                        que.push(Pow(prime[i], a[j]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123;</span><br><span class="line">                        Top = j;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.push(Pow(prime[i], a[j]));</span><br><span class="line">                    Size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = 1;</span><br><span class="line">    int SI = 0;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        ans *= que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        ans%=mod;</span><br><span class="line">        SI++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道，120有16个因子(不信自己数一数)。事实上120也是最小的有16个因子的数。&lt;/p&gt;
&lt;p&gt;请你找出最小的有2的500500次方个因子的数。&lt;/p&gt;
&lt;p&gt;因为数据过大，可以结果对500500507取模。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;以120为例，120
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>昨世今生</title>
    <link href="http://qianyouyou.cn/2018/11/09/2018-11-09/"/>
    <id>http://qianyouyou.cn/2018/11/09/2018-11-09/</id>
    <published>2018-11-09T06:47:12.000Z</published>
    <updated>2018-11-09T12:52:32.941Z</updated>
    
    <content type="html"><![CDATA[<p>author：浅悠悠</p><p>致亲人，致自己</p><p>5岁，</p><p>你的梦想是什么呢？</p><p>emm，环游世界！</p><p>为什么呢？</p><p>爷爷之前说的。</p><p>9岁，告别了童言无忌</p><p>然而玩耍依然是最大的乐趣。</p><p>那些年，是记忆里的伊甸园。</p><p>12岁，你开始了奋发学习</p><p>你并不理解知识改变命运，</p><p>但你却依旧坚持，</p><p>为了心中的荣誉。</p><p>那些年，你的理想是北大清华。</p><p>15岁，你读了高中</p><p>开始憧憬大人们的生活，</p><p>也开始尝试各种偶像剧。</p><p>你喜欢看好莱坞，听飞轮海。</p><p>你学明星留起了长发，</p><p>也在心里默默藏起了一个她。</p><p>17岁，快要高考了</p><p>你却接受了各式文化的洗礼，</p><p>渐渐喜欢弹琴写词，</p><p>喜欢吟诗作画，</p><p>喜欢古典音乐与欧美文学，</p><p>喜欢听《为你写诗》，看她笑靥如花 。</p><p>那些年，你眼里只有她。</p><p>18岁，你踏上了大学生活</p><p>昔日的她也断了联系。</p><p>你开始学李清照多愁善感，</p><p>也学苏轼一笑释然。</p><p>时而感时花溅泪，</p><p>时而欲与天公试比高。</p><p>那一年，你的理想是文学与艺术。</p><p>20岁，大二刚刚结束</p><p>你开始后悔两年的蹉跎，</p><p>也明白了人生几何。</p><p>身边有几个一直陪伴你的红颜，</p><p>但你每次都觉得和那个她比，</p><p>差了一点。</p><p>你封闭起自己奋发图强，</p><p>渐渐厌倦了与别人的交流，</p><p>却渴望着别人的理解。</p><p>那些年，你的理想是出人头地。</p><p>22岁，即将毕业</p><p>却发现很难找到一份令自己满意的工作，</p><p>你渐渐明白很多事情不是由自己决定。</p><p>你收起了曾经的轻狂，</p><p>也渐渐学着别人假装。</p><p>你开始喜欢看周星驰，听毛不易。</p><p>那一年，你的理想是找到一份稳定的工作。</p><p>24岁，忙碌的工作压得你喘不过气</p><p>看尽了天外有天有无常，</p><p>山外有山有他乡，</p><p>你已忘却了喜怒无常，</p><p>凡事都一笑而过。</p><p>你穿梭于各个城市之间，</p><p>有时也常常想起曾经环游世界的梦想，</p><p>但也只能感慨马路的纵横交错。</p><p>那些年，你只想轻松一点。</p><p>26岁，你依旧孑然一身</p><p>随着年纪增长的，</p><p>除了脱单的朋友们，</p><p>还有送去各种礼金。</p><p>过节回家，父母从带你串亲戚，</p><p>变成了催你找对象。</p><p>而你每次都是推辞说忙，</p><p>或者配不上别人家的姑娘。</p><p>28岁，你遇见了一个和你境遇类似的姑娘</p><p>初次见面，简单地交涉，</p><p>彼此没有脸红，也没有心跳，只剩下尴尬。</p><p>终于她喝了一口浓咖啡说，你还不错。</p><p>你愣了一下，说，你也不错。</p><p>29岁，你们结婚了</p><p>你并不确定她是否真的喜欢你，</p><p>就像你不确定是否真的喜欢她，</p><p>只是双方父母一直在催促。</p><p>攒了几年去实现理想的钱，</p><p>全部用在了这场婚宴上。</p><p>婚前的酒宴，朋友来的不多也不少。</p><p>你醉后对朋友说，不想结婚，</p><p>朋友说，你只是喝多了，想多了。</p><p>30岁，渐渐升职</p><p>独自负责几个项目，</p><p>管理几个刚毕业的入职者。</p><p>然而她怀孕了，辞掉了工作，</p><p>于是你又每日加班。</p><p>电话那边总是抱怨，</p><p>但你却不能争辩什么。</p><p>那些年，你的理想是简单安稳的生活。</p><p>31岁，有了孩子</p><p>大大小小的费用又花去了一笔钱，</p><p>不过都无所谓，</p><p>你看着你的孩子，</p><p>心中满是欣慰。</p><p>那一年，你的全部只为孩子。</p><p>32岁，人生最忙碌的一年，</p><p>孩子24小时的折腾，</p><p>第二天拖着疲惫的身体上班，</p><p>老板说你上班不干活，</p><p>回家媳妇说你不干活，</p><p>你想了半天也没明白，那谁干的活呢。</p><p>那些年，你不再提起理想。</p><p>35岁，你的身体越来越差，</p><p>加班越来越少，</p><p>晋升也越来越慢，</p><p>而孩子也要开始上幼儿园了，</p><p>各种培训机构与学费又花去了不少积蓄，</p><p>那一年，你本打算给自己过个生日，换个新电脑</p><p>40岁，曾经宣告世界的理想已不知去何方。</p><p>你常常希望将曾经未完成的心愿寄托给孩子，</p><p>但望着尚未还完的房贷，你笑笑摇摇头。</p><p>一天，他对你说，爸，我想学钢琴。</p><p>你没什么犹豫的，这些年你已经习惯了，</p><p>但那句“爸爸现在买不起”你始终说不出口。</p><p>孩子很懂事，说：爸爸没事，我学吉他也可以。</p><p>你看着这么懂事的孩子，却开心不起来。</p><p>那些年，你不再提起那些年。</p><p>50岁，孩子上了大学</p><p>他学的专业你有点不懂，</p><p>你知道工作不好找，</p><p>你和他深夜聊聊，</p><p>准备了四两白酒，</p><p>你说着那些曾经你最讨厌的话，</p><p>你们从交流变成了争吵，</p><p>你发现，你老了，老到可能都打不过这个18岁的孩子。</p><p>你说不过他，只能说一句：我是你爸！ </p><p>孩子看着你，知道再怎么争辩都没用，</p><p>这场确立你最后威严的酒局不欢而散，</p><p>在孩子回自己屋的路上叨叨了一句 “我不想活成你那样” 。</p><p>50岁的人了，怎么就哭了呢？</p><p>一定是酒太烈了，</p><p>对，一定是酒太烈了</p><p>54岁，孩子也工作了</p><p>似乎有一点理解你了，</p><p>但你却反了过来，</p><p>告诉他说不要妥协 。</p><p>55岁，孩子结婚了</p><p>你问他，你喜欢他吗。</p><p>他愣了愣，喜欢吧。</p><p>60岁，有时间旅行了</p><p>你和老伴准备好了，</p><p>孩子却说：爸妈，我工作忙了。</p><p>帮我照顾一下孩子。</p><p>你们退了机票，</p><p>又回到了30年前</p><p>65岁，孩子的孩子也上学了</p><p>你下定决心说：一定要环游世界，</p><p>可是手边的拐杖，</p><p>只能支撑你走到楼下花园。</p><p>68岁，你已走到了人生的尽头。</p><p>你躺在医院的病床上，</p><p>望着窗外泛黄的枯叶不知何时落下来。</p><p>你迷迷糊糊的看见医生摇了摇头，</p><p>你明白了，你要死了。</p><p>你并没有感到害怕。</p><p>你这一生，无怨无悔。</p><p>只是，有好多遗憾啊。</p><p>听说，人死时是最清醒的。</p><p>因为那时你的大脑里会倒叙你的一生。</p><p>生命的倒叙走向了最后一秒，</p><p>忽然间，身边的人哭了，你却笑了。</p><p>原来画面又回到了18岁的离别季，</p><p>那一天离别前，你们端坐在操场的石凳上，</p><p>各自心中思绪万千，嘴上却沉默无言。</p><p>终于，你放下了腼腆，</p><p>攥紧了她的手，</p><p>笑着对她说，</p><p>往后余生，</p><p>愿你拥有全部的权力，</p><p>而我愿拥有全部的义务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;author：浅悠悠&lt;/p&gt;
&lt;p&gt;致亲人，致自己&lt;/p&gt;
&lt;p&gt;5岁，&lt;/p&gt;
&lt;p&gt;你的梦想是什么呢？&lt;/p&gt;
&lt;p&gt;emm，环游世界！&lt;/p&gt;
&lt;p&gt;为什么呢？&lt;/p&gt;
&lt;p&gt;爷爷之前说的。&lt;/p&gt;
&lt;p&gt;9岁，告别了童言无忌&lt;/p&gt;
&lt;p&gt;然而玩耍依然是最大的乐趣。
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://qianyouyou.cn/2018/10/15/2018-04-24/"/>
    <id>http://qianyouyou.cn/2018/10/15/2018-04-24/</id>
    <published>2018-10-15T13:49:48.831Z</published>
    <updated>2018-04-28T11:01:20.104Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://qianyouyou.cn/">My Blog</a>! This is my very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://qianyouyou.cn/&quot;&gt;My Blog&lt;/a&gt;! This is my very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://qianyouyou.cn/tags/hexo/"/>
    
      <category term="github" scheme="http://qianyouyou.cn/tags/github/"/>
    
      <category term="npm" scheme="http://qianyouyou.cn/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>最小割求解最大权闭合子图</title>
    <link href="http://qianyouyou.cn/2018/10/10/2018-10-10/"/>
    <id>http://qianyouyou.cn/2018/10/10/2018-10-10/</id>
    <published>2018-10-10T13:17:18.000Z</published>
    <updated>2018-10-10T13:18:50.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。<br> 如下图：<br> <img src="https://img-blog.csdn.net/20170826170245647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="有向图"><br> 能选的子图有Ø,{4},{3,4},{2,4},{1,2,3,4},它们的权值分别为0,-1,5,-6,4.<br> 所以最大权闭合子图为{3,4}，权值为5.</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这个问题可以转化为最小割问题，用网络流解决。<br> 从源点s向每个正权点连一条容量为权值的边，每个负权点向汇点t连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。<br> <img src="https://img-blog.csdn.net/20170826171031814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="最小割建模"><br> 求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和-最小割）。</p><h3 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h3><h4 id="割掉一条边的含义"><a href="#割掉一条边的含义" class="headerlink" title="割掉一条边的含义"></a>割掉一条边的含义</h4><p>由于原图的边都是无穷大，那么割边一定是与源点s或汇点t相连的。</p><p>割掉s与i的边，表示不选择i点作为子图的点；<br> 割掉i与t的边，表示选择i点为子图的点。</p><p>如果s与i有边，表示i存在子图中；<br> 如果i与t有边，表示i不存在于子图中。</p><h4 id="合法性"><a href="#合法性" class="headerlink" title="合法性"></a>合法性</h4><p>只有s与t不连通时，才能得到闭合子图。</p><p>如果s与t连通，则存在点i,j，使得s到i有边，i到j连通，j到t有边，所以j一定是i的后继，但选择了i，没有选择j，不是闭合子图。</p><p>如果s与t不连通，选择了正权点i，一定选择了i后继中的所有负权点。设j是i的后继中的正权点，则割掉s到j的边是没有意义的，最小割不会割掉它，则j一点被选中，所以i的所有后继都被选中，符合闭合图的定义。</p><h4 id="最优性"><a href="#最优性" class="headerlink" title="最优性"></a>最优性</h4><p>最小割=(不选的正权之和+要选的负权绝对值之和）<br> 最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割<br> 因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>POJ2987_Firing</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="最小割" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
      <category term="最大权闭合子图" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统三大经典同步问题</title>
    <link href="http://qianyouyou.cn/2018/10/09/2018-10-09/"/>
    <id>http://qianyouyou.cn/2018/10/09/2018-10-09/</id>
    <published>2018-10-09T09:04:39.000Z</published>
    <updated>2019-02-23T09:20:24.818Z</updated>
    
    <content type="html"><![CDATA[<p>用专业术语来说, 进程是程序的一次动态执行.说简单点, 就是进程是系统中的某个任务.操作系统中有多个任务需要执行, 那么怎样执行才能使它们同步呢? 即如何让任务并发执行互不影响呢? 这就引出了进程同步中的经典问题: 生产者消费者问题, 哲学家进餐问题, 读写问题</p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>有一群生产者进程在生产产品, 并将这些产品提供给消费者进程取消费. 为使生产者进程与消费者进程能并发进行, 在两者间设置了一个具有n个缓冲区的缓冲池, 生产者进程将其所生产的产品翻入缓冲区中, 消费者进程可从一个缓冲区中取走产品取消费.生产者消费者进程都以异步方式进行, 但它们之间必须保持同步, 不允许消费者进程到空缓冲区去取产品, 也不允许生产者进程向已满的缓冲区投放产品.</p><p>一个缓冲池中有n个缓冲区, 只要缓冲池未满, 生产者便可以投放产品; 缓冲池为空, 消费者便可以消费产品</p><h3 id="法一-记录型信号量"><a href="#法一-记录型信号量" class="headerlink" title="法一:记录型信号量"></a>法一:记录型信号量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//生产者消费者问题</span><br><span class="line">//记录型信号量</span><br><span class="line">//缓冲池中有n个缓冲区, 互斥信号量mutex, </span><br><span class="line">//信号量empty表示空缓冲区数量, full表示满缓冲区的数量</span><br><span class="line">int in = out = 0;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = 1, empty = n, full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        producer an item nextp;</span><br><span class="line">        wait(empty);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();</span><br><span class="line">        consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 对信号量的wait()和signal()操作必定是成对出现的.</p><h3 id="法二-AND型信号量"><a href="#法二-AND型信号量" class="headerlink" title="法二:AND型信号量"></a>法二:AND型信号量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//AND型信号量</span><br><span class="line">//Swait(empty, mutex)代替wait(empty)和wait(mutex)</span><br><span class="line">//Ssignal(mutex,full)代替signal(mutext)和signal(full)</span><br><span class="line">//Swait(full, mutex)代替wait(full)和wait(mutex)</span><br><span class="line">//Ssignal(mutex, empty)代替signal(mutex)和signal(empty)</span><br><span class="line">int in = out = 0;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = 1, empty = n, full = 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        producer an item nextp;</span><br><span class="line">        Swait(empty, mutex);</span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % n;</span><br><span class="line">        Ssignal(mutex, full);</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        Swait(full, mutex);</span><br><span class="line">        nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % n;</span><br><span class="line">        Ssignal(mutex, empty);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">    &#125; while(true);</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();</span><br><span class="line">        consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="法三-管程"><a href="#法三-管程" class="headerlink" title="法三: 管程"></a>法三: 管程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//管程</span><br><span class="line">//建立管程producerconsumer,PC</span><br><span class="line">/*</span><br><span class="line">put(x), 生产者利用该过程将自己生产的产品投放到缓冲池中, 并用整型变量count表示缓冲池中已有的产品数目,当</span><br><span class="line">count&gt;=N时, 表示缓冲池已满,生产者需等待.</span><br><span class="line">get(x), 消费者利用该过程从缓冲池中取出一个产品, 当count&lt;=0时, 表示缓冲池已无可用的产品, 消费者需等待</span><br><span class="line">condition 为notfull和notempty</span><br><span class="line">cwait(condition), 当管程被一个进程占用时, 其他进程调用该进程时阻塞, 并挂在条件condition的队列上</span><br><span class="line">csignal(condition), 唤醒在cwait执行后阻塞在条件condition队列上的进程, 如果这样的进程不止一个, 则选择其中一个</span><br><span class="line">实施唤醒操作, 如果队列为空, 则无操作而返回.</span><br><span class="line">*/</span><br><span class="line">Monitor producerconsumer &#123;</span><br><span class="line">    item buffer[N];</span><br><span class="line">    int in, out;</span><br><span class="line">    condition notfull, notempty;</span><br><span class="line">    int count;</span><br><span class="line">    public:</span><br><span class="line">        void put(item x) &#123;</span><br><span class="line">            if (count &gt;= N) cwait(notfull);</span><br><span class="line">            buffer[in] = x;</span><br><span class="line">            in = (in + 1) % N;</span><br><span class="line">            count++;</span><br><span class="line">            ssignal(notempty);</span><br><span class="line">        &#125;</span><br><span class="line">        void get(item x) &#123;</span><br><span class="line">            if (count &lt;= 0) cwait(notempty);</span><br><span class="line">            x = buffer[out];</span><br><span class="line">            out = (out + 1) % N;</span><br><span class="line">            count--;</span><br><span class="line">            csignal(notfull);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            in = 0;</span><br><span class="line">            out = 0;</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;PC;</span><br><span class="line"></span><br><span class="line">void producer() &#123;</span><br><span class="line">    item x;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        producer an item in nextp;</span><br><span class="line">        PC.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    item x;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        PC.get(x);</span><br><span class="line">        consumer the item in nextc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        producer();</span><br><span class="line">        consumer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>五个哲学家公用一张圆桌, 分别坐在周围的五张桌子上, 在圆桌上有五个碗和五只筷子交叉排列, 它们的生活方式是交替的进行思考和进餐. 哲学家进行思考时不用筷子, 饥饿时取一只他两边的任意一只筷子(默认取左边的筷子, 没有时取右边的, 都没有时就取不了), 当他有两只筷子时就能进餐. 进餐后, 放下筷子继续思考.若只有一只筷子, 不放弃该筷子并等待拥有另一只筷子时再进餐.</p><p>用一个信号量表示一只筷子, 共五个信号量 semaphore chopsitck[5] = {1, 1, 1, 1, 1}; , 为 1 表示筷子未拿起, 为0表示筷子被拿起.那么第i为科学家的进餐活动就可以描述为</p><h3 id="法一-记录型信号量-1"><a href="#法一-记录型信号量-1" class="headerlink" title="法一:记录型信号量"></a>法一:记录型信号量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    wait(chopstick[i]);</span><br><span class="line">    wait(chopstick[(i + 1) % 5]);</span><br><span class="line">    //eat</span><br><span class="line">    signal(chopstick[i]);</span><br><span class="line">    signal(chopstick[(i + 1) % 5]);</span><br><span class="line">    //think</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure><p>假设五位哲学家都要拿筷子(都拿左手边), 那么将没有人可以 用餐, 就会陷入死锁状态.则哲学家进餐的解决方法:</p><p>1.至多允许四位哲学家拿同一边的筷子, 则可让至少一位哲学家先用餐, 用餐完后释放筷子进而让其他哲学家有机会用餐.</p><p>2.五位哲学家先竞争奇数(偶数)好筷子, 在竞争偶数(奇数)号筷子, 总会有一位哲学家能进餐.</p><h3 id="法二-AND型信号量-1"><a href="#法二-AND型信号量-1" class="headerlink" title="法二: AND型信号量"></a>法二: AND型信号量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//AND型信号量</span><br><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line">do &#123;</span><br><span class="line">    //think</span><br><span class="line">    Swait(chopsitck[(i + 1) % 5], chopsitck[i]);</span><br><span class="line">    //eat</span><br><span class="line">    Ssignal(chopsitck[(i + 1) % 5], chopsitck[i]);</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>一个数据文件或记录可被多个进程所共享, 则我们称这个文件或记录为共享对象.读文件的进程称为Reader进程, 写文件的进程称为Writer进程.共享对象可以被多个Reader进程, 因为读进程并不会破坏数据, 但是Writer进程在任何时刻只能有一个, 且须与其他对象互斥的访问共享对象, 否则多个写进程会造成冲突. 读写者问题即一个Writer进程必须与其他进程互斥的访问共享对象.</p><p>设置写互斥信号量wmutex</p><p>设置读互斥信号量rmutex</p><p>整型变量readcount表示正在读的进程数目(Reader)</p><p>当readcount!=0时, 表示有Reader进程,此时不能进行Writer进程.</p><p>法一:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//记录型信号量</span><br><span class="line">semaphore rmutext = 1, wmutext = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line">void Reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        if (readcount == 0) &#123;</span><br><span class="line">            wait(wmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">        </span><br><span class="line">        perform read operation;</span><br><span class="line">        </span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        if (readcount == 0) &#123;</span><br><span class="line">            signal(wmutext);</span><br><span class="line">        &#125;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        perform write operation;</span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        Reader();</span><br><span class="line">        Writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二:</p><p>引入RN, 表示最多允许RN个Reader进程同时读</p><p>信号量L初始为RN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//信号量集</span><br><span class="line">int RN;</span><br><span class="line">semaphore L = RN, mx = 1;</span><br><span class="line">void Reader() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        Swait(L, 1, 1);</span><br><span class="line">        Swait(mx, 1, 0);</span><br><span class="line">        </span><br><span class="line">        perform read operation;</span><br><span class="line">        </span><br><span class="line">        Ssignal(L, 1);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line">void Writer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        Swait(mx, 1, 1; L, RN, 0);</span><br><span class="line">        perform write operation;</span><br><span class="line">        Ssignal(mx, 1);</span><br><span class="line">    &#125; while (true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">    cobegin</span><br><span class="line">        Reader();</span><br><span class="line">        Writer();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用专业术语来说, 进程是程序的一次动态执行.说简单点, 就是进程是系统中的某个任务.操作系统中有多个任务需要执行, 那么怎样执行才能使它们同步呢? 即如何让任务并发执行互不影响呢? 这就引出了进程同步中的经典问题: 生产者消费者问题, 哲学家进餐问题, 读写问题&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="系统编程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="多线程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多线程" scheme="http://qianyouyou.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>强连通图经典算法——Tarjan算法</title>
    <link href="http://qianyouyou.cn/2018/10/08/2018-10-08/"/>
    <id>http://qianyouyou.cn/2018/10/08/2018-10-08/</id>
    <published>2018-10-08T13:11:28.000Z</published>
    <updated>2018-10-08T13:13:50.288Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Tarjan 算法</strong></p><p><strong>一.算法简介</strong></p><p>Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。</p><p>我们定义：</p><p>如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914143526445-1192876799.png" alt="img"></p><p>例如：在上图中，{1 , 2 , 3 , 4 } , { 5 }　,  { 6 } 三个区域可以相互连通，称为这个图的强连通分量。</p><p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p><p>再Tarjan算法中，有如下定义。</p><p>DFN[ i ] : 在DFS中该节点被搜索的次序(时间戳)</p><p>LOW[ i ] : 为i或i的子树能够追溯到的最早的栈中节点的次序号</p><p>当DFN[ i ]==LOW[ i ]时，为i或i的子树可以构成一个强连通分量。</p><p><strong>二.算法图示</strong></p><p>以1为Tarjan 算法的起始点，如图</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914144921414-2016099517.png" alt="img"></p><p>顺次DFS搜到节点6</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914145231586-1855011628.png" alt="img"></p><p> 回溯时发现LOW[ 5 ]==DFN[ 5 ] ,  LOW[ 6 ]==DFN[ 6 ] ,则{ 5 } , { 6 } 为两个强连通分量。回溯至3节点，拓展节点4.</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914145758727-370899436.png" alt="img"></p><p>拓展节点1 ， 发现1再栈中更新LOW[ 4 ]，LOW[ 3 ] 的值为1</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914150752023-616745966.png" alt="img"></p><p> 回溯节点1，拓展节点2</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160914150954258-732799852.png" alt="img"></p><p>自此，Tarjan Algorithm 结束，{1 , 2 , 3 , 4 } , { 5 }　,  { 6 } 为图中的三个强连通分量。</p><p><img src="https://images2015.cnblogs.com/blog/1009519/201609/1009519-20160916105304086-271091564.png" alt="img"></p><p>不难发现，Tarjan Algorithm 的时间复杂度为O(E+V).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void Tarjan ( int x ) &#123;</span><br><span class="line">         dfn[ x ] = ++dfs_num ;</span><br><span class="line">         low[ x ] = dfs_num ;</span><br><span class="line">         vis [ x ] = true ;//是否在栈中</span><br><span class="line">         stack [ ++top ] = x ;</span><br><span class="line">         for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123;</span><br><span class="line">                  int temp = e[ i ].to ;</span><br><span class="line">                  if ( !dfn[ temp ] )&#123;</span><br><span class="line">                           Tarjan ( temp ) ;</span><br><span class="line">                           low[ x ] = gmin ( low[ x ] , low[ temp ] ) ;</span><br><span class="line">                 &#125;</span><br><span class="line">                 else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ;</span><br><span class="line">         &#125;</span><br><span class="line">         if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量</span><br><span class="line">                  vis[ x ] = false ;</span><br><span class="line">                  color[ x ] = ++col_num ;//染色</span><br><span class="line">                  while ( stack[ top ] != x ) &#123;//清空</span><br><span class="line">                           color [stack[ top ]] = col_num ;</span><br><span class="line">                           vis [ stack[ top-- ] ] = false ;</span><br><span class="line">                 &#125;</span><br><span class="line">                 top -- ;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Tarjan 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.算法简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。&lt;/p&gt;
&lt;p&gt;我们定义：&lt;/p&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Tarjan算法" scheme="http://qianyouyou.cn/tags/Tarjan%E7%AE%97%E6%B3%95/"/>
    
      <category term="强连通" scheme="http://qianyouyou.cn/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>ACM算法专用模板(持续更新中)</title>
    <link href="http://qianyouyou.cn/2018/10/05/2018-10-05/"/>
    <id>http://qianyouyou.cn/2018/10/05/2018-10-05/</id>
    <published>2018-10-05T06:16:34.000Z</published>
    <updated>2018-10-13T09:58:13.047Z</updated>
    
    <content type="html"><![CDATA[<p>标签：位运算，gcd，exgcd，欧拉筛，快速乘，快速幂，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，树链剖分，莫队，LCA，Trie树，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyed，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fa[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i = 0; i &lt; maxn; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x==fa[x] ? x : x=root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void Union(int px, int py)&#123;</span><br><span class="line">    px = root(px);</span><br><span class="line">    py = root(py);</span><br><span class="line">    if(px != py)&#123;</span><br><span class="line">        fa[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int head[maxn], cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u, w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="LCA-Tarjan"><a href="#LCA-Tarjan" class="headerlink" title="LCA(Tarjan)"></a>LCA(Tarjan)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e4 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, head[maxn], fa[maxn], head_2[maxn], cnt, cnt_2, sx;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">struct QUERY&#123;</span><br><span class="line">    int next, to, u, lca;</span><br><span class="line">&#125;query[maxn];</span><br><span class="line">void add_edge(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add_query(int u, int v)&#123;</span><br><span class="line">    query[cnt_2].next = head_2[u];</span><br><span class="line">    query[cnt_2].to = v;</span><br><span class="line">    query[cnt_2].u = u;</span><br><span class="line">    head_2[u] = cnt_2++;</span><br><span class="line">    query[cnt_2].next = head_2[v];</span><br><span class="line">    query[cnt_2].to = u;</span><br><span class="line">    query[cnt_2].u = v;</span><br><span class="line">    head_2[v] = cnt_2++;</span><br><span class="line">&#125;</span><br><span class="line">void init_edge()&#123;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void init_query()&#123;</span><br><span class="line">    memset(head_2, -1, sizeof(head_2));</span><br><span class="line">    cnt_2 = 0;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x = x == fa[x] ? x : root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x) &#123;</span><br><span class="line">    fa[x] = x;</span><br><span class="line">    for (int i = head[x]; i != -1; i = edge[i].next) &#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        tarjan(v);</span><br><span class="line">        fa[root(v)] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = true;</span><br><span class="line">    for (int i = head_2[x]; i != -1; i = query[i].next) &#123;</span><br><span class="line">        int v = query[i].to;</span><br><span class="line">        if (vis[v]) &#123;</span><br><span class="line">            query[i].lca = query[i^1].lca = root(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add_edge(u, v);</span><br><span class="line">        vis[v] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=n; i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            sx = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">    add_query(u, v);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    tarjan(sx);</span><br><span class="line">    for(int i = 0; i &lt; cnt_2; i+=2)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, query[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init_edge();</span><br><span class="line">        init_query();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">1 14</span><br><span class="line">8 5</span><br><span class="line">10 16</span><br><span class="line">5 9</span><br><span class="line">4 6</span><br><span class="line">8 4</span><br><span class="line">4 10</span><br><span class="line">1 13</span><br><span class="line">6 15</span><br><span class="line">10 11</span><br><span class="line">6 7</span><br><span class="line">10 2</span><br><span class="line">16 3</span><br><span class="line">8 1</span><br><span class="line">16 12</span><br><span class="line">16 7</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">*/</span><br><span class="line">//4 3</span><br></pre></td></tr></table></figure><h2 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h2><h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*解释：</span><br><span class="line">belong[x]x属于分块后的哪一块，Q[i]每个询问</span><br><span class="line">modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析</span><br><span class="line">注意：</span><br><span class="line">最后也可以不对询问id排序，直接保存到一个数组里面输出即可</span><br><span class="line">*/</span><br><span class="line">int a[nmax], belong[nmax];</span><br><span class="line">ll ans = 0;</span><br><span class="line">struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];</span><br><span class="line">bool cmp(node a, node b) &#123;</span><br><span class="line">if (belong[a.l] != belong[b.l]) return a.l &lt; b.l;</span><br><span class="line">else return a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;</span><br><span class="line">void modify(int pos, int tag) &#123;</span><br><span class="line">// ......... 增删操作</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">int sz = sqrt(n);</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;</span><br><span class="line">belong[i] = (i - 1) / sz + 1;</span><br><span class="line">&#125;</span><br><span class="line">sort(Q + 1, Q + 1 + m, cmp);</span><br><span class="line">int l = 1, r = 0;</span><br><span class="line">for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">while (l &lt; Q[i].l) modify(l++, -1);</span><br><span class="line">while (l &gt; Q[i].l) modify(--l, 1);</span><br><span class="line">while (r &gt; Q[i].r) modify(r--, -1);</span><br><span class="line">while (r &lt; Q[i].r) modify(++r, 1);</span><br><span class="line">Q[i].ans = ans;</span><br><span class="line">&#125;</span><br><span class="line">sort(Q + 1, Q + 1 + m, cmpid);</span><br><span class="line">for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra-邻接矩阵"><a href="#Dijkstra-邻接矩阵" class="headerlink" title="Dijkstra(邻接矩阵)"></a>Dijkstra(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int road[maxn][maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(road, inf, sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int u = 1; u&lt;=n; u++)&#123;</span><br><span class="line">        int minD = inf, k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(k == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = dis[k] + road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        road[u][v] = min(road[u][v], w);</span><br><span class="line">        //road[v][u] = min(road[v][u], w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int cas = 1; cas&lt;=n; cas++)&#123;</span><br><span class="line">        int minD = inf, kk = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                kk = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(kk == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        //add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dijkstra-heap"><a href="#Dijkstra-heap" class="headerlink" title="Dijkstra+heap"></a>Dijkstra+heap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">    NODE(int x, int y) : u(x), dis(y)&#123;&#125;</span><br><span class="line">    bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    priority_queue&lt;NODE&gt;que;</span><br><span class="line">    que.push(NODE(sx, 0));</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        NODE tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        int kk = tmp.u;</span><br><span class="line">        if(vis[kk])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                que.push(NODE(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">int SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(dis[v] &gt; dis[kk] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v] = true;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        sx = 1, ex = n;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            //add(v, u, w);   //双向边</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, SPFA(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="DINIC"><a href="#DINIC" class="headerlink" title="DINIC"></a>DINIC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DINIC优化"><a href="#DINIC优化" class="headerlink" title="DINIC优化"></a>DINIC优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn], cur[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        memcpy(cur, head, sizeof(head));</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DINIC-邻接矩阵"><a href="#DINIC-邻接矩阵" class="headerlink" title="DINIC(邻接矩阵)"></a>DINIC(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 307;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int f;</span><br><span class="line">&#125;;</span><br><span class="line">int sx,ex;</span><br><span class="line">int pre[maxn];</span><br><span class="line">NODE road[maxn][maxn];</span><br><span class="line">int n, m, N;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">    memset(pre,0,sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int d = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123;</span><br><span class="line">                pre[i] = pre[d] + 1;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex]!=0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int pos, int flow)&#123;</span><br><span class="line">    int f = flow;</span><br><span class="line">    if(pos==ex)</span><br><span class="line">        return flow;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123;</span><br><span class="line">            int a = road[pos][i].c - road[pos][i].f;</span><br><span class="line">            int t = dfs(i, min(a, flow));</span><br><span class="line">            road[pos][i].f += t;</span><br><span class="line">            road[i][pos].f -= t;</span><br><span class="line">            flow -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while(BFS())&#123;</span><br><span class="line">        sum+=dfs(sx,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = N;</span><br><span class="line">    memset(road,0,sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        road[u][v].c+=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,dinic());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm = 1e5+7;</span><br><span class="line">const int maxn = 1e4+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, cnt, sx, ex;</span><br><span class="line">int head[maxn], pre[maxn], dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int c;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void init()&#123;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = 1;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add_edge(int u, int v, int c, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c, int w)&#123;</span><br><span class="line">    add_edge(u, v, c, w);</span><br><span class="line">    add_edge(v, u, 0, -w);</span><br><span class="line">&#125;</span><br><span class="line">bool SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, -1, sizeof(pre));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            EDGE tmp = edge[i];</span><br><span class="line">            if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123;</span><br><span class="line">                dis[tmp.to] = dis[kk] + tmp.w;</span><br><span class="line">                pre[tmp.to] = i;</span><br><span class="line">                if(!vis[tmp.to])&#123;</span><br><span class="line">                    vis[tmp.to] = true;</span><br><span class="line">                    que.push(tmp.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != -1;</span><br><span class="line">&#125;</span><br><span class="line">int MCMF(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0, cost = 0;</span><br><span class="line">    while(SPFA(sx, ex))&#123;</span><br><span class="line">    int min_flow = inf;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            min_flow = min(min_flow, edge[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            edge[i].c -= min_flow;</span><br><span class="line">            edge[i^1].c += min_flow;</span><br><span class="line">            cost += min_flow * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += min_flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return cost;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, c, w;</span><br><span class="line">    ex = n+1;</span><br><span class="line">    for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w);</span><br><span class="line">        add(u,v,c, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(n+m==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,MCMF(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="匈牙利算法-邻接矩阵"><a href="#匈牙利算法-邻接矩阵" class="headerlink" title="匈牙利算法(邻接矩阵)"></a>匈牙利算法(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int N, K;</span><br><span class="line">int edge[maxn][maxn], head[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, 0, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x) &#123;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">if (edge[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">vis[i] = true;</span><br><span class="line">if (!head[i] || find_edge(head[i])) &#123;</span><br><span class="line">head[i] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">int x, y;</span><br><span class="line">for (int i = 1; i &lt;= K; i++)&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">edge[x][y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; Magyar(N) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int T, N, m;</span><br><span class="line">int head[maxn], link[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, u, to, w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(link, 0, sizeof(link));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x)&#123;</span><br><span class="line">    for(int i = head[x]; i!= -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v] = true;</span><br><span class="line">            if (!link[v] || find_edge(link[v])) &#123;</span><br><span class="line">link[v] = x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int ans = Magyar(N);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N, &amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">        add(x, y, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        memset(edge, 0, sizeof(edge));</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM算法最小权匹配"><a href="#KM算法最小权匹配" class="headerlink" title="KM算法最小权匹配"></a>KM算法最小权匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KM算法最小权匹配优化版"><a href="#KM算法最小权匹配优化版" class="headerlink" title="KM算法最小权匹配优化版"></a>KM算法最小权匹配优化版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int head[maxn], cnt, top, dfs_num, col_num;</span><br><span class="line">int dfn[maxn], low[maxn], Stack[maxn], color[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void Tarjan(int x)&#123;</span><br><span class="line">    dfn[x] = ++dfs_num;</span><br><span class="line">    low[x] = dfs_num;</span><br><span class="line">    vis[x] = true;  //是否在栈中</span><br><span class="line">    Stack[++top] = x;</span><br><span class="line">    for(int i = head[x]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[x] = min(low[x], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[v])&#123;</span><br><span class="line">            low[x] = min(low[x], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x] == low[x])&#123;   //构成强连通分量</span><br><span class="line">        vis[x] = false;</span><br><span class="line">        color[x] = ++col_num;   //染色</span><br><span class="line">        while(Stack[top] != x)&#123; //清空</span><br><span class="line">            color[Stack[top]] = col_num;</span><br><span class="line">            vis [ Stack[ top-- ] ] = false ;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    top = dfs_num = col_num = cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    memset(dfn, 0, sizeof(dfn));</span><br><span class="line">    memset(low, 0, sizeof(low));</span><br><span class="line">    memset(color, 0, sizeof(color));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        if(!color[i])&#123;</span><br><span class="line">            Tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(col_num != 1)&#123;</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b)&#123;</span><br><span class="line">    return !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。</p><h3 id="O-logn-快速乘"><a href="#O-logn-快速乘" class="headerlink" title="O(logn)快速乘"></a>O(logn)快速乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline LL quick_mul(LL a,LL n,LL m)&#123;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-1-快速乘"><a href="#O-1-快速乘" class="headerlink" title="O(1)快速乘"></a>O(1)快速乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">#define MOL 123456789012345LL</span><br><span class="line">inline ll mul_mod_ll(ll a,ll b)&#123;</span><br><span class="line">    ll d=(ll)floor(a*(long double)b/MOL+0.5);</span><br><span class="line">    ll ret=a*b-d*MOL;</span><br><span class="line">    if(ret&lt;0)   ret+=MOL;</span><br><span class="line">    return   ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，使用浮点数计算 a<em>b/MOL 的值，关键在于第二句，显然  a</em>b -  d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。</p><p>考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline ll ksc(ll x,ll y,ll mod)&#123;</span><br><span class="line">    return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getid(int x)&#123;</span><br><span class="line">return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1;i&lt;=n;++i)&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    v.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end());</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="统计1的个数"><a href="#统计1的个数" class="headerlink" title="统计1的个数"></a>统计1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int NumberOfOne(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">    n &amp;= (n-1);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标签：位运算，gcd，exgcd，欧拉筛，快速乘，快速幂，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，树链剖分，莫队，LCA，Trie树，KMP，AC自
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="计算几何" scheme="http://qianyouyou.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>NAIPC2016-F.Mountain Scenes</title>
    <link href="http://qianyouyou.cn/2018/10/02/2018-10-02/"/>
    <id>http://qianyouyou.cn/2018/10/02/2018-10-02/</id>
    <published>2018-10-02T07:55:38.000Z</published>
    <updated>2018-10-02T08:12:28.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1000ms</li><li>262144K</li></ul><p>An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various integral lengths, then aligns them with the bottom of a frame, rising vertically in columns, to form a mountain scene. A mountain scene must be uneven; if all columns are the same height, it’s a plain scene, not a mountain scene! It is possible that she may not use all of the ribbon.</p><p><a href="https://res.jisuanke.com/img/upload/20180914/0d311ad59ca6302ae44e05c553c59b205ecf2913.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/0d311ad59ca6302ae44e05c553c59b205ecf2913.png" alt="img"></a></p><p>If our artist has 44 inches of ribbon and a 2 \times 22×2 inch frame, she could form these scenes:</p><p><a href="https://res.jisuanke.com/img/upload/20180914/2e4d94cb5e3526193ec13f4402c8d7fbe533df16.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/2e4d94cb5e3526193ec13f4402c8d7fbe533df16.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/90ef24006d11e28c94eed98262a7ae555963c28d.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/90ef24006d11e28c94eed98262a7ae555963c28d.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/c43ed5f0716e4d776714586c04369d1299cccb7a.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/c43ed5f0716e4d776714586c04369d1299cccb7a.png" alt="img"></a> <a href="https://res.jisuanke.com/img/upload/20180914/474d838a889f76324ffecb940bd7bf5731cfca2d.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/474d838a889f76324ffecb940bd7bf5731cfca2d.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/116665c4b2c23c019afe8991e93f28786fc9c7dd.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/116665c4b2c23c019afe8991e93f28786fc9c7dd.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/5cc932933eb1b0c94e695090999f5b5cf88e7966.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/5cc932933eb1b0c94e695090999f5b5cf88e7966.png" alt="img"></a></p><p>She would not form these scenes, because they’re plains, not mountains!</p><p><a href="https://res.jisuanke.com/img/upload/20180914/61f02e20e1290a24e6e2bd70df3626df8d4b20de.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/61f02e20e1290a24e6e2bd70df3626df8d4b20de.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/8d83ffddd160ffd19a4a5522b9e73ef09bb02b39.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/8d83ffddd160ffd19a4a5522b9e73ef09bb02b39.png" alt="img"></a><a href="https://res.jisuanke.com/img/upload/20180914/100a7f671569edb6ba5decbc74cadcc130a56da4.png" target="_blank" rel="noopener"><img src="https://res.jisuanke.com/img/upload/20180914/100a7f671569edb6ba5decbc74cadcc130a56da4.png" alt="img"></a></p><p>Given the length of the ribbon and the width and height of the frame, all in inches, how many different mountain scenes can she create? Two scenes are different if the regions covered by ribbon are different. There’s no point in putting more than one piece of ribbon in any column.</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input will consist of a single line with three space-separated integers nn, ww and hh, where nn (0 \le n \le 10,000)(0≤n≤10,000) is the length of the ribbon in inches, w (1 \le w \le 100)w(1≤w≤100) is the width and hh (1 \le h \le 100)(1≤h≤100)is the height of the frame, both in inches.</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Output a single integer, indicating the total number of mountain scenes our artist could possibly make, modulo 10^9 + 7109+7.</p><h4 id="样例输入1复制"><a href="#样例输入1复制" class="headerlink" title="样例输入1复制"></a>样例输入1复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25 5 5</span><br></pre></td></tr></table></figure><h4 id="样例输出1复制"><a href="#样例输出1复制" class="headerlink" title="样例输出1复制"></a>样例输出1复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7770</span><br></pre></td></tr></table></figure><h4 id="样例输入2复制"><a href="#样例输入2复制" class="headerlink" title="样例输入2复制"></a>样例输入2复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 5 5</span><br></pre></td></tr></table></figure><h4 id="样例输出2复制"><a href="#样例输出2复制" class="headerlink" title="样例输出2复制"></a>样例输出2复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6050</span><br></pre></td></tr></table></figure><h4 id="样例输入3复制"><a href="#样例输入3复制" class="headerlink" title="样例输入3复制"></a>样例输入3复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 10 1</span><br></pre></td></tr></table></figure><h4 id="样例输出3复制"><a href="#样例输出3复制" class="headerlink" title="样例输出3复制"></a>样例输出3复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1022</span><br></pre></td></tr></table></figure><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>问题可以转化为有n个物品，现有w个盘子，每个盘子的容量为[0,h]，所有盘子放的物品不能全部相同，n个物品选[0,n]个物品放进盘中，共有多少种方法。</p><p>首先，利用dp，第一层i为第i个盘子，第2层j为前i个盘子共放置j个物品共有多少种方法。这样<code>dp[i][j]+=dp[i-1][j-k]</code>，其中k[0,h]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxn = 1e4+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll dp[107][maxn];</span><br><span class="line">ll n,w,h;</span><br><span class="line">ll solve()&#123;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    if(n &gt; w * h)&#123;</span><br><span class="line">        n = w*h;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=w; i++)&#123;</span><br><span class="line">        for(int j = 0;j&lt;=n; j++)&#123;</span><br><span class="line">            for(int k = 0; k&lt;=h&amp;&amp;k&lt;=j; k++)&#123;</span><br><span class="line">                dp[i][j]+=dp[i-1][j-k];</span><br><span class="line">                dp[i][j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (dp[w][n] - 1 - n/w + mod)%mod;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;w,&amp;h))&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;1000ms&lt;/li&gt;
&lt;li&gt;262144K&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various in
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>分时最短路+次小生成树+最小费用最大流题解</title>
    <link href="http://qianyouyou.cn/2018/09/29/2018-09-29/"/>
    <id>http://qianyouyou.cn/2018/09/29/2018-09-29/</id>
    <published>2018-09-29T07:54:04.000Z</published>
    <updated>2018-10-02T08:03:36.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-A-高速"><a href="#问题-A-高速" class="headerlink" title="问题 A: 高速"></a>问题 A: 高速</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 15  解决: 4<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1027&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1915" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1915&amp;cid=1027" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>教练开车去东北，因为比赛地点在东北。共有 n 座城，已知教练在 s 城，比赛地点在 t 城，n 座城之间共有 m 条高速，每条高速连接两座城市，每两座城市之间最多两条高速。每条高速都有权值 v，表示两个城市之间最快可以 v 小时到达。</p><p>然而高速不是永久开放的，每条高速都会有一段开放时间 [ a，b ]，表示该高速在 a ~ b 小时范围之间开放，其余时间处于关闭状态，不能通过任何车辆。例如 [ 24，27 ]表示该路在第 24 小时到 27 小时之间开放。</p><p>已知教练在 0 时刻出发，他最快多少小时可以到达 t 城。</p><p>（PS：由于刹车坏掉了，因此车一旦启动就不能停下来，也就是说车不能停于某点或某边，不过车可以来回无限次在两地之间穿梭）</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，首行输入 t，表示 t 组样例。</p><p>图为无向图，s 城固定为 1 点，t 城固定为 n 点。</p><p>每组样例第 1 行，输入n，m（1 &lt; n ≤ 100，0 &lt; m ≤ 1000）。</p><p>接下来 m 行，每行 5 个数值x，y，v，l，f。表示 x 与 y 有一条高速，耗时为 v。该路开放时间为[ l，f ]。</p><p>数据保证教练可以到达终点，只不过是时间问题。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出一个数值，即最少耗时。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 4</span><br><span class="line">2 3 1 5 11</span><br><span class="line">2 5 1 3 18</span><br><span class="line">4 3 1 7 14</span><br><span class="line">1 4 1 0 15</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><blockquote><p>tag：图论、分时最短路</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">//最短路</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">int dis[maxn];  //当前该点到原点最短距离</span><br><span class="line">bool vis[maxn]; //是否访问过</span><br><span class="line">int head[maxn]; //点集</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next,to,w,l,r;  //上一条边，下一个点，权值，左值，右值</span><br><span class="line">&#125;edge[2*maxn];  //边集</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u,dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];  //点集加最短距离</span><br><span class="line">void add(int u, int v, int w, int l,int r)&#123; //构建边集</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].l = l;</span><br><span class="line">    edge[cnt].r = r;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;    //初始化</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;    //读入数据</span><br><span class="line">    int u,v,w,l,r;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,&amp;u,&amp;v,&amp;w,&amp;l,&amp;r);</span><br><span class="line">        add(u,v,w,l,r);</span><br><span class="line">        add(v,u,w,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init_data(int kk)&#123; //初始化数据</span><br><span class="line">    vis[kk] = false;</span><br><span class="line">    dis[kk] = maxx;</span><br><span class="line">&#125;</span><br><span class="line">int solve(int s)&#123;</span><br><span class="line">    priority_queue&lt;NODE&gt;q;  //储存最短距离</span><br><span class="line">    q.push(NODE(s,0));  //读入原点</span><br><span class="line">    while(!q.empty())&#123;  //队列为空则无法到达</span><br><span class="line">        int kk = q.top().u; //储存当前最短距离下标</span><br><span class="line">        int minD = q.top().dis; //储存当前最短距离</span><br><span class="line">        q.pop();</span><br><span class="line">        if(kk==n)   //若下标为目标值，return</span><br><span class="line">            return minD;</span><br><span class="line">        vis[kk] = true; //该点是否访问</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;   //松弛边</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD&lt;=edge[l].r&amp;&amp;minD&gt;=edge[l].l&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to]));   //将松弛后的边压入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        init_data(kk);  //初始化数据</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        init(); //初始化</span><br><span class="line">        read(); //读入</span><br><span class="line">        printf(&quot;%d\n&quot;,solve(1));    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-千年老二"><a href="#问题-C-千年老二" class="headerlink" title="问题 C: 千年老二"></a>问题 C: 千年老二</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 24  解决: 12<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1028&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1913" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1913&amp;cid=1028" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>雷婷与万钧是青梅竹马，无论是考试还是玩游戏，雷婷总是第一，而万钧总是第二，尽管万钧有做第一的实力，但他每次都会把第一让给雷婷，仅因为每次读榜单时雷霆万钧听起来是那么顺耳。这天，雷婷参加了 acm 选拔，万钧也跟着雷婷参加。题目是这样的：</p><p>有 n 个节点，编号为 1~n，有 m 条边，每条边都有一个距离。两点之间最多只有 1 条边。现在你需要选取 n-1 条边，使得所有点都连接起来都有通路。n-1 条边距离之和越小分数越高。</p><p>万钧立马意识到这道题是求最小生成树的，并且每个人的答案不能相同，万钧根据瞪眼法立马瞪出了答案，然而他还是等待雷婷先做完。现在雷婷已经找到了距离最短的1种方案，不过他俩太心有灵犀了，答案一模一样，万钧想获得第 2 名，请你帮万钧想一种方案，距离之和越短越好，但不能和雷婷的结果相同。一条边不同即可认为不同。如果找不到输出 -1。当然存在一种情况，如果雷婷的方案是没有方案求出最短距离，即表示该图没有最小生成树，即输出 -1。总之雷婷的方案是最优解的一种。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>存在多组数据，第一行一个正整数 t，表示有 t 组数据。</p><p>每组数据第一行有两个整数 n 和 m（2 ≤ n ≤ 100，1 ≤ m ≤ 1000)，之后 m 行，每行三个正整数 s，e，w，表示 s 到 e 的双向路的权值为 w。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出次小生成树的值（如果存在多个最小生成树或仅有一个树，则次小生成树就是最小生成树，输出-1），如果不存在输出 -1。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">3 1 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><blockquote><p>tag：图论、次小生成树</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">//次小生成树</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int L=1e5+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const int maxn=1000+7;</span><br><span class="line">int father[maxn],n,m,num[maxn],nPos;    //父节点（并查集），点数，边数，最小生成树点集，当前访问方位</span><br><span class="line">struct node&#123;</span><br><span class="line">    int s,y,w;</span><br><span class="line">&#125;edge[L];   //边集，左端点，右端点，权值</span><br><span class="line">void init()&#123;    //初始化并查集</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">        father[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;    //并查集，构造父节点</span><br><span class="line">    return father[x]==x?x:father[x]=root(father[x]);</span><br><span class="line">&#125;</span><br><span class="line">void unite(int x,int y)&#123;    //并查集，合并两个联通图</span><br><span class="line">    x=root(x);</span><br><span class="line">    y=root(y);</span><br><span class="line">    if(x!=y)</span><br><span class="line">        father[y]=x;</span><br><span class="line">&#125;</span><br><span class="line">int alike(int x,int y)&#123; //并查集，判断是否为同一连通图</span><br><span class="line">    return root(x)==root(y);</span><br><span class="line">&#125;</span><br><span class="line">int cmp(node a,node b)&#123; //sort结构体排序</span><br><span class="line">    return a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line">int secondTree(int pos) //次小生成树</span><br><span class="line">&#123;</span><br><span class="line">    init(); //初始化</span><br><span class="line">    int sum=0,cnt=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)    //对于删去边后的图进行最小生成树运算</span><br><span class="line">    &#123;</span><br><span class="line">        if(cnt==n-1)</span><br><span class="line">            break;</span><br><span class="line">        if(i==pos)</span><br><span class="line">            continue;</span><br><span class="line">        if(!alike(edge[i].s,edge[i].y))&#123;</span><br><span class="line">            unite(edge[i].s,edge[i].y);</span><br><span class="line">            sum+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt!=n-1?-1:sum; //判断删除边后是否能构成最小生成树</span><br><span class="line">&#125;</span><br><span class="line">int kruskal()&#123;  //最小生成树</span><br><span class="line">    init();</span><br><span class="line">    sort(edge,edge+m,cmp);  //对边进行权值排序</span><br><span class="line">    int sum=0,cnt=0;</span><br><span class="line">    for(int i=0;i&lt;m;i++)    //每次选择最小且未访问过的一条边</span><br><span class="line">    &#123;</span><br><span class="line">        if(cnt==n-1)</span><br><span class="line">            break;</span><br><span class="line">        if(!alike(edge[i].s,edge[i].y))&#123;</span><br><span class="line">            unite(edge[i].s,edge[i].y);</span><br><span class="line">            sum+=edge[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">            num[++nPos]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt!=n-1?-1:sum; //判断边是否大于等于n-1，否则输出-1</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;    //读入数据</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;edge[i].s,&amp;edge[i].y,&amp;edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;   //解决方案</span><br><span class="line">    int Min=inf;</span><br><span class="line">    nPos=0;</span><br><span class="line">    int mst=kruskal();  //最小生成树值</span><br><span class="line">    if(mst==-1) &#123;   //没有最小生成树即输出-1</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=nPos;i++)&#123;   //对最小生成树的每条边进行遍历，选择删边后的最小值</span><br><span class="line">        int secmst=secondTree(num[i]);</span><br><span class="line">        if(secmst!=-1)  //若没有次小生成树输出-1</span><br><span class="line">            Min=min(Min,secmst);</span><br><span class="line">        &#125;</span><br><span class="line">    if(Min!=inf&amp;&amp;Min!=mst)</span><br><span class="line">        printf(&quot;%d\n&quot;,Min); //输出结果</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        read(); //读入数据</span><br><span class="line">        solve();    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-给力台球厅"><a href="#问题-F-给力台球厅" class="headerlink" title="问题 F: 给力台球厅"></a>问题 F: 给力台球厅</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 10  解决: 3<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1028&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1912" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1912&amp;cid=1028" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>教练爱打台球。这天偶遇一家台球厅，便进去看看。然而这家台球厅貌似和平常的台球厅不太一样，它的每张桌面上的洞都是随机分布在桌面上的，球也是随机摆放的。</p><p>教练立即意识到，此台球厅的桌面不符合正态分布之概率密度函数，而是呈离散分布，顿时患有强迫症的教练心里就不舒服了。为了平缓一下翻腾的内心，教练随机选取了一张球和洞数量一样的球桌，望着奇怪的桌面与奇怪的球，教练脑袋上不禁长出了大把大把的草：如果能求出所有球入洞的最短距离之和该有多好啊。</p><p>现有一个桌面面积为 n×m 的台球桌，将台球桌分成 n×m 个小格，台球桌上有许多的洞和许多的球，均匀分布在小格里，且每个小格只有三种状态，有球，有洞，空白。球用 @ 表示，洞用 # 表示，空白的地方用 * 表示。每个洞只能容纳一个球，球每次只能按照上下左右的方向移动，且每移动一格视为移动 1 个单位长度。当一个球被另一个球挡住时，它可以跳球，所以每一个球都可以完全无视其他球或洞的存在而继续前行，直到进自己心仪的洞。现求所有球进洞的距离之和最小是多少。如果你能帮教练解决这道题，恭喜你就是 ACM 队员了（每个球只能进一个洞，每个洞内有球的话就变成空白状态）</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，首行输入 m，n，即矩形台球桌面的边长。(2 ≤ m，n ≤ 20，球最多100个，洞最多100个，保证洞和球数量相等)</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，即所有球入洞的距离最短是多少。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">*#</span><br><span class="line">@*</span><br><span class="line">7 8</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">@@@@#@@@</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br><span class="line">****#***</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">28</span><br></pre></td></tr></table></figure><blockquote><p>tag：图论、最小费用最大流</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//网络流</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF = 0x3f3f3f3f; //无穷大</span><br><span class="line">const int maxn = 60007;</span><br><span class="line">const int maxm = 1000007;</span><br><span class="line">int vis[maxn],d[maxn],pre[maxn],a[maxn],m,n;    //是否访问，最短路，前置节点，流量，边集，点集</span><br><span class="line">char mp[107][107];  //台球地图</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int u, v, c, cost, next;</span><br><span class="line">&#125;edge[maxm];    //网络流边集</span><br><span class="line"></span><br><span class="line">int s[maxn], cnt;   //每个点流量</span><br><span class="line"></span><br><span class="line">void init()&#123;    //初始化</span><br><span class="line">cnt = 0;</span><br><span class="line">memset(s, -1, sizeof(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int u, int v, int c, int cost)&#123;    //对两点之间进行单向边建立</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].cost = cost;</span><br><span class="line">edge[cnt].c = c;</span><br><span class="line">edge[cnt].next = s[u];</span><br><span class="line">s[u] = cnt++;   //建立单向边</span><br><span class="line">edge[cnt].u = v;</span><br><span class="line">edge[cnt].v = u;</span><br><span class="line">edge[cnt].cost = -cost;</span><br><span class="line">edge[cnt].c = 0;</span><br><span class="line">edge[cnt].next = s[v];</span><br><span class="line">s[v] = cnt++;   //建立双向边</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool spfa(int ss, int ee,int &amp;flow,int &amp;cost)&#123;  //以距离为费用寻找最短路，以最短路为当前增广路</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">memset(d, INF, sizeof d);</span><br><span class="line">memset(vis, 0, sizeof vis); //初始化</span><br><span class="line">d[ss] = 0, vis[ss] = 1, pre[ss] = 0, a[ss] = INF;</span><br><span class="line">q.push(ss);</span><br><span class="line">while (!q.empty())&#123; //spfa以费用为距离寻找最短路</span><br><span class="line">int u = q.front();q.pop();</span><br><span class="line">vis[u] = 0;</span><br><span class="line">for (int i = s[u]; ~i; i = edge[i].next)&#123;   //和当前点相连所有边松弛过程</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">if (edge[i].c&gt;0&amp;&amp; d[v]&gt;d[u] + edge[i].cost)&#123;    //松弛过程</span><br><span class="line">d[v] = d[u] + edge[i].cost;</span><br><span class="line">pre[v] = i;</span><br><span class="line">a[v] = min(a[u], edge[i].c);    //取最小值</span><br><span class="line">if (!vis[v])&#123;</span><br><span class="line">vis[v] = 1;</span><br><span class="line">q.push(v);     //压入待松弛队列</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (d[ee] == INF) return 0; //判断是否有最短路，无说明最大流完成</span><br><span class="line">flow += a[ee];</span><br><span class="line">cost += d[ee]*a[ee];</span><br><span class="line">int u = ee;</span><br><span class="line">while (u != ss)&#123;    //求当前最短路下的流量和</span><br><span class="line">edge[pre[u]].c -= a[ee];</span><br><span class="line">edge[pre[u] ^ 1].c += a[ee];</span><br><span class="line">u = edge[pre[u]].u;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int MCMF(int ss, int ee)&#123;   //最小费用最大流</span><br><span class="line">int cost = 0, flow=0;   //初始化</span><br><span class="line">while (spfa(ss, ee, flow, cost));   //寻找增广路径，直到没有增广路径为止</span><br><span class="line">return cost;    //返回最大流费用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct point&#123;</span><br><span class="line">    int x,y;    //球坐标，洞坐标</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    point H[107],P[107];    //建立球集与洞集</span><br><span class="line">    int h=0,p=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;   //输入地图</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;mp[i]);</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if(mp[i][j]==&apos;#&apos;)&#123;  //若为洞则坐标加入洞集</span><br><span class="line">                H[h].x=i;</span><br><span class="line">                H[h].y=j;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(mp[i][j]==&apos;@&apos;)&#123; //若为球则坐标加入球集</span><br><span class="line">                P[p].x=i;</span><br><span class="line">                P[p].y=j;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init(); //初始化</span><br><span class="line">    for(int i=0;i&lt;h;i++)</span><br><span class="line">        for(int j=0;j&lt;p;j++)&#123;</span><br><span class="line">        int c=fabs(H[i].x-P[j].x)+fabs(H[i].y-P[j].y);</span><br><span class="line">             add(i+1,h+j+1,1,c);</span><br><span class="line">        &#125;   //建立球与洞之间的路径</span><br><span class="line">    for(int i=0;i&lt;h;i++)    //建立超级源点</span><br><span class="line">        add(0,i+1,1,0);</span><br><span class="line">    for(int i=0;i&lt;p;i++)    //建立超级汇点</span><br><span class="line">        add(h+1+i,h+p+1,1,0);</span><br><span class="line">    printf(&quot;%d\n&quot;,MCMF(0,h+p+1));   //最小费用最大流</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(!(m||n))</span><br><span class="line">            break;</span><br><span class="line">        solve();    //解决方案</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题-A-高速&quot;&gt;&lt;a href=&quot;#问题-A-高速&quot; class=&quot;headerlink&quot; title=&quot;问题 A: 高速&quot;&gt;&lt;/a&gt;问题 A: 高速&lt;/h1&gt;&lt;p&gt;时间限制: 1 Sec  内存限制: 128 MB&lt;br&gt;提交: 15  解决: 4&lt;br&gt;[&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="最小费用最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="次小生成树" scheme="http://qianyouyou.cn/tags/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>利用容斥原理求解范围内互素数对数例题</title>
    <link href="http://qianyouyou.cn/2018/09/26/2018-09-26/"/>
    <id>http://qianyouyou.cn/2018/09/26/2018-09-26/</id>
    <published>2018-09-26T12:11:17.000Z</published>
    <updated>2018-09-26T12:30:10.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>Given 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs.<br>Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.<br><strong>Yoiu can assume that a = c = 1 in all test cases.</strong> </p><p>Input</p><p>The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.<br>Each case contains five integers: a, b, c, d, k, 0 &lt; a &lt;= b &lt;= 100,000, 0 &lt; c &lt;= d &lt;= 100,000, 0 &lt;= k &lt;= 100,000, as described above. </p><p>Output</p><p>For each test case, print the number of choices. Use the format in the example. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 3 1 5 1</span><br><span class="line">1 11014 1 14409 9</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 9</span><br><span class="line">Case 2: 736427</span><br></pre></td></tr></table></figure><p>Hint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5).</span><br></pre></td></tr></table></figure><p>题意：</p><p>求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数</p><p>题解：</p><p>gcd(a,b)=k，我们可以写成gcd(a/k,b/k)=1。因此我们只需求[1,b/k]和[1,d/k]范围内互素数的对数。首先利用欧拉函数很容易求解[1,min(a,b)]范围内互素数的对数，将φ(1~min(a,b))全部加起来，就求出1~min(a,b)所有互素对数，假设d永远＞=b,那么接下来我们只需求[1,b]范围内和[b+1,d]范围内互素的数，此时需用容斥原理。对于[1,b]范围内和x互素的数，最多为b个，而在这b个数中我们只需减去不互素的对数即可。我们需先求出x的所有质因数，然后这些质因数的倍数在[1,b]范围内的个数为b/g，因此只需减去这些对数即可，然而由于会有重复的情况出现，因此需用容斥原理处理一下。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll oula[maxn];</span><br><span class="line">int a,b,c,d,k;</span><br><span class="line">struct Number</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int prime[20];</span><br><span class="line">&#125; fac[maxn];</span><br><span class="line">void getLa( int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(fac,0,sizeof(fac));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">        oula[i] = i;</span><br><span class="line">    for(int i = 2; i &lt; n; ++i)</span><br><span class="line">        if( oula[i] == i )</span><br><span class="line">            for(int j = 1; j*i &lt; n; ++j)&#123;</span><br><span class="line">                oula[j*i] -= oula[j*i]/i;</span><br><span class="line">                fac[j*i].prime[fac[j*i].cnt++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inc(int index,int b,int m)</span><br><span class="line">&#123;</span><br><span class="line">    ll r=0,t;</span><br><span class="line">    for(int i=index; i&lt;fac[m].cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=b/fac[m].prime[i];//b范围内有多少个数和m的因数为prime[i]</span><br><span class="line">        r+=t-inc(i+1,t,m);//减去这些数就是b范围内和m互质的数的个数。</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">    b/=k;</span><br><span class="line">    d/=k;</span><br><span class="line">    if(b&gt;d)</span><br><span class="line">        swap(b,d);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= b; ++i)</span><br><span class="line">        ans+=oula[i];</span><br><span class="line">    for(int i=b+1; i&lt;=d; ++i)</span><br><span class="line">        ans+=b-inc(0,b,i);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    getLa(maxn);</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cas = 1; cas&lt;=t; ++cas)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        if(k==0)&#123;</span><br><span class="line">            printf(&quot;Case %d: 0\n&quot;,cas);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;,cas,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面那道和上面这道类似，稍微改一下就好。</p><h2 id="Visible-Trees"><a href="#Visible-Trees" class="headerlink" title="Visible Trees"></a>Visible Trees</h2><p>There are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see.<br>If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him.</p><p>Input</p><p>The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000)</p><p>Output</p><p>For each test case output one line represents the number of trees Farmer Sherlock can see.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>题意</p><p>求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数。当然和上面不同之处在于对数左右数不同也认为不同。(2,3)和(3,2)为不同的对数。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll oula[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">struct Number</span><br><span class="line">&#123;</span><br><span class="line">    int cnt;</span><br><span class="line">    int prime[20];</span><br><span class="line">&#125; fac[maxn];</span><br><span class="line">void getLa( int n)</span><br><span class="line">&#123;</span><br><span class="line">    memset(fac,0,sizeof(fac));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">        oula[i] = i;</span><br><span class="line">    for(int i = 2; i &lt; n; ++i)</span><br><span class="line">        if( oula[i] == i )</span><br><span class="line">            for(int j = 1; j*i &lt; n; ++j)&#123;</span><br><span class="line">                oula[j*i] -= oula[j*i]/i;</span><br><span class="line">                fac[j*i].prime[fac[j*i].cnt++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inc(int index,int b,int m)</span><br><span class="line">&#123;</span><br><span class="line">    ll r=0,t;</span><br><span class="line">    for(int i=index; i&lt;fac[m].cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t=b/fac[m].prime[i];</span><br><span class="line">        r+=t-inc(i+1,t,m);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">    if(m&gt;n)</span><br><span class="line">        swap(m,n);</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; ++i)</span><br><span class="line">        ans+=oula[i];</span><br><span class="line">    ans=ans*2-1;</span><br><span class="line">    for(int i=m+1; i&lt;=n; ++i)</span><br><span class="line">        ans+=m-inc(0,m,i);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    getLa(maxn);</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳蚤"><a href="#跳蚤" class="headerlink" title="跳蚤"></a>跳蚤</h2><p>Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。<br>比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。<br>当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 </p><p>Input</p><p>两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。</p><p>Output</p><p>可以完成任务的卡片数。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><p>Hint</p><p>这12张卡片分别是：<br>(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4),<br>(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define LL long long int</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005,maxm = 100005,INF = 1000000000;</span><br><span class="line"></span><br><span class="line">LL N,M;</span><br><span class="line">int fac[maxn],faci = 0;</span><br><span class="line"></span><br><span class="line">void Sp()&#123;</span><br><span class="line">LL e = M;</span><br><span class="line">for (LL i = 2; i * i &lt;= e; i++)&#123;</span><br><span class="line">if (e % i == 0)&#123;</span><br><span class="line">fac[++faci] = i;</span><br><span class="line">while (e % i == 0) e /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (e - 1) fac[++faci] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL qpow(LL a,LL b)&#123;</span><br><span class="line">LL ans = 1;</span><br><span class="line">for (; b; b &gt;&gt;= 1, a *= a)</span><br><span class="line">if (b &amp; 1) ans *= a;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL cal(int s)&#123;</span><br><span class="line">LL mult = 1,pos = 1;</span><br><span class="line">for (int i = 1; s; i++,s &gt;&gt;= 1)&#123;</span><br><span class="line">if (s &amp; 1)&#123;</span><br><span class="line">mult *= fac[i];</span><br><span class="line">pos *= -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return qpow(M/mult,N) * pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;p&gt;Given 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
