<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-09-20T05:37:52.008Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[容斥原理]Hard to prepare</title>
    <link href="http://qianyouyou.cn/2018/09/20/2018-09-20/"/>
    <id>http://qianyouyou.cn/2018/09/20/2018-09-20/</id>
    <published>2018-09-20T05:02:52.000Z</published>
    <updated>2018-09-20T05:37:52.008Z</updated>
    
    <content type="html"><![CDATA[<p>After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enjoy the show, every audience has to wear a Nogaku mask, and seat around as a circle.</p><p>There are N guests Reimu serves. Kokoro has 2^k2k masks numbered from 0,1,\cdots,0,1,⋯, 2^k - 12k−1, and every guest wears one of the masks. The masks have dark power of Dark Nogaku, and to prevent guests from being hurt by the power, two guests seating aside must ensure that if their masks are numbered ii and jj , then ii XNOR jj must be positive. (two guests can wear the same mask). XNOR means ~(ii^jj) and every number has kk bits. (11 XNOR 1 = 11=1, 00XNOR 0 = 10=1, 11 XNOR 0 = 00=0)</p><p>You may have seen 《A Summer Day’s dream》, a doujin Animation of Touhou Project. Things go like the anime, Suika activated her ability, and the feast will loop for infinite times. This really troubles Reimu: to not make her customers feel bored, she must prepare enough numbers of different Nogaku scenes. Reimu find that each time the same guest will seat on the same seat, and She just have to prepare a new scene for a specific mask distribution. Two distribution plans are considered different, if any guest wears different masks.</p><p>In order to save faiths for Shrine, Reimu have to calculate that to make guests not bored, how many different Nogaku scenes does Reimu and Kokoro have to prepare. Due to the number may be too large, Reimu only want to get the answer modules 1e9+71e9+7 . Reimu did never attend Terakoya, so she doesn’t know how to calculate in module. So Reimu wishes you to help her figure out the answer, and she promises that after you succeed she will give you a balloon as a gift.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line one number TT , the number of testcases; (T \le 20)(T≤20) .</p><p>Next TT lines each contains two numbers, NNand k(0&lt;N, k \le 1e6)k(0&lt;N,k≤1e6) .</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each testcase output one line with a single number of scenes Reimu and Kokoro have to prepare, the answer modules 1e9+71e9+7 .</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">84</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p><p><strong>题目描述</strong></p><p>有n个位置围成一个圈，2^k个数，每个位置随便放置一个数，要求范围在1到2^k之间，然而每个数都有一个互斥的数，且互斥的两个数不会和其他的重复，要求相邻位置不能有互斥的数。</p><p><strong>题解</strong></p><p>首先用快速幂求出2^k然后赋给k，即k = 2^k。然后假设这n个数依次排开，那么每一个数不能是上一个元素的互斥数，那么第1个元素共k种，那么之后每一种为k-1种。即<code>k*(k-1)^(n-1)</code>，然而这样的话最后一个元素可以为第一个元素的互斥数，因此要减去相应的数，根据容斥原理最终列出实在为<code>k*(k-1)^(n-1)-k*(k-1)^(n-2)+k*(k-1)^(n-3)-k*(k-1)^(n-4)……</code>然而这样做会超时，因此我们可以合并，即加一次减一次合并到一起重新得到公式。</p><p>当然我们也可以换一种思考方式，很容易想到，第1个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek" alt="\small 2^k">种选择，第2个数到第n-1个数都有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-1" alt="\small 2^k-1">种选择，第n个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-2" alt="\small 2^k-2">种选择。</p><p>所以答案就是<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek%282%5Ek-2%29%282%5Ek-1%29%5E%7Bn-2%7D" alt="\small 2^k(2^k-2)(2^k-1)^{n-2}"></p><p>但是这样会出现漏算：在第1个数和第n-1个数相同的情况下，第n个数有<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-1" alt="\small 2^k-1">种选择， 而并非<img src="https://private.codecogs.com/gif.latex?%5Csmall%202%5Ek-2" alt="\small 2^k-2">种</p><p>然后仔细分析可以发现，漏算的情况你可以把第1个数和第n-1个数当成同一个数，这样序列长度就变成n-2了，问题规模变小</p><p>递归或递推即可</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll quick_pow(ll ans, ll res, ll n)&#123;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">            ans = ans * res % mod;</span><br><span class="line">        res = res * res % mod;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll n, ll k)&#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    ll i = (n&amp;1)+2;</span><br><span class="line">    ll res = pow(k-1,i-2);</span><br><span class="line">    for(;i&lt;=n;i+=2)&#123;</span><br><span class="line">        ans = (ans + res) % mod;</span><br><span class="line">        res = res * (k - 1) % mod * (k - 1) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * k % mod * (k - 2) % mod;</span><br><span class="line">    ans = (ans + k) % mod;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t,n,k;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">        k = quick_pow(1,2,k);</span><br><span class="line">        printf(&quot;%lld\n&quot;,solve(n,k));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enj
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2015 ACM-ICPC Asia Regional Contest Shanghai Site - Onsite Contest</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18-2/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18-2/</id>
    <published>2018-09-18T13:22:56.000Z</published>
    <updated>2018-09-18T13:43:53.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-Friendship-of-Frog"><a href="#F-Friendship-of-Frog" class="headerlink" title="F - Friendship of Frog"></a>F - Friendship of Frog</h2><p> NN frogs from different countries are standing in a line. Each country is represented by a lowercase letter. The distance between adjacent frogs (e.g. the 1st1stand the 2nd2nd frog, the N−1thN−1th and the NthNth frog, etc) are exactly 11. Two frogs are friends if they come from the same country.<br>The closest friends are a pair of friends with the <strong>minimum</strong> distance. Help us find that distance.</p><p>Input</p><p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case only contains a string with length NN, and the ithith character of the string indicates the country of ithith frogs.<br>⋅⋅ 1≤T≤501≤T≤50.<br>⋅⋅ for 80% data, 1≤N≤1001≤N≤100.<br>⋅⋅ for 100% data, 1≤N≤10001≤N≤1000.<br>⋅⋅ the string only contains lowercase letters.</p><p>Output</p><p>For every test case, you should output “ <strong>Case #x: y</strong>“, where xx indicates the case number and counts from 11 and yy is the result. If there are no frogs in same country, output −1−1 instead.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">abcecba</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 2</span><br><span class="line">Case #2: -1</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>超级水题，一次性遍历，顺便设置一个字母表，记录上一个字母位置，初始值为0，每遇到一个字母，对该字母表进行更新。如果上一个该字母表不为0，则先用当前位置减去表中上一个位置，然后记录下最小值，然后再更新。最终如果最小值为初始值，则输出-1，否则输出该最小值。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e9+7;</span><br><span class="line">char str[1007];</span><br><span class="line">int a[26];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cc = 1;cc&lt;=t;cc++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,&amp;str);</span><br><span class="line">        int minD = maxx;</span><br><span class="line">        memset(a,0,sizeof(a));</span><br><span class="line">        int len = strlen(str);</span><br><span class="line">        for(int i = 0;i&lt;len;i++)&#123;</span><br><span class="line">            int num = str[i]-&apos;a&apos;;</span><br><span class="line">            if(a[num])</span><br><span class="line">                minD = min(minD,i - a[num] + 1);</span><br><span class="line">            a[num] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minD == maxx)</span><br><span class="line">            printf(&quot;Case #%d: -1\n&quot;,cc);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Case #%d: %d\n&quot;,cc,minD);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-Kingdom-of-Black-and-White"><a href="#K-Kingdom-of-Black-and-White" class="headerlink" title="K - Kingdom of Black and White"></a>K - Kingdom of Black and White</h2><p>In the Kingdom of Black and White (KBW), there are two kinds of frogs: black frog and white frog.<br>Now NN frogs are standing in a line, some of them are black, the others are white. The total strength of those frogs are calculated by dividing the line into minimum parts, each part should still be continuous, and can only contain one kind of frog. Then the strength is the sum of the squared length for each part.<br>However, an old, evil witch comes, and tells the frogs that she will change the color of <strong>at most one</strong> frog and thus the strength of those frogs might change.<br>The frogs wonder the <strong>maximum</strong> possible strength after the witch finishes her job.</p><p>Input</p><p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case only contains a string with length NN, including only 00(representing<br>a black frog) and 11 (representing a white frog).<br>⋅⋅ 1≤T≤501≤T≤50.<br>⋅⋅ for 60% data, 1≤N≤10001≤N≤1000.<br>⋅⋅ for 100% data, 1≤N≤1051≤N≤105.<br>⋅⋅ the string only contains 0 and 1.</p><p>Output</p><p>For every test case, you should output “ <strong>Case #x: y</strong>“,where xx indicates the case number and counts from 11 and yy is the answer.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">000011</span><br><span class="line">0101</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 26</span><br><span class="line">Case #2: 10</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>解法有点偏暴力，首先将01分成m个联通块，一次性遍历，将m个联通块的长度储存起来，算出总值ans。然后对这m个联通块分别判断加1情况下是否变大，当然该值的计算要先用ans减去该联通块以及相邻左边或右边联通块的值，然后再加上更新的值。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    for(int cas=1;cas&lt;=t;cas++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        int flag = -1;</span><br><span class="line">        vector&lt;long long&gt; Q;</span><br><span class="line">        int len = 0;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]-&apos;0&apos;!=flag)</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push_back(len);</span><br><span class="line">                len = 1;</span><br><span class="line">                flag = s[i]-&apos;0&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push_back(len);</span><br><span class="line">        Q.push_back(0);</span><br><span class="line">        long long res = 0;</span><br><span class="line">        for(int i=1;i&lt;Q.size()-1;i++)</span><br><span class="line">            res += Q[i]*Q[i];</span><br><span class="line">        long long ans = res;</span><br><span class="line">        for(int i=1;i&lt;Q.size()-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            long long tmp = 0;</span><br><span class="line">            if(Q[i]==1)</span><br><span class="line">                ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]-Q[i+1]*Q[i+1]+(Q[i-1]+Q[i+1]+1)*(Q[i-1]+Q[i+1]+1));</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]+(Q[i-1]+1)*(Q[i-1]+1)+(Q[i]-1)*(Q[i]-1));</span><br><span class="line">                ans = max(ans,res-Q[i+1]*Q[i+1]-Q[i]*Q[i]+(Q[i+1]+1)*(Q[i+1]+1)+(Q[i]-1)*(Q[i]-1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case #%d: %lld\n&quot;,cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L-LCM-Walk"><a href="#L-LCM-Walk" class="headerlink" title="L - LCM Walk"></a>L - LCM Walk</h2><p> A frog has just learned some number theory, and can’t wait to show his ability to his girlfriend.<br>Now the frog is sitting on a grid map of infinite rows and columns. Rows are numbered 1,2,⋯1,2,⋯ from the bottom, so are the columns. At first the frog is sitting at grid (sx,sy)(sx,sy), and begins his journey.<br>To show his girlfriend his talents in math, he uses a special way of jump. If currently the frog is at the grid (x,y)(x,y), first of all, he will find the minimum zzthat can be divided by both xx and yy, and jump exactly zz steps to the up, or to the right. So the next possible grid will be (x+z,y)(x+z,y), or (x,y+z)(x,y+z).<br>After a finite number of steps (perhaps zero), he finally finishes at grid (ex,ey)(ex,ey). However, he is too tired and he forgets the position of his starting grid!<br>It will be too stupid to check each grid one by one, so please tell the frog the number of possible starting grids that can reach (ex,ey)(ex,ey)!</p><p>Input</p><p>First line contains an integer TT, which indicates the number of test cases.<br>Every test case contains two integers exex and eyey, which is the destination grid.<br>⋅⋅ 1≤T≤10001≤T≤1000.<br>⋅⋅ 1≤ex,ey≤1091≤ex,ey≤109.</p><p>Output</p><p>For every test case, you should output “ <strong>Case #x: y</strong>“, where xx indicates the case number and counts from 11 and yy is the number of possible starting grids. </p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6 10</span><br><span class="line">6 8</span><br><span class="line">2 8</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 2</span><br><span class="line">Case #3: 3</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>设当前位置为(x,y)，gcd(x,y) = g。则可设x = m1g，y=m2g，LCM（x,y） = m1m2g，则目标值为（m1g+m1m2g，m2g）或（m1g，m2g+m1m2g）。已知目标值，求x，y。我们设目标值为x2，y2，则可推出m1 = x2/(g+y2)或m2 = y2/(g+x2)。递归过程，直到m1或m2不为0则返回值，否则次数加1，再继续递归。</p><p>最终得到结果。</p><p><strong>代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return a%b==0?b:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll g,ll x,ll y)&#123;</span><br><span class="line">    ll ans = 0;</span><br><span class="line">    if(!(x%(g+y)))&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        ll tmp = x*g/(g+y);</span><br><span class="line">        ans+=dfs(gcd(max(tmp,y),min(tmp,y)),tmp,y);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(y%(g+x)))&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        ll tmp = y*g/(g+x);</span><br><span class="line">        ans+=dfs(gcd(max(tmp,x),min(tmp,x)),x,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t,x,y;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    for(ll c = 1;c&lt;=t;c++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);</span><br><span class="line">        ll tmp = gcd(max(x,y),min(x,y));</span><br><span class="line">        ll ans = dfs(tmp,x,y);</span><br><span class="line">        printf(&quot;Case #%lld: %lld\n&quot;,c,++ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;F-Friendship-of-Frog&quot;&gt;&lt;a href=&quot;#F-Friendship-of-Frog&quot; class=&quot;headerlink&quot; title=&quot;F - Friendship of Frog&quot;&gt;&lt;/a&gt;F - Friendship of Frog&lt;/
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://qianyouyou.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>NOI手拉手问题</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18-1/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18-1/</id>
    <published>2018-09-18T07:08:24.000Z</published>
    <updated>2018-09-18T08:03:32.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成环的个数的期望。PS：一个人的左手和右手也可以拉起来构成一个环。</p><p>例如：n为2时，期望为4/3，假设从第一个人的左手开始，他的左手和右手和第2个人的左手和右手拉起来的概率都为1/3，其中自己的左手和右手拉起来构成环数为2，其他为1，则期望为<code>1/3*2+1/3*1+1/3*1</code></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>1+1/3+1/5+……1/(2n-1)</p><p>如果直接看公式很容易理解，每多一个人，就多了两只手，假设除了这个人以外其他人的期望都算出来了，假设期望为F(n)，那么对于这个人来说无非两种情况，要么和自己拉，要么和别人拉，和自己拉的概率为1/(2n-1)，和别人拉的概率为(2n-2)/(2n-1)。和自己拉的话很好理解，在之前的期望上加1就好了，和别人拉的话就可以把这两个人绑定起来当成一个人就好了，期望就是之前的期望。所以用公式的话就是<code>F(n+1)=F(n)*(2n-2)/(2n-1)+(F(n)+1)*1/(2n-1)</code>,化简就得<code>F(n+1)=F(n)+1/(2n-1)</code>，递归得F(n)=1+1/3+1/5+……1/(2n-1)</p><p>根据调和级数推到公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ld long double</span><br><span class="line">const int maxn = 1e7+7;</span><br><span class="line">ld a[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    a[0] = 0;</span><br><span class="line">    a[1]=1;</span><br><span class="line">    for(int i = 2;i&lt;maxn;i++)&#123;</span><br><span class="line">        a[i]=a[i-1]+1.0/(2*i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;head.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;head.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    long long tmp;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;tmp;</span><br><span class="line">    if(tmp*1.0&gt;=maxn)</span><br><span class="line">        cout&lt;&lt;log(2*tmp-1) - log(((2*tmp-1)-1)/2)/ 2 + 0.57721566490153286060651209 / 2&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;a[tmp]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="概率轮" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E8%BD%AE/"/>
    
    
      <category term="期望" scheme="http://qianyouyou.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>寻找距离最小点对</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18/</id>
    <published>2018-09-18T03:07:01.000Z</published>
    <updated>2018-09-18T03:08:31.951Z</updated>
    
    <content type="html"><![CDATA[<p>在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一。下面我们着重考虑平面上的最接近点对问题。</p><p>​    最接近点对问题的提法是:给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。</p><p>​    严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。</p><p><strong>参考解答</strong></p><p>​    这个问题很容易理解，似乎也不难解决。我们只要将每一点与其他n-1个点的距离算出，找出达到最小距离的两个点即可。然而，这样做效率太低，需要O(n2)的计算时间。在问题的计算复杂性中我们可以看到，该问题的计算时间下界为Ω(nlogn)。这个下界引导我们去找问题的一个θ(nlogn)<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>。</p><p>这个问题显然满足分治法的第一个和第二个适用条件，我们考虑将所给的平面上n个点的集合S分成2个子集S1和S2，每个子集中约有n/2个点，·然后在每个子集中递归地求其最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对，因为S1和S2的最接近点对未必就是S的最接近点对。如果组成S的最接近点对的2个点都在S1中或都在S2中，则问题很容易解决。但是，如果这2个点分别在S1和S2中，则对于S1中任一点p，S2中最多只有n/2个点与它构成最接近点对的候选者，仍需做n2/4次计算和比较才能确定S的最接近点对。因此，依此思路，合并步骤耗时为O(n2)。整个算法所需计算时间T(n)应满足:　</p><p>T(n)=2T(n/2)+O(n2)</p><p>​     它的解为T(n)=O(n2)，即与合并步骤的耗时同阶，显示不出比用穷举的方法好。从解递归方程的套用公式法，我们看到问题出在合并步骤耗时太多。这启发我们把注意力放在合并步骤上。</p><p>​    为了使问题易于理解和分析，我们先来考虑一维的情形。此时S中的n个点退化为x轴上的n个实数x1,x2,..,xn。最接近点对即为这n个实数中相差最小的2个实数。我们显然可以先将x1,x2,..,xn排好序，然后，用一次线性扫描就可以找出最接近点对。这种方法主要计算时间花在排序上，因此如在排序算法中所证明的，耗时为O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对这种一维的简单情形，我们还是尝试用分治法来求解，并希望能推广到二维的情形。</p><p>​    假设我们用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}。这样一来，对于所有p∈S1和q∈S2有p</p><p>​    递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设δ=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如图1所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_1_633579015612968750.gif" alt="img">图1 一维情形的分治法</p><p>我们注意到，如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;δ，则p3和q3两者与m的距离不超过δ，即|p3-m|&lt;δ，|q3-m|&lt;δ，也就是说，p3∈(m-δ,m]，q3∈(m,m+δ]。由于在S1中，每个长度为δ的半闭区间至多包含一个点（否则必有两点距离小于δ），并且m是S1和S2的分割点，因此(m-δ,m]中至多包含S中的一个点。同理，(m,m+δ]中也至多包含S中的一个点。由图1可以看出，如果(m-δ,m]中有S中的点，则此点就是S1中最大点。同理，如果(m,m+δ]中有S中的点，则此点就是S2中最小点。因此，我们用线性时间就能找到区间(m-δ,m]和(m,m+δ]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。也就是说，按这种分治策略，合并步可在O(n)时间内完成。这样是否就可以得到一个有效的算法了呢？还有一个问题需要认真考虑，即分割点m的选取，及S1和S2的划分。选取分割点m的一个基本要求是由此导出集合S的一个线性分割，即S=S1∪S2 ，S1∩S2=Φ，且S1{x|x≤m}；S2{x|x&gt;m}。容易看出，如果选取m=[max(S)+min(S)]/2，可以满足线性分割的要求。选取分割点后，再用O(n)时间即可将S划分成S1={x∈S|x≤m}和S2={x∈S|x&gt;m}。然而，这样选取分割点m，有可能造成划分出的子集S1和S2的不平衡。例如在最坏情况下，|S1|=1，|S2|=n-1，由此产生的分治法在最坏情况下所需的计算时间T(n)应满足递归方程:</p><p>T(n)=T(n-1)+O(n)</p><p>​    它的解是T(n)=O(n2)。这种效率降低的现象可以通过分治法中”平衡子问题”的方法加以解决。也就是说，我们可以通过适当选择分割点m，使S1和S2中有大致相等个数的点。自然地，我们会想到用S的n个点的坐标的中位数来作分割点。在选择算法中介绍的选取中位数的线性时间算法使我们可以在O(n)时间内确定一个平衡的分割点m。</p><p>​     至此，我们可以设计出一个求一维点集S中最接近点对的距离的算法CPAIR1如下。</p><p>function CPAIR1(S);</p><p>begin</p><p>if |S|=2</p><p>then δ=|x[2]-x[1]| // x[1..n]存放的是S中n个点的坐标</p><p>else if (|S|=1)</p><p>then δ:=∞</p><p>else</p><p>begin</p><p>m:=S中各点的坐标值的中位数;</p><p>构造S1和S2,使S1={x∈S|x≤m}，S2={x∈S|x&gt;m}; δ1:=CPAIRI(S1); δ2:=CPAIRI(S2);</p><p>p:=max(S1); q:=min(S2);</p><p>δ:=min(δ1,δ2,q-p);</p><p>end;</p><p>return(δ);</p><p>end;</p><p>由以上的分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程：</p><p>​     解此递归方程可得T(n)=O(nlogn)。</p><p>​    这个算法看上去比用排序加扫描的算法复杂，然而这个算法可以向二维推广。</p><p>​    下面我们来考虑二维的情形。此时S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。</p><p>​    递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min(δ1,δ1)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈P1，q∈P2，如图2所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_2.jpg" alt="img"></p><p>图2 距直线l的距离小于δ的所有点</p><p> 在一维的情形，距分割点距离为δ的2个区间(m-δ,m](m,m+δ]中最多各有S中一个点。因而这2点成为唯一的末检查过的最接近点对候选者。二维的情形则要复杂些，此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，如图3所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_3_633579015617343750.jpg" alt="img">图3 包含点q的δ×2δ的矩形R</p><p>​    由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。如图4(a)所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_4_633579015619375000.jpg" alt="img">图4 矩形R中点的稀疏性</p><p>​    若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个δ×2δ的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则</p><p>​     因此d(u,v)≤5δ/6&lt;δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。图4(b)是矩形R中含有S中的6个点的极端情形。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n2/4对候选者。这是否就意味着我们可以在O(n)时间内完成分治法的合并步骤呢？现在还不能作出这个结论，因为我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。</p><p>​    至此，我们可以给出用分治法求二维最接近点对的算法CPAIR2如下:</p><p>function CPAIR2(S);</p><p>begin</p><p>if |S|=2</p><p>then δ:=S中这2点的距离</p><p>else if |S|=0</p><p>then δ:=∞</p><p>else</p><p>begin</p><p>\1. m:=S中各点x坐标值的中位数; 构造S1和S2，使S1={p∈S|px≤m}和S2={p∈S|px&gt;m}</p><p>\2. δ1:=CPAIR2(S1);δ2:=CPAIR2(S2);</p><p>\3. δm:=min(δ1,δ2);</p><p>\4. 设P1是S1中距垂直分割线l的距离在δm之内的所有点组成的集合， P2是S2中距分割线l的距离在δm之内所有点组成的集合。将P1和P2中的点依其y坐标值从小到大排序，并设P1<em>和P2</em>是相应的已排好序的点列;</p><ol start="5"><li>通过扫描P1<em>以及对于P1</em>中每个点检查P2<em>中与其距离在δm之内的所有点(最多6个)可以完成合并。当P1</em>中的扫描指针逐次向上移动 时，P2*中的扫描指针可在宽为2δm的一个区间内移动。设δl是按 这种扫描方式找到的点对间的最小距离;</li></ol><p>\6. δ=min(δm,δl);</p><p>end;</p><p>return(δ);</p><p>end;</p><p>下面我们来分析一下算法CPAIR2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间，第3步和第6步用了常数时间，第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合我们的要求。因此，在这里我们要作一个技术上的处理。我们采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列为P<em>。在执行分治法的第4步时，只要对P</em>作一次线性扫描，即可抽取出我们所需要的排好序的点列P1<em>和P2</em>。然后，在第5步中再对P1*作一次线性扫描，即可求得δl。因此，第4步和第5步的两遍扫描合在一起只要用O(n)时间。这样一来，经过预排序处理后的算法CPAIR2所需的计算时间T(n)满足递归方程：</p><p>​    显而易见T(n)=O(nlogn)，预排序所需的计算时间为O(n1ogn)。因此，整个算法所需的计算时间为O(nlogn)。在渐近的意义下，此算法已是最优的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="分治" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="分治" scheme="http://qianyouyou.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后，如何快速搭建之前基于github的博客</title>
    <link href="http://qianyouyou.cn/2018/09/17/2018-09-17/"/>
    <id>http://qianyouyou.cn/2018/09/17/2018-09-17/</id>
    <published>2018-09-17T11:08:06.000Z</published>
    <updated>2018-09-18T08:18:56.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="声明：此文是针对于windows环境"><a href="#声明：此文是针对于windows环境" class="headerlink" title="声明：此文是针对于windows环境"></a>声明：此文是针对于windows环境</h3><p>前提：我需要说几个条件;</p><p>1.当初搭建博客时的ssh没有删除，如果删除那就再重新配置一个，配置方法参照我上一篇博客；</p><p>2.当初搭建博客的仓库没有删除，如果删除，那就再重新搭一个吧，剩下的教程几乎没有关系了</p><p>3.如果，当时搭建博客时，如果按照我的教程，或者说按照网上大多数教程，有建了一个文件夹（例如：git pages或者hexo），这个文件夹在重装系统后还有保留下来，那最好不过。</p><h4 id="先说第一种情况：如果那个文件夹在的情况下："><a href="#先说第一种情况：如果那个文件夹在的情况下：" class="headerlink" title="先说第一种情况：如果那个文件夹在的情况下："></a>先说第一种情况：如果那个文件夹在的情况下：</h4><p>不知道你们有没有按照其他的教程去配置静态页面，我按照那个方法有在github上新建了一个branch</p><p>那个gh-pages是我新建的branch，如果建了没关系</p><p>我们只需用点击master就好，回到原来的地方</p><p>然后再你原来的那个文件夹里打开git bash here</p><p>输入npm install hexo –save</p><p>然后可以试着输入hexo g 和hexo d</p><p>提示你需要重新配置邮箱和用户名，那么按照原来的邮箱和原来的用户名输入就好；</p><p>再次输入hexo g，如果有提示</p><p>就说明已经重新配置好了；</p><h4 id="如果没有保留当初在桌面配置的文件夹"><a href="#如果没有保留当初在桌面配置的文件夹" class="headerlink" title="如果没有保留当初在桌面配置的文件夹"></a>如果没有保留当初在桌面配置的文件夹</h4><p>首先先看看自己电脑上有没有ssh</p><p>在自己的一个盘里建一个文件夹，里面分别有三个文件夹（git，node，git pages）</p><p>分别在git和node里配置好git和node</p><p>然后再git pages里打开git bash here检查有没有ssh</p><p>cd ~/. ssh</p><p>如果有 No such file or directory</p><p>说明是第一次使用，那么按照上一篇博客配置，</p><p>如果提示有，那么你可以先试试这个ssh能用不，先别急着删；</p><p>按照刚刚的步骤再输入 npm install hexo –save</p><p>然后按照刚刚的步骤再来一次；</p><p>如果最后hexo d后，文章没有推上去，那么就说明没有成功，需要重新配置ssh</p><p>先删除原来的ssh<br>ssh-add -D<br>rm -r ~/.ssh</p><p>最好查看一下上一篇博客里，Deployment的config.yml文件里面的deploy值有没有改好（参照上一篇）</p><p>配置好了之后再按照刚刚的步骤再来一次（记得配置邮箱和用户名）</p><p>如果git bash在这儿没有起作用的话，</p><p>那么win+r打开cmd，安装一个类似刚刚操作的扩展</p><p>输入 npm install hexo-deployer-git –save</p><p>然后再输入</p><p>hexo g<br>hexo d</p><p>然后再进入自己的博客页面查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;声明：此文是针对于windows环境&quot;&gt;&lt;a href=&quot;#声明：此文是针对于windows环境&quot; class=&quot;headerlink&quot; title=&quot;声明：此文是针对于windows环境&quot;&gt;&lt;/a&gt;声明：此文是针对于windows环境&lt;/h3&gt;&lt;p&gt;前提：我需要
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="JavaScript" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/"/>
    
      <category term="hexo教程" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/JavaScript/hexo%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>数论小问题</title>
    <link href="http://qianyouyou.cn/2018/09/16/2018-09-16/"/>
    <id>http://qianyouyou.cn/2018/09/16/2018-09-16/</id>
    <published>2018-09-16T08:23:17.000Z</published>
    <updated>2018-09-18T08:34:32.904Z</updated>
    
    <content type="html"><![CDATA[<p>输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？</p><p>答案：n = min( n*(n+1)/2&gt;=x+y )</p><p>当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状的管子，往里面灌水，x代表一定容量的水，y代表一定容量的水，然后管子每升高1个高度就会多1个容量，最终刚好为n<em>(n+1)/2或n</em>(n+1)/2+1，n<em>(n+1)/2即x+y=n</em>(n+1)/2，否则为n*(n+1)/2+1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？&lt;/p&gt;
&lt;p&gt;答案：n = min( n*(n+1)/2&amp;gt;=x+y )&lt;/p&gt;
&lt;p&gt;当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>质因数分解原创算法</title>
    <link href="http://qianyouyou.cn/2018/09/13/2018-09-13/"/>
    <id>http://qianyouyou.cn/2018/09/13/2018-09-13/</id>
    <published>2018-09-13T10:54:41.000Z</published>
    <updated>2018-09-18T08:18:21.764Z</updated>
    
    <content type="html"><![CDATA[<p>由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Prime()&#123;</span><br><span class="line">memset(tag,0,sizeof(tag));</span><br><span class="line">int cnt=0;</span><br><span class="line">for(int i = 2; i&lt;N; i++)&#123;</span><br><span class="line">if(tag[i])</span><br><span class="line">prime[cnt++]=i;</span><br><span class="line">for(int j=0;j&lt;cnt &amp;&amp; prime[j]*i&lt;N; j++)&#123;</span><br><span class="line">tag[i*prime[j]] = i;</span><br><span class="line">if(i % prime[j]==0)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打表时表中储存为该数最小质数，这样给一个数只需除以对应表中数，直到除到最后为1为止</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>路径规划总结之A*搜索</title>
    <link href="http://qianyouyou.cn/2018/09/10/2018-09-10/"/>
    <id>http://qianyouyou.cn/2018/09/10/2018-09-10/</id>
    <published>2018-09-10T12:59:37.000Z</published>
    <updated>2018-09-10T13:39:49.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h2><p>路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。机器人的路径规划应用场景极丰富，最常见如游戏中NPC及控制角色的位置移动，百度地图等导航问题，小到家庭扫地机器人、无人机大到各公司正争相开拓的无人驾驶汽车等。</p><p>目前路径规划算法分为：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-09-10-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png" alt=""></p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>首先，我们来看看<code>A*</code>算法的定义：<code>A*</code>（A-Star)算法是一种静态路网中求解最短路径最有效的<strong>直接</strong>搜索方法，也是解决许多搜索问题的有效算法。 采用广度优先搜索策略，在搜索过程中使用启发函数，即有大致方向的向前进虽然目标有时候不是很明确。 </p><p>在计算机科学中，A*算法作为Dijkstra算法的扩展，因其高效性而被广泛应用于寻路及图的遍历，如星际争霸等游戏中就大量使用。在理解算法前，我们需要知道几个概念：</p><ul><li>搜索区域（The Search Area）：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。　　</li><li>开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。</li><li>父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针。</li><li>路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销。</li><li>启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和。</li></ul><p>可能看定义不是很好理解，那么我们根据例子具体看看什么是A*算法吧。</p><p>详细讲解参考：</p><p><a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin" target="_blank" rel="noopener">启发式算法</a></p><p><a href="https://www.cnblogs.com/zhoug2020/p/3468167.html" target="_blank" rel="noopener">A*算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路径规划&quot;&gt;&lt;a href=&quot;#路径规划&quot; class=&quot;headerlink&quot; title=&quot;路径规划&quot;&gt;&lt;/a&gt;路径规划&lt;/h2&gt;&lt;p&gt;路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ACM-ICPC 2018 徐州赛区网络预赛</title>
    <link href="http://qianyouyou.cn/2018/09/09/2018-09-09/"/>
    <id>http://qianyouyou.cn/2018/09/09/2018-09-09/</id>
    <published>2018-09-09T14:04:18.000Z</published>
    <updated>2018-09-09T14:20:13.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Characters-with-Hash"><a href="#Characters-with-Hash" class="headerlink" title="Characters with Hash"></a>Characters with Hash</h2><p><a href="https://wenda.jisuanke.com/nanti/31461" target="_blank" rel="noopener">问答</a></p><ul><li>26.45%</li><li>1000ms</li><li>262144K</li></ul><p>Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”.</p><p>It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line a integer TT , the number of test cases (T \le 10)(T≤10).</p><p>For each test case:</p><p>First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000).</p><p>Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single number which gives the answer.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 z</span><br><span class="line">oMl</span><br><span class="line">6 Y</span><br><span class="line">YJSNPI</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char str[1000007],ch[2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%s%s&quot;,&amp;n,ch,str);</span><br><span class="line">        int ans = 2*n;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(str[i]==ch[0])</span><br><span class="line">                ans-=2;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(abs(str[i]-ch[0])&lt;10)</span><br><span class="line">                    ans-=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans==0)</span><br><span class="line">            ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Characters-with-Hash&quot;&gt;&lt;a href=&quot;#Characters-with-Hash&quot; class=&quot;headerlink&quot; title=&quot;Characters with Hash&quot;&gt;&lt;/a&gt;Characters with Hash&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛K题-Supreme Number</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08-1/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08-1/</id>
    <published>2018-09-08T14:28:16.000Z</published>
    <updated>2018-09-09T14:03:30.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Supreme-Number"><a href="#Supreme-Number" class="headerlink" title="Supreme Number"></a>Supreme Number</h3><p><a href="https://wenda.jisuanke.com/nanti/31452" target="_blank" rel="noopener">问答</a></p><ul><li>26.7%</li><li>1000ms</li><li>131072K</li></ul><p>A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers.</p><p>Now lets define a number NN as the <strong>supreme number</strong> if and only if each number made up of an non-empty <strong>subsequence</strong> of all the numeric digits of NN must be either a prime number or 11.</p><p>For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number.</p><p>Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal <em>supreme number</em> that does not exceed NN?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases.</p><p>In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case print <code>&quot;Case #x: y&quot;</code>, in which xx is the order number of the test case and yy is the answer.</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 5</span><br><span class="line">Case #2: 73</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;</span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    char ch=&apos; &apos;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ans&lt;100000)</span><br><span class="line">        ans=ans*10+ch-&apos;0&apos;;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int aaa=1;aaa&lt;=t;aaa++)&#123;</span><br><span class="line">        int ans = read();</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for(i = 0;i&lt;19;i++)&#123;</span><br><span class="line">            if(pri[i]&gt;ans)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==19)</span><br><span class="line">            cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000000</span><br><span class="line">int h=0;</span><br><span class="line">bool p[N];</span><br><span class="line">int prime[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    if(p[x]==false)</span><br><span class="line">        return false;</span><br><span class="line">    int c = 1;</span><br><span class="line">    while(c&lt;x)&#123;</span><br><span class="line">        c*=10;</span><br><span class="line">        if(p[x%c]==false)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        if(c&gt;x)</span><br><span class="line">            break;</span><br><span class="line">        int tmp = x;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(p[tmp]==false)</span><br><span class="line">                return false;</span><br><span class="line">            if(p[tmp%c]==false)</span><br><span class="line">                return false;</span><br><span class="line">            tmp/=c;</span><br><span class="line">            if(!tmp)</span><br><span class="line">                break;</span><br><span class="line">            if(dfs(tmp)==false)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void db()</span><br><span class="line">&#123;</span><br><span class="line">memset(p,true,sizeof(p));</span><br><span class="line">p[0] = false;</span><br><span class="line">for(int i=2;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[i]==false)</span><br><span class="line">            continue;</span><br><span class="line">for(int j=2;i*j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line">p[i*j]=false;</span><br><span class="line">&#125;</span><br><span class="line">if(!dfs(i))</span><br><span class="line">            p[i] = false;</span><br><span class="line">        if(p[i]==true)</span><br><span class="line">&#123;</span><br><span class="line">prime[h++]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">db();</span><br><span class="line">int n;  //打印前n个质数</span><br><span class="line">for(int i=0;i&lt;=h;i++)</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Supreme-Number&quot;&gt;&lt;a href=&quot;#Supreme-Number&quot; class=&quot;headerlink&quot; title=&quot;Supreme Number&quot;&gt;&lt;/a&gt;Supreme Number&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛D题-A*模板题</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08/</id>
    <published>2018-09-08T13:28:16.000Z</published>
    <updated>2018-09-09T14:03:51.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Made-In-Heaven"><a href="#Made-In-Heaven" class="headerlink" title="Made In Heaven"></a>Made In Heaven</h2><p><a href="https://wenda.jisuanke.com/nanti/31445" target="_blank" rel="noopener">问答</a></p><ul><li>14.67%</li><li>1000ms</li><li>131072K</li></ul><p>One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry.</p><p>JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are at most 5050 test cases.</p><p>The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN.</p><p>The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ).</p><p>Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW.</p><p>It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist.</p><p>All the test cases are generated randomly.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>One line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output <code>&quot;yareyaredawa&quot;</code> (without quote), else output <code>&quot;Whitesnake!&quot;</code> (without quote).</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 2 14</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yareyaredawa</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“<code>Whitesnake!</code>”，否则输出“<code>yareyaredawa</code>”</p><p>类似<a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ2449</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>A*+SPFA</p><h4 id="A-算法："><a href="#A-算法：" class="headerlink" title="A*算法："></a>A*算法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A*，启发式搜索，是一种较为有效的搜索方法。</span><br><span class="line">我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。</span><br><span class="line">我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。</span><br><span class="line">所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。</span><br></pre></td></tr></table></figure><h4 id="估价函数："><a href="#估价函数：" class="headerlink" title="估价函数："></a>估价函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。</span><br><span class="line">在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。</span><br><span class="line"></span><br><span class="line">估价函数需要满足：</span><br><span class="line">　　设当前状态state到目标函数所需代价的估计值为f(state)</span><br><span class="line">　　设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state)</span><br><span class="line">　　对于任意的state，应该有f(state)&lt;=g(state)</span><br><span class="line">也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。</span><br></pre></td></tr></table></figure><h4 id="第K短路："><a href="#第K短路：" class="headerlink" title="第K短路："></a>第K短路：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。</span><br><span class="line">实现过程：</span><br><span class="line">1.预处理f(x)，在反向图上以T为起点求到每个点的最短路</span><br><span class="line">2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问</span><br><span class="line">3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中</span><br><span class="line">4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路</span><br><span class="line"></span><br><span class="line">因为估价函数的作用，图中很多节点访问次数远小于K</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll x,y,z,s,t,k;</span><br><span class="line">    ll T;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T;</span><br><span class="line">        prepare();</span><br><span class="line">        for(ll i=1;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            add_edge(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(t);</span><br><span class="line">        ll ans=a_star(s,t,k);</span><br><span class="line">        if(ans&lt;=T&amp;&amp;ans!=-1)</span><br><span class="line">            cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k短路模板"><a href="#k短路模板" class="headerlink" title="k短路模板"></a>k短路模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Made-In-Heaven&quot;&gt;&lt;a href=&quot;#Made-In-Heaven&quot; class=&quot;headerlink&quot; title=&quot;Made In Heaven&quot;&gt;&lt;/a&gt;Made In Heaven&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/A-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
      <category term="k短路" scheme="http://qianyouyou.cn/tags/k%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[最短路]SPFA的SLF与LLL优化</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05-2/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05-2/</id>
    <published>2018-09-05T10:08:53.000Z</published>
    <updated>2018-09-05T12:14:48.508Z</updated>
    
    <content type="html"><![CDATA[<p>SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。</p><p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ; Q.pop_front( ) ; mark[u] = false ;</span><br><span class="line">    </span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] &gt; dis[Q.front( )]  ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，每次出队时，若 d[i]&gt;平均值，把 i 移到队列末尾，如此反复，直到找到某一i使得dist(i)&lt;=x，则将i出队进行松弛操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ; tot = 0 ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ;</span><br><span class="line">        Q.pop_front( ) ;</span><br><span class="line">        if( dis[u] * tot &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">        Q.push_back( u ) ;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[u] = false ;</span><br><span class="line">        tot-- ; sum -= dis[u] ;</span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] * tot &gt; sum ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    tot++ ; sum += dis[v] ;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。&lt;/p&gt;
&lt;p&gt;SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &amp;lt; dist(i
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="SPFA算法" scheme="http://qianyouyou.cn/tags/SPFA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[C++] pair和make_pair</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05-1/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05-1/</id>
    <published>2018-09-05T08:16:08.000Z</published>
    <updated>2018-09-05T08:25:13.959Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：<a href="https://blog.csdn.net/yockie/article/details/6980692" target="_blank" rel="noopener">pair与make_pair</a></p><p>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。<br>例如std::pair&lt;int,float&gt; 或者 std::pair&lt;double,double&gt;等。<br>pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。<br>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：<br>template pair make_pair(T1 a, T2 b) { return pair(a, b); }<br>    一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。<br>另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：<br>    例如有如下两个定义：<br>        std::pair&lt;int, float&gt;(1, 1.1);<br>        std::make_pair(1, 1.1);<br>其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。<br>这个问题在编程是需要引起注意。<br>下面是一段pair与make_pair的例子程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product1.first &lt;&lt;&quot; is $&quot;&lt;&lt; product1.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product2.first &lt;&lt;&quot; is $&quot;&lt;&lt; product2.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product3.first &lt;&lt;&quot; is $&quot;&lt;&lt; product3.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：&lt;a href=&quot;https://blog.csdn.net/yockie/article/details/6980692&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pair与ma
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="stl" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/stl/"/>
    
    
      <category term="stl" scheme="http://qianyouyou.cn/tags/stl/"/>
    
      <category term="模板" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>[单源最短路]两大优化算法争锋之SPFA与堆优化版Dijkstra</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05/</id>
    <published>2018-09-05T07:16:00.000Z</published>
    <updated>2018-09-05T09:12:42.033Z</updated>
    
    <content type="html"><![CDATA[<p>单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。</p><p>这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 </p><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>时间复杂度：O(V2+E) </p><p>n-1次循环</p><p>–&gt;找到未标记的d最小的点</p><p>–&gt;标记，松弛它的边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)&#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])&#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>时间复杂度：O(VE) </p><p>n-1次循环</p><p>–&gt;对所有边松弛</p><p>还能再松弛则有负环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int dis[10010];</span><br><span class="line">int u[10010],v[10010],w[10010];</span><br><span class="line">int n,m;</span><br><span class="line">void Bellman_ford(int a)&#123;</span><br><span class="line">    memset(dis,inf,sizeof(dis));//赋初始值</span><br><span class="line">    dis[a]=0;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)//更新n-1次</span><br><span class="line">        for(int j=1;j&lt;=m;j++)//更新每一条边</span><br><span class="line">            dis[v[j]]=min(dis[v[j]],dis[u[j]]+w[j]);//判断是否更新</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="两大基础算法对比"><a href="#两大基础算法对比" class="headerlink" title="两大基础算法对比"></a>两大基础算法对比</h2><ul><li>Dijkstra是每次确定了到一个点的最短距离，再用该点更新到其它点的距离。不能处理有负边的图。</li><li>Bellman-Ford是每次对所有边松弛。可以计算出有负边无负环的最短路，可以判断是否存在负环。</li></ul><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="Dijkstra-heap优化"><a href="#Dijkstra-heap优化" class="headerlink" title="Dijkstra+heap优化"></a>Dijkstra+heap优化</h2><p>时间复杂度：O((V+E)lgV)</p><p>用STL中的优先队列实现堆：</p><p>while(优先队列非空)</p><p>–&gt;队头出队，松弛它的边</p><p>–&gt;松弛了的&lt;新距离,点&gt;入队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;</span><br><span class="line">...</span><br><span class="line">while(!q.empty())&#123;  // O(V) 加上count&lt;n可以优化一点点 </span><br><span class="line">    int w=q.top().first, u=q.top().second;</span><br><span class="line">    q.pop();   // O(lgV)</span><br><span class="line">    if(b[u])continue; b[u]=true;</span><br><span class="line">    //++count;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123; // Sum -&gt; O(E)</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            q.push(PII(d[v],v));  // O(lgV)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>时间复杂度：O(kE) or O(VE)</p><p>while(队非空)</p><p>–&gt;队头出队，松弛它的边</p><p>–&gt;松弛了且不在队内的点入队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(!q.empty())&#123;</span><br><span class="line">    int u=q.front(); q.pop();</span><br><span class="line">    b[u]=false;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            if(!b[v])b[v]=true,q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路对比"><a href="#算法思路对比" class="headerlink" title="算法思路对比"></a>算法思路对比</h2><ul><li>Dijkstra+heap是用小根堆，每次取出d最小的点，来更新距离，那么这个点来说，最小距离就是当前的d。</li><li>SPFA是用双端队列，每次取出队头，来更新距离，它之后可能还会入队。它是一种动态逼近法，因为每次松弛距离都会减小，所以松弛一定会有结束的。如果一个点入队超过n次就是存在负环。</li></ul><h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><p>Dijkstra+heap</p><ul><li>因为是堆，取队头需要O(lgV)。</li><li>松弛边时，因为点的d改变了，所以点v需要以新距离重新入堆，O(lgV)，总共O(ElgV)。</li><li>因此总的是O((V+E)lgV)</li></ul><p>SPFA</p><ul><li>论文证明也不严格。复杂度不太好分析。</li><li><del>总的是O(kE)。k大概为2</del>。</li><li>复杂度应该是 O(VE)。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。</p><p>另外，Dijkstra和Prim也很相似，它们的区别主要是d的含义，前者是到s的临时最短距离，后者是到树的临时最短距离，相同点是，每次找d最小的更新其它点的距离。</p><h1 id="Dijkstra堆优化版代码"><a href="#Dijkstra堆优化版代码" class="headerlink" title="Dijkstra堆优化版代码"></a>Dijkstra堆优化版代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">ll dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n]!=maxx)</span><br><span class="line">        printf(&quot;%lld\n&quot;,dis[n]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。&lt;/p&gt;
&lt;p&gt;这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 &lt;/p&gt;
&lt;h1 id=&quot;基础
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Dijkstra算法" scheme="http://qianyouyou.cn/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
      <category term="SPFA算法" scheme="http://qianyouyou.cn/tags/SPFA%E7%AE%97%E6%B3%95/"/>
    
      <category term="Bellman-Ford算法" scheme="http://qianyouyou.cn/tags/Bellman-Ford%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[分层最短路]Magical Girl Haze</title>
    <link href="http://qianyouyou.cn/2018/09/04/2018-09-04/"/>
    <id>http://qianyouyou.cn/2018/09/04/2018-09-04/</id>
    <published>2018-09-04T07:21:48.000Z</published>
    <updated>2018-09-05T07:57:39.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>去掉的k条路肯定全部在从1到n的某一条路径上，这样走这一条路径才有可能最短。我们可以对最短路分层，即分别求k为0，k为1，k为2……k为k的情况下最短路程。定义最短路时使用二维数组<code>dis[n][k]</code>,n为结点数，k为分层数。设i为每次求得的最短路结点，kk为所在层，dis为最短路，原点到原点的距离为0，则：</p><p>最短路状态转移方程：<code>dis[j][kk]=min(dis[i][kk]+road[i][j],dis[j][kk])</code></p><p>分层状态转移方程：<code>dis[j][kk+1]=min(dis[i][kk],dis[j][kk+1])</code></p><h2 id="Magical-Girl-Haze"><a href="#Magical-Girl-Haze" class="headerlink" title="Magical Girl Haze"></a>Magical Girl Haze</h2><p>There are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases.</p><p>For each test case, the first line has three integers N, MN,M and KK.</p><p>Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv.</p><p>It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,<br>0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print the minimum distance.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,k,cnt;</span><br><span class="line">ll dis[maxn][12];</span><br><span class="line">bool vis[maxn][12];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u, j;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,int j,ll w):u(u),j(j),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        int j = q.top().j;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk][j])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk][j] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(j&lt;k&amp;&amp;!vis[edge[l].to][j+1]&amp;&amp;dis[edge[l].to][j+1] &gt; minD)&#123;</span><br><span class="line">                dis[edge[l].to][j+1] = minD;</span><br><span class="line">                q.push(NODE(edge[l].to,j+1,dis[edge[l].to][j+1]));</span><br><span class="line">            &#125;</span><br><span class="line">            if(!vis[edge[l].to][j]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to][j])&#123;</span><br><span class="line">                dis[edge[l].to][j] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,j,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n][k]!=maxx)</span><br><span class="line">        printf(&quot;%lld\n&quot;,dis[n][k]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="分层最短路" scheme="http://qianyouyou.cn/tags/%E5%88%86%E5%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[数论]辗转相除法求gcd的数学证明</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03-2/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03-2/</id>
    <published>2018-09-03T15:57:36.000Z</published>
    <updated>2018-09-04T10:48:32.100Z</updated>
    
    <content type="html"><![CDATA[<p>在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。</p><p>gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a,b)。这里就不证明了。</p><p>我们接着看gcd，如何高效求gcd呢？目前最快的方法算是欧几里得算法了。</p><p>欧几里得算法其实很简单，已知a，b，其中a&gt;b，求gcd(a,b)。</p><p>解：用b整除a，得到余数c，再用c整除b，得到余数d，再用d整除c，得到余数e……不断这样操作，最后直到没有余数为止。假设e再整除d，余数为0，则e为最大公因数。</p><p>列式子即为：</p><p>a = x1 * b + r1;</p><p>b = x2 * r1 + r2;</p><p>r1 = x3 * r2 + r3;</p><p>……</p><p>rn-1= xn+1 * rn + rn+1;</p><p>rn = xn+2 * rn+1 + 0;</p><p>若设a为r-1，b为r0，则通项公式即为rn-1 / rn = xn+1 <em> rn + rn+1，最后一项为rn / rn+1 = xn+2 </em> rn+1。</p><p>很容易理解，若某一步余数为0，则上一步的余数即为最大公约数。很容易证明该循环一定会终止，因为最坏的情况下a和b的最大公因数是1，那么任何一个数都是1的倍数，所以任何数取余1都为0，所以循环必会结束。</p><p>该算法历经千年，直到现在依然为求解gcd最高效的算法，gcd(a,b)最坏的情况下运算次数最多才是b位数的7位，这里就不详细介绍了。</p><p>那么为什么最后的结果就是最大公因数呢，接下来我们来证明一下。</p><p>假设g为gcd(a,b)，即g为g，b的最大公因数，则带到上式记为rn = xn+2 * g，这个式子g必然为rn的因数。</p><p>那再带到上一个式子，rn-1 = xn+1 * rn + g，由于g既是rn的因数，又是g的因数，则g是rn-1的因数。</p><p>再带到上一个式子，rn-2 = xn * rn-1 + rn，由于g是rn-1，rn的因数，所以g必然是rn-2的因数。</p><p>……</p><p>最终带到第一组式子中，即g既是a的因数，也是b的因数。</p><p>那如何证明它是最大公因数呢？</p><p>我们假设h为a，b的任意因数，则h整除a，且h整除b，带到第一个式子，则h整除r1，再带到第2个式子，h整除r2，再带到第3个式子，h整除r3……直到倒数第二个式子，h整除rn+1，即h整除g由于最后一个式子余数为0，那么既然g为a，b的因数，h为g的因数，则h&lt;=g，故g为gcd(a,b)。</p><p>证毕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。&lt;/p&gt;
&lt;p&gt;gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>An Olympian Math Problem</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03-1/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03-1/</id>
    <published>2018-09-03T15:57:28.000Z</published>
    <updated>2018-09-05T05:39:16.683Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：</p><p>求解<code>(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1</code>。</p><p>PS：<code>n! = 1 * 2 * …… * n</code>。</p><p>证明过程：</p><p><img src="http://pdz5m676b.bkt.clouddn.com/2018-09-03QQ%E5%9B%BE%E7%89%8720180904190419.jpg" alt=""></p><p>Alice, a student of grade 66, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is:</p><p>We denote k!k!:</p><p>k! = 1 \times 2 \times \cdots \times (k - 1) \times kk!=1×2×⋯×(k−1)×k</p><p>We denote SS:</p><p>S = 1 \times 1! + 2 \times 2! + \cdots +S=1×1!+2×2!+⋯+<br>(n - 1) \times (n-1)!(n−1)×(n−1)!</p><p>Then SS module nn is <strong><strong>____</strong></strong></p><p>You are given an integer nn.</p><p>You have to calculate SS modulo nn.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer T(T \le 1000)T(T≤1000), denoting the number of test cases.</p><p>For each test case, there is a line which has an integer nn.</p><p>It is guaranteed that 2 \le n\le 10^{18}2≤n≤1018.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print an integer SS modulo nn.</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The first test is: S = 1\times 1!= 1S=1×1!=1, and 11modulo 22 is 11.</p><p>The second test is: S = 1\times 1!+2 \times 2!= 5S=1×1!+2×2!=5, and 55 modulo 33 is 22.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll t,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;求解&lt;code&gt;(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;n! = 1 * 2 * …… * n&lt;/
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>介于邻接矩阵与邻接表之间的存图方式————链式前向星</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03/</id>
    <published>2018-09-03T12:23:43.000Z</published>
    <updated>2018-09-03T12:31:36.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>链式前向星</strong></p><p><strong>图的存储一般有三种：邻接矩阵、邻接表、前向星。</strong></p><p><strong>若图是稀疏图，边很少，开二维数组很浪费;</strong></p><p><strong>若点很多(如10000个点)<code>a[10000][10000]</code>又会爆.只能用前向星做.</strong></p><p><strong>前向星的效率不是很高，优化后为链式前向星，直接介绍链式前向星。</strong></p><h2 id="（一）链式前向星"><a href="#（一）链式前向星" class="headerlink" title="（一）链式前向星"></a><strong>（一）链式前向星</strong></h2><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. <strong>结构</strong></h2><p><strong>这里用两个东西：</strong></p><p><strong>1 结构体数组edge存边，edge[i]表示第i条边,</strong></p><p><strong>2 head[i]存以i为起点的第一条边(在edge中的下标)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct EDGE&#123;</span><br><span class="line">int next;   //下一条边的存储下标(默认0) </span><br><span class="line">int to;     //这条边的终点 </span><br><span class="line">int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[500010];</span><br></pre></td></tr></table></figure><h2 id="2-增边"><a href="#2-增边" class="headerlink" title="2.增边"></a><strong>2.增边</strong></h2><p><strong>若以点i为起点的边新增了一条，在edge中的下标为j.</strong></p><p><strong>那么edge[j].next=head[i];然后head[i]=j.</strong></p><p><strong>即每次新加的边作为第一条边，最后倒序遍历</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">//cnt为边的计数，从1开始计 </span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. <strong>遍历</strong></h2><p><strong>遍历以st为起点的边</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=head[st]; i!=0; i=edge[i].next)</span><br></pre></td></tr></table></figure><p>i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）</p><p><strong>一个简单的输出有向图熟悉链式前向星：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">int next;   //下一条边的存储下标 </span><br><span class="line">int to;     //这条边的终点 </span><br><span class="line">int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, cnt;</span><br><span class="line">int head[MAXN];  //head[i]表示以i为起点的第一条边 </span><br><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125; </span><br><span class="line">void Print() &#123;</span><br><span class="line">int st;</span><br><span class="line">cout &lt;&lt; &quot;Begin with[Please Input]: \n&quot;;</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line">for(int i=head[st]; i!=0; i=edge[i].next) &#123;//i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 </span><br><span class="line">cout &lt;&lt; &quot;Start: &quot; &lt;&lt; st &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;End: &quot; &lt;&lt; edge[i].to &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;W: &quot; &lt;&lt; edge[i].w &lt;&lt; endl &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int s, t, w;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;</span><br><span class="line">Add(s, t, w);</span><br><span class="line">&#125;</span><br><span class="line">Print(); </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）链式前向星实现SPFA"><a href="#（二）链式前向星实现SPFA" class="headerlink" title="（二）链式前向星实现SPFA"></a><strong>（二）链式前向星实现SPFA</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define ANS_MAX 2147483647</span><br><span class="line">struct EDGE &#123;</span><br><span class="line">int next;</span><br><span class="line">int to;</span><br><span class="line">int w;</span><br><span class="line">&#125;;</span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, st, cnt;</span><br><span class="line">int head[MAXN];</span><br><span class="line">int d[MAXN];</span><br><span class="line">bool inq[MAXN];</span><br><span class="line">inline int Read() &#123;</span><br><span class="line">char c; int ans = 0; bool Sign = false;</span><br><span class="line">while(!isdigit(c=getchar()) &amp;&amp; c != &apos;-&apos;);</span><br><span class="line">if(c == &apos;-&apos;) &#123;</span><br><span class="line">Sign = true;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">ans = (ans&lt;&lt;3) + (ans&lt;&lt;1) + (c ^ &apos;0&apos;);</span><br><span class="line">&#125; while(isdigit(c=getchar()));</span><br><span class="line">return Sign ? -ans : ans;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int u, int v, int w) &#123;</span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">void read() &#123;</span><br><span class="line">int x, y, w;</span><br><span class="line">n = Read();</span><br><span class="line">m = Read();</span><br><span class="line">st = Read();</span><br><span class="line">for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">x = Read();</span><br><span class="line">y = Read();</span><br><span class="line">w = Read();</span><br><span class="line">Add(x, y, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void SPFA(int x) &#123;</span><br><span class="line">d[x] = 0; for(int i=1; i&lt;=n; i++) d[i] = ANS_MAX;</span><br><span class="line">queue&lt;int&gt; Q; Q.push(x); inq[x] = true;</span><br><span class="line">while(!Q.empty()) &#123;</span><br><span class="line">int k = Q.front(); Q.pop(); inq[k] = false;</span><br><span class="line">for(int i=head[k]; i!=0; i=edge[i].next) &#123;</span><br><span class="line">int j = edge[i].to;</span><br><span class="line">if(d[j] &gt; d[k] + edge[i].w) &#123;</span><br><span class="line">d[j] = d[k] + edge[i].w;</span><br><span class="line">if(!inq[j]) &#123;</span><br><span class="line">Q.push(j);</span><br><span class="line">inq[j] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, d[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">read();</span><br><span class="line">SPFA(st);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;链式前向星&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图的存储一般有三种：邻接矩阵、邻接表、前向星。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若图是稀疏图，边很少，开二维数组很浪费;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若点很多(如
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="链式前向星" scheme="http://qianyouyou.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1001 Buy and Resell</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25-2/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25-2/</id>
    <published>2018-08-25T14:55:54.000Z</published>
    <updated>2018-08-26T12:26:24.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p><p>Problem Description</p><p>The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:<br>\1. spend ai dollars to buy a Power Cube<br>\2. resell a Power Cube and get ai dollars if he has at least one Power Cube<br>\3. do nothing<br>Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning.</p><p>Input</p><p>There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:<br>The first line has an integer n. (1≤n≤105)<br>The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)<br>It is guaranteed that the sum of all n is no more than 5×105.</p><p>Output</p><p>For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit.</p><p>Sample Input</p><p>3 4 1 2 10 9 5 9 5 9 10 5 2 2 1</p><p>Sample Output</p><p><em>Hint</em></p><p>profit = - 1 - 2 + 10 + 9 = 16</p><p>profit = - 5 + 10 = 5</p><p>profit = 0</p><p>题解：</p><p>n天，每天商品有个价格，或买或卖或不买不卖。</p><p>贪心策略：分为两个堆（或优先队列），一个堆v为储存买的价格，一个堆s储存卖的价格。第i天的商品和之前买与卖两个堆中的最小值进行比较。共分为四种情况：1.如果第i天的价格比买的堆v里最小值大，且买的堆v里最小值比卖的堆s里最小值小，则买掉买的堆v里最小的，再卖出去，交易次数加2，即v.pop(),s.push(),cnt+2。2.如果第i天的价格比卖的堆s里最小值大，且买的堆v里最小值比卖的堆s里最小值大，则买掉卖的堆s里最小的，再卖出去，意思为现在卖比之前卖的那次更划算，我们把它买回来就等于之前那次没有卖，再卖出去等于现在才卖，即s.pop(),v.push(),s.push()。3.如果当天的价格即小于s中最小又小于v中最小，则把他放到买的堆v里，即v.push()。</p><p>这样下来，最后买的堆里剩下的就是没买没卖的。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll n, tmp, cnt = 0,sum = 0;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;v,s;</span><br><span class="line">        for(ll i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;tmp);</span><br><span class="line">            if(!v.empty())&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top()&amp;&amp;s.top()&lt;=v.top())&#123;</span><br><span class="line">                    sum+=tmp-(s.top());</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                 else if(tmp&gt;v.top()&amp;&amp;(s.empty()||s.top()&gt;v.top()))&#123;</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                    sum+=tmp-(v.top());</span><br><span class="line">                    v.pop();</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(tmp&lt;=v.top())&#123;</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top())&#123;</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    sum+=tmp-s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld %lld\n&quot;,sum,2*cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Buy-and-Resell&quot;&gt;&lt;a href=&quot;#Buy-and-Resell&quot; class=&quot;headerlink&quot; title=&quot;Buy and Resell&quot;&gt;&lt;/a&gt;Buy and Resell&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit: 20
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1009 Tree and Permutation</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25-1/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25-1/</id>
    <published>2018-08-25T13:03:48.000Z</published>
    <updated>2018-08-26T12:27:00.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tree-and-Permutation"><a href="#Tree-and-Permutation" class="headerlink" title="Tree and Permutation"></a>Tree and Permutation</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p><p>Problem Description</p><p>There are N vertices connected by N?1 edges, each edge has its own length.<br>The set { 1,2,3,…,N } contains a total of N! unique permutations, let’s say the i-th permutation is Pi and Pi,j is its j-th number.<br>For the i-th permutation, it can be a traverse sequence of the tree with N vertices, which means we can go from the Pi,1-th vertex to the Pi,2-th vertex by the shortest path, then go to the Pi,3-th vertex ( also by the shortest path ) , and so on. Finally we’ll reach the Pi,N-th vertex, let’s define the total distance of this route as D(Pi) , so please calculate the sum of D(Pi) for all N! permutations.</p><p>Input</p><p>There are 10 test cases at most.<br>The first line of each test case contains one integer N ( 1≤N≤105 ) .<br>For the next N?1 lines, each line contains three integer X, Y and L, which means there is an edge between X-th vertex and Y-th of length L ( 1≤X,Y≤N,1≤L≤109 ) .</p><p>Output</p><p>For each test case, print the answer module 109+7 in one line.</p><p>Sample Input</p><p>3</p><p>1 2 1</p><p>2 3 1</p><p>3</p><p>1 2 1</p><p>1 3 2</p><p>Sample Output</p><p>16</p><p>24</p><p>题意：</p><p>首先给出一个含有n个节点的树，边权为距离。</p><p>对于1-n的某一种排列p1,p2,p3……pn，贡献为dis(p1,p2)+dis(p2,p3)+dis(p3,p4)+……+dis(pn-1,pn)</p><p>求所有排列的贡献和</p><p>题解：</p><p>一棵树n个结点n-1条边，所以任意两点之间都有最短距离。由于所有遍历方式可以看做n个结点的排列，而每次有直接关系的只有两点之间的距离，因此只需求出两点之间的距离在所有排列中一共出现多少次即可。</p><p>比如n=2时，两个点1,2，共有两种排列方式，即1,2,和2,1</p><p>n=3时，三个点1,2,3,其中1,2共有4种方法得到，即1,2,3,和2,1,3,和3,1,2,和3,2,1</p><p>n=4时，三个点1,2,3,4,其中1,2共有12种方法得到，即1,2,3,4,和1,2,4,3,和2,1,3,4,和2,1,4,3,和3,1,2,4,和3,2,1,4和4,1,2,3,和4,2,1,3,和3,4,1,2,和4,3,1,2,和3,4,2,1,和4,3,2,1,</p><p>n=jie[n-1]*（n-1）。</p><p>先用树状dp求出所有两两结点之间的距离之和，再乘以每条边在所有结点排列的n！方式中一共用到的次数。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll sum[maxn], n;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll jie[maxn];</span><br><span class="line">ll jie2[maxn];</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; tree[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    jie[2] = 2;</span><br><span class="line">    for(ll i = 3;i&lt;maxn;i++)&#123;</span><br><span class="line">        jie[i] = jie[i-1]*(i-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(ll cur, ll father)</span><br><span class="line">&#123;</span><br><span class="line">    sum[cur] = 1;</span><br><span class="line">    for(ll i = 0; i &lt; tree[cur].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll son = tree[cur][i].v;</span><br><span class="line">        ll len = tree[cur][i].w;</span><br><span class="line">        if(father == son)</span><br><span class="line">            continue;</span><br><span class="line">        dfs(son, cur);</span><br><span class="line">        sum[cur] += sum[son]%mod;</span><br><span class="line">        sum[cur]%=mod;</span><br><span class="line">        dp[cur] += (dp[son]%mod + (n-sum[son])%mod*sum[son]%mod * len%mod)%mod;</span><br><span class="line">        dp[cur]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll u, v, w;</span><br><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;=2)&#123;</span><br><span class="line">            if(n==1)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            printf(&quot;%lld\n&quot;, 2*w%mod);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(ll i = 0; i &lt; n; i++)</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for(ll i = 0; i &lt; n-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            u--,v--;</span><br><span class="line">            Edge t1, t2;</span><br><span class="line">            t1.v = v;</span><br><span class="line">            t1.w = w;</span><br><span class="line">            t2.v = u;</span><br><span class="line">            t2.w = w;</span><br><span class="line">            tree[u].push_back(t1);</span><br><span class="line">            tree[v].push_back(t2);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, -1);</span><br><span class="line">        printf(&quot;%lld\n&quot;, (dp[0]%mod)*jie[n]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tree-and-Permutation&quot;&gt;&lt;a href=&quot;#Tree-and-Permutation&quot; class=&quot;headerlink&quot; title=&quot;Tree and Permutation&quot;&gt;&lt;/a&gt;Tree and Permutation&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
</feed>
