<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-09-18T08:03:32.264Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NOI手拉手问题</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18-1/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18-1/</id>
    <published>2018-09-18T07:08:24.000Z</published>
    <updated>2018-09-18T08:03:32.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成环的个数的期望。PS：一个人的左手和右手也可以拉起来构成一个环。</p><p>例如：n为2时，期望为4/3，假设从第一个人的左手开始，他的左手和右手和第2个人的左手和右手拉起来的概率都为1/3，其中自己的左手和右手拉起来构成环数为2，其他为1，则期望为<code>1/3*2+1/3*1+1/3*1</code></p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>1+1/3+1/5+……1/(2n-1)</p><p>如果直接看公式很容易理解，每多一个人，就多了两只手，假设除了这个人以外其他人的期望都算出来了，假设期望为F(n)，那么对于这个人来说无非两种情况，要么和自己拉，要么和别人拉，和自己拉的概率为1/(2n-1)，和别人拉的概率为(2n-2)/(2n-1)。和自己拉的话很好理解，在之前的期望上加1就好了，和别人拉的话就可以把这两个人绑定起来当成一个人就好了，期望就是之前的期望。所以用公式的话就是<code>F(n+1)=F(n)*(2n-2)/(2n-1)+(F(n)+1)*1/(2n-1)</code>,化简就得<code>F(n+1)=F(n)+1/(2n-1)</code>，递归得F(n)=1+1/3+1/5+……1/(2n-1)</p><p>根据调和级数推到公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ld long double</span><br><span class="line">const int maxn = 1e7+7;</span><br><span class="line">ld a[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    a[0] = 0;</span><br><span class="line">    a[1]=1;</span><br><span class="line">    for(int i = 2;i&lt;maxn;i++)&#123;</span><br><span class="line">        a[i]=a[i-1]+1.0/(2*i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;head.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;head.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    long long tmp;</span><br><span class="line">    init();</span><br><span class="line">    cin&gt;&gt;tmp;</span><br><span class="line">    if(tmp*1.0&gt;=maxn)</span><br><span class="line">        cout&lt;&lt;log(2*tmp-1) - log(((2*tmp-1)-1)/2)/ 2 + 0.57721566490153286060651209 / 2&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;a[tmp]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="概率轮" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E8%BD%AE/"/>
    
    
      <category term="期望" scheme="http://qianyouyou.cn/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>寻找距离最小点对</title>
    <link href="http://qianyouyou.cn/2018/09/18/2018-09-18/"/>
    <id>http://qianyouyou.cn/2018/09/18/2018-09-18/</id>
    <published>2018-09-18T03:07:01.000Z</published>
    <updated>2018-09-18T03:08:31.951Z</updated>
    
    <content type="html"><![CDATA[<p>在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一。下面我们着重考虑平面上的最接近点对问题。</p><p>​    最接近点对问题的提法是:给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。</p><p>​    严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。</p><p><strong>参考解答</strong></p><p>​    这个问题很容易理解，似乎也不难解决。我们只要将每一点与其他n-1个点的距离算出，找出达到最小距离的两个点即可。然而，这样做效率太低，需要O(n2)的计算时间。在问题的计算复杂性中我们可以看到，该问题的计算时间下界为Ω(nlogn)。这个下界引导我们去找问题的一个θ(nlogn)<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>。</p><p>这个问题显然满足分治法的第一个和第二个适用条件，我们考虑将所给的平面上n个点的集合S分成2个子集S1和S2，每个子集中约有n/2个点，·然后在每个子集中递归地求其最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对，因为S1和S2的最接近点对未必就是S的最接近点对。如果组成S的最接近点对的2个点都在S1中或都在S2中，则问题很容易解决。但是，如果这2个点分别在S1和S2中，则对于S1中任一点p，S2中最多只有n/2个点与它构成最接近点对的候选者，仍需做n2/4次计算和比较才能确定S的最接近点对。因此，依此思路，合并步骤耗时为O(n2)。整个算法所需计算时间T(n)应满足:　</p><p>T(n)=2T(n/2)+O(n2)</p><p>​     它的解为T(n)=O(n2)，即与合并步骤的耗时同阶，显示不出比用穷举的方法好。从解递归方程的套用公式法，我们看到问题出在合并步骤耗时太多。这启发我们把注意力放在合并步骤上。</p><p>​    为了使问题易于理解和分析，我们先来考虑一维的情形。此时S中的n个点退化为x轴上的n个实数x1,x2,..,xn。最接近点对即为这n个实数中相差最小的2个实数。我们显然可以先将x1,x2,..,xn排好序，然后，用一次线性扫描就可以找出最接近点对。这种方法主要计算时间花在排序上，因此如在排序算法中所证明的，耗时为O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对这种一维的简单情形，我们还是尝试用分治法来求解，并希望能推广到二维的情形。</p><p>​    假设我们用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}。这样一来，对于所有p∈S1和q∈S2有p</p><p>​    递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设δ=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如图1所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_1_633579015612968750.gif" alt="img">图1 一维情形的分治法</p><p>我们注意到，如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;δ，则p3和q3两者与m的距离不超过δ，即|p3-m|&lt;δ，|q3-m|&lt;δ，也就是说，p3∈(m-δ,m]，q3∈(m,m+δ]。由于在S1中，每个长度为δ的半闭区间至多包含一个点（否则必有两点距离小于δ），并且m是S1和S2的分割点，因此(m-δ,m]中至多包含S中的一个点。同理，(m,m+δ]中也至多包含S中的一个点。由图1可以看出，如果(m-δ,m]中有S中的点，则此点就是S1中最大点。同理，如果(m,m+δ]中有S中的点，则此点就是S2中最小点。因此，我们用线性时间就能找到区间(m-δ,m]和(m,m+δ]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。也就是说，按这种分治策略，合并步可在O(n)时间内完成。这样是否就可以得到一个有效的算法了呢？还有一个问题需要认真考虑，即分割点m的选取，及S1和S2的划分。选取分割点m的一个基本要求是由此导出集合S的一个线性分割，即S=S1∪S2 ，S1∩S2=Φ，且S1{x|x≤m}；S2{x|x&gt;m}。容易看出，如果选取m=[max(S)+min(S)]/2，可以满足线性分割的要求。选取分割点后，再用O(n)时间即可将S划分成S1={x∈S|x≤m}和S2={x∈S|x&gt;m}。然而，这样选取分割点m，有可能造成划分出的子集S1和S2的不平衡。例如在最坏情况下，|S1|=1，|S2|=n-1，由此产生的分治法在最坏情况下所需的计算时间T(n)应满足递归方程:</p><p>T(n)=T(n-1)+O(n)</p><p>​    它的解是T(n)=O(n2)。这种效率降低的现象可以通过分治法中”平衡子问题”的方法加以解决。也就是说，我们可以通过适当选择分割点m，使S1和S2中有大致相等个数的点。自然地，我们会想到用S的n个点的坐标的中位数来作分割点。在选择算法中介绍的选取中位数的线性时间算法使我们可以在O(n)时间内确定一个平衡的分割点m。</p><p>​     至此，我们可以设计出一个求一维点集S中最接近点对的距离的算法CPAIR1如下。</p><p>function CPAIR1(S);</p><p>begin</p><p>if |S|=2</p><p>then δ=|x[2]-x[1]| // x[1..n]存放的是S中n个点的坐标</p><p>else if (|S|=1)</p><p>then δ:=∞</p><p>else</p><p>begin</p><p>m:=S中各点的坐标值的中位数;</p><p>构造S1和S2,使S1={x∈S|x≤m}，S2={x∈S|x&gt;m}; δ1:=CPAIRI(S1); δ2:=CPAIRI(S2);</p><p>p:=max(S1); q:=min(S2);</p><p>δ:=min(δ1,δ2,q-p);</p><p>end;</p><p>return(δ);</p><p>end;</p><p>由以上的分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程：</p><p>​     解此递归方程可得T(n)=O(nlogn)。</p><p>​    这个算法看上去比用排序加扫描的算法复杂，然而这个算法可以向二维推广。</p><p>​    下面我们来考虑二维的情形。此时S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。</p><p>​    递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min(δ1,δ1)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈P1，q∈P2，如图2所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_2.jpg" alt="img"></p><p>图2 距直线l的距离小于δ的所有点</p><p> 在一维的情形，距分割点距离为δ的2个区间(m-δ,m](m,m+δ]中最多各有S中一个点。因而这2点成为唯一的末检查过的最接近点对候选者。二维的情形则要复杂些，此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，如图3所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_3_633579015617343750.jpg" alt="img">图3 包含点q的δ×2δ的矩形R</p><p>​    由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。如图4(a)所示。</p><p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/junerfsoft/466945/o_092408_1704_4_633579015619375000.jpg" alt="img">图4 矩形R中点的稀疏性</p><p>​    若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个δ×2δ的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则</p><p>​     因此d(u,v)≤5δ/6&lt;δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。图4(b)是矩形R中含有S中的6个点的极端情形。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n2/4对候选者。这是否就意味着我们可以在O(n)时间内完成分治法的合并步骤呢？现在还不能作出这个结论，因为我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。</p><p>​    至此，我们可以给出用分治法求二维最接近点对的算法CPAIR2如下:</p><p>function CPAIR2(S);</p><p>begin</p><p>if |S|=2</p><p>then δ:=S中这2点的距离</p><p>else if |S|=0</p><p>then δ:=∞</p><p>else</p><p>begin</p><p>\1. m:=S中各点x坐标值的中位数; 构造S1和S2，使S1={p∈S|px≤m}和S2={p∈S|px&gt;m}</p><p>\2. δ1:=CPAIR2(S1);δ2:=CPAIR2(S2);</p><p>\3. δm:=min(δ1,δ2);</p><p>\4. 设P1是S1中距垂直分割线l的距离在δm之内的所有点组成的集合， P2是S2中距分割线l的距离在δm之内所有点组成的集合。将P1和P2中的点依其y坐标值从小到大排序，并设P1<em>和P2</em>是相应的已排好序的点列;</p><ol start="5"><li>通过扫描P1<em>以及对于P1</em>中每个点检查P2<em>中与其距离在δm之内的所有点(最多6个)可以完成合并。当P1</em>中的扫描指针逐次向上移动 时，P2*中的扫描指针可在宽为2δm的一个区间内移动。设δl是按 这种扫描方式找到的点对间的最小距离;</li></ol><p>\6. δ=min(δm,δl);</p><p>end;</p><p>return(δ);</p><p>end;</p><p>下面我们来分析一下算法CPAIR2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间，第3步和第6步用了常数时间，第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合我们的要求。因此，在这里我们要作一个技术上的处理。我们采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列为P<em>。在执行分治法的第4步时，只要对P</em>作一次线性扫描，即可抽取出我们所需要的排好序的点列P1<em>和P2</em>。然后，在第5步中再对P1*作一次线性扫描，即可求得δl。因此，第4步和第5步的两遍扫描合在一起只要用O(n)时间。这样一来，经过预排序处理后的算法CPAIR2所需的计算时间T(n)满足递归方程：</p><p>​    显而易见T(n)=O(nlogn)，预排序所需的计算时间为O(n1ogn)。因此，整个算法所需的计算时间为O(nlogn)。在渐近的意义下，此算法已是最优的了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="分治" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E5%88%86%E6%B2%BB/"/>
    
    
      <category term="分治" scheme="http://qianyouyou.cn/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后，如何快速搭建之前基于github的博客</title>
    <link href="http://qianyouyou.cn/2018/09/17/2018-09-17/"/>
    <id>http://qianyouyou.cn/2018/09/17/2018-09-17/</id>
    <published>2018-09-17T11:08:06.000Z</published>
    <updated>2018-09-17T11:11:25.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="声明：此文是针对于windows环境"><a href="#声明：此文是针对于windows环境" class="headerlink" title="声明：此文是针对于windows环境"></a>声明：此文是针对于windows环境</h3><p>前提：我需要说几个条件;</p><p>1.当初搭建博客时的ssh没有删除，如果删除那就再重新配置一个，配置方法参照我上一篇博客；</p><p>2.当初搭建博客的仓库没有删除，如果删除，那就再重新搭一个吧，剩下的教程几乎没有关系了</p><p>3.如果，当时搭建博客时，如果按照我的教程，或者说按照网上大多数教程，有建了一个文件夹（例如：git pages或者hexo），这个文件夹在重装系统后还有保留下来，那最好不过。</p><h4 id="先说第一种情况：如果那个文件夹在的情况下："><a href="#先说第一种情况：如果那个文件夹在的情况下：" class="headerlink" title="先说第一种情况：如果那个文件夹在的情况下："></a>先说第一种情况：如果那个文件夹在的情况下：</h4><p>不知道你们有没有按照其他的教程去配置静态页面，我按照那个方法有在github上新建了一个branch</p><p>那个gh-pages是我新建的branch，如果建了没关系</p><p>我们只需用点击master就好，回到原来的地方</p><p>然后再你原来的那个文件夹里打开git bash here</p><p>输入npm install hexo –save</p><p>然后可以试着输入hexo g 和hexo d</p><p>提示你需要重新配置邮箱和用户名，那么按照原来的邮箱和原来的用户名输入就好；</p><p>再次输入hexo g，如果有提示</p><p>就说明已经重新配置好了；</p><h4 id="如果没有保留当初在桌面配置的文件夹"><a href="#如果没有保留当初在桌面配置的文件夹" class="headerlink" title="如果没有保留当初在桌面配置的文件夹"></a>如果没有保留当初在桌面配置的文件夹</h4><p>首先先看看自己电脑上有没有ssh</p><p>在自己的一个盘里建一个文件夹，里面分别有三个文件夹（git，node，git pages）</p><p>分别在git和node里配置好git和node</p><p>然后再git pages里打开git bash here检查有没有ssh</p><p>cd ~/. ssh</p><p>如果有 No such file or directory</p><p>说明是第一次使用，那么按照上一篇博客配置，</p><p>如果提示有，那么你可以先试试这个ssh能用不，先别急着删；</p><p>按照刚刚的步骤再输入 npm install hexo –save</p><p>然后按照刚刚的步骤再来一次；</p><p>如果最后hexo d后，文章没有推上去，那么就说明没有成功，需要重新配置ssh</p><p>先删除原来的ssh<br>ssh-add -D<br>rm -r ~/.ssh</p><p>最好查看一下上一篇博客里，Deployment的config.yml文件里面的deploy值有没有改好（参照上一篇）</p><p>配置好了之后再按照刚刚的步骤再来一次（记得配置邮箱和用户名）</p><p>如果git bash在这儿没有起作用的话，</p><p>那么win+r打开cmd，安装一个类似刚刚操作的扩展</p><p>输入 npm install hexo-deployer-git –save</p><p>然后再输入</p><p>hexo g<br>hexo d</p><p>然后再进入自己的博客页面查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;声明：此文是针对于windows环境&quot;&gt;&lt;a href=&quot;#声明：此文是针对于windows环境&quot; class=&quot;headerlink&quot; title=&quot;声明：此文是针对于windows环境&quot;&gt;&lt;/a&gt;声明：此文是针对于windows环境&lt;/h3&gt;&lt;p&gt;前提：我需要
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>质因数分解原创算法</title>
    <link href="http://qianyouyou.cn/2018/09/13/2018-09-13/"/>
    <id>http://qianyouyou.cn/2018/09/13/2018-09-13/</id>
    <published>2018-09-13T10:54:41.000Z</published>
    <updated>2018-09-17T11:06:47.461Z</updated>
    
    <content type="html"><![CDATA[<p>由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Prime()&#123;</span><br><span class="line">memset(tag,0,sizeof(tag));</span><br><span class="line">int cnt=0;</span><br><span class="line">for(int i = 2; i&lt;N; i++)&#123;</span><br><span class="line">if(tag[i])</span><br><span class="line">prime[cnt++]=i;</span><br><span class="line">for(int j=0;j&lt;cnt &amp;&amp; prime[j]*i&lt;N; j++)&#123;</span><br><span class="line">tag[i*prime[j]] = i;</span><br><span class="line">if(i % prime[j]==0)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>路径规划总结之A*搜索</title>
    <link href="http://qianyouyou.cn/2018/09/10/2018-09-10/"/>
    <id>http://qianyouyou.cn/2018/09/10/2018-09-10/</id>
    <published>2018-09-10T12:59:37.000Z</published>
    <updated>2018-09-10T13:39:49.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h2><p>路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。机器人的路径规划应用场景极丰富，最常见如游戏中NPC及控制角色的位置移动，百度地图等导航问题，小到家庭扫地机器人、无人机大到各公司正争相开拓的无人驾驶汽车等。</p><p>目前路径规划算法分为：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-09-10-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92.png" alt=""></p><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h2><p>首先，我们来看看<code>A*</code>算法的定义：<code>A*</code>（A-Star)算法是一种静态路网中求解最短路径最有效的<strong>直接</strong>搜索方法，也是解决许多搜索问题的有效算法。 采用广度优先搜索策略，在搜索过程中使用启发函数，即有大致方向的向前进虽然目标有时候不是很明确。 </p><p>在计算机科学中，A*算法作为Dijkstra算法的扩展，因其高效性而被广泛应用于寻路及图的遍历，如星际争霸等游戏中就大量使用。在理解算法前，我们需要知道几个概念：</p><ul><li>搜索区域（The Search Area）：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。　　</li><li>开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。</li><li>父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针。</li><li>路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销。</li><li>启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和。</li></ul><p>可能看定义不是很好理解，那么我们根据例子具体看看什么是A*算法吧。</p><p>详细讲解参考：</p><p><a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987?fr=aladdin" target="_blank" rel="noopener">启发式算法</a></p><p><a href="https://www.cnblogs.com/zhoug2020/p/3468167.html" target="_blank" rel="noopener">A*算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路径规划&quot;&gt;&lt;a href=&quot;#路径规划&quot; class=&quot;headerlink&quot; title=&quot;路径规划&quot;&gt;&lt;/a&gt;路径规划&lt;/h2&gt;&lt;p&gt;路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ACM-ICPC 2018 徐州赛区网络预赛</title>
    <link href="http://qianyouyou.cn/2018/09/09/2018-09-09/"/>
    <id>http://qianyouyou.cn/2018/09/09/2018-09-09/</id>
    <published>2018-09-09T14:04:18.000Z</published>
    <updated>2018-09-09T14:20:13.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Characters-with-Hash"><a href="#Characters-with-Hash" class="headerlink" title="Characters with Hash"></a>Characters with Hash</h2><p><a href="https://wenda.jisuanke.com/nanti/31461" target="_blank" rel="noopener">问答</a></p><ul><li>26.45%</li><li>1000ms</li><li>262144K</li></ul><p>Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”.</p><p>It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line a integer TT , the number of test cases (T \le 10)(T≤10).</p><p>For each test case:</p><p>First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000).</p><p>Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single number which gives the answer.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 z</span><br><span class="line">oMl</span><br><span class="line">6 Y</span><br><span class="line">YJSNPI</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char str[1000007],ch[2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%s%s&quot;,&amp;n,ch,str);</span><br><span class="line">        int ans = 2*n;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(str[i]==ch[0])</span><br><span class="line">                ans-=2;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(abs(str[i]-ch[0])&lt;10)</span><br><span class="line">                    ans-=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans==0)</span><br><span class="line">            ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Characters-with-Hash&quot;&gt;&lt;a href=&quot;#Characters-with-Hash&quot; class=&quot;headerlink&quot; title=&quot;Characters with Hash&quot;&gt;&lt;/a&gt;Characters with Hash&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛K题-Supreme Number</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08-1/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08-1/</id>
    <published>2018-09-08T14:28:16.000Z</published>
    <updated>2018-09-09T14:03:30.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Supreme-Number"><a href="#Supreme-Number" class="headerlink" title="Supreme Number"></a>Supreme Number</h3><p><a href="https://wenda.jisuanke.com/nanti/31452" target="_blank" rel="noopener">问答</a></p><ul><li>26.7%</li><li>1000ms</li><li>131072K</li></ul><p>A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers.</p><p>Now lets define a number NN as the <strong>supreme number</strong> if and only if each number made up of an non-empty <strong>subsequence</strong> of all the numeric digits of NN must be either a prime number or 11.</p><p>For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number.</p><p>Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal <em>supreme number</em> that does not exceed NN?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases.</p><p>In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case print <code>&quot;Case #x: y&quot;</code>, in which xx is the order number of the test case and yy is the answer.</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 5</span><br><span class="line">Case #2: 73</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;</span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    char ch=&apos; &apos;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ans&lt;100000)</span><br><span class="line">        ans=ans*10+ch-&apos;0&apos;;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int aaa=1;aaa&lt;=t;aaa++)&#123;</span><br><span class="line">        int ans = read();</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for(i = 0;i&lt;19;i++)&#123;</span><br><span class="line">            if(pri[i]&gt;ans)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==19)</span><br><span class="line">            cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000000</span><br><span class="line">int h=0;</span><br><span class="line">bool p[N];</span><br><span class="line">int prime[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    if(p[x]==false)</span><br><span class="line">        return false;</span><br><span class="line">    int c = 1;</span><br><span class="line">    while(c&lt;x)&#123;</span><br><span class="line">        c*=10;</span><br><span class="line">        if(p[x%c]==false)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        if(c&gt;x)</span><br><span class="line">            break;</span><br><span class="line">        int tmp = x;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(p[tmp]==false)</span><br><span class="line">                return false;</span><br><span class="line">            if(p[tmp%c]==false)</span><br><span class="line">                return false;</span><br><span class="line">            tmp/=c;</span><br><span class="line">            if(!tmp)</span><br><span class="line">                break;</span><br><span class="line">            if(dfs(tmp)==false)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void db()</span><br><span class="line">&#123;</span><br><span class="line">memset(p,true,sizeof(p));</span><br><span class="line">p[0] = false;</span><br><span class="line">for(int i=2;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[i]==false)</span><br><span class="line">            continue;</span><br><span class="line">for(int j=2;i*j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line">p[i*j]=false;</span><br><span class="line">&#125;</span><br><span class="line">if(!dfs(i))</span><br><span class="line">            p[i] = false;</span><br><span class="line">        if(p[i]==true)</span><br><span class="line">&#123;</span><br><span class="line">prime[h++]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">db();</span><br><span class="line">int n;  //打印前n个质数</span><br><span class="line">for(int i=0;i&lt;=h;i++)</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Supreme-Number&quot;&gt;&lt;a href=&quot;#Supreme-Number&quot; class=&quot;headerlink&quot; title=&quot;Supreme Number&quot;&gt;&lt;/a&gt;Supreme Number&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛D题-A*模板题</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08/</id>
    <published>2018-09-08T13:28:16.000Z</published>
    <updated>2018-09-09T14:03:51.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Made-In-Heaven"><a href="#Made-In-Heaven" class="headerlink" title="Made In Heaven"></a>Made In Heaven</h2><p><a href="https://wenda.jisuanke.com/nanti/31445" target="_blank" rel="noopener">问答</a></p><ul><li>14.67%</li><li>1000ms</li><li>131072K</li></ul><p>One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry.</p><p>JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are at most 5050 test cases.</p><p>The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN.</p><p>The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ).</p><p>Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW.</p><p>It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist.</p><p>All the test cases are generated randomly.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>One line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output <code>&quot;yareyaredawa&quot;</code> (without quote), else output <code>&quot;Whitesnake!&quot;</code> (without quote).</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 2 14</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yareyaredawa</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“<code>Whitesnake!</code>”，否则输出“<code>yareyaredawa</code>”</p><p>类似<a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ2449</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>A*+SPFA</p><h4 id="A-算法："><a href="#A-算法：" class="headerlink" title="A*算法："></a>A*算法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A*，启发式搜索，是一种较为有效的搜索方法。</span><br><span class="line">我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。</span><br><span class="line">我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。</span><br><span class="line">所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。</span><br></pre></td></tr></table></figure><h4 id="估价函数："><a href="#估价函数：" class="headerlink" title="估价函数："></a>估价函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。</span><br><span class="line">在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。</span><br><span class="line"></span><br><span class="line">估价函数需要满足：</span><br><span class="line">　　设当前状态state到目标函数所需代价的估计值为f(state)</span><br><span class="line">　　设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state)</span><br><span class="line">　　对于任意的state，应该有f(state)&lt;=g(state)</span><br><span class="line">也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。</span><br></pre></td></tr></table></figure><h4 id="第K短路："><a href="#第K短路：" class="headerlink" title="第K短路："></a>第K短路：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。</span><br><span class="line">实现过程：</span><br><span class="line">1.预处理f(x)，在反向图上以T为起点求到每个点的最短路</span><br><span class="line">2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问</span><br><span class="line">3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中</span><br><span class="line">4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路</span><br><span class="line"></span><br><span class="line">因为估价函数的作用，图中很多节点访问次数远小于K</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll x,y,z,s,t,k;</span><br><span class="line">    ll T;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T;</span><br><span class="line">        prepare();</span><br><span class="line">        for(ll i=1;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            add_edge(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(t);</span><br><span class="line">        ll ans=a_star(s,t,k);</span><br><span class="line">        if(ans&lt;=T&amp;&amp;ans!=-1)</span><br><span class="line">            cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k短路模板"><a href="#k短路模板" class="headerlink" title="k短路模板"></a>k短路模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Made-In-Heaven&quot;&gt;&lt;a href=&quot;#Made-In-Heaven&quot; class=&quot;headerlink&quot; title=&quot;Made In Heaven&quot;&gt;&lt;/a&gt;Made In Heaven&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/A-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
      <category term="k短路" scheme="http://qianyouyou.cn/tags/k%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[最短路]SPFA的SLF与LLL优化</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05-2/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05-2/</id>
    <published>2018-09-05T10:08:53.000Z</published>
    <updated>2018-09-05T12:14:48.508Z</updated>
    
    <content type="html"><![CDATA[<p>SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。</p><p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ; Q.pop_front( ) ; mark[u] = false ;</span><br><span class="line">    </span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] &gt; dis[Q.front( )]  ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，每次出队时，若 d[i]&gt;平均值，把 i 移到队列末尾，如此反复，直到找到某一i使得dist(i)&lt;=x，则将i出队进行松弛操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ; tot = 0 ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ;</span><br><span class="line">        Q.pop_front( ) ;</span><br><span class="line">        if( dis[u] * tot &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">        Q.push_back( u ) ;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[u] = false ;</span><br><span class="line">        tot-- ; sum -= dis[u] ;</span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] * tot &gt; sum ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    tot++ ; sum += dis[v] ;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。&lt;/p&gt;
&lt;p&gt;SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &amp;lt; dist(i
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="SPFA算法" scheme="http://qianyouyou.cn/tags/SPFA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[C++] pair和make_pair</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05-1/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05-1/</id>
    <published>2018-09-05T08:16:08.000Z</published>
    <updated>2018-09-05T08:25:13.959Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：<a href="https://blog.csdn.net/yockie/article/details/6980692" target="_blank" rel="noopener">pair与make_pair</a></p><p>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。<br>例如std::pair&lt;int,float&gt; 或者 std::pair&lt;double,double&gt;等。<br>pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。<br>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：<br>template pair make_pair(T1 a, T2 b) { return pair(a, b); }<br>    一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。<br>另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：<br>    例如有如下两个定义：<br>        std::pair&lt;int, float&gt;(1, 1.1);<br>        std::make_pair(1, 1.1);<br>其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。<br>这个问题在编程是需要引起注意。<br>下面是一段pair与make_pair的例子程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product1.first &lt;&lt;&quot; is $&quot;&lt;&lt; product1.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product2.first &lt;&lt;&quot; is $&quot;&lt;&lt; product2.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product3.first &lt;&lt;&quot; is $&quot;&lt;&lt; product3.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：&lt;a href=&quot;https://blog.csdn.net/yockie/article/details/6980692&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pair与ma
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="stl" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/stl/"/>
    
    
      <category term="stl" scheme="http://qianyouyou.cn/tags/stl/"/>
    
      <category term="模板" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>[单源最短路]两大优化算法争锋之SPFA与堆优化版Dijkstra</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05/</id>
    <published>2018-09-05T07:16:00.000Z</published>
    <updated>2018-09-05T09:12:42.033Z</updated>
    
    <content type="html"><![CDATA[<p>单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。</p><p>这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 </p><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>时间复杂度：O(V2+E) </p><p>n-1次循环</p><p>–&gt;找到未标记的d最小的点</p><p>–&gt;标记，松弛它的边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)&#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])&#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>时间复杂度：O(VE) </p><p>n-1次循环</p><p>–&gt;对所有边松弛</p><p>还能再松弛则有负环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int dis[10010];</span><br><span class="line">int u[10010],v[10010],w[10010];</span><br><span class="line">int n,m;</span><br><span class="line">void Bellman_ford(int a)&#123;</span><br><span class="line">    memset(dis,inf,sizeof(dis));//赋初始值</span><br><span class="line">    dis[a]=0;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)//更新n-1次</span><br><span class="line">        for(int j=1;j&lt;=m;j++)//更新每一条边</span><br><span class="line">            dis[v[j]]=min(dis[v[j]],dis[u[j]]+w[j]);//判断是否更新</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="两大基础算法对比"><a href="#两大基础算法对比" class="headerlink" title="两大基础算法对比"></a>两大基础算法对比</h2><ul><li>Dijkstra是每次确定了到一个点的最短距离，再用该点更新到其它点的距离。不能处理有负边的图。</li><li>Bellman-Ford是每次对所有边松弛。可以计算出有负边无负环的最短路，可以判断是否存在负环。</li></ul><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="Dijkstra-heap优化"><a href="#Dijkstra-heap优化" class="headerlink" title="Dijkstra+heap优化"></a>Dijkstra+heap优化</h2><p>时间复杂度：O((V+E)lgV)</p><p>用STL中的优先队列实现堆：</p><p>while(优先队列非空)</p><p>–&gt;队头出队，松弛它的边</p><p>–&gt;松弛了的&lt;新距离,点&gt;入队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;</span><br><span class="line">...</span><br><span class="line">while(!q.empty())&#123;  // O(V) 加上count&lt;n可以优化一点点 </span><br><span class="line">    int w=q.top().first, u=q.top().second;</span><br><span class="line">    q.pop();   // O(lgV)</span><br><span class="line">    if(b[u])continue; b[u]=true;</span><br><span class="line">    //++count;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123; // Sum -&gt; O(E)</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            q.push(PII(d[v],v));  // O(lgV)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>时间复杂度：O(kE) or O(VE)</p><p>while(队非空)</p><p>–&gt;队头出队，松弛它的边</p><p>–&gt;松弛了且不在队内的点入队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(!q.empty())&#123;</span><br><span class="line">    int u=q.front(); q.pop();</span><br><span class="line">    b[u]=false;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            if(!b[v])b[v]=true,q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路对比"><a href="#算法思路对比" class="headerlink" title="算法思路对比"></a>算法思路对比</h2><ul><li>Dijkstra+heap是用小根堆，每次取出d最小的点，来更新距离，那么这个点来说，最小距离就是当前的d。</li><li>SPFA是用双端队列，每次取出队头，来更新距离，它之后可能还会入队。它是一种动态逼近法，因为每次松弛距离都会减小，所以松弛一定会有结束的。如果一个点入队超过n次就是存在负环。</li></ul><h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><p>Dijkstra+heap</p><ul><li>因为是堆，取队头需要O(lgV)。</li><li>松弛边时，因为点的d改变了，所以点v需要以新距离重新入堆，O(lgV)，总共O(ElgV)。</li><li>因此总的是O((V+E)lgV)</li></ul><p>SPFA</p><ul><li>论文证明也不严格。复杂度不太好分析。</li><li><del>总的是O(kE)。k大概为2</del>。</li><li>复杂度应该是 O(VE)。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。</p><p>另外，Dijkstra和Prim也很相似，它们的区别主要是d的含义，前者是到s的临时最短距离，后者是到树的临时最短距离，相同点是，每次找d最小的更新其它点的距离。</p><h1 id="Dijkstra堆优化版代码"><a href="#Dijkstra堆优化版代码" class="headerlink" title="Dijkstra堆优化版代码"></a>Dijkstra堆优化版代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">ll dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n]!=maxx)</span><br><span class="line">        printf(&quot;%lld\n&quot;,dis[n]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。&lt;/p&gt;
&lt;p&gt;这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 &lt;/p&gt;
&lt;h1 id=&quot;基础
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Dijkstra算法" scheme="http://qianyouyou.cn/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
      <category term="SPFA算法" scheme="http://qianyouyou.cn/tags/SPFA%E7%AE%97%E6%B3%95/"/>
    
      <category term="Bellman-Ford算法" scheme="http://qianyouyou.cn/tags/Bellman-Ford%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[分层最短路]Magical Girl Haze</title>
    <link href="http://qianyouyou.cn/2018/09/04/2018-09-04/"/>
    <id>http://qianyouyou.cn/2018/09/04/2018-09-04/</id>
    <published>2018-09-04T07:21:48.000Z</published>
    <updated>2018-09-05T07:57:39.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>去掉的k条路肯定全部在从1到n的某一条路径上，这样走这一条路径才有可能最短。我们可以对最短路分层，即分别求k为0，k为1，k为2……k为k的情况下最短路程。定义最短路时使用二维数组<code>dis[n][k]</code>,n为结点数，k为分层数。设i为每次求得的最短路结点，kk为所在层，dis为最短路，原点到原点的距离为0，则：</p><p>最短路状态转移方程：<code>dis[j][kk]=min(dis[i][kk]+road[i][j],dis[j][kk])</code></p><p>分层状态转移方程：<code>dis[j][kk+1]=min(dis[i][kk],dis[j][kk+1])</code></p><h2 id="Magical-Girl-Haze"><a href="#Magical-Girl-Haze" class="headerlink" title="Magical Girl Haze"></a>Magical Girl Haze</h2><p>There are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases.</p><p>For each test case, the first line has three integers N, MN,M and KK.</p><p>Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv.</p><p>It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,<br>0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print the minimum distance.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,k,cnt;</span><br><span class="line">ll dis[maxn][12];</span><br><span class="line">bool vis[maxn][12];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u, j;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,int j,ll w):u(u),j(j),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        int j = q.top().j;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk][j])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk][j] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(j&lt;k&amp;&amp;!vis[edge[l].to][j+1]&amp;&amp;dis[edge[l].to][j+1] &gt; minD)&#123;</span><br><span class="line">                dis[edge[l].to][j+1] = minD;</span><br><span class="line">                q.push(NODE(edge[l].to,j+1,dis[edge[l].to][j+1]));</span><br><span class="line">            &#125;</span><br><span class="line">            if(!vis[edge[l].to][j]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to][j])&#123;</span><br><span class="line">                dis[edge[l].to][j] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,j,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n][k]!=maxx)</span><br><span class="line">        printf(&quot;%lld\n&quot;,dis[n][k]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="分层最短路" scheme="http://qianyouyou.cn/tags/%E5%88%86%E5%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[数论]辗转相除法求gcd的数学证明</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03-2/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03-2/</id>
    <published>2018-09-03T15:57:36.000Z</published>
    <updated>2018-09-04T10:48:32.100Z</updated>
    
    <content type="html"><![CDATA[<p>在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。</p><p>gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a,b)。这里就不证明了。</p><p>我们接着看gcd，如何高效求gcd呢？目前最快的方法算是欧几里得算法了。</p><p>欧几里得算法其实很简单，已知a，b，其中a&gt;b，求gcd(a,b)。</p><p>解：用b整除a，得到余数c，再用c整除b，得到余数d，再用d整除c，得到余数e……不断这样操作，最后直到没有余数为止。假设e再整除d，余数为0，则e为最大公因数。</p><p>列式子即为：</p><p>a = x1 * b + r1;</p><p>b = x2 * r1 + r2;</p><p>r1 = x3 * r2 + r3;</p><p>……</p><p>rn-1= xn+1 * rn + rn+1;</p><p>rn = xn+2 * rn+1 + 0;</p><p>若设a为r-1，b为r0，则通项公式即为rn-1 / rn = xn+1 <em> rn + rn+1，最后一项为rn / rn+1 = xn+2 </em> rn+1。</p><p>很容易理解，若某一步余数为0，则上一步的余数即为最大公约数。很容易证明该循环一定会终止，因为最坏的情况下a和b的最大公因数是1，那么任何一个数都是1的倍数，所以任何数取余1都为0，所以循环必会结束。</p><p>该算法历经千年，直到现在依然为求解gcd最高效的算法，gcd(a,b)最坏的情况下运算次数最多才是b位数的7位，这里就不详细介绍了。</p><p>那么为什么最后的结果就是最大公因数呢，接下来我们来证明一下。</p><p>假设g为gcd(a,b)，即g为g，b的最大公因数，则带到上式记为rn = xn+2 * g，这个式子g必然为rn的因数。</p><p>那再带到上一个式子，rn-1 = xn+1 * rn + g，由于g既是rn的因数，又是g的因数，则g是rn-1的因数。</p><p>再带到上一个式子，rn-2 = xn * rn-1 + rn，由于g是rn-1，rn的因数，所以g必然是rn-2的因数。</p><p>……</p><p>最终带到第一组式子中，即g既是a的因数，也是b的因数。</p><p>那如何证明它是最大公因数呢？</p><p>我们假设h为a，b的任意因数，则h整除a，且h整除b，带到第一个式子，则h整除r1，再带到第2个式子，h整除r2，再带到第3个式子，h整除r3……直到倒数第二个式子，h整除rn+1，即h整除g由于最后一个式子余数为0，那么既然g为a，b的因数，h为g的因数，则h&lt;=g，故g为gcd(a,b)。</p><p>证毕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。&lt;/p&gt;
&lt;p&gt;gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>An Olympian Math Problem</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03-1/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03-1/</id>
    <published>2018-09-03T15:57:28.000Z</published>
    <updated>2018-09-05T05:39:16.683Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：</p><p>求解<code>(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1</code>。</p><p>PS：<code>n! = 1 * 2 * …… * n</code>。</p><p>证明过程：</p><p><img src="http://pdz5m676b.bkt.clouddn.com/2018-09-03QQ%E5%9B%BE%E7%89%8720180904190419.jpg" alt=""></p><p>Alice, a student of grade 66, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is:</p><p>We denote k!k!:</p><p>k! = 1 \times 2 \times \cdots \times (k - 1) \times kk!=1×2×⋯×(k−1)×k</p><p>We denote SS:</p><p>S = 1 \times 1! + 2 \times 2! + \cdots +S=1×1!+2×2!+⋯+<br>(n - 1) \times (n-1)!(n−1)×(n−1)!</p><p>Then SS module nn is <strong><strong>____</strong></strong></p><p>You are given an integer nn.</p><p>You have to calculate SS modulo nn.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer T(T \le 1000)T(T≤1000), denoting the number of test cases.</p><p>For each test case, there is a line which has an integer nn.</p><p>It is guaranteed that 2 \le n\le 10^{18}2≤n≤1018.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print an integer SS modulo nn.</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The first test is: S = 1\times 1!= 1S=1×1!=1, and 11modulo 22 is 11.</p><p>The second test is: S = 1\times 1!+2 \times 2!= 5S=1×1!+2×2!=5, and 55 modulo 33 is 22.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll t,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;求解&lt;code&gt;(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;n! = 1 * 2 * …… * n&lt;/
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>介于邻接矩阵与邻接表之间的存图方式————链式前向星</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03/</id>
    <published>2018-09-03T12:23:43.000Z</published>
    <updated>2018-09-03T12:31:36.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>链式前向星</strong></p><p><strong>图的存储一般有三种：邻接矩阵、邻接表、前向星。</strong></p><p><strong>若图是稀疏图，边很少，开二维数组很浪费;</strong></p><p><strong>若点很多(如10000个点)<code>a[10000][10000]</code>又会爆.只能用前向星做.</strong></p><p><strong>前向星的效率不是很高，优化后为链式前向星，直接介绍链式前向星。</strong></p><h2 id="（一）链式前向星"><a href="#（一）链式前向星" class="headerlink" title="（一）链式前向星"></a><strong>（一）链式前向星</strong></h2><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. <strong>结构</strong></h2><p><strong>这里用两个东西：</strong></p><p><strong>1 结构体数组edge存边，edge[i]表示第i条边,</strong></p><p><strong>2 head[i]存以i为起点的第一条边(在edge中的下标)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct EDGE&#123;</span><br><span class="line">int next;   //下一条边的存储下标(默认0) </span><br><span class="line">int to;     //这条边的终点 </span><br><span class="line">int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[500010];</span><br></pre></td></tr></table></figure><h2 id="2-增边"><a href="#2-增边" class="headerlink" title="2.增边"></a><strong>2.增边</strong></h2><p><strong>若以点i为起点的边新增了一条，在edge中的下标为j.</strong></p><p><strong>那么edge[j].next=head[i];然后head[i]=j.</strong></p><p><strong>即每次新加的边作为第一条边，最后倒序遍历</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">//cnt为边的计数，从1开始计 </span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. <strong>遍历</strong></h2><p><strong>遍历以st为起点的边</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=head[st]; i!=0; i=edge[i].next)</span><br></pre></td></tr></table></figure><p>i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）</p><p><strong>一个简单的输出有向图熟悉链式前向星：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">int next;   //下一条边的存储下标 </span><br><span class="line">int to;     //这条边的终点 </span><br><span class="line">int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, cnt;</span><br><span class="line">int head[MAXN];  //head[i]表示以i为起点的第一条边 </span><br><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125; </span><br><span class="line">void Print() &#123;</span><br><span class="line">int st;</span><br><span class="line">cout &lt;&lt; &quot;Begin with[Please Input]: \n&quot;;</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line">for(int i=head[st]; i!=0; i=edge[i].next) &#123;//i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 </span><br><span class="line">cout &lt;&lt; &quot;Start: &quot; &lt;&lt; st &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;End: &quot; &lt;&lt; edge[i].to &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;W: &quot; &lt;&lt; edge[i].w &lt;&lt; endl &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int s, t, w;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;</span><br><span class="line">Add(s, t, w);</span><br><span class="line">&#125;</span><br><span class="line">Print(); </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）链式前向星实现SPFA"><a href="#（二）链式前向星实现SPFA" class="headerlink" title="（二）链式前向星实现SPFA"></a><strong>（二）链式前向星实现SPFA</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define ANS_MAX 2147483647</span><br><span class="line">struct EDGE &#123;</span><br><span class="line">int next;</span><br><span class="line">int to;</span><br><span class="line">int w;</span><br><span class="line">&#125;;</span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, st, cnt;</span><br><span class="line">int head[MAXN];</span><br><span class="line">int d[MAXN];</span><br><span class="line">bool inq[MAXN];</span><br><span class="line">inline int Read() &#123;</span><br><span class="line">char c; int ans = 0; bool Sign = false;</span><br><span class="line">while(!isdigit(c=getchar()) &amp;&amp; c != &apos;-&apos;);</span><br><span class="line">if(c == &apos;-&apos;) &#123;</span><br><span class="line">Sign = true;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">ans = (ans&lt;&lt;3) + (ans&lt;&lt;1) + (c ^ &apos;0&apos;);</span><br><span class="line">&#125; while(isdigit(c=getchar()));</span><br><span class="line">return Sign ? -ans : ans;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int u, int v, int w) &#123;</span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">void read() &#123;</span><br><span class="line">int x, y, w;</span><br><span class="line">n = Read();</span><br><span class="line">m = Read();</span><br><span class="line">st = Read();</span><br><span class="line">for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">x = Read();</span><br><span class="line">y = Read();</span><br><span class="line">w = Read();</span><br><span class="line">Add(x, y, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void SPFA(int x) &#123;</span><br><span class="line">d[x] = 0; for(int i=1; i&lt;=n; i++) d[i] = ANS_MAX;</span><br><span class="line">queue&lt;int&gt; Q; Q.push(x); inq[x] = true;</span><br><span class="line">while(!Q.empty()) &#123;</span><br><span class="line">int k = Q.front(); Q.pop(); inq[k] = false;</span><br><span class="line">for(int i=head[k]; i!=0; i=edge[i].next) &#123;</span><br><span class="line">int j = edge[i].to;</span><br><span class="line">if(d[j] &gt; d[k] + edge[i].w) &#123;</span><br><span class="line">d[j] = d[k] + edge[i].w;</span><br><span class="line">if(!inq[j]) &#123;</span><br><span class="line">Q.push(j);</span><br><span class="line">inq[j] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, d[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">read();</span><br><span class="line">SPFA(st);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;链式前向星&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图的存储一般有三种：邻接矩阵、邻接表、前向星。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若图是稀疏图，边很少，开二维数组很浪费;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若点很多(如
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="链式前向星" scheme="http://qianyouyou.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1001 Buy and Resell</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25-2/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25-2/</id>
    <published>2018-08-25T14:55:54.000Z</published>
    <updated>2018-08-26T12:26:24.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p><p>Problem Description</p><p>The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:<br>\1. spend ai dollars to buy a Power Cube<br>\2. resell a Power Cube and get ai dollars if he has at least one Power Cube<br>\3. do nothing<br>Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning.</p><p>Input</p><p>There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:<br>The first line has an integer n. (1≤n≤105)<br>The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)<br>It is guaranteed that the sum of all n is no more than 5×105.</p><p>Output</p><p>For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit.</p><p>Sample Input</p><p>3 4 1 2 10 9 5 9 5 9 10 5 2 2 1</p><p>Sample Output</p><p><em>Hint</em></p><p>profit = - 1 - 2 + 10 + 9 = 16</p><p>profit = - 5 + 10 = 5</p><p>profit = 0</p><p>题解：</p><p>n天，每天商品有个价格，或买或卖或不买不卖。</p><p>贪心策略：分为两个堆（或优先队列），一个堆v为储存买的价格，一个堆s储存卖的价格。第i天的商品和之前买与卖两个堆中的最小值进行比较。共分为四种情况：1.如果第i天的价格比买的堆v里最小值大，且买的堆v里最小值比卖的堆s里最小值小，则买掉买的堆v里最小的，再卖出去，交易次数加2，即v.pop(),s.push(),cnt+2。2.如果第i天的价格比卖的堆s里最小值大，且买的堆v里最小值比卖的堆s里最小值大，则买掉卖的堆s里最小的，再卖出去，意思为现在卖比之前卖的那次更划算，我们把它买回来就等于之前那次没有卖，再卖出去等于现在才卖，即s.pop(),v.push(),s.push()。3.如果当天的价格即小于s中最小又小于v中最小，则把他放到买的堆v里，即v.push()。</p><p>这样下来，最后买的堆里剩下的就是没买没卖的。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll n, tmp, cnt = 0,sum = 0;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;v,s;</span><br><span class="line">        for(ll i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;tmp);</span><br><span class="line">            if(!v.empty())&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top()&amp;&amp;s.top()&lt;=v.top())&#123;</span><br><span class="line">                    sum+=tmp-(s.top());</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                 else if(tmp&gt;v.top()&amp;&amp;(s.empty()||s.top()&gt;v.top()))&#123;</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                    sum+=tmp-(v.top());</span><br><span class="line">                    v.pop();</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(tmp&lt;=v.top())&#123;</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top())&#123;</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    sum+=tmp-s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld %lld\n&quot;,sum,2*cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Buy-and-Resell&quot;&gt;&lt;a href=&quot;#Buy-and-Resell&quot; class=&quot;headerlink&quot; title=&quot;Buy and Resell&quot;&gt;&lt;/a&gt;Buy and Resell&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit: 20
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1009 Tree and Permutation</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25-1/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25-1/</id>
    <published>2018-08-25T13:03:48.000Z</published>
    <updated>2018-08-26T12:27:00.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tree-and-Permutation"><a href="#Tree-and-Permutation" class="headerlink" title="Tree and Permutation"></a>Tree and Permutation</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p><p>Problem Description</p><p>There are N vertices connected by N?1 edges, each edge has its own length.<br>The set { 1,2,3,…,N } contains a total of N! unique permutations, let’s say the i-th permutation is Pi and Pi,j is its j-th number.<br>For the i-th permutation, it can be a traverse sequence of the tree with N vertices, which means we can go from the Pi,1-th vertex to the Pi,2-th vertex by the shortest path, then go to the Pi,3-th vertex ( also by the shortest path ) , and so on. Finally we’ll reach the Pi,N-th vertex, let’s define the total distance of this route as D(Pi) , so please calculate the sum of D(Pi) for all N! permutations.</p><p>Input</p><p>There are 10 test cases at most.<br>The first line of each test case contains one integer N ( 1≤N≤105 ) .<br>For the next N?1 lines, each line contains three integer X, Y and L, which means there is an edge between X-th vertex and Y-th of length L ( 1≤X,Y≤N,1≤L≤109 ) .</p><p>Output</p><p>For each test case, print the answer module 109+7 in one line.</p><p>Sample Input</p><p>3</p><p>1 2 1</p><p>2 3 1</p><p>3</p><p>1 2 1</p><p>1 3 2</p><p>Sample Output</p><p>16</p><p>24</p><p>题意：</p><p>首先给出一个含有n个节点的树，边权为距离。</p><p>对于1-n的某一种排列p1,p2,p3……pn，贡献为dis(p1,p2)+dis(p2,p3)+dis(p3,p4)+……+dis(pn-1,pn)</p><p>求所有排列的贡献和</p><p>题解：</p><p>一棵树n个结点n-1条边，所以任意两点之间都有最短距离。由于所有遍历方式可以看做n个结点的排列，而每次有直接关系的只有两点之间的距离，因此只需求出两点之间的距离在所有排列中一共出现多少次即可。</p><p>比如n=2时，两个点1,2，共有两种排列方式，即1,2,和2,1</p><p>n=3时，三个点1,2,3,其中1,2共有4种方法得到，即1,2,3,和2,1,3,和3,1,2,和3,2,1</p><p>n=4时，三个点1,2,3,4,其中1,2共有12种方法得到，即1,2,3,4,和1,2,4,3,和2,1,3,4,和2,1,4,3,和3,1,2,4,和3,2,1,4和4,1,2,3,和4,2,1,3,和3,4,1,2,和4,3,1,2,和3,4,2,1,和4,3,2,1,</p><p>n=jie[n-1]*（n-1）。</p><p>先用树状dp求出所有两两结点之间的距离之和，再乘以每条边在所有结点排列的n！方式中一共用到的次数。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll sum[maxn], n;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll jie[maxn];</span><br><span class="line">ll jie2[maxn];</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; tree[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    jie[2] = 2;</span><br><span class="line">    for(ll i = 3;i&lt;maxn;i++)&#123;</span><br><span class="line">        jie[i] = jie[i-1]*(i-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(ll cur, ll father)</span><br><span class="line">&#123;</span><br><span class="line">    sum[cur] = 1;</span><br><span class="line">    for(ll i = 0; i &lt; tree[cur].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll son = tree[cur][i].v;</span><br><span class="line">        ll len = tree[cur][i].w;</span><br><span class="line">        if(father == son)</span><br><span class="line">            continue;</span><br><span class="line">        dfs(son, cur);</span><br><span class="line">        sum[cur] += sum[son]%mod;</span><br><span class="line">        sum[cur]%=mod;</span><br><span class="line">        dp[cur] += (dp[son]%mod + (n-sum[son])%mod*sum[son]%mod * len%mod)%mod;</span><br><span class="line">        dp[cur]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll u, v, w;</span><br><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;=2)&#123;</span><br><span class="line">            if(n==1)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            printf(&quot;%lld\n&quot;, 2*w%mod);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(ll i = 0; i &lt; n; i++)</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for(ll i = 0; i &lt; n-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            u--,v--;</span><br><span class="line">            Edge t1, t2;</span><br><span class="line">            t1.v = v;</span><br><span class="line">            t1.w = w;</span><br><span class="line">            t2.v = u;</span><br><span class="line">            t2.w = w;</span><br><span class="line">            tree[u].push_back(t1);</span><br><span class="line">            tree[v].push_back(t2);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, -1);</span><br><span class="line">        printf(&quot;%lld\n&quot;, (dp[0]%mod)*jie[n]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tree-and-Permutation&quot;&gt;&lt;a href=&quot;#Tree-and-Permutation&quot; class=&quot;headerlink&quot; title=&quot;Tree and Permutation&quot;&gt;&lt;/a&gt;Tree and Permutation&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1004 Find Integer</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25/</id>
    <published>2018-08-25T13:03:04.000Z</published>
    <updated>2018-08-28T06:36:13.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Find-Integer"><a href="#Find-Integer" class="headerlink" title="Find Integer"></a>Find Integer</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0Special Judge</strong></p><p>Problem Description</p><p>people in USSS love math very much, and there is a famous math problem .<br>give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn.</p><p>Input</p><p>one line contains one integer T;(1≤T≤1000000)<br>next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000)</p><p>Output</p><p>print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);<br>else print two integers -1 -1 instead.</p><p>Sample Input</p><p>1 2 3</p><p>Sample Output</p><p>4 5</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>本题首先用到了费马大定理，即a^n+b^n≠c^n。(a,b,c∈Z，n&gt;2)</p><p>所以当n大于2或者n为0时直接输出-1,-1，当n=1时直接输出1,a+1。</p><p>当n=2时，输出勾股数。</p><p>首先a²+b²=c²，a²=c²-b²，a²=(c+b)(c-b)。</p><p>设x=c+b，y=c-b，则a²=xy。</p><p>c=(x+y)/2，b=(x-y)/2。</p><p>当然我的方法是通过打表求得勾股数，方法有点偏暴力，即枚举x，y，然后用公式看c，b是否在范围内且为整数，当然在枚举的时候少不了剪枝，不然肯定tle。</p><p>不过后来听说根据费马大定理奇偶数列法则可。直接推出式子。</p><p>打表代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll b,c;</span><br><span class="line">&#125;aa[40007];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(aa,0,sizeof(aa));</span><br><span class="line">    for(ll i = 3;i&lt;=40000;i++)&#123;</span><br><span class="line">        for(ll j = 1;j&lt;i;j++)&#123;</span><br><span class="line">            if(i*i%j==0)&#123;</span><br><span class="line">                ll x = j;</span><br><span class="line">                ll y = i*i/j;</span><br><span class="line">                if((x+y)%2==0)&#123;</span><br><span class="line">                    aa[i].c=(x+y)/2;</span><br><span class="line">                    aa[i].b=(y-x)/2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll a,b,c,n;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);</span><br><span class="line">        if(n&gt;2||n==0)&#123;</span><br><span class="line">            printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n==1)&#123;</span><br><span class="line">            printf(&quot;1 %lld\n&quot;,a+1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(aa[a].b)&#123;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,aa[a].b,aa[a].c);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;-1 -1\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0(1)代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b,c,n;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);</span><br><span class="line">        if(n&gt;2||n==0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;1 %lld\n&quot;,a+1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(a%2==1&amp;&amp;a&gt;1)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cc=(a-1)/2;</span><br><span class="line">                b=2*cc*(cc+1);</span><br><span class="line">                c=2*cc*(cc+1)+1;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,b,c);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(a%2==0&amp;&amp;a&gt;2)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cc=a/2;</span><br><span class="line">                b=cc*cc-1;</span><br><span class="line">                c=cc*cc+1;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,b,c);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推导过程："><a href="#推导过程：" class="headerlink" title="推导过程："></a>推导过程：</h2><p>a为任意情况</p><p>a² = c² - b²</p><p>a² = (c+b)(c-b)</p><p>a²  = a² * 1</p><p>c + b = a² </p><p>c - b = 1</p><p>c = (a²  + 1) / 2</p><p>b = (a²  - 1) / 2</p><p>a为偶数情况：</p><p>if(a² % 2 == 0)</p><p>a²  = a²/2 * 2</p><p>c + b = a²/2 </p><p>c - b = 2</p><p>c = a²/4 + 1</p><p>b =a²/4 - 1</p><p>证毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Find-Integer&quot;&gt;&lt;a href=&quot;#Find-Integer&quot; class=&quot;headerlink&quot; title=&quot;Find Integer&quot;&gt;&lt;/a&gt;Find Integer&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit: 2000/1000 
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
      <category term="费马大定理" scheme="http://qianyouyou.cn/tags/%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>8.23网络流专项训练题解</title>
    <link href="http://qianyouyou.cn/2018/08/23/2018-08-23/"/>
    <id>http://qianyouyou.cn/2018/08/23/2018-08-23/</id>
    <published>2018-08-23T08:02:47.000Z</published>
    <updated>2018-08-26T12:35:28.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-A-赛马"><a href="#问题-A-赛马" class="headerlink" title="问题 A: 赛马"></a>问题 A: 赛马</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 32  解决: 5<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1890" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1890&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1890&amp;getkey=A121ED5825" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1890" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>古有田忌赛马戏齐王，今有悠悠赛马虐渣渣。悠悠和他的小老弟渣渣每人有n匹马，每匹马都有一个评分，分数越高速度越快。现在渣渣不甘于当小老弟，随着赛马曲的想起，渣渣决定挑战悠悠，规则同田忌赛马。每胜一局得1分，每负一局减一分，赵神做裁判，悠悠为了捍卫自己的王者地位，决定出老千，问了赵神关于渣渣的赛马顺序，请问悠悠最高能得多少分。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>文件有多组测试样例，遇0为止。</p><p>首行一个整数n，n&lt;=1000;</p><p>第2行n个整数表示悠悠每匹马的分数。</p><p>第3行n个整数表示渣渣每匹马的分数。0&lt;=分数&lt;500;</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出悠悠最高分。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">192 173 71</span><br><span class="line">195 177 74</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">10 10</span><br><span class="line">2</span><br><span class="line">220 219</span><br><span class="line">222 218</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>水题，可以用网络流或者匹配，也可以用更简单的方法。</p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1890" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1890&amp;getkey=A121ED5825" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1890" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题贪心可解。贪心策略即田忌赛马的策略。第1步我们将我们最慢的马和对方最快的马进行比较，如果最慢的马比对方最慢的马快，那么我们就胜一局，然后返回第1步。反之我们进行第2步，继续拿我们最快的马和对方最快的马进行比较，如果获胜就胜一局，然后返回第1步。反之我们进行第3步，继续拿我们最慢的马和对方最快的马进行比较，这种情况下分为两种情况，一种是得分相等，另外一种是我方必败，必败得分减一，否则不变，然后我们再返回第1步。直到所有的马都结束为止，此时我们就得到了最高得分。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1007],b[1007];</span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">    break;</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        sort(b,b+n);</span><br><span class="line">        int s=0;</span><br><span class="line">        for(int i=0,j=0,k=n-1,l=n-1; i&lt;=k;)&#123;</span><br><span class="line">            if(a[i]&gt;b[j])</span><br><span class="line">            s++,i++,j++;</span><br><span class="line">            else if(a[k]&gt;b[l])</span><br><span class="line">            s++,k--,l--;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(a[i]&lt;b[l])</span><br><span class="line">                s--;</span><br><span class="line">                i++,l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-海上钢琴师"><a href="#问题-B-海上钢琴师" class="headerlink" title="问题 B: 海上钢琴师"></a>问题 B: 海上钢琴师</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1894" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1894&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1894&amp;getkey=93904EDF34" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1894" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>宁愿一生孤独，不愿随波逐流。海上钢琴师毅然留在了船上，与大海为伴，此生再不上岸。</p><p>然而，他的音乐却已名扬四海。为了将他的钢琴声可以传播到陆地以便欣赏，人们决定在陆地与钢琴师所在的船之间的n-2座岛屿上建立声音保留设备。每当声音传到该设备处时，以该设备为起点可以将声音信号发送到其他与该设备有信号连接的设备那里。信号传播是单向的，且是有限的。当该设备将一部分信号传给其他设备时，该设备所拥有的总信号要减去相应传出去的信号，所保留的信号可以继续传给其他的设备。船上也有该设备，由于岛屿与船的位置不同，所以钢琴声传到设备的声音有限。设备与设备之间的传播分贝也有限。陆地的总接收设备与某些岛屿上的设备有信号连接，请问陆地最多能收到多少分贝的钢琴声。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>第一行输入两个数m，n。m代表共有m对设备建立了单向连接。n代表包括船和陆地在内共有n个设备。编号1为船，编号n为陆地，其他为岛屿（n&lt;=100，m&lt;=1000）</p><p>接下来m行，每行三个数a，b，c，代表a-&gt;b，即a的信号可以传到b信号，最大可以通过该信号传送c分贝。c&lt;=2000</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出陆地上最大可以收到多少分贝声音。（海上钢琴声不超过10000分贝）</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2 100</span><br><span class="line">1 3 50</span><br><span class="line">2 3 2</span><br><span class="line">3 4 60</span><br><span class="line">2 4 99</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">150</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>样例解释：（容量，流量）</p><p>方案1：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180822/20180822133414_80763.png" alt="img"></p><p>方案2：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180822/20180822133437_68424.png" alt="img"></p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1894" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1894&amp;getkey=93904EDF34" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1894" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>网络流最大流模板题。题面转化过来就是一个网络流模型，船为s，陆地为t，设备之间的连接就是弧。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(1,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-进击的巨人"><a href="#问题-C-进击的巨人" class="headerlink" title="问题 C: 进击的巨人"></a>问题 C: 进击的巨人</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1895" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1895&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1895&amp;getkey=DF84EFB393" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1895" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>那一年，巨人发起了第一轮进击，s城破，埃尔文团长带领众居民计划逃往较安全的t城。从s城到t城之间共有m坐城市，某些城市之间构成单向通路。由s城到t城恰构成一个有向无环图。然而每条路上都有限定的最大人流量。埃尔文团长想知道每一次最多有多少居民能到达t城。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>首行输入两个数n，m（n，m&lt;=100），n0为s城，nn为t城。s城到t城之间的城用n1——nn表示。m表示单项通道数。</p><p>接下来m行，每行三个数a，b，c，代表a到b的最大人流量是c。c&lt;1000。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出最多有多少人到t</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6 14</span><br><span class="line">0 2 5</span><br><span class="line">0 1 10</span><br><span class="line">1 2 6</span><br><span class="line">0 3 5</span><br><span class="line">3 1 2</span><br><span class="line">1 5 3</span><br><span class="line">5 2 3</span><br><span class="line">5 4 3</span><br><span class="line">3 5 3</span><br><span class="line">3 4 4</span><br><span class="line">3 6 5</span><br><span class="line">2 6 6</span><br><span class="line">4 6 10</span><br><span class="line">2 4 4</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1895" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1895&amp;getkey=DF84EFB393" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1895" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>网络流最大流模板题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-X档案"><a href="#问题-D-X档案" class="headerlink" title="问题 D: X档案"></a>问题 D: X档案</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 5  解决: 3<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1883" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1883&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1883&amp;getkey=B46583A0E8" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1883" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>据X档案记载，倘若外星文明即将攻击地球，会在战争之前发动病毒袭击，最合理的对象是鸟或狗，因为鸟在空中传播病毒的范围2较广，而狗相较于其他动物来说和人类接触最频繁。X城作为全球反外星文明的重要基地，对外星文明来说威胁最大而作为外星文明首先攻击的目标。因此，X长官下令捕杀了全城的鸟，而狗由于受到爱狗人士们的保护免于此劫。然而灾难还是降临了，外星文明悄无声息地将病毒注入到一些狗体内。据全球卫星显示，X城的地形是一个n<em>m的矩阵，划分成了n</em>m个1<em>1的小矩阵。矩阵的四周被城墙所围。而在某些单位1</em>1的小矩阵中有居民，或者有被感染的狗。我们已经知道了狗的全部坐标，为了安全起见，X长官启动了X计划，将这些狗在未发作之前用围栏隔离起来以防止狗攻击人类，每个1*1的小矩阵四周均可建立围栏。该计划收录到了X档案中。围栏使得狗和人类均无法通过。由于计划的机密性，长官不想动用太多的财力，现求最少需要多长围栏才能将所有狗隔离。</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组样例，读到文件结束。</p><p>第一行为n，m，代表n*m的矩阵。（0&lt;n，m&lt;=150）</p><p>接下来n行，每行m个由0，1，2组成的数。</p><p>0代表此处没有任何东西，1代表此处有人，2代表此处有被感染的狗。</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出格式为：Case i: k</p><p>i为第i组样例，k为所需最短的围栏长度。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">2 0 0 0 0 1</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line">0 0 2 0 0 1</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">4 6</span><br><span class="line">0 0 1 0 0 1</span><br><span class="line">0 0 0 1 1 0</span><br><span class="line">0 0 0 0 2 2</span><br><span class="line">0 1 1 0 2 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 6</span><br><span class="line">Case 2: 4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>第1组样例解释：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180821/20180821210755_92707.png" alt="img"> </p><p>第2组样例解释：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180821/20180821211137_35539.png" alt="img"> </p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1883" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1883&amp;getkey=B46583A0E8" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1883" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>题目描述那么多，其实就是最小割问题。只不过我们要建立一个超级源点指向所有狼（羊），再建立一个超级汇点指向所有羊（狼）。羊和狼为结点，两个节点直接一条边，权值为1。最终求解最大流即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 100100</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int to[maxn],c[maxn],first[maxn],Next[maxn],N;</span><br><span class="line">int d[maxn];</span><br><span class="line">int Q[maxn],bot,top,tag[maxn],can[maxn];</span><br><span class="line">int s,t,n,m,tmp,ans,cas=0;</span><br><span class="line">int TAG=5201314;</span><br><span class="line">void _init()</span><br><span class="line">&#123;</span><br><span class="line">    ans=s=0,t=n*m+1,N=-1;</span><br><span class="line">    for (int i=s; i&lt;=t; i++) first[i]=-1;</span><br><span class="line">&#125;</span><br><span class="line">void edge(int U,int V,int W)</span><br><span class="line">&#123;</span><br><span class="line">    N++;</span><br><span class="line">    to[N]=V,c[N]=W;</span><br><span class="line">    Next[N]=first[U],first[U]=N;</span><br><span class="line">&#125;</span><br><span class="line">void _input()</span><br><span class="line">&#123;</span><br><span class="line">    int cur=0;</span><br><span class="line">    for (int i=1; i&lt;=n; i++)</span><br><span class="line">        for (int j=1; j&lt;=m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);</span><br><span class="line">            cur++;</span><br><span class="line">            if (i&lt;n) edge(cur,cur+m,1),edge(cur+m,cur,1);</span><br><span class="line">            if (j&lt;m) edge(cur,cur+1,1),edge(cur+1,cur,1);</span><br><span class="line">            if (tmp==2) edge(s,cur,inf),edge(cur,s,inf);</span><br><span class="line">                else if (tmp==1) edge(cur,t,inf),edge(t,cur,inf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    TAG++;</span><br><span class="line">    Q[bot=top=1]=t,d[t]=0,tag[t]=TAG;</span><br><span class="line">    while (bot&lt;=top)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=Q[bot++];</span><br><span class="line">        for (int i=first[cur]; i!=-1; i=Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (c[i^1]&lt;=0 || tag[to[i]]==TAG) continue;</span><br><span class="line">            tag[to[i]]=TAG,d[to[i]]=d[cur]+1,Q[++top]=to[i];</span><br><span class="line">            if (to[i]==s) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int cur,int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (cur==t) return num;</span><br><span class="line">    int tmp=num,k;</span><br><span class="line">    for (int i=first[cur]; i!=-1; i=Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        if (d[cur]!=d[to[i]]+1 || c[i]&lt;=0 || tag[to[i]]!=TAG || can[to[i]]==TAG) continue;</span><br><span class="line">        k=dfs(to[i],min(num,c[i]));</span><br><span class="line">        if (k) c[i]-=k,c[i^1]+=k,num-=k;</span><br><span class="line">        if (num==0) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num) can[cur]=TAG;</span><br><span class="line">    return tmp-num;</span><br><span class="line">&#125;</span><br><span class="line">void dinic()&#123;</span><br><span class="line">    while (bfs())</span><br><span class="line">    ans+=dfs(s,inf);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        _init();</span><br><span class="line">        _input();</span><br><span class="line">        dinic();</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;,++cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-同桌的你"><a href="#问题-E-同桌的你" class="headerlink" title="问题 E: 同桌的你"></a>问题 E: 同桌的你</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1892" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1892&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1892&amp;getkey=FA65543DBF" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1892" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>据yoyo统计，青春期的情侣80%都是曾经的同桌。因此，选择好的同桌对你日后的感情发展有很大的帮助。高一7班共有n个男生，m个女生，男生们听过分析后纷纷要求重新排座位，以期待和心仪的女生做同桌。每个男生都有自己的暗恋对象，0&lt;=暗恋对象的个数&lt;=m，也就是说某个男生最多暗恋全班女生，最少一个都不暗恋。汪老师知道这件事后很是重视，于是开始调座位，优先考虑男生和他的暗恋女生坐在一起。男生用a表示，女生用n表示。请问最多有多少男生能和自己心仪的对象坐在一起。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>首行输入n，m，e（0&lt;n，m&lt;=1000，0&lt;=e&lt;=10000）n男m女e为所有男生暗恋女生的个数之和。</p><p>接下来e行，每行两个数i，j，代表ai男生暗恋bj女生。</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>一个整数，最优分配下最多有多少男生能和自己心仪的对象坐在一起。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1 2</span><br><span class="line">2 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>样例解释：</p><p>全班两个男生暗恋班里唯一一个女生，无论怎么分配只能凑成一对。</p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1892" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1892&amp;getkey=FA65543DBF" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1892" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>二分图最大匹配问题。男生和女生构成二分图，每个男生和暗恋的女生之间建立一条边。由于不涉及到权值，因此可用匈牙利算法求解，当然也可用网络流求解。网络流的话就是在二分图的两部分分别建立超级源点s和超级汇点t，每条边的容量固定是1，然后此题就转化成了网络流问题。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int cnt=2;</span><br><span class="line">int alist[6000001];</span><br><span class="line">struct data&#123;</span><br><span class="line">    int v;int next;int value;</span><br><span class="line">&#125;edge[6000001];</span><br><span class="line">void add(int u,int v,int value)</span><br><span class="line">&#123;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].value=value;</span><br><span class="line">    edge[cnt].next=alist[u];</span><br><span class="line">    alist[u]=cnt++;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int h[1000001];</span><br><span class="line">int q[1000001];</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int x,next;</span><br><span class="line">    memset(h,-1,sizeof(h));</span><br><span class="line">    int head=0,tail=1;</span><br><span class="line">    q[head]=1;</span><br><span class="line">    h[1]=0;</span><br><span class="line">    while(head&lt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        x=q[head++];</span><br><span class="line">        next=alist[x];</span><br><span class="line">        while(next)</span><br><span class="line">        &#123;</span><br><span class="line">            int v=edge[next].v;</span><br><span class="line">            int value=edge[next].value;</span><br><span class="line">            if(value&amp;&amp;h[v]&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                q[tail++]=v;</span><br><span class="line">                h[v]=h[x]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            next=edge[next].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(h[n]==-1) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int ans;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==n) return y;</span><br><span class="line">    int next=alist[x];</span><br><span class="line">    int w,used=0;</span><br><span class="line">    while(next)</span><br><span class="line">    &#123;</span><br><span class="line">        int v=edge[next].v;</span><br><span class="line">        int value=edge[next].value;</span><br><span class="line">        if(value&amp;&amp;h[v]==h[x]+1)</span><br><span class="line">        &#123;</span><br><span class="line">                w=y-used;</span><br><span class="line">                w=dfs(v,min(w,value));</span><br><span class="line">                edge[next].value-=w;</span><br><span class="line">                edge[next^1].value+=w;</span><br><span class="line">                used+=w;</span><br><span class="line">                if(used==y) return y;</span><br><span class="line">        &#125;</span><br><span class="line">        next=edge[next].next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!used) h[x]=-1;</span><br><span class="line">    return used;</span><br><span class="line">&#125;</span><br><span class="line">void dinic()</span><br><span class="line">&#123;</span><br><span class="line">    while(bfs()) ans+=dfs(1,0x7fffffff);</span><br><span class="line">&#125;</span><br><span class="line">int n1,m1,e1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;m1,&amp;e1);</span><br><span class="line">    n=n1+m1+2;</span><br><span class="line">    for(int i=1;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(1,i+1,1);</span><br><span class="line">        add(i+1,1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=e1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        if(u&lt;=n1&amp;&amp;v&lt;=m1)</span><br><span class="line">        add(u+1,v+n1+1,1),</span><br><span class="line">        add(v+n1+1,u+1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i+n1+1,n,1);</span><br><span class="line">        add(n,i+n1+1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    dinic();//暴力跑最大流</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-奇迹暖暖"><a href="#问题-F-奇迹暖暖" class="headerlink" title="问题 F: 奇迹暖暖"></a>问题 F: 奇迹暖暖</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1893" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1893&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1893&amp;getkey=5F0E1E84F3" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1893" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>梅拉抢走了绫罗的设计图，暖暖决定帮绫罗抢过来。于是梅拉和暖暖开始了搭配比赛。梅拉和暖暖各有n套衣服。由于暖暖是天才服装搭配师，且自带主角光环，又怎会输呢，（废话，输了你怎么通关啊）只不过暖暖为了让梅拉输的心服口服，决定狠狠虐梅拉一把。针对梅拉的n套衣服，暖暖的每套衣服i得分都比梅拉的任意一套衣服j得分高出score(ij)，0&lt;=score(ij)&lt;100000。然而每比完一场，他们之后的比赛都不能再用这套的衣服了。所以对于n场比赛，求出暖暖最高能比梅拉高多少分？（至少为0）</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>首行输入n(n&lt;=300)</p><p>接下来n行，第i行表示暖暖的第i套衣服，每行n个数，第j个数表示暖暖第i套衣服比梅拉第j套衣服的分高多少分。</p><p>0&lt;=score(ij)&lt;100000</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，即最高高出多少分</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">100 5</span><br><span class="line">20 23</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1893" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1893&amp;getkey=5F0E1E84F3" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1893" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>最大权二分图匹配。暖暖和梅拉构成二分图。每条边均有权值，最终求解二分匹配下的最大权值。二分图匹配除了网络流以外还有两道专门解二分图的算法，即匈牙利算法和KM算法。匈牙利算法一般解决二分图最大匹配问题，即边没有权值。而km算法一般解决有权值的二分图。本题为KM算法模板题。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=300+7;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int n,nx,ny;</span><br><span class="line">int linker[N],lx[N],ly[N],slack[N];</span><br><span class="line">int visx[N],visy[N],w[N][N];</span><br><span class="line"></span><br><span class="line">int DFS(int x)&#123;</span><br><span class="line">    visx[x]=1;</span><br><span class="line">    for(int y=1;y&lt;=ny;y++)&#123;</span><br><span class="line">        if(visy[y])</span><br><span class="line">            continue;</span><br><span class="line">        int tmp=lx[x]+ly[y]-w[x][y];</span><br><span class="line">        if(tmp==0)&#123;</span><br><span class="line">            visy[y]=1;</span><br><span class="line">            if(linker[y]==-1 || DFS(linker[y]))&#123;</span><br><span class="line">                linker[y]=x;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(slack[y]&gt;tmp)&#123;</span><br><span class="line">            slack[y]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int KM()&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    memset(linker,-1,sizeof(linker));</span><br><span class="line">    memset(ly,0,sizeof(ly));</span><br><span class="line">    for(i=1;i&lt;=nx;i++)      //lx初始化为与它关联边中最大的</span><br><span class="line">        for(j=1,lx[i]=-INF;j&lt;=ny;j++)</span><br><span class="line">            if(w[i][j]&gt;lx[i])</span><br><span class="line">                lx[i]=w[i][j];</span><br><span class="line">    for(int x=1;x&lt;=nx;x++)&#123;</span><br><span class="line">        for(i=1;i&lt;=ny;i++)</span><br><span class="line">            slack[i]=INF;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            memset(visx,0,sizeof(visx));</span><br><span class="line">            memset(visy,0,sizeof(visy));</span><br><span class="line">            if(DFS(x))  //若成功（找到了增广轨），则该点增广完成，进入下一个点的增广</span><br><span class="line">                break;  //若失败（没有找到增广轨），则需要改变一些点的标号，使得图中可行边的数量增加。</span><br><span class="line">                        //方法为：将所有在增广轨中（就是在增广过程中遍历到）的X方点的标号全部减去一个常数d，</span><br><span class="line">                        //所有在增广轨中的Y方点的标号全部加上一个常数d</span><br><span class="line">            int d=INF;</span><br><span class="line">            for(i=1;i&lt;=ny;i++)</span><br><span class="line">                if(!visy[i] &amp;&amp; d&gt;slack[i])</span><br><span class="line">                    d=slack[i];</span><br><span class="line">            for(i=1;i&lt;=nx;i++)</span><br><span class="line">                if(visx[i])</span><br><span class="line">                    lx[i]-=d;</span><br><span class="line">            for(i=1;i&lt;=ny;i++)  //修改顶标后，要把所有不在交错树中的Y顶点的slack值都减去d</span><br><span class="line">                if(visy[i])</span><br><span class="line">                    ly[i]+=d;</span><br><span class="line">                else</span><br><span class="line">                    slack[i]-=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(i=1;i&lt;=ny;i++)</span><br><span class="line">        if(linker[i]!=-1)</span><br><span class="line">            res+=w[linker[i]][i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        nx=ny=n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=n;j++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;w[i][j]);</span><br><span class="line">        int ans=KM();</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-巨人也疯狂"><a href="#问题-G-巨人也疯狂" class="headerlink" title="问题 G: 巨人也疯狂"></a>问题 G: 巨人也疯狂</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1896" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1896&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1896&amp;getkey=53D9617A4C" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1896" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>人类发现巨人控制吃人的神经是由一些神经元和一些神经通道组成的，每个神经通道两端各有一个神经元，且这个通道是单向的。吃人信号从脑部神经元S发出到控制吃人的神经元T，S、T之间是一个有向无环图。人类想把某些神经通道切断达到S的信号无法传到T（由于神经元太小不容易砍掉，所以考虑神经元），每个神经通道由于位置不同也有砍断所需的力量。人类想知道如何花最小的力气而使S的信号传不到T。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>首行输入两个数，n，m，（n，m&lt;1000）。n代表包括s，t在内共有n个节点，1为s，n为t。</p><p>接下来m行，每行3个数，a，b，c，表示a到b的神经通路需要花费c力气。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出最小的力气。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">1 2 2</span><br><span class="line">1 3 2</span><br><span class="line">2 4 2</span><br><span class="line">2 5 2</span><br><span class="line">3 5 2</span><br><span class="line">4 6 2</span><br><span class="line">6 7 2</span><br><span class="line">5 7 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1896" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1896&amp;getkey=53D9617A4C" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1896" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>网络流最小割模板题。根据最小割最大流定理，求最小割问题即求最大流问题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-H-过河拆桥"><a href="#问题-H-过河拆桥" class="headerlink" title="问题 H: 过河拆桥"></a>问题 H: 过河拆桥</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1891" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1891&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1891&amp;getkey=EC9961F440" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1891" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>猴子是一种自私的动物。动物世界由河流分成了n个岛屿。这天，猴子在a1岛屿上望见an岛屿上有一片桃林。a1到an之间有n-2个岛屿，分别是a2——an-1。岛屿之间共有m坐桥，每座桥都有一定的距离。现在猴子通过这些桥从a1走到了an，然而由于猴子怕其他动物也过去享受那片桃林，于是每走一座桥都会拆一座桥。终于到了an，吃完桃子后，正直涨潮，于是他必须马上回到a1，由于之前走过的桥被拆了，所以只能寻找一条新的路回到a1。请问猴子从a1到an，再从an回到a1的最短路径是多少。</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>首行输入nm（n&lt;=1000m&lt;=10000）</p><p>接下来m行，每行三个数x，y，z，代表ax岛与ay岛之间有桥，距离是z。（z&lt;=35000）</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，为最短距离。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 3 1</span><br><span class="line">2 4 2</span><br><span class="line">1 2 1</span><br><span class="line">3 4 1</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1891" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1891&amp;getkey=EC9961F440" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1891" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>最小费用最大流问题。本题可以转化为从1到n找两条不重边的路，使得这两条路的距离之和加起来相对于其他方案来说最小。转化成功之后就是建模过程。首先以1为源点，n为汇点。边的长度就是每条边的费用，每条边的容量为1。由于我们要找两条路到达t，那么我们s点的流量就必须是2，这样流到t点的最大流最大为2，为1证明无解，为2即有解。然而由于源点流量一般无限大，那么我们只需再建立一个超级源点sss，和源点s相连，且容量为2，当然sss到s的费用为0。建完模之后我们就可以用最小费用最大流模板代码求解了。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,cap,cost ,rev;</span><br><span class="line">&#125;;</span><br><span class="line">int V;</span><br><span class="line">vector&lt;edge&gt;G[maxn];</span><br><span class="line">int dist[maxn];</span><br><span class="line">int prevv[maxn],preve[maxn];</span><br><span class="line">void add(int from,int to,int cap,int cost)</span><br><span class="line">&#123;</span><br><span class="line">    edge e,w;</span><br><span class="line">    e.to=to;</span><br><span class="line">    e.cap=cap;</span><br><span class="line">    e.cost=cost;</span><br><span class="line">    e.rev=G[to].size();</span><br><span class="line">    G[from].push_back(e);</span><br><span class="line">    w.to=from;</span><br><span class="line">    w.cap=0;</span><br><span class="line">    w.cost=-cost;</span><br><span class="line">    w.rev=G[from].size()-1;</span><br><span class="line">    G[to].push_back(w);</span><br><span class="line">&#125;</span><br><span class="line">int min_ans(int s,int t,int f)</span><br><span class="line">&#123;</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    while(f&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;V; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[s]=0;</span><br><span class="line">        bool update=true;</span><br><span class="line">        while(update)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            update=false;</span><br><span class="line">            for(int v=0; v&lt;V; v++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(dist[v]==inf)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int i=0; i&lt;G[v].size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    edge &amp;e=G[v][i];</span><br><span class="line">                    if(e.cap&gt;0&amp;&amp;dist[e.to]&gt;dist[v]+e.cost)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[e.to]=dist[v]+e.cost;</span><br><span class="line">                        prevv[e.to]=v;</span><br><span class="line">                        preve[e.to]=i;</span><br><span class="line">                        update=true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dist[t]==inf)</span><br><span class="line">            return -1;</span><br><span class="line">        int d=f;</span><br><span class="line">        for(int v=t; v!=s; v=prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d=min(d,G[prevv[v]][preve[v]].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f-=d;</span><br><span class="line">        res+=d*dist[t];</span><br><span class="line">        for(int v=t; v!=s; v=prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e =G[prevv[v]][preve[v]];</span><br><span class="line">            e.cap-=d;</span><br><span class="line">            G[v][e.rev].cap+=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int N,M;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int a,b,c;</span><br><span class="line">    while(cin&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        V=N;</span><br><span class="line">        for(int i=0; i&lt;=N; i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        for(int i=0; i&lt;M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            a--;</span><br><span class="line">            b--;</span><br><span class="line">            add(a,b,1,c);</span><br><span class="line">            add(b,a,1,c);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,min_ans(0,N-1,2));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-I-植物大战僵尸"><a href="#问题-I-植物大战僵尸" class="headerlink" title="问题 I: 植物大战僵尸"></a>问题 I: 植物大战僵尸</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1889" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1889&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1889&amp;getkey=31996BAC1B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1889" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和Zombies（僵尸）是游戏的主角，其中Plants防守，而Zombies进攻。该款游戏包含多种不同的挑战系列，比如Protect Your Brain、Bowling等等。其中最为经典的，莫过于玩家通过控制Plants来防守Zombies的进攻，或者相反地由玩家通过控制Zombies对Plants发起进攻。</p><p>现在，我们将要考虑的问题是游戏中Zombies对Plants的进攻，请注意，本题中规则与实际游戏有所不同。游戏中有两种角色，Plants和Zombies，每个Plant有一个攻击位置集合，它可以对这些位置进行保护；而Zombie进攻植物的方式是走到植物所在的位置上并将其吃掉。</p><p>游戏的地图可以抽象为一个N行M列的矩阵，行从上到下用0到N–1编号，列从左到右用0到M–1编号；在地图的每个位置上都放有一个Plant，为简单起见，我们把位于第r行第c列的植物记为Pr c。</p><p>Plants分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个Plant，定义Score和Attack如下：</p><p>Score[Pr c]</p><p>Zombie击溃植物Pr c可获得的能源。若Score[Pr c]为非负整数，则表示击溃植物Pr c可获得能源Score[Pr c]，若为负数表示击溃Pr c需要付出能源 -Score[Pr c]。</p><p>Attack[Pr c]</p><p>植物Pr c能够对Zombie进行攻击的位置集合。</p><p>Zombies必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此Zombies的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻，Zombies必须首先攻击Pr M-1；若需要对Pr c（0≤c&lt;M-1）攻击，必须将PrM-1 Pr M-2 … Pr c+1先击溃，并移动到位置(r c)才可进行攻击。</p><p>在本题的设定中，Plants的攻击力是无穷大的，一旦Zombie进入某个Plant的攻击位置，该Zombie会被瞬间消灭，而该Zombie没有时间进行任何攻击操作。因此，即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。</p><p>Zombies的目标是对Plants的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套Zombies的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。</p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含两个整数N M，分别表示地图的行数和列数。</p><p>接下来N×M行描述每个位置上植物的信息。第r×M + c + 1行按照如下格式给出植物Pr c的信息：第一个整数为Score[Pr c] 第二个整数为集合Attack[Pr c]中的位置个数w，接下来w个位置信息（r’ c’），表示Pr c可以攻击位置第r’ 行第c’ 列。</p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>输出仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为0。</p><h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">10 0</span><br><span class="line">20 0</span><br><span class="line">-10 0</span><br><span class="line">-5 1 0 0</span><br><span class="line">100 1 2 1</span><br><span class="line">100 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1889" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1889&amp;getkey=31996BAC1B" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1889" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>最大权闭合图问题。最大权闭合图转化为最小割问题，再由最小割转化成最大流问题。课件上有详解。</p><p>（本题作为NOI的考试题，同时也是今天十道题中最难的一道题，是不是顿时感觉到了自己与高中生们的差距(ó﹏ò｡)ε=(´ο｀*)))唉）</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">#define M 1000</span><br><span class="line">using namespace std;</span><br><span class="line">int now,tot,s,t,va[M],du[M],H[M],h[M],ok[M],d[M],v[M],cur[M];</span><br><span class="line">int n,m;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">struct edge1</span><br><span class="line">&#123;</span><br><span class="line">int x,y,ne;</span><br><span class="line">&#125;e[500000];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">int from,to,cap,flow,ne;</span><br><span class="line">&#125;E[500000];</span><br><span class="line">int C(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">return (x-1)*m+y;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">e[++tot].y=y;</span><br><span class="line">e[tot].x=x;</span><br><span class="line">e[tot].ne=H[x];</span><br><span class="line">H[x]=tot;</span><br><span class="line">du[y]++;</span><br><span class="line">&#125;</span><br><span class="line">void Addedge(int from,int to,int cap)</span><br><span class="line">&#123;</span><br><span class="line">E[++tot]=(edge)&#123;from,to,cap,0,h[from]&#125;;</span><br><span class="line">h[from]=tot;</span><br><span class="line">E[++tot]=(edge)&#123;to,from,0,0,h[to]&#125;;</span><br><span class="line">h[to]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">for (int i=s;i&lt;=t;i++)</span><br><span class="line">v[i]=0;</span><br><span class="line">v[s]=1;</span><br><span class="line">d[s]=0;</span><br><span class="line">q.push(s);</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for (int i=h[x];i;i=E[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">edge e=E[i];</span><br><span class="line">if (!v[e.to]&amp;&amp;e.cap&gt;e.flow)</span><br><span class="line">&#123;</span><br><span class="line">v[e.to]=1;</span><br><span class="line">d[e.to]=d[x]+1;</span><br><span class="line">q.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return v[t];</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int x,int a)</span><br><span class="line">&#123;</span><br><span class="line">if (x==t||!a) return a;</span><br><span class="line">int flow=0;</span><br><span class="line">for (int &amp;i=cur[x];i;i=E[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e=E[i];</span><br><span class="line">if (d[e.to]!=d[x]+1) continue;</span><br><span class="line">int f=dfs(e.to,min(a,e.cap-e.flow));</span><br><span class="line">if (f)</span><br><span class="line">&#123;</span><br><span class="line">flow+=f;</span><br><span class="line">a-=f;</span><br><span class="line">e.flow+=f;</span><br><span class="line">E[i^1].flow-=f;</span><br><span class="line">if (!a) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">int flow=0;</span><br><span class="line">while (bfs())</span><br><span class="line">&#123;</span><br><span class="line">for (int i=s;i&lt;=t;i++)</span><br><span class="line">cur[i]=h[i];</span><br><span class="line">flow+=dfs(s,inf);</span><br><span class="line">&#125;</span><br><span class="line">return flow;</span><br><span class="line">&#125;</span><br><span class="line">void Topsort()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for (int i=1;i&lt;=now;i++)</span><br><span class="line">if (!du[i]) ok[i]=1,q.push(i);</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for (int i=H[x];i;i=e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">int y=e[i].y;</span><br><span class="line">du[y]--;</span><br><span class="line">if (!du[y])</span><br><span class="line">&#123;</span><br><span class="line">ok[y]=1;</span><br><span class="line">q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">for (int i=1;i&lt;=n;i++)</span><br><span class="line">for (int j=1;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">now++;</span><br><span class="line">int w;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;va[now],&amp;w);</span><br><span class="line">for (int k=1;k&lt;=w;k++)</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">x++,y++;</span><br><span class="line">Add(now,C(x,y));</span><br><span class="line">&#125;</span><br><span class="line">if (j!=m) Add(now+1,now);</span><br><span class="line">&#125;</span><br><span class="line">Topsort();</span><br><span class="line">s=0,t=now+1;</span><br><span class="line">int ans=0;</span><br><span class="line">tot=1;</span><br><span class="line">for (int x=1;x&lt;=now;x++)</span><br><span class="line">if (ok[x])</span><br><span class="line">&#123;</span><br><span class="line">if (va[x]&gt;0) ans+=va[x],Addedge(s,x,va[x]);</span><br><span class="line">else Addedge(x,t,-va[x]);</span><br><span class="line">for (int i=H[x];i;i=e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">int y=e[i].y;</span><br><span class="line">if (ok[y])</span><br><span class="line">Addedge(y,x,inf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans-dinic()&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-J-Pigs"><a href="#问题-J-Pigs" class="headerlink" title="问题 J: Pigs"></a>问题 J: Pigs</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=9&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1887" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1887&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1887&amp;getkey=874A405F35" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1887" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>Mirko works on a pig farm that consists of M locked pig-houses and Mirko can’t unlock any pighouse because he doesn’t have the keys. Customers come to the farm one after another. Each of them has keys to some pig-houses and wants to buy a certain number of pigs.<br>All data concerning customers planning to visit the farm on that particular day are available to Mirko early in the morning so that he can make a sales-plan in order to maximize the number of pigs sold.<br>More precisely the procedure is as following: the customer arrives opens all pig-houses to which he has the key Mirko sells a certain number of pigs from all the unlocked pig-houses to him and if Mirko wants he can redistribute the remaining pigs across the unlocked pig-houses.<br>An unlimited number of pigs can be placed in every pig-house.<br>Write a program that will find the maximum number of pigs that he can sell on that day.</p><h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>The first line of input contains two integers M and N 1 &lt;= M &lt;= 1000 1 &lt;= N &lt;= 100 number of pighouses and number of customers. Pig houses are numbered from 1 to M and customers are numbered from 1 to N.<br>The next line contains M integeres for each pig-house initial number of pigs. The number of pigs in each pig-house is greater or equal to 0 and less or equal to 1000.<br>The next N lines contains records about the customers in the following form ( record about the i-th customer is written in the (i+2)-th line):<br>A K1 K2 … KA B It means that this customer has key to the pig-houses marked with the numbers K1 K2 … KA (sorted nondecreasingly ) and that he wants to buy B pigs. Numbers A and B can be equal to 0.</p><h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>The first and only line of the output should contain the number of sold pigs.</p><h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">3 1 10</span><br><span class="line">2 1 2 2</span><br><span class="line">2 1 3 3</span><br><span class="line">1 2 6</span><br></pre></td></tr></table></figure><h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=9&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1887" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1887&amp;getkey=874A405F35" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1887" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>课件上有建模讲解。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=107,M=1007,INF=0x3f3f3f3f;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char c=getchar();int x=0,f=1;</span><br><span class="line">    while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-1; c=getchar();&#125;</span><br><span class="line">    while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;; c=getchar();&#125;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int m,n,s,t;</span><br><span class="line">int pig[M],now[M];</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int v,c,f,ne;</span><br><span class="line">&#125;e[N*M&lt;&lt;1];</span><br><span class="line">int cnt,h[N];</span><br><span class="line">inline void ins(int u,int v,int c)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v=v;e[cnt].c=c;e[cnt].f=0;e[cnt].ne=h[u];h[u]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v=u;e[cnt].c=0;e[cnt].f=0;e[cnt].ne=h[v];h[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">int q[N],head,tail,vis[N],d[N];</span><br><span class="line">bool bfs()&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(d,0,sizeof(d));</span><br><span class="line">    head=tail=1;</span><br><span class="line">    d[s]=0;vis[s]=1;</span><br><span class="line">    q[tail++]=s;</span><br><span class="line">    while(head!=tail)&#123;</span><br><span class="line">        int u=q[head++];</span><br><span class="line">        for(int i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">            int v=e[i].v;</span><br><span class="line">            if(!vis[v]&amp;&amp;e[i].c&gt;e[i].f)&#123;</span><br><span class="line">                vis[v]=1;</span><br><span class="line">                d[v]=d[u]+1;</span><br><span class="line">                q[tail++]=v;</span><br><span class="line">                if(v==t) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int cur[N];</span><br><span class="line">int dfs(int u,int a)&#123;</span><br><span class="line">    if(u==t||a==0) return a;</span><br><span class="line">    int flow=0,f;</span><br><span class="line">    for(int &amp;i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">        int v=e[i].v;</span><br><span class="line">        if(d[v]==d[u]+1&amp;&amp;(f=dfs(v,min(a,e[i].c-e[i].f)))&gt;0)&#123;</span><br><span class="line">            flow+=f;</span><br><span class="line">            e[i].f+=f;</span><br><span class="line">            e[((i-1)^1)+1].f-=f;</span><br><span class="line">            a-=f;</span><br><span class="line">            if(a==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int flow=0;</span><br><span class="line">    while(bfs())&#123;</span><br><span class="line">        for(int i=s;i&lt;=t;i++) cur[i]=h[i];</span><br><span class="line">        flow+=dfs(s,INF);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    m=read();</span><br><span class="line">    n=read();</span><br><span class="line">    s=0;</span><br><span class="line">    t=n+1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    pig[i]=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int A=read(),B,x;</span><br><span class="line">        while(A--)&#123;</span><br><span class="line">            x=read();</span><br><span class="line">            if(!now[x]) ins(s,i,pig[x]),now[x]=i;</span><br><span class="line">            else ins(now[x],i,INF),now[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        B=read();</span><br><span class="line">        ins(i,t,B);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,dinic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题-A-赛马&quot;&gt;&lt;a href=&quot;#问题-A-赛马&quot; class=&quot;headerlink&quot; title=&quot;问题 A: 赛马&quot;&gt;&lt;/a&gt;问题 A: 赛马&lt;/h1&gt;&lt;p&gt;时间限制: 1 Sec  内存限制: 128 MB&lt;br&gt;提交: 32  解决: 5&lt;br&gt;[&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分图" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="匹配" scheme="http://qianyouyou.cn/tags/%E5%8C%B9%E9%85%8D/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="最小费用最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>进击的网络流</title>
    <link href="http://qianyouyou.cn/2018/08/22/2018-08-22/"/>
    <id>http://qianyouyou.cn/2018/08/22/2018-08-22/</id>
    <published>2018-08-22T12:38:54.000Z</published>
    <updated>2018-08-26T12:35:40.102Z</updated>
    
    <content type="html"><![CDATA[<p>内容：网络流</p><p>网络流：2018-8-23</p><p>课件：by.浅悠悠</p><p>主讲人：王骏</p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8725.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8726.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8727.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8728.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8729.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8730.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8731.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8732.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8733.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8734.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8735.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8736.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8737.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8738.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8739.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8740.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8741.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8742.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8743.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8744.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8745.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8746.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8747.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8748.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8749.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8750.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8751.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8752.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8753.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8754.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8755.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8756.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8757.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8758.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8759.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8760.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8761.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8762.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8763.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8764.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8765.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8766.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8767.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8768.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8769.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8770.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8771.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8772.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8773.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8774.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8775.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8776.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8777.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8778.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8779.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8780.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8781.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8782.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8783.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8784.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8785.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8786.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8787.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8788.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8789.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8790.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8791.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8792.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8793.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8794.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8795.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8796.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8797.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8798.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8799.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87100.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87101.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87102.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87103.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87104.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87105.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87106.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87107.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87108.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87109.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87110.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87111.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87112.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87113.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87114.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87115.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87116.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87117.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87118.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87119.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87120.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87121.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87122.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87123.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87124.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87125.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87126.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87127.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87128.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87129.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87130.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87131.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87132.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87133.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87134.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87135.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87136.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87137.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87138.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87139.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87140.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87141.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87142.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87143.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87144.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87145.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87146.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87147.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87148.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87149.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87150.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87151.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87152.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87153.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87154.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87155.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87156.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87157.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87158.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87159.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87160.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内容：网络流&lt;/p&gt;
&lt;p&gt;网络流：2018-8-23&lt;/p&gt;
&lt;p&gt;课件：by.浅悠悠&lt;/p&gt;
&lt;p&gt;主讲人：王骏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%871
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="预流推进" scheme="http://qianyouyou.cn/tags/%E9%A2%84%E6%B5%81%E6%8E%A8%E8%BF%9B/"/>
    
      <category term="最小割" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
</feed>
