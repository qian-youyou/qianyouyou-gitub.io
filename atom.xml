<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-08-14T12:58:59.561Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图论进阶总结（欧拉图+二分图匹配+强连通+着色问题）</title>
    <link href="http://qianyouyou.cn/2018/08/14/2018-08-14/"/>
    <id>http://qianyouyou.cn/2018/08/14/2018-08-14/</id>
    <published>2018-08-14T09:46:23.000Z</published>
    <updated>2018-08-14T12:58:59.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><p><img src="http://p7woygi8q.bkt.clouddn.com/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF.gif" alt=""></p><h2 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h2><p>欧拉回路问题是图论中最古老的问题之一。它诞生于十八世纪的欧洲古城哥尼斯堡。普瑞格尔河流经这座城市，人们在两岸以及河中间的两个小岛之间建了七座桥（如图1）。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%981.png" alt=""></p><p>于是产生了这样一个问题：是否可以找到一种方案，使得人们从自己家里出发，不重复地走遍每一座桥，然后回到家中？这个问题如果用数学语言来描述，就是在图2中找出一条回路，使得它不重复地经过每一条边。这便是著名的“哥尼斯堡七桥问题”。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%982.png" alt=""></p><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h2><p>​        欧拉回路：图G=(V,E) (无向图or有向图) 的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。</p><p>​        欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。</p><p>​    欧拉图与半欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉通路而无欧拉回路的图称为半欧拉图。</p><p>​    桥：设无向图G=&lt;V,E&gt;，若存在边集E的一个非空子集E1，使得p(G-E1)&gt;p(G)，而对于E1的任意真子集E2，均有p(G-E2)=p(G)，则称E1是G的边割集，或简称割集；若E1是单元集，即E1={e}，则称e为割边或桥。[p(G)表示图G的连通分支数.]</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E6%AC%A7%E6%8B%89%E5%9B%BE.png" alt=""></p><p>图中，图（4）为欧拉图，图（3）为半欧拉图，图（1）（2）不是欧拉图。</p><h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a><strong>性质：</strong></h2><p>　　欧拉回路：一个欧拉回路，删掉一个点，仍然是一个欧拉回路。从一个欧拉回路拖走一个小欧拉回路，结果也是一个欧拉回路。</p><h2 id="判定（充要）："><a href="#判定（充要）：" class="headerlink" title="判定（充要）："></a><strong>判定（充要）：</strong></h2><p>　　欧拉回路：1:  图G是连通的，不能有孤立点存在。</p><p>　　　　　　　2:  对于无向图来说度数为奇数的点个数为0;对于有向图来说每个点的入度必须等于出度。</p><p>　　欧拉通路：1:  图G是连通的，无孤立点存在。</p><p>　　　　　　　2:  对于无向图来说，度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点。对于有向图来说，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。</p><h2 id="算法（求欧拉回路）："><a href="#算法（求欧拉回路）：" class="headerlink" title="算法（求欧拉回路）："></a><strong>算法（求欧拉回路）：</strong></h2><h3 id="Fleury算法"><a href="#Fleury算法" class="headerlink" title="Fleury算法:"></a><strong>Fleury算法:</strong></h3><p>设图G是一个无向欧拉图，则按照下面算法求欧拉回路:</p><p>1:任取G中一个顶点v0,令P0 = v0.</p><p>2:假设沿Pi = v0e1v1e2v2……eivi 走到了顶点 vi,按照下面方法从E(i) = E(G) -  {e1, e2, e3,…,ei} 中选e(i ＋　1),选择后删除e(i +１)这条边.</p><p>　　a):e(i+1)余vi关联</p><p>　　b):除非无别的边可选，否则e(i+1)不应是Gi = G – {e1,e2,…,ei} 中的桥.假若迫不得已选的是桥,除删除这条边之外,还应该再把孤立点从Gi中移除(选择桥边必然会形成孤立的点).</p><p>3:当步骤 2 无法继续执行时停止算法.</p><p>当算法停止时，所得到的简单回路 Pm = = v0e1v1e2v2e3v3……emvm  (vm = v0) 为图G的一条欧拉回路.</p><p><strong>下面用图来描述：</strong></p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093832441-1464795842.png" alt="img"></p><p>随便选择一个起点 v1。当前处在 v1 点，有两种走法 v1 – v9,v1 – v10，这俩条边都不是桥边，那么随便选择一个，&lt;v1, v10&gt;这条边吧。那么图就会成为这样.Eu = (走过的边集){&lt;v1, v10&gt;}</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833082-1968185223.png" alt="img"></p><p>当前到了 V10 点，有&lt;v10,v4&gt;,&lt;v10,v3&gt;,&lt;v10, v8&gt;，先看&lt;v10,v8&gt;这条边吧，如果选择了这条边那么图就会成为这样：</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833488-2076065400.png" alt="img"></p><p>很显然形成了两个图，上下两个图不连通，即&lt;v10, v8&gt;这条边就是所谓的桥边，算法中说除非别无他选，否则不应该选择桥边，那么这条边就不能选择。回到上面，由于&lt;v10,v4&gt;,&lt;v10,v3&gt;都不是桥边，所以随便选择&lt;v10,v4&gt;吧. Eu={&lt;v1, v10&gt;,&lt;v10,v4&gt;}</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833910-319654348.png" alt="img"></p><p>到了 v4 这个点，&lt;v4, v2&gt;这条边是桥边,但是别无选择，只好选择这条边.选择完这条边这时不仅要从原图中删除这条边，由于点4成为了孤点，所以这个点也该从原图删除。Eu={&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834410-492154878.png" alt="img"></p><p>同理到达 v2 只好选择&lt;v2,v3&gt;，删除孤点 v2和边. Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834941-273171314.png" alt="img"></p><p>别无他选，&lt;v3,v10&gt;。Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835473-1872025007.png" alt="img"></p><p>同样,选择&lt;v10, v8&gt;，Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835941-942659814.png" alt="img"></p><p>此时到了 v8 同第一次到达v10时的情况，不能选择&lt;v8,v9&gt;这条桥边,选择&lt;v8,v6&gt;,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836457-215788402.png" alt="img"></p><p>到达v6，选择&lt;v6,v7&gt;,删点删边,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;}.以下就不给图了(逃;</p><p>然后接下来的选择都是别无他选,依次选择&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;，最后得到的欧拉边集Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;,&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;},于是我们就得到了一条欧拉回路.</p><p><strong>代码：</strong>    </p><p>　　个人感觉时间复杂度不如基本法，主要是判断桥边的时间复杂度有点高，达到O(1)才和基本法一样，所以就放弃写了。</p><h3 id="基本-套圈-法"><a href="#基本-套圈-法" class="headerlink" title="基本(套圈)法"></a><strong>基本(套圈)法</strong></h3><p>1.在图中任意找一个回路C；</p><p>2.将图中属于C的边删除；</p><p>3.在残留图的各个极大连通分量中求欧拉回路；</p><p>4.将各极大连通分量中的欧拉回路合并到C上。</p><h4 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h4><p>　　首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，所停止的点必然也是起点(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，然后停止时，走过的路径形成了一个圈，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。</p><p>　　总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。</p><p><strong>下面用图描述一遍：</strong></p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836879-1824078027.png" alt="img"></p><p>假设我们选择从v1开始走,由于随便走，所以可能出现以下走法</p><p>第一步：v1 – v9</p><p>第二步：v9 – v8</p><p>第三步：v8 – v10</p><p>第四步：v10 – v1</p><p>此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么</p><p>第五步: v10 – v3</p><p>第六步: v3 – v2</p><p>第七步: v2 – v4</p><p>第八步: v4 – v10</p><p>发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么</p><p>第九步：v8 – v6</p><p>第十步：v6 –v7</p><p>第十一步：v7– v8</p><p>又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。</p><p><strong>具体实现与分析:</strong></p><p>使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV = 100 + 7;</span><br><span class="line">const int MAXE = 100 * 100 + 7;</span><br><span class="line">int head[MAXV];</span><br><span class="line">int V, E;</span><br><span class="line"></span><br><span class="line">typedef struct EdgeNode</span><br><span class="line">&#123;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int next;   </span><br><span class="line">&#125;edgeNode;</span><br><span class="line">edgeNode Edges[MAXE];</span><br><span class="line"></span><br><span class="line">bool visit[2 * MAXE];</span><br><span class="line">stack&lt;int&gt; stv;</span><br><span class="line">queue&lt;int&gt; quv;//点集</span><br><span class="line">queue&lt;int&gt; que;//边集</span><br><span class="line"></span><br><span class="line">void EulerDFS(int now)</span><br><span class="line">&#123;</span><br><span class="line">    st.push(now);//每访问一个点，就把该点压入栈</span><br><span class="line">    for(int k = head[now]; k != -1; k = Edges[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visit[k])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[k] = true;            //有向图每条边保存了两次，也要标记两次</span><br><span class="line">            if(k &amp; 1)</span><br><span class="line">                visit[k + 1] = true;</span><br><span class="line">            else</span><br><span class="line">                visit[k - 1] = true;</span><br><span class="line">            EulerDFS(Edges[k].to);</span><br><span class="line">            que.push(k);//回溯时记录边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quv.push(stv.top());//记录点</span><br><span class="line">    stv.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;V, &amp;E);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    for(int i = 1; i &lt;= E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        Edges[2 * i - 1].to = v;                //双向储存边</span><br><span class="line">        Edges[2 * i - 1].w = w;</span><br><span class="line">        Edges[2 * i - 1].next = head[u];</span><br><span class="line">        head[u] = 2 * i - 1;</span><br><span class="line">        Edges[2 * i].to = u;</span><br><span class="line">        Edges[2 * i].w = w;</span><br><span class="line">        Edges[2 * i].next = head[v];</span><br><span class="line">        head[v] = 2 * i;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visit, false, sizeof(visit));</span><br><span class="line">    EulerDFS(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9C%88.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欧拉图&quot;&gt;&lt;a href=&quot;#欧拉图&quot; class=&quot;headerlink&quot; title=&quot;欧拉图&quot;&gt;&lt;/a&gt;欧拉图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p7woygi8q.bkt.clouddn.com/%E6%AC%A7%E6%8B%89%E5%9
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ccpc-wannafly秦皇岛站集训部分题解</title>
    <link href="http://qianyouyou.cn/2018/08/13/2018-08-12/"/>
    <id>http://qianyouyou.cn/2018/08/13/2018-08-12/</id>
    <published>2018-08-13T11:10:46.000Z</published>
    <updated>2018-08-14T04:36:36.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WANNAFLY-DAY1"><a href="#WANNAFLY-DAY1" class="headerlink" title="WANNAFLY_DAY1"></a>WANNAFLY_DAY1</h1><h2 id="Problem-A-Birthday"><a href="#Problem-A-Birthday" class="headerlink" title="Problem A. Birthday"></a>Problem A. Birthday</h2><p>恬恬的生日临近了。宇扬给她准备了一个大蛋糕。</p><p>正如往常一样，宇扬在蛋糕上插了n支蜡烛，并把蛋糕分为m个区域。因为某种原因，他必须把第i根蜡烛插在第ai个区域或第bi个区域。区域之间是不相交的。宇扬在一个区域内同时摆放x支蜡烛就要花费x2的时间。宇扬布置蛋糕所用的总时间是他在每个区域花的时间的和。</p><p>宇扬想快些见到恬恬，你能告诉他布置蛋糕最少需要多少时间吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数n，m（1 ≤ n ≤ 50， 2 ≤ m ≤ 50）。<br>接下来n行，每行两个整数ai, bi（1 ≤ ai, bi ≤ m）。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示答案</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>standard input<br>3 3<br>1 2<br>1 2<br>1 2</p><p>standard output</p><p>5</p><p>standard input </p><p>3 3<br>1 2<br>2 3<br>1 3</p><p>standard output</p><p>3</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>考虑费用流时把每个part拆成n个点，选择第i个点的代表为放置i块蛋糕和(i - 1)块蛋糕的时间差，这个时间差是增的，因此在费用流的过程中必定会从小到大选择<br>具体建图：左边n个点代表n个蛋糕，右边m * n个点代表m个part,每个part拆成n个点。源点向每个左边的点连一条流量1费用0的边，每个右边的点向汇点连一条流量1费用0的编。每个蛋糕向可以放的两个part的所有点连边，连向第i个点的费用为i^2 - (i - 1)^2，流量为1。这样求最小费用流既为答案。</p><h2 id="Problem-B-Board"><a href="#Problem-B-Board" class="headerlink" title="Problem B. Board"></a>Problem B. Board</h2><p>恬恬有一个n × n的数组。她在用这个数组玩游戏：</p><p>开始时，数组中每一个元素都是0。</p><p>恬恬会做某些操作。在一次操作中，她可以将某一行的所有元素同时加上一个值，也可以将某一列的所有元素同时加上一个值。</p><p>在几次操作后，一个元素被隐藏了。你能帮助她回忆隐藏的数是几吗？</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n（1 ≤ n ≤ 1000）。<br>接下来n行每行n个整数表示数组a。<br>第(i + 1)行的第j个元素表示aij（aij = −1或0 ≤ aij ≤ 100000）。−1表示隐藏的元素</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>仅一个整数表示答案</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>3<br>1 2 1<br>0 -1 0<br>0 1 0</p><p> standard output</p><p>1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把格子N染色，第i行第j列格子的颜色为(i + j) % N。那么每次操作时，必定是N种不同的颜色都有一格被操作到，因此最后任何颜色格子的和必定是相等的。因此只需要记录每种颜色格子的和，并算出缺失格子的颜色C，用其余颜色的和减去颜色C的和即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int x,y;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;map[i][j];</span><br><span class="line">if(map[i][j]==-1) </span><br><span class="line">&#123;</span><br><span class="line">x=i;</span><br><span class="line">y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==x) continue;</span><br><span class="line">int minn=0x3f3f3f;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j]-=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==y) continue;</span><br><span class="line">int minn=0x3f3f3f;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,map[j][i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">map[j][i]-=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans1=0,ans2=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(map[i][y]!=0 &amp;&amp; map[i][y]!=-1) ans1=map[i][y];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(map[x][i]!=0 &amp;&amp; map[x][i]!=-1) ans2=map[x][i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans1+ans2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C-Circle"><a href="#Problem-C-Circle" class="headerlink" title="Problem C. Circle"></a>Problem C. Circle</h2><p>现在我们要把1 . . . n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多。请输出最大对数。</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>一行一个整数n(1 ≤ n ≤ 1000)。</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>standard input </p><p>4</p><p>standard output<br>4</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>样例的一种构造方法为1 4 3 2。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为(i,i+1)=1且(1,n)=1，所以把1…n依次放进一个环，就可以啦。答案为n。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">while(cin&gt;&gt;t)&#123;</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-D-土龙弟弟"><a href="#Problem-D-土龙弟弟" class="headerlink" title="Problem D. 土龙弟弟"></a>Problem D. 土龙弟弟</h2><h2 id="Problem-E-Growth"><a href="#Problem-E-Growth" class="headerlink" title="Problem E. Growth"></a>Problem E. Growth</h2><p>弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。</p><p>为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a ≥ xi且b ≥ yi，则弱<br>弱在接下来的每一天都可以得到zi的分数。</p><p>问m天以后弱弱最多能得到多少分数。</p><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>第一行一个两个整数n和m（1 ≤ n ≤ 1000，1 ≤ m ≤ 2000000000）。<br>接下来n行，每行三个整数xi，yi，zi（1 ≤ xi, yi ≤ 1000000000，1 ≤ zi ≤ 1000000）。</p><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>2 4<br>2 1 10<br>1 2 20</p><p> standard output</p><p>50</p><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。<br>共获得0 + 0 + 20 + 30 = 50分</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把奖励的x拿出来从小到大排序，得到x1,x2,…,xn。<br>把奖励的y拿出来从小到大排序，得到y1,y2,…,yn。<br>用v[i][j]表示a值到达xi，b值达到yi时接下来每天可以得到的奖励。<br>v[i][j] = v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1] + t[i][j]<br>其中t[i][j]为满足x=i，y=j的奖励的总和。<br>用f[i][j]表示a值达到xi，b值达到yj时已经拿到的奖励的最大值。<br>f[i][j] + (x[i + 1] - x[i] - 1) <em> t[i][j] + t[i + 1][j] -&gt; f[i + 1][j]<br>f[i][j] + (y[j + 1] - y[j] - 1) </em> t[i][j] + t[i][j + 1] -&gt; f[i][j + 1]<br>最后统计一下答案就可以了。</p><h2 id="Problem-F-Kingdom"><a href="#Problem-F-Kingdom" class="headerlink" title="Problem F. Kingdom"></a>Problem F. Kingdom</h2><p>X王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个<br>官员是这个上司的下属。上司的编号总比下属小。</p><p>我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力<br>是1。国王的影响力总是n。</p><p>任何一位有下属的官员总是选择他的下属中影响力最高的作为他的心腹（有若干下属影响力相同的话则<br>会选择编号最小的）。</p><p>一位官员得到一条消息后，他就要把消息传达给国王。我们定义一位官员的花费为他将消息传达给国王<br>的花费。国王自己的花费为0。如果一位官员是他上司的心腹，则他的花费等于他上司的花费，否则他<br>的花费为他上司的花费加1。</p><p>由于时代和平，消息并不需要传递的太快。我们希望你决定每位官员（除了国王）的上司，使得所有官<br>员的花费之和和尽量小。</p><h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>一个整数n（1 ≤ n ≤ 8000）表示包括国王在内的官员的总数。</p><h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示最大的花费之和。</p><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>4</p><p> standard output</p><p>2</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>f[i]代表i个点时的答案，g[i][j]代表若干颗树加起来，size和为i，每棵树size&lt;=j时，这些树的代价和最大是多少<br>从1到n枚举i，在i固定时枚举心腹的影响力大小更新f[i]，然后用类似背包的思路更新g[i][1]~g[i][i]<br>复杂度O(N^2)</p><h2 id="Problem-G-Matrix"><a href="#Problem-G-Matrix" class="headerlink" title="Problem G. Matrix"></a>Problem G. Matrix</h2><p>弱弱有一个n × m的矩阵，第i行第j列位置上的值为aij。<br>弱弱定义以(x, y)为顶点，大小为k的三角形为：</p><p>第x行y位置，<br>第x + 1行y − 1，y，y + 1位置，<br>. . .，<br>第x + k − 1行y − k + 1，. . .，y + k − 1位置组成的区域。</p><p>比如说，以(1, 3)为顶点，大小为3的三角形为</p><p>OOXOOOO<br>OXXXOOO<br>XXXXXOO<br>OOOOOOO<br>中打叉的位置。</p><p>现在弱弱想要知道所有大小为k的三角形中，重心位置离顶点最近的是哪个？重心是三角形中每个位置<br>按照它们的值加权平均所得的点。<br>请输出这个最小距离（欧几里得距离）。</p><h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>第一行一个三个整数n，m，k（1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，1 ≤ k ≤ min n,(m + 1)/2</p><p>接下来n行，每行m个整数aij（1 ≤ aij ≤ 1000）表示每个位置的重量。</p><h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>一行一个数表示答案。相对误差或绝对误差在10−5（1e-5）之内均会被判断为正确。</p><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>2 3 2<br>1 1 1<br>1 1 1</p><p>standard output</p><p>0.7500000000</p><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>只有一个大小为2的三角形。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>w个格子的重心的坐标为（∑xi<em>wi / ∑wi, ∑yi</em>wi / ∑wi)。<br>那么其实我们只要维护∑xi<em>wi，∑yi</em>wi，∑wi就可以了。<br>假设我们现在有一个顶点为(x, y)的三角形，我们想要推到顶点为(x, y+1)的三角形，观察两者之间的差异，会发现在推过去的过程中，其实就是删去了一个斜条，又加入了一个斜条。<br>同理，从(x, y)到(x+1, y)其实只是删去了两个斜条，加上了底上的横条，而这些关键的值都是可以通过前缀和的方法维护。</p><h2 id="Problem-H-Mountain"><a href="#Problem-H-Mountain" class="headerlink" title="Problem H. Mountain"></a>Problem H. Mountain</h2><p>平面上有n座山，每座山都有左右两面，第i座山的高度为ai，现在弱弱在第一座山的左边山脚下（高度为0），他想要依此爬过这些山，到达第n座山的右边山脚下。</p><p>除了简单的爬上爬下，还有一种特殊操作。</p><p>如果弱弱目前在第i座山右面的海拔x的位置，且第j(i &lt; j)座山的海拔大于等于x，且第i + 1, . . . , j − 1座山中没有一座山的海拔高于x，那么他可以使用绳索滑到第j座山左面海拔x的位置。</p><p>弱弱想找到一种方式，使得他在行程中海拔变化的幅度最小。请输出最小幅度。</p><h3 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n（1 ≤ n ≤ 1000）。<br>接下来一行n个整数ai（1 ≤ ai ≤ 1000）表示每座山的高度。</p><h3 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p><h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>5<br>1 3 5 4 2</p><p>standard output</p><p>10</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>考虑山中最高的一座，最优操作一定是从第一座山的左下角开始不停地往上爬，然后从最高的山不停地往下爬爬到最后一座山的右下角。<br>所以答案为最高山的高度*2。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1007], n;</span><br><span class="line">int main()&#123;</span><br><span class="line"> while(cin&gt;&gt;n)&#123;</span><br><span class="line">  int cnt = 0;</span><br><span class="line">  a[0] = 0;</span><br><span class="line">  int cur = 0;</span><br><span class="line">  for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">   cin&gt;&gt;a[i];</span><br><span class="line">   if(a[i] &gt;= a[cur])&#123;</span><br><span class="line">    cnt += abs(a[i] - a[cur]);</span><br><span class="line">    cur = i;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while(cur&lt;n)&#123;</span><br><span class="line">   int cur2 = cur+1;</span><br><span class="line">   for(int i = cur2;i&lt;=n;i++)&#123;</span><br><span class="line">    if(a[i] &gt;= a[cur2])&#123;</span><br><span class="line">     cur2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cnt+=abs(a[cur2]-a[cur]);</span><br><span class="line">   cur = cur2;</span><br><span class="line">  &#125;</span><br><span class="line">  cnt+=a[n];</span><br><span class="line">  cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-I-清明梦超能力者黄"><a href="#Problem-I-清明梦超能力者黄" class="headerlink" title="Problem I. 清明梦超能力者黄"></a>Problem I. 清明梦超能力者黄</h2><p>黄YY是一个清明梦超能力者，同时也是一个记忆大师。他能够轻松控制自己在梦中的一切，在醒来之<br>后还能清晰的记得梦中所有的细节，这让他的朋友们都十分羡慕。</p><p>又是一个晚上，黄YY又到了自己的梦中，并且随手造出了一棵有n个点的树，树上每个点有一个初始颜<br>色0。为了让这棵树不那么单调，黄YY拿起了画笔在上面尽情上色。每一次上色可以用u, v, c来描述，代<br>表黄YY把u, v这条路径上的点都染色成了c。</p><p>正当黄YY开心的完成了m次染色，准备在早上醒来之时向朋友们炫耀。但现实中的黄YY由于过于兴奋<br>滚到了床下，撞到了脑袋，在剧痛中醒来。由于脑部受到了严重创伤，黄YY对刚才梦境中发生的一切<br>发生了严重的信息丢失。</p><p>但英俊潇洒的黄YY当然不希望自己的窘态被朋友们发现。为了证明自己还是那个清明梦超能力者，他<br>希望告诉朋友们自己上色后每个节点的颜色。同时为了更进一步证明他还是个记忆大师，他希望干脆直<br>接说出每个点在倒数第k次染色时的颜色。</p><p>当然，现在的黄YY已经成了弱智了，作为黄YY最亲密的朋友，你快来帮帮黄YY吧！</p><h3 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h3><p>第一行三个整数n, m, k，代表树的点数，黄YY染色的次数，以及最后求颜色时，倒数的次数<br>（1 ≤ n, m, k ≤ 100000）。</p><p>接下来n − 1行，每行u, v代表u, v两点之间有一条边。这里保证1 ≤ u, v ≤ n，且无重边与自环，是一棵<br>标准的树。</p><p>接下来m行，每一行三个数字u, v, c代表黄YY在第这次用c颜色的画笔从u涂到了v。</p><h3 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h3><p>一行n个数字，输出每个点倒数第k次染色时的颜色。如果本身不足k次，输出0。</p><h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h3><p>standard input </p><p>3 3 2</p><p>1 2</p><p>2 3</p><p>1 2 1</p><p>2 3 2</p><p>1 3 3</p><p>standard output</p><p>1 2 2</p><h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p>对于点1在第一次和第三次染色的时候分别被染色为1, 3，倒数第二次的颜色就是1。</p><p>对于点2在第一、二、三次染色的时候分别被染色为1, 2, 3，倒数第二次的颜色就是2。</p><p>对于点3在第二次和第三次染色的时候分别被染色为2, 3，倒数第二次的颜色就是2。</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>首先每条路径从LCA处分开可以拆成两条链<br>假设链A-&gt;B执行了第i次染色操作，假设A是B的祖先，那么我们在B点加入一个”插入i”的事件，在A的父亲点加入一个”删除i”的事件<br>然后dfs整颗树求解，每个点维护一个线段树。处理一个点时先合并所有儿子的线段树，然后再处理这个点上的事件，得到线段树之后询问第K大值既可得到答案。<br>复杂度分析：<br>Node<em> merge(Node</em> a, Node* b) {<br>    if (a == NULL) return b;<br>    if (b == NULL) return a;<br>    a-&gt;sum += b-&gt;sum;<br>    a-&gt;child[0] = merge(a-&gt;child[0], b-&gt;child[0]);<br>    a-&gt;child[1] = merge(a-&gt;child[1], b-&gt;child[1]);<br>    return a;<br>}<br>考虑以上的线段树合并，每次合并会减少一个区间。而在事件点插入、删除的时候会产生至多log个区间，因此复杂度为O(NLogN)</p><h2 id="Problem-J-最短路"><a href="#Problem-J-最短路" class="headerlink" title="Problem J. 最短路"></a>Problem J. 最短路</h2><p>给一个连通图，每次询问两点间最短路。每条边的长度都是1。</p><h3 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数n和m，表示图的点数和边数（1 ≤ n ≤ 100000, 1 ≤ m ≤ n + 100）。</p><p>接下来m行每行两个整数a和b，表示一条边（1 ≤ a, b ≤ n）。保证没有自环和重边。保证图连通。</p><p>接下来一个整数q表示询问的个数（1 ≤ q ≤ 100000）。</p><p>接下来q行每行两个整数a和b表示询问a和b之间的最短路。</p><h3 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h3><p>每个询问输出一行表示答案</p><h3 id="Example-7"><a href="#Example-7" class="headerlink" title="Example"></a>Example</h3><p>input</p><p>4 5<br>1 2<br>2 3<br>1 4<br>4 3<br>2 4<br>4<br>1 4<br>1 2<br>2 4<br>1 3</p><p>output</p><p>1<br>1<br>1<br>2</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>本题十分直接。我们不断地把度数为1的点删掉，把度数为2的点收缩，最后会得到一个图，和原图的点数与边数之差相同，且新图中每个点的度数都至少是3。这就是说我们会得到一个200个点300条边以内的图。新图可以用Floyd算法预处理所有点对之间最短路。询问时，将询问转化到新图上即可。转化时需要注意细节。</p><h1 id="WANNAFLY-DAY2"><a href="#WANNAFLY-DAY2" class="headerlink" title="WANNAFLY_DAY2"></a>WANNAFLY_DAY2</h1><h2 id="Problem-A-Tobaku-Mokushiroku-Kaiji"><a href="#Problem-A-Tobaku-Mokushiroku-Kaiji" class="headerlink" title="Problem A. Tobaku Mokushiroku Kaiji"></a>Problem A. Tobaku Mokushiroku Kaiji</h2><p>开司正在与另外一人玩石头剪刀布。双方各有一些代表石头、剪刀、布的卡牌，每局两人各出一张卡<br>牌，根据卡牌的内容决定这一局的胜负。胜负规则为：石头赢剪刀、剪刀赢布、布赢石头、相同为平<br>局。每张卡牌至多被使用一次。<br>已知双方的卡牌数量，问开司最多赢几局？</p><h3 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h3><p>一行六个数字a, b, c, d, e, f(0 ≤ a, b, c, d, e, f ≤ 50)，a, b, c分别表示开司的石头、剪刀、布的牌的数<br>量，d, e, f分别表示此时另一人的石头、剪刀、布的牌的数量。</p><h2 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h2><p>一个整数表示开司最多赢几局</p><h3 id="Example-8"><a href="#Example-8" class="headerlink" title="Example"></a>Example</h3><p>in</p><p>29 7 41 14 12 42</p><p>out</p><p>33</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[6];</span><br><span class="line">for(int i = 0;i&lt;6;i++)</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">cout&lt;&lt;min(a[0],a[4])+min(a[1],a[5])+min(a[2],a[3])&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-E-Eustia-of-the-Tarnished-Wings"><a href="#Problem-E-Eustia-of-the-Tarnished-Wings" class="headerlink" title="Problem E. Eustia of the Tarnished Wings"></a>Problem E. Eustia of the Tarnished Wings</h2><p>Novus Aither是一个潜藏着多个势力的城市。每个势力都有一个唯一的领导人，每个领导人有一个属性<br>值。如果两个势力的领导人的属性值分别为a, b，且|a − b| ≤ m，说明这两个领导人的思想有一定的相似<br>之处，这两个势力可以合并，新的领导人可以指定为原来的两个领导人中的任意一个。新产生的势力可<br>以依照相同的的规则，继续与其他势力合并。问在所有可能的合并情况中，最少会剩下几个势力。</p><h3 id="Input-10"><a href="#Input-10" class="headerlink" title="Input"></a>Input</h3><p>第一行两个空格隔开的整数n(1 ≤ n ≤ 106<br>), m(0 ≤ m109<br>)。n代表当前势力的个数。m的含义如题目描<br>述。<br>第二行n个空格隔开的整数di(0 ≤ di ≤ 109<br>)，代表第i个势力的领导人的属性值。</p><h3 id="Output-10"><a href="#Output-10" class="headerlink" title="Output"></a>Output</h3><p>输出一个数表示势力的最少数量。</p><p>Example<br>standard input<br>4 1<br>2 1 3 10</p><p>standard output</p><p>2</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const int maxn = 1e6+7;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">ll n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">int cnt = 1;</span><br><span class="line">for(int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">if(a[i]-a[i-1]&gt;m)</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY3"><a href="#WANNAFLY-DAY3" class="headerlink" title="WANNAFLY_DAY3"></a>WANNAFLY_DAY3</h1><h2 id="Problem-D-Shopping"><a href="#Problem-D-Shopping" class="headerlink" title="Problem D. Shopping"></a>Problem D. Shopping</h2><p>你要买n件物品，其中有一些是凳子。<br>商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个<br>物品。<br>你有m辆购物车，请最小小化你的花费。</p><h3 id="Input-11"><a href="#Input-11" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数t表示数据组数(1 ≤ t ≤ 100)。</p><p>每组数据第一行两个整数n, m (1 ≤ n, m ≤ 1000)，接下来n行每行两个整数ai<br>, bi，分别表示第i件物品的<br>价格以及它是否是凳子(1 ≤ ai ≤ 105<br>, 0 ≤ bi ≤ 1)。</p><h3 id="Output-11"><a href="#Output-11" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出一行一个实数表示最小花费，保留一位小数。</p><p>Example<br>stdin<br>2<br>5 1<br>1 0<br>2 1<br>3 1<br>4 0<br>5 0<br>5 10<br>1 0<br>2 1<br>3 1<br>4 0<br>5 0</p><p>stdout</p><p>12.5<br>10.5</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">const int maxn = 1007;</span><br><span class="line">struct node&#123;</span><br><span class="line">double cost;</span><br><span class="line">int flag;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">int cmp(node a,node b)&#123;</span><br><span class="line">return a.cost&gt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">int cnt = 0;</span><br><span class="line">double all = 0;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].cost;</span><br><span class="line">cin&gt;&gt;a[i].flag;</span><br><span class="line">if(a[i].flag==1)</span><br><span class="line">cnt++;</span><br><span class="line">all+=a[i].cost;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt&gt;m)</span><br><span class="line">cnt = m;</span><br><span class="line">sort(a,a+n,cmp);</span><br><span class="line">for(int i = 0;i&lt;cnt;i++)&#123;</span><br><span class="line">all-=(a[i].cost/2.0);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.1lf\n&quot;,all);</span><br><span class="line">&#125;</span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY4"><a href="#WANNAFLY-DAY4" class="headerlink" title="WANNAFLY_DAY4"></a>WANNAFLY_DAY4</h1><h2 id="7-贵族用户"><a href="#7-贵族用户" class="headerlink" title="7 贵族用户"></a>7 贵族用户</h2><p>终于活成了自己讨厌的样子。<br>充钱能让你变得更强。</p><p>在暖婊这个游戏里面，如果你充了 x 元钱，那么你能获得 10x 个钻石。同时暖婊也有 m 档VIP，如果你往暖婊里面充了 ai 个钻石，那么你能成为第 i 档贵族用户。当你成为为第 i 档贵族用户。当你成为第 i 档贵族用户之后，那么你可以获得 pi% 的优惠。</p><p>你需要 k 件材料合成衣服，其中第 i 件材料原价为 di 个钻石，你一共需要 ci 件这种材料。<br>当你获得 p 的优惠时，这个材料的真实价格为 ⌈di(1 − p)⌉。<br>请问栗子米最少需要氪多少钱，这里我们规定只能氪整数的钱。</p><h3 id="7-2-输入格式"><a href="#7-2-输入格式" class="headerlink" title="7.2 输入格式"></a>7.2 输入格式</h3><p>第一行一个整数 T(T ≤ 1000)，表示数据组数。<br>每组数据第一行两个整数 m, k(1 ≤ m, k ≤ 15)。</p><p>接下来 m 行每行两个正整数 1 ≤ ai ≤ 105<br>, 1 ≤ pi ≤ 100，保证 ai &lt; ai+1, pi ≤ pi+1。<br>接下来 k 行每行两个正整数 1 ≤ ci<br>, di ≤ 1000。</p><h3 id="7-3-输出格式"><a href="#7-3-输出格式" class="headerlink" title="7.3 输出格式"></a>7.3 输出格式</h3><p>对于每组数据，输出一个整数，表示至少要氪多少钱。</p><h3 id="7-4-样例输入"><a href="#7-4-样例输入" class="headerlink" title="7.4 样例输入"></a>7.4 样例输入</h3><p>1<br>1 1<br>100 100<br>100 100</p><h3 id="7-5-样例输出"><a href="#7-5-样例输出" class="headerlink" title="7.5 样例输出"></a>7.5 样例输出</h3><p>10</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">int a;</span><br><span class="line">int p;</span><br><span class="line">&#125;vip[20];</span><br><span class="line">struct cost&#123;</span><br><span class="line">int cc;</span><br><span class="line">int dd;</span><br><span class="line">&#125;dim[20];</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;k;</span><br><span class="line">for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">cin&gt;&gt;vip[i].a&gt;&gt;vip[i].p;</span><br><span class="line">if(vip[i].a%10)</span><br><span class="line">vip[i].a+=10-(vip[i].a%10);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">cin&gt;&gt;dim[i].cc&gt;&gt;dim[i].dd;</span><br><span class="line">ans+=dim[i].cc*dim[i].dd;</span><br><span class="line">&#125;</span><br><span class="line">if(ans%10)</span><br><span class="line">ans+=10-(ans%10);</span><br><span class="line">int minx = ans;</span><br><span class="line">for(int u = 0;u&lt;m;u++)&#123;</span><br><span class="line">int ans2 = 0;</span><br><span class="line">for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">ans2 += dim[i].cc*(ceil((1-((double)vip[u].p/100.0))*dim[i].dd));</span><br><span class="line">&#125;</span><br><span class="line">if(ans2%10)&#123;</span><br><span class="line">ans2+=10-(ans2%10);</span><br><span class="line">&#125;</span><br><span class="line">if(ans2&lt;=vip[u].a)&#123;</span><br><span class="line">ans2 = vip[u].a;</span><br><span class="line">&#125;</span><br><span class="line">minx = min(minx,ans2);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;minx/10&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY6"><a href="#WANNAFLY-DAY6" class="headerlink" title="WANNAFLY_DAY6"></a>WANNAFLY_DAY6</h1><h2 id="F平衡二叉树"><a href="#F平衡二叉树" class="headerlink" title="F平衡二叉树"></a>F平衡二叉树</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1%60_0EI$RPOB1E$BDXEDC2%25W.png" alt=""></p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 70;</span><br><span class="line">ll n,d;</span><br><span class="line">ll a,b;</span><br><span class="line">ll c[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;d;</span><br><span class="line">a = 1;</span><br><span class="line">b = 0;</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">for(int i = 0;i&lt;n-1;i++)</span><br><span class="line">a*=2;</span><br><span class="line">a-=1;</span><br><span class="line">for(int i = 0;i&lt;=d;i++)&#123;</span><br><span class="line">c[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">c[d+1] = 2;</span><br><span class="line">for(int i = d+2;i&lt;n-1-d;i++)&#123;</span><br><span class="line">c[i] = c[i-1]+c[i-d-1];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0;i&lt;n-1-d;i++)</span><br><span class="line">b+=c[i];</span><br><span class="line">cout&lt;&lt;a-b&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H卡牌游戏"><a href="#H卡牌游戏" class="headerlink" title="H卡牌游戏"></a>H卡牌游戏</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1%25%7B0%29ORKZ_W%29T4%7B3$FKU3R9.png" alt=""></p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">for(int u = 1;u&lt;=t;u++)&#123;</span><br><span class="line">long double x,y;</span><br><span class="line">int z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">cin&gt;&gt;z;</span><br><span class="line">printf(&quot;Case #%d: &quot;,u);</span><br><span class="line">long double ans = 0;</span><br><span class="line">for(int i = 0;i&lt;z;i++)&#123;</span><br><span class="line">ans += x/y;</span><br><span class="line">x--;</span><br><span class="line">y--;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%Lf\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY7"><a href="#WANNAFLY-DAY7" class="headerlink" title="WANNAFLY_DAY7"></a>WANNAFLY_DAY7</h1><h2 id="A-机器学习"><a href="#A-机器学习" class="headerlink" title="A.机器学习"></a>A.机器学习</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/7WIGFX9JGWV%5DBD0A9XRS%5DG8.png" alt="http://p7woygi8q.bkt.clouddn.com/7WIGFX9JGWV%5DBD0A9XRS%5DG8.png"></p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">double n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">printf(&quot;%.2lf\n&quot;,n);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D最小生成树"><a href="#D最小生成树" class="headerlink" title="D最小生成树"></a>D最小生成树</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/3XW5G5R%7DEQ~Y6M%25%5BM4G6O1T.png" alt=""></p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ll minx = 0x3fffffff;</span><br><span class="line">ll sum = 0;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">minx = min(minx,a[i]);</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">sum += minx*(n-1);</span><br><span class="line">sum-=minx;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G区间权值"><a href="#G区间权值" class="headerlink" title="G区间权值"></a>G区间权值</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1UEZSLL%25IWJN7N%60%7D~ID$R%5DQ.png" alt=""></p><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e7+7;</span><br><span class="line">const int maxn = 300007;</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">ll a[maxn] = &#123;0&#125;;</span><br><span class="line">ll w[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpa[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpb[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpl[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpr[maxn] = &#123;0&#125;;</span><br><span class="line">int n;</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">int tmp = min(i,n-i+1);</span><br><span class="line">dpb[i] = tmp*dpa[n]%mod;</span><br><span class="line">dpb[i] -= dpl[tmp-1];</span><br><span class="line">dpb[i] -= dpr[n-tmp+2];</span><br><span class="line">dpb[i]%=mod;</span><br><span class="line">dpb[i] *= w[i];</span><br><span class="line">dpb[i]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">dpa[i] = a[i];</span><br><span class="line">dpa[i]+=dpa[i-1];</span><br><span class="line">dpa[i]%=mod;</span><br><span class="line">dpl[i] = dpl[i-1];</span><br><span class="line">dpl[i]+=dpa[i];</span><br><span class="line">dpl[i]%=mod;</span><br><span class="line">&#125; </span><br><span class="line">dpr[n+1] = 0;</span><br><span class="line">for(int i = n;i&gt;=1;i--)&#123;</span><br><span class="line">dpr[i] = dpr[i+1];</span><br><span class="line">dpr[i]+=dpa[n]-dpa[i-1];</span><br><span class="line">dpr[i]%=mod;</span><br><span class="line">&#125; </span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;w[i];</span><br><span class="line">&#125;</span><br><span class="line">ll ans = 0;</span><br><span class="line">init();</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=dpb[i];</span><br><span class="line">ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I联通块计数"><a href="#I联通块计数" class="headerlink" title="I联通块计数"></a>I联通块计数</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1K%7DH9GVNQ5%2943T$8IZ3HUY7.png" alt=""></p><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e7+7;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">int n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">dp[i] = a[i];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">if(i&gt;0)&#123;</span><br><span class="line">dp[i]*=dp[i-1];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">dp[i]+=a[i];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">dp[i]+=dp[i-1];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ll ans = 1;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">ans+=(a[i]*(a[i]+1)/2)%mod;</span><br><span class="line">ans%=mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line">if(n&gt;0)&#123;</span><br><span class="line">ans+=dp[n-1];</span><br><span class="line">ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans%mod&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J寻找复读机"><a href="#J寻找复读机" class="headerlink" title="J寻找复读机"></a>J寻找复读机</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1GP5%60K5WW_NQ%60S%5B4GR8T%5B%29Y.png" alt=""></p><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n,m;</span><br><span class="line">int vis[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">string str1, tmp;</span><br><span class="line">int d;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">cin&gt;&gt;d;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">if(str1==tmp)&#123;</span><br><span class="line">if(vis[d]!=-1)</span><br><span class="line">vis[d]++;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">vis[d]=-1;</span><br><span class="line">&#125;</span><br><span class="line">str1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int flag = 0;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">if(vis[i]!=-1)&#123;</span><br><span class="line">if(flag==0)&#123;</span><br><span class="line">cout&lt;&lt;i;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&apos; &apos;&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WANNAFLY-DAY1&quot;&gt;&lt;a href=&quot;#WANNAFLY-DAY1&quot; class=&quot;headerlink&quot; title=&quot;WANNAFLY_DAY1&quot;&gt;&lt;/a&gt;WANNAFLY_DAY1&lt;/h1&gt;&lt;h2 id=&quot;Problem-A-Birthday&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>7.26图论基础专项训练题解</title>
    <link href="http://qianyouyou.cn/2018/07/26/2018-07-26/"/>
    <id>http://qianyouyou.cn/2018/07/26/2018-07-26/</id>
    <published>2018-07-26T14:22:06.000Z</published>
    <updated>2018-07-26T15:10:56.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-A-签到题之青蛙爬楼梯"><a href="#问题-A-签到题之青蛙爬楼梯" class="headerlink" title="问题 A: 签到题之青蛙爬楼梯"></a>问题 A: 签到题之青蛙爬楼梯</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 117  解决: 37<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1784" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1784&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1784&amp;getkey=3D275E187A" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1784" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>楼梯有n阶台阶，青蛙每次可以跳1~n阶台阶，问青蛙共有多少种上楼梯的方法。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入仅一行，一个整数n（n&lt;=50）</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出n阶台阶对应上楼梯的方法。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题作为水题，不作为图论题。样例提示（1，1，1），（1，2），（2，1），（3）共4种方法</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第n阶台阶，我们可以从n-1跳到n，可以从n-2跳到n……可以从1跳到n，也可以从0跳到n。那么要求第n阶的数量，只需求前n-1阶，前n-2阶……前1阶的方法，所以我们列出关系式为F(n)=F(n-1)+F(n-2)+……+F(1)+1。同理，第n-1阶的关系式为F(n-2)+F(n-3)+……+F(1)+1。两个式子合并得F(n)=2*F(n-1)。由于F(1)=1,所以F(n)=2^(n-1)。</p><h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll a = pow(2,n-1);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-排名"><a href="#问题-B-排名" class="headerlink" title="问题 B: 排名"></a>问题 B: 排名</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 60  解决: 24<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1785" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1785&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1785&amp;getkey=40F8E5A0BF" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1785" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 N 个比赛队（1&lt;=N&lt;=500），编号依次为 1，2，3……N 进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即 P1 赢 P2，用 P1，P2 表示，排名时 P1 在 P2之前。现在请你编程序确定排名。</p><p>符合条件的排名可能不是唯一的。此时要求输出时编号小的队伍在前。输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入有若干组。每组中的第一行为二个数N（1&lt;=N&lt;=500）。M；当中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中。每行也有两个整数P1。P2表示即P1队赢了P2队。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>给出一个符合要求的排名。输出时队伍号之间有空格。最后一名后面没有空格。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 4</span><br><span class="line">4 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>拓扑排序模板题，唯一可能出现问题的地方就是题目要求同样拓扑序的两个编号小的要在前面，这点可以通过将普通拓扑排序中的队列改为使用优先队列或者堆来实现。</p><h2 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line">int graph[maxn][maxn];//保存图</span><br><span class="line">int degree[maxn];//保存入度</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(graph,0,sizeof(graph));</span><br><span class="line">        memset(degree,0,sizeof(degree));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            if(!graph[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                graph[u][v]=1;</span><br><span class="line">                degree[v]++;//的入度++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(degree[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        bool first=1;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(first)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;cur;</span><br><span class="line">                first=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot; &quot;&lt;&lt;cur;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(graph[cur][i]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    degree[i]--;//相连的点的入度减1</span><br><span class="line">                    if(degree[i]==0)//假设入度为0，增加队列</span><br><span class="line">                        q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-系兄弟就来砍我"><a href="#问题-C-系兄弟就来砍我" class="headerlink" title="问题 C: 系兄弟就来砍我"></a>问题 C: 系兄弟就来砍我</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 34  解决: 10<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1787" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1787&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1787&amp;getkey=584D6A6FD5" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1787" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>渣渣灰因为一句“大家好，我系渣渣辉，系兄弟就来砍我”引得众粉丝纷纷拿两米长的大刀寻找。现有n个据点，编号（1~n），有m条单向路使据点相连。每个据点仅有一个人。这n个人中有k个粉丝。其中渣渣灰在s据点处。请问这k个粉丝到渣渣灰的最短距离是多少</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>首行输入nmks。(k&lt;=n&lt;=100m&lt;=500)s为渣渣灰所在位置</p><p>接下来m行，每行输入xyz，表示从x到y的距离是z，由于是单向边，则y到x的距离不一定是z。</p><p>接下来k个数字，表示粉丝所在据点。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>对于每一个粉丝，输出对应的最短距离。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 2 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据保证k个粉丝均能到达渣渣灰的据点</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先，既然要求k个点到s点的最短路，我们可以反过来求s到这k个点的最短路。这样就变成了单源最短路问题，dijkstra算法和spfa算法都可以做。由于图为有向图，我们在存图时反向存图即可，原本a[i][j]表示i-&gt;j，我们可以将它重新定义为j-&gt;i，或者存图时直接写成a[j][i]即可。</p><h2 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 107;</span><br><span class="line">const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷inf</span><br><span class="line">int n,m,k,s;</span><br><span class="line">int dis[maxn];  //储存各个点到源点的最短距离,dis[s]为0</span><br><span class="line">int road[maxn][maxn];   //两点之间直接距离关系</span><br><span class="line">bool vis[maxn];     //判断源点到该点的距离是否为最短距离</span><br><span class="line">int fans[maxn];</span><br><span class="line">void dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)</span><br><span class="line">            &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    memset(road,inf,sizeof(road));</span><br><span class="line">    for(int i = 1; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;tmp;</span><br><span class="line">        road[y][x]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    for(int i = 0; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;fans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i&lt;k-1; i++)</span><br><span class="line">        cout&lt;&lt;dis[fans[i]]&lt;&lt;&apos; &apos;;</span><br><span class="line">    cout&lt;&lt;dis[fans[k-1]]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-躁动的小Z"><a href="#问题-D-躁动的小Z" class="headerlink" title="问题 D: 躁动的小Z"></a>问题 D: 躁动的小Z</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 7  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1669" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1669&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:外部导入][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1669&amp;getkey=F81CC9CF2B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1669" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>你猜怎么样？小Z追到Gakki了！Gakki邀请小Z去她家共进晚餐，小Z喜出望外。小Z的家和Gakki的家隔着几个街区，所以他决定乘坐公交车前往</p><p>Gakki家赴约。小Z的家在公交站台的起始站（编号为1），而Gakki家正好在末站（编号为n）。城市中有许多公交站台，有些站台之间可以通过公交</p><p>线路互相到达。现在给你n个公交站台和m条不同的公交线路的时间花费，请你帮助小Z分析一下最短的可以从家里来到Gakki身边的路径？</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>有多组测试样例。</p><p>第一行两个正整数n,m(2≤n≤10^5,0≤m≤10^5)，代表站台数与公交线路数量。</p><p>接下来m行每行三个正整数a[i],b[i],w[i],代表从公交站a[i]到b[i]需要花费的时间为w[i]。(1≤a[i],b[i]≤n,1≤w[i]≤10^6)</p><p>注意：公交线路可能会产生环，并且两个站台之间可能有多条公交线路。</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>单独一行，输出花费时间最小时小Z经过的公交站台编号，以空格隔开；如果小Z无法到达Gakki的家，则输出-1.</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 2 2</span><br><span class="line">2 5 5</span><br><span class="line">2 3 4</span><br><span class="line">1 4 1</span><br><span class="line">4 3 3</span><br><span class="line">3 5 1</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 3 5</span><br></pre></td></tr></table></figure><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>半年前写的代码。其实原理很简单，在dijkstra算法模板的基础上加上一个pre数组，用于记录该节点的上一个节点，即该点是经过哪一点才到达该点的。pre数组具体在边松弛的过程中进行重新赋值，松弛成功就将pre值记录k点，及该点是由起点经过k点后所得到的。最后把pre数组中的值递归输出一遍即可。</p><h2 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 900000</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">int d; </span><br><span class="line">int pre;</span><br><span class="line">&#125;path;</span><br><span class="line">path to[1000 + 2];</span><br><span class="line">int g[1000 + 2][1000 + 2], vis[1000 + 2]; </span><br><span class="line">void fun(int ddd) &#123;</span><br><span class="line">if (ddd == 1) &#123;</span><br><span class="line">printf(&quot;%d&quot;, ddd);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int j= to[ddd].pre;</span><br><span class="line">fun(j);</span><br><span class="line">printf(&quot; %d&quot;, ddd);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m, a, b, v, i, j, min, k, from;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; </span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">for (j = 0; j &lt;= n; j++) &#123;</span><br><span class="line">g[i][j] = max;</span><br><span class="line">&#125;</span><br><span class="line">to[i].d = max;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; m; i++) &#123; </span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v);</span><br><span class="line">g[a][b] = v;</span><br><span class="line">g[b][a] = v;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">to[i].d = g[1][i];</span><br><span class="line">if (g[1][i] != max) &#123;</span><br><span class="line">to[i].pre = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[1] = 1;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">min = max;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123;</span><br><span class="line">min = to[j].d;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123;</span><br><span class="line">to[j].d = to[k].d + g[k][j];</span><br><span class="line">to[j].pre = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(n);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-逛街"><a href="#问题-E-逛街" class="headerlink" title="问题 E: 逛街"></a>问题 E: 逛街</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 8  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1788" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1788&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1788&amp;getkey=7BBB5CA0F9" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1788" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设渣渣灰有一个女朋友，他的女朋友要他陪着一起去公园。由于渣渣灰不喜欢运动，所以他想找一条最短的路到达公园。由于途中会有许多消费点，而每到一个消费点女朋友就要购物，而渣渣灰比较抠，所以假如有多条最短路，则他会选择途中消费点最便宜的。给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入nm，点的编号是1~n然后是m行，每行4个数 abdp，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 st;起点s，终点。n和m为0时输入结束。<br>(1&lt;n&lt;=1000 0&lt;m&lt;100000 s != t)</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出 一行有两个数， 最短距离及其花费。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 5 6</span><br><span class="line">2 3 4 5</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 11</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>输入样例的空行只是为了让大家分辨数据，输入有没有空行都没关系。输出样例没有空行。</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>同上一道题的方法，我们再创建一个value数组储存花费情况。在松弛时对value进行改变。松弛成功则value（s-&gt;i）=value(s-&gt;k-&gt;i)。若最短路相等则对value值进行比较，即value（s-&gt;i）=min(value(s-&gt;k-&gt;i),value（s-&gt;i))。s为源点，i为当前终点，k为中间点。最终输出最短路及对应value值即可。</p><h2 id="代码参考-4"><a href="#代码参考-4" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define Min(a,b) a&gt;b?b:a</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">int adj,val;</span><br><span class="line">&#125;g[1005][1005];</span><br><span class="line">int dist[1005];//距离</span><br><span class="line">int value[1005];//费用</span><br><span class="line">int used[1005];//标记</span><br><span class="line">int n,m,i,j;</span><br><span class="line">void Dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">memset(dist,0x3f,sizeof(dist));</span><br><span class="line">memset(value,0x3f,sizeof(value));</span><br><span class="line">memset(used,0,sizeof(used));</span><br><span class="line">dist[s]=0;//从起点开始</span><br><span class="line">value[s]=0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">int k,u=-1,d[1005];</span><br><span class="line">int min=INF;</span><br><span class="line">memset(d,0,sizeof(d));</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">if(used[i]==0&amp;&amp;dist[i]&lt;min)//找出从起点到下一个最小距离的顶点</span><br><span class="line">&#123;</span><br><span class="line">min=dist[i];</span><br><span class="line">u=i;//记录下标</span><br><span class="line">&#125;</span><br><span class="line">if(u==-1)//判断所有顶点是否都到达过</span><br><span class="line">return ;</span><br><span class="line">for(i=1,k=0;i&lt;=n;i++)</span><br><span class="line">if(dist[u]==dist[i]&amp;&amp;used[i]==0)</span><br><span class="line">d[k++]=i;//从起点到下一个要访问的顶点的最小距离可能有多个</span><br><span class="line">for(i=0;i&lt;k;i++)</span><br><span class="line">used[d[i]]=1;</span><br><span class="line">for(i=0;i&lt;k;i++)//多个满足的点分别进行迪杰斯特拉最短路查找</span><br><span class="line">for(j=1;j&lt;=n;j++)</span><br><span class="line">if(g[d[i]][j].adj!=INF &amp;&amp; (dist[d[i]]+g[d[i]][j].adj)&lt;=dist[j])</span><br><span class="line">&#123;//原理与 main()函数中建立邻接矩阵一样</span><br><span class="line">if((dist[d[i]]+g[d[i]][j].adj)&lt;dist[j])</span><br><span class="line">value[j]=value[d[i]]+g[d[i]][j].val;</span><br><span class="line">else</span><br><span class="line">value[j]=Min(value[j],value[d[i]]+g[d[i]][j].val);</span><br><span class="line">dist[j]=dist[d[i]]+g[d[i]][j].adj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (n||m))</span><br><span class="line">&#123;</span><br><span class="line">int a,b,d,p;</span><br><span class="line">memset(g,0x3f,sizeof(g));</span><br><span class="line">for(i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;d,&amp;p);</span><br><span class="line">if(d&lt;=g[a][b].adj)//处理路径距离问题</span><br><span class="line">&#123;</span><br><span class="line">if(d==g[a][b].adj)//如果距离相等，则存放最少的费用</span><br><span class="line">g[a][b].val=g[b][a].val=Min(p,g[a][b].val);</span><br><span class="line">else//否则，存放新路径距离的费用</span><br><span class="line">g[a][b].val=g[b][a].val=p;</span><br><span class="line">g[a][b].adj=g[b][a].adj=d;//填充路径距离</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int s,t;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;s,&amp;t);</span><br><span class="line">Dijkstra(s);</span><br><span class="line">printf(&quot;%d %d\n&quot;,dist[t],value[t]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-足球"><a href="#问题-F-足球" class="headerlink" title="问题 F: 足球"></a>问题 F: 足球</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 3  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1786" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1786&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1786&amp;getkey=C290CA1E34" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1786" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>yoyo得到了一个足球，这个足球与其他的足球一样，表面有 12 个正五边形和 20 个正六边形组成，足球的每个面初始的时候都为白色。现在yoyo把这个足球拆解开来，32个面编号为1~32。爱画画的yoyo希望将足球的某些面涂为黑色（可能是 0 个），在每次涂色操作中，慢慢只可以将某一些相邻或者联通的面一起涂为黑色（两个面相邻当且仅当他们共用一条边）。例如，yoyo可以在一次涂色操作中将面 1、2、3、4、5 涂为黑色，但是他不可以将面11 和 24 涂为白色，因为面 11 和 24 是不相邻也不联通的。求yoyo所需要的最少的涂色次数。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数 t，表示有t组测试数据，对于每组测试数据：</p><p>输入包含一行，该行包含 32 个整数，每个数的值等于 0 时表示白色，等于 1 时表示黑色。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出Case c: ans，其中 c 为测试数据编号，ans 为最少的操作次数。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 0</span><br><span class="line">Case 3: 2</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>除了相邻的数面也相邻外，面 1 和面 13 是相邻的，面 13 和面 17 是相邻的，面 17 和面 32 是相邻的，面 15 和面 32 是相邻的，面 19 和面 32 是相邻的。</p><p>PS:1和32不相邻。</p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>先把所有相邻的点赋值为1，再用Floyd算法把所有点之间的最短距离打表求出来。之后每输入一组样例，则对样例中的1dfs深搜，然后深搜把所有相邻为1且值为1的点重新赋值为0。最后记录下主循环中dfs的次数即可。</p><h2 id="代码参考-5"><a href="#代码参考-5" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 32 + 1;</span><br><span class="line">int dis[maxn][maxn];</span><br><span class="line">int vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(dis,0x3f3f3f3f,sizeof(dis));</span><br><span class="line">    dis[32][32] = 0;</span><br><span class="line">    for(int i = 1; i &lt; maxn - 1; i++)&#123;</span><br><span class="line">        dis[i][i] = 0;</span><br><span class="line">        dis[i][i + 1] = 1;</span><br><span class="line">        dis[i + 1][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[1][13] = dis[13][1] = 1;</span><br><span class="line">    dis[17][13] = dis[13][17] = 1;</span><br><span class="line">    dis[17][32] = dis[32][17] = 1;</span><br><span class="line">    dis[15][32] = dis[32][15] = 1;</span><br><span class="line">    dis[19][32] = dis[32][19] = 1;</span><br><span class="line">    for(int k = 1; k &lt; maxn; k++)&#123;</span><br><span class="line">        for(int i = 1; i &lt; maxn; i++)</span><br><span class="line">            for(int j = 1; j &lt; maxn; j++)</span><br><span class="line">                if(dis[i][j] &gt; dis[i][k]+dis[k][j])</span><br><span class="line">                    dis[i][j] = dis[i][k]+dis[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    vis[x] = 0;</span><br><span class="line">    for(int i = 1; i &lt; maxn; i++)&#123;</span><br><span class="line">        if(vis[i]&amp;&amp;dis[x][i]==1)</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int u = 1;u &lt;= t;u++)&#123;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)</span><br><span class="line">            cin&gt;&gt;vis[i];</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 1; i &lt; maxn; i++)&#123;</span><br><span class="line">            if(vis[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-牌"><a href="#问题-G-牌" class="headerlink" title="问题 G: 牌"></a>问题 G: 牌</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1789" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1789&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1789&amp;getkey=86CA76A96B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1789" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌i，j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>首行输入n，代表n个点</p><p>接下来n行，每一行两个属性ab第i行代表第i张牌，属性为ai，bi。数据范围保持在200以内。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出最大分数</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 4</span><br><span class="line">3 3</span><br><span class="line">1 7</span><br><span class="line">2 5</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">108</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p><h2 id="代码参考-6"><a href="#代码参考-6" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 900000</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">int d; </span><br><span class="line">int pre;</span><br><span class="line">&#125;path;</span><br><span class="line">path to[1000 + 2];</span><br><span class="line">int g[1000 + 2][1000 + 2], vis[1000 + 2]; </span><br><span class="line">void fun(int ddd) &#123;</span><br><span class="line">if (ddd == 1) &#123;</span><br><span class="line">printf(&quot;%d&quot;, ddd);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int j= to[ddd].pre;</span><br><span class="line">fun(j);</span><br><span class="line">printf(&quot; %d&quot;, ddd);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m, a, b, v, i, j, min, k, from;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; </span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">for (j = 0; j &lt;= n; j++) &#123;</span><br><span class="line">g[i][j] = max;</span><br><span class="line">&#125;</span><br><span class="line">to[i].d = max;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; m; i++) &#123; </span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v);</span><br><span class="line">g[a][b] = v;</span><br><span class="line">g[b][a] = v;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">to[i].d = g[1][i];</span><br><span class="line">if (g[1][i] != max) &#123;</span><br><span class="line">to[i].pre = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[1] = 1;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">min = max;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123;</span><br><span class="line">min = to[j].d;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123;</span><br><span class="line">to[j].d = to[k].d + g[k][j];</span><br><span class="line">to[j].pre = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(n);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用模板代码"><a href="#常用模板代码" class="headerlink" title="常用模板代码"></a>常用模板代码</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line">int graph[maxn][maxn];//保存图</span><br><span class="line">int degree[maxn];//保存入度</span><br><span class="line">int TOP[maxn];//保存已删除点</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">    int now = 0；//指针作用记录TOP中可插入的位置</span><br><span class="line">        memset(graph,0,sizeof(graph));</span><br><span class="line">        memset(degree,0,sizeof(degree));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            if(!graph[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                graph[u][v]=1;</span><br><span class="line">                degree[v]++;//v的入度++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(degree[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TOP[now++]=cur;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(graph[cur][i]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    degree[i]--;//相连的点的入度减1</span><br><span class="line">                    if(degree[i]==0)//假设入度为0，增加队列</span><br><span class="line">                        q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里可以添加输出，排序已保存在TOP数组中</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dijkstra（单元最短路径）"><a href="#dijkstra（单元最短路径）" class="headerlink" title="dijkstra（单元最短路径）"></a>dijkstra（单元最短路径）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 107;</span><br><span class="line">const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷inf</span><br><span class="line">int n,m,k,s;</span><br><span class="line">int dis[maxn];  //储存各个点到源点的最短距离,dis[s]为0</span><br><span class="line">int road[maxn][maxn];   //两点之间直接距离关系</span><br><span class="line">bool vis[maxn];     //判断源点到该点的距离是否为最短距离</span><br><span class="line">int fans[maxn];</span><br><span class="line">void dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)</span><br><span class="line">            &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    memset(road,inf,sizeof(road));</span><br><span class="line">    //主函数添加程序与数据以及调用dijkstra</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA（单元最短路径，可带负环）"><a href="#SPFA（单元最短路径，可带负环）" class="headerlink" title="SPFA（单元最短路径，可带负环）"></a>SPFA（单元最短路径，可带负环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int res[N];//存储源点到每个顶点的最短距离值</span><br><span class="line">int g[N][N];</span><br><span class="line">int cnt[N];//每个点入队次数，判断是否出现负环</span><br><span class="line">int que[N*N];//队列</span><br><span class="line">bool in_que[N];//标记一个点是否已在队列中</span><br><span class="line">int front;//队首位置</span><br><span class="line">int rear;//队尾位置</span><br><span class="line">void spfa(int n,int src)</span><br><span class="line">&#123;</span><br><span class="line">    rear=front=0;</span><br><span class="line">    que[++rear]=src;</span><br><span class="line">    memset(res,0x3f3f3f3f,sizeof(res));</span><br><span class="line">    memset(in_que,0,sizeof(in_que));</span><br><span class="line">    res[src]=0;</span><br><span class="line">    while(front&lt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=que[++front];</span><br><span class="line">        in_que[cur]=0;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[cur]+g[cur][i]&lt;res[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]=res[cur]+g[cur][i];</span><br><span class="line">                if(!in_que[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    que[++rear]=i;</span><br><span class="line">                    in_que=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyed（全源最短路径）"><a href="#Floyed（全源最短路径）" class="headerlink" title="Floyed（全源最短路径）"></a>Floyed（全源最短路径）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int k=0; k&lt;n; ++k)</span><br><span class="line">  for (int i=0; i&lt;n; ++i)</span><br><span class="line">    for (int j=0; j&lt;n; ++j)</span><br><span class="line">            /*</span><br><span class="line">            实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j]</span><br><span class="line">            都不是Inf ，只要一个是Inf，那么就肯定不必更新。 </span><br><span class="line">            */</span><br><span class="line">      if (dist[i][k] + dist[k][j] &lt; dist[i][j] )</span><br><span class="line">        dist[i][j] = dist[i][k] + dist[k][j];</span><br></pre></td></tr></table></figure><h2 id="Prim最小生成树"><a href="#Prim最小生成树" class="headerlink" title="Prim最小生成树"></a>Prim最小生成树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">int i,j,k,tmp,ans;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">dis[i]=inf;//初始化 </span><br><span class="line">dis[1]=0;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">tmp=inf;</span><br><span class="line">for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123;</span><br><span class="line">tmp=dis[j];</span><br><span class="line">k=j;</span><br><span class="line">&#125;//找出最小距离的节点 </span><br><span class="line">&#125;</span><br><span class="line">vis[k]=1;//把访问的节点做标记</span><br><span class="line">for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;dis[j]&gt;map[k][j])</span><br><span class="line">dis[j]=map[k][j];//更新最短距离 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1007;</span><br><span class="line">int n,m;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int l;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line">int fa[maxn];</span><br><span class="line">int init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i&lt;maxn; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int findfa(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return fa[x] == x ? x : (fa[x] = findfa(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int merge_1(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    fa[findfa(x)] = findfa(y);</span><br><span class="line">&#125;</span><br><span class="line">int kruskal()</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i&lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int fx = findfa(edge[i].x);</span><br><span class="line">        int fy = findfa(edge[i].y);</span><br><span class="line">        if(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            merge_1(fx,fy);</span><br><span class="line">            cnt++;</span><br><span class="line">            sum+=edge[i].l;</span><br><span class="line">            if(cnt&gt;=n-1)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    //此处填写边以及点等待输入数据，填写完成后须对边的权值进行排序</span><br><span class="line">    kruskal();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题-A-签到题之青蛙爬楼梯&quot;&gt;&lt;a href=&quot;#问题-A-签到题之青蛙爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;问题 A: 签到题之青蛙爬楼梯&quot;&gt;&lt;/a&gt;问题 A: 签到题之青蛙爬楼梯&lt;/h1&gt;&lt;p&gt;时间限制: 1 Sec  内存限制: 1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图论基础课件（拓扑排序+最短路+最小生成树）</title>
    <link href="http://qianyouyou.cn/2018/07/26/2018-07-26-1/"/>
    <id>http://qianyouyou.cn/2018/07/26/2018-07-26-1/</id>
    <published>2018-07-26T04:26:14.000Z</published>
    <updated>2018-08-14T04:36:57.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>图论起源于著名的哥尼斯堡七桥问题。在哥尼斯堡的普莱格尔河上有七座桥将河中的岛及岛与河岸联结起来问题是要从这四块陆地中任何一块开始，通过每一座桥正好一次，再回到起点。然而无数次的尝试都没有成功。欧拉在1736年解决了这个问题，他用抽像分析法将这个问题化为第一个图论问题：即把每一块陆地用一个点来代替，将每一座桥用联接相应的两个点的一条线来代替，从而相当于得到一个“图”。欧拉证明了这个问题没有解，并且推广了这个问题，给出了对于一个给定的图可以某种方式走遍的判定法则。这就是后来的欧拉路径和欧拉回路。这项工作使欧拉成为图论〔及拓扑学〕的创始人。</p><h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>若图G中存在这样一条路径，使得它恰通过G中每条边一次,则称该路径为欧拉路径。若该路径是一个圈，则称为欧拉(Euler)回路。</p><p>定理：（一）一个图有欧拉回路当且仅当它是连通的且每个顶点都有偶数度。（二）一个图有欧拉通路当且经当它是连通的且除两个顶点外，其他顶点都有偶数度。</p><p>在第二个定理下，含奇数度的两个节点中，一个必为欧拉通路起点，另一个必为欧拉通路的终点。</p><h2 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么"></a>图是什么</h2><p>图的的定义      图是由顶点V的集合和边E的集合组成的二元组：             </p><p>记G=（V，E）    存在一个结点v，可能含有多个前驱结点和后继结点。</p><h2 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h2><p>有向图</p><p>无向图</p><p>无权图</p><p>带权图</p><p>连通图</p><p>二分图…</p><p>有向图:    点与有向边的集合</p><p>带权图（网）：图中的边加上表示某种含义的数值，数值称为边的权</p><p>连通：两顶点间有路可通。</p><p>连通图：能连成一片的图。</p><p>连通分量：无向图中的极大连通子图</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>​    在图G=（V，E）中，如果对于结点a，b，存在满足下述条件的结点序列x1……xk(k&gt;1)        ⑴ x1=a，xk=b     ⑵ (xi，xi+1)∈E         i=1‥k-1则称结点序列x1=a，x2，…，xk=b为结点a到结点b的一条路径，而路径上边的数目（k-1）称为该路径的长度。</p><p>图1: 1、(1,2,3,5)    长度=3        2、(1,2,3,5,2)  长度=4        3、(1,2,5,4,1)  长度=4</p><p>图2: (1,2,5,4) 长度=3</p><p>若起点与终点相同着为环（也叫做回路）</p><h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>在无向图中：顶点v的度是指与顶点v相连的边的数目。D( 2 )=3</p><p>在有向图中：入度——以该顶点为终点的边的数目 . ID(3)=2  出度——以该顶点为起点的边的数目 . OD(3)=1度：等于该顶点的入度与出度之和。D(5)=ID(5)+OD(5)=1+2=3 </p><h2 id="太多了，有时间再添加"><a href="#太多了，有时间再添加" class="headerlink" title="太多了，有时间再添加"></a>太多了，有时间再添加</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;图论起源于著名的哥尼斯堡七桥问题。在哥尼斯堡的普莱格尔河上有七座桥将河中的岛及岛与河岸联结起来问题是要从这四块陆地中任何一块开始，通过每一座
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>7.20-stl专项训练题解</title>
    <link href="http://qianyouyou.cn/2018/07/20/2018-07-20/"/>
    <id>http://qianyouyou.cn/2018/07/20/2018-07-20/</id>
    <published>2018-07-20T07:00:15.000Z</published>
    <updated>2018-07-20T16:36:36.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h1><p>问题A同问题B，具体方法在问题B中介绍，此处仅贴代码</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p><p>对于每一行，输入四个整数a，b，c，d</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每组样例，输出一个整数表示答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 9;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">init();//打表</span><br><span class="line">ll ans = 1;</span><br><span class="line">//这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">//将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-yoyo思维题-困难"><a href="#问题-B-yoyo思维题-困难" class="headerlink" title="问题 B: yoyo思维题(困难)"></a>问题 B: yoyo思维题(困难)</h1><p>问题A同问题B</p><p>提交: 4  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1731" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1731&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1731&amp;getkey=4DE1A19111" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1731" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小琳，小花，小薇，yoyo，他们每个人手上有一堆牌，牌的张数分别为x1，x2，x3，x4，每张牌都不一样。现有n名同学，n=x1+x2+x3+x4。每名同学均需要一张牌，于是他们按顺序每人随机到四个人那里拿取牌顶的一张牌，最后一个人刚好拿到剩下的最后一张牌。排队拿牌的同学的顺序是固定的，选择拿谁的牌是不确定的。假如发牌的人手上的牌发完了，则要拿牌的同学会选择其他发牌的人。请问有多少种取法取走所有的牌。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p><p>对于每一行，输入四个整数a，b，c，d，输入为均不超过500的正整数</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组样例，输出一个整数表示答案，答案对10^9+7取模</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 4 2 3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题作为思维题，并未用到stl，仅锻炼一下大家解决问题的能力。用到的数学知识相对多一点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是C(b,a+b);那么三堆的话我们可以把前两堆看成一堆，那么表达式就是C(c,a+b+c)，这是我们需要与前两堆的组成方法相乘，就是C(b,a+b)C(c,a+b+c)。4堆的话就是C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。所以答案就是C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。此外，有一公式C(a,b) = C(a,b-1)+C(a-1,b-1)，所以我们用数组来代替C(m,n)操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">init();//打表</span><br><span class="line">ll ans = 1;</span><br><span class="line">//这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">//将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-悠派计算器"><a href="#问题-C-悠派计算器" class="headerlink" title="问题 C: 悠派计算器"></a>问题 C: 悠派计算器</h1><p>提交: 4  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1732" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1732&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1732&amp;getkey=C0EA34F688" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1732" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>yoyo的小老弟小渣渣灰特别懒，兴趣爱好并不多，就睡觉一个。为了多睡会儿懒觉，他把数学老师布置的作业全部推给yoyo计算。yoyo很头疼，于是请你帮他写一个计算器帮忙计算。现有多个数学表达式，请你写一个计算器算出结果，表达式只包含’+’’-‘’*’’/‘’%’’(‘’)’操作，其中表达式中’-‘作为减运算符，不会作为负号出现，此外’/‘为整除运算符，’%’为取余运算符。表达式保证合法。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>输入第一行t，表示共有t行测试用例，接下来t行每一行均为一个合法的数学表达式。保证每个数在[09999]范围内，保证计算过程中不会出现超范围情况。（注：没有空格）</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出计算结果</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">0*1</span><br><span class="line">5%6</span><br><span class="line">1-2*(3+4*5%6)+7/8-9*10%11*12</span><br><span class="line">(1+2*3)</span><br><span class="line">1-(100%5)</span><br><span class="line">(3+2*5)/(5)</span><br><span class="line">(11-11)+(33)*64-11</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br><span class="line">-135</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2101</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据很水，不用考虑long long或取余等情况。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)<em>(c+d)转换为ab+cd+</em></p><p>如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。</p><p>例如(a+b)<em>(c+d)转换为ab+cd+</em>   计算机在计算普通表达式时，要对运算优先级用递归进行判断，对于更为复杂的表达式会使计算机运算效率变低甚至崩溃。而逆波兰表达式只需要进行简单的入栈出栈操作就可以完成任何普通表达式的运算。</p><p>普通表达式——&gt;逆波兰表达式</p><p>(1)a+b——&gt;a b +</p><p>(2)a+(b-c)——&gt;a b c - +</p><p>(3)a+(b-c)<em>d——&gt;a b c -  d </em> +</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 100007;</span><br><span class="line">map&lt;char,int&gt;Pri;//其实可以不必用map，只是为了方便大家理解map而多添加的一步</span><br><span class="line">stack&lt;int&gt;num;</span><br><span class="line">stack&lt;char&gt;Ope;</span><br><span class="line">char str[maxn];</span><br><span class="line">//初始化</span><br><span class="line">void init()&#123;</span><br><span class="line">    Pri[&apos;+&apos;] = Pri[&apos;-&apos;] = 1;</span><br><span class="line">    Pri[&apos;*&apos;] = Pri[&apos;/&apos;] = Pri[&apos;%&apos;] = Pri[&apos;(&apos;] = Pri[&apos;)&apos;] = 2;</span><br><span class="line">    while(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    while(!Ope.empty())</span><br><span class="line">        Ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">//基本运算操作</span><br><span class="line">void operation_1(int &amp;a,int &amp;b, char c)&#123;</span><br><span class="line">    if(c == &apos;+&apos;)</span><br><span class="line">        a += b;</span><br><span class="line">    else if(c == &apos;-&apos;)</span><br><span class="line">        a = b-a;</span><br><span class="line">    else if(c == &apos;*&apos;)</span><br><span class="line">        a *= b;</span><br><span class="line">    else if(c == &apos;/&apos;)</span><br><span class="line">        a = b/a;</span><br><span class="line">    else if(c == &apos;%&apos;)</span><br><span class="line">        a = b%a;</span><br><span class="line">&#125;</span><br><span class="line">//遇到+或者)时执行的操作</span><br><span class="line">void operation_2()&#123;</span><br><span class="line">    char ch = Ope.top();</span><br><span class="line">        while(ch != &apos;(&apos;&amp;&amp;!Ope.empty())&#123;</span><br><span class="line">            Ope.pop();</span><br><span class="line">            int a = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            operation_1(a,b,ch);</span><br><span class="line">            num.push(a);</span><br><span class="line">            if(!Ope.empty())</span><br><span class="line">                ch = Ope.top();</span><br><span class="line">        &#125;</span><br><span class="line">        if(!Ope.empty()&amp;&amp;Ope.top() == &apos;(&apos;)</span><br><span class="line">            Ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;getchar();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin.getline(str,maxn);</span><br><span class="line">        stringstream s(str);</span><br><span class="line">        init();</span><br><span class="line">        char tmp;</span><br><span class="line">        while(s &gt;&gt; tmp)&#123;</span><br><span class="line">        //遇到数字字符时，需要判断下一位是否依旧是数字，是的话需要合并</span><br><span class="line">            if(tmp &gt;= &apos;0&apos; &amp;&amp; tmp &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                int t = 0;</span><br><span class="line">                do&#123;</span><br><span class="line">                    if(Pri[tmp])&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t *= 10;</span><br><span class="line">                    t += tmp - &apos;0&apos;;</span><br><span class="line">                &#125;while(s &gt;&gt; tmp);</span><br><span class="line">                num.push(t);</span><br><span class="line">            &#125;</span><br><span class="line">            //遇到&apos;)&apos;时</span><br><span class="line">            if(tmp == &apos;)&apos;)&#123;</span><br><span class="line">                operation_2();</span><br><span class="line">            &#125;</span><br><span class="line">            //遇到&apos;+&apos; ‘-’时</span><br><span class="line">            else if(Pri[tmp]==1)&#123;</span><br><span class="line">                if(!Ope.empty()&amp;&amp;Ope.top()!=&apos;(&apos;)&#123;</span><br><span class="line">                    operation_2();</span><br><span class="line">                &#125;</span><br><span class="line">                Ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(Pri[tmp])&#123;</span><br><span class="line">                Ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        while(!num.empty()&amp;&amp;!Ope.empty())&#123;</span><br><span class="line">            operation_1(ans,num.top(),Ope.top());</span><br><span class="line">            Ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-留胡子"><a href="#问题-D-留胡子" class="headerlink" title="问题 D: 留胡子"></a>问题 D: 留胡子</h1><p>提交: 53  解决: 6<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1733" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1733&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1733&amp;getkey=3B707F894D" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1733" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>众所周知，刘虎子同学爱留胡子，人送外号刘胡子。为了留一抹性感又忧郁的小胡子，刘虎子专门与yoyo合作研发了一套算法，俗称油胡子算法。油胡子算法原理很简单，要想获得油胡子，首先将胡子从左到右分为n撮胡子，第i撮胡子的平均长度为xi。现每次从n中选出最左边的相邻胡子长度之差的绝对值为1的两撮胡子，减掉较长的1撮胡子，减掉的那撮胡子可以认为从n撮胡子中删除，剩下n-1撮胡子待修剪，再将剩下的n-1撮胡子从左到右重新排列成相邻的数继续如此操作，直到没有两撮相邻差的绝对值为1的胡子为止。此时的胡子称为完美油胡子。请问刘虎子同学最多需要剪多少次才能得到自己心仪的性感小胡子。</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入第一行为n，接下来一行n个数x1x2…xi…xn。</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出最多执行次数。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">3 2 3 1 0 1</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p><strong>用栈来维护每次合并完的数，每入栈一个数以后栈顶和次栈顶比较，如果可以合并就合并为新的栈顶，并且再次与次栈顶比较直至无法合并，在合并过程中统计次数即可。</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,x;</span><br><span class="line">int ans=0;     //最大操作次数</span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">//将x与当前栈顶元素st.top()比较，若栈不空且st.top()比x大1，则合并一次(此时即当前栈顶元素出栈)</span><br><span class="line">//然后x与次栈顶比较，以此类推，直到不满足栈不空且st.top()比x大1</span><br><span class="line">while(!st.empty() &amp;&amp; st.top()-x==1)</span><br><span class="line">&#123;</span><br><span class="line">st.pop();</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">//若栈不空且x比st.top()大1，则合并一次</span><br><span class="line">//(此时即x&quot;出栈&quot;，也就是忽略此x继续看下一个输入的x 但栈不发生任何变化)</span><br><span class="line">if(!st.empty() &amp;&amp; x-st.top()==1)</span><br><span class="line">ans++;</span><br><span class="line">//其他情况(x为第一个元素或不满足上述两种情况)：将x入栈</span><br><span class="line">else</span><br><span class="line">st.push(x);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-卜卦"><a href="#问题-E-卜卦" class="headerlink" title="问题 E: 卜卦"></a>问题 E: 卜卦</h1><p>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?id=1734" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1734" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1734" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1734&amp;getkey=7E5D1F2620" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1734" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>赵神是一个特别特别闷骚的人。别看他平日表现很高冷，其实他一直暗恋着自己的小迷妹小花花，一日不见兮，思之如狂。马上快七夕了，赵神想卜一卦算一下他的爱情幸运数，于是他找到了yoyo半仙替他卜卦。yoyo半仙需要赵神的3个幸运数字以及小花花的3个幸运数字方可进行卜卦。已知赵神的3个幸运数字是’5’’2’’0’而小花花的幸运数字是abc，(保证由5，2，0，a，b，c，这6个数各不相同，且abc均为30以内的素数)。卜卦规则如下：<br>由{520abc}组成的6个各不相同数中选取最小的3个数作为加数，其余最大的3个数作为基数。每一个数若加上加数仅能被基数整除，其他素数均不能整除，则该数称为幸运数。其中第1314个幸运数为爱情幸运数。<br>现在你刚好知道小花花的幸运数，请你帮yoyo完成卜卦吧。PS：顺利完成任务后则会收获赵神珍藏版kiss一枚。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p><p>接下来t行输入三个数abc。</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出第1314个幸运值</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7 3 11</span><br><span class="line">7 11 13</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">29541015622</span><br><span class="line">1775105893556</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>待写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int fort = 1314;</span><br><span class="line">ll coeff[6];</span><br><span class="line">int cmp(ll a,ll b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;coeff[0]&gt;&gt;coeff[1]&gt;&gt;coeff[2];</span><br><span class="line">        coeff[3] = 5;</span><br><span class="line">        coeff[4] = 2;</span><br><span class="line">        coeff[5] = 0;</span><br><span class="line">        sort(coeff,  coeff + 6, cmp);</span><br><span class="line">        priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        set&lt;ll&gt;s;</span><br><span class="line">        set&lt;ll&gt;ans;</span><br><span class="line">        pq.push(1);</span><br><span class="line">        s.insert(1);</span><br><span class="line">        for(int i = 0;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(i)&#123;</span><br><span class="line">                for(int k = 3;k &lt; 6;k++)&#123;</span><br><span class="line">                    ans.insert(x - coeff[k]);</span><br><span class="line">                    if(ans.size()==fort)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans.size()==fort)&#123;</span><br><span class="line">                    /*int ttt = 1;</span><br><span class="line">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span><br><span class="line">                        cout&lt;&lt;ttt++&lt;&lt;&apos; &apos;&lt;&lt;*it&lt;&lt;endl;*/</span><br><span class="line">                    set&lt;ll&gt;::reverse_iterator it = ans.rbegin();</span><br><span class="line">                    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0;j&lt;3;j++)&#123;</span><br><span class="line">                ll x2=x*coeff[j];</span><br><span class="line">                if(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-成绩互评"><a href="#问题-F-成绩互评" class="headerlink" title="问题 F: 成绩互评"></a>问题 F: 成绩互评</h1><p>提交: 117  解决: 40<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1738" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1738&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1738&amp;getkey=9C71BFBEA7" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1738" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>学生互评作业的简单规则是这样定的：每个人的作业会被k个同学评审，得到k个成绩。系统需要去掉一个最高分和一个最低分，将剩下的分数取平均，就得到这个学生的最后成绩。本题就要求你编写这个互评系统的算分模块。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入第一行给出3个正整数N（3&lt; N &lt;= 104，学生总数）、k（3&lt;= k &lt;= 10，每份作业的评审数）、M（&lt;= 20，需要输出的学生数）。随后N行，每行给出一份作业得到的k个评审成绩（在区间[0 100]内），其间以空格分隔。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>按非递减顺序输出最后得分最高的M个成绩，保留小数点后3位。分数间有1个空格，行首尾不得有多余空格。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 5 3</span><br><span class="line">88 90 85 99 60</span><br><span class="line">67 60 80 76 70</span><br><span class="line">90 93 96 99 99</span><br><span class="line">78 65 77 70 72</span><br><span class="line">88 88 88 88 88</span><br><span class="line">55 55 55 55 55</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">87.667 88.000 96.000</span><br></pre></td></tr></table></figure><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p><strong>total数组保存各个同学的平均分，v数组保存每次接收得到的分数，排序后取前m名，按递增输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int cmp(double a, double b) &#123;</span><br><span class="line">return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int N, K, M;</span><br><span class="line">while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; M) &#123;</span><br><span class="line">vector&lt;double&gt;v(K);</span><br><span class="line">vector&lt;double&gt;v2(N);</span><br><span class="line">for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">double sum = 0;</span><br><span class="line">for (int j = 0; j &lt; K; j++) &#123;</span><br><span class="line">cin &gt;&gt; v[j];</span><br><span class="line">sum += v[j];</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(), v.end(), cmp);</span><br><span class="line">sum -= v[0] + v[K - 1];</span><br><span class="line">sum /= K - 2;</span><br><span class="line">v2[i] = sum;</span><br><span class="line">&#125;</span><br><span class="line">sort(v2.begin(), v2.end(), cmp);</span><br><span class="line">for (int i = M - 1; i &gt; 0; i--)</span><br><span class="line">printf(&quot;%.3lf &quot;, v2[i]);</span><br><span class="line">printf(&quot;%.3lf\n&quot;, v2[0]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-列车"><a href="#问题-G-列车" class="headerlink" title="问题 G: 列车"></a>问题 G: 列车</h1><p>提交: 18  解决: 10<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1736" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1736&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1736&amp;getkey=EDCA6F0278" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1736" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>火车站的列车调度铁轨的结构如下图所示。<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/07/Snip20160719_118.png" alt="img">tle=”” align=”” /&gt;</p><p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>输入第一行给出一个整数N (2 &lt;= N &lt;= 105)，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">8 4 2 5 3 9 1 6 7</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p><strong>必须要车号大的先出，小的后出。所以列车排队的每一队必须是从大到小排列（从右往左看），才能保证开出去的车也是从大到小的。</strong> <strong>对于每一个想要进入并列铁轨的车，如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨</strong> <strong>否则，选择一个最接近它车号的尾部车号的队伍进入</strong> <strong>其实无需保存每一个并行队列的所有值，只需要保存当前队伍的车尾（就是每一列最左边 即 每一列的最小值）即可</strong> <strong>因为每一次都是需要排序比较大小的，所以用set自动排序</strong> <strong>首先把set里面放入一个0值。每一次set的最后一个值s.rbegin()都是当前所有队列队尾的最大值.</strong> <strong>如果当前想要进入排队队伍的t值比集合里面最大值小，就移除第一个比他大的值，然后把t插入集合中。表示的是将t值插入了最接近它车号的队伍的队尾</strong> <strong>否则就直接插入进去t值。作为新的队伍。</strong>s.upper_bound(t)返回的是第一个大于t的迭代器的位置<strong> </strong>在前面加星号表示取这个位置的值<strong> </strong>所以s.erase(*(s.upper_bound(t)));表示删除当前这个刚好大于t的位置处的值<strong> </strong>因为一开始插入了一个没有的0，所以最后输出是s.size()-1。** </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    s.insert(0);</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        if(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.size() - 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-H-新浪关注"><a href="#问题-H-新浪关注" class="headerlink" title="问题 H: 新浪关注"></a>问题 H: 新浪关注</h1><p>提交: 24  解决: 14<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1737" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1737&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1737&amp;getkey=EB2FC0BAF0" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1737" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入首先在第一行给出某用户的关注列表，格式如下：</p><p>人数N 用户1 用户2 …… 用户N</p><p>其中N是不超过5000的正整数，每个“用户i”（i=1 … N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。</p><p>之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao</span><br><span class="line">8</span><br><span class="line">Magi 50</span><br><span class="line">Pota 30</span><br><span class="line">LLao 3</span><br><span class="line">Ammy 48</span><br><span class="line">Dave 15</span><br><span class="line">GAO3 31</span><br><span class="line">Zoro 1</span><br><span class="line">Cath 60</span><br></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ammy</span><br><span class="line">Cath</span><br><span class="line">Pota</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p><strong>将关注的人存储在集合set里，将点赞的人和点赞的次数存储在map中，并统计点赞的平均次数sum / M，遍历map，如果map的值大于平均次数，且在set中找不到该用户名，就输出当前用户名（因为map中的键是已经按照字典序排序过的，所以直接输出就可以），并用flag标记是否有过输出，如果从始至终没有输出，说明没有悄悄关注的人，就输出Bing Mei You</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int m, n;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">set&lt;string&gt;id;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">id.insert(name);</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">map&lt;string, int&gt;mm;</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">int cnt;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str &gt;&gt; cnt;</span><br><span class="line">mm[str] = cnt;</span><br><span class="line">sum += cnt;</span><br><span class="line">&#125;</span><br><span class="line">sum /= m;</span><br><span class="line">int flag = 0;</span><br><span class="line">for (auto it : mm) &#123;</span><br><span class="line">if (it.second &gt; sum&amp;&amp;id.find(it.first) == id.end()) &#123;</span><br><span class="line">cout &lt;&lt; it.first &lt;&lt; endl;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!flag)</span><br><span class="line">cout &lt;&lt; &quot;Bing Mei You&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-I-礼物"><a href="#问题-I-礼物" class="headerlink" title="问题 I: 礼物"></a>问题 I: 礼物</h1><p>提交: 94  解决: 44<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1739" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1739&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1739&amp;getkey=09962A88B1" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1739" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>四月一日快到了，Vayko想了个愚人的好办法——送礼物。嘿嘿，不要想的太好，这礼物可没那么简单，Vayko为了愚人，准备了一堆盒子，其中有一个盒子里面装了礼物。盒子里面可以再放零个或者多个盒子。假设放礼物的盒子里不再放其他盒子。<br>用()表示一个盒子，B表示礼物，Vayko想让你帮她算出愚人指数，即最少需要拆多少个盒子才能拿到礼物。 </p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>本题目包含多组测试，请处理到文件结束。<br>每组测试包含一个长度不大于1000只包含’(‘’)’和’B’三种字符的字符串，代表Vayko设计的礼物透视图。<br>你可以假设，每个透视图画的都是合法的。 </p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试，请在一行里面输出愚人指数。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((((B)()))())</span><br><span class="line">(B)</span><br></pre></td></tr></table></figure><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p><strong>看上去像是编译原理的文法识别，要用到栈，其实不是，只要看准备上面红色的字，就知道，只有三种字符()B，且待处理的串为合法的文法，所以要知道包装盒的个数，只要知道B前面有多少(字符，但可能有(()B)这种情况，B前面有)，但因为合法，所以可以在B之前的找到(与)相匹配，就剔除掉了，所以盒子的个数就是B之前的串中(的个数减去)的个数。</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">string str;</span><br><span class="line">while (cin &gt;&gt; str) &#123;</span><br><span class="line">int sco = 0;</span><br><span class="line">for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">if (str[i] == &apos;(&apos;)</span><br><span class="line">sco++;</span><br><span class="line">else if (str[i] == &apos;)&apos;)</span><br><span class="line">sco--;</span><br><span class="line">else if (str[i] == &apos;B&apos;)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sco &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-J-Sunscreen"><a href="#问题-J-Sunscreen" class="headerlink" title="问题 J: Sunscreen"></a>问题 J: Sunscreen</h1><p>题意：有C头奶牛要去沐光浴，太阳光太强烈会晒坏皮肤，太弱又会没效果。每头牛都有一个太阳光适宜的范围经行沐光浴，分别给出minspf_i和maxspf_i。  有L种防晒霜，每种防晒霜可以把所受阳光固定于一个值spf_i，每种有cover_i瓶。  问最多会有几头牛得到合适的光晒强度？ </p><p><strong>题解：贪心策略，在满足minspf的条件下，尽量将spf的防晒霜涂到maxspf小的奶牛身上，因为maxspf大的奶牛有更多的选择。这里就需要一个优先队列来储存满足minspf的奶牛的maxspf的值。     具体解题步骤如下：</strong></p><p><strong>1.将奶牛按照minspf升序排列，将防晒霜按照spf升序排列。</strong></p><p><strong>2.枚举防晒霜，将minspf&lt;=spf的奶牛的maxspf存到优先队列中，然后值小的先出队列，看是否满足maxspf&gt;=spf，更新记录值。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 12505;</span><br><span class="line">struct spf &#123;</span><br><span class="line">int max;</span><br><span class="line">int min;</span><br><span class="line">friend bool operator &lt; (spf a, spf b) &#123;</span><br><span class="line">return a.min &lt; b.min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cow[MAXN], bot[MAXN];</span><br><span class="line">struct cmp &#123;</span><br><span class="line">bool operator()(const int a, const int b)const &#123;</span><br><span class="line">return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int C, L, i;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;pq;</span><br><span class="line">while (cin &gt;&gt; C &gt;&gt; L) &#123;</span><br><span class="line">for (i = 0; i &lt; C; i++)</span><br><span class="line">cin &gt;&gt; cow[i].min &gt;&gt; cow[i].max;</span><br><span class="line">for (i = 0; i &lt; L;i++)</span><br><span class="line">cin &gt;&gt; bot[i].min &gt;&gt; bot[i].max;</span><br><span class="line">sort(cow, cow + C);</span><br><span class="line">sort(bot, bot + L);</span><br><span class="line">int cur = 0, ans = 0;</span><br><span class="line">for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">while(cur &lt; C&amp;&amp;cow[cur].min &lt;= bot[i].min) &#123; </span><br><span class="line">pq.push(cow[cur].max); </span><br><span class="line">cur++; </span><br><span class="line">&#125;</span><br><span class="line">while(!pq.empty()&amp;&amp;bot[i].max) &#123; </span><br><span class="line">int maxSPF = pq.top(); </span><br><span class="line">pq.pop();</span><br><span class="line">if(maxSPF &gt;= bot[i].min)&#123;</span><br><span class="line">ans++; </span><br><span class="line">bot[i].max--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题A&quot;&gt;&lt;a href=&quot;#问题A&quot; class=&quot;headerlink&quot; title=&quot;问题A&quot;&gt;&lt;/a&gt;问题A&lt;/h1&gt;&lt;p&gt;问题A同问题B，具体方法在问题B中介绍，此处仅贴代码&lt;/p&gt;
&lt;h2 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[少年班]天分与平凡，青春与坚守</title>
    <link href="http://qianyouyou.cn/2018/07/14/2018-07-14/"/>
    <id>http://qianyouyou.cn/2018/07/14/2018-07-14/</id>
    <published>2018-07-14T14:15:12.000Z</published>
    <updated>2018-07-15T16:57:08.453Z</updated>
    
    <content type="html"><![CDATA[<p>好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初心呢；或许是经历过许许多多次起起伏伏，遇见过形形色色想遇或不想遇的人或事，又怀念起那段那段青涩的高中岁月；或许只是单纯的想再看看这部电影吧。不管为何，总之现在思绪万千。就让我将这万千的思绪草草记录一下吧。</p><p>这部电影剧情很简单，讲述的是几个天才少年与一个平凡少年被发掘功课数学难题却因青春的叛逆与时代的变迁而成长的故事。故事以主人公以吴未的少年班回忆而展开，主人公吴未就是那个平凡的少年。</p><p>少年班，顾名思义就是大学里专为年纪轻轻却智商非凡的天才们开设的精英班，某知名大学老师周知庸曾经就是少年班的成员，他的梦想是攻克IMC的题目，但曾经的他未能实现，于是将希望寄托在新时代的少年身上。在他的坚持下从全国各地找到了几名心仪的人选，其中包括了吴未。</p><p>然而，像其他天才系列电影一样，天才们拥有着平凡人所羡慕的才能之外，往往却拥有着平凡人所不能理解的烦恼。天才少年方厚政年纪最小，却智商超群，可谓前途无量，只是他IQ高。EQ却低，因此没有什么朋友。天才少年麦克因家庭原因而性格叛逆，打架斗殴无所不为。天才少年王大法无拘无束，自由散漫，因此总让别人捉摸不透，不想与之有交集。天才少女周兰品学兼优，是典型的别人家的子，但也是因为优秀而让所有人都敬而远之。但是和其他电影不同的是，这些天才们不可思议的烦恼其实我们都能理解。毕竟曾经或现在处于青春期的我们哪一个人曾经没有过类似的烦恼呢？他们的性格不过是我们所有人青春期各种性格的集合并放大罢了。</p><p>当然，我们的主人公也有着自己的烦恼，身为平凡人的代表，当他进入少年班后从之前的全校第二摇身一变变成班上的倒数第一，这种落差估计每个处于青春期的孩子都受不了吧。于是他一边仰望着天才们过人的天赋，一边忍受着天才们怪异的性格，一边照顾着正处于青春期幼稚的天才们，一边独自默默努力着，为了自己心中的荣誉。然而，努力在这满是天才的地方却显得那么多余。就在他一筹莫展，开始疑惑为何老师选中他的时候，周知庸老师出现，解开了她的心结。“运送金枪鱼的时候，要在里面混进几条鲶鱼，否则金枪鱼就会因懒惰而死，到不了岸。”老师鼓励他做好自己鲶鱼的身份，因为天才们离开了它的照顾就会堕入深渊。尽管是鲶鱼，但吴未却似乎找到了自己的归宿，并以此为荣，从此，吴未以天才们的快乐为快乐，以天才们的梦想为梦想，就在自己喜欢的人面前，也只能呼喊着天才们所喜欢的校花名字。</p><p>IMC马上开始了，老师想进各种办法激励着天才们去努力钻研，但是恃才傲物并且正处于青春期的天才们又怎会把新鲜的大学生活浪费在学习上呢？趁着大学生活的新鲜感犹在，天才们渐渐被校花江依琳所吸引，从此各种各样的新奇表白开始了。只有吴未从一开始就暗恋着同班的天才少女周兰。尽管周兰从来都看不起吴未，并且单恋这少年班的迈克。</p><p>比赛前一天，几名少年班朝夕相处的小伙伴们在酒后发泄着各种各样青春期的passion，来到女生宿舍楼下，大声表白校花，那一刻，漫天飞舞的纸花，洋洋洒洒，似乎整个世界都在期待着几个天才少年去改变。</p><p>比赛的一个月里，天才们尽管出现各种各样的矛盾，但在吴未的调节下，无伤大雅。但一次偶遇，校花与富家公子哥之间的隐曲之事深深刺激到了天才们。他们落荒而逃，逃得那么彻底。</p><p>老师闻讯，拿起了酒杯，向舞台赶去。天才们旧气难言，拿起了自制的化学炸药，向富二代的车赶去。老师将酒水泼向校花，门外传来雷鸣般的爆炸。这一刻，老师的梦想毁了，天才们的前途毁了，然而，世界依然有活力地在转，一如既往。</p><p>然而，老师仍心怀希望，尽力将此事最小化解决。这边，王大法作为被开除的学生被家人拖走，那边，吴未望向楼上的橱窗，老师站在橱窗望着吴未。这一刻，吴未明白，自己的价值将要发挥了。就这样，吴未顶替其他天才们而被学校开除。</p><p>奔驰的归家车上，吴未哭的撕心裂肺，将自己仅有的一枚荣誉勋章扔向窗外，像扔去回忆一样。身后周兰，方厚政，迈克，追的精疲力尽，他们将过去的笔记本扔向追不上的公交车，像追随友谊一样。</p><p>最终，天才们并没有解出题，也没有改变世界，但他们最终都找到了自己的方向。周知庸老师最后没能实现自己的天才梦，也丢掉了工作，像人间蒸发一样，随旧时代而去，但他却找到了自己的人生伴侣。吴未，平淡无味，但又快乐的漂浮着。</p><p>这部影片最大的亮点就在于其真实性。首先，少年班的故事从1978年起一直延续着。然而，随着时代的发展，如今的少年班已不复存在了。旧时代里，时代的推进是由天才们推进的，这就是为何周知庸老师为何执着于天才的原因之一。就像他说的，“高斯十七岁就发现了第二相反定理，这些天才当时他们不敢发表，因为怕人们不信。”因为这种理念的支撑，让他对所有平凡人带上了有色眼镜，以至于四十多岁依旧单身。然而，过去毕竟是过去，世界上有很多天才，但只有一个高斯，只有一个牛顿，只有一个爱因斯坦。牛顿他们所带表的这类基础科学并不是一个人所完成的，它需要所处时代的支持以及现有技术的支撑，就像牛顿自己也说过，自己是站在巨人肩膀上的，况且牛顿从未说过自己是天才，自己只是热爱探索而已，因此，想要天才改变世界的周知庸老师从一开始就错了，因为他不懂平凡人的价值，所以，他没有牛顿的成就，与牛顿唯一的共同点就是一直单身。世界是一个多元化的世界，不只是理论的世界，如果说基础科学是时代质的飞跃，那应用科学就是时代量的积累、倘若基础科学离开了应用科学，那么世界依旧停滞不前，基础科学反而成为了最没用的东西。故事的结尾，天才们并没有从事科研工作，而是选择了自己所喜欢的岗位，他们没有改变世界，只是生活的比平凡人更潇洒。平凡与天赋，其实离开谁都不行，正是因为天才们的研发，广大平凡的劳动者的坚持工作与制作，才使得这个世界不断推进向前。</p><p>然而，少年班不适宜于当下最主要的原因还是心智的为题。尽管天才们智商超群，但是年纪与经历更重要。十几岁就步入大学校门，尽管他们智商达标了，但心智并未达标。电影中表现的淋淋尽致。他们从未接触过社会，也并不懂得什么是责任，当然，那个时代的我们都一样，在心智上，人人都是平等的。我们就来分析一下各个主人公吧。</p><p>首先是主人公方厚政。作为年纪最小的天才，他的心情，性格，全都写在了脸上。目测智商150，心理年龄只有9岁。遇到委屈就哭，遇到自己看不上的事就挖苦，总之这个世界上只有自己是最厉害的，当面对丰富多彩的大学生活，他又怎会抵挡住各种各样的新鲜事物而去专心钻研呢。主人公迈克，看似成熟，其实心智同样幼稚，面对所有事第一个想到的就是用拳头来解决，从不会考虑后果。主人公王大法自由散漫，每天吃着馒头，听着经文，一副玩世不恭的样子。主人公周兰，可以说是所有优秀的女孩的代表，可以说是比较正常的一个，但正处于花季年纪的她并不适合大学生活，成绩优异不懂打扮的她让人只能敬而远之。尽管是天才，但是如今的大学并不只是学习知识的地方，如果说初中是每个人最会做梦的年纪，高中洋溢着每个人最具浓厚的青春，走向社会是一个人成长为打人的标志，那么大学时代则是每一个人从孩子长成大人的过度期，因此嚷处于做梦年纪的孩子直接去面向社会的残酷未免太过残忍。</p><p>校花江依琳可谓是剧中较完美的一个人，他承载着天才们对女性最完美的幻想。她可以说是剧中EQ最高的一位。尽管他是天才们放弃比赛的导火线，但是天才们又有几个真正懂得感情呢。她对方厚政的感情其实就是姐姐对弟弟的照顾，而对于心智只有9岁的方厚政来说，又怎会冬的何谓男女之情呢。方厚政对待像话的感觉也不过是弟弟对大姐姐的仰慕之情。王大法测试时便已说过他所期望的爱情是门当户对，显然校花并不是他所期待的人，因此他对校花的感情量自己都不会说清楚。至于迈克，校花也许的确对迈克有点好感，但迈克显然给不了校花幸福，首先，迈克并不知道什么是责任，测试时便已清楚他的情绪宣泄是暴力，倘若青春期那股passion磨灭了，后果自行脑补。其次迈克给不了校花真正需要的。之所以前期近似完美的校花最后会有那么一出戏，其实很容易看出的。江依琳需要一场舞蹈独秀以支撑日后的发展，身为天才的少年们有谁能给呢，因此江依琳选择了富家公子哥，这都是情理之中。而此时的天才们只顾自己的感受，仗着长久以来老师的庇护去炸车。所以，当看到周知庸老师泼江依琳水时，我倒有点替校花感到冤枉，自己争取来的前途就因为接近了天才们而被老师给毁了。而周老师之所以泼水，也许是曾经旧时代里被戏弄过，旧火新火全发泄在了江依琳身上。</p><p>周知庸老师，典型旧时代的人，因为自己未能拿奖的遗憾，而把希望寄托在新时代的少年天才们身上。也许努力学习没有错，但他忽略了当今世界已不是简简单单努力学习就能改变的了。当一个人不愿接受新时代时，他已经被这个时代所遗弃，成为旧时代的古董。当他最后不在从事教育事业，专心于交际时，此刻的他应该是幸福的。</p><p>不过，周老师错了吗，没人能说他错了。至少20多年来，他一直秉持着初心，坚守着梦想，对于现代人来说，这一点是多么的可贵呢。社会这个大染缸将每一个青春期怀穿着梦想的少年少女染成形形色色为生活而忙碌的机器，又有几个人能站出来说我要改变这个世界呢。我感觉说这话的人并不丢人，反而是那些早已面目全非的人让人可悲。</p><p>不知不觉，恭喜我又成功把我给绕进去了。我竟然有分不清自己的立场了，呵呵。不过不论什么样的人，坚持做好自己就好。正处于大学生活的我们，无论何时都要坚持自己的梦想，不必在意那些圆滑的人说你不够圆滑，不必在意那些所谓成熟的人说你不够成熟，不要照原样接受别人的生活。选择坚守，选择理想，选择倾听自己内心深处的呼唤。因为在这个充满怀疑的世界，我们依旧需要梦想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="影评" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>回忆若一指流沙，散落了谁的风华</title>
    <link href="http://qianyouyou.cn/2018/06/11/2018-06-11/"/>
    <id>http://qianyouyou.cn/2018/06/11/2018-06-11/</id>
    <published>2018-06-11T06:16:28.000Z</published>
    <updated>2018-06-11T09:23:54.552Z</updated>
    
    <content type="html"><![CDATA[<p>宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。</p><p>后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有一种壮志凌云。</p><p>在宁夏，没有高楼大厦，但远处的山峰鳞次栉比。没有车水马龙，但广阔的天空一碧如洗。一切都安顿好之后，我们便奔向当地特色小吃而去。宁夏理工学院，坐落在湖心的一座岛屿之上，可以说，一座岛屿即一座城。很快我们便摸不清方向了。此时，一个小姐姐跑过来跟我们搭讪。由于比赛都发的队服，很是显眼，显然，她是被我们的队服吸引而来的。就这样莫名其妙的，我们渐渐熟悉。在她的带领下，我们逛了校园，逛了小吃摊……</p><p>宁夏昼长夜短，即使到了晚上八九点，天依然为褪色。就这样逛着逛着，吃着吃着，天就黑了，当我们看时间时，已是十点多了。我们留下了联系方式，各自归宿。</p><p>第2天，宁夏理工学院组织我们所有参赛者一起去旅游，地点是沙湖，即沙漠中的一片绿洲。我们队和昨天的小姐姐约好今天一起游玩，而我们队刚好缺了一个教练，就这样理所当然的，她以我们教练的身份一起踏上了沙漠的旅程。</p><p>一路上，我们划过了湖泊，翻过了沙漠，跨过了沙丘，因为她的出现，在她的陪伴下，我们的旅程不再显得单调乏味。在沙漠中，偶然发现某片沙地里满是荆棘，当跨过荆棘之后，望到了一片花海。尽管花在强烈的阳光下已奄奄一息，然而它们仿佛在用生命证明自己存在的意义。同伴们纷纷前往亭下避暑，只有我守着安静的沙漠，等待着花开。</p><p>第3天，终于要比赛了。经过了上一次失败的经验，这次尽管最后一次提交因为时间到了没有提交成功，不过好在前两个半小时成功A了3道题，我们队最终斩获一枚铜奖，也算是这么多月的训练也算有了一个回报。</p><p>临别时，小姐姐教练来为我们送行，并带来当地的特产。因为赶飞机，我们草草照相留念之后，便踏上了返程的飞机。</p><p>戴上耳机，梳理着三天的回忆。其实我们每个人来到这个世界上，就只能义无反顾的前进。在人生的道路上，除了自己，其他人都只能伴我们走过一程。这一程，或长或短，也许转瞬已尽，也许直通彼岸，但永远不会是永远。当走完这一程，余下的路需由自己来走完。然而不必逗留着，因为每时每刻，都会有新的过客伴你走过新的一程。尽管离别之后，我们可能会永远不见，但彼此走过的那份欢乐，永远藏在心里。</p><p>谢谢你伴我们走过这三天，也许今后永远不会再见，但我们走过的那段旅程以及旅程中的你我永远不会失散。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。&lt;/p&gt;
&lt;p&gt;后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>API函数配置读写文件</title>
    <link href="http://qianyouyou.cn/2018/06/03/2018-06-03/"/>
    <id>http://qianyouyou.cn/2018/06/03/2018-06-03/</id>
    <published>2018-06-03T15:19:41.000Z</published>
    <updated>2018-06-03T15:32:58.144Z</updated>
    
    <content type="html"><![CDATA[<p>cfg_op.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">//获取配置项</span><br><span class="line">int GetCfgItem(char *pFileName/*in*/, char*pKey/*in*/, char *pValue/*in out*/, int *pValueLen/*out*/);</span><br><span class="line">//写配置项</span><br><span class="line">int WriteCfgItem(char*pFileName/*in*/, char *pKey/*in*/, char *pValue/*in*/, int *ValueLen/*in*/);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>cfg_op.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define Maxline 2048</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">int GetCfgItem(char *pFileName, char*pKey, char *pValue, int *pValueLen)</span><br><span class="line">&#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char lineBuf[Maxline];</span><br><span class="line">char *pTmp = NULL, *pEnd = NULL, *pBegin = NULL;</span><br><span class="line">fp = fopen(pFileName, &quot;r&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">ret = -1;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">while (!feof(fp)) &#123;</span><br><span class="line">memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">fgets(lineBuf, Maxline, fp);</span><br><span class="line">printf(&quot;lineBuf:%s &quot;, lineBuf);</span><br><span class="line"></span><br><span class="line">pTmp = strchr(lineBuf, &apos;=&apos;);</span><br><span class="line">if (pTmp == NULL) &#123;//没有=号</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp = strstr(lineBuf, pKey);</span><br><span class="line">if (pTmp == NULL) &#123;//判断key是不是在//所在行 是不是有key</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp = pTmp + strlen(pKey);//mykey1 = myvalue11111111==&gt;&quot;myvalue11111111&quot;</span><br><span class="line">pTmp = strchr(pTmp, &apos;=&apos;);</span><br><span class="line">if (pTmp == NULL) &#123;//判断所在行是不是有key</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp++;</span><br><span class="line">printf(&quot;pTmp:%s &quot;, pTmp);</span><br><span class="line">//获取value起点</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (*pTmp == &apos; &apos;) &#123;</span><br><span class="line">pTmp++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">pBegin = pTmp;</span><br><span class="line">if (*pBegin == &apos;\n&apos;) &#123;</span><br><span class="line">//没有配置value</span><br><span class="line">printf(&quot;配置项:%s 没有配置value \n&quot;, pKey);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取value结束点</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (*pTmp == &apos; &apos; || *pTmp == &apos;\n&apos;) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">pTmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pEnd = pTmp;</span><br><span class="line">//赋值</span><br><span class="line">*pValueLen = pEnd - pBegin;</span><br><span class="line">memcpy(pValue, pBegin, pEnd - pBegin);</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line">if (fp == NULL)</span><br><span class="line">fclose(fp);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">int WriteCfgItem(char*pFileName, char *pKey, char *pValue, int *ValueLen)</span><br><span class="line">&#123;</span><br><span class="line">int rv = 0, iTag = 0, length = 0;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char lineBuf[Maxline];</span><br><span class="line">char *pTmp = NULL, *pBegin = NULL, *pEnd = NULL;</span><br><span class="line">char filebuf[1024 * 8] = &#123; 0 &#125;;</span><br><span class="line">if (pFileName == NULL || pKey == NULL || pValue == NULL) &#123;</span><br><span class="line">rv = -1;</span><br><span class="line">printf(&quot;SetCfgItem() err. param err \n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(pFileName, &quot;r+&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -2;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -3;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fseek(fp, 0L, SEEK_END);//把文件指针从0位置开始，移动到文件末尾</span><br><span class="line">//获取文件长度</span><br><span class="line">length = ftell(fp);</span><br><span class="line">fseek(fp, 0L, SEEK_SET);</span><br><span class="line">if (length &gt; 1024 * 8) &#123;</span><br><span class="line">rv = -3;</span><br><span class="line">printf(&quot;文件超过1024*8,nunsupport&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">while (!feof(fp)) &#123;</span><br><span class="line">//读每一行</span><br><span class="line">memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">pTmp = fgets(lineBuf, Maxline, fp);</span><br><span class="line">if (pTmp == NULL) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//key关键字是否在本行</span><br><span class="line">pTmp = strstr(lineBuf, pKey);</span><br><span class="line">if (pTmp == NULL)//key关键字不在本行，copy到filebuf中</span><br><span class="line">&#123;</span><br><span class="line">strcat(filebuf, lineBuf);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else//key关键字在本行中，替换旧的行，再copy到filebuf中</span><br><span class="line">&#123;</span><br><span class="line">sprintf(lineBuf, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">strcat(filebuf, lineBuf);</span><br><span class="line">//若存在key</span><br><span class="line">iTag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//若key关键字，不存在 追加</span><br><span class="line">if (iTag == 0) &#123;</span><br><span class="line">fprintf(fp, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//若key关键字，存在，则重新创建文件</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">fclose(fp);</span><br><span class="line">fp = NULL;//避免野指针</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -4;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">fputs(filebuf, fp);</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line">return rv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&quot;cfg_op.h&quot;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define CFGNAME &quot;d:/mycfg.ini&quot;</span><br><span class="line">//读配置项</span><br><span class="line">int GetCfg() &#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">char name[1024] = &#123; 0 &#125;;</span><br><span class="line">char value[1024] = &#123; 0 &#125;;</span><br><span class="line">int vlen = 0;</span><br><span class="line">printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line">ret = GetCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">printf(&quot;func GetCfgItem err:%d \n&quot;, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;value:%s \n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">//写配置项</span><br><span class="line">int TWriteCfg() &#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">char name[1024] = &#123; 0 &#125;;</span><br><span class="line">char value[1024] = &#123; 0 &#125;;</span><br><span class="line">int vlen = 0;</span><br><span class="line">printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line">printf(&quot;\n请输入Value:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, value);</span><br><span class="line">WriteCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">printf(&quot;func WriteCfgItem err:%d \n&quot;, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;您的输入是：%s = %s \n&quot;, name, value);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show_menu() &#123;</span><br><span class="line">printf(&quot;==========================\n&quot;);</span><br><span class="line">printf(&quot;1.测试写配置文件\n&quot;);</span><br><span class="line">printf(&quot;2.测试读配置文件\n&quot;);</span><br><span class="line">printf(&quot;0.退出\n&quot;);</span><br><span class="line">printf(&quot;==========================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int choice;</span><br><span class="line">show_menu();</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;choice)) &#123;</span><br><span class="line">//显示一个菜单</span><br><span class="line">switch (choice) &#123;</span><br><span class="line">case 1:</span><br><span class="line">TWriteCfg();</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">GetCfg();</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">show_menu();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cfg_op.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="文件" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="API函数" scheme="http://qianyouyou.cn/tags/API%E5%87%BD%E6%95%B0/"/>
    
      <category term="文件" scheme="http://qianyouyou.cn/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>牛客训练赛19之托米专场</title>
    <link href="http://qianyouyou.cn/2018/06/01/2018-06-01/"/>
    <id>http://qianyouyou.cn/2018/06/01/2018-06-01/</id>
    <published>2018-06-01T15:42:31.000Z</published>
    <updated>2018-07-15T14:27:17.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="托米的简单表示法"><a href="#托米的简单表示法" class="headerlink" title="托米的简单表示法"></a><a href="https://www.nowcoder.com/acm/contest/111/A" target="_blank" rel="noopener">托米的简单表示法</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   作为故事主角的托米是一名老师。  </p></blockquote><p>  一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: </p><p>  几何表示的定义： </p><p>  <strong>1.</strong>          <strong>对于一个括号序列A，我们定义g(A)是A的几何表示形式,则          “()”的表示是一个1*1的方块，高度为1;</strong>            <strong>2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1; 3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。 其中+指的是字符串的连接符。</strong>  </p><p>​                              </p><p>  在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： </p><p>  <img src="https://uploadfiles.nowcoder.com/images/20180529/301599_1527594747449_9C23C3C01AAE429614DCD886F400FAF2" alt="img"></p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入的第一行包含一个整数T，表示指定测试用例的数量。</span><br><span class="line">每个测试用例前面都有一个空白行。</span><br><span class="line">每个测试用例由一个合法括号序列组成。 每行只包含字符&apos;(&apos;和&apos;)&apos;。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">((()))</span><br><span class="line"></span><br><span class="line">(())(()(()))</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二个测试案例是上图中显示的案例。</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1≤T≤10</span><br><span class="line">一个合法括号序列长度≤4 x 105</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题提交了好多次，一直WA。后来改成long long就过了。原理很简单，就是遇见左括号入栈，遇见右括号出栈。在入栈出栈时执行操作。先入栈的高度比后入栈的最高高度要高1，初始宽度为1，每执行一次出栈操作，出栈元素前一个元素的宽度等于他自身宽度加上出栈元素宽度再加1。而出栈元素的面积等于宽乘高减去包含元素的面积。就这样，每次出栈时，前一个元素宽度加上该元素宽度加1，前元素将要减去的面积area等于出栈元素的面积minu。而出栈元素的面积area等于高乘宽减去将要减去的面积minu。最终由于0位置没有面积，就是全域，那他的minu即将要减去的面积就是总面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200010;</span><br><span class="line">char str[maxn*2];</span><br><span class="line">ll high[maxn],wed[maxn],area[maxn],minu[maxn],mystack[maxn];</span><br><span class="line">ll fun()&#123;</span><br><span class="line">    int cnt = 1,head = 1,tail = 1,len = strlen(str);</span><br><span class="line">    memset(high,0,sizeof(high));</span><br><span class="line">    memset(wed,0,sizeof(wed));</span><br><span class="line">    memset(minu,0,sizeof(minu));</span><br><span class="line">    memset(mystack,0,sizeof(mystack));</span><br><span class="line">    for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">        if(str[i] == &apos;(&apos;)&#123;</span><br><span class="line">            mystack[tail++]=cnt++;</span><br><span class="line">            high[mystack[tail - 1]]++;</span><br><span class="line">            wed[mystack[tail - 1]] = 1;</span><br><span class="line">            if(high[mystack[tail - 2]] &lt;= high[mystack[tail - 1]])</span><br><span class="line">                high[mystack[tail - 2]] = high[mystack[tail - 1]] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(str[i] == &apos;)&apos;)&#123;</span><br><span class="line">            if(tail &gt; 1)&#123;</span><br><span class="line">                if(high[mystack[tail-2]] &lt;= high[mystack[tail-1]])</span><br><span class="line">                    high[mystack[tail-2]] = high[mystack[tail-1]] + 1;</span><br><span class="line">                tail--;</span><br><span class="line">                wed[mystack[tail - 1]] += wed[mystack[tail]] + 1;</span><br><span class="line">                area[mystack[tail]] = wed[mystack[tail]] * high[mystack[tail]] - minu[mystack[tail]];</span><br><span class="line">                minu[mystack[tail - 1]] += area[mystack[tail]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minu[0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        cout &lt;&lt; fun() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托米的饮料"><a href="#托米的饮料" class="headerlink" title="托米的饮料"></a><a href="https://www.nowcoder.com/acm/contest/111/E" target="_blank" rel="noopener">托米的饮料</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   好了，现在是小托米的故事啦~~~  </p></blockquote><p>  可爱的小托米得到了n瓶饮料. </p><p>但他不小心把开盖的工具弄丢了,所以他只能利用饮料瓶来开盖.</p><p>已知第i个瓶子的品牌为a</p><p>i</p><p>,且其能打开b</p><p>i</p><p>品牌的瓶子.</p><p>问有几瓶饮料托米无法喝到.</p><p><strong>被用于打开饮料瓶的瓶子不一定需要被打开.</strong></p><p><strong>一个瓶子不能打开其本身.</strong></p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n,表示饮料的瓶数.</span><br><span class="line">接下来n行,每行两个整数ai,bi.</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数,表示小托米无法喝到的饮料瓶数.</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1≤n≤100</span><br><span class="line">1≤ ai,bi≤ 1000</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>本题坑人之处在于理解题意。因为没理解题意导致提交了好多次才提交成功。本题实质很简单，就是每个瓶子对应有一个编号b，可以开这个编号b除了自己以外的所有的瓶子。但仅限于该瓶子，其他瓶子也只能执行自己的编号b。首先输入完成时记录下所有编号的瓶子个数，把n赋给瓶子个数cnt，因为一开始n个瓶子都没打开。接着对b按顺序进行遍历，如果对应编号的瓶子不存在，则不执行操作，否则接着判断，如果a和b不同，则cnt减去该瓶子的数量，然后数量置零，因为该类瓶子已经打开完了，之后不需要再打开，否则执行完操作后再加1，因为不能打开自己。最后cnt就是剩下没打开的数量。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1010]=&#123;0&#125;,a[1010],b[1010];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int cnt = n;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        vis[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[b[i]])&#123;</span><br><span class="line">            cnt-=vis[b[i]];</span><br><span class="line">            vis[b[i]]=0;</span><br><span class="line">            if(a[i]==b[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[b[i]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托米搭积木"><a href="#托米搭积木" class="headerlink" title="托米搭积木"></a><a href="https://www.nowcoder.com/acm/contest/111/F" target="_blank" rel="noopener">托米搭积木</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>  小托米真的很可爱呀(&gt;_&lt;) </p></blockquote><p>  这天,可爱的小托米得到了n堆积木,且第i堆积木初始时有ai块积木. </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一行两个整数n,m.</span><br><span class="line">第二行n个整数,第i个整数代表ai的值.</span><br><span class="line">接下来m行,每行代表一个操作:</span><br><span class="line">第一个整数t代表操作的类型</span><br><span class="line">若t=1,则接下来两个整数v,x,代表操作1.</span><br><span class="line">若t=2,则接下来一个整数y,代表操作2.</span><br><span class="line">若t=3,则接下来一个整数q,代表操作3.</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个操作3,输出其对应的答案.</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10 11</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">3 2</span><br><span class="line">3 9</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">1 1 10</span><br><span class="line">2 10</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">39</span><br></pre></td></tr></table></figure><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤ 105</span><br><span class="line">1≤ai≤109</span><br><span class="line">1≤t≤3</span><br><span class="line">1≤v≤ n,1≤ x≤109</span><br><span class="line">1≤y≤104</span><br><span class="line">1≤q≤n</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>很简单的一道题，3种操作，第1操作是把第i位置的数该为另一个数x，第2个操作是所有数加v，第3个操作是查询某一位置的数。首先分析，第1种操作和第3种操作时间复杂度都是O(1),第2中操作如果每位加v的话时间复杂度O(n)。所以优化在于第2操作。不过对于此操作我们可以降维优化，因为是所有数都加v，那么我们只需把v记录下来，每次查询时对查询的数直接加v就行了。这样就又遇到了一个问题，就是假如所有的数现在的状态是加v，而i位置元素现在变成了x，这样就会造成所有元素相加不一致。解决也很简单，只需每次变成x后，给x减去v就行了，这样查询时再加上v结果并没变。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">int a[100010], cnt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    int t,x,y;</span><br><span class="line">    cnt=0;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        if(t==3)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;a[x]+cnt&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==2)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cnt+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            a[x]=y;</span><br><span class="line">            a[x]-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;托米的简单表示法&quot;&gt;&lt;a href=&quot;#托米的简单表示法&quot; class=&quot;headerlink&quot; title=&quot;托米的简单表示法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/111/A&quot; target=&quot;_
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>[心路历程]心境决定处境，心界决定眼界</title>
    <link href="http://qianyouyou.cn/2018/05/31/2018-05-31/"/>
    <id>http://qianyouyou.cn/2018/05/31/2018-05-31/</id>
    <published>2018-05-31T04:51:35.000Z</published>
    <updated>2018-06-11T06:35:27.499Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸，但此刻的你并没有精力寻找彼岸的方向，因为你的心思全放在了如何不被突如其来的大水淹没，于是你拼命的寻找救命稻草，以阻止自己下沉。就这样，在慌乱的过程中，阻止了你上岸的步伐。</p><p>假如一开始你没有目标，那么此时这种状态并非坏事。因为当你在水里抓住救命稻草之后，会寻找彼岸的方向。如果你足够冷静，此刻你会总结你和他的差距在哪里，从而为自己确立目标，并参考他的经历为自己制定计划。如果你不够冷静，那此时你也许会照搬别人的做法，以别人的目标为自己的目标。这样也许会走很多弯路，做许多无用功，但至少比之前毫无目标浑浑噩噩要好得多，同时这段经历也会成为你如何成长道路上的一比财富。</p><p>倘若你一开始就有自己的目标，有属于自己的彼岸，而当你看到有人已经走到人生的彼岸时，你会怀疑自己走过的路，即使彼岸就在前方，你也会动摇，因为你还没有到达彼岸，没有见过彼岸的风景。假如此时的你停下脚步眺望对方的彼岸，那无疑是致命的。它就像突如其来的潮水，可能会拖延了你前行的道路，更有可能会动摇你前行路上的决心，甚至改变你前进的方向。</p><p>我有一个计算机系的舍友，他的目标是考研。自大一以来一直成绩优异，大二时便已轻松通过四六级，而且交际甚广，可谓前程平坦，身边阳光明媚。但此时，某人给他发了一个自己做的贺卡程序，看起来挺酷，此时他开始动摇了。因为自进校以来同学们一直都是面对黑窗口敲代码，敲出来的也是黑窗口，从来没有想过有人能够编出应用来。他说，当他收到那份礼物时，心中交错的并不是喜悦，而是迷惘。就好像春天的果树看着繁花满庭，而自己却总是开不出花，便开始抱怨自己的价值，而忘记了自己的果实要等到秋天才能品尝。于是当他看到别人已经拥有了强大的实力并且取得相应的成果，而自己还停留在课本中的C语言基础知识，不会应用，顿时思绪万千，怀疑自己走的道路，怀疑学校的课程安排。那种感觉，就像走着走着掉进水里一样。</p><p>此时，他拼命的寻找救命稻草。终于，他抓到了第一根救命稻草。他开始跟着别人做项目，一起写程序，别人打比赛，他便开始模拟比赛。在这段时间，他感到生活变得充实，做事也有动力，因为他也想拥有像那个人一样的实力，像那个人一样去打比赛。但正当他感觉找到目标时，选拔结果出来了，正式比赛的名额没有他，他落选了。此时的他顿时感觉自己又失去了方向。于是他又开始寻找救命稻草。他抓到的第二根救命稻草是校外的编程培训班。于是他果断交了大笔费用去报了培训班。在培训班里，他又燃起了希望，因为在这里，老师讲的一些东西都是课本上所没有的，老师还经常在课堂上带他们写一些小应用，这些都是他们以前不曾经历过的。由于这种模式以前没有接触过，所以便对学的东西燃起了兴趣，即使一切都是从头开始学习，即使许多东西以前都学过。就这样过了两个月，当他冷静下来，重新审视自己时，才发现自己真正要走的路的还是考研，而这段时间所学的技术只是就业路上的一个工具。而培训班中的许多东西其实学校的课程里都有，只是他从未重视过，没接触过的东西未来也会学习。就这样，他又开始了最初的考研复习之路。</p><p>那么，当我们在前行的路上看到别人已经到达人生的彼岸或者接近人生的彼岸时该怎么办呢。</p><p>其实，一个人的心境决定了这个人的处境。假如心中拥抱黑暗，那么眼之所见也会变得暗淡。即使前程平坦，阳光盎然，你也望不见人生的彼岸。假如心中充满光明，那么黑夜也会为你亮起星光。即使道路坎坷，前程黑暗，你也会收获自信坚定向前。</p><p>以我为例，记得之前比赛失利，没有获奖，而朋友却在其他项目中表现优异，此时的我就像《三体》中经历水滴之战惨败而侥幸逃跑的舰队队长一样，当看到章北海率领的舰队未雨绸缪时，眼前是一片黑暗，不由自主地感叹:”好黑，真tm的黑啊”。此刻的我早已迷失了方向，整日思绪想的是同样是付出，朋友们一个个却硕果累累，而我却像墙角的蘑菇怎么也沐浴不到阳光。为了这场比赛，准备了一个多月，那段时间翘了许多节课，一心研究算法，而最后连个证明自己这段时间的成果都没有。眼前面临的是各种各样的考试，以及英语四级考试，顿时怀疑自己之前的付出是否值得。其实在不久之后又有一次比赛，而此时的我却整日处于悲观之中，害怕下次比赛同样拿不到成绩，害怕考试失利，害怕英语四级。此刻的我，感到人人都各有所长，就只有自己一直处于失败当中，人人都比我成功。于是我把自己包裹起来，不喜欢与人交流，感觉每个人都很虚伪，从此变得越来越冷漠。就这样，我一边准备比赛，一边疯狂复习，一边孤独，一边迷惘。由于同时选择多种方向，最终也一事无成。马上就要比赛了，此刻的我偶然间望见教室的窗外阳光依旧明媚，回忆起之前努力奋斗的日子里也是同样的阳光，望着这从未消逝的阳光，我重新总结了一下这段时间的经历，终于明白，其实阳光很好，世界很好，所有人都很好，只是我的心态变得暗淡了。当我重新投入到阳光灿烂的日子里，此时发现，其实许多人都在羡慕我。尽管我没有拿到奖，但这段时间我的实力已经突飞猛进。虽然我没有收获奖杯，但我却收获了成长，坚定了方向。</p><p>所以，心界决定了眼界。当你凝视黑暗的时候，黑暗也在呼唤着你。倘若一个人心中见不到光，那么对他而言，整个世界都是黑暗的。当看到别人取得的成就时，只会是羡慕嫉妒恨，自怨自艾。也许有人会说，悲观，是一种远见。但当一个人始终以悲观的态度看待世界，那么所看到的整个世界只剩下冷漠，背叛，黑暗，而你收获的也只有孤独，失望，迷茫。</p><p>不妨敞开心扉，让阳光渗透到我们的心中。此时你会发现，当你看到别人的成就时，更多的是送去祝福，而不是怀疑自己。这样，就不会迷失方向，同时别人的经历中总结经验，化作自己前行的垫脚石。</p><p>阳光很好，我亦很好，整个世界更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>C/C++结构体中的深copy和浅copy&amp;&amp;结构体偏移量的两种求法</title>
    <link href="http://qianyouyou.cn/2018/05/30/2018-05-30/"/>
    <id>http://qianyouyou.cn/2018/05/30/2018-05-30/</id>
    <published>2018-05-30T11:56:43.000Z</published>
    <updated>2018-05-30T13:36:55.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅copy："><a href="#浅copy：" class="headerlink" title="浅copy："></a>浅copy：</h2><p>编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，拷贝之后释放内存就不会出现问题。但是如果结构体中含有指针变量的时候，编译器只会copy指针变量，而对应的内存空间却不会缺不再多分配。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">char a[64];</span><br><span class="line">int b;</span><br><span class="line">char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">*to = *from;</span><br><span class="line">//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">note d, e;</span><br><span class="line">strcpy(d.a, &quot;123&quot;);</span><br><span class="line">d.b = 456;</span><br><span class="line">while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(d.c, &quot;789&quot;);</span><br><span class="line">printf(&quot;d的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">my_copy(&amp;d, &amp;e);</span><br><span class="line">printf(&quot;e的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">if (d.c != NULL) &#123;</span><br><span class="line">free(d.c);</span><br><span class="line">d.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此样例为例，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br><span class="line">e的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure><p>然后接着某些编译器如vs的编译器就会报错。出错位置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是由于将结构体d内存元素直接赋给结构体e时，即进行 <em> e= </em> d操作时，由于结构体中含有指针元素，d结构体中的指针已经动态分配内存，而操作完成之后e中指针的值也会写上d动态分配内存的地址，因此d和e指向同一内存空间。这样当d中指针d.c释放内存之后，由于e.c仍然指向该部分内存，而不指向空，此时会强制释放掉e.c所指向内存，由于此处内存已经释放过了，处于不能被访问状态，而e.c又强制释放该内存，就会造成vs编译器报错。这就是前copy的弊端。</p><h2 id="深copy："><a href="#深copy：" class="headerlink" title="深copy："></a>深copy：</h2><p>编译器会为拷贝的对象分配一定的内存空间。</p><p>以上述代码为例，只需在进行 <em> e= </em> d操作之后再为e.c重新分配内存，然后执行strcpy(e,d)即可。这样e.c和d.c分别指向两块不同的内存，这样就不会出现上面那种错误。</p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">char a[64];</span><br><span class="line">int b;</span><br><span class="line">char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">*to = *from;</span><br><span class="line">//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">while ((to-&gt;c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(to-&gt;c, from-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">note d, e;</span><br><span class="line">strcpy(d.a, &quot;123&quot;);</span><br><span class="line">d.b = 456;</span><br><span class="line">while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(d.c, &quot;789&quot;);</span><br><span class="line">printf(&quot;d的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">my_copy(&amp;d, &amp;e);</span><br><span class="line">printf(&quot;e的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">if (d.c != NULL) &#123;</span><br><span class="line">free(d.c);</span><br><span class="line">d.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏移量的求法"><a href="#偏移量的求法" class="headerlink" title="偏移量的求法"></a>偏移量的求法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct note&#123;</span><br><span class="line">    char name[64];</span><br><span class="line">    int age;</span><br><span class="line">    int sex;</span><br><span class="line">&#125;a,*p;</span><br><span class="line">p=&amp;a;</span><br></pre></td></tr></table></figure><p>以p为例求p-&gt;age偏移量</p><h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsize = (int)&amp;(p-&gt;age)-(int)p;</span><br></pre></td></tr></table></figure><h3 id="间接法"><a href="#间接法" class="headerlink" title="间接法"></a>间接法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsize = (int)&amp;(((*note)0)-&gt;age);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅copy：&quot;&gt;&lt;a href=&quot;#浅copy：&quot; class=&quot;headerlink&quot; title=&quot;浅copy：&quot;&gt;&lt;/a&gt;浅copy：&lt;/h2&gt;&lt;p&gt;编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="结构体" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="结构体" scheme="http://qianyouyou.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>关于模拟或暴力类型题的时间复杂度降维优化举例</title>
    <link href="http://qianyouyou.cn/2018/05/29/2018-05-29/"/>
    <id>http://qianyouyou.cn/2018/05/29/2018-05-29/</id>
    <published>2018-05-29T12:39:04.000Z</published>
    <updated>2018-05-29T12:50:23.458Z</updated>
    
    <content type="html"><![CDATA[<p>首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即实现由0(…)0(N)-&gt;0(…)0(1)的降维过程。但推导公式往往是一件很麻烦的事情，因此推导公式是模拟类题的关键。以下两道题原本是用模拟或暴力来解决，但其实它们都是可以优化的，例如第一题只需要求周期内的数与周期即可，不用遍历全部数，第2题只需对该数n进行分析即可，时间复杂度0(1)，不用从1遍历到n一个个进行统计。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>百度熊对数学一直都非常感兴趣。最近在学习斐波那契数列的它，向你展示了一个数字串，它称之为“斐波那契”串：</p><p>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11235813471123581347112358…</span><br></pre></td></tr></table></figure><p>聪明的你当然一眼就看出了这个串是这么构造的：</p><ol><li><p>先写下两位在0~9范围内的数字a, b，构成串ab；</p></li><li><p>取串最后的两位数字相加，将和写在串的最后面。</p></li></ol><p>上面百度熊向你展示的串就是取a = b = 1构造出来的串。</p><p>显然，步骤1之后不停地进行步骤2，数字串可以无限扩展。现在，百度熊希望知道串的第n位是什么数字。</p><p>输入数据的第一行为一个整数T（1 ≤ T ≤1000）, 表示有T组测试数据；每组测试数据为三个正整数a, b, n（0 ≤ a, b &lt; 10, 0 &lt; n ≤109）。</p><p>对于每组测试数据，输出一行“Case #c: ans”（不包含引号） c是测试数据的组数，从1开始。</p><p>提示：</p><ol><li><p>对于第一、二组数据，串为112358134711235…</p></li><li><p>对于第三组数据，串为14591459145914…</p></li></ol><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">1 1 8</span><br><span class="line">1 4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 3</span><br><span class="line">Case #3: 9</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 500;</span><br><span class="line">int t, c, d, n, cyc, cnt;</span><br><span class="line">int a[maxn], vis[maxn];</span><br><span class="line">int init()&#123;</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    a[1] = c;</span><br><span class="line">    a[2] = d;</span><br><span class="line">    cnt = 2;</span><br><span class="line">    while(!vis[a[cnt-1]*10+a[cnt-0]])&#123;</span><br><span class="line">        vis[a[cnt-1]*10+a[cnt]] = cnt;</span><br><span class="line">        int tmp = a[cnt-1] + a[cnt];</span><br><span class="line">        if(tmp&lt;10)</span><br><span class="line">            a[++cnt]=tmp;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[++cnt]=tmp/10;</span><br><span class="line">            a[++cnt]=tmp%10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vis[a[cnt-1]*10+a[cnt]];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int i = 1;i&lt;=t;i++)&#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d &gt;&gt; n;</span><br><span class="line">        int res = init();</span><br><span class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;;</span><br><span class="line">        if(cnt&gt;=n)</span><br><span class="line">            cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;a[res+(n-res)%(cnt-res)]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h2><p>试计算在区间 11 到 nn 的所有整数中，数字 xx（0 \leq x \leq 90≤x≤9）共出现了多少次？例如，在 11 到 1111 中，即在 11、22、33、44、55、66、77、88、99、1010、1111 中，数字 11 出现了 4 次。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 1 行，包含 2 个整数 nn、xx，之间用一个空格隔开。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含一个整数，表示 xx 出现的次数。</p><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 100% 的数据，1 \leq n \leq 1,000,0001≤n≤1,000,000，0 \leq x \leq 90≤x≤9。</p><p>忽略每行输出的末尾多余空格</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    int cnt = 0, res = 1, re = 1;</span><br><span class="line">    int tmp = n;</span><br><span class="line">    if(x)&#123;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            int mod = tmp%10;</span><br><span class="line">            cnt+=(res-re)/10*mod;</span><br><span class="line">            if(mod&gt;x)</span><br><span class="line">                cnt+=re;</span><br><span class="line">            else if(mod==x)</span><br><span class="line">                cnt+=n%re+1;</span><br><span class="line">            re*=10;</span><br><span class="line">            res*=10;</span><br><span class="line">            res+=re;</span><br><span class="line">            tmp/=10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)</span><br><span class="line">            for(int j=i;j;j/=10)</span><br><span class="line">                if(j%10==x)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="暴力枚举" scheme="http://qianyouyou.cn/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>[C指针进阶]二级指针做输入的3种内存模型</title>
    <link href="http://qianyouyou.cn/2018/05/26/2018-05-26/"/>
    <id>http://qianyouyou.cn/2018/05/26/2018-05-26/</id>
    <published>2018-05-26T06:24:45.000Z</published>
    <updated>2018-05-30T13:30:40.171Z</updated>
    
    <content type="html"><![CDATA[<p>对于指针，我们只需要从两个角度进行分析即可。</p><p>第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） </p><p>第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一维的还是二维的。 </p><p>今天分析的二维指针三种内存模型都是指针做输入的情况，在主调函数中分配内存。 </p><p>在分析指针之前，先回顾一下内存四区的知识。首先我们知道内存分为5大区，我们暂把BSS段与数据段合称为全局区或者常量区，构成内存四区。以下是内存5大区具体概况。</p><h2 id="内存5大区"><a href="#内存5大区" class="headerlink" title="内存5大区"></a>内存5大区</h2><ul><li><p><strong>BSS段( bss segment )</strong></p><p>通常是指用来存放程序中<code>未初始化的全局变量和静态变量</code> （这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。既然都是0那么就<code>没必要把每个0都存储起来</code>,从而节省磁盘空间,这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。</p></li></ul><hr><ul><li><p><strong>数据段(data segment)</strong></p><p>通常是指用来存放程序中已经<code>初始化的全局变量和静态变量</code>的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,但一般都是放在只读数据段中。</p></li></ul><hr><ul><li><p><strong>代码段(code segment/text segment)</strong></p><p>通常是指用来存放<code>程序执行代码的一块内存区域</code>。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。</p></li></ul><hr><ul><li><p><strong>堆(heap)</strong></p><p>堆是用于存放进程运行中被<code>动态分配的内存段</code>,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减)</p></li></ul><hr><ul><li><p><strong>栈 (stack)</strong></p><p>栈又称堆栈, 是<code>用户存放程序临时创建的局部变量</code>,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在数据段中存放变 量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的先进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。 </p></li></ul><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-25-%E5%86%85%E5%AD%985%E5%8C%BA.png" alt="内存分区图"></p><h2 id="二阶指针做输入的3种内存模型"><a href="#二阶指针做输入的3种内存模型" class="headerlink" title="二阶指针做输入的3种内存模型"></a>二阶指针做输入的3种内存模型</h2><p>接下来我们来讨论二阶指针做输入的3种内存模型。</p><h3 id="第1种"><a href="#第1种" class="headerlink" title="第1种"></a>第1种</h3><p>首先第一种就是指针数组，以字符型指针数组为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char*p1[10];</span><br></pre></td></tr></table></figure><p>指针数组的实质是表示存放指针的数组。 </p><h3 id="第2种"><a href="#第2种" class="headerlink" title="第2种"></a>第2种</h3><p>第二种为二维数组，以字符型二维数组为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char p2[3][4];</span><br></pre></td></tr></table></figure><h3 id="第3种"><a href="#第3种" class="headerlink" title="第3种"></a>第3种</h3><p>第三种为二维指针，以字符型二维指针为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char **p3;</span><br></pre></td></tr></table></figure><p>二维指针是一个存放指针的指针，因此使用前需先开辟一段空间。 </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="指针数组与二维指针的区别："><a href="#指针数组与二维指针的区别：" class="headerlink" title="指针数组与二维指针的区别："></a>指针数组与二维指针的区别：</h4><p>由于二维指针储存的是指针，因此二维指针首先需要开辟空间，然后再在子元素上继续开辟空间，因此需要两步完成。</p><p>而指针数组由于本质上是数组，因此省略了第1步，只需在子元素上继续开辟空间。因此只需要1步完成。</p><p>以动态分配内存为例：</p><p>第1步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof(char *));//等价于 *ptr [3];</span><br></pre></td></tr></table></figure><p>第2步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof (char *));等价于 *ptr [3];</span><br><span class="line">for(i =0;i&lt;3;i++)</span><br><span class="line">    ptr[i] =malloc(sizeof(char)*10);//表示可以存放长度为10 的字符串。</span><br></pre></td></tr></table></figure><p>指针数组只需第2步，二维指针则需要1,2步。</p><p>而除此之外，基本再没有什么区别。他们的步长都是4，即一个指针的内存大小。</p><h4 id="指针数组与数组指针的区别："><a href="#指针数组与数组指针的区别：" class="headerlink" title="指针数组与数组指针的区别："></a>指针数组与数组指针的区别：</h4><p>首先，我们知道，二维数组ptr[2].[2]，ptr的实质是一个数组指针。我们知道，对于一维指针数组a[2]，a本质是指针，只不过a是一个常量指针，即a的值不能被修改。那么对于二维数组ptr[2].[2],ptr是一个常量数组指针，即ptr的值不可修改。</p><p>那么，他们本质的区别是什么呢。首先，对于char <em>p[3]，他的步长是4。即一个指针的内存大小。 </em> (p+1)=p[1],(int)(p+1)-(int)p=4。对于char( <em>p )[3],他的步长是3，即一个数组内存大小。 </em>(p+1) = p[1].[3],(int)(p+1)-(int)p=3。所以这就是为什么指针数组和数组指针不能相互赋值的原因。</p><h2 id="内存模型示意图"><a href="#内存模型示意图" class="headerlink" title="内存模型示意图"></a>内存模型示意图</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-26-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是针对二维指针的3种内存模型进行排序的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">/*排序并输出第1种内存模型:指针数组*/</span><br><span class="line">void sort_myArray1(char **myArray, int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针的指向*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char *tmp = myArray[j];</span><br><span class="line">myArray[j] = myArray[j - 1];</span><br><span class="line">myArray[j - 1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第2种内存模型：二维数组（数组指针）*/</span><br><span class="line">void sort_myArray2(char(*myArray)[4], int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针所指向内存的值*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char tmp[4];</span><br><span class="line">strcpy(tmp, myArray[j]);</span><br><span class="line">strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">strcpy(myArray[j - 1], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第3种内存模型：二维指针*/</span><br><span class="line">void sort_myArray3(char **myArray, int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针所指向内存的值，也可以改写成改变指针的指向*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char tmp[4];</span><br><span class="line">strcpy(tmp, myArray[j]);</span><br><span class="line">strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">strcpy(myArray[j - 1], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*为二级指针分配动态内存并赋值*/</span><br><span class="line">char**get_myArray3(int len) &#123;</span><br><span class="line">char**myArray = NULL;</span><br><span class="line">while ((myArray = (char**)malloc(3 * sizeof(char*))) == NULL) &#123;</span><br><span class="line">printf(&quot;Error.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">while ((myArray[i] = (char*)calloc(100, sizeof(char))) == NULL) &#123;</span><br><span class="line">printf(&quot;Error.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">sprintf(myArray[i], &quot;%d%d%d&quot;, i + 1, i + 2, i + 3);</span><br><span class="line">&#125;</span><br><span class="line">return myArray;</span><br><span class="line">&#125;</span><br><span class="line">/*将动态分配的内存空间释放掉*/</span><br><span class="line">void init_myArray3(char**myArray, int len) &#123;</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">if (myArray[i] != NULL) &#123;</span><br><span class="line">free(myArray[i]);</span><br><span class="line">myArray[i] = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">char*p1[] = &#123; &quot;123&quot;,&quot;456&quot;,&quot;789&quot; &#125;;/*第1种内存模型：指针数组*/</span><br><span class="line">char p2[3][4] = &#123; &quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot; &#125;;/*第2种内存模型：多维数组*/</span><br><span class="line">char**p3 = get_myArray3(3);/*第3种内存模型：二维指针*/</span><br><span class="line">sort_myArray1(p1, sizeof(p1) / sizeof(p1[0]));/*数组的指针个数*/</span><br><span class="line">sort_myArray2(p2, sizeof(p2) / sizeof(p2[0]));/*数组的行数*/</span><br><span class="line">sort_myArray3(p3, 3);/*由于sizeof(p3)为4，即一个指针的大小，故不能用sizeof(p3) / sizeof(p2[3])*/</span><br><span class="line">init_myArray3(p3, 3);</span><br><span class="line">if (p3 != NULL)</span><br><span class="line">free(p3);/*释放掉二维指针分配的内存*/</span><br><span class="line">p3 = NULL;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于指针，我们只需要从两个角度进行分析即可。&lt;/p&gt;
&lt;p&gt;第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） &lt;/p&gt;
&lt;p&gt;第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E6%8C%87%E9%92%88/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[C常量]C语言中的伪装大佬——伪常量const</title>
    <link href="http://qianyouyou.cn/2018/05/25/2018-05-25-1/"/>
    <id>http://qianyouyou.cn/2018/05/25/2018-05-25-1/</id>
    <published>2018-05-25T15:35:44.000Z</published>
    <updated>2018-05-26T10:44:02.243Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的const列出来，以免之后犯错。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先以int为例定义整形常量a的两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br></pre></td></tr></table></figure><p>当然，这两种方法其实是一样的，都代表的是整形常量。对于其他类型也是同样的方法。</p><p>不过对于指针，就有点特别了。首先强调，const和 <em> 的优先级是 </em> 优先级高于const。以下是以字符串为例的</p><p>3种定义方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *p;//char const *p;</span><br><span class="line">char * const p;</span><br><span class="line">const char * const p;//char const * const p;</span><br></pre></td></tr></table></figure><p>第一种指的是p是指向常量字符型数的指针，所指向的内存数据不可以被修改，但是本身可修改。</p><p>第2种指的是p是指向字符型数的常指针，所指向的内存数据可以被修改，但是本身不可被修改。</p><p>第3种是指向常量字符型数的常指针，所指向的内存数据补可被修改，本身也不可被修改。</p><h2 id="伪常量"><a href="#伪常量" class="headerlink" title="伪常量"></a>伪常量</h2><p>用法介绍完了，但为什么说C的const是伪常量呢？因为常量是不可被更改的，但const可以通过简介赋值所改变。我们首先说一下C中的const使用时需要注意的一些细节。</p><p>const是伪常量，无法用于数组的初始化和全局变量的初始化,本质就是限定一个变量不能直接赋值。</p><p>　　如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 #define A 10</span><br><span class="line">2 int arr[A];</span><br><span class="line">3 </span><br><span class="line">4 //const本质，伪常量 ,无法用于数组初始化和全局变量初始化</span><br><span class="line">5 /*</span><br><span class="line">6 const int B = 10;</span><br><span class="line">7 int arr[B];</span><br><span class="line">8 */</span><br></pre></td></tr></table></figure><p>　　但是如果局部变量是能够初始化编译并运行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 void main()</span><br><span class="line">2 &#123;</span><br><span class="line">3     const int B = 10;</span><br><span class="line">4     int arr[B];</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure><p>　　const是伪常量，都知道常量是不能改变值的。例如这样是根本无法编译的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 void main() &#123;</span><br><span class="line">2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line">3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line">4     const int num = 10;//num就是一个常量</span><br><span class="line">5     //num = 11; //const本质，限定一个变量不能直接赋值</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>　　前面一直强调const是伪常量，因为可以间接的去改变它的值。利用指针变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 void main() &#123;</span><br><span class="line"> 2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line"> 3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line"> 4     const int num = 10;//num就是一个常量</span><br><span class="line"> 5     //num = 11; //error const本质，限定一个变量不能直接赋值</span><br><span class="line"> 6 </span><br><span class="line"> 7     //间接改变常量值</span><br><span class="line"> 8     const int *p = &amp;num;//定义一个指针指向一个常量，存储num的地址</span><br><span class="line"> 9     int *pv = (int *)p;//对指向常量的指针进行强制转换</span><br><span class="line">10     *pv = 8;//对指针指向内容赋值</span><br><span class="line">11 </span><br><span class="line">12     printf(&quot;%d&quot;,num); //8</span><br><span class="line">13 </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>c语言的const是冒牌货。C语言const的含义是被称为一个不能被改变的普通变量 ，它会分配内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的cons
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="常量" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E5%B8%B8%E9%87%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="const" scheme="http://qianyouyou.cn/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>[组合数学]取石子</title>
    <link href="http://qianyouyou.cn/2018/05/25/2018-05-25/"/>
    <id>http://qianyouyou.cn/2018/05/25/2018-05-25/</id>
    <published>2018-05-25T14:42:37.000Z</published>
    <updated>2018-05-25T15:31:38.584Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。</p><h2 id="取石子"><a href="#取石子" class="headerlink" title="取石子"></a><a href="https://www.nowcoder.com/acm/contest/113/A" target="_blank" rel="noopener">取石子</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出四堆石子，石子数分别为a,b,c,d。规定每次只能从堆顶取走石子，问取走所有石子的方案数。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一行内读入四个由空格分隔的整数a,b,c,d， 输入均为不超过500的正整数</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示答案，答案对109+7取模</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5 4 2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p>输入均为不超过500的正整数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>我们一堆一堆的考虑。第一堆a，第2堆b，第3堆c，第4堆d。假如只有一堆，则只有1种情况，即C(a,a)。假如有两堆，我们可以当做这两堆石子的排列组合。可以算出两堆石子的方案数。即C(b,a+b)。第三堆我们可以把前两堆看成一堆，然后继续排列组合，即C(c,a+b+c)。第4队即C(d,a+b+c+d)。最后全部相乘即可，即C(a,a) <em> C(b,a+b) </em> C(c,a+b+c)*C(d,a+b+c+d)。</p><h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><p>首先想到暴力枚举，虽然一定超时。以下是代码。只需要把所有情况列一遍即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">ll a[4];</span><br><span class="line">ll cnt = 0;</span><br><span class="line">void dfs(ll a, ll b, ll c, ll d) &#123;</span><br><span class="line">if (!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!d) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">cnt %= 1000000000 + 7;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (a)</span><br><span class="line">dfs(a - 1, b, c, d);</span><br><span class="line">if (b)</span><br><span class="line">dfs(a, b - 1, c, d);</span><br><span class="line">if (c)</span><br><span class="line">dfs(a, b, c - 1, d);</span><br><span class="line">if (d)</span><br><span class="line">dfs(a, b, c, d - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">dfs(a[0], a[1], a[2], a[3]);</span><br><span class="line">printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>由于数据过大，c++没有大数类，所以用python首先A了一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = input().split()</span><br><span class="line">ans = 1</span><br><span class="line">sum = [int(f[0]),0,0,0]</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    sum[i]=sum[i-1]+int(f[i])</span><br><span class="line">    for j in range(sum[i]-int(f[i])+1,sum[i]+1):</span><br><span class="line">        ans*=j</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    for j in range(1,int(f[i])+1):</span><br><span class="line">        ans//=j</span><br><span class="line">ans%=1000000007</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><p>由于acm不能用python，所以只能再考虑c++。首先由于涉及到除法，所以不能直接取余。</p><p>我没知道公式：C(M,N)=C(M-1,N)+C(M-1，N-1)，这样把除法转化成加法，就可以模运算了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">init();</span><br><span class="line">ll ans = 1;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-M-N-模板"><a href="#C-M-N-模板" class="headerlink" title="C(M,N)模板"></a>C(M,N)模板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。&lt;/p&gt;
&lt;h2 id=&quot;取石子&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="http://qianyouyou.cn/tags/python/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="暴力枚举" scheme="http://qianyouyou.cn/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>[数据库]关系数据库标准语言sql</title>
    <link href="http://qianyouyou.cn/2018/05/22/2018-05-22/"/>
    <id>http://qianyouyou.cn/2018/05/22/2018-05-22/</id>
    <published>2018-05-22T04:39:35.000Z</published>
    <updated>2018-05-22T06:18:34.144Z</updated>
    
    <content type="html"><![CDATA[<p>有些人生而成功，像你。有些人生而失败，像我。——随笔</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SQL（Structured Query Language）</p><p>结构化查询语言，是关系数据库的标准语言。</p><p>SQL是一个通用的、功能极强的关系数据库语言。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="综合统一"><a href="#综合统一" class="headerlink" title="综合统一"></a>综合统一</h4><p>集数据查询，数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。</p><p>可以独立完成数据库生命周期中的全部活动：</p><ul><li>定义关系模式，插入数据，建立数据库； </li><li>对数据库中的数据进行查询和更新； </li><li>数据库重构和维护 </li><li>数据库安全性、完整性控制等</li></ul><p>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。</p><p>数据操作符统一</p><h4 id="高度非过程化"><a href="#高度非过程化" class="headerlink" title="高度非过程化"></a>高度非过程化</h4><p>非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径。</p><p>SQL只要提出“做什么”，无须了解存取路径。</p><p>存取路径的选择以及SQL的操作过程由系统自动完成。</p><h4 id="面向集合的操作方式"><a href="#面向集合的操作方式" class="headerlink" title="面向集合的操作方式"></a>面向集合的操作方式</h4><p>非关系数据模型采用面向记录的操作方式，操作对象是一条记录。</p><p>SQL采用集合操作方式 </p><ul><li><p>操作对象、查找结果可以是元组的集合 </p></li><li><p>一次插入、删除、更新操作的对象可以是元组的集合</p></li></ul><h4 id="以同一种语法结构提供多种使用方式"><a href="#以同一种语法结构提供多种使用方式" class="headerlink" title="以同一种语法结构提供多种使用方式"></a>以同一种语法结构提供多种使用方式</h4><p>SQL是独立的语言，能够独立地用于联机交互的使用方式。</p><p>SQL又是嵌入式语言，SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用。</p><h4 id="语言简洁，易学易用"><a href="#语言简洁，易学易用" class="headerlink" title="语言简洁，易学易用"></a>语言简洁，易学易用</h4><p>SQL功能极强，完成核心功能只用了9个动词。</p><table><thead><tr><th>SQL功能</th><th>动词</th></tr></thead><tbody><tr><td>数据查询</td><td>SELECT</td></tr><tr><td>数据定义</td><td>CREATE, DROP, ALTER</td></tr><tr><td>数据操纵</td><td>INSERT, UPDATE, DELETE</td></tr><tr><td>数据控制</td><td>GRANT, REVOKE</td></tr></tbody></table><h3 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h3><p>SQL支持关系数据库三级模式结构</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-22-sql%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" alt=""></p><h4 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h4><p>本身独立存在的表</p><p>SQL中一个关系就对应一个基本表</p><p>一个(或多个)基本表对应一个存储文件</p><p>一个表可以带若干索引</p><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><p>逻辑结构组成了关系数据库的内模式</p><p>物理结构是任意的，对用户透明</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>从一个或几个基本表</p><p>导出的表数据库中只存放视图的定义而不存放视图对应的数据</p><p>视图是一个虚表</p><p>用户可以在视图上再定义视图</p><h2 id="学生-课程数据库"><a href="#学生-课程数据库" class="headerlink" title="学生-课程数据库"></a>学生-课程数据库</h2><h3 id="学生-课程模式-S-T"><a href="#学生-课程模式-S-T" class="headerlink" title="学生-课程模式 S-T :"></a>学生-课程模式 S-T :</h3><p>学生表：Student(Sno,Sname,Ssex,Sage,Sdept)    </p><p>课程表：Course(Cno,Cname,Cpno,Ccredit)    </p><p>学生选课表：SC(Sno,Cno,Grade)</p><h3 id="Student表"><a href="#Student表" class="headerlink" title="Student表"></a>Student表</h3><table><thead><tr><th style="text-align:center">学  号 Sno</th><th style="text-align:center">姓  名 Sname</th><th style="text-align:center">性  别  Ssex</th><th style="text-align:center">年  龄  Sage</th><th style="text-align:center">所 在 系  Sdept</th></tr></thead><tbody><tr><td style="text-align:center">200215121</td><td style="text-align:center">李勇</td><td style="text-align:center">男</td><td style="text-align:center">20</td><td style="text-align:center">CS</td></tr><tr><td style="text-align:center">200215122</td><td style="text-align:center">刘晨</td><td style="text-align:center">女</td><td style="text-align:center">19</td><td style="text-align:center">CS</td></tr><tr><td style="text-align:center">200215123</td><td style="text-align:center">王敏</td><td style="text-align:center">女</td><td style="text-align:center">18</td><td style="text-align:center">MA</td></tr><tr><td style="text-align:center">200515125</td><td style="text-align:center">张立</td><td style="text-align:center">男</td><td style="text-align:center">19</td><td style="text-align:center">IS</td></tr></tbody></table><h3 id="Course表"><a href="#Course表" class="headerlink" title="Course表"></a>Course表</h3><table><thead><tr><th style="text-align:center">课程号 Cno</th><th style="text-align:center">课程名 Cname</th><th style="text-align:center">先行课 Cpno</th><th style="text-align:center">学分 Ccredit</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">5</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">数学</td><td style="text-align:center"></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">信息系统</td><td style="text-align:center">1</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">操作系统</td><td style="text-align:center">6</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">数据结构</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">数据处理</td><td style="text-align:center"></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">PASCAL语言</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr></tbody></table><h3 id="SC表"><a href="#SC表" class="headerlink" title="SC表"></a>SC表</h3><table><thead><tr><th style="text-align:center">学 号 Sno</th><th style="text-align:center">课程号   Cno</th><th style="text-align:center">成绩     Grade</th></tr></thead><tbody><tr><td style="text-align:center">200215121</td><td style="text-align:center">1</td><td style="text-align:center">92</td></tr><tr><td style="text-align:center">200215121</td><td style="text-align:center">2</td><td style="text-align:center">85</td></tr><tr><td style="text-align:center">200215121</td><td style="text-align:center">3</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">200215122</td><td style="text-align:center">2</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">200215122</td><td style="text-align:center">3</td><td style="text-align:center">80</td></tr></tbody></table><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL的数据定义功能: 模式定义、表定义、视图和索引的定义</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-22-sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.png" alt=""></p><h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>[例1]定义一个学生-课程模式S-T</p><p><strong>CREATE SCHEMA “S-T” AUTHORIZATION WANG;</strong></p><p>为用户WANG定义了一个模式S-T</p><p>[例2]<strong>CREATE SCHEMA AUTHORIZATION WANG；</strong></p><p>&lt;模式名&gt;隐含为用户名WANG</p><p>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</p><h4 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h4><p>定义模式实际上定义了一个<strong>命名空间</strong></p><p>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</p><p>在<strong>CREATE SCHEMA</strong>中可以接受<strong>CREATE TABLE</strong>，<strong>CREATE VIEW</strong>和<strong>GRANT</strong>子句。</p><p><strong>CREATE SCHEMA [&lt;模式名&gt;] AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</strong></p><p>[例3]</p><p><strong>CREATE SCHEMA TEST AUTHORIZATION ZHANG</strong></p><p>​     <strong>CREATE TABLE TAB1(COL1 SMALLINT，</strong></p><p>​                                             <strong>COL2 INT，</strong></p><p>​                                            <strong>COL3 CHAR(20)，</strong></p><p>​                                            <strong>COL4 NUMERIC(10，3)，</strong></p><p>​                                            <strong>COL5 DECIMAL(5，2)</strong></p><p>​                                          <strong>)；</strong></p><p>​    为用户ZHANG创建了一个模式TEST，并在其中定义了一个表TAB1。</p><h4 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h4><p><strong>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</strong></p><p>CASCADE(级联)    </p><p>删除模式的同时把该模式中所有的数据库对象全部删除RESTRICT(限制)   </p><p>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</p><p>当该模式中没有任何下属的对象时才能执行。</p><p>[例4]  <strong>DROP SCHEMA TEST CASCADE；</strong></p><p>​         删除模式ZHANG</p><p>​         同时该模式中定义的表TAB1也被删除</p><h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><p><strong>CREATE TABLE &lt;表名&gt;</strong></p><p>​      <strong>（&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]</strong></p><p>​    <strong>[，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] …</strong></p><p>​    <strong>[，&lt;表级完整性约束条件&gt; ] ）；</strong></p><p>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</p><p>[例5]  建立“学生”表Student，学号是主码，姓名取值唯一。</p><p>CREATE TABLE Student</p><p>​                    (Sno   CHAR(9) <strong>PRIMARY KEY</strong>， /<em> 列级完整性约束条件 </em>/</p><p>​            Sname  CHAR(20) <strong>UNIQUE</strong>，     /<em> Sname取唯一值</em>/  </p><p>​            Ssex    CHAR(2)，</p><p>​            Sage   SMALLINT，</p><p>​             Sdept  CHAR(20)</p><p>​            )；</p><p>​            [，<strong>PRIMARY KEY （Sno）</strong>] </p><p>[例6] 建立一个“课程”表Course</p><p>CREATE TABLE  Course</p><p>​               ( Cno       CHAR(4) PRIMARY KEY，</p><p>​                 Cname  CHAR(40)，</p><p>​                 Cpno     CHAR(4) ，    /<em> 先行课 </em>/</p><p>​                    Ccredit  SMALLINT，</p><p>​                FOREIGN KEY (Cpno) REFERENCES  Course(Cno)    /<em> Cpno是外码，被参照表是Course，被参照列是Cno </em>/</p><p>​             ); </p><p>[例7]  建立一个“学生选课”表SC</p><p>CREATE TABLE  SC</p><p>​           (Sno  CHAR(9)，</p><p>​        Cno  CHAR(4)，</p><p>​        Grade    SMALLINT，</p><p>​           PRIMARY KEY (Sno，Cno)，/<em> 主码由两个属性构成，必须作为表级完整性进行定义</em>/</p><p>​    FOREIGN KEY (Sno) REFERENCES Student(Sno)，    /<em> 表级完整性约束条件，Sno是外码，被参照表是Student </em>/ </p><p>​    FOREIGN KEY (Cno) REFERENCES Course(Cno)     /<em> 表级完整性约束条件， Cno是外码，被参照表是Course</em>/    </p><p>); </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>SQL中域的概念用数据类型来实现</p><p>定义表的属性时 需要指明其数据类型及长度</p><p>选用哪种数据类型</p><ul><li><p>取值范围</p></li><li><p>要做哪些运算</p></li></ul><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>CHAR(n)</td><td>长度为n的定长字符串</td></tr><tr><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr><td>INT</td><td>长整数（也可以写作INTEGER）</td></tr><tr><td>SMALLINT</td><td>短整数</td></tr><tr><td>NUMERIC(p，d)</td><td>定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字</td></tr><tr><td>REAL</td><td>取决于机器精度的浮点数</td></tr><tr><td>Double Precision</td><td>取决于机器精度的双精度浮点数</td></tr><tr><td>FLOAT(n)</td><td>浮点数，精度至少为n位数字</td></tr><tr><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr></tbody></table><h4 id="模式与表"><a href="#模式与表" class="headerlink" title="模式与表"></a>模式与表</h4><p>每一个基本表都属于某一个模式</p><p>一个模式包含多个基本表</p><h5 id="定义基本表所属模式"><a href="#定义基本表所属模式" class="headerlink" title="定义基本表所属模式"></a>定义基本表所属模式</h5><p>方法一：在表名中明显地给出模式名 </p><p>Create table “S-T”.Student（……）;   /<em>模式名为 S-T</em>/</p><p>Create table “S-T”.Cource（……）;</p><p>Create table “S-T”.SC（……）; </p><p>方法二：在创建模式语句中同时创建表 </p><p>方法三：设置所属的模式</p><p>创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p><p>RDBMS会使用模式列表中第一个存在的模式作为数据库对象的模式名 。</p><p>若搜索路径中的模式名都不存在，系统将给出错误 </p><p>显示当前的搜索路径： SHOW search_path; </p><p>搜索路径的当前默认值是：$user， PUBLIC</p><p>先搜索与用户名相同的模式，若不存在，则使用PUBLIC </p><h5 id="模式与表-1"><a href="#模式与表-1" class="headerlink" title="模式与表"></a>模式与表</h5><p>DBA用户可以设置搜索路径，然后定义基本表</p><p>​      <strong>SET search_path TO “S-T”，PUBLIC；</strong></p><p>​     <strong>Create table Student（……）;</strong> </p><p>  结果建立了S-T.Student基本表。</p><p>RDBMS发现搜索路径中第一个模式名S-T存在，就把该模式作为基本表Student所属的模式。</p><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><p>ALTER TABLE &lt;表名&gt;</p><p>[ ADD [&lt;新列名&gt; &lt;数据类型&gt;].[完整性约束 ]]</p><p>[ DROP &lt;完整性约束名&gt; ]</p><p>[ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]；</p><p>  <strong>MODIFY</strong></p><p>  <strong>约束（属性名）</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些人生而成功，像你。有些人生而失败，像我。——随笔&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SQL（Structured Query Language）&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="关系数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="sql语言" scheme="http://qianyouyou.cn/tags/sql%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>[数据库]数据库概论基础整理</title>
    <link href="http://qianyouyou.cn/2018/05/21/2018-05-21/"/>
    <id>http://qianyouyou.cn/2018/05/21/2018-05-21/</id>
    <published>2018-05-21T05:29:08.000Z</published>
    <updated>2018-05-21T14:52:40.030Z</updated>
    
    <content type="html"><![CDATA[<p>努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔</p><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><h4 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h4><p>数据(Data)：数据库中存储的基本对象。</p><p>定义：描述事物的符号记录</p><p>种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>数据与其语义是不可分的。</p><p>eg：</p><p>54是一个数据</p><p>语义1：学生某门课的成绩</p><p>语义2：某人的体重</p><p>语义3：计算机系2011级学生人数</p><p>eg:</p><p>学生档案中的学生记录</p><p>（张三，男，19941014，陕西西安市，计算机系，2011）</p><p>语义：学生姓名、性别、出生年月、籍贯、所在院系、入学时间</p><p>解释：张三是个大学生，1994年10月14日出生，陕西省西安市人，2011年考入计算机系</p><h4 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h4><p>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>数据按一定的数据模型组织、描述和储存</p><p>可为各种用户共享</p><p>冗余度较小</p><p>数据独立性较高</p><p>易扩展</p><h4 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>位于用户与操作系统之间的一层数据管理软件。</p><p>是基础软件，是一个大型复杂的软件系统</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>科学地组织和存储数据、高效地获取和维护数据。</p><h5 id="数据库在计算机系统中的位置"><a href="#数据库在计算机系统中的位置" class="headerlink" title="数据库在计算机系统中的位置"></a>数据库在计算机系统中的位置</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-DBMS.png" alt=""></p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><table><thead><tr><th><strong>数据定义功能</strong></th><th>提供数据定义语言(DDL)</th><th>定义数据库中的数据对象</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>数据组织、存储和管理</strong></td><td>分类组织、存储和管理各种数据</td><td>确定组织数据的文件结构和存取方式</td><td>实现数据之间的联系</td><td>提供多种存取方法提高存取效率</td><td></td></tr><tr><td><strong>数据操纵功能</strong></td><td>提供数据操纵语言(DML)</td><td>实现对数据库的基本操作  (增删改查)</td><td></td><td></td><td></td></tr><tr><td><strong>数据库的事务管理和运行管理</strong></td><td>数据库在建立、运行和维护时由DBMS统一管理和控制</td><td>保证数据的安全性、完整性、多用户对数据的并发使用</td><td>发生故障后的系统恢复</td><td></td><td></td></tr><tr><td><strong>数据库的建立和维护功能(实用程序和管理工具)</strong></td><td>数据库初始数据装载转换</td><td>数据库转储</td><td>介质故障恢复</td><td>数据库的重组织</td><td>性能监视分析等</td></tr><tr><td><strong>其它功能</strong></td><td>DBMS与网络中其它软件系统的通信</td><td>两个DBMS系统的数据转换</td><td>异构数据库之间的互访和互操作</td><td></td></tr></tbody></table><h4 id="数据库系统（DBS"><a href="#数据库系统（DBS" class="headerlink" title="数据库系统（DBS)"></a>数据库系统（DBS)</h4><p>Database System，在计算机系统中引入数据库后的系统。</p><h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>数据库</p><p>数据库管理系统（及其开发工具）</p><p>应用系统</p><p>数据库管理员</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-05-21-DBS.png" alt=""></p><h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><h4 id="什么是数据管理"><a href="#什么是数据管理" class="headerlink" title="什么是数据管理"></a>什么是数据管理</h4><p>对数据进行分类、组织、编码、存储、检索和维护</p><p>是数据处理的中心问题</p><p>数据处理：对各种数据进行收集、存储、加工和传播。</p><h4 id="数据管理技术的发展过程"><a href="#数据管理技术的发展过程" class="headerlink" title="数据管理技术的发展过程"></a>数据管理技术的发展过程</h4><p>人工管理阶段(20世纪40年代中–50年代中)</p><p>文件系统阶段(20世纪50年代末–60年代中)</p><p>数据库系统阶段(20世纪60年代末–现在)</p><h4 id="数据管理技术的发展动力"><a href="#数据管理技术的发展动力" class="headerlink" title="数据管理技术的发展动力"></a>数据管理技术的发展动力</h4><p>应用需求的推动</p><p>计算机硬件的发展</p><p>计算机软件的发展</p><h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><h4 id="数据结构化"><a href="#数据结构化" class="headerlink" title="数据结构化"></a>数据结构化</h4><p>整体数据的结构化是数据库的主要特征之一。</p><h5 id="整体结构化"><a href="#整体结构化" class="headerlink" title="整体结构化"></a>整体结构化</h5><p>不再仅仅针对某一个应用，而是面向全组织</p><p>不仅数据内部结构化，整体是结构化的，数据之间具有联系</p><h5 id="数据库中实现的是数据的真正结构化"><a href="#数据库中实现的是数据的真正结构化" class="headerlink" title="数据库中实现的是数据的真正结构化"></a>数据库中实现的是数据的真正结构化</h5><p>数据的结构用数据模型描述，无需程序定义和解释</p><p>数据可以变长</p><p>数据的最小存取单位是数据项</p><h4 id="数据的共享性高，冗余度低，易扩充"><a href="#数据的共享性高，冗余度低，易扩充" class="headerlink" title="数据的共享性高，冗余度低，易扩充"></a>数据的共享性高，冗余度低，易扩充</h4><p>数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。</p><h5 id="数据共享的好处"><a href="#数据共享的好处" class="headerlink" title="数据共享的好处"></a>数据共享的好处</h5><p>减少数据冗余，节约存储空间</p><p>避免数据之间的不相容性与不一致性</p><p>使系统易于扩充</p><h4 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h4><p>数据独立性是由DBMS的二级映像功能来保证的。</p><h5 id="物理独立性"><a href="#物理独立性" class="headerlink" title="物理独立性"></a>物理独立性</h5><p>指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</p><h5 id="逻辑独立性"><a href="#逻辑独立性" class="headerlink" title="逻辑独立性"></a>逻辑独立性</h5><p>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</p><h4 id="数据由DBMS统一管理和控制"><a href="#数据由DBMS统一管理和控制" class="headerlink" title="数据由DBMS统一管理和控制"></a>数据由DBMS统一管理和控制</h4><h5 id="DBMS提供的数据控制功能"><a href="#DBMS提供的数据控制功能" class="headerlink" title="DBMS提供的数据控制功能"></a>DBMS提供的数据控制功能</h5><p>(1)数据的安全性（Security）</p><p>保护保护数据，以防止不合法的使用造成的数据的泄密和破坏。</p><p>(2)数据的完整性（Integrity）</p><p>检查将数据控制在有效的范围内，或保证数据之间满足一定的关系。</p><p>(3)并发（Concurrency）</p><p>控制对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p><p>(4)数据库恢复（Recovery）</p><p>将数据库从错误状态恢复到某一已知的正确状态。</p><h5 id="应用程序与数据的对应关系-数据库系统"><a href="#应用程序与数据的对应关系-数据库系统" class="headerlink" title="应用程序与数据的对应关系(数据库系统)"></a>应用程序与数据的对应关系(数据库系统)</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-05-21-DBS2.png" alt=""></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="两大类数据模型"><a href="#两大类数据模型" class="headerlink" title="两大类数据模型"></a>两大类数据模型</h3><p>数据模型分为两类（分属两个不同的层次）</p><p>(1) 概念模型</p><p>也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</p><p>(2) 逻辑模型和物理模型</p><p>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。</p><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</p><p>设计人员了解和选择物理模型。</p><p><strong>客观对象的抽象过程—两步抽象</strong></p><p>现实世界中的客观对象抽象为概念模型；</p><p>把概念模型转换为某一DBMS支持的数据模型。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E4%B8%A4%E5%A4%A7%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="数据模型组成元素"><a href="#数据模型组成元素" class="headerlink" title="数据模型组成元素"></a>数据模型组成元素</h3><p>数据结构，数据操作，完整性约束条件</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>描述数据库的组成对象，以及对象之间的联系</p><p>数据结构是对系统静态特性的描述（描述对象类型的集合）</p><h5 id="描述的内容"><a href="#描述的内容" class="headerlink" title="描述的内容"></a>描述的内容</h5><p>与数据类型、内容、性质有关的对象（域、属性、关系）</p><p>与数据之间联系有关的对象</p><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则</p><h5 id="数据操作的类型"><a href="#数据操作的类型" class="headerlink" title="数据操作的类型"></a>数据操作的类型</h5><p>查询</p><p>更新(包括插入、删除、修改)</p><h5 id="数据模型对操作的定义"><a href="#数据模型对操作的定义" class="headerlink" title="数据模型对操作的定义"></a>数据模型对操作的定义</h5><p>操作的确切含义</p><p>操作符号</p><p>操作规则（如优先级）</p><p>实现操作的语言</p><p><strong>数据操作是对系统动态特性的描述</strong></p><h4 id="数据的完整性约束条件"><a href="#数据的完整性约束条件" class="headerlink" title="数据的完整性约束条件"></a>数据的完整性约束条件</h4><p>一组完整性规则的集合。</p><p>完整性规则：给定的数据模型中数据及其联系所具有的制约和储存规则</p><p>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</p><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>反映和规定本数据模型必须遵守的基本的通用的完整性约束条件。例如在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。</p><p>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。如：退休</p><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>概念模型用于信息世界的建模</p><p>是现实世界到机器世界的一个中间层次</p><p>是数据库设计的有力工具</p><p>数据库设计人员和用户之间进行交流的语言</p><h4 id="对概念模型的基本要求"><a href="#对概念模型的基本要求" class="headerlink" title="对概念模型的基本要求"></a>对概念模型的基本要求</h4><p>较强的语义表达能力</p><p>能够方便、直接地表达应用中的各种语义知识</p><p>简单、清晰、易于用户理解</p><h4 id="信息世界中的基本概念"><a href="#信息世界中的基本概念" class="headerlink" title="信息世界中的基本概念"></a>信息世界中的基本概念</h4><h5 id="实体（Entity）"><a href="#实体（Entity）" class="headerlink" title="实体（Entity）"></a>实体（Entity）</h5><p>客观存在并可相互区别的事物称为实体。</p><p>可以是具体的人、事、物或抽象的概念。如：选课</p><h5 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h5><p>实体所具有的某一特性称为属性。</p><p>一个实体可以由若干个属性来刻画。</p><h5 id="码（Key）"><a href="#码（Key）" class="headerlink" title="码（Key）"></a>码（Key）</h5><p> 唯一标识实体的属性集称为码。如：Snum</p><h5 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h5><p>属性的取值范围称为该属性的域。  如：Grade</p><h5 id="实体型（Entity-Type）"><a href="#实体型（Entity-Type）" class="headerlink" title="实体型（Entity Type）"></a>实体型（Entity Type）</h5><p> 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 如：Student(Snum,Sname,Grade )</p><h5 id="实体集（Entity-Set）"><a href="#实体集（Entity-Set）" class="headerlink" title="实体集（Entity Set）"></a>实体集（Entity Set）</h5><p>同一类型实体的集合称为实体集</p><h5 id="联系（Relationship）"><a href="#联系（Relationship）" class="headerlink" title="联系（Relationship）"></a>联系（Relationship）</h5><p>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。</p><p>实体内部的联系通常是指组成实体的各属性之间的联系</p><p>实体之间的联系通常是指不同实体集之间的联系</p><h4 id="两个实体型之间的联系"><a href="#两个实体型之间的联系" class="headerlink" title="两个实体型之间的联系"></a>两个实体型之间的联系</h4><p>用图形来表示两个实体型之间的这三类联系</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E4%B8%A4%E5%A4%A7%E5%AE%9E%E4%BD%93.png" alt=""></p><h5 id="一对一联系（1-1）"><a href="#一对一联系（1-1）" class="headerlink" title="一对一联系（1:1）"></a>一对一联系（1:1）</h5><p> 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1</p><p>实例</p><p>一个班级只有一个正班长，一个班长只在一个班中任职</p><h5 id="一对多联系（1：n）"><a href="#一对多联系（1：n）" class="headerlink" title="一对多联系（1：n）"></a>一对多联系（1：n）</h5><p>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n</p><p>实例</p><p>一个班级中有若干名学生，每个学生只在一个班级中学习</p><h5 id="多对多联系（m-n）"><a href="#多对多联系（m-n）" class="headerlink" title="多对多联系（m:n）"></a>多对多联系（m:n）</h5><p>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n</p><p>实例</p><p>课程与学生之间的联系：一门课程同时有若干个学生选修，一个学生可以同时选修多门课程</p><h4 id="两个以上实体型之间的联系"><a href="#两个以上实体型之间的联系" class="headerlink" title="两个以上实体型之间的联系"></a>两个以上实体型之间的联系</h4><h5 id="两个以上实体型之间一对多联系"><a href="#两个以上实体型之间一对多联系" class="headerlink" title="两个以上实体型之间一对多联系"></a>两个以上实体型之间一对多联系</h5><p>若实体集E1，E2，…，En存在联系，对于实体集Ej（j=1，2，…，i-1，i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的</p><p>实例</p><p>课程、教师与参考书三个实体型一门课程可以有若干个教师讲授，使用若干本参考书，每一个教师只讲授一门课程，每一本参考书只供一门课程使用课程与教师、参考书之间1：n</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A1%EF%BC%9An.png" alt=""></p><h5 id="两个以上实体型间的多对多联系"><a href="#两个以上实体型间的多对多联系" class="headerlink" title="两个以上实体型间的多对多联系"></a>两个以上实体型间的多对多联系</h5><p>两个以上实体型间的多对多联系</p><p>实例</p><p>供应商、项目、零件三个实体型,一个供应商可以供给多个项目多种零件,每个项目可以使用多个供应商供应的零件,每种零件可由不同供应商供给</p><h4 id="单个实体型内的联系"><a href="#单个实体型内的联系" class="headerlink" title="单个实体型内的联系"></a>单个实体型内的联系</h4><h5 id="一对一联系"><a href="#一对一联系" class="headerlink" title="一对一联系"></a>一对一联系</h5><h5 id="一对多联系"><a href="#一对多联系" class="headerlink" title="一对多联系"></a>一对多联系</h5><p>实例</p><p>职工实体型内部具有领导与被领导的联系,某一职工（干部）“领导”若干名职工,一个职工仅被另外一个职工直接领导,这是一对多的联系</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E5%AE%9E%E4%BD%93%E5%86%85%E9%83%A8-1%EF%BC%9An.png" alt=""></p><h5 id="多对多联系"><a href="#多对多联系" class="headerlink" title="多对多联系"></a>多对多联系</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E5%AE%9E%E4%BD%93%E5%86%85%E9%83%A8-m%EF%BC%9An.png" alt=""></p><h4 id="概念模型的一种表示方法"><a href="#概念模型的一种表示方法" class="headerlink" title="概念模型的一种表示方法"></a>概念模型的一种表示方法</h4><h5 id="实体－联系方法-E-R方法"><a href="#实体－联系方法-E-R方法" class="headerlink" title="实体－联系方法(E-R方法)"></a>实体－联系方法(E-R方法)</h5><p>用E-R图来描述现实世界的概念模型</p><p>E-R方法也称为E-R模型</p><h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h5><p><strong>实体型</strong></p><p>用矩形表示，矩形框内写明实体名。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E5%AE%9E%E4%BD%93%E5%9E%8B.png" alt=""></p><p><strong>属性</strong></p><p>用椭圆形表示，并用无向边将其与相应的实体连接起来</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-ER%E5%B1%9E%E6%80%A7.png" alt=""></p><p><strong>联系</strong></p><p>联系本身：   用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-ER%E5%85%B3%E7%B3%BB.png" alt=""></p><p>联系的属性：</p><p>联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-ER%E8%81%94%E7%B3%BB%E5%B1%9E%E6%80%A7.png" alt=""></p><h3 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h3><h4 id="非关系模型（格式化模型）"><a href="#非关系模型（格式化模型）" class="headerlink" title="非关系模型（格式化模型）"></a>非关系模型（格式化模型）</h4><p>层次模型(Hierarchical Model)  实体-&gt;记录</p><p>网状模型(Network Model)       属性-&gt;字段（数据项）</p><h5 id="非关系模型中数据结构基本单位"><a href="#非关系模型中数据结构基本单位" class="headerlink" title="非关系模型中数据结构基本单位"></a>非关系模型中数据结构基本单位</h5><p>基本层次联系：两个记录以及它们之间的一对多（包括一对一）的联系。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-%E5%9F%BA%E6%9C%AC%E5%B1%82%E6%AC%A1%E8%81%94%E7%B3%BB.png" alt=""></p><h4 id="关系模型-Relational-Model"><a href="#关系模型-Relational-Model" class="headerlink" title="关系模型(Relational Model)"></a>关系模型(Relational Model)</h4><h4 id="面向对象模型-Object-Oriented-Model）"><a href="#面向对象模型-Object-Oriented-Model）" class="headerlink" title="面向对象模型(Object Oriented Model）"></a>面向对象模型(Object Oriented Model）</h4><h4 id="对象关系模型-Object-Relational-Model"><a href="#对象关系模型-Object-Relational-Model" class="headerlink" title="对象关系模型(Object Relational Model)"></a>对象关系模型(Object Relational Model)</h4><h3 id="层次模型-最早的模型"><a href="#层次模型-最早的模型" class="headerlink" title="层次模型(最早的模型)"></a>层次模型(最早的模型)</h3><p>层次模型用树形结构来表示各类实体以及实体间的联系  </p><p><strong>满足下面两个条件的基本层次联系的集合为层次模型</strong></p><ol><li>有且只有一个结点没有双亲结点，这个结点称为根结点</li><li>根以外的其它结点有且只有一个双亲结点</li></ol><p><strong>层次模型中的几个术语</strong></p><p>根结点，双亲结点，兄弟结点（同一双亲的节点），叶结点（没有子女的节点）</p><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>网状数据库系统采用网状模型作为数据的组织方式</p><p>满足下面两个条件的基本层次联系的集合：</p><ol><li>允许一个以上的结点无双亲；</li><li>一个结点可以有多于一个的双亲。</li></ol><p>表示方法(与层次数据模型相同)</p><p>实体型：用记录类型描述每个结点表示一个记录类型（实体）</p><p>属性：用字段描述每个记录类型可包含若干个字段</p><p>联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系数据库系统采用关系模型作为数据的组织方式。</p><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><h4 id="关系（Relation）"><a href="#关系（Relation）" class="headerlink" title="关系（Relation）"></a>关系（Relation）</h4><p>一个关系对应通常说的一张表</p><h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>表中的一行即为一个元组</p><h4 id="属性（Attribute）-1"><a href="#属性（Attribute）-1" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h4><p>表中的一列即为一个属性，给每一个属性起一个名称即属性名</p><h4 id="主码（Key）"><a href="#主码（Key）" class="headerlink" title="主码（Key）"></a>主码（Key）</h4><p>表中的某个属性或属性组，它可以唯一确定一个元组。</p><h4 id="域（Domain）-1"><a href="#域（Domain）-1" class="headerlink" title="域（Domain）"></a>域（Domain）</h4><p>属性的取值范围。</p><h4 id="分量"><a href="#分量" class="headerlink" title="分量"></a>分量</h4><p>元组中的一个属性值。</p><h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>对关系的描述</p><p>关系名（属性1，属性2，…，属性n）</p><p>学生（学号，姓名，年龄，性别，系，年级）</p><h4 id="术语对比"><a href="#术语对比" class="headerlink" title="术语对比"></a>术语对比</h4><table><thead><tr><th>关系术语</th><th>一般表格的术语</th></tr></thead><tbody><tr><td>关系名</td><td>表名</td></tr><tr><td>关系模式</td><td>表头（表格的描述）</td></tr><tr><td>关系</td><td>（一张）二维表</td></tr><tr><td>元组</td><td>记录或行</td></tr><tr><td>属性</td><td>列</td></tr><tr><td>属性名</td><td>列名</td></tr><tr><td>属性值</td><td>列值</td></tr><tr><td>分量</td><td>一条记录中的一个列值</td></tr><tr><td>非规范关系</td><td>表中有表（大表中嵌有小表）</td></tr></tbody></table><p>关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。</p><h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><p>查询</p><p>插入</p><p>删除</p><p>更新</p><p>数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合</p><p>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</p><h4 id="关系的完整性约束条件"><a href="#关系的完整性约束条件" class="headerlink" title="关系的完整性约束条件"></a>关系的完整性约束条件</h4><p>实体完整性</p><p>参照完整性</p><p>用户定义的完整性</p><h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><p>从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。</p><p>从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为:</p><p>单用户结构</p><p>主从式结构分布式结构</p><p>客户／服务器</p><p>浏览器／应用服务器／数据库服务器多层结构等</p><h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><h4 id="“型”-和“值”-的概念"><a href="#“型”-和“值”-的概念" class="headerlink" title="“型” 和“值” 的概念"></a>“型” 和“值” 的概念</h4><h5 id="型-Type"><a href="#型-Type" class="headerlink" title="型(Type)"></a>型(Type)</h5><p>对某一类数据的结构和属性的说明</p><h5 id="值-Value"><a href="#值-Value" class="headerlink" title="值(Value)"></a>值(Value)</h5><p>是型的一个具体赋值例如学生记录</p><p>型：  （学号，姓名，性别，系别，年龄，籍贯）一个记录</p><p>值：  （900201，李明，男，计算机，22，江苏）</p><h4 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h4><p>数据库逻辑结构和特征的描述</p><p>是型的描述</p><p>反映的是数据的结构及其联系</p><p>模式是相对稳定的</p><h4 id="实例（Instance）"><a href="#实例（Instance）" class="headerlink" title="实例（Instance）"></a>实例（Instance）</h4><p>模式的一个具体值</p><p>反映数据库某一时刻的状态</p><p>同一个模式可以有很多实例实例</p><p>随数据库中的数据的更新而变动</p><p>例如：在学生选课数据库模式中，包含学生记录、课程记录和学生选课记录 </p><p>2013年的一个学生数据库实例，包含：</p><p>2013年学校中所有学生的记录</p><p>学校开设的所有课程的记录</p><p>所有学生选课的记录 </p><p>2012年度学生数据库模式对应的实例与2013年度学生数据库模式对应的实例是不同的 </p><h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" alt=""></p><h4 id="模式（Schema也称逻辑模式）"><a href="#模式（Schema也称逻辑模式）" class="headerlink" title="模式（Schema也称逻辑模式）"></a>模式（Schema也称逻辑模式）</h4><p>数据库中全体数据的逻辑结构和特征的描述</p><p>所有用户的公共数据视图，综合了所有用户的需求</p><p><strong>一个数据库只有一个模式</strong></p><h5 id="模式的地位："><a href="#模式的地位：" class="headerlink" title="模式的地位："></a>模式的地位：</h5><p>是数据库系统模式结构的中间层与数据的物理存储细节和硬件环境无关</p><p>与具体的应用程序、开发工具及高级程序设计语言无关</p><h5 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h5><p>数据的逻辑结构（数据项的名字、类型、取值范围等）</p><p>数据之间的联系</p><p>数据有关的安全性、完整性要求</p><h4 id="外模式（External-Schema也称子模式或用户模式）"><a href="#外模式（External-Schema也称子模式或用户模式）" class="headerlink" title="外模式（External Schema也称子模式或用户模式）"></a>外模式（External Schema也称子模式或用户模式）</h4><p>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</p><p>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p><h5 id="模式与外模式的关系：一对多"><a href="#模式与外模式的关系：一对多" class="headerlink" title="模式与外模式的关系：一对多"></a>模式与外模式的关系：一对多</h5><p>外模式通常是模式的子集</p><p>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</p><p>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</p><h5 id="外模式与应用的关系：一对多"><a href="#外模式与应用的关系：一对多" class="headerlink" title="外模式与应用的关系：一对多"></a>外模式与应用的关系：一对多</h5><p>同一外模式也可以为某一用户的多个应用系统所使用</p><p>但一个应用程序只能使用一个外模式</p><h5 id="外模式的用途"><a href="#外模式的用途" class="headerlink" title="外模式的用途"></a>外模式的用途</h5><p>保证数据库安全性的一个有力措施</p><p>每个用户只能看见和访问所对应的外模式中的数据</p><h4 id="内模式（Internal-Schema也称存储模式）"><a href="#内模式（Internal-Schema也称存储模式）" class="headerlink" title="内模式（Internal Schema也称存储模式）"></a>内模式（Internal Schema也称存储模式）</h4><p>一个数据库只有一个内模式</p><h5 id="是数据物理结构和存储方式的描述"><a href="#是数据物理结构和存储方式的描述" class="headerlink" title="是数据物理结构和存储方式的描述"></a>是数据物理结构和存储方式的描述</h5><h5 id="是数据在数据库内部的表示方式"><a href="#是数据在数据库内部的表示方式" class="headerlink" title="是数据在数据库内部的表示方式"></a>是数据在数据库内部的表示方式</h5><p>记录的存储方式（堆存储，顺序存储，聚簇存储）</p><p> 索引的组织方式（B+树索引，按hash索引存储）</p><p>数据是否压缩存储</p><p>数据是否加密</p><p>数据存储记录结构的规定</p><p>数据库的二级映像功能与数据独立性</p><h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>三级模式是对数据的三个抽象级别</p><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p><h4 id="外模式／模式映象"><a href="#外模式／模式映象" class="headerlink" title="外模式／模式映象"></a>外模式／模式映象</h4><p>模式：描述的是数据的全局逻辑结构</p><p>外模式：描述的是数据的局部逻辑结构 </p><p>同一个模式可以有任意多个外模式 </p><p>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</p><p>映象定义通常包含在各自外模式的描述中</p><h5 id="保证数据的逻辑独立性"><a href="#保证数据的逻辑独立性" class="headerlink" title="保证数据的逻辑独立性"></a>保证数据的逻辑独立性</h5><p>当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</p><p>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p><h4 id="模式／内模式映像"><a href="#模式／内模式映像" class="headerlink" title="模式／内模式映像"></a>模式／内模式映像</h4><p>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的</p><p>数据库中模式／内模式映象是唯一的</p><p>该映象定义通常包含在模式描述中</p><h5 id="保证数据的物理独立性"><a href="#保证数据的物理独立性" class="headerlink" title="保证数据的物理独立性"></a>保证数据的物理独立性</h5><p>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变</p><p>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</p><h5 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h5><p>即全局逻辑结构是数据库的中心与关键 </p><p>独立于数据库的其他层次 </p><p>设计数据库模式结构时应首先确定数据库的逻辑模式</p><h5 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h5><p>依赖于它的全局逻辑结构</p><p>独立于数据库的用户视图，即外模式</p><p>独立于具体的存储设备  </p><p>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 </p><h5 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h5><p>面向具体的应用程序</p><p>定义在逻辑模式之上</p><p>独立于存储模式和存储设备</p><p>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 </p><p>设计外模式时应充分考虑到应用的扩充性 </p><h5 id="特定的应用程序"><a href="#特定的应用程序" class="headerlink" title="特定的应用程序"></a>特定的应用程序</h5><p>在外模式描述的数据结构上编制的</p><p>依赖于特定的外模式</p><p>与数据库的模式和存储结构独立</p><p>不同的应用程序有时可以共用同一个外模式</p><h5 id="数据库的二级映像"><a href="#数据库的二级映像" class="headerlink" title="数据库的二级映像"></a>数据库的二级映像</h5><p>保证了数据库外模式的稳定性</p><p>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 </p><p><strong>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去</strong> </p><h5 id="数据的存取由DBMS管理"><a href="#数据的存取由DBMS管理" class="headerlink" title="数据的存取由DBMS管理"></a>数据的存取由DBMS管理</h5><p>用户不必考虑存取路径等细节</p><p>简化了应用程序的编制</p><p>大大减少了应用程序的维护和修改</p><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>数据库</p><p>数据库管理系统（及其开发工具）</p><p>应用系统</p><p>数据库管理员</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔&lt;/p&gt;
&lt;h2 id=&quot;数据库系统概述&quot;&gt;&lt;a href=&quot;#数据库系统概述&quot; class=&quot;headerlink&quot; title=&quot;数据库系统概述&quot;&gt;&lt;/a&gt;数据库系统概述&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库概论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="数据库" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ACM全国邀请赛热身赛题2并查集</title>
    <link href="http://qianyouyou.cn/2018/05/19/2018-05-19/"/>
    <id>http://qianyouyou.cn/2018/05/19/2018-05-19/</id>
    <published>2018-05-19T15:37:32.000Z</published>
    <updated>2018-05-19T15:45:48.164Z</updated>
    
    <content type="html"><![CDATA[<p>真是糟糕的一天，愿不要影响到明天邀请赛发挥。</p><p>题意：</p><p>有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可能叛徒数，否则输出-1，遇到第几条时判断是谎言。</p><p>例：</p><p>输入</p><p>3 3</p><p>1 2</p><p>2 3</p><p>3 1</p><p>输出</p><p>-1 3</p><p>输入</p><p>5 4</p><p>1 2</p><p>2 3</p><p>3 4</p><p>4 1</p><p>输出</p><p>1 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXX = 100010;</span><br><span class="line">int fa[MAXX], r[MAXX];</span><br><span class="line">int vis[MAXX];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if (fa[x] == x) return fa[x];</span><br><span class="line">int tmp = fa[x];</span><br><span class="line">fa[x] = find(fa[x]);</span><br><span class="line">r[x] = (r[tmp] + r[x]) % 2;</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void fun(int x, int y)&#123;</span><br><span class="line">int fx = find(x), fy = find(y);</span><br><span class="line">if (fx == fy)   return;</span><br><span class="line">fa[fy] = fx;</span><br><span class="line">r[fy] = (r[x] + 1 - r[y]) % 2;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">int N, M, x, y, flag = 0, cnt = 0;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;N, &amp;M);</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (int i = 0; i &lt;= N; i++)   fa[i] = i, r[i] = 0;</span><br><span class="line">for (int i = 1; i &lt;= M; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">if (!vis[x])</span><br><span class="line">cnt++;</span><br><span class="line">if (!vis[y])</span><br><span class="line">cnt++;</span><br><span class="line">vis[x] = vis[y] = 1;</span><br><span class="line">if (flag)</span><br><span class="line">continue;</span><br><span class="line">if (find(x) == find(y)) &#123;</span><br><span class="line">if (r[x] == r[y])</span><br><span class="line">flag = i;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">fun(x, y);</span><br><span class="line">&#125;</span><br><span class="line">if (flag)</span><br><span class="line">printf(&quot;-1 %d\n&quot;, flag);</span><br><span class="line">else &#123;</span><br><span class="line">int cnt2 = 0;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">find(i);</span><br><span class="line">if (r[i] == 1 || !vis[i])</span><br><span class="line">cnt2++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;1 %d\n&quot;, cnt - cnt2 &gt; cnt2 ? cnt - cnt2 : cnt2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真是糟糕的一天，愿不要影响到明天邀请赛发挥。&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://qianyouyou.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>牛客小白月赛&amp;&amp;艾教习题总结</title>
    <link href="http://qianyouyou.cn/2018/05/16/2018-05-16/"/>
    <id>http://qianyouyou.cn/2018/05/16/2018-05-16/</id>
    <published>2018-05-16T14:51:02.000Z</published>
    <updated>2018-05-17T05:19:32.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管道取珠"><a href="#管道取珠" class="headerlink" title="管道取珠"></a>管道取珠</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_1.jpg" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_2.jpg" alt=""></p><p><strong>输入</strong></p><p>第一行包含两个整数n, m，分别表示上下两个管道中球的数目。 第二行为一个AB字符串，长度为n，表示上管道中从左到右球的类型。其中A表示浅色球，B表示深色球。 第三行为一个AB字符串，长度为m，表示下管道中的情形。</p><p><strong>输出</strong></p><p>仅包含一行，即为 Sigma(Ai^2) i从1到k 除以1024523的余数。</p><p><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">AB</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>数据规模及约定</strong></p><p>约30%的数据满足 n, m ≤ 12；<br>约100%的数据满足n, m ≤ 500。</p><p><strong>题解</strong></p><p>这题思路比较妙，我们需要先想想 ∑ai2 有什么意义。如果我们构造出这样一个游戏场景，即两个人同时玩两份同样的如题目所述的管道取珠的游戏，那么这两个人游戏结束后取到的珠子颜色序列一模一样的方案数就是题目里要求的答案。</p><p>令这两个人分别是 p1 和 p2。于是设 f[i][j][k] 表示 p1 取了第二个管道中的前 i 个珠子，第一个管道中的前 j 个珠子；p2 取了第一个管道的前 k 个珠子，这个状态下颜色序列相同的方案数，转移显然。</p><p>注：n为12以内一般是阶乘的题，n为30以内可以考虑状态压缩，莫队，线段树等各种情况，50左右选择二分，100以上需要另想方法。</p><h2 id="问号猜数"><a href="#问号猜数" class="headerlink" title="问号猜数"></a>问号猜数</h2><p>有一堆数按照递增的顺序排列，然而这些数的某些位我们并不知道，我们知道的只是这些数是从小到大排列的，现在依次给出这些数，不知道的位用？表示。我们需要猜这个数能满足递增条件的最小数。例如：</p><p>??</p><p>1?</p><p>?1</p><p>???</p><p>?99</p><p>?9?</p><p>?4?5</p><p>第一个数是10，第2个11，第3个21，第4个100，第5个199，第6个290，第7个1405。</p><p><strong>题解</strong></p><p>用贪心虽然比较快，但代码不容易写，须考虑情况挺多。因此我们分析一下。首先n&lt;=6，代表最大位数是6，也就是说最大的数也就是百万位。因此直接从1枚举，另设指针指向第1个数，每枚举到某个数满足该指针指向的数，则将指针指向下一个数，然后继续枚举，因此扫描一遍之后就得到所有的答案了。</p><p>接下来，假如n&lt;=15，由于数是递增的，则将枚举用二分来完成。假如n&gt;=100，这时再考虑贪心。</p><h2 id="取牌去牌"><a href="#取牌去牌" class="headerlink" title="取牌去牌"></a>取牌去牌</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌ii.j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p><p><strong>题解</strong></p><p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p><h2 id="铁索连环"><a href="#铁索连环" class="headerlink" title="铁索连环"></a>铁索连环</h2><p>有n个数，现在有m次查询，每次查询[l,r]范围所有不同的数。假设n很大</p><p><strong>题解</strong></p><p>我的思路是打表记录上一个相同元素的位置，比如a[1-10]=1,2,4,3,2,4,5,6,3,4,那么b[1-10]=0,0,0,0,2,3,0,0,4,6。这样l，r的范围内只需扫描1遍即可，扫到0结果加1，扫到非0的数看该下标是否 &lt; l，是则加1，否则不处理。时间复杂度是0mn。</p><p>艾教的方法不是很懂，不过举了一个例子，假如(3(3(3(3(3)))))，查询范围为括号所示，那么只需将第5个3赋为1，其他3赋为0即可。看起来最后就像一条链子捆绑着相同的元素。</p><h2 id="狭路相逢"><a href="#狭路相逢" class="headerlink" title="狭路相逢"></a>狭路相逢</h2><p>有一个图，每条路上都有强盗，每个节点都有驴友，假如到某条路上，该路上的强盗抢劫你的条件是强盗人数大于等于你们人数。你们每经过一个节点可以拉驴友入伍结伴而行，问（忘记问什么了，尴尬~QAQ~）</p><p><strong>题解</strong></p><p>并查集</p><h2 id="区间gcd"><a href="#区间gcd" class="headerlink" title="区间gcd"></a>区间gcd</h2><p>给定l，r，问多少种gcd(l,r)==gcd(l2.r2)</p><p><strong>题解</strong></p><p>1、两个条件，从1到n，最大公约数呈递减阶梯式。</p><p>2、gcd(gcd（a,b）,gcd(c,d))==gcd(a,d)</p><p>根据性质2可以用st表列出范围内l，r的最大公约数，即1，n最大公约数</p><p>根据性质1，二分求解</p><h2 id="信号误差"><a href="#信号误差" class="headerlink" title="信号误差"></a>信号误差</h2><p>艾教给女朋友传情发信号，信号是01串（16位）组成的字母，但是有情敌的干扰，途中可能至多会有两位进制会发生改变。问如何设置01串才能无视干扰准确将信号传给女盆友。例如1111111111111111，那么该2个1也是比0多，所以无视干扰。但每次只能处理一个字母，效率太慢。</p><p><strong>题解</strong></p><p>图论。将距离2以内的所有结点全部连起来。贪心选取结点，可以直接选择第一个结点开始。</p><h2 id="牛客小白月赛"><a href="#牛客小白月赛" class="headerlink" title="牛客小白月赛"></a>牛客小白月赛</h2><h3 id="音标"><a href="#音标" class="headerlink" title="音标"></a><a href="https://www.nowcoder.com/acm/contest/87/A" target="_blank" rel="noopener">音标</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>  我们规定元音字母有a、e、i、o、u，并且规定半元音字母y也是元音字母。 </p><p>  Cwbc在学习英语，XHRlyb为了让Cwbc的记忆更加深刻，于是她让Cwbc把每个字符串的所有字母都变成一个<strong>恰好**</strong>不大于它本身的小写元音字母**。 </p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有一个仅包含小写字母的字符串。</span><br></pre></td></tr></table></figure><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，每行有一个变化后的字符串。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元音字母变为一个恰好不大于它本身的字母，也就是元音字母本身</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfjpv</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入样例是由元音字母a、e、i、o、u的后一个字母组成，每个字母变为一个恰好不大于它本身的字母，也就是a、e、i、o、u。</span><br></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>upper_bound的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">char s[210000];</span><br><span class="line">char a[]=&quot;aeiouy&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;s[i];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]=a[upper_bound(a,a+6,s[i])-a-1];</span><br><span class="line">        &#125;</span><br><span class="line">        puts(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="躲藏"><a href="#躲藏" class="headerlink" title="躲藏"></a><a href="https://www.nowcoder.com/acm/contest/87/B" target="_blank" rel="noopener">躲藏</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>XHRlyb和她的小伙伴Cwbc在玩捉迷藏游戏。<br> Cwbc藏在多个不区分大小写的字符串中。<br> 好奇的XHRlyb想知道，在每个字符串中Cwbc作为子序列分别出现了多少次。<br> 由于Cwbc可能出现的次数过多，你只需要输出每个答案对<strong>2000120420010122</strong>取模后的结果。<br> 聪明的你在仔细阅读题目后，一定可以顺利的解决这个问题！</p><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有一个字符串。</span><br></pre></td></tr></table></figure><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，每行表示一个答案取模后的结果。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc作为子序列仅出现了1次。</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acdcecfwgwhwibjbkblcmcnco</span><br></pre></td></tr></table></figure><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc作为子序列出现了34=81次。</span><br></pre></td></tr></table></figure><h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>一个memset导致超时，也是够无语。时间复杂度4 <em> On，加上memset是5 </em> On，就差1个On就超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">char str[200010];</span><br><span class="line">long long dp[5][200010];</span><br><span class="line">int main() &#123;</span><br><span class="line">int i;</span><br><span class="line">while (scanf(&quot;%s&quot;, str + 2) != EOF) &#123;</span><br><span class="line">dp[1][0] = &apos;c&apos;, dp[2][0] = &apos;w&apos;, dp[3][0] = &apos;b&apos;,dp[4][0] = &apos;c&apos;;</span><br><span class="line">for (i = 2; str[i]; i++) &#123;</span><br><span class="line">dp[0][i] = 1;</span><br><span class="line">str[i] = tolower(str[i]);</span><br><span class="line">for (int k = 1; k &lt; 5; k++) &#123;</span><br><span class="line">dp[k][i] = dp[k][i - 1];</span><br><span class="line">if (str[i] == dp[k][0]) &#123;</span><br><span class="line">dp[k][i] += dp[k - 1][i];</span><br><span class="line">dp[k][i] %= 2000120420010122;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[4][i - 1]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a><a href="https://www.nowcoder.com/acm/contest/87/C" target="_blank" rel="noopener">博弈</a></h3><p> 博弈双方都是绝顶聪明的，并且XHRlyb先手，请你来帮XHRlyb预测这一局游戏谁会获胜。 </p><p>  如果博弈双方谁也无法取胜，那么判定为平局。 </p><h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有三个正整数，l，r，k。</span><br></pre></td></tr></table></figure><h4 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，如果这一局XHRlyb获胜，那么请输出XHRlyb；如果Cwbc获胜，请输出Cwbc；如果两人平局，请输出Draw。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 2</span><br></pre></td></tr></table></figure><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XHRlyb</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure><h4 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ≤ l ≤ r ≤ 105。</span><br><span class="line">1 ≤ k ≤ 100。</span><br><span class="line">1 ≤ T ≤ 1000。</span><br></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>水dp，l，r写反了，一直报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[100005];</span><br><span class="line">int sum[100005];</span><br><span class="line">int main() &#123;</span><br><span class="line">int l, r, k;</span><br><span class="line">while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; k) &#123;</span><br><span class="line">memset(dp, 0, sizeof(dp));</span><br><span class="line">memset(sum, 0, sizeof(sum));</span><br><span class="line">if (k == 1) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">sum[i] = (sum[i - 1] + 1);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = k; i &lt;= r; i++) &#123;</span><br><span class="line">dp[i] = (dp[i / k] * k + 1);</span><br><span class="line">sum[i] = (sum[i - 1] + dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">if (abs(sum[r] - sum[l - 1]) % 2 == 1)</span><br><span class="line">cout &lt;&lt; &quot;XHRlyb&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;Cwbc&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;管道取珠&quot;&gt;&lt;a href=&quot;#管道取珠&quot; class=&quot;headerlink&quot; title=&quot;管道取珠&quot;&gt;&lt;/a&gt;管道取珠&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="线性dp" scheme="http://qianyouyou.cn/tags/%E7%BA%BF%E6%80%A7dp/"/>
    
  </entry>
  
  <entry>
    <title>陕西师范大学第七届程序设计竞赛题解</title>
    <link href="http://qianyouyou.cn/2018/05/14/2018-05-14/"/>
    <id>http://qianyouyou.cn/2018/05/14/2018-05-14/</id>
    <published>2018-05-14T08:42:18.000Z</published>
    <updated>2018-05-14T10:53:18.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WWX的520"><a href="#WWX的520" class="headerlink" title="WWX的520"></a><a href="https://www.nowcoder.com/acm/contest/121/A" target="_blank" rel="noopener">WWX的520</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>520，因为谐音为我爱你，所以也被称之为表白日。</p><p>这一天，人们借机把藏在心底的洪荒之力通过表白、撒娇、传情、送礼、结婚等形式释放出来，商家也会趁势开展各类优惠促销活动，掀起一波或浪漫或虐狗的节日热浪。</p><p>这一天，也是送男朋友礼物、送女朋友礼物、送自己礼物、送亲朋好友礼物的好时机。</p><p>在520即将到来之际，wwx准备为她的女朋友购买一批礼物。于是他列出了一份礼物清单，但由于预算有限，必须删掉一种礼物。经过深思熟虑，他决定删掉价格第k高的礼物，你能帮帮他，找出是哪一种礼物吗?</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行是一个整数T（1&lt;=T&lt;=80），表示有T组数据.</span><br><span class="line">对于每一组数据，首先一行输入N(3&lt;=N&lt;=1000)，接下来的N行每行输入一个字符串和一个整数，以空格间隔，分别作为每种礼物的名字和价格。</span><br><span class="line">接下来一行输入k，表示要删去第k(1&lt;=&lt;=N)高的礼物</span><br><span class="line">礼物的名字的长度不超过30，礼物的价格不超过1000，且均为整数。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于每组输入数据，依次输出它的组号和要删去的礼物的名字和价格,以空格间隔。</span><br><span class="line">若两种商品的价格相同，则比较礼物名字的字典序大小。即:两种礼物的价格相同时，字典序大者若为第k高，字典序小者则为第k+1高。</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Apple 18</span><br><span class="line">Book 30</span><br><span class="line">Milk 8000</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Apple 300</span><br><span class="line">Bananas  200</span><br><span class="line">Bracelet 200</span><br><span class="line">Candy 200</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1: Apple 18</span><br><span class="line">#2: Bracelet 200</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">可用strcmp(s1,s2)函数进行字符串的比较。</span><br><span class="line">2.</span><br><span class="line">对于样例一中第二组数据:Apple 300是价格第一大，Candy 200是价格第二高，Bracelet</span><br><span class="line">200是价格第三大。</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接按照价格从大到小排序，如果价格相同按照字母序从大到小排序。排完序之后直接输出第k位的礼物名称与价格即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">string str;</span><br><span class="line">int v;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">if (a.v == b.v) &#123;</span><br><span class="line">return a.str&gt;b.str;</span><br><span class="line">&#125;</span><br><span class="line">return a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">for (int z = 1; z &lt;= t; z++) &#123;</span><br><span class="line">int n, k;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i].str;</span><br><span class="line">cin &gt;&gt; a[i].v;</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + n, cmp);</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; &quot;#&quot; &lt;&lt; z &lt;&lt; &quot;: &quot; &lt;&lt; a[k - 1].str &lt;&lt; &quot; &quot; &lt;&lt; a[k - 1].v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配环境"><a href="#配环境" class="headerlink" title="配环境"></a><a href="https://www.nowcoder.com/acm/contest/121/B" target="_blank" rel="noopener">配环境</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      黑猫在给校赛配环境，结果被服务器的各种入站规则出站规则搞得头疼，想到自己要上传GVIM、EMACS、VSCODE、Jetbrain全家桶、Visual Studio、Gedit、Microsoft Office Word、Eclipse等等，完全不知道要要花费多少时间才能上传完校赛需要的环境。 </p><p>​      黑猫跑去问ddjing，谁知道ddjing说：“我要去实习了，没功夫解决这个问题，你去问问其他人吧。“ </p><p>​      于是黑猫想请你帮他解决这个问题。 </p><p>​      服务器总传输速度为每秒M个单位（本题出现的所有单位都统一），黑猫现在需要上传总共n个软件（按优先级顺序从高到低给出），每个软件的大小分别为v1、v2….vn，每个软件为保持稳定连接，上传需要一个最小的传输速度为m1、m2…mn。 </p><p>​      服务器带宽分配的策略是：按优先级满足每一个软件要求的传输速度。如果服务器剩余的带宽不能满足某个软件最小传输速度的话，服务器将继续寻找下去，直到找到能满足最小传输速度的软件。 </p><p>​      如果目前服务器的总传输速度不能满足所有还需要上传的软件的话，服务器将把传输速度全部给予当前优先级最高的（即使不能满足其最小传输速度）。 </p><p>​      如果目前对所有软件都满足了其最小传输速度的话，服务器将把剩余所有传输速度全部给予当前优先级最高的软件。 </p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行给出一个正整数，表示服务器总带宽M</span><br><span class="line">第二行给出整数n，表示需要上传的n个软件。</span><br><span class="line">第三行为n个正整数，第i个数表示vi。</span><br><span class="line">第四行为n个正整数，第i个数表示mi。</span><br><span class="line">( 1 &lt;= M &lt;= 1000,  1 &lt;= n &lt;= 100 , 1 &lt;=  vi &lt;= 1000 ,  1 &lt;= mi &lt;= 1000 )</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行，为上传完毕所有软件所需要的时间，保留两位小数。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">1 1 4 5 1 4 </span><br><span class="line">10 9 8 7 6 5</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.60</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">10 9 8 7 6 5</span><br><span class="line">1 1 4 5 1 4</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.50</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原本是一道水题，结果成功被题面绕进去了。其实只需要把所有软件的大小V加起来除以宽带大小M即可。所谓最小速度都是迷惑人的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int M, n;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;M, &amp;n);</span><br><span class="line">double tmp, ans = 0;</span><br><span class="line">for (int i = 0; i &lt; n;i++) &#123;</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">ans += tmp;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line">ans /= M;</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一段超时代码，成功将题面的过程给模拟了出来，当时没仔细看数据是怎么得到的，一直超时很不可思议。因此总结出了经验，以后做题一定得分析出数据是怎么得到的，有时候就很容易找到规律或者发现玄机。另外下面的代码总结出了一个新的方法，就是利用滚动数组实现删除元素，虽然vector有删除功能，但删除效率低。以下的方法是利用滚动数组，将未删除的元素重新压入数组，删除的元素不进行操作，然后清空数组，这样循环操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int M, n;</span><br><span class="line">struct node&#123;</span><br><span class="line">double v;</span><br><span class="line">int m;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int vis[1005];</span><br><span class="line">vector&lt;int&gt;vv[2];</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; n;</span><br><span class="line">double ans = 0, wei;</span><br><span class="line">int ff[2] = &#123; 0,1 &#125;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; a[i].v;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i].m;</span><br><span class="line">vv[ff[0]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while (flag &gt;= 0) &#123;</span><br><span class="line">flag = -1;</span><br><span class="line">wei = M;</span><br><span class="line">double mint = inf;</span><br><span class="line">vv[ff[1]].clear();</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">for (it = vv[ff[0]].begin(); it != vv[ff[0]].end(); it++) &#123;</span><br><span class="line">if (a[*it].v &lt;= 0) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;vis[*it] = 0;</span><br><span class="line">vv[ff[1]].push_back(*it);</span><br><span class="line">if (flag &lt; 0)</span><br><span class="line">flag = *it;</span><br><span class="line">if (a[*it].v &lt;= wei) &#123;</span><br><span class="line">vis[*it] = 1;</span><br><span class="line">wei -= a[*it].m;</span><br><span class="line">if (*it != flag)</span><br><span class="line">mint = min(mint, a[*it].v / a[*it].m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag &lt; 0)</span><br><span class="line">break;</span><br><span class="line">mint = min(mint, a[flag].v / (vis[flag] ? a[flag].m + wei : wei));</span><br><span class="line">for (it = vv[ff[1]].begin(); it != vv[ff[1]].end(); it++) &#123;</span><br><span class="line">if (a[*it].v &lt;= 0 || !vis[*it] || flag == *it)</span><br><span class="line">continue;</span><br><span class="line">a[*it].v -= a[*it].m*mint;</span><br><span class="line">&#125;</span><br><span class="line">a[flag].v -= (vis[flag] ? a[flag].m + wei : wei)*mint;</span><br><span class="line">ans += mint;</span><br><span class="line">ff[0] = ff[0] ^ ff[1];</span><br><span class="line">ff[1] = ff[0] ^ ff[1];</span><br><span class="line">ff[0] = ff[0] ^ ff[1];</span><br><span class="line">//cout &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; mint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iko和她的糖"><a href="#iko和她的糖" class="headerlink" title="iko和她的糖"></a><a href="https://www.nowcoder.com/acm/contest/121/C" target="_blank" rel="noopener">iko和她的糖</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      iko超级超级喜欢吃糖，有一天iko想出去玩，她计划从1点走到N点（按1,2,3，…，n的顺序走），每个点都有一个补给站，第i点的补给站有a[i]颗糖，从i点走到i+1点会消耗掉b[i]颗糖，iko在出游的途中可以选择三个补给站，iko想知道她走完全程到达N点时口袋里最多还能剩下几颗糖（初始时iko的口袋里一颗糖都没有）。 </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入N（3&lt;=N&lt;=1000）</span><br><span class="line">第二行输入N个数代表a[1].......a[N]  (0&lt;=a[i]&lt;=1000 )</span><br><span class="line">第三行输入N-1个数代表b[1]......b[N-1]  ( 1&lt;=b[i]&lt;=1000 )</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出一个数字表示iko到达n点时口袋里最多剩下的糖，</span><br><span class="line">若不能到达N点输出-1。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 5 2 4</span><br><span class="line">3 2 2 2</span><br></pre></td></tr></table></figure><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先，3个补给站必须得选择第1个，因为一开始没有糖，而每条路都需要消耗糖，所以必须拿起点的糖。之后就很好理解了，每走一条路记录当前走过的补给站最大的两个，如果哪一条路糖果不够了，就把最大的补给站加上，如果还不够就把次大的也加上。每次记录走到这条路经过的最大补给站记录下来，然后现有糖果减去消耗的糖果，如果为负就把之前的最大补给站的糖果加上。例如第2组数据，初始是3，走到第1条路剩余糖果为0，此时记录的最大补给站是4，然后走到下一条路糖果变成了-2，那就把最大补给站的加上，现在剩余糖果是2。此时最大补给站记录5，再往下走是2，剩余糖果是0，继续走，消耗2个为-2，则加上最大补给站的糖5。最终就是3。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int N, cur, MAX1, MAX2, flag, a[maxn];</span><br><span class="line">void check(int &amp;cnt) &#123;</span><br><span class="line">while (cnt&amp;&amp;cur &lt; 0) &#123;</span><br><span class="line">cur += MAX1;</span><br><span class="line">MAX1 = MAX2;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fun(int i) &#123;</span><br><span class="line">if (MAX1 &lt;= a[i]) &#123;</span><br><span class="line">MAX2 = MAX1;</span><br><span class="line">MAX1 = a[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (MAX2 &lt; a[i]) &#123;</span><br><span class="line">MAX2 = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N) &#123;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">MAX1 = -1, MAX2 = -1, flag = 0;</span><br><span class="line">int tmp, cnt = 3;</span><br><span class="line">cur = 0;</span><br><span class="line">for (int i = 0; i &lt; N; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">for (int i = 0; i &lt; N - 1; i++) &#123;</span><br><span class="line">fun(i);</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">cur -= tmp;</span><br><span class="line">if (cur &lt; 0) &#123;</span><br><span class="line">check(cnt);</span><br><span class="line">&#125;</span><br><span class="line">if (cur &lt; 0)</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">fun(N - 1);</span><br><span class="line">if (flag)</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">else &#123;</span><br><span class="line">if (cnt == 2)</span><br><span class="line">cur += MAX1 + MAX2;</span><br><span class="line">else if (cnt == 1)</span><br><span class="line">cur += MAX1;</span><br><span class="line">printf(&quot;%d\n&quot;, cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZQ的睡前故事"><a href="#ZQ的睡前故事" class="headerlink" title="ZQ的睡前故事"></a><a href="https://www.nowcoder.com/acm/contest/121/D" target="_blank" rel="noopener">ZQ的睡前故事</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      ZQ是一个拥有n女朋友的万人迷，她的每一个女朋友每天晚上都会挨个给他打电话，要他讲了睡前故事才能睡觉。可是，每次他的女朋友都会挑他在吃鸡的时候打电话，ZQ总是因为挂机被舍友赶出宿舍，于是，ZQ告诉他的女朋友们，别打电话了，他会主动打过去给他们讲故事，再打电话就分手！ </p><p>​      于是，ZQ把他的女朋友名字写在纸上，画成一圈，顺时针编号为1~n，然后从1开始顺时针数。在每一次数数中，ZQ数k个就停下来，然后给选中的女朋友打电话讲故事。   </p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先输入一个t，然后t组数据，每行包含两个数字n,k，n&lt;20,k&gt;0</span><br></pre></td></tr></table></figure><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按顺序输出每轮被选中的女朋友的编号。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">5 2</span><br><span class="line">11 4</span><br></pre></td></tr></table></figure><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br><span class="line">2 4 1 5 3</span><br><span class="line">4 8 1 6 11 7 3 2 5 10 9</span><br></pre></td></tr></table></figure><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>约瑟夫环。由于数据比较水，所以多种方法求解，这里不介绍了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, k, t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">int i = 0;</span><br><span class="line">int cnt = n;</span><br><span class="line">int vis[20] = &#123; 0 &#125;;</span><br><span class="line">while (cnt) &#123;</span><br><span class="line">int kk = k;</span><br><span class="line">while (vis[i%n])</span><br><span class="line">i++;</span><br><span class="line">for (int j = 1; j &lt; kk; j++) &#123;</span><br><span class="line">i++;</span><br><span class="line">while (vis[i%n])</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">vis[i%n] = 1;</span><br><span class="line">cnt--;</span><br><span class="line">cnt ? printf(&quot;%d &quot;, i%n + 1) : printf(&quot;%d\n&quot;, i%n + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加：hdu5135-Little-Zu-Chongzhi’s-Triangles"><a href="#附加：hdu5135-Little-Zu-Chongzhi’s-Triangles" class="headerlink" title="附加：hdu5135 Little Zu Chongzhi’s Triangles"></a>附加：hdu5135 Little Zu Chongzhi’s Triangles</h2><p>题意：</p><p>有n条边组三角形，每个三角形必须由3条边组成，三角形边不可以重复利用，不可以共线，只能是分开的三角形。问这n条边组成的所有三角形的面积和最大为多少。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>原本状压dp求解，但数据比较水，因此递归还没有记忆化搜索直接就过了。每次从n条边里面选择3条边组成三角形，方程maxx[i],[j] = max(maxx[i-1],[j],[1~n] );由于状态是集合，因此需要状压以下。这里主要说的是一个常犯的错误。我没找到vis是当前状态是否已经选过，尤其是搜索时vis的作用非常重要。但本题用深搜时犯了一个错误，就是在vis=1,与vis=0之间多了一个continue，即vis=1，continue，dfs，vis=0，导致状态更改，数据一直错误。正确顺序应该是continue，vis=1，dfs，vis=0。因此之后比赛时一定要注意此细节。在vis=1与vis=0之间一定要注意是否有其他条件导致循环结束而状态还未还原。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int vis[15];</span><br><span class="line">double a[15];</span><br><span class="line">double dfs(int x) &#123;</span><br><span class="line">double ans = 0, maxx = 0;</span><br><span class="line">for (int i = x; i&lt;n; i++) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">continue;</span><br><span class="line">vis[i] = 1;</span><br><span class="line">for (int j = i + 1; j&lt; n; j++) &#123;</span><br><span class="line">if (vis[j])</span><br><span class="line">continue;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">for (int k = j + 1; k&lt;n; k++) &#123;</span><br><span class="line">if (vis[k])</span><br><span class="line">continue;</span><br><span class="line">if (a[k] &gt;= a[i] + a[j] || a[j] &gt;= a[i] + a[k] || a[i] &gt;= a[j] + a[k])</span><br><span class="line">continue;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">double c = (a[i] + a[k] + a[j]) / 2.0;</span><br><span class="line">ans = sqrt(c*(c - a[i])*(c - a[j])*(c - a[k]));</span><br><span class="line">ans += dfs(i + 1);</span><br><span class="line">maxx = max(maxx, ans);</span><br><span class="line"></span><br><span class="line">vis[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">vis[j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">vis[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">return maxx;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">if (!n)</span><br><span class="line">break;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">double ans = dfs(0);</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WWX的520&quot;&gt;&lt;a href=&quot;#WWX的520&quot; class=&quot;headerlink&quot; title=&quot;WWX的520&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/121/A&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
</feed>
