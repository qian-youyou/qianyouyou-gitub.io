<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-09-09T14:13:04.266Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-09-09</title>
    <link href="http://qianyouyou.cn/2018/09/09/2018-09-09/"/>
    <id>http://qianyouyou.cn/2018/09/09/2018-09-09/</id>
    <published>2018-09-09T14:04:18.000Z</published>
    <updated>2018-09-09T14:13:04.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Characters-with-Hash"><a href="#Characters-with-Hash" class="headerlink" title="Characters with Hash"></a>Characters with Hash</h2><p><a href="https://wenda.jisuanke.com/nanti/31461" target="_blank" rel="noopener">问答</a></p><ul><li>26.45%</li><li>1000ms</li><li>262144K</li></ul><p>Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”.</p><p>It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>First line a integer TT , the number of test cases (T \le 10)(T≤10).</p><p>For each test case:</p><p>First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000).</p><p>Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single number which gives the answer.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 z</span><br><span class="line">oMl</span><br><span class="line">6 Y</span><br><span class="line">YJSNPI</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%BE%90%E5%B7%9E%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 徐州赛区网络预赛</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char str[1000007],ch[2];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%s%s&quot;,&amp;n,ch,str);</span><br><span class="line">        int ans = 2*n;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(str[i]==ch[0])</span><br><span class="line">                ans-=2;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(abs(str[i]-ch[0])&lt;10)</span><br><span class="line">                    ans-=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ans==0)</span><br><span class="line">            ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Characters-with-Hash&quot;&gt;&lt;a href=&quot;#Characters-with-Hash&quot; class=&quot;headerlink&quot; title=&quot;Characters with Hash&quot;&gt;&lt;/a&gt;Characters with Hash&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛K题-Supreme Number</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08-1/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08-1/</id>
    <published>2018-09-08T14:28:16.000Z</published>
    <updated>2018-09-09T14:03:30.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Supreme-Number"><a href="#Supreme-Number" class="headerlink" title="Supreme Number"></a>Supreme Number</h3><p><a href="https://wenda.jisuanke.com/nanti/31452" target="_blank" rel="noopener">问答</a></p><ul><li>26.7%</li><li>1000ms</li><li>131072K</li></ul><p>A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers.</p><p>Now lets define a number NN as the <strong>supreme number</strong> if and only if each number made up of an non-empty <strong>subsequence</strong> of all the numeric digits of NN must be either a prime number or 11.</p><p>For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number.</p><p>Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal <em>supreme number</em> that does not exceed NN?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>In the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases.</p><p>In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case print <code>&quot;Case #x: y&quot;</code>, in which xx is the order number of the test case and yy is the answer.</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 5</span><br><span class="line">Case #2: 73</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;</span><br><span class="line">int read()</span><br><span class="line">&#123;</span><br><span class="line">    char ch=&apos; &apos;;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ans&lt;100000)</span><br><span class="line">        ans=ans*10+ch-&apos;0&apos;;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int aaa=1;aaa&lt;=t;aaa++)&#123;</span><br><span class="line">        int ans = read();</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for(i = 0;i&lt;19;i++)&#123;</span><br><span class="line">            if(pri[i]&gt;ans)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==19)</span><br><span class="line">            cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000000</span><br><span class="line">int h=0;</span><br><span class="line">bool p[N];</span><br><span class="line">int prime[N];</span><br><span class="line">bool dfs(int x)&#123;</span><br><span class="line">    if(p[x]==false)</span><br><span class="line">        return false;</span><br><span class="line">    int c = 1;</span><br><span class="line">    while(c&lt;x)&#123;</span><br><span class="line">        c*=10;</span><br><span class="line">        if(p[x%c]==false)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        if(c&gt;x)</span><br><span class="line">            break;</span><br><span class="line">        int tmp = x;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            if(p[tmp]==false)</span><br><span class="line">                return false;</span><br><span class="line">            if(p[tmp%c]==false)</span><br><span class="line">                return false;</span><br><span class="line">            tmp/=c;</span><br><span class="line">            if(!tmp)</span><br><span class="line">                break;</span><br><span class="line">            if(dfs(tmp)==false)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void db()</span><br><span class="line">&#123;</span><br><span class="line">memset(p,true,sizeof(p));</span><br><span class="line">p[0] = false;</span><br><span class="line">for(int i=2;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[i]==false)</span><br><span class="line">            continue;</span><br><span class="line">for(int j=2;i*j&lt;N;j++)</span><br><span class="line">&#123;</span><br><span class="line">p[i*j]=false;</span><br><span class="line">&#125;</span><br><span class="line">if(!dfs(i))</span><br><span class="line">            p[i] = false;</span><br><span class="line">        if(p[i]==true)</span><br><span class="line">&#123;</span><br><span class="line">prime[h++]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">db();</span><br><span class="line">int n;  //打印前n个质数</span><br><span class="line">for(int i=0;i&lt;=h;i++)</span><br><span class="line">cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Supreme-Number&quot;&gt;&lt;a href=&quot;#Supreme-Number&quot; class=&quot;headerlink&quot; title=&quot;Supreme Number&quot;&gt;&lt;/a&gt;Supreme Number&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018-ACM-ICPC沈阳网络预赛D题-A*模板题</title>
    <link href="http://qianyouyou.cn/2018/09/08/2018-09-08/"/>
    <id>http://qianyouyou.cn/2018/09/08/2018-09-08/</id>
    <published>2018-09-08T13:28:16.000Z</published>
    <updated>2018-09-09T14:03:51.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Made-In-Heaven"><a href="#Made-In-Heaven" class="headerlink" title="Made In Heaven"></a>Made In Heaven</h2><p><a href="https://wenda.jisuanke.com/nanti/31445" target="_blank" rel="noopener">问答</a></p><ul><li>14.67%</li><li>1000ms</li><li>131072K</li></ul><p>One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry.</p><p>JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are at most 5050 test cases.</p><p>The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN.</p><p>The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ).</p><p>Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW.</p><p>It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist.</p><p>All the test cases are generated randomly.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>One line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output <code>&quot;yareyaredawa&quot;</code> (without quote), else output <code>&quot;Whitesnake!&quot;</code> (without quote).</p><h3 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 2 14</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yareyaredawa</span><br></pre></td></tr></table></figure><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E6%B2%88%E9%98%B3%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 沈阳赛区网络预赛</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“<code>Whitesnake!</code>”，否则输出“<code>yareyaredawa</code>”</p><p>类似<a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">POJ2449</a></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>A*+SPFA</p><h4 id="A-算法："><a href="#A-算法：" class="headerlink" title="A*算法："></a>A*算法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A*，启发式搜索，是一种较为有效的搜索方法。</span><br><span class="line">我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。</span><br><span class="line">我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。</span><br><span class="line">所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。</span><br></pre></td></tr></table></figure><h4 id="估价函数："><a href="#估价函数：" class="headerlink" title="估价函数："></a>估价函数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。</span><br><span class="line">在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。</span><br><span class="line"></span><br><span class="line">估价函数需要满足：</span><br><span class="line">　　设当前状态state到目标函数所需代价的估计值为f(state)</span><br><span class="line">　　设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state)</span><br><span class="line">　　对于任意的state，应该有f(state)&lt;=g(state)</span><br><span class="line">也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。</span><br></pre></td></tr></table></figure><h4 id="第K短路："><a href="#第K短路：" class="headerlink" title="第K短路："></a>第K短路：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。</span><br><span class="line">实现过程：</span><br><span class="line">1.预处理f(x)，在反向图上以T为起点求到每个点的最短路</span><br><span class="line">2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问</span><br><span class="line">3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中</span><br><span class="line">4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路</span><br><span class="line"></span><br><span class="line">因为估价函数的作用，图中很多节点访问次数远小于K</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll x,y,z,s,t,k;</span><br><span class="line">    ll T;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T;</span><br><span class="line">        prepare();</span><br><span class="line">        for(ll i=1;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            add_edge(x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(t);</span><br><span class="line">        ll ans=a_star(s,t,k);</span><br><span class="line">        if(ans&lt;=T&amp;&amp;ans!=-1)</span><br><span class="line">            cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="k短路模板"><a href="#k短路模板" class="headerlink" title="k短路模板"></a>k短路模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">const ll maxn=100010;</span><br><span class="line">ll n,m,dis[maxn];</span><br><span class="line">ll tot,head1[maxn],head2[maxn];</span><br><span class="line">bool flag[maxn];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    ll to;</span><br><span class="line">    ll w;</span><br><span class="line">    ll next;</span><br><span class="line">&#125;e[maxn*2],e2[maxn*2];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll f;</span><br><span class="line">    ll g;</span><br><span class="line">    ll from;</span><br><span class="line">    bool operator &lt; (node a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(a.f==f)</span><br><span class="line">        return g&gt;a.g;</span><br><span class="line">        return f&gt;a.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add_edge(ll u,ll v,ll w)</span><br><span class="line">&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head1[u];</span><br><span class="line">    head1[u]=tot;</span><br><span class="line">    e2[tot].to=u;</span><br><span class="line">    e2[tot].w=w;</span><br><span class="line">    e2[tot].next=head2[v];</span><br><span class="line">    head2[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void prepare()</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;tot=0;</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">&#125;</span><br><span class="line">void spfa(ll t)</span><br><span class="line">&#123;</span><br><span class="line">    for(ll i=1;i&lt;=n;i++)</span><br><span class="line">    dis[i]=maxn;</span><br><span class="line">    dis[t]=0;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.push(t);</span><br><span class="line">    flag[t]=1;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll v=q.front();</span><br><span class="line">        q.pop();flag[v]=0;</span><br><span class="line">        for(ll i=head2[v];i;i=e2[i].next)</span><br><span class="line">        if(dis[e2[i].to]&gt;dis[v]+e2[i].w)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[e2[i].to]=dis[v]+e2[i].w;</span><br><span class="line">            if(!flag[e2[i].to])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(e2[i].to);</span><br><span class="line">                flag[e2[i].to]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a_star(ll s,ll t,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    if(s==t) k++;</span><br><span class="line">    if(dis[s]==maxn) return -1;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    ll cnt=0;</span><br><span class="line">    node tmp,to;</span><br><span class="line">    tmp.from=s;</span><br><span class="line">    tmp.g=0;</span><br><span class="line">    tmp.f=tmp.g+dis[tmp.from];</span><br><span class="line">    q.push(tmp);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(tmp.from==t) cnt++;</span><br><span class="line">        if(cnt==k) return tmp.g;</span><br><span class="line">        for(ll i=head1[tmp.from];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            to.from=e[i].to;</span><br><span class="line">            to.g=tmp.g+e[i].w;</span><br><span class="line">            to.f=to.g+dis[to.from];</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Made-In-Heaven&quot;&gt;&lt;a href=&quot;#Made-In-Heaven&quot; class=&quot;headerlink&quot; title=&quot;Made In Heaven&quot;&gt;&lt;/a&gt;Made In Heaven&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://wenda
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/A-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="A*算法" scheme="http://qianyouyou.cn/tags/A-%E7%AE%97%E6%B3%95/"/>
    
      <category term="k短路" scheme="http://qianyouyou.cn/tags/k%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[最短路]SPFA的SLF与LLL优化</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05-2/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05-2/</id>
    <published>2018-09-05T10:08:53.000Z</published>
    <updated>2018-09-05T12:14:48.508Z</updated>
    
    <content type="html"><![CDATA[<p>SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。</p><p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ; Q.pop_front( ) ; mark[u] = false ;</span><br><span class="line">    </span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] &gt; dis[Q.front( )]  ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，每次出队时，若 d[i]&gt;平均值，把 i 移到队列末尾，如此反复，直到找到某一i使得dist(i)&lt;=x，则将i出队进行松弛操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11  ; </span><br><span class="line">using namespace std ;//1061109567</span><br><span class="line">int n , m , head[maxn]  , dis[maxn] , cnt , sum , tot ;</span><br><span class="line">bool mark[maxn] ; </span><br><span class="line">struct id</span><br><span class="line">&#123;</span><br><span class="line">    int nxt ,to , val ;</span><br><span class="line">&#125; edge[M] ;</span><br><span class="line">deque &lt; int &gt; Q ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline void Init ( )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin  ) ;</span><br><span class="line">    freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int read( )</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar( ) ; int k = 1 , ret = 0 ;</span><br><span class="line">    while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125;</span><br><span class="line">    while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ;</span><br><span class="line">    return k * ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add( int u , int v , int va )</span><br><span class="line">&#123;</span><br><span class="line">    edge[++cnt].nxt = head[u] , edge[cnt].to = v ;</span><br><span class="line">    edge[cnt].val = va , head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input(  )</span><br><span class="line">&#123;</span><br><span class="line">    n = read()  , m = read( ) ;</span><br><span class="line">    int u ,v , c ;</span><br><span class="line">    memset( head , -1 , sizeof(head)) ;</span><br><span class="line">    for( int x = 1 ; x &lt;= m ; ++x )</span><br><span class="line">    &#123;</span><br><span class="line">        u = read( ) , v = read( ) , c = read( ) ;</span><br><span class="line">        add( u ,v , c )  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void spfa( )</span><br><span class="line">&#123;</span><br><span class="line">    memset( dis , 127/2 , sizeof(dis) ) ;</span><br><span class="line">    dis[1] = 0 , mark[1] = true ;</span><br><span class="line">    Q.push_back( 1 ) ; tot = 0 ;</span><br><span class="line">    while( !Q.empty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        int u = Q.front( ) ;</span><br><span class="line">        Q.pop_front( ) ;</span><br><span class="line">        if( dis[u] * tot &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">        Q.push_back( u ) ;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        mark[u] = false ;</span><br><span class="line">        tot-- ; sum -= dis[u] ;</span><br><span class="line">        for( int i = head[u] ; ~i ; i = edge[i].nxt )</span><br><span class="line">        &#123;</span><br><span class="line">            int v = edge[i].to ; </span><br><span class="line">            if( dis[v] &gt; dis[u] + edge[i].val )</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].val ;</span><br><span class="line">                if( !mark[v] )</span><br><span class="line">                &#123;</span><br><span class="line">                    mark[v] = true ; </span><br><span class="line">                    if( Q.empty( ) || dis[v] * tot &gt; sum ) Q.push_back( v ) ;</span><br><span class="line">                    else Q.push_front( v ) ;</span><br><span class="line">                    tot++ ; sum += dis[v] ;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ;</span><br><span class="line">    else printf( &quot;%d\n&quot; , dis[n] ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">//    Init( ) ; </span><br><span class="line">    input( ) ;</span><br><span class="line">    spfa( ) ;</span><br><span class="line">//    fclose( stdin ) ;</span><br><span class="line">//       fclose( stdout ) ;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。&lt;/p&gt;
&lt;p&gt;SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &amp;lt; dist(i
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="SPFA算法" scheme="http://qianyouyou.cn/tags/SPFA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[C++] pair和make_pair</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05-1/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05-1/</id>
    <published>2018-09-05T08:16:08.000Z</published>
    <updated>2018-09-05T08:25:13.959Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：<a href="https://blog.csdn.net/yockie/article/details/6980692" target="_blank" rel="noopener">pair与make_pair</a></p><p>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。<br>例如std::pair&lt;int,float&gt; 或者 std::pair&lt;double,double&gt;等。<br>pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。<br>初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：<br>template pair make_pair(T1 a, T2 b) { return pair(a, b); }<br>    一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。<br>另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题：<br>    例如有如下两个定义：<br>        std::pair&lt;int, float&gt;(1, 1.1);<br>        std::make_pair(1, 1.1);<br>其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。<br>这个问题在编程是需要引起注意。<br>下面是一段pair与make_pair的例子程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25);</span><br><span class="line">pair &lt;string,double&gt; product2;</span><br><span class="line">pair &lt;string,double&gt; product3;</span><br><span class="line">product2.first =&quot;lightbulbs&quot;; // type of first is string</span><br><span class="line">product2.second =0.99; // type of second is double</span><br><span class="line">product3 = make_pair (&quot;shoes&quot;,20.0);</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product1.first &lt;&lt;&quot; is $&quot;&lt;&lt; product1.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product2.first &lt;&lt;&quot; is $&quot;&lt;&lt; product2.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product3.first &lt;&lt;&quot; is $&quot;&lt;&lt; product3.second &lt;&lt;&quot;\n&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：&lt;a href=&quot;https://blog.csdn.net/yockie/article/details/6980692&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pair与ma
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="stl" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/stl/"/>
    
    
      <category term="stl" scheme="http://qianyouyou.cn/tags/stl/"/>
    
      <category term="模板" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>[单源最短路]两大优化算法争锋之SPFA与堆优化版Dijkstra</title>
    <link href="http://qianyouyou.cn/2018/09/05/2018-09-05/"/>
    <id>http://qianyouyou.cn/2018/09/05/2018-09-05/</id>
    <published>2018-09-05T07:16:00.000Z</published>
    <updated>2018-09-05T09:12:42.033Z</updated>
    
    <content type="html"><![CDATA[<p>单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。</p><p>这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 </p><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>时间复杂度：O(V2+E) </p><p>n-1次循环</p><p>–&gt;找到未标记的d最小的点</p><p>–&gt;标记，松弛它的边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)&#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])&#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>时间复杂度：O(VE) </p><p>n-1次循环</p><p>–&gt;对所有边松弛</p><p>还能再松弛则有负环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int dis[10010];</span><br><span class="line">int u[10010],v[10010],w[10010];</span><br><span class="line">int n,m;</span><br><span class="line">void Bellman_ford(int a)&#123;</span><br><span class="line">    memset(dis,inf,sizeof(dis));//赋初始值</span><br><span class="line">    dis[a]=0;</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)//更新n-1次</span><br><span class="line">        for(int j=1;j&lt;=m;j++)//更新每一条边</span><br><span class="line">            dis[v[j]]=min(dis[v[j]],dis[u[j]]+w[j]);//判断是否更新</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="两大基础算法对比"><a href="#两大基础算法对比" class="headerlink" title="两大基础算法对比"></a>两大基础算法对比</h2><ul><li>Dijkstra是每次确定了到一个点的最短距离，再用该点更新到其它点的距离。不能处理有负边的图。</li><li>Bellman-Ford是每次对所有边松弛。可以计算出有负边无负环的最短路，可以判断是否存在负环。</li></ul><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="Dijkstra-heap优化"><a href="#Dijkstra-heap优化" class="headerlink" title="Dijkstra+heap优化"></a>Dijkstra+heap优化</h2><p>时间复杂度：O((V+E)lgV)</p><p>用STL中的优先队列实现堆：</p><p>while(优先队列非空)</p><p>–&gt;队头出队，松弛它的边</p><p>–&gt;松弛了的&lt;新距离,点&gt;入队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;</span><br><span class="line">...</span><br><span class="line">while(!q.empty())&#123;  // O(V) 加上count&lt;n可以优化一点点 </span><br><span class="line">    int w=q.top().first, u=q.top().second;</span><br><span class="line">    q.pop();   // O(lgV)</span><br><span class="line">    if(b[u])continue; b[u]=true;</span><br><span class="line">    //++count;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123; // Sum -&gt; O(E)</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            q.push(PII(d[v],v));  // O(lgV)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>时间复杂度：O(kE) or O(VE)</p><p>while(队非空)</p><p>–&gt;队头出队，松弛它的边</p><p>–&gt;松弛了且不在队内的点入队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while(!q.empty())&#123;</span><br><span class="line">    int u=q.front(); q.pop();</span><br><span class="line">    b[u]=false;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        int v=e[i].to;</span><br><span class="line">        if(d[u]+e[i].w&lt;d[v])&#123;</span><br><span class="line">            d[v]=d[u]+e[i].w;</span><br><span class="line">            if(!b[v])b[v]=true,q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法思路对比"><a href="#算法思路对比" class="headerlink" title="算法思路对比"></a>算法思路对比</h2><ul><li>Dijkstra+heap是用小根堆，每次取出d最小的点，来更新距离，那么这个点来说，最小距离就是当前的d。</li><li>SPFA是用双端队列，每次取出队头，来更新距离，它之后可能还会入队。它是一种动态逼近法，因为每次松弛距离都会减小，所以松弛一定会有结束的。如果一个点入队超过n次就是存在负环。</li></ul><h2 id="复杂度分析对比"><a href="#复杂度分析对比" class="headerlink" title="复杂度分析对比"></a>复杂度分析对比</h2><p>Dijkstra+heap</p><ul><li>因为是堆，取队头需要O(lgV)。</li><li>松弛边时，因为点的d改变了，所以点v需要以新距离重新入堆，O(lgV)，总共O(ElgV)。</li><li>因此总的是O((V+E)lgV)</li></ul><p>SPFA</p><ul><li>论文证明也不严格。复杂度不太好分析。</li><li><del>总的是O(kE)。k大概为2</del>。</li><li>复杂度应该是 O(VE)。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。</p><p>另外，Dijkstra和Prim也很相似，它们的区别主要是d的含义，前者是到s的临时最短距离，后者是到树的临时最短距离，相同点是，每次找d最小的更新其它点的距离。</p><h1 id="Dijkstra堆优化版代码"><a href="#Dijkstra堆优化版代码" class="headerlink" title="Dijkstra堆优化版代码"></a>Dijkstra堆优化版代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,cnt;</span><br><span class="line">ll dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,ll w):u(u),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(!vis[edge[l].to]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123;</span><br><span class="line">                dis[edge[l].to] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n]!=maxx)</span><br><span class="line">        printf(&quot;%lld\n&quot;,dis[n]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。&lt;/p&gt;
&lt;p&gt;这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 &lt;/p&gt;
&lt;h1 id=&quot;基础
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Dijkstra算法" scheme="http://qianyouyou.cn/tags/Dijkstra%E7%AE%97%E6%B3%95/"/>
    
      <category term="SPFA算法" scheme="http://qianyouyou.cn/tags/SPFA%E7%AE%97%E6%B3%95/"/>
    
      <category term="Bellman-Ford算法" scheme="http://qianyouyou.cn/tags/Bellman-Ford%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[分层最短路]Magical Girl Haze</title>
    <link href="http://qianyouyou.cn/2018/09/04/2018-09-04/"/>
    <id>http://qianyouyou.cn/2018/09/04/2018-09-04/</id>
    <published>2018-09-04T07:21:48.000Z</published>
    <updated>2018-09-05T07:57:39.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>去掉的k条路肯定全部在从1到n的某一条路径上，这样走这一条路径才有可能最短。我们可以对最短路分层，即分别求k为0，k为1，k为2……k为k的情况下最短路程。定义最短路时使用二维数组<code>dis[n][k]</code>,n为结点数，k为分层数。设i为每次求得的最短路结点，kk为所在层，dis为最短路，原点到原点的距离为0，则：</p><p>最短路状态转移方程：<code>dis[j][kk]=min(dis[i][kk]+road[i][j],dis[j][kk])</code></p><p>分层状态转移方程：<code>dis[j][kk+1]=min(dis[i][kk],dis[j][kk+1])</code></p><h2 id="Magical-Girl-Haze"><a href="#Magical-Girl-Haze" class="headerlink" title="Magical Girl Haze"></a>Magical Girl Haze</h2><p>There are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases.</p><p>For each test case, the first line has three integers N, MN,M and KK.</p><p>Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv.</p><p>It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,<br>0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print the minimum distance.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">int t,n,m,k,cnt;</span><br><span class="line">ll dis[maxn][12];</span><br><span class="line">bool vis[maxn][12];</span><br><span class="line">int head[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;edge[2*maxn];</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u, j;</span><br><span class="line">    ll dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">NODE(int u,int j,ll w):u(u),j(j),dis(w)&#123;&#125;</span><br><span class="line">bool operator &lt;(const NODE &amp;a)const</span><br><span class="line">&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node[2*maxn];</span><br><span class="line">void add(int u, int v, ll w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s)&#123;</span><br><span class="line">    memset(dis,maxx,sizeof(dis));</span><br><span class="line">    memset(vis,false,sizeof(vis));</span><br><span class="line">    priority_queue&lt;NODE&gt;q;</span><br><span class="line">    q.push(NODE(s,0,0));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int kk = q.top().u;</span><br><span class="line">        int j = q.top().j;</span><br><span class="line">        ll minD = q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[kk][j])</span><br><span class="line">            continue;</span><br><span class="line">        vis[kk][j] = true;</span><br><span class="line">        for(int l = head[kk]; l!=-1; l=edge[l].next)&#123;</span><br><span class="line">            if(j&lt;k&amp;&amp;!vis[edge[l].to][j+1]&amp;&amp;dis[edge[l].to][j+1] &gt; minD)&#123;</span><br><span class="line">                dis[edge[l].to][j+1] = minD;</span><br><span class="line">                q.push(NODE(edge[l].to,j+1,dis[edge[l].to][j+1]));</span><br><span class="line">            &#125;</span><br><span class="line">            if(!vis[edge[l].to][j]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to][j])&#123;</span><br><span class="line">                dis[edge[l].to][j] = minD + edge[l].w;</span><br><span class="line">                q.push(NODE(edge[l].to,j,dis[edge[l].to][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll u,v,w;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        cnt = 0;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        for(int i = 0;i &lt; m; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(1);</span><br><span class="line">        if(dis[n][k]!=maxx)</span><br><span class="line">        printf(&quot;%lld\n&quot;,dis[n][k]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="分层最短路" scheme="http://qianyouyou.cn/tags/%E5%88%86%E5%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[数论]辗转相除法求gcd的数学证明</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03-2/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03-2/</id>
    <published>2018-09-03T15:57:36.000Z</published>
    <updated>2018-09-04T10:48:32.100Z</updated>
    
    <content type="html"><![CDATA[<p>在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。</p><p>gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a,b)。这里就不证明了。</p><p>我们接着看gcd，如何高效求gcd呢？目前最快的方法算是欧几里得算法了。</p><p>欧几里得算法其实很简单，已知a，b，其中a&gt;b，求gcd(a,b)。</p><p>解：用b整除a，得到余数c，再用c整除b，得到余数d，再用d整除c，得到余数e……不断这样操作，最后直到没有余数为止。假设e再整除d，余数为0，则e为最大公因数。</p><p>列式子即为：</p><p>a = x1 * b + r1;</p><p>b = x2 * r1 + r2;</p><p>r1 = x3 * r2 + r3;</p><p>……</p><p>rn-1= xn+1 * rn + rn+1;</p><p>rn = xn+2 * rn+1 + 0;</p><p>若设a为r-1，b为r0，则通项公式即为rn-1 / rn = xn+1 <em> rn + rn+1，最后一项为rn / rn+1 = xn+2 </em> rn+1。</p><p>很容易理解，若某一步余数为0，则上一步的余数即为最大公约数。很容易证明该循环一定会终止，因为最坏的情况下a和b的最大公因数是1，那么任何一个数都是1的倍数，所以任何数取余1都为0，所以循环必会结束。</p><p>该算法历经千年，直到现在依然为求解gcd最高效的算法，gcd(a,b)最坏的情况下运算次数最多才是b位数的7位，这里就不详细介绍了。</p><p>那么为什么最后的结果就是最大公因数呢，接下来我们来证明一下。</p><p>假设g为gcd(a,b)，即g为g，b的最大公因数，则带到上式记为rn = xn+2 * g，这个式子g必然为rn的因数。</p><p>那再带到上一个式子，rn-1 = xn+1 * rn + g，由于g既是rn的因数，又是g的因数，则g是rn-1的因数。</p><p>再带到上一个式子，rn-2 = xn * rn-1 + rn，由于g是rn-1，rn的因数，所以g必然是rn-2的因数。</p><p>……</p><p>最终带到第一组式子中，即g既是a的因数，也是b的因数。</p><p>那如何证明它是最大公因数呢？</p><p>我们假设h为a，b的任意因数，则h整除a，且h整除b，带到第一个式子，则h整除r1，再带到第2个式子，h整除r2，再带到第3个式子，h整除r3……直到倒数第二个式子，h整除rn+1，即h整除g由于最后一个式子余数为0，那么既然g为a，b的因数，h为g的因数，则h&lt;=g，故g为gcd(a,b)。</p><p>证毕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。&lt;/p&gt;
&lt;p&gt;gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="gcd" scheme="http://qianyouyou.cn/tags/gcd/"/>
    
  </entry>
  
  <entry>
    <title>An Olympian Math Problem</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03-1/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03-1/</id>
    <published>2018-09-03T15:57:28.000Z</published>
    <updated>2018-09-05T05:39:16.683Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：</p><p>求解<code>(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1</code>。</p><p>PS：<code>n! = 1 * 2 * …… * n</code>。</p><p>证明过程：</p><p><img src="http://pdz5m676b.bkt.clouddn.com/2018-09-03QQ%E5%9B%BE%E7%89%8720180904190419.jpg" alt=""></p><p>Alice, a student of grade 66, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is:</p><p>We denote k!k!:</p><p>k! = 1 \times 2 \times \cdots \times (k - 1) \times kk!=1×2×⋯×(k−1)×k</p><p>We denote SS:</p><p>S = 1 \times 1! + 2 \times 2! + \cdots +S=1×1!+2×2!+⋯+<br>(n - 1) \times (n-1)!(n−1)×(n−1)!</p><p>Then SS module nn is <strong><strong>____</strong></strong></p><p>You are given an integer nn.</p><p>You have to calculate SS modulo nn.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains an integer T(T \le 1000)T(T≤1000), denoting the number of test cases.</p><p>For each test case, there is a line which has an integer nn.</p><p>It is guaranteed that 2 \le n\le 10^{18}2≤n≤1018.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print an integer SS modulo nn.</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>The first test is: S = 1\times 1!= 1S=1×1!=1, and 11modulo 22 is 11.</p><p>The second test is: S = 1\times 1!+2 \times 2!= 5S=1×1!+2×2!=5, and 55 modulo 33 is 22.</p><h4 id="样例输入复制"><a href="#样例输入复制" class="headerlink" title="样例输入复制"></a>样例输入复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="样例输出复制"><a href="#样例输出复制" class="headerlink" title="样例输出复制"></a>样例输出复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h4><p><a href="https://nanti.jisuanke.com/?kw=ACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B" target="_blank" rel="noopener">ACM-ICPC 2018 南京赛区网络预赛</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll t,n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;,n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;求解&lt;code&gt;(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;n! = 1 * 2 * …… * n&lt;/
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>介于邻接矩阵与邻接表之间的存图方式————链式前向星</title>
    <link href="http://qianyouyou.cn/2018/09/03/2018-09-03/"/>
    <id>http://qianyouyou.cn/2018/09/03/2018-09-03/</id>
    <published>2018-09-03T12:23:43.000Z</published>
    <updated>2018-09-03T12:31:36.917Z</updated>
    
    <content type="html"><![CDATA[<p><strong>链式前向星</strong></p><p><strong>图的存储一般有三种：邻接矩阵、邻接表、前向星。</strong></p><p><strong>若图是稀疏图，边很少，开二维数组很浪费;</strong></p><p><strong>若点很多(如10000个点)<code>a[10000][10000]</code>又会爆.只能用前向星做.</strong></p><p><strong>前向星的效率不是很高，优化后为链式前向星，直接介绍链式前向星。</strong></p><h2 id="（一）链式前向星"><a href="#（一）链式前向星" class="headerlink" title="（一）链式前向星"></a><strong>（一）链式前向星</strong></h2><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. <strong>结构</strong></h2><p><strong>这里用两个东西：</strong></p><p><strong>1 结构体数组edge存边，edge[i]表示第i条边,</strong></p><p><strong>2 head[i]存以i为起点的第一条边(在edge中的下标)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct EDGE&#123;</span><br><span class="line">int next;   //下一条边的存储下标(默认0) </span><br><span class="line">int to;     //这条边的终点 </span><br><span class="line">int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[500010];</span><br></pre></td></tr></table></figure><h2 id="2-增边"><a href="#2-增边" class="headerlink" title="2.增边"></a><strong>2.增边</strong></h2><p><strong>若以点i为起点的边新增了一条，在edge中的下标为j.</strong></p><p><strong>那么edge[j].next=head[i];然后head[i]=j.</strong></p><p><strong>即每次新加的边作为第一条边，最后倒序遍历</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">//cnt为边的计数，从1开始计 </span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. <strong>遍历</strong></h2><p><strong>遍历以st为起点的边</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(int i=head[st]; i!=0; i=edge[i].next)</span><br></pre></td></tr></table></figure><p>i开始为第一条边，每次指向下一条(以0为结束标志)  （若下标从0开始，next应初始化-1）</p><p><strong>一个简单的输出有向图熟悉链式前向星：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">int next;   //下一条边的存储下标 </span><br><span class="line">int to;     //这条边的终点 </span><br><span class="line">int w;      //权值 </span><br><span class="line">&#125;; </span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, cnt;</span><br><span class="line">int head[MAXN];  //head[i]表示以i为起点的第一条边 </span><br><span class="line">void Add(int u, int v, int w) &#123;  //起点u, 终点v, 权值w </span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">head[u] = cnt;    //第一条边为当前边 </span><br><span class="line">&#125; </span><br><span class="line">void Print() &#123;</span><br><span class="line">int st;</span><br><span class="line">cout &lt;&lt; &quot;Begin with[Please Input]: \n&quot;;</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line">for(int i=head[st]; i!=0; i=edge[i].next) &#123;//i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 </span><br><span class="line">cout &lt;&lt; &quot;Start: &quot; &lt;&lt; st &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;End: &quot; &lt;&lt; edge[i].to &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;W: &quot; &lt;&lt; edge[i].w &lt;&lt; endl &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int s, t, w;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;</span><br><span class="line">Add(s, t, w);</span><br><span class="line">&#125;</span><br><span class="line">Print(); </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）链式前向星实现SPFA"><a href="#（二）链式前向星实现SPFA" class="headerlink" title="（二）链式前向星实现SPFA"></a><strong>（二）链式前向星实现SPFA</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXM 500010</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define ANS_MAX 2147483647</span><br><span class="line">struct EDGE &#123;</span><br><span class="line">int next;</span><br><span class="line">int to;</span><br><span class="line">int w;</span><br><span class="line">&#125;;</span><br><span class="line">EDGE edge[MAXM];</span><br><span class="line">int n, m, st, cnt;</span><br><span class="line">int head[MAXN];</span><br><span class="line">int d[MAXN];</span><br><span class="line">bool inq[MAXN];</span><br><span class="line">inline int Read() &#123;</span><br><span class="line">char c; int ans = 0; bool Sign = false;</span><br><span class="line">while(!isdigit(c=getchar()) &amp;&amp; c != &apos;-&apos;);</span><br><span class="line">if(c == &apos;-&apos;) &#123;</span><br><span class="line">Sign = true;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">ans = (ans&lt;&lt;3) + (ans&lt;&lt;1) + (c ^ &apos;0&apos;);</span><br><span class="line">&#125; while(isdigit(c=getchar()));</span><br><span class="line">return Sign ? -ans : ans;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int u, int v, int w) &#123;</span><br><span class="line">edge[++cnt].next = head[u];</span><br><span class="line">edge[cnt].to = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">void read() &#123;</span><br><span class="line">int x, y, w;</span><br><span class="line">n = Read();</span><br><span class="line">m = Read();</span><br><span class="line">st = Read();</span><br><span class="line">for(int i=1; i&lt;=m; i++) &#123;</span><br><span class="line">x = Read();</span><br><span class="line">y = Read();</span><br><span class="line">w = Read();</span><br><span class="line">Add(x, y, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void SPFA(int x) &#123;</span><br><span class="line">d[x] = 0; for(int i=1; i&lt;=n; i++) d[i] = ANS_MAX;</span><br><span class="line">queue&lt;int&gt; Q; Q.push(x); inq[x] = true;</span><br><span class="line">while(!Q.empty()) &#123;</span><br><span class="line">int k = Q.front(); Q.pop(); inq[k] = false;</span><br><span class="line">for(int i=head[k]; i!=0; i=edge[i].next) &#123;</span><br><span class="line">int j = edge[i].to;</span><br><span class="line">if(d[j] &gt; d[k] + edge[i].w) &#123;</span><br><span class="line">d[j] = d[k] + edge[i].w;</span><br><span class="line">if(!inq[j]) &#123;</span><br><span class="line">Q.push(j);</span><br><span class="line">inq[j] = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, d[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">read();</span><br><span class="line">SPFA(st);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;链式前向星&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图的存储一般有三种：邻接矩阵、邻接表、前向星。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若图是稀疏图，边很少，开二维数组很浪费;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若点很多(如
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="链式前向星" scheme="http://qianyouyou.cn/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1001 Buy and Resell</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25-2/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25-2/</id>
    <published>2018-08-25T14:55:54.000Z</published>
    <updated>2018-08-26T12:26:24.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Buy-and-Resell"><a href="#Buy-and-Resell" class="headerlink" title="Buy and Resell"></a>Buy and Resell</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p><p>Problem Description</p><p>The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:<br>\1. spend ai dollars to buy a Power Cube<br>\2. resell a Power Cube and get ai dollars if he has at least one Power Cube<br>\3. do nothing<br>Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning.</p><p>Input</p><p>There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:<br>The first line has an integer n. (1≤n≤105)<br>The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)<br>It is guaranteed that the sum of all n is no more than 5×105.</p><p>Output</p><p>For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit.</p><p>Sample Input</p><p>3 4 1 2 10 9 5 9 5 9 10 5 2 2 1</p><p>Sample Output</p><p><em>Hint</em></p><p>profit = - 1 - 2 + 10 + 9 = 16</p><p>profit = - 5 + 10 = 5</p><p>profit = 0</p><p>题解：</p><p>n天，每天商品有个价格，或买或卖或不买不卖。</p><p>贪心策略：分为两个堆（或优先队列），一个堆v为储存买的价格，一个堆s储存卖的价格。第i天的商品和之前买与卖两个堆中的最小值进行比较。共分为四种情况：1.如果第i天的价格比买的堆v里最小值大，且买的堆v里最小值比卖的堆s里最小值小，则买掉买的堆v里最小的，再卖出去，交易次数加2，即v.pop(),s.push(),cnt+2。2.如果第i天的价格比卖的堆s里最小值大，且买的堆v里最小值比卖的堆s里最小值大，则买掉卖的堆s里最小的，再卖出去，意思为现在卖比之前卖的那次更划算，我们把它买回来就等于之前那次没有卖，再卖出去等于现在才卖，即s.pop(),v.push(),s.push()。3.如果当天的价格即小于s中最小又小于v中最小，则把他放到买的堆v里，即v.push()。</p><p>这样下来，最后买的堆里剩下的就是没买没卖的。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll n, tmp, cnt = 0,sum = 0;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">        priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;v,s;</span><br><span class="line">        for(ll i = 0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lld&quot;,&amp;tmp);</span><br><span class="line">            if(!v.empty())&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top()&amp;&amp;s.top()&lt;=v.top())&#123;</span><br><span class="line">                    sum+=tmp-(s.top());</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                 else if(tmp&gt;v.top()&amp;&amp;(s.empty()||s.top()&gt;v.top()))&#123;</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                    sum+=tmp-(v.top());</span><br><span class="line">                    v.pop();</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(tmp&lt;=v.top())&#123;</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(!s.empty()&amp;&amp;tmp&gt;s.top())&#123;</span><br><span class="line">                    v.push(s.top());</span><br><span class="line">                    sum+=tmp-s.top();</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    v.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%lld %lld\n&quot;,sum,2*cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Buy-and-Resell&quot;&gt;&lt;a href=&quot;#Buy-and-Resell&quot; class=&quot;headerlink&quot; title=&quot;Buy and Resell&quot;&gt;&lt;/a&gt;Buy and Resell&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit: 20
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1009 Tree and Permutation</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25-1/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25-1/</id>
    <published>2018-08-25T13:03:48.000Z</published>
    <updated>2018-08-26T12:27:00.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tree-and-Permutation"><a href="#Tree-and-Permutation" class="headerlink" title="Tree and Permutation"></a>Tree and Permutation</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0</strong></p><p>Problem Description</p><p>There are N vertices connected by N?1 edges, each edge has its own length.<br>The set { 1,2,3,…,N } contains a total of N! unique permutations, let’s say the i-th permutation is Pi and Pi,j is its j-th number.<br>For the i-th permutation, it can be a traverse sequence of the tree with N vertices, which means we can go from the Pi,1-th vertex to the Pi,2-th vertex by the shortest path, then go to the Pi,3-th vertex ( also by the shortest path ) , and so on. Finally we’ll reach the Pi,N-th vertex, let’s define the total distance of this route as D(Pi) , so please calculate the sum of D(Pi) for all N! permutations.</p><p>Input</p><p>There are 10 test cases at most.<br>The first line of each test case contains one integer N ( 1≤N≤105 ) .<br>For the next N?1 lines, each line contains three integer X, Y and L, which means there is an edge between X-th vertex and Y-th of length L ( 1≤X,Y≤N,1≤L≤109 ) .</p><p>Output</p><p>For each test case, print the answer module 109+7 in one line.</p><p>Sample Input</p><p>3</p><p>1 2 1</p><p>2 3 1</p><p>3</p><p>1 2 1</p><p>1 3 2</p><p>Sample Output</p><p>16</p><p>24</p><p>题意：</p><p>首先给出一个含有n个节点的树，边权为距离。</p><p>对于1-n的某一种排列p1,p2,p3……pn，贡献为dis(p1,p2)+dis(p2,p3)+dis(p3,p4)+……+dis(pn-1,pn)</p><p>求所有排列的贡献和</p><p>题解：</p><p>一棵树n个结点n-1条边，所以任意两点之间都有最短距离。由于所有遍历方式可以看做n个结点的排列，而每次有直接关系的只有两点之间的距离，因此只需求出两点之间的距离在所有排列中一共出现多少次即可。</p><p>比如n=2时，两个点1,2，共有两种排列方式，即1,2,和2,1</p><p>n=3时，三个点1,2,3,其中1,2共有4种方法得到，即1,2,3,和2,1,3,和3,1,2,和3,2,1</p><p>n=4时，三个点1,2,3,4,其中1,2共有12种方法得到，即1,2,3,4,和1,2,4,3,和2,1,3,4,和2,1,4,3,和3,1,2,4,和3,2,1,4和4,1,2,3,和4,2,1,3,和3,4,1,2,和4,3,1,2,和3,4,2,1,和4,3,2,1,</p><p>n=jie[n-1]*（n-1）。</p><p>先用树状dp求出所有两两结点之间的距离之和，再乘以每条边在所有结点排列的n！方式中一共用到的次数。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 1e9+7;</span><br><span class="line">ll sum[maxn], n;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll jie[maxn];</span><br><span class="line">ll jie2[maxn];</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    ll v, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; tree[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    jie[2] = 2;</span><br><span class="line">    for(ll i = 3;i&lt;maxn;i++)&#123;</span><br><span class="line">        jie[i] = jie[i-1]*(i-1)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(ll cur, ll father)</span><br><span class="line">&#123;</span><br><span class="line">    sum[cur] = 1;</span><br><span class="line">    for(ll i = 0; i &lt; tree[cur].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll son = tree[cur][i].v;</span><br><span class="line">        ll len = tree[cur][i].w;</span><br><span class="line">        if(father == son)</span><br><span class="line">            continue;</span><br><span class="line">        dfs(son, cur);</span><br><span class="line">        sum[cur] += sum[son]%mod;</span><br><span class="line">        sum[cur]%=mod;</span><br><span class="line">        dp[cur] += (dp[son]%mod + (n-sum[son])%mod*sum[son]%mod * len%mod)%mod;</span><br><span class="line">        dp[cur]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll u, v, w;</span><br><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&lt;=2)&#123;</span><br><span class="line">            if(n==1)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            printf(&quot;%lld\n&quot;, 2*w%mod);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(ll i = 0; i &lt; n; i++)</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for(ll i = 0; i &lt; n-1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            u--,v--;</span><br><span class="line">            Edge t1, t2;</span><br><span class="line">            t1.v = v;</span><br><span class="line">            t1.w = w;</span><br><span class="line">            t2.v = u;</span><br><span class="line">            t2.w = w;</span><br><span class="line">            tree[u].push_back(t1);</span><br><span class="line">            tree[v].push_back(t2);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, -1);</span><br><span class="line">        printf(&quot;%lld\n&quot;, (dp[0]%mod)*jie[n]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tree-and-Permutation&quot;&gt;&lt;a href=&quot;#Tree-and-Permutation&quot; class=&quot;headerlink&quot; title=&quot;Tree and Permutation&quot;&gt;&lt;/a&gt;Tree and Permutation&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>2018中国大学生程序设计竞赛 - 网络选拔赛 1004 Find Integer</title>
    <link href="http://qianyouyou.cn/2018/08/25/2018-08-25/"/>
    <id>http://qianyouyou.cn/2018/08/25/2018-08-25/</id>
    <published>2018-08-25T13:03:04.000Z</published>
    <updated>2018-08-28T06:36:13.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Find-Integer"><a href="#Find-Integer" class="headerlink" title="Find Integer"></a>Find Integer</h1><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0    Accepted Submission(s): 0Special Judge</strong></p><p>Problem Description</p><p>people in USSS love math very much, and there is a famous math problem .<br>give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn.</p><p>Input</p><p>one line contains one integer T;(1≤T≤1000000)<br>next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000)</p><p>Output</p><p>print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);<br>else print two integers -1 -1 instead.</p><p>Sample Input</p><p>1 2 3</p><p>Sample Output</p><p>4 5</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>本题首先用到了费马大定理，即a^n+b^n≠c^n。(a,b,c∈Z，n&gt;2)</p><p>所以当n大于2或者n为0时直接输出-1,-1，当n=1时直接输出1,a+1。</p><p>当n=2时，输出勾股数。</p><p>首先a²+b²=c²，a²=c²-b²，a²=(c+b)(c-b)。</p><p>设x=c+b，y=c-b，则a²=xy。</p><p>c=(x+y)/2，b=(x-y)/2。</p><p>当然我的方法是通过打表求得勾股数，方法有点偏暴力，即枚举x，y，然后用公式看c，b是否在范围内且为整数，当然在枚举的时候少不了剪枝，不然肯定tle。</p><p>不过后来听说根据费马大定理奇偶数列法则可。直接推出式子。</p><p>打表代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll b,c;</span><br><span class="line">&#125;aa[40007];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(aa,0,sizeof(aa));</span><br><span class="line">    for(ll i = 3;i&lt;=40000;i++)&#123;</span><br><span class="line">        for(ll j = 1;j&lt;i;j++)&#123;</span><br><span class="line">            if(i*i%j==0)&#123;</span><br><span class="line">                ll x = j;</span><br><span class="line">                ll y = i*i/j;</span><br><span class="line">                if((x+y)%2==0)&#123;</span><br><span class="line">                    aa[i].c=(x+y)/2;</span><br><span class="line">                    aa[i].b=(y-x)/2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll a,b,c,n;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);</span><br><span class="line">        if(n&gt;2||n==0)&#123;</span><br><span class="line">            printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n==1)&#123;</span><br><span class="line">            printf(&quot;1 %lld\n&quot;,a+1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(aa[a].b)&#123;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,aa[a].b,aa[a].c);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;-1 -1\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0(1)代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b,c,n;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a);</span><br><span class="line">        if(n&gt;2||n==0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(n==1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;1 %lld\n&quot;,a+1);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(a%2==1&amp;&amp;a&gt;1)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cc=(a-1)/2;</span><br><span class="line">                b=2*cc*(cc+1);</span><br><span class="line">                c=2*cc*(cc+1)+1;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,b,c);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(a%2==0&amp;&amp;a&gt;2)</span><br><span class="line">            &#123;</span><br><span class="line">                ll cc=a/2;</span><br><span class="line">                b=cc*cc-1;</span><br><span class="line">                c=cc*cc+1;</span><br><span class="line">                printf(&quot;%lld %lld\n&quot;,b,c);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;-1 -1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推导过程："><a href="#推导过程：" class="headerlink" title="推导过程："></a>推导过程：</h2><p>a为任意情况</p><p>a² = c² - b²</p><p>a² = (c+b)(c-b)</p><p>a²  = a² * 1</p><p>c + b = a² </p><p>c - b = 1</p><p>c = (a²  + 1) / 2</p><p>b = (a²  - 1) / 2</p><p>a为偶数情况：</p><p>if(a² % 2 == 0)</p><p>a²  = a²/2 * 2</p><p>c + b = a²/2 </p><p>c - b = 2</p><p>c = a²/4 + 1</p><p>b =a²/4 - 1</p><p>证毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Find-Integer&quot;&gt;&lt;a href=&quot;#Find-Integer&quot; class=&quot;headerlink&quot; title=&quot;Find Integer&quot;&gt;&lt;/a&gt;Find Integer&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit: 2000/1000 
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
      <category term="费马大定理" scheme="http://qianyouyou.cn/tags/%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>8.23网络流专项训练题解</title>
    <link href="http://qianyouyou.cn/2018/08/23/2018-08-23/"/>
    <id>http://qianyouyou.cn/2018/08/23/2018-08-23/</id>
    <published>2018-08-23T08:02:47.000Z</published>
    <updated>2018-08-26T12:35:28.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-A-赛马"><a href="#问题-A-赛马" class="headerlink" title="问题 A: 赛马"></a>问题 A: 赛马</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 32  解决: 5<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1890" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1890&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1890&amp;getkey=A121ED5825" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1890" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>古有田忌赛马戏齐王，今有悠悠赛马虐渣渣。悠悠和他的小老弟渣渣每人有n匹马，每匹马都有一个评分，分数越高速度越快。现在渣渣不甘于当小老弟，随着赛马曲的想起，渣渣决定挑战悠悠，规则同田忌赛马。每胜一局得1分，每负一局减一分，赵神做裁判，悠悠为了捍卫自己的王者地位，决定出老千，问了赵神关于渣渣的赛马顺序，请问悠悠最高能得多少分。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>文件有多组测试样例，遇0为止。</p><p>首行一个整数n，n&lt;=1000;</p><p>第2行n个整数表示悠悠每匹马的分数。</p><p>第3行n个整数表示渣渣每匹马的分数。0&lt;=分数&lt;500;</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出悠悠最高分。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">192 173 71</span><br><span class="line">195 177 74</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">10 10</span><br><span class="line">2</span><br><span class="line">220 219</span><br><span class="line">222 218</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>水题，可以用网络流或者匹配，也可以用更简单的方法。</p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1890" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1890&amp;getkey=A121ED5825" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1890" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题贪心可解。贪心策略即田忌赛马的策略。第1步我们将我们最慢的马和对方最快的马进行比较，如果最慢的马比对方最慢的马快，那么我们就胜一局，然后返回第1步。反之我们进行第2步，继续拿我们最快的马和对方最快的马进行比较，如果获胜就胜一局，然后返回第1步。反之我们进行第3步，继续拿我们最慢的马和对方最快的马进行比较，这种情况下分为两种情况，一种是得分相等，另外一种是我方必败，必败得分减一，否则不变，然后我们再返回第1步。直到所有的马都结束为止，此时我们就得到了最高得分。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1007],b[1007];</span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    if(n==0)</span><br><span class="line">    break;</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        sort(b,b+n);</span><br><span class="line">        int s=0;</span><br><span class="line">        for(int i=0,j=0,k=n-1,l=n-1; i&lt;=k;)&#123;</span><br><span class="line">            if(a[i]&gt;b[j])</span><br><span class="line">            s++,i++,j++;</span><br><span class="line">            else if(a[k]&gt;b[l])</span><br><span class="line">            s++,k--,l--;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(a[i]&lt;b[l])</span><br><span class="line">                s--;</span><br><span class="line">                i++,l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-海上钢琴师"><a href="#问题-B-海上钢琴师" class="headerlink" title="问题 B: 海上钢琴师"></a>问题 B: 海上钢琴师</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1894" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1894&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1894&amp;getkey=93904EDF34" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1894" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>宁愿一生孤独，不愿随波逐流。海上钢琴师毅然留在了船上，与大海为伴，此生再不上岸。</p><p>然而，他的音乐却已名扬四海。为了将他的钢琴声可以传播到陆地以便欣赏，人们决定在陆地与钢琴师所在的船之间的n-2座岛屿上建立声音保留设备。每当声音传到该设备处时，以该设备为起点可以将声音信号发送到其他与该设备有信号连接的设备那里。信号传播是单向的，且是有限的。当该设备将一部分信号传给其他设备时，该设备所拥有的总信号要减去相应传出去的信号，所保留的信号可以继续传给其他的设备。船上也有该设备，由于岛屿与船的位置不同，所以钢琴声传到设备的声音有限。设备与设备之间的传播分贝也有限。陆地的总接收设备与某些岛屿上的设备有信号连接，请问陆地最多能收到多少分贝的钢琴声。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>第一行输入两个数m，n。m代表共有m对设备建立了单向连接。n代表包括船和陆地在内共有n个设备。编号1为船，编号n为陆地，其他为岛屿（n&lt;=100，m&lt;=1000）</p><p>接下来m行，每行三个数a，b，c，代表a-&gt;b，即a的信号可以传到b信号，最大可以通过该信号传送c分贝。c&lt;=2000</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>输出陆地上最大可以收到多少分贝声音。（海上钢琴声不超过10000分贝）</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2 100</span><br><span class="line">1 3 50</span><br><span class="line">2 3 2</span><br><span class="line">3 4 60</span><br><span class="line">2 4 99</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">150</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>样例解释：（容量，流量）</p><p>方案1：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180822/20180822133414_80763.png" alt="img"></p><p>方案2：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180822/20180822133437_68424.png" alt="img"></p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1894" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1894&amp;getkey=93904EDF34" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1894" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>网络流最大流模板题。题面转化过来就是一个网络流模型，船为s，陆地为t，设备之间的连接就是弧。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;m&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(1,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-进击的巨人"><a href="#问题-C-进击的巨人" class="headerlink" title="问题 C: 进击的巨人"></a>问题 C: 进击的巨人</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1895" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1895&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1895&amp;getkey=DF84EFB393" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1895" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>那一年，巨人发起了第一轮进击，s城破，埃尔文团长带领众居民计划逃往较安全的t城。从s城到t城之间共有m坐城市，某些城市之间构成单向通路。由s城到t城恰构成一个有向无环图。然而每条路上都有限定的最大人流量。埃尔文团长想知道每一次最多有多少居民能到达t城。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>首行输入两个数n，m（n，m&lt;=100），n0为s城，nn为t城。s城到t城之间的城用n1——nn表示。m表示单项通道数。</p><p>接下来m行，每行三个数a，b，c，代表a到b的最大人流量是c。c&lt;1000。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出最多有多少人到t</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6 14</span><br><span class="line">0 2 5</span><br><span class="line">0 1 10</span><br><span class="line">1 2 6</span><br><span class="line">0 3 5</span><br><span class="line">3 1 2</span><br><span class="line">1 5 3</span><br><span class="line">5 2 3</span><br><span class="line">5 4 3</span><br><span class="line">3 5 3</span><br><span class="line">3 4 4</span><br><span class="line">3 6 5</span><br><span class="line">2 6 6</span><br><span class="line">4 6 10</span><br><span class="line">2 4 4</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1895" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1895&amp;getkey=DF84EFB393" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1895" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>网络流最大流模板题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-X档案"><a href="#问题-D-X档案" class="headerlink" title="问题 D: X档案"></a>问题 D: X档案</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 5  解决: 3<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1883" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1883&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1883&amp;getkey=B46583A0E8" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1883" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>据X档案记载，倘若外星文明即将攻击地球，会在战争之前发动病毒袭击，最合理的对象是鸟或狗，因为鸟在空中传播病毒的范围2较广，而狗相较于其他动物来说和人类接触最频繁。X城作为全球反外星文明的重要基地，对外星文明来说威胁最大而作为外星文明首先攻击的目标。因此，X长官下令捕杀了全城的鸟，而狗由于受到爱狗人士们的保护免于此劫。然而灾难还是降临了，外星文明悄无声息地将病毒注入到一些狗体内。据全球卫星显示，X城的地形是一个n<em>m的矩阵，划分成了n</em>m个1<em>1的小矩阵。矩阵的四周被城墙所围。而在某些单位1</em>1的小矩阵中有居民，或者有被感染的狗。我们已经知道了狗的全部坐标，为了安全起见，X长官启动了X计划，将这些狗在未发作之前用围栏隔离起来以防止狗攻击人类，每个1*1的小矩阵四周均可建立围栏。该计划收录到了X档案中。围栏使得狗和人类均无法通过。由于计划的机密性，长官不想动用太多的财力，现求最少需要多长围栏才能将所有狗隔离。</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组样例，读到文件结束。</p><p>第一行为n，m，代表n*m的矩阵。（0&lt;n，m&lt;=150）</p><p>接下来n行，每行m个由0，1，2组成的数。</p><p>0代表此处没有任何东西，1代表此处有人，2代表此处有被感染的狗。</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出格式为：Case i: k</p><p>i为第i组样例，k为所需最短的围栏长度。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">2 0 0 0 0 1</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line">0 0 2 0 0 1</span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">4 6</span><br><span class="line">0 0 1 0 0 1</span><br><span class="line">0 0 0 1 1 0</span><br><span class="line">0 0 0 0 2 2</span><br><span class="line">0 1 1 0 2 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 6</span><br><span class="line">Case 2: 4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>第1组样例解释：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180821/20180821210755_92707.png" alt="img"> </p><p>第2组样例解释：</p><p><img src="http://sustoj.com/JudgeOnline/upload/image/20180821/20180821211137_35539.png" alt="img"> </p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1883" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1883&amp;getkey=B46583A0E8" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1883" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>题目描述那么多，其实就是最小割问题。只不过我们要建立一个超级源点指向所有狼（羊），再建立一个超级汇点指向所有羊（狼）。羊和狼为结点，两个节点直接一条边，权值为1。最终求解最大流即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 100100</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int to[maxn],c[maxn],first[maxn],Next[maxn],N;</span><br><span class="line">int d[maxn];</span><br><span class="line">int Q[maxn],bot,top,tag[maxn],can[maxn];</span><br><span class="line">int s,t,n,m,tmp,ans,cas=0;</span><br><span class="line">int TAG=5201314;</span><br><span class="line">void _init()</span><br><span class="line">&#123;</span><br><span class="line">    ans=s=0,t=n*m+1,N=-1;</span><br><span class="line">    for (int i=s; i&lt;=t; i++) first[i]=-1;</span><br><span class="line">&#125;</span><br><span class="line">void edge(int U,int V,int W)</span><br><span class="line">&#123;</span><br><span class="line">    N++;</span><br><span class="line">    to[N]=V,c[N]=W;</span><br><span class="line">    Next[N]=first[U],first[U]=N;</span><br><span class="line">&#125;</span><br><span class="line">void _input()</span><br><span class="line">&#123;</span><br><span class="line">    int cur=0;</span><br><span class="line">    for (int i=1; i&lt;=n; i++)</span><br><span class="line">        for (int j=1; j&lt;=m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);</span><br><span class="line">            cur++;</span><br><span class="line">            if (i&lt;n) edge(cur,cur+m,1),edge(cur+m,cur,1);</span><br><span class="line">            if (j&lt;m) edge(cur,cur+1,1),edge(cur+1,cur,1);</span><br><span class="line">            if (tmp==2) edge(s,cur,inf),edge(cur,s,inf);</span><br><span class="line">                else if (tmp==1) edge(cur,t,inf),edge(t,cur,inf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    TAG++;</span><br><span class="line">    Q[bot=top=1]=t,d[t]=0,tag[t]=TAG;</span><br><span class="line">    while (bot&lt;=top)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=Q[bot++];</span><br><span class="line">        for (int i=first[cur]; i!=-1; i=Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            if (c[i^1]&lt;=0 || tag[to[i]]==TAG) continue;</span><br><span class="line">            tag[to[i]]=TAG,d[to[i]]=d[cur]+1,Q[++top]=to[i];</span><br><span class="line">            if (to[i]==s) return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int cur,int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (cur==t) return num;</span><br><span class="line">    int tmp=num,k;</span><br><span class="line">    for (int i=first[cur]; i!=-1; i=Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        if (d[cur]!=d[to[i]]+1 || c[i]&lt;=0 || tag[to[i]]!=TAG || can[to[i]]==TAG) continue;</span><br><span class="line">        k=dfs(to[i],min(num,c[i]));</span><br><span class="line">        if (k) c[i]-=k,c[i^1]+=k,num-=k;</span><br><span class="line">        if (num==0) break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num) can[cur]=TAG;</span><br><span class="line">    return tmp-num;</span><br><span class="line">&#125;</span><br><span class="line">void dinic()&#123;</span><br><span class="line">    while (bfs())</span><br><span class="line">    ans+=dfs(s,inf);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        _init();</span><br><span class="line">        _input();</span><br><span class="line">        dinic();</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;,++cas,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-同桌的你"><a href="#问题-E-同桌的你" class="headerlink" title="问题 E: 同桌的你"></a>问题 E: 同桌的你</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1892" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1892&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1892&amp;getkey=FA65543DBF" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1892" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>据yoyo统计，青春期的情侣80%都是曾经的同桌。因此，选择好的同桌对你日后的感情发展有很大的帮助。高一7班共有n个男生，m个女生，男生们听过分析后纷纷要求重新排座位，以期待和心仪的女生做同桌。每个男生都有自己的暗恋对象，0&lt;=暗恋对象的个数&lt;=m，也就是说某个男生最多暗恋全班女生，最少一个都不暗恋。汪老师知道这件事后很是重视，于是开始调座位，优先考虑男生和他的暗恋女生坐在一起。男生用a表示，女生用n表示。请问最多有多少男生能和自己心仪的对象坐在一起。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>首行输入n，m，e（0&lt;n，m&lt;=1000，0&lt;=e&lt;=10000）n男m女e为所有男生暗恋女生的个数之和。</p><p>接下来e行，每行两个数i，j，代表ai男生暗恋bj女生。</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>一个整数，最优分配下最多有多少男生能和自己心仪的对象坐在一起。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1 2</span><br><span class="line">2 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>样例解释：</p><p>全班两个男生暗恋班里唯一一个女生，无论怎么分配只能凑成一对。</p><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1892" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1892&amp;getkey=FA65543DBF" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1892" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>二分图最大匹配问题。男生和女生构成二分图，每个男生和暗恋的女生之间建立一条边。由于不涉及到权值，因此可用匈牙利算法求解，当然也可用网络流求解。网络流的话就是在二分图的两部分分别建立超级源点s和超级汇点t，每条边的容量固定是1，然后此题就转化成了网络流问题。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">int cnt=2;</span><br><span class="line">int alist[6000001];</span><br><span class="line">struct data&#123;</span><br><span class="line">    int v;int next;int value;</span><br><span class="line">&#125;edge[6000001];</span><br><span class="line">void add(int u,int v,int value)</span><br><span class="line">&#123;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].value=value;</span><br><span class="line">    edge[cnt].next=alist[u];</span><br><span class="line">    alist[u]=cnt++;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int h[1000001];</span><br><span class="line">int q[1000001];</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">    int x,next;</span><br><span class="line">    memset(h,-1,sizeof(h));</span><br><span class="line">    int head=0,tail=1;</span><br><span class="line">    q[head]=1;</span><br><span class="line">    h[1]=0;</span><br><span class="line">    while(head&lt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        x=q[head++];</span><br><span class="line">        next=alist[x];</span><br><span class="line">        while(next)</span><br><span class="line">        &#123;</span><br><span class="line">            int v=edge[next].v;</span><br><span class="line">            int value=edge[next].value;</span><br><span class="line">            if(value&amp;&amp;h[v]&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                q[tail++]=v;</span><br><span class="line">                h[v]=h[x]+1;</span><br><span class="line">            &#125;</span><br><span class="line">            next=edge[next].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(h[n]==-1) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int ans;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==n) return y;</span><br><span class="line">    int next=alist[x];</span><br><span class="line">    int w,used=0;</span><br><span class="line">    while(next)</span><br><span class="line">    &#123;</span><br><span class="line">        int v=edge[next].v;</span><br><span class="line">        int value=edge[next].value;</span><br><span class="line">        if(value&amp;&amp;h[v]==h[x]+1)</span><br><span class="line">        &#123;</span><br><span class="line">                w=y-used;</span><br><span class="line">                w=dfs(v,min(w,value));</span><br><span class="line">                edge[next].value-=w;</span><br><span class="line">                edge[next^1].value+=w;</span><br><span class="line">                used+=w;</span><br><span class="line">                if(used==y) return y;</span><br><span class="line">        &#125;</span><br><span class="line">        next=edge[next].next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!used) h[x]=-1;</span><br><span class="line">    return used;</span><br><span class="line">&#125;</span><br><span class="line">void dinic()</span><br><span class="line">&#123;</span><br><span class="line">    while(bfs()) ans+=dfs(1,0x7fffffff);</span><br><span class="line">&#125;</span><br><span class="line">int n1,m1,e1;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;m1,&amp;e1);</span><br><span class="line">    n=n1+m1+2;</span><br><span class="line">    for(int i=1;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(1,i+1,1);</span><br><span class="line">        add(i+1,1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=e1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        if(u&lt;=n1&amp;&amp;v&lt;=m1)</span><br><span class="line">        add(u+1,v+n1+1,1),</span><br><span class="line">        add(v+n1+1,u+1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(i+n1+1,n,1);</span><br><span class="line">        add(n,i+n1+1,1);</span><br><span class="line">    &#125;</span><br><span class="line">    dinic();//暴力跑最大流</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-奇迹暖暖"><a href="#问题-F-奇迹暖暖" class="headerlink" title="问题 F: 奇迹暖暖"></a>问题 F: 奇迹暖暖</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1893" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1893&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1893&amp;getkey=5F0E1E84F3" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1893" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>梅拉抢走了绫罗的设计图，暖暖决定帮绫罗抢过来。于是梅拉和暖暖开始了搭配比赛。梅拉和暖暖各有n套衣服。由于暖暖是天才服装搭配师，且自带主角光环，又怎会输呢，（废话，输了你怎么通关啊）只不过暖暖为了让梅拉输的心服口服，决定狠狠虐梅拉一把。针对梅拉的n套衣服，暖暖的每套衣服i得分都比梅拉的任意一套衣服j得分高出score(ij)，0&lt;=score(ij)&lt;100000。然而每比完一场，他们之后的比赛都不能再用这套的衣服了。所以对于n场比赛，求出暖暖最高能比梅拉高多少分？（至少为0）</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>首行输入n(n&lt;=300)</p><p>接下来n行，第i行表示暖暖的第i套衣服，每行n个数，第j个数表示暖暖第i套衣服比梅拉第j套衣服的分高多少分。</p><p>0&lt;=score(ij)&lt;100000</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，即最高高出多少分</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">100 5</span><br><span class="line">20 23</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1893" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1893&amp;getkey=5F0E1E84F3" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1893" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>最大权二分图匹配。暖暖和梅拉构成二分图。每条边均有权值，最终求解二分匹配下的最大权值。二分图匹配除了网络流以外还有两道专门解二分图的算法，即匈牙利算法和KM算法。匈牙利算法一般解决二分图最大匹配问题，即边没有权值。而km算法一般解决有权值的二分图。本题为KM算法模板题。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=300+7;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int n,nx,ny;</span><br><span class="line">int linker[N],lx[N],ly[N],slack[N];</span><br><span class="line">int visx[N],visy[N],w[N][N];</span><br><span class="line"></span><br><span class="line">int DFS(int x)&#123;</span><br><span class="line">    visx[x]=1;</span><br><span class="line">    for(int y=1;y&lt;=ny;y++)&#123;</span><br><span class="line">        if(visy[y])</span><br><span class="line">            continue;</span><br><span class="line">        int tmp=lx[x]+ly[y]-w[x][y];</span><br><span class="line">        if(tmp==0)&#123;</span><br><span class="line">            visy[y]=1;</span><br><span class="line">            if(linker[y]==-1 || DFS(linker[y]))&#123;</span><br><span class="line">                linker[y]=x;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(slack[y]&gt;tmp)&#123;</span><br><span class="line">            slack[y]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int KM()&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    memset(linker,-1,sizeof(linker));</span><br><span class="line">    memset(ly,0,sizeof(ly));</span><br><span class="line">    for(i=1;i&lt;=nx;i++)      //lx初始化为与它关联边中最大的</span><br><span class="line">        for(j=1,lx[i]=-INF;j&lt;=ny;j++)</span><br><span class="line">            if(w[i][j]&gt;lx[i])</span><br><span class="line">                lx[i]=w[i][j];</span><br><span class="line">    for(int x=1;x&lt;=nx;x++)&#123;</span><br><span class="line">        for(i=1;i&lt;=ny;i++)</span><br><span class="line">            slack[i]=INF;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            memset(visx,0,sizeof(visx));</span><br><span class="line">            memset(visy,0,sizeof(visy));</span><br><span class="line">            if(DFS(x))  //若成功（找到了增广轨），则该点增广完成，进入下一个点的增广</span><br><span class="line">                break;  //若失败（没有找到增广轨），则需要改变一些点的标号，使得图中可行边的数量增加。</span><br><span class="line">                        //方法为：将所有在增广轨中（就是在增广过程中遍历到）的X方点的标号全部减去一个常数d，</span><br><span class="line">                        //所有在增广轨中的Y方点的标号全部加上一个常数d</span><br><span class="line">            int d=INF;</span><br><span class="line">            for(i=1;i&lt;=ny;i++)</span><br><span class="line">                if(!visy[i] &amp;&amp; d&gt;slack[i])</span><br><span class="line">                    d=slack[i];</span><br><span class="line">            for(i=1;i&lt;=nx;i++)</span><br><span class="line">                if(visx[i])</span><br><span class="line">                    lx[i]-=d;</span><br><span class="line">            for(i=1;i&lt;=ny;i++)  //修改顶标后，要把所有不在交错树中的Y顶点的slack值都减去d</span><br><span class="line">                if(visy[i])</span><br><span class="line">                    ly[i]+=d;</span><br><span class="line">                else</span><br><span class="line">                    slack[i]-=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(i=1;i&lt;=ny;i++)</span><br><span class="line">        if(linker[i]!=-1)</span><br><span class="line">            res+=w[linker[i]][i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        nx=ny=n;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=1;j&lt;=n;j++)</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;w[i][j]);</span><br><span class="line">        int ans=KM();</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-巨人也疯狂"><a href="#问题-G-巨人也疯狂" class="headerlink" title="问题 G: 巨人也疯狂"></a>问题 G: 巨人也疯狂</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1896" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1896&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1896&amp;getkey=53D9617A4C" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1896" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>人类发现巨人控制吃人的神经是由一些神经元和一些神经通道组成的，每个神经通道两端各有一个神经元，且这个通道是单向的。吃人信号从脑部神经元S发出到控制吃人的神经元T，S、T之间是一个有向无环图。人类想把某些神经通道切断达到S的信号无法传到T（由于神经元太小不容易砍掉，所以考虑神经元），每个神经通道由于位置不同也有砍断所需的力量。人类想知道如何花最小的力气而使S的信号传不到T。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>首行输入两个数，n，m，（n，m&lt;1000）。n代表包括s，t在内共有n个节点，1为s，n为t。</p><p>接下来m行，每行3个数，a，b，c，表示a到b的神经通路需要花费c力气。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出最小的力气。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">1 2 2</span><br><span class="line">1 3 2</span><br><span class="line">2 4 2</span><br><span class="line">2 5 2</span><br><span class="line">3 5 2</span><br><span class="line">4 6 2</span><br><span class="line">6 7 2</span><br><span class="line">5 7 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1896" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1896&amp;getkey=53D9617A4C" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1896" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>网络流最小割模板题。根据最小割最大流定理，求最小割问题即求最大流问题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=200+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int r[maxn][maxn]; //残留网络，初始化为原图</span><br><span class="line">bool visit[maxn];</span><br><span class="line">int pre[maxn];</span><br><span class="line">int m,n;</span><br><span class="line">bool bfs(int s,int t)  //寻找一条从s到t的增广路，若找到返回true</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    queue&lt;int &gt; q;</span><br><span class="line">    memset(pre,-1,sizeof(pre));</span><br><span class="line">    memset(visit,false,sizeof(visit));</span><br><span class="line"></span><br><span class="line">    pre[s]=s;</span><br><span class="line">    visit[s]=true;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(r[p][i]&gt;0&amp;&amp;!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=p;</span><br><span class="line">                visit[i]=true;</span><br><span class="line">                if(i==t) return true;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int EdmondsKarp(int s,int t)</span><br><span class="line">&#123;</span><br><span class="line">   int flow=0,d,i;</span><br><span class="line">   while(bfs(s,t))</span><br><span class="line">   &#123;</span><br><span class="line">       d=inf;</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">           d=d&lt;r[pre[i]][i]? d:r[pre[i]][i];</span><br><span class="line">       for(i=t;i!=s;i=pre[i])</span><br><span class="line">       &#123;</span><br><span class="line">           r[pre[i]][i]-=d;</span><br><span class="line">           r[i][pre[i]]+=d;</span><br><span class="line">       &#125;</span><br><span class="line">       flow+=d;</span><br><span class="line">   &#125;</span><br><span class="line">   return flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        memset(r,0,sizeof(r));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            r[u][v]+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-H-过河拆桥"><a href="#问题-H-过河拆桥" class="headerlink" title="问题 H: 过河拆桥"></a>问题 H: 过河拆桥</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1891" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1891&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1891&amp;getkey=EC9961F440" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1891" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>猴子是一种自私的动物。动物世界由河流分成了n个岛屿。这天，猴子在a1岛屿上望见an岛屿上有一片桃林。a1到an之间有n-2个岛屿，分别是a2——an-1。岛屿之间共有m坐桥，每座桥都有一定的距离。现在猴子通过这些桥从a1走到了an，然而由于猴子怕其他动物也过去享受那片桃林，于是每走一座桥都会拆一座桥。终于到了an，吃完桃子后，正直涨潮，于是他必须马上回到a1，由于之前走过的桥被拆了，所以只能寻找一条新的路回到a1。请问猴子从a1到an，再从an回到a1的最短路径是多少。</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>首行输入nm（n&lt;=1000m&lt;=10000）</p><p>接下来m行，每行三个数x，y，z，代表ax岛与ay岛之间有桥，距离是z。（z&lt;=35000）</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，为最短距离。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 3 1</span><br><span class="line">2 4 2</span><br><span class="line">1 2 1</span><br><span class="line">3 4 1</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1891" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1891&amp;getkey=EC9961F440" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1891" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>最小费用最大流问题。本题可以转化为从1到n找两条不重边的路，使得这两条路的距离之和加起来相对于其他方案来说最小。转化成功之后就是建模过程。首先以1为源点，n为汇点。边的长度就是每条边的费用，每条边的容量为1。由于我们要找两条路到达t，那么我们s点的流量就必须是2，这样流到t点的最大流最大为2，为1证明无解，为2即有解。然而由于源点流量一般无限大，那么我们只需再建立一个超级源点sss，和源点s相连，且容量为2，当然sss到s的费用为0。建完模之后我们就可以用最小费用最大流模板代码求解了。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,cap,cost ,rev;</span><br><span class="line">&#125;;</span><br><span class="line">int V;</span><br><span class="line">vector&lt;edge&gt;G[maxn];</span><br><span class="line">int dist[maxn];</span><br><span class="line">int prevv[maxn],preve[maxn];</span><br><span class="line">void add(int from,int to,int cap,int cost)</span><br><span class="line">&#123;</span><br><span class="line">    edge e,w;</span><br><span class="line">    e.to=to;</span><br><span class="line">    e.cap=cap;</span><br><span class="line">    e.cost=cost;</span><br><span class="line">    e.rev=G[to].size();</span><br><span class="line">    G[from].push_back(e);</span><br><span class="line">    w.to=from;</span><br><span class="line">    w.cap=0;</span><br><span class="line">    w.cost=-cost;</span><br><span class="line">    w.rev=G[from].size()-1;</span><br><span class="line">    G[to].push_back(w);</span><br><span class="line">&#125;</span><br><span class="line">int min_ans(int s,int t,int f)</span><br><span class="line">&#123;</span><br><span class="line">    int res=0;</span><br><span class="line"></span><br><span class="line">    while(f&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;V; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[s]=0;</span><br><span class="line">        bool update=true;</span><br><span class="line">        while(update)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            update=false;</span><br><span class="line">            for(int v=0; v&lt;V; v++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(dist[v]==inf)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int i=0; i&lt;G[v].size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    edge &amp;e=G[v][i];</span><br><span class="line">                    if(e.cap&gt;0&amp;&amp;dist[e.to]&gt;dist[v]+e.cost)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[e.to]=dist[v]+e.cost;</span><br><span class="line">                        prevv[e.to]=v;</span><br><span class="line">                        preve[e.to]=i;</span><br><span class="line">                        update=true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dist[t]==inf)</span><br><span class="line">            return -1;</span><br><span class="line">        int d=f;</span><br><span class="line">        for(int v=t; v!=s; v=prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d=min(d,G[prevv[v]][preve[v]].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f-=d;</span><br><span class="line">        res+=d*dist[t];</span><br><span class="line">        for(int v=t; v!=s; v=prevv[v])</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e =G[prevv[v]][preve[v]];</span><br><span class="line">            e.cap-=d;</span><br><span class="line">            G[v][e.rev].cap+=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int N,M;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    int a,b,c;</span><br><span class="line">    while(cin&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        V=N;</span><br><span class="line">        for(int i=0; i&lt;=N; i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        for(int i=0; i&lt;M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            a--;</span><br><span class="line">            b--;</span><br><span class="line">            add(a,b,1,c);</span><br><span class="line">            add(b,a,1,c);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,min_ans(0,N-1,2));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-I-植物大战僵尸"><a href="#问题-I-植物大战僵尸" class="headerlink" title="问题 I: 植物大战僵尸"></a>问题 I: 植物大战僵尸</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1889" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1889&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1889&amp;getkey=31996BAC1B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1889" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和Zombies（僵尸）是游戏的主角，其中Plants防守，而Zombies进攻。该款游戏包含多种不同的挑战系列，比如Protect Your Brain、Bowling等等。其中最为经典的，莫过于玩家通过控制Plants来防守Zombies的进攻，或者相反地由玩家通过控制Zombies对Plants发起进攻。</p><p>现在，我们将要考虑的问题是游戏中Zombies对Plants的进攻，请注意，本题中规则与实际游戏有所不同。游戏中有两种角色，Plants和Zombies，每个Plant有一个攻击位置集合，它可以对这些位置进行保护；而Zombie进攻植物的方式是走到植物所在的位置上并将其吃掉。</p><p>游戏的地图可以抽象为一个N行M列的矩阵，行从上到下用0到N–1编号，列从左到右用0到M–1编号；在地图的每个位置上都放有一个Plant，为简单起见，我们把位于第r行第c列的植物记为Pr c。</p><p>Plants分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个Plant，定义Score和Attack如下：</p><p>Score[Pr c]</p><p>Zombie击溃植物Pr c可获得的能源。若Score[Pr c]为非负整数，则表示击溃植物Pr c可获得能源Score[Pr c]，若为负数表示击溃Pr c需要付出能源 -Score[Pr c]。</p><p>Attack[Pr c]</p><p>植物Pr c能够对Zombie进行攻击的位置集合。</p><p>Zombies必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此Zombies的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻，Zombies必须首先攻击Pr M-1；若需要对Pr c（0≤c&lt;M-1）攻击，必须将PrM-1 Pr M-2 … Pr c+1先击溃，并移动到位置(r c)才可进行攻击。</p><p>在本题的设定中，Plants的攻击力是无穷大的，一旦Zombie进入某个Plant的攻击位置，该Zombie会被瞬间消灭，而该Zombie没有时间进行任何攻击操作。因此，即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。</p><p>Zombies的目标是对Plants的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套Zombies的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。</p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>输入的第一行包含两个整数N M，分别表示地图的行数和列数。</p><p>接下来N×M行描述每个位置上植物的信息。第r×M + c + 1行按照如下格式给出植物Pr c的信息：第一个整数为Score[Pr c] 第二个整数为集合Attack[Pr c]中的位置个数w，接下来w个位置信息（r’ c’），表示Pr c可以攻击位置第r’ 行第c’ 列。</p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>输出仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为0。</p><h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">10 0</span><br><span class="line">20 0</span><br><span class="line">-10 0</span><br><span class="line">-5 1 0 0</span><br><span class="line">100 1 2 1</span><br><span class="line">100 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1889" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1889&amp;getkey=31996BAC1B" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1889" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>最大权闭合图问题。最大权闭合图转化为最小割问题，再由最小割转化成最大流问题。课件上有详解。</p><p>（本题作为NOI的考试题，同时也是今天十道题中最难的一道题，是不是顿时感觉到了自己与高中生们的差距(ó﹏ò｡)ε=(´ο｀*)))唉）</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">#define M 1000</span><br><span class="line">using namespace std;</span><br><span class="line">int now,tot,s,t,va[M],du[M],H[M],h[M],ok[M],d[M],v[M],cur[M];</span><br><span class="line">int n,m;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">struct edge1</span><br><span class="line">&#123;</span><br><span class="line">int x,y,ne;</span><br><span class="line">&#125;e[500000];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">int from,to,cap,flow,ne;</span><br><span class="line">&#125;E[500000];</span><br><span class="line">int C(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">return (x-1)*m+y;</span><br><span class="line">&#125;</span><br><span class="line">void Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">e[++tot].y=y;</span><br><span class="line">e[tot].x=x;</span><br><span class="line">e[tot].ne=H[x];</span><br><span class="line">H[x]=tot;</span><br><span class="line">du[y]++;</span><br><span class="line">&#125;</span><br><span class="line">void Addedge(int from,int to,int cap)</span><br><span class="line">&#123;</span><br><span class="line">E[++tot]=(edge)&#123;from,to,cap,0,h[from]&#125;;</span><br><span class="line">h[from]=tot;</span><br><span class="line">E[++tot]=(edge)&#123;to,from,0,0,h[to]&#125;;</span><br><span class="line">h[to]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">for (int i=s;i&lt;=t;i++)</span><br><span class="line">v[i]=0;</span><br><span class="line">v[s]=1;</span><br><span class="line">d[s]=0;</span><br><span class="line">q.push(s);</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for (int i=h[x];i;i=E[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">edge e=E[i];</span><br><span class="line">if (!v[e.to]&amp;&amp;e.cap&gt;e.flow)</span><br><span class="line">&#123;</span><br><span class="line">v[e.to]=1;</span><br><span class="line">d[e.to]=d[x]+1;</span><br><span class="line">q.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return v[t];</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int x,int a)</span><br><span class="line">&#123;</span><br><span class="line">if (x==t||!a) return a;</span><br><span class="line">int flow=0;</span><br><span class="line">for (int &amp;i=cur[x];i;i=E[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e=E[i];</span><br><span class="line">if (d[e.to]!=d[x]+1) continue;</span><br><span class="line">int f=dfs(e.to,min(a,e.cap-e.flow));</span><br><span class="line">if (f)</span><br><span class="line">&#123;</span><br><span class="line">flow+=f;</span><br><span class="line">a-=f;</span><br><span class="line">e.flow+=f;</span><br><span class="line">E[i^1].flow-=f;</span><br><span class="line">if (!a) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()</span><br><span class="line">&#123;</span><br><span class="line">int flow=0;</span><br><span class="line">while (bfs())</span><br><span class="line">&#123;</span><br><span class="line">for (int i=s;i&lt;=t;i++)</span><br><span class="line">cur[i]=h[i];</span><br><span class="line">flow+=dfs(s,inf);</span><br><span class="line">&#125;</span><br><span class="line">return flow;</span><br><span class="line">&#125;</span><br><span class="line">void Topsort()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for (int i=1;i&lt;=now;i++)</span><br><span class="line">if (!du[i]) ok[i]=1,q.push(i);</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for (int i=H[x];i;i=e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">int y=e[i].y;</span><br><span class="line">du[y]--;</span><br><span class="line">if (!du[y])</span><br><span class="line">&#123;</span><br><span class="line">ok[y]=1;</span><br><span class="line">q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">for (int i=1;i&lt;=n;i++)</span><br><span class="line">for (int j=1;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">now++;</span><br><span class="line">int w;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;va[now],&amp;w);</span><br><span class="line">for (int k=1;k&lt;=w;k++)</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">x++,y++;</span><br><span class="line">Add(now,C(x,y));</span><br><span class="line">&#125;</span><br><span class="line">if (j!=m) Add(now+1,now);</span><br><span class="line">&#125;</span><br><span class="line">Topsort();</span><br><span class="line">s=0,t=now+1;</span><br><span class="line">int ans=0;</span><br><span class="line">tot=1;</span><br><span class="line">for (int x=1;x&lt;=now;x++)</span><br><span class="line">if (ok[x])</span><br><span class="line">&#123;</span><br><span class="line">if (va[x]&gt;0) ans+=va[x],Addedge(s,x,va[x]);</span><br><span class="line">else Addedge(x,t,-va[x]);</span><br><span class="line">for (int i=H[x];i;i=e[i].ne)</span><br><span class="line">&#123;</span><br><span class="line">int y=e[i].y;</span><br><span class="line">if (ok[y])</span><br><span class="line">Addedge(y,x,inf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans-dinic()&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-J-Pigs"><a href="#问题-J-Pigs" class="headerlink" title="问题 J: Pigs"></a>问题 J: Pigs</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=9&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1887" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1887&amp;cid=1024" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1887&amp;getkey=874A405F35" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1887" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>Mirko works on a pig farm that consists of M locked pig-houses and Mirko can’t unlock any pighouse because he doesn’t have the keys. Customers come to the farm one after another. Each of them has keys to some pig-houses and wants to buy a certain number of pigs.<br>All data concerning customers planning to visit the farm on that particular day are available to Mirko early in the morning so that he can make a sales-plan in order to maximize the number of pigs sold.<br>More precisely the procedure is as following: the customer arrives opens all pig-houses to which he has the key Mirko sells a certain number of pigs from all the unlocked pig-houses to him and if Mirko wants he can redistribute the remaining pigs across the unlocked pig-houses.<br>An unlimited number of pigs can be placed in every pig-house.<br>Write a program that will find the maximum number of pigs that he can sell on that day.</p><h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>The first line of input contains two integers M and N 1 &lt;= M &lt;= 1000 1 &lt;= N &lt;= 100 number of pighouses and number of customers. Pig houses are numbered from 1 to M and customers are numbered from 1 to N.<br>The next line contains M integeres for each pig-house initial number of pigs. The number of pigs in each pig-house is greater or equal to 0 and less or equal to 1000.<br>The next N lines contains records about the customers in the following form ( record about the i-th customer is written in the (i+2)-th line):<br>A K1 K2 … KA B It means that this customer has key to the pig-houses marked with the numbers K1 K2 … KA (sorted nondecreasingly ) and that he wants to buy B pigs. Numbers A and B can be equal to 0.</p><h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>The first and only line of the output should contain the number of sold pigs.</p><h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">3 1 10</span><br><span class="line">2 1 2 2</span><br><span class="line">2 1 3 3</span><br><span class="line">1 2 6</span><br></pre></td></tr></table></figure><h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><p>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1024&amp;pid=9&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1887" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1887&amp;getkey=874A405F35" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1887" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>课件上有建模讲解。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=107,M=1007,INF=0x3f3f3f3f;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    char c=getchar();int x=0,f=1;</span><br><span class="line">    while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-1; c=getchar();&#125;</span><br><span class="line">    while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;; c=getchar();&#125;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int m,n,s,t;</span><br><span class="line">int pig[M],now[M];</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int v,c,f,ne;</span><br><span class="line">&#125;e[N*M&lt;&lt;1];</span><br><span class="line">int cnt,h[N];</span><br><span class="line">inline void ins(int u,int v,int c)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v=v;e[cnt].c=c;e[cnt].f=0;e[cnt].ne=h[u];h[u]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].v=u;e[cnt].c=0;e[cnt].f=0;e[cnt].ne=h[v];h[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">int q[N],head,tail,vis[N],d[N];</span><br><span class="line">bool bfs()&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(d,0,sizeof(d));</span><br><span class="line">    head=tail=1;</span><br><span class="line">    d[s]=0;vis[s]=1;</span><br><span class="line">    q[tail++]=s;</span><br><span class="line">    while(head!=tail)&#123;</span><br><span class="line">        int u=q[head++];</span><br><span class="line">        for(int i=h[u];i;i=e[i].ne)&#123;</span><br><span class="line">            int v=e[i].v;</span><br><span class="line">            if(!vis[v]&amp;&amp;e[i].c&gt;e[i].f)&#123;</span><br><span class="line">                vis[v]=1;</span><br><span class="line">                d[v]=d[u]+1;</span><br><span class="line">                q[tail++]=v;</span><br><span class="line">                if(v==t) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int cur[N];</span><br><span class="line">int dfs(int u,int a)&#123;</span><br><span class="line">    if(u==t||a==0) return a;</span><br><span class="line">    int flow=0,f;</span><br><span class="line">    for(int &amp;i=cur[u];i;i=e[i].ne)&#123;</span><br><span class="line">        int v=e[i].v;</span><br><span class="line">        if(d[v]==d[u]+1&amp;&amp;(f=dfs(v,min(a,e[i].c-e[i].f)))&gt;0)&#123;</span><br><span class="line">            flow+=f;</span><br><span class="line">            e[i].f+=f;</span><br><span class="line">            e[((i-1)^1)+1].f-=f;</span><br><span class="line">            a-=f;</span><br><span class="line">            if(a==0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int flow=0;</span><br><span class="line">    while(bfs())&#123;</span><br><span class="line">        for(int i=s;i&lt;=t;i++) cur[i]=h[i];</span><br><span class="line">        flow+=dfs(s,INF);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    m=read();</span><br><span class="line">    n=read();</span><br><span class="line">    s=0;</span><br><span class="line">    t=n+1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    pig[i]=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int A=read(),B,x;</span><br><span class="line">        while(A--)&#123;</span><br><span class="line">            x=read();</span><br><span class="line">            if(!now[x]) ins(s,i,pig[x]),now[x]=i;</span><br><span class="line">            else ins(now[x],i,INF),now[x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        B=read();</span><br><span class="line">        ins(i,t,B);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,dinic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题-A-赛马&quot;&gt;&lt;a href=&quot;#问题-A-赛马&quot; class=&quot;headerlink&quot; title=&quot;问题 A: 赛马&quot;&gt;&lt;/a&gt;问题 A: 赛马&lt;/h1&gt;&lt;p&gt;时间限制: 1 Sec  内存限制: 128 MB&lt;br&gt;提交: 32  解决: 5&lt;br&gt;[&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="匹配" scheme="http://qianyouyou.cn/tags/%E5%8C%B9%E9%85%8D/"/>
    
      <category term="二分图" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="最小费用最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>进击的网络流</title>
    <link href="http://qianyouyou.cn/2018/08/22/2018-08-22/"/>
    <id>http://qianyouyou.cn/2018/08/22/2018-08-22/</id>
    <published>2018-08-22T12:38:54.000Z</published>
    <updated>2018-08-26T12:35:40.102Z</updated>
    
    <content type="html"><![CDATA[<p>内容：网络流</p><p>网络流：2018-8-23</p><p>课件：by.浅悠悠</p><p>主讲人：王骏</p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8725.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8726.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8727.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8728.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8729.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8730.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8731.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8732.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8733.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8734.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8735.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8736.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8737.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8738.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8739.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8740.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8741.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8742.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8743.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8744.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8745.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8746.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8747.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8748.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8749.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8750.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8751.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8752.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8753.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8754.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8755.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8756.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8757.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8758.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8759.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8760.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8761.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8762.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8763.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8764.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8765.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8766.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8767.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8768.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8769.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8770.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8771.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8772.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8773.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8774.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8775.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8776.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8777.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8778.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8779.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8780.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8781.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8782.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8783.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8784.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8785.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8786.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8787.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8788.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8789.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8790.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8791.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8792.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8793.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8794.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8795.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8796.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8797.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8798.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8799.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87100.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87101.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87102.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87103.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87104.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87105.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87106.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87107.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87108.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87109.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87110.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87111.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87112.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87113.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87114.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87115.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87116.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87117.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87118.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87119.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87120.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87121.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87122.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87123.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87124.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87125.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87126.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87127.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87128.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87129.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87130.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87131.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87132.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87133.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87134.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87135.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87136.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87137.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87138.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87139.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87140.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87141.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87142.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87143.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87144.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87145.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87146.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87147.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87148.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87149.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87150.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87151.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87152.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87153.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87154.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87155.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87156.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87157.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87158.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87159.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87160.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内容：网络流&lt;/p&gt;
&lt;p&gt;网络流：2018-8-23&lt;/p&gt;
&lt;p&gt;课件：by.浅悠悠&lt;/p&gt;
&lt;p&gt;主讲人：王骏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%871
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="预流推进" scheme="http://qianyouyou.cn/tags/%E9%A2%84%E6%B5%81%E6%8E%A8%E8%BF%9B/"/>
    
      <category term="最小割" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>图论3(网络流 + 二分图 + 匹配)</title>
    <link href="http://qianyouyou.cn/2018/08/19/2018-08-19/"/>
    <id>http://qianyouyou.cn/2018/08/19/2018-08-19/</id>
    <published>2018-08-19T12:38:54.000Z</published>
    <updated>2018-08-18T06:51:38.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>最大流问题的解决一般基于两种方法，即<strong>增广路算法</strong>与<strong>预流推进算法</strong>。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>一个连通的赋权有向图D=（V、E、C），其中V是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>网络上的流就是由起点流向终点的可行流</p><h3 id="正方向"><a href="#正方向" class="headerlink" title="正方向"></a>正方向</h3><p>设P为容量网络中源点到汇点的一条链，由源点s到汇点t的方向就为正方向。</p><h3 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h3><p>在一个图中，<strong>残留网络</strong>指在既有的容量和已具备的流量条件下，网络中仍然可以继续增大流量的边所组成的网络。</p><h3 id="增广路经"><a href="#增广路经" class="headerlink" title="增广路经"></a>增广路经</h3><p>在残留网络中的一条从源点s流向汇点t的路径叫做一条<strong>增广路。</strong></p><h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>图的<strong>割</strong>可以用来表示对图的一个划分，将原图 G=(V,E)的顶点集 V 分为 S、T 两部分，让源点 s 在 S 中，汇点 t 在 T 中，能够通过 S、T 间的最大净流量为割(S,T)的容量，<strong>最小割</strong>为图中具有最小容量的割。</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h3><p>利用不断寻找增广路并在其上对流量进行更新的方法寻找网络的最大流。</p><p>每次用BFS找一条最短的增广路径，然后沿着这条路径修改流量值（实际修改的是残量网络的边权）。当没有增广路时，算法停止，此时的流就是最大流。</p><h3 id="最大流最小割定理："><a href="#最大流最小割定理：" class="headerlink" title="最大流最小割定理："></a>最大流最小割定理：</h3><p>在网络的一个流量状态下，通过图的任意一个割的流量都与该流量相同，所以具有最小容量的割的的容量就是该图的流量的最大值即最大流。</p><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h2 id="有上下界的最大流"><a href="#有上下界的最大流" class="headerlink" title="有上下界的最大流"></a>有上下界的最大流</h2><h2 id="二分图网络流匹配"><a href="#二分图网络流匹配" class="headerlink" title="二分图网络流匹配"></a>二分图网络流匹配</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络流&quot;&gt;&lt;a href=&quot;#网络流&quot; class=&quot;headerlink&quot; title=&quot;网络流&quot;&gt;&lt;/a&gt;网络流&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="匹配" scheme="http://qianyouyou.cn/tags/%E5%8C%B9%E9%85%8D/"/>
    
      <category term="二分图" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="匈牙利算法" scheme="http://qianyouyou.cn/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="KM算法" scheme="http://qianyouyou.cn/tags/KM%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们一起学过的线性代数</title>
    <link href="http://qianyouyou.cn/2018/08/17/2018-08-17/"/>
    <id>http://qianyouyou.cn/2018/08/17/2018-08-17/</id>
    <published>2018-08-17T12:38:28.000Z</published>
    <updated>2018-08-17T12:42:54.750Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="矩阵论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
    
      <category term="高斯消元" scheme="http://qianyouyou.cn/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="矩阵论" scheme="http://qianyouyou.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="http://qianyouyou.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>组合数学1（排列组合 + 鸽巢原理 + 容斥原理）</title>
    <link href="http://qianyouyou.cn/2018/08/16/2018-08-16/"/>
    <id>http://qianyouyou.cn/2018/08/16/2018-08-16/</id>
    <published>2018-08-16T10:45:33.000Z</published>
    <updated>2018-08-17T12:05:03.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="加法-乘法法则"><a href="#加法-乘法法则" class="headerlink" title="加法/乘法法则"></a>加法/乘法法则</h2><h3 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h3><p>相互独立的事件 A、B 分别有 k 和 l 种方法产生，则产生 A 或 B 的方法数为 k+l 种。</p><h4 id="集合论定义"><a href="#集合论定义" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>若|A|=k，|B|=l ，且A∩B=Φ ，则|A∪B| = k+l 。</p><p>S = S1 ∪ S2 ∪ · · · ∪ Sm,    Si ∩ Sj = ∅ (i ≠ j)</p><p>⇒</p><p>|S| = |S1| + |S2| + · · · + |Sm|。</p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>a食堂有3种汉堡，b食堂有4种小吃，c食堂有2种包子，你的早餐只想吃一种，共有多少种选择方法？</p><p>解：</p><p>设S是所有食物的集合，Si是第i类食物的集合(i=1,2,3)，显然，Si∩Sj=Φ (i≠j) ，根据加法法则有：</p><p>|S| = |S1| + |S2| + |S3| = 3 + 4 + 2 = 9。</p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>大于0小于10的奇偶数有多少个？</p><p>解：</p><p>设S是符合条件数的集合，S1、S2分别是符合条件的奇数、偶数集合，显然，S1∩S2=Φ ，根据加法法则有：</p><p>|S| = |S1| + |S2| = 5 + 4 = 9。</p><h3 id="乘法法则"><a href="#乘法法则" class="headerlink" title="乘法法则"></a>乘法法则</h3><p>相互独立的事件 A、B 分别有 k 和 l 种方法产生，则选取A以后再选取B 的方法数为 k×l 种。</p><h4 id="集合论定义-1"><a href="#集合论定义-1" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>若|A|=k，|B|=l ，A×B={(a,b)|a∈A，b∈B}，则|A×B| = k×l 。</p><p>S = P × Q </p><p>⇒</p><p>|S| = |P | × |Q|。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>从A 地到B地有二条不同的道路，从B地到C地有四条不同的道路，而从C地到D地有三条不同的道路。求从A地经B、C两地到达D地的道路数。</p><p>解：</p><p>设S是所求的道路数集合，S1、S2、S3分别是从A到B、从B到C、从C到D的道路集合，根据乘法法则有</p><p>|S| = |S1 | × |S2| × |S3| = 2 × 4 × 3 = 24。</p><h3 id="计数问题的分类"><a href="#计数问题的分类" class="headerlink" title="计数问题的分类"></a>计数问题的分类</h3><p>有序安排或有序选择</p><p>​      ——允许重复/不允许重复</p><p>无序安排或无序选择</p><p>​      ——允许重复/不允许重复</p><h4 id="重集的概念"><a href="#重集的概念" class="headerlink" title="重集的概念"></a>重集的概念</h4><p>标准集的特性：确定、无序、相异等。</p><p>重集：B={k1 <em> b1, k2 </em> b2, …, kn * bn}，其中：bi为n个互不相同的元素，称 ki为bi的重数， i = 1, 2, …, n，n=1,2,…, ∞，ki = 1, 2, …, ∞。</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><h3 id="线排列"><a href="#线排列" class="headerlink" title="线排列"></a>线排列</h3><p>从n个不同元素中，取r个(0≤r≤n)按一定顺序排列起来，其排列数P(n,r)。</p><h4 id="集合论定义-2"><a href="#集合论定义-2" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>设A={an} ，从A中选择r个(0≤r≤n)元素排列起来，A的r−有序子集，A的r−排列。</p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>若n, r∈Z且n≥r≥0, P(n,r)=n!/(n-r)!。</p><p>若n=r，称全排列P(n,n)= n!；</p><p>若n＜r, P(n,r)=0；</p><p>若r=0, P(n,r)=1。</p><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>构造集合A的r−排列时，可以从A的n各元素中任选一个作为排列的第一项，有n种选法；第一项选定后从剩下的n-1个元素中选排列的第二项有n-1种选法；…由此类推，第r项有n-r+1种选法。根据乘法原理有：</p><p>P(n,r) = n(n-1)……(n-r+1) = n!/(n-r)! 。</p><h4 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h4><p>若n, r∈N且n≥r≥2，则P(n,r)=n×P(n-1,r-1) 。</p><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>在集合A的n个元素中，任一个元素都可以排在它的r−排列首位，故首位有n种取法；首位取定后，其他位置的元素正好是从A的另n-1个元素中取r-1个的排列，因此有P(n-1,r-1)种取法。由乘法法则有：</p><p>P(n,r)=n×P(n-1,r-1)</p><h4 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h4><p>若n, r∈N且n≥r≥2，则P(n,r)= r×P(n-1,r-1)+P(n-1,r) 。</p><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h5><p>当r≥2时，把集合A的r−排列分为两大类：一类包含A中的某个固定元素，不妨设为a1，另一类不包含a1 。第一类排列相当于先从A-{a1}中取r-1个元素进行排列，有P(n-1,r-1)种取法，再将a1放入每一个上述排列中，对任一排列，a1都有r种放法。由乘法法则，第一类排列共有r×P(n-1,r-1)个。第二类排列实质上是A-{a1}的r−排列，共有P(n-1,r)个。再由加法法则有：</p><p>P(n,r)= r×P(n-1,r-1)+P(n-1,r)</p><h4 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h4><p>由数字1,2,3,4,5可以构成多少个所有数字互不相同的四位数？</p><p>解：</p><p>由于所有的四位数字互不相同，故每一个四位数就是集合{1,2,3,4,5}的一个4−排列，因而所求的四位数个数为</p><p>P(5,4)=5!/(5-4)!=120。</p><h4 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h4><p>将具有9个字母的单词FRAGMENTS进行排列，要求字母A总是紧跟在字母R的右边，问有多少种这样的排法？如果再要求字母M和N必须相邻呢？</p><p>解：</p><p>由于A总是R的右边，故这样的排列相当于是8个元素的集合{F,RA,G,M,E,N,T,S}的一个全排列，个数为</p><p>P(8,8) = 8! = 40320。</p><p>如果再要求M和N必须相邻，可先把M和N看成一个整体={M,N}，进行7个元素的集合{F,RA,G,E,T,S,}的全排列，在每一个排列中再进行 {M,N}的全排列，由乘法法则，排列个数为</p><p>P(7,7) <em> P(2,2) = 7! </em> 2! = 10080。</p><h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>有多少个5位数，每位数字都不相同，不能取0，且数字7和9不能相邻？</p><p>解：</p><p>由于所有的5位数字互不相同，且不能取0，故每一个5位数就是集合{1,2,…,9}的一个5-排列，其排列数为P(9,5)，其中7和9相邻的排列数为[c(7,3)4!2]4×2×P(7,3)，满足题目要求的5位数个数为</p><p>P(9,5) - 4 <em> 2 </em> P(7,3) = 15120 -1680 = 13440</p><h3 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h3><p>设A={an} ，从A中取r个(0≤r≤n)元素按某种顺序（如逆时针）排成一个圆圈，称为圆排列（循环排列）。</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><p>设A={an}，A的r圆排列个数为P(n,r)/r。</p><h5 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h5><p>由于把一个圆排列旋转所得到另一个圆排列视为相同的圆排列，因此线排列a1a2…ar，a2a3…ara1，… ara1a2…ar-1在圆排列中是一个，即一个圆排列可产生r个不同的线排列；同理， r个不同的线排列对应一个圆排列。而总共有P(n,r)个线排列，故圆排列的个数为</p><p>​                              P(n,r)/r= n!/(r×(n-r)!)</p><h4 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h4><p>有8人围圆桌就餐，问有多少种就座方式？如果有两人不愿坐在一起，又有多少种就座方式？</p><p>解：</p><p>由上述定理知8人围圆桌就餐，有8!/8=7!=5040种就座方式。</p><p>又有两人不愿坐在一起，不妨设此二人为A、B，当A、B坐在一起时，相当于7人围圆桌就餐，有7!/7=6!种就座方式。 而A、B坐在一起时，又有两种情况，或者A在B的左面，或者A在B的右面，因此A、B坐在一起时，共有2×6!种就座方式，因此如果有两人不愿坐在一起，就座方式为</p><p>7!-2×6!= 5×6!=3600</p><h4 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h4><p>4男4女围圆桌交替就座有多少种就座方式？</p><p>解：</p><p>显然，这是一个圆排列问题。首先让4个男的围圆桌就座，有4!/4=3!种就座方式。 因为要求男女围圆桌交替就座，在男的坐定后，两两之间均需留有一个空位，女的就座相当于一个4元素集合的全排列，就座方式数为4!。由乘法法则知，就座方式数为</p><p>3!×4!=144</p><h3 id="重排列"><a href="#重排列" class="headerlink" title="重排列"></a>重排列</h3><p>从n个不同元素中，可重复选取r个按一定顺序排列起来，称为重排列。</p><h4 id="集合论定义-3"><a href="#集合论定义-3" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>从重集B={k1 <em> b1, k2 </em> b2, … , kn * bn}中选取r个按一定顺序排列起来。</p><h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>重集B={∞ <em> b1, ∞ </em> b2, … , ∞ * bn} 的r−排列的个数为nr。</p><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>构造B的r−排列如下：选择第一项时可从n个元素中任选一个，有n种选法，选择第二项时由于可以重复选取，仍有n种选法，…，同理，选择第r项时仍有n种选法，根据乘法法则，可得出r−排列的个数为nr。</p><h4 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h4><p>由数字1,2,3,4,5,6这六个数字能组成多少个五位数？又可组成多少大于34500的五位数？</p><p>解：</p><p>一个五位数的各位数字可重复出现，是一个典型的重排列问题，相当于重集B={∞ <em> 1,∞ </em> 2,…,∞*6}的5−排列，所求的五位数个数为6^5=7776。</p><p>大于34500的五位数可由下面三种情况组成：</p><p>万位选4,5,6中的一个，其余4位相当于重集B的4−排列，由乘法法则知，共有3×6^4个五位数；</p><p>万位是3，千位5,6中的一个，其余3位相当于重集B的3−排列，由乘法法则知，共有2×6^3个五位数；</p><p>万位是3，千位4中的一个，百位选5,6中的一个，其余2位相当于重集B的2−排列，由乘法法则知，共有2×6^2个五位数；</p><p>由加法法则知，大于34500的五位数个数为3×6^4 + 2×6^3 + 2×6^2=4392</p><h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>重集B={n1 <em> b1,n2 </em> b2,…,nk <em> bk}的全排列个数为n! / ( n1! </em> n2! <em> …… </em> nk! )，其中，n = n1 + n2 +…… +nk。</p><h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><p>将B中的ni个bi看作不同的ni个元素，赋予上标1,2,…, ni，即b(1,i),b(2,i)……,b(ni,i), i=1, 2,…… k，如此，重集B就变成具有n1+n2+…+nk=n个不同的元素集合A = {b(1,1),b(2,1)……,b(n1,1),b(1,2),b(2,2)……,b(n2,2),……b(1,k),b(2,k)……,b(nk,k,}</p><p>显然，集合A的全排列个数为n!。又由于ni个bi赋予上标的方法有ni!种，于是对重集B的任一个全排列，都可以产生集合A的n1!×n2!×…×nk!个排列（由乘法法则），故重集B的全排列个数为n! / ( n1! <em> n2! </em> …… * nk! )。</p><p>注：利用组合数的计数方法同样可以得出证明。</p><h4 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h4><p>有四面红旗，三面蓝旗，二面黄旗，五面绿旗可以组成多少种由14面旗子组成的一排彩旗？</p><p>解：</p><p>这是一个重排列问题，是求重集{4<em>红旗,3</em>蓝旗,2<em>黄旗,5</em>绿旗}的全排列个数，根据定理，一排彩旗的种数为</p><p>14! / ( 4! <em> 3! </em> 2! * 5! ) = 2522520。</p><h4 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h4><p>用字母A、B、C组成五个字母的符号，要求在每个符号里，A至多出现2次，B至多出现1次，C至多出现3次，求此类符号的个数。</p><p>解：</p><p>这也是一个重排列问题。根据分析，符合题意的符号个数相当于求重集M={2<em>A,1</em>B,3*C}的5−排列个数，可分为三种情况：需要分别求M-{A}、M-{B}和M-{C}的全排列个数。根据加法法则，此类符号个数为</p><p>5! / (1! <em> 1! </em> 3!) + 5! / (2! <em> 0! </em> 3!) + 5! / (2! <em> 1! </em> 2!) = 60</p><h3 id="项链排列"><a href="#项链排列" class="headerlink" title="项链排列"></a>项链排列</h3><p>对圆排列，通过转动、平移、翻转、可重合的，即可看作项链排列。</p><p>若n个不同元素的r−项链排列个数为P(n,r)/(2×r)，具体参照Pólya定理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排列组合&quot;&gt;&lt;a href=&quot;#排列组合&quot; class=&quot;headerlink&quot; title=&quot;排列组合&quot;&gt;&lt;/a&gt;排列组合&lt;/h1&gt;&lt;h2 id=&quot;加法-乘法法则&quot;&gt;&lt;a href=&quot;#加法-乘法法则&quot; class=&quot;headerlink&quot; title=&quot;加法/
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数论1(辗转相除法 + 欧拉筛 + 杜教筛 + 模运算 + 快速幂)</title>
    <link href="http://qianyouyou.cn/2018/08/15/2018-08-15/"/>
    <id>http://qianyouyou.cn/2018/08/15/2018-08-15/</id>
    <published>2018-08-15T15:29:57.000Z</published>
    <updated>2018-08-17T12:09:46.257Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论2（强连通 + 2-SAT + 欧拉图 + 着色问题）</title>
    <link href="http://qianyouyou.cn/2018/08/14/2018-08-14/"/>
    <id>http://qianyouyou.cn/2018/08/14/2018-08-14/</id>
    <published>2018-08-14T09:46:23.000Z</published>
    <updated>2018-08-18T03:56:46.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>所谓连通性，直观的讲，就是“连成一片”。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%9B%BE%E8%81%94%E9%80%9A%E5%88%A4%E6%96%AD.png" alt=""></p><p>我们发现，按照上面的划分方法，我们可以把G1分为三部分，因此，G1是不连通的，但是，这三个部分，我们把它们叫做图G1的三个连通分量。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>无向图G中，如果任意两顶点u和v，都能找到从一条u到v的路径。称无向图G是连通的。</p><p>当G为有向图时，若G中存在一条以 u为起点 v为终点的有向路P，则称从 u到 v是可达的。</p><p>如果G的任何两个顶点都是相互可达的 ，则称图G是强连通的；如果G的有向边被看作无向边时是连通的，则称有向图G是弱连通的 。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E8%BF%9E%E9%80%9A%E5%BC%BA%E5%BC%B1.png" alt=""></p><h4 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h4><p>所谓连通分量，指的是图中的极大连通子图。</p><p>有了连通分量的概念，我们可以对图的连通性换言之为：如果图G中只有唯一一个连通分量，那么G是连通的，我们称G为连通图。</p><h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="无向图连通性"><a href="#无向图连通性" class="headerlink" title="无向图连通性"></a>无向图连通性</h3><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先遍历或广度优先遍历，便可访问到图中所有顶点；对于非连通图，则需从多个顶点出发进行遍历，而每次从一个新的起点出发进行遍历得到的顶点访问序列恰好是一个连通分量中的顶点集。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>对无向图的连通性判定，一般我们采用搜索的方法，这里我们首先要提到应用非常广泛的深度优先搜索算法DFS，DFS在图论算法中有非常重要的地位。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>对下图( a ) 所示无向图进行深度优先遍历，需分别从顶点 v 1 和 v 5 出发调用两次 DFS（或 BFS），得到的顶点序列分别为： v 1 v 2 v 3 v 4 和 v 5 v 6 。这两个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图 G  的两个连通分量，如下图 ( b ) 所示。 </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>因此，要想判定一个无向图是否为连通图，或有几个连通分量，可以设置一个计数器 count ，初始时取值为 0 ，每调用一次遍历算法，就给 count 增 1 。这样，当整个遍历算法结束时，依据 count 的值，就可确定图的连通性了。算法用伪代码描述如下：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">无向图连通分支</span><br><span class="line">//无向图连通分支，dfs邻接阵形式，o（n^2）</span><br><span class="line">//返回分支数，id返回1..分支数的值</span><br><span class="line">//传入图的大小n和邻接阵mat，不相邻点边权0</span><br><span class="line">#define MAXN 100 </span><br><span class="line">void floodfill(int n,int mat[][MAXN],int* id,int now,int tag)&#123;</span><br><span class="line">int i; </span><br><span class="line">for (id[now]=tag,i=0;i&lt;n;i++) </span><br><span class="line">if (!id[i]&amp;&amp;mat[now][i]) </span><br><span class="line">floodfill(n,mat,id,i,tag); </span><br><span class="line">&#125;</span><br><span class="line">int find_components(int n,int mat[][MAXN],int* id)&#123; </span><br><span class="line">int count,i; </span><br><span class="line">for (i=0;i&lt;n;id[i++]=0); </span><br><span class="line">for (count=i=0;i&lt;n;i++) </span><br><span class="line">if (!id[i]) </span><br><span class="line">floodfill(n,mat,id,i,++count); </span><br><span class="line">return count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图连通性"><a href="#有向图连通性" class="headerlink" title="有向图连通性"></a>有向图连通性</h3><p>假设，我们把一张有向图的所有边看做无向的，然后对转化后的无向图进行一次DFS，是不是就可以判断无向图的连通性呢？显然可以。</p><p>对于采用邻接矩阵表示的有向图G=&lt;E，V&gt;，如果存在一条边e(u,v),那么在矩阵中e(u,v)&gt;0，我们令e(v,u)=e(u,v)，这样就可以将一条有向边变成无向边。</p><p>之后，对于这个转化后的矩阵进行一次DFS，这样既可以判断有向图是否连通。</p><p>需要注意的是，一般情况下，我们在题目中应用到得不是简单的有向图是否连通，而是：求有向图的强连通分量。</p><h4 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h4><p>有向图G的极大强连通子图称为G的强连通分量(SCC)。</p><p>下图中，子图{1,2,3,4}为一个强连通分量，因为顶点 1,2,3,4 两两可达。{5},{6}也分别是两个强连通分量。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt=""></p><p>直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为 O(N^2+M)。<br>更好的方法是 Kosaraju 算法或 和Tarjan 算法，两者的时间复杂度都是 O(N+M)。还有Gabow算法不介绍。</p><h4 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a>Kosaraju 算法</h4><p>Kosaraju算法的解释和实现都比较简单，为了找到强连通分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域。具体流程如图(1~4)。</p><p>上面我们提及原图G的逆图GT，其定义为GT=(V, ET)，ET={(u, v):(v, u)∈E}}。也就是说GT是由G中的边反向所组成的，通常也称之为图G的转置。在这里值得一提的是，逆图GT和原图G有着完全相同的连通分支，也就说，如果顶点s和t在G中是互达的，当且仅当s和t在GT中也是互达的。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-k%E7%AE%97%E6%B3%95.JPG" alt=""></p><p>在这里顺便提一下在调用dfs的过程中，几种添加顶点到集合的顺序。一共有四种顺序：</p><ul><li><p>Pre-Order，在递归调用dfs之前将当前顶点添加到queue中</p></li><li><p>Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中</p></li><li><p>Post-Order，在递归调用dfs之后将当前顶点添加到queue中</p></li><li>Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中</li></ul><p>最后一种的用途最广，至少目前看来是这样，比如步骤2-a以及拓扑排序中，都是利用的Reverse Post-Order来获取顶点集合。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p> (1)对G执行深度优先搜索，求出每个顶点的后序遍历顺序号postOrder。    </p><p>(2)反转有向图G中的边，构造一个新的有向图G*。</p><p>(3)由最高的postOrder编号开始，对G*执行深度优先搜索。如果深度优先搜索未达到所有顶点，由未访问的最高postOrder编号的顶点开始，继续深度优先搜索。    </p><p>(4)步骤三所产生的森林中的每一棵树，对应于一个强连通分支。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define maxN 1024</span><br><span class="line">int marked[maxN];//用于记录某个点是否被访问过，0为没有被临幸过，1为被临幸过</span><br><span class="line">int id[maxN];//记录每个点所属的连通分量</span><br><span class="line">int count;//记录连通分量总数目</span><br><span class="line">void kosaraju(graph *g)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    memset(marked,0,sizeof(marked));</span><br><span class="line">    memset(id,0,sizeof(id));</span><br><span class="line">    count=0;</span><br><span class="line">    for(i=0;i&lt;g-&gt;V;i++)&#123;//之所以这里用循环就是因为g指向的无向图可能不是一个连通图，而是由多个连同分量组成</span><br><span class="line">        if(!marked[i])&#123;dfs(g,i); count++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void dfs(graph *g,int v)&#123;</span><br><span class="line">    graphNode *t;</span><br><span class="line">    marked[v]=1;</span><br><span class="line">    id[v]=count;</span><br><span class="line">    t=g-&gt;adjlist[v].next;//t指向v的邻接点</span><br><span class="line">    while(t)&#123;</span><br><span class="line">        if(!marked[t-&gt;key])&#123;dfs(g,t-&gt;key);&#125;//这里是重点，就是你发现v到t-&gt;key有路径就把它算到跟自己在一个连通分量里了，这里有一个隐性前提，就是你提前知道t-&gt;key一定可以到v，所以你发现v可以到t-&gt;key的时候，你毫不犹豫把它算为跟自己一伙儿的了。Korasaju算法不同书上有不同的表述，区别是先遍历图g还是先遍历图g的逆向图，这只是顺序的区别。我把我看得版本完整说一下：（1）先DFS遍历图g的逆向图，记录遍历的逆后序。（什么叫逆后序？逆后序就是DFS时后序的逆序，注意逆后序不一定为DFS的前序。DFS前序为，访问某个顶点前，把它push进队列。DFS后序为访问完某个顶点后才把它push进队列。而DFS逆后序为访问完某个顶点后把它push进一个栈中。当DFS遍历完整个图后，后序队列的输出与逆后序栈的输出正好相反。）（2）然后按着图g逆向图的DFS遍历的逆后序序列遍历图g求所有的强连通分量，这一步的过程跟无向图求所有连通分量的算法一模一样！按着这里说的遍历顺序重复无向图求所有连通分量的步骤求出来的就是有向图的所有强连通分量，为什么呢？因为我们完成第一步后，按着第一步得到的逆后序要对有向图g进行DFS遍历的前一刻，前面这段过程就相当于我们完成了对这幅有向图g一个加工，把它加工成了一个无向图！也就是说，这个加工实现了我注释开头提到的那个隐性前提。所以后面按着无向图求所有连通分量的步骤求出来的就是有向图g的所有强连通分量。举个例子，比如有向图3-&gt;5-&gt;4-&gt;3，它的逆向图为3-&gt;4-&gt;5-&gt;3（你最好在纸上画下，就是个三角循环图），从逆向图的顶点3开始DFS，得到的逆后续为3，4,5 。按着这个顺序对原图进行DFS，DFS(3)时遇到5，则5肯定跟3在一个强连通分量中（为什么？因为我们逆向图DFS(5)时肯定能到达3，这就是隐形前提。所以正向图DFS(3)遇到5时，我们毫不犹豫把它算到自己一个强连通分量中。）</span><br><span class="line">        t=t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a>Tarjan 算法</h4><p>Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。定义 DFN(u)为节点 u 搜索的次序编号(时间戳)，Low(u)为 u 或 u 的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Low(u)=Min </span><br><span class="line">&#123; </span><br><span class="line"> DFN(u), </span><br><span class="line"> Low(v),(u,v)为树枝边，u为v的父节点</span><br><span class="line"> DFN(v),(u,v)为指向栈中节点的后向边(非横叉边) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 DFN(u)=Low(u)时，以 u 为根的搜索子树上所有节点是一个强连通分量。<br>算法伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u) </span><br><span class="line">&#123; </span><br><span class="line">DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值</span><br><span class="line">Stack.push(u) // 将节点u压入栈中</span><br><span class="line">for each (u, v) in E // 枚举每一条边</span><br><span class="line">if (v is not visted) // 如果节点v未被访问过</span><br><span class="line">tarjan(v) // 继续向下找</span><br><span class="line">Low[u] = min(Low[u], Low[v]) </span><br><span class="line">else if (v in S) // 如果节点v还在栈内</span><br><span class="line">Low[u] = min(Low[u], DFN[v]) </span><br><span class="line">if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根</span><br><span class="line"> repeat </span><br><span class="line">v = S.pop // 将v退栈，为该强连通分量中一个顶点</span><br><span class="line"> print v </span><br><span class="line">until (u== v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>从节点 1 开 始 DFS ，把遍历到的节点加入栈中。搜索到节点 u=6 时 ，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到 u=v 为止，{6}为一个强连通分量。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-a.png" alt=""></p><p>返回节点 5，发现 DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-b.png" alt=""></p><p>返回节点 3，继续搜索到节点 4，把 4 加入堆栈。发现节点 4 向节点 1 有后向边，节点 1 还在栈中，所以 LOW[4]=1。节点 6 已经出栈，(4,6)是横叉边，返回 3，(3,4)为树枝边，所以 LOW[3]=LOW[4]=1。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-c.png" alt=""></p><p>继续回到节点 1 ，最后访问节点 2 。访问边 (2,4) ， 4 还在栈中，所以LOW[2]=DFN[4]=5。返回 1 后，发现 DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-d.png" alt=""></p><p>至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。可以发现，运行 Tarjan 算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为 O(N+M)。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void tarjan(int i)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    DFN[i]=LOW[i]=++Dindex;</span><br><span class="line">    instack[i]=true;</span><br><span class="line">    Stap[++Stop]==i;</span><br><span class="line">    for (edge *e=V[i]; e; e=e-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        j=e-&gt;t;</span><br><span class="line">        if (!DFN[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);</span><br><span class="line">            if (LOW[j]&lt;LOW[i])</span><br><span class="line">                LOW[i]=LOW[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i]</span><br><span class="line">                )</span><br><span class="line">            LOW[i]=DFN[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if (DFN[i]==LOW[i])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            j=Stap[Stop--];</span><br><span class="line">            instack[j]=false;</span><br><span class="line">            Belong[j]=Bcnt;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j!=i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    Stop=Bcnt=Dindex=0;</span><br><span class="line">    memset(DFN,0,sizeof(DFN));</span><br><span class="line">    for (i=1; i&lt;=N; i++)</span><br><span class="line">        if (!DFN[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Gabow算法"><a href="#Gabow算法" class="headerlink" title="Gabow算法"></a>Gabow算法</h4><p>这个算法其实就是Tarjan算法的变异体，我们观察一下，只是它用第二个堆栈来辅助求出强连通分量的根，而不是Tarjan算法里面的dfn[]和backn[]数组。那么，我们说一下如何使用第二个堆栈来辅助求出强连通分量的根。 </p><p>我们使用类比方法，在Tarjan算法中，每次backn[i]的修改都是由于环的出现(不然，backn[i]的值不可能变小)，每次出现环，在这个环里面只剩下一个backnk[i]没有被改变(深度最低的那个)，或者全部被改变，因为那个深度最低的节点在另一个环内。那么Gabow算法中的第二堆栈变化就是删除构成环的节点，只剩深度最低的节点，或者全部删除，这个过程是通过出栈来实现，因为深度最低的那个顶点一定比前面的先访问，那么只要出栈一直到栈顶那个顶点的访问时间不大于深度最低的那个顶点。其中每个被弹出的节点属于同一个强连通分量。那有人会问：为什么弹出的都是同一个强连通分量？因为在这个节点访问之前，能够构成强连通分量的那些节点已经被弹出了，这个对Tarjan算法有了解的都应该清楚，那么Tarjan算法中的判断根我们用什么来代替呢？想想，其实就是看看第二个堆栈的顶元素是不是当前顶点就可以了。 </p><p>现在，你应该明白其实Tarjan算法和Gabow算法其实是同一个思想的不同实现，但是，Gabow算法更精妙，时间更少(不用频繁更新backn[])。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool map[100][100];//记录图形</span><br><span class="line">bool visited[100];//记录点是不是已经被访问过了</span><br><span class="line">bool del[100];//记录点是不是已经删除了</span><br><span class="line">int dfn[100];//记录点访问的次序</span><br><span class="line">stack&lt;int&gt;s1,s2;</span><br><span class="line">int dotn;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    int line;</span><br><span class="line">    cin&gt;&gt;dotn&gt;&gt;line;</span><br><span class="line">    for(int i=1;i&lt;=line;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        map[u][v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visited,0,sizeof(visited));</span><br><span class="line">    memset(del,0,sizeof(del));</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">    visited[u]=1;</span><br><span class="line">    dfn[u]=++time;</span><br><span class="line">    s1.push(u);</span><br><span class="line">    s2.push(u);</span><br><span class="line">    for(int i=1;i&lt;=dotn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(map[u][i])</span><br><span class="line">        &#123;</span><br><span class="line">            if(!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,time);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(!del[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    while(dfn[s2.top()]&gt;dfn[i])s2.pop();//注意这个地方</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(u==s2.top())</span><br><span class="line">    &#123;</span><br><span class="line">        while(u!=s1.top())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;s1.top()&lt;&lt;&quot;   &quot;;</span><br><span class="line">            del[s1.top()]=1;</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;u&lt;&lt;endl;</span><br><span class="line">        del[s1.top()]=1;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Gadow()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int i=1;i&lt;=dotn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(i,time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    Gadow();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>强连通分支问题的最大应用就在于两个字：缩点！</p><p>所谓缩点，就是把图中属于同一个强连通分支中的点缩为一个点，这样，我们就得到了一个新的有向图，而且图中不存在回路。</p><p>POJ 1236 - Network of Schools（最小点基）</p><h4 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h4><p>有向图缩点一个很大的应用，就是2-SAT问题(2判定性问题 )。</p><p>POJ 3678 - Katu Puzzle</p><p>POJ 3683 - Priest John’s Busiest Day</p><h1 id="2-SAT-1"><a href="#2-SAT-1" class="headerlink" title="2-SAT"></a>2-SAT</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 1:"></a>定义 1:</h2><p>布尔变量 x，假如逻辑运算“或”和“与”分别用“∨”和“∧ ”来表示，﹁x表示 x 的非，布尔表达式是用算术运算符号连接起来的变量所构成的代数表达式。给定每个变量 x 的一个值 p(x)，可以像计算代数表达式一样计算布表达式的值。如果存在一个真值分配，使得布尔表达式的取值为真，则这个布尔表达式称为可适定性的，简称 SAT。</p><p>例如（x1∨x2）∧(﹁x1∨﹁x2) 这个布尔表达式，如果 p(x1)=真，p(x2)=假，则表达式的值为真，则这个表达式是适定性的。不是所有的布尔表达式都是可适定的。</p><p>例如x1∧﹁x2∧(﹁x1∨x2)，则不管 p(x1),p(x2)取何值，表达式都不可能为真，因此这个布尔表达式是不可适定的。</p><p>适定性问题的一般形式 X=｛x1,x2..,xn｝为一个有限的布尔变量集，包含 x1,x2，..,xn的“或”和“与”，运算的 m 个句子 C1,C2,..,Cm,布尔表达式 C1∧C2∧,..,∧Cm 是否可适定。</p><p> 布尔表达式由用“与”连接起来的一些句子构成，则称这个表达式为“合取范式”。</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义 2:"></a>定义 2:</h2><p>对于给定的句子 C1,C2,..,Cm,如果 max{|Ci|}=k(1≦i≦m),则称此适定性问题为 k 适定性问题，简称 k-SAT。</p><p>当 k&gt;2 时，k-SAT 是 NP 完全的，所以我们一般讨论2-SAT问题。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>下面我们从一道例题来认识 2-SAT 问题，并提出对一类 2-SAT 问题通用的解法。<br>Poi 0106 Peaceful Commission [和平委员会] </p><p>某国有 n 个党派，每个党派在议会中恰有 2 个代表。现在要成立和平委员会 ，该会满足：</p><p>每个党派在和平委员会中有且只有一个代表<br>如果某两个代表不和，则他们不能都属于委员会<br>代表的编号从 1 到 2n，编号为 2a-1、2a 的代表属于第 a 个党派</p><p>输入 n（党派数），m（不友好对数）及 m 对两两不和的代表编号<br>其中 1≤n≤8000，0≤m ≤20000<br>求和平委员会是否能创立。<br>若能，求一种构成方式。 </p><p>例：</p><p>输入：</p><p>3 2</p><p>1 3</p><p>2 4</p><p>输出：</p><p>1</p><p>4</p><p>5</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>原题可描述为：</p><p>有 n 个组，第 i 个组里有两个节点 Ai, Ai’ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的 n 个点都能两两相容。（在这里把 Ai,Ai’ 的定义稍稍放宽一些，它们同时表示属于同一个组的两个节点。也就是说，如果我们描述 Ai，那么描述这个组的另一个节点就可以用 Ai’）</p><p>初步构图</p><p>如果 Ai 与 Aj 不相容，那么如果选择了 Ai，必须选择 Aj ‘ ；同样，如果选择了 Aj，就必须选择 Ai ’ 。</p><p>Ai → Aj<code>Aj → Ai</code></p><p>这样的两条边对称</p><p>我们从一个例子来看：</p><p>假设 4 个组，不和的代表为：1 和 4，2 和 3，7 和 3，那么构图：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-2-sat%E9%97%AE%E9%A2%981.png" alt=""></p><p>假设：</p><p>首先选 1<br>3 必须选，2 不可选<br>5、6 可以任选一个<br>8 必须选，4、7 不可选</p><p>矛盾的情况为：<br>存在 Ai，使得 Ai 既必须被选又不可选。<br>得到算法 1：<br>枚举每一对尚未确定的 Ai, Ai‘ ，任选 1 个，推导出相关的组，若不矛盾，则可选择；否则选选另 1 个，同样推导。若矛盾，问题必定无解。</p><p>此算法正确性简要说明：</p><p>由于 Ai,Ai’ 都是尚未确定的，它们不与之前的组相关联，前面的选择不会影响 Ai,Ai’ 。<br>算法的时间复杂度在最坏的情况下为 O(nm)。</p><p>在这个算法中，并没有很好的利用图中边的对称性<br>观察图（1）可以发现，1 和 3 构成一个环，这样 1 和 3 要么都被选中，要么都不选。2和 4 也同样如此。</p><p>在每个一个环里，任意一个点的选择代表将要选择此环里的每一个点。不妨把环收缩成一个子节点。新节点的选择表示选择这个节点所对应的环中的每一个节点。</p><p>对于原图中的每条边 Ai → Aj（设 Ai 属于环 Si，Aj 属于环 Sj）如果 Si≠Sj，则在新图中连边：</p><p>Si → Sj </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-2-sat%E9%97%AE%E9%A2%982.png" alt=""></p><p>这样构造的有向无环图和原图是等价的，这样我们就可以用之前介绍过的强连通分量的算法把图转化成有向无环图，在这个基础上，如果存在一对 Ai, Ai’属于同一个环，则判无解，否则将采用拓扑排序，以自底向上的顺序进行推导，一定能找到可行解。</p><p>下面给出 2-SAT 问题中常用的建边方式：</p><p>2-SAT 中元素关系常见有以下 11 种</p><p>A[x]</p><p>NOT A[x]</p><p>A[x] AND A[y]</p><p>A[x] AND NOT A[y]</p><p>A[x] OR A[y]</p><p>A[x] OR NOT A[y]</p><p>NOT (A[x] AND A[y]) </p><p>NOT (A[x] OR A[y]) </p><p>A[x] XOR A[y]</p><p>NOT (A[x] XOR A[y]) </p><p>A[x] XOR NOT A[y]</p><p>And 结果为 1：建边 ~x-&gt;y, ~y-&gt;x (两个数都为 1)<br>And 结果为 0：建边 y-&gt;~x , x-&gt;~y(两个数至少有一个为 0)<br>OR 结果为 1：建边 ~x-&gt;y ,  ~y-&gt;x(两个数至少有一个为 1)<br>OR 结果为 0：建边 x-&gt;~x , y-&gt;~y(两个数都为 0)<br>XOR 结果为 1：建边 x-&gt;~y , ~x-&gt;y , ~y-&gt;x , y -&gt; ~x (两个数一个为 0，一个为 1)<br>XOR 结果为 0：建边 x-&gt;y , ~x-&gt;~y , y-&gt;x ~y-&gt;~x(两个数同为 1 或者同为 0) </p><p>对于一般判定是不是有解的情况，我们可以直接采用 tarjan 算法求强联通，然后缩点，如果 x 与~x 染色相同，说明无解，否则有解。有的时候，可能需要用二分++tarjan 算法</p><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><p>每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。</p><p> <img src="http://p7woygi8q.bkt.clouddn.com/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF.gif" alt=""></p><p>答案是肯定的。 math 版上的 <a href="https://www.reddit.com/r/math/comments/3hz9u9/will_each_jellyfish_in_this_gif_eventually_end_up/cubw779" target="_blank" rel="noopener">OmnipotentEntity</a> 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。</p><p>熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。</p><h2 id="欧拉图（E问题）"><a href="#欧拉图（E问题）" class="headerlink" title="欧拉图（E问题）"></a>欧拉图（E问题）</h2><h3 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h3><p>欧拉回路问题是图论中最古老的问题之一。它诞生于十八世纪的欧洲古城哥尼斯堡。普瑞格尔河流经这座城市，人们在两岸以及河中间的两个小岛之间建了七座桥（如图1）。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%981.png" alt=""></p><p>于是产生了这样一个问题：是否可以找到一种方案，使得人们从自己家里出发，不重复地走遍每一座桥，然后回到家中？这个问题如果用数学语言来描述，就是在图2中找出一条回路，使得它不重复地经过每一条边。这便是著名的“哥尼斯堡七桥问题”。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%982.png" alt=""></p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><p>​        欧拉回路：图G=(V,E) (无向图or有向图) 的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。</p><p>​        欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。</p><p>​    欧拉图与半欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉通路而无欧拉回路的图称为半欧拉图。</p><p>​    桥：设无向图G=&lt;V,E&gt;，若存在边集E的一个非空子集E1，使得p(G-E1)&gt;p(G)，而对于E1的任意真子集E2，均有p(G-E2)=p(G)，则称E1是G的边割集，或简称割集；若E1是单元集，即E1={e}，则称e为割边或桥。[p(G)表示图G的连通分支数.]</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E6%AC%A7%E6%8B%89%E5%9B%BE.png" alt=""></p><p>图中，图（4）为欧拉图，图（3）为半欧拉图，图（1）（2）不是欧拉图。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a><strong>性质：</strong></h3><p>　　欧拉回路：一个欧拉回路，删掉一个点，仍然是一个欧拉回路。从一个欧拉回路拖走一个小欧拉回路，结果也是一个欧拉回路。</p><h3 id="判定（充要）："><a href="#判定（充要）：" class="headerlink" title="判定（充要）："></a><strong>判定（充要）：</strong></h3><p>　　欧拉回路：1:  图G是连通的，不能有孤立点存在。</p><p>　　　　　　　2:  对于无向图来说度数为奇数的点个数为0;对于有向图来说每个点的入度必须等于出度。</p><p>　　欧拉通路：1:  图G是连通的，无孤立点存在。</p><p>　　　　　　　2:  对于无向图来说，度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点。对于有向图来说，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。</p><h3 id="算法（求欧拉回路）："><a href="#算法（求欧拉回路）：" class="headerlink" title="算法（求欧拉回路）："></a><strong>算法（求欧拉回路）：</strong></h3><h4 id="Fleury算法"><a href="#Fleury算法" class="headerlink" title="Fleury算法:"></a><strong>Fleury算法:</strong></h4><p>设图G是一个无向欧拉图，则按照下面算法求欧拉回路:</p><p>1:任取G中一个顶点v0,令P0 = v0.</p><p>2:假设沿Pi = v0e1v1e2v2……eivi 走到了顶点 vi,按照下面方法从E(i) = E(G) -  {e1, e2, e3,…,ei} 中选e(i ＋　1),选择后删除e(i +１)这条边.</p><p>　　a):e(i+1)余vi关联</p><p>　　b):除非无别的边可选，否则e(i+1)不应是Gi = G – {e1,e2,…,ei} 中的桥.假若迫不得已选的是桥,除删除这条边之外,还应该再把孤立点从Gi中移除(选择桥边必然会形成孤立的点).</p><p>3:当步骤 2 无法继续执行时停止算法.</p><p>当算法停止时，所得到的简单回路 Pm = = v0e1v1e2v2e3v3……emvm  (vm = v0) 为图G的一条欧拉回路.</p><p><strong>下面用图来描述：</strong></p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093832441-1464795842.png" alt="img"></p><p>随便选择一个起点 v1。当前处在 v1 点，有两种走法 v1 – v9,v1 – v10，这俩条边都不是桥边，那么随便选择一个，&lt;v1, v10&gt;这条边吧。那么图就会成为这样.Eu = (走过的边集){&lt;v1, v10&gt;}</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833082-1968185223.png" alt="img"></p><p>当前到了 V10 点，有&lt;v10,v4&gt;,&lt;v10,v3&gt;,&lt;v10, v8&gt;，先看&lt;v10,v8&gt;这条边吧，如果选择了这条边那么图就会成为这样：</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833488-2076065400.png" alt="img"></p><p>很显然形成了两个图，上下两个图不连通，即&lt;v10, v8&gt;这条边就是所谓的桥边，算法中说除非别无他选，否则不应该选择桥边，那么这条边就不能选择。回到上面，由于&lt;v10,v4&gt;,&lt;v10,v3&gt;都不是桥边，所以随便选择&lt;v10,v4&gt;吧. Eu={&lt;v1, v10&gt;,&lt;v10,v4&gt;}</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833910-319654348.png" alt="img"></p><p>到了 v4 这个点，&lt;v4, v2&gt;这条边是桥边,但是别无选择，只好选择这条边.选择完这条边这时不仅要从原图中删除这条边，由于点4成为了孤点，所以这个点也该从原图删除。Eu={&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834410-492154878.png" alt="img"></p><p>同理到达 v2 只好选择&lt;v2,v3&gt;，删除孤点 v2和边. Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834941-273171314.png" alt="img"></p><p>别无他选，&lt;v3,v10&gt;。Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835473-1872025007.png" alt="img"></p><p>同样,选择&lt;v10, v8&gt;，Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835941-942659814.png" alt="img"></p><p>此时到了 v8 同第一次到达v10时的情况，不能选择&lt;v8,v9&gt;这条桥边,选择&lt;v8,v6&gt;,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836457-215788402.png" alt="img"></p><p>到达v6，选择&lt;v6,v7&gt;,删点删边,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;}.以下就不给图了(逃;</p><p>然后接下来的选择都是别无他选,依次选择&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;，最后得到的欧拉边集Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;,&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;},于是我们就得到了一条欧拉回路.</p><h5 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h5><p>这个算法在实现时也有很巧妙的方法。因为DFS本身就是一个入栈出栈的过程，所以我们直接利用DFS的性质来实现栈，其伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DFS(u):</span><br><span class="line">While (u存在未被删除的边e(u,v))</span><br><span class="line">删除边e(u,v)</span><br><span class="line">DFS(v)</span><br><span class="line">End</span><br><span class="line">PathSize ← PathSize + 1</span><br><span class="line">Path[ PathSize ] ← u</span><br></pre></td></tr></table></figure><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Graph &amp;G,SqStack &amp;S,int x,int t)</span><br><span class="line">&#123;</span><br><span class="line">       k=0;//一个标志,来标记当前访问的节点是否还有邻接边可供访问</span><br><span class="line">       Push(S,x); //将本次遍历边所经由的点入栈</span><br><span class="line">       for(i=t;i&lt;v;i++) //v是顶点数,e是边数</span><br><span class="line">        if(G[i][x]&gt;0)  </span><br><span class="line">         &#123;</span><br><span class="line">          k=1;</span><br><span class="line">          G[i][x]=0; G[x][i]=0; //此边已访问,删除此边</span><br><span class="line">          DFS(G,S,i,0);//寻找下一条关联的边,本次找到的是与x关联的i,在</span><br><span class="line">                        //下一层中将寻找与i关联的边</span><br><span class="line">          break;</span><br><span class="line">         &#125;//if,for</span><br><span class="line">          if(k==0)       //如果k=0,说明与当前顶点关联的边已穷尽</span><br><span class="line">       &#123;</span><br><span class="line">              Pop(S);</span><br><span class="line">              GetTop(S,m);</span><br><span class="line">              G[x][m]=1;G[m][x]=1;//恢复在上一层中被删除的边</span><br><span class="line">              a=x+1;//如果可能的话,从当前节点的下一条关联边开始搜寻</span><br><span class="line">              if(StackLength(S)!=e)//继续搜寻,边还没有全部遍历完</span><br><span class="line">              &#123;</span><br><span class="line">                     Pop(S); //还原到上一步去</span><br><span class="line">                     DFS(G,S,m,a);//</span><br><span class="line">              &#125;//if</span><br><span class="line">              else   //搜寻完毕,将最后节点也入栈</span><br><span class="line">                     Push(S,x);</span><br><span class="line">       &#125;//if</span><br><span class="line">&#125;//DFS</span><br><span class="line">void Euler(Graph &amp;G,int x)</span><br><span class="line">&#123;</span><br><span class="line">//G是存储图的邻接矩阵,都处理成无向图形式,值为1代表有边,0代表无边,不包括自回路,x是出发点</span><br><span class="line">InitStack(S);//用来存放遍历边时依次走过的顶点</span><br><span class="line">DFS(G,S,x,0);//深度优先遍历查找,0是指查询的起点</span><br><span class="line">//输出</span><br><span class="line"> while(!StackEmpty(S))</span><br><span class="line"> &#123;</span><br><span class="line">  GetTop(S,m);</span><br><span class="line">  printf(&quot;-&gt;v%d&quot;,m);</span><br><span class="line">  Pop(S);</span><br><span class="line"> &#125;//while</span><br><span class="line">&#125;//Euler</span><br></pre></td></tr></table></figure><p><strong>代码：</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1005;</span><br><span class="line">int n, m, flag, top, sum, du[N], ans[5005], map[N][N];</span><br><span class="line"></span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    ans[++top] = x;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(map[x][i] &gt;= 1)</span><br><span class="line">        &#123;</span><br><span class="line">            map[x][i]--;</span><br><span class="line">            map[i][x]--;</span><br><span class="line">            dfs(i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fleury(int x)</span><br><span class="line">&#123;</span><br><span class="line">    top = 1;</span><br><span class="line">    ans[top] = x;</span><br><span class="line">    while(top &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//判断是否可扩展</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[ans[top]][i] &gt;= 1)//若存在一条从ans[top]出发的边  那么就是可扩展</span><br><span class="line">            &#123;k = 1; break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k == 0)//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d &quot;, ans[top]);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(k == 1)//如可扩展， 则dfs可扩展的哪条路线</span><br><span class="line">        &#123;</span><br><span class="line">            top--;//这需要注意</span><br><span class="line">            dfs(ans[top+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(du, 0, sizeof(du));</span><br><span class="line">        memset(map, 0, sizeof(map));</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, y;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">            map[x][y]++; //记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边</span><br><span class="line">            map[y][x]++;</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = 1; // flag标记开始点。 如果所有点度数全为偶数那就从1开始搜</span><br><span class="line">        sum = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(du[i] % 2 == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                flag = i;// 若有奇数边， 从奇数边开始搜</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == 0 || sum == 2)</span><br><span class="line">            fleury(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本-套圈-法"><a href="#基本-套圈-法" class="headerlink" title="基本(套圈)法"></a><strong>基本(套圈)法</strong></h4><p>1.在图中任意找一个回路C；</p><p>2.将图中属于C的边删除；</p><p>3.在残留图的各个极大连通分量中求欧拉回路；</p><p>4.将各极大连通分量中的欧拉回路合并到C上。</p><h5 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h5><p>　　首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，所停止的点必然也是起点(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，然后停止时，走过的路径形成了一个圈，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。</p><p>　　总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。</p><p><strong>下面用图描述一遍：</strong></p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836879-1824078027.png" alt="img"></p><p>假设我们选择从v1开始走,由于随便走，所以可能出现以下走法</p><p>第一步：v1 – v9</p><p>第二步：v9 – v8</p><p>第三步：v8 – v10</p><p>第四步：v10 – v1</p><p>此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么</p><p>第五步: v10 – v3</p><p>第六步: v3 – v2</p><p>第七步: v2 – v4</p><p>第八步: v4 – v10</p><p>发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么</p><p>第九步：v8 – v6</p><p>第十步：v6 –v7</p><p>第十一步：v7– v8</p><p>又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。</p><p><strong>具体实现与分析:</strong></p><p>使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV = 100 + 7;</span><br><span class="line">const int MAXE = 100 * 100 + 7;</span><br><span class="line">int head[MAXV];</span><br><span class="line">int V, E;</span><br><span class="line"></span><br><span class="line">typedef struct EdgeNode</span><br><span class="line">&#123;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int next;   </span><br><span class="line">&#125;edgeNode;</span><br><span class="line">edgeNode Edges[MAXE];</span><br><span class="line"></span><br><span class="line">bool visit[2 * MAXE];</span><br><span class="line">stack&lt;int&gt; stv;</span><br><span class="line">queue&lt;int&gt; quv;//点集</span><br><span class="line">queue&lt;int&gt; que;//边集</span><br><span class="line"></span><br><span class="line">void EulerDFS(int now)</span><br><span class="line">&#123;</span><br><span class="line">    st.push(now);//每访问一个点，就把该点压入栈</span><br><span class="line">    for(int k = head[now]; k != -1; k = Edges[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visit[k])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[k] = true;            //有向图每条边保存了两次，也要标记两次</span><br><span class="line">            if(k &amp; 1)</span><br><span class="line">                visit[k + 1] = true;</span><br><span class="line">            else</span><br><span class="line">                visit[k - 1] = true;</span><br><span class="line">            EulerDFS(Edges[k].to);</span><br><span class="line">            que.push(k);//回溯时记录边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quv.push(stv.top());//记录点</span><br><span class="line">    stv.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;V, &amp;E);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    for(int i = 1; i &lt;= E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        Edges[2 * i - 1].to = v;                //双向储存边</span><br><span class="line">        Edges[2 * i - 1].w = w;</span><br><span class="line">        Edges[2 * i - 1].next = head[u];</span><br><span class="line">        head[u] = 2 * i - 1;</span><br><span class="line">        Edges[2 * i].to = u;</span><br><span class="line">        Edges[2 * i].w = w;</span><br><span class="line">        Edges[2 * i].next = head[v];</span><br><span class="line">        head[v] = 2 * i;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visit, false, sizeof(visit));</span><br><span class="line">    EulerDFS(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E4%BE%8B%E9%A2%981b.png" alt=""></p><p>有N个盘子，每个盘子上写着一个仅由小写字母组成的英文单词。你需要给这些盘子按照合适的顺序排成一行，使得相邻两个盘子中，前一个盘子上面单词的末字母等于后一个盘子上面单词的首字母。请你编写一个程序，判断是否能达到这一要求。如果能，请给出一个合适的顺序。</p><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>以26个英文字母作为顶点。对于每一个单词，在图中从它的首字母向末字母连一条有向边。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E4%BE%8B%E9%A2%981c.png" alt=""></p><p>问题转化为在图中寻找一条不重复地经过所有边的路径，即欧拉路径。这个问题能够在O(|E|)时间内解决。</p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><strong>PKU 2337</strong></p><p>问题描述</p><p>给出一些字符串，让你首尾串起来串成一串，并且输出一个字典序最小的方案。如果不能，输出“**”。否则输出字典序最小的回路。</p><p><strong><em>输入</em></strong></p><p>2</p><p>6</p><p>aloha</p><p>arachnid</p><p>dog</p><p>gopher</p><p>rat</p><p>tiger</p><p>3</p><p>oak</p><p>maple</p><p>elm</p><p><strong>输出</strong></p><p>aloha.arachnid.dog.gopher.rat.tiger</p><p>**</p><p><strong>分析</strong></p><p>在没有特殊要求的情况下，DFS遍历图的结点顺序是可以任选的。但是这里由于加上了字典序最小的要求，所以DFS遍历时需要按照以下的优先顺序：</p><p>如果有不是桥的边，遍历这些边中字典序最小的边。</p><p>否则，遍历这些这些桥中字典序最小的边。</p><p>比如一个单词，abcde，那么就连接一条a到e的有向边。如此构成的图一共最多有26个节点。每条边都代表一个单词，那么就转化成了：找一条路，遍历所有的边。就是欧拉通路问题。</p><p>遍历欧拉通路的方法：</p><p>确定一个起点（出度-入度=1，或者等于0（如果存在欧拉回路的话））</p><p>从起点开始深搜（首先要保证图中存在欧拉回路或者通路）</p><p>dfs(vid, eid)</p><p>其中vid表示当前搜到的点。eid表示当前搜到的边（一个点可能会有很多边）</p><p>对于每条边，都是等它搜索完了后，把它代表的内容（这里是单词）压入一个栈中。</p><p>最后深搜结束后，依次弹栈就是答案。</p><h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p><strong>DOOR MAN</strong></p><p>大意：给定N(&lt;=20)个房间,房间之间有门相隔，门的数目不超过100道，当前人在第M个房门，当前人每经过一道门的时候就把经过的门锁上，问有没有一条路可以使得我们走到第0个房门的时候所有的门都锁上了。 思路：我们可以把门看成是两个房间之间的边，那么问题可以转化成找一条欧拉路径。PS：判断的时候只要判断所有的边在一起就行了，所有的点不一定连通，当0点和M点不连通的时候，无解。注意这组数据。</p><h3 id="中国邮递员问题-CPP"><a href="#中国邮递员问题-CPP" class="headerlink" title="中国邮递员问题(CPP)"></a>中国邮递员问题(CPP)</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一个邮递员从邮局出发，要走完他所管辖范围内的每一条街道，至少一次再返回邮局，如何选择一条尽可能短的路线？这就是中国邮递员问题（CPP），其命名是因为中国数学家管梅谷在1962年首先提出了这个问题。如果用顶点表示交叉路口，用边表示街道，那么邮递员所管辖的范围可用一个赋权图来表示，其中边的权重表示对应街道的长度。 </p><h4 id="图论语言"><a href="#图论语言" class="headerlink" title="图论语言"></a>图论语言</h4><p>中国邮递员问题可用图论语言叙述为：在一个具有非负权的赋权连通图G中，找出一条权最小的环游。这种环游称为最优环游。若G是欧拉图，则G的任意欧拉环游都是最优环游，从而可利用弗勒里算法求解。若G不是欧拉图，则G的任意一个环游必定通过某些边不止一次。将边e的两个端点再用一条权为w(e)的新边连接时，称边e为重复的。此时CPP与下述问题等价，若G是给定的有非赋权的赋权连通图，</p><p>（1）用添加重复边的方法求G的一个欧拉赋权母图 <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D17/sign=f1b420a3edcd7b89ed6c3e840e244643/7acb0a46f21fbe094ed0e37d60600c338644adc8.jpg" alt="img"> ，使得  <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D76/sign=9ab06f680155b31998f9807342a9af83/2934349b033b5bb5fc9903973dd3d539b600bc08.jpg" alt="img"> 尽可能小； </p><p>（2）求  <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D17/sign=f1b420a3edcd7b89ed6c3e840e244643/7acb0a46f21fbe094ed0e37d60600c338644adc8.jpg" alt="img"> 的欧拉环游。 </p><p>此图图论中和中国邮递员问题类似的是旅行商问题，区别于中国邮递员问题，旅行商问题是说在边赋权的完全图中找一个权和最小的哈密尔顿圈。</p><p>埃德蒙兹（J.Edmonds）和约翰逊（E.L.Johnson)在1973年给出了求解（1）的多项式时间算法。</p><p>如果邮递员所通过的街道都是单向道，则对应的图应为有向图。1973年，埃德蒙兹和约翰逊证明此时CPP也有多项式时间算法。帕帕季米特里屋（C.H.Papadimitrious）在1976年证明，如果既有双向道，又有单向道，则CPP是NP困难的。</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>由于每边至少遍历一次，所以最短路的瓶颈就在于重复遍历。由于图一直保持连通性，所以两两奇点之间都存在欧拉路；又两两奇点之间的最短路可求；奇点个数为偶数。所以问题就等价于找一个奇点构成的完全图G’(V,E)的最小权匹配(Perfect Matching in General Graph)。V(G’)为原图G中的奇点，每条边为两奇点对应原图的最短路长度。</p><h4 id="奇偶点图作业法"><a href="#奇偶点图作业法" class="headerlink" title="奇偶点图作业法"></a>奇偶点图作业法</h4><ol><li><p>确定G中的奇点，构成G’。</p></li><li><p>确定G’两两结点在G中的最短路作为它们在G’中的边权。</p></li><li><p>对G’进行最小权匹配。</p></li><li><p>最小权匹配里的各匹配边所对应的路径在G中被重复遍历一次,得到欧拉图G’’。</p></li><li><p>对G’’找一条欧拉路即可。</p></li></ol><p>有向的中国邮路问题，比较复杂。</p><h2 id="哈密顿图（H问题）"><a href="#哈密顿图（H问题）" class="headerlink" title="哈密顿图（H问题）"></a>哈密顿图（H问题）</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9C%88.png" alt=""></p><p>1857年，英国数学家汉密尔顿(Hamilton)提出了著名的汉密尔顿回路问题，其后，该问题进一步被发展成为所谓的“货郎担问题”，即赋权汉密尔顿回路最小化问题：这两个问题成为数学史上著名的难题。 </p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>汉密尔顿路：</strong>给定图G，若存在一条路，经过图中每个结点恰好一次，这条路称作汉密尔顿路。  </p><p><strong>汉密尔顿回路：</strong>给定图G，若存在一条回路，经过图中每个结点恰好一次，这条回路称作汉密尔顿回路。  </p><p><strong>汉密尔顿图：</strong>具有汉密尔顿回路的图，称作汉密尔顿图。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>必须说明，汉密尔顿回路问题是一个NP完全问题(NP-Complete)，也就是说，至今没有一个行之有效的多项式时间的算法能够找到这类问题的最优解，只有一些近似算法。关于NPC问题，我们这里不做讨论。我们一般情况下，直接用DFS进行搜索，当然，如果图的点比较多的时候(一般n&gt;10)，这个算法是不现实的。</p><h3 id="旅行商问题-TSP"><a href="#旅行商问题-TSP" class="headerlink" title="旅行商问题(TSP)"></a>旅行商问题(TSP)</h3><p><a href="https://baike.baidu.com/pic/%E4%B8%AD%E5%9B%BD%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98/11055168/0/d31b0ef41bd5ad6ea2c41f7288cb39dbb6fd3c6c?fr=lemma&amp;ct=single" target="_blank" rel="noopener"><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=ed589fa1bade9c82a265fe8d5c8080d2/d31b0ef41bd5ad6ea2c41f7288cb39dbb6fd3c6c.jpg" alt="img"></a></p><p>Traveling Salesman Problem，即旅行商问题， 旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值，这是一个NP难问题。 </p><p>TSP的历史很久，最早的描述是1759年欧拉研究的骑士周游问题，即对于国际象棋棋盘中的64个方格，走访64个方格一次且仅一次，并且最终返回到起始点。</p><p>TSP由美国RAND公司于1948年引入，该公司的声誉以及线形规划]这一新方法的出现使得TSP成为一个知名且流行的问题。</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>状压DP</p><h1 id="着色问题"><a href="#着色问题" class="headerlink" title="着色问题"></a>着色问题</h1><p>图的着色问题是由地图的着色问题引申而来的：用m种颜色为地图着色，使得地图上的每一个区域着一种颜色，且相邻区域颜色不同。问题处理：如果把每一个区域收缩为一个顶点，把相邻两个区域用一条边相连接，就可以把一个区域图抽象为一个平面图。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%9C%B0%E5%9B%BE%E9%97%AE%E9%A2%98.png" alt=""></p><p>通常所说的着色问题是指下述两类问题：</p><p>1．给定无环图G=(V,E)，用m种颜色为图中的每条边着色，要求每条边着一种颜色，并使相邻两条边有着不同的颜色，这个问题称为图的边着色问题。</p><p>2．给定无向图G=(V,E)，用m种颜色为图中的每个顶点着色，要求每个顶点着一种颜色，并使相邻两顶点之间有着不同的颜色，这个问题称为图的顶着色问题。</p><h2 id="边着色问题"><a href="#边着色问题" class="headerlink" title="边着色问题"></a>边着色问题</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>给图G的边着色，使得有共同顶点的边异色的最少颜色数，称为边色数。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E8%BE%B9%E7%9D%80%E8%89%B2%E5%9B%BE.png" alt=""></p><h4 id="妖怪图（snark-graph）"><a href="#妖怪图（snark-graph）" class="headerlink" title="妖怪图（snark graph）"></a>妖怪图（snark graph）</h4><p>妖怪图每个点都关联着3条边，用4种颜色可以把每条边涂上颜色，使得有公共端点的边异色，而用3种颜色办不到，切断任意3条边不会使它断裂成2个有边的图。</p><p><strong>单星妖怪和双星妖怪：</strong></p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%A6%96%E6%80%AA%E5%9B%BE.png" alt=""></p><h4 id="时间表问题；"><a href="#时间表问题；" class="headerlink" title="时间表问题；"></a>时间表问题；</h4><p>设x1,x2,…,xm为m个工作人员，y1,y2,…,yn表为n种设备，工作人员对设备提出要求，使用时间均假定以单位时间计算，自然每一个工作人员在同一个时间只能使用一种设备，某一种设备在同一时间里只能为一个工作人员使用，问应如何合理安排，使得尽可能短时间里满足工作人员的要求？       </p><p>问题转换为X={x1,x2,…,xm}，Y={y1,y2,…,yn}的二分图G，工作人员xi要求使用设备yj，每单位时间对应一条从xi到yj的边，这样所得的二分图过xi ，yj的边可能不止一条。问题变为对所得二分图G的边着色问题。有相同颜色的边可以安排在同一时间里。</p><h3 id="定理："><a href="#定理：" class="headerlink" title="定理："></a>定理：</h3><p>二分图G的边色数＝图中顶点的最大度。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E4%BA%8C%E5%88%86%E5%9B%BE%E8%BE%B9%E8%89%B2.png" alt=""></p><h4 id="定理-Vizing-1964-："><a href="#定理-Vizing-1964-：" class="headerlink" title="定理(Vizing 1964)："></a>定理(Vizing 1964)：</h4><p>若图G为简单图，图中顶点最大度为d，则G的边色数为d或d+1。</p><p><strong><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%B1%BB%E5%9B%BE.png" alt=""></strong></p><p>目前仍无有效区分(判别)任给定图属第几类图的有效方法。</p><h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>边的着色问题可以转化为顶点的着色问题。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E8%BE%B9%E7%82%B9%E7%9D%80%E8%89%B2.png" alt=""></p><h2 id="点着色问题"><a href="#点着色问题" class="headerlink" title="点着色问题"></a>点着色问题</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>给图G的顶点着色，使得相邻的顶点异色的最少颜色数，称为图G顶色数，简称色数；记作χ(G)。</p><h3 id="四色猜想："><a href="#四色猜想：" class="headerlink" title="四色猜想："></a>四色猜想：</h3><p>平面图的色数不大于5。</p><h3 id="色数的性质："><a href="#色数的性质：" class="headerlink" title="色数的性质："></a>色数的性质：</h3><p>（1）图G只有孤立点时，χ(G)=1；</p><p>（2）n个顶点的完全图G有χ(G)=n；</p><p>（3）若图G是n个顶点的回路，则χ(G)=2，        n为偶数。χ(G) =3，        n为奇数；</p><p>（4）图G是顶点数超过1的树时，χ(G)=2；</p><p>（5）若图G是二分图，则χ(G)=2。</p><h3 id="定理：-1"><a href="#定理：-1" class="headerlink" title="定理："></a>定理：</h3><p>图G=(V,E)的色数χ(G)=2的充要条件是：(1)|E|≥1；(2)G不存在边数为奇数的回路。</p><p>若图G=(V,E)，d=max{d(vi)},vi∈V，则χ(G)≤d+1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的连通性&quot;&gt;&lt;a href=&quot;#图的连通性&quot; class=&quot;headerlink&quot; title=&quot;图的连通性&quot;&gt;&lt;/a&gt;图的连通性&lt;/h1&gt;&lt;h2 id=&quot;连通图&quot;&gt;&lt;a href=&quot;#连通图&quot; class=&quot;headerlink&quot; title=&quot;连通图&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="欧拉图" scheme="http://qianyouyou.cn/tags/%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    
      <category term="哈密顿图" scheme="http://qianyouyou.cn/tags/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE/"/>
    
      <category term="连通图" scheme="http://qianyouyou.cn/tags/%E8%BF%9E%E9%80%9A%E5%9B%BE/"/>
    
      <category term="着色问题" scheme="http://qianyouyou.cn/tags/%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
