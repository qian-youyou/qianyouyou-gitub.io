<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-08-20T18:53:23.809Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进击的网络流</title>
    <link href="http://qianyouyou.cn/2018/08/22/2018-08-22/"/>
    <id>http://qianyouyou.cn/2018/08/22/2018-08-22/</id>
    <published>2018-08-22T12:38:54.000Z</published>
    <updated>2018-08-20T18:53:23.809Z</updated>
    
    <content type="html"><![CDATA[<p>网络流：2018.8.23</p><p>课件：by.浅悠悠</p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%871.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%872.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%873.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%874.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%875.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%879.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8713.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8714.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8715.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8716.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8717.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8718.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8719.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8720.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8721.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8722.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8723.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8724.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8725.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8726.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8727.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8728.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8729.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8730.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8731.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8732.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8733.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8734.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8735.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8736.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8737.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8738.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8739.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8740.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8741.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8742.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8743.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8744.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8745.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8746.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8747.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8748.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8749.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8750.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8751.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8752.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8753.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8754.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8755.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8756.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8757.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8758.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8759.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8760.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8761.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8762.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8763.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8764.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8765.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8766.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8767.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8768.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8769.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8770.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8771.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8772.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8773.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8774.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8775.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8776.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8777.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8778.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8779.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8780.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8781.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8782.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8783.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8784.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8785.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8786.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8787.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8788.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8789.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8790.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8791.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8792.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8793.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8794.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8795.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8796.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8797.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8798.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%8799.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87100.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87101.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87102.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87103.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87104.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87105.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87106.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87107.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87108.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87109.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87110.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87111.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87112.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87113.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87114.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87115.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87116.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87117.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87118.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87119.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87120.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87121.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87122.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87123.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87124.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87125.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87126.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87127.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87128.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87129.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87130.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87131.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87132.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87133.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87134.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87135.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87136.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87137.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87138.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87139.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87140.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87141.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87142.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87143.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87144.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87145.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87146.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87147.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87148.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87149.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87150.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87151.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87152.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87153.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87154.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87155.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87156.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87157.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87158.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87159.jpg" alt=""></p><p><img src="http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%87160.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网络流：2018.8.23&lt;/p&gt;
&lt;p&gt;课件：by.浅悠悠&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pdru087qr.bkt.clouddn.com/%E5%B9%BB%E7%81%AF%E7%89%871.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="预流推进" scheme="http://qianyouyou.cn/tags/%E9%A2%84%E6%B5%81%E6%8E%A8%E8%BF%9B/"/>
    
      <category term="最小割" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>图论3(网络流 + 二分图 + 匹配)</title>
    <link href="http://qianyouyou.cn/2018/08/19/2018-08-19/"/>
    <id>http://qianyouyou.cn/2018/08/19/2018-08-19/</id>
    <published>2018-08-19T12:38:54.000Z</published>
    <updated>2018-08-18T06:51:38.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>最大流问题的解决一般基于两种方法，即<strong>增广路算法</strong>与<strong>预流推进算法</strong>。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>一个连通的赋权有向图D=（V、E、C），其中V是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>网络上的流就是由起点流向终点的可行流</p><h3 id="正方向"><a href="#正方向" class="headerlink" title="正方向"></a>正方向</h3><p>设P为容量网络中源点到汇点的一条链，由源点s到汇点t的方向就为正方向。</p><h3 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h3><p>在一个图中，<strong>残留网络</strong>指在既有的容量和已具备的流量条件下，网络中仍然可以继续增大流量的边所组成的网络。</p><h3 id="增广路经"><a href="#增广路经" class="headerlink" title="增广路经"></a>增广路经</h3><p>在残留网络中的一条从源点s流向汇点t的路径叫做一条<strong>增广路。</strong></p><h3 id="割"><a href="#割" class="headerlink" title="割"></a>割</h3><p>图的<strong>割</strong>可以用来表示对图的一个划分，将原图 G=(V,E)的顶点集 V 分为 S、T 两部分，让源点 s 在 S 中，汇点 t 在 T 中，能够通过 S、T 间的最大净流量为割(S,T)的容量，<strong>最小割</strong>为图中具有最小容量的割。</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h3><p>利用不断寻找增广路并在其上对流量进行更新的方法寻找网络的最大流。</p><p>每次用BFS找一条最短的增广路径，然后沿着这条路径修改流量值（实际修改的是残量网络的边权）。当没有增广路时，算法停止，此时的流就是最大流。</p><h3 id="最大流最小割定理："><a href="#最大流最小割定理：" class="headerlink" title="最大流最小割定理："></a>最大流最小割定理：</h3><p>在网络的一个流量状态下，通过图的任意一个割的流量都与该流量相同，所以具有最小容量的割的的容量就是该图的流量的最大值即最大流。</p><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h2 id="有上下界的最大流"><a href="#有上下界的最大流" class="headerlink" title="有上下界的最大流"></a>有上下界的最大流</h2><h2 id="二分图网络流匹配"><a href="#二分图网络流匹配" class="headerlink" title="二分图网络流匹配"></a>二分图网络流匹配</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络流&quot;&gt;&lt;a href=&quot;#网络流&quot; class=&quot;headerlink&quot; title=&quot;网络流&quot;&gt;&lt;/a&gt;网络流&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="匹配" scheme="http://qianyouyou.cn/tags/%E5%8C%B9%E9%85%8D/"/>
    
      <category term="二分图" scheme="http://qianyouyou.cn/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="匈牙利算法" scheme="http://qianyouyou.cn/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="KM算法" scheme="http://qianyouyou.cn/tags/KM%E7%AE%97%E6%B3%95/"/>
    
      <category term="网络流" scheme="http://qianyouyou.cn/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们一起学过的线性代数</title>
    <link href="http://qianyouyou.cn/2018/08/17/2018-08-17/"/>
    <id>http://qianyouyou.cn/2018/08/17/2018-08-17/</id>
    <published>2018-08-17T12:38:28.000Z</published>
    <updated>2018-08-17T12:42:54.750Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="矩阵论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
    
      <category term="高斯消元" scheme="http://qianyouyou.cn/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="矩阵论" scheme="http://qianyouyou.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
      <category term="快速幂" scheme="http://qianyouyou.cn/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>组合数学1（排列组合 + 鸽巢原理 + 容斥原理）</title>
    <link href="http://qianyouyou.cn/2018/08/16/2018-08-16/"/>
    <id>http://qianyouyou.cn/2018/08/16/2018-08-16/</id>
    <published>2018-08-16T10:45:33.000Z</published>
    <updated>2018-08-17T12:05:03.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h2 id="加法-乘法法则"><a href="#加法-乘法法则" class="headerlink" title="加法/乘法法则"></a>加法/乘法法则</h2><h3 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h3><p>相互独立的事件 A、B 分别有 k 和 l 种方法产生，则产生 A 或 B 的方法数为 k+l 种。</p><h4 id="集合论定义"><a href="#集合论定义" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>若|A|=k，|B|=l ，且A∩B=Φ ，则|A∪B| = k+l 。</p><p>S = S1 ∪ S2 ∪ · · · ∪ Sm,    Si ∩ Sj = ∅ (i ≠ j)</p><p>⇒</p><p>|S| = |S1| + |S2| + · · · + |Sm|。</p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>a食堂有3种汉堡，b食堂有4种小吃，c食堂有2种包子，你的早餐只想吃一种，共有多少种选择方法？</p><p>解：</p><p>设S是所有食物的集合，Si是第i类食物的集合(i=1,2,3)，显然，Si∩Sj=Φ (i≠j) ，根据加法法则有：</p><p>|S| = |S1| + |S2| + |S3| = 3 + 4 + 2 = 9。</p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>大于0小于10的奇偶数有多少个？</p><p>解：</p><p>设S是符合条件数的集合，S1、S2分别是符合条件的奇数、偶数集合，显然，S1∩S2=Φ ，根据加法法则有：</p><p>|S| = |S1| + |S2| = 5 + 4 = 9。</p><h3 id="乘法法则"><a href="#乘法法则" class="headerlink" title="乘法法则"></a>乘法法则</h3><p>相互独立的事件 A、B 分别有 k 和 l 种方法产生，则选取A以后再选取B 的方法数为 k×l 种。</p><h4 id="集合论定义-1"><a href="#集合论定义-1" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>若|A|=k，|B|=l ，A×B={(a,b)|a∈A，b∈B}，则|A×B| = k×l 。</p><p>S = P × Q </p><p>⇒</p><p>|S| = |P | × |Q|。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>从A 地到B地有二条不同的道路，从B地到C地有四条不同的道路，而从C地到D地有三条不同的道路。求从A地经B、C两地到达D地的道路数。</p><p>解：</p><p>设S是所求的道路数集合，S1、S2、S3分别是从A到B、从B到C、从C到D的道路集合，根据乘法法则有</p><p>|S| = |S1 | × |S2| × |S3| = 2 × 4 × 3 = 24。</p><h3 id="计数问题的分类"><a href="#计数问题的分类" class="headerlink" title="计数问题的分类"></a>计数问题的分类</h3><p>有序安排或有序选择</p><p>​      ——允许重复/不允许重复</p><p>无序安排或无序选择</p><p>​      ——允许重复/不允许重复</p><h4 id="重集的概念"><a href="#重集的概念" class="headerlink" title="重集的概念"></a>重集的概念</h4><p>标准集的特性：确定、无序、相异等。</p><p>重集：B={k1 <em> b1, k2 </em> b2, …, kn * bn}，其中：bi为n个互不相同的元素，称 ki为bi的重数， i = 1, 2, …, n，n=1,2,…, ∞，ki = 1, 2, …, ∞。</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><h3 id="线排列"><a href="#线排列" class="headerlink" title="线排列"></a>线排列</h3><p>从n个不同元素中，取r个(0≤r≤n)按一定顺序排列起来，其排列数P(n,r)。</p><h4 id="集合论定义-2"><a href="#集合论定义-2" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>设A={an} ，从A中选择r个(0≤r≤n)元素排列起来，A的r−有序子集，A的r−排列。</p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>若n, r∈Z且n≥r≥0, P(n,r)=n!/(n-r)!。</p><p>若n=r，称全排列P(n,n)= n!；</p><p>若n＜r, P(n,r)=0；</p><p>若r=0, P(n,r)=1。</p><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>构造集合A的r−排列时，可以从A的n各元素中任选一个作为排列的第一项，有n种选法；第一项选定后从剩下的n-1个元素中选排列的第二项有n-1种选法；…由此类推，第r项有n-r+1种选法。根据乘法原理有：</p><p>P(n,r) = n(n-1)……(n-r+1) = n!/(n-r)! 。</p><h4 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h4><p>若n, r∈N且n≥r≥2，则P(n,r)=n×P(n-1,r-1) 。</p><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>在集合A的n个元素中，任一个元素都可以排在它的r−排列首位，故首位有n种取法；首位取定后，其他位置的元素正好是从A的另n-1个元素中取r-1个的排列，因此有P(n-1,r-1)种取法。由乘法法则有：</p><p>P(n,r)=n×P(n-1,r-1)</p><h4 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h4><p>若n, r∈N且n≥r≥2，则P(n,r)= r×P(n-1,r-1)+P(n-1,r) 。</p><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h5><p>当r≥2时，把集合A的r−排列分为两大类：一类包含A中的某个固定元素，不妨设为a1，另一类不包含a1 。第一类排列相当于先从A-{a1}中取r-1个元素进行排列，有P(n-1,r-1)种取法，再将a1放入每一个上述排列中，对任一排列，a1都有r种放法。由乘法法则，第一类排列共有r×P(n-1,r-1)个。第二类排列实质上是A-{a1}的r−排列，共有P(n-1,r)个。再由加法法则有：</p><p>P(n,r)= r×P(n-1,r-1)+P(n-1,r)</p><h4 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h4><p>由数字1,2,3,4,5可以构成多少个所有数字互不相同的四位数？</p><p>解：</p><p>由于所有的四位数字互不相同，故每一个四位数就是集合{1,2,3,4,5}的一个4−排列，因而所求的四位数个数为</p><p>P(5,4)=5!/(5-4)!=120。</p><h4 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h4><p>将具有9个字母的单词FRAGMENTS进行排列，要求字母A总是紧跟在字母R的右边，问有多少种这样的排法？如果再要求字母M和N必须相邻呢？</p><p>解：</p><p>由于A总是R的右边，故这样的排列相当于是8个元素的集合{F,RA,G,M,E,N,T,S}的一个全排列，个数为</p><p>P(8,8) = 8! = 40320。</p><p>如果再要求M和N必须相邻，可先把M和N看成一个整体={M,N}，进行7个元素的集合{F,RA,G,E,T,S,}的全排列，在每一个排列中再进行 {M,N}的全排列，由乘法法则，排列个数为</p><p>P(7,7) <em> P(2,2) = 7! </em> 2! = 10080。</p><h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>有多少个5位数，每位数字都不相同，不能取0，且数字7和9不能相邻？</p><p>解：</p><p>由于所有的5位数字互不相同，且不能取0，故每一个5位数就是集合{1,2,…,9}的一个5-排列，其排列数为P(9,5)，其中7和9相邻的排列数为[c(7,3)4!2]4×2×P(7,3)，满足题目要求的5位数个数为</p><p>P(9,5) - 4 <em> 2 </em> P(7,3) = 15120 -1680 = 13440</p><h3 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h3><p>设A={an} ，从A中取r个(0≤r≤n)元素按某种顺序（如逆时针）排成一个圆圈，称为圆排列（循环排列）。</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><p>设A={an}，A的r圆排列个数为P(n,r)/r。</p><h5 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h5><p>由于把一个圆排列旋转所得到另一个圆排列视为相同的圆排列，因此线排列a1a2…ar，a2a3…ara1，… ara1a2…ar-1在圆排列中是一个，即一个圆排列可产生r个不同的线排列；同理， r个不同的线排列对应一个圆排列。而总共有P(n,r)个线排列，故圆排列的个数为</p><p>​                              P(n,r)/r= n!/(r×(n-r)!)</p><h4 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h4><p>有8人围圆桌就餐，问有多少种就座方式？如果有两人不愿坐在一起，又有多少种就座方式？</p><p>解：</p><p>由上述定理知8人围圆桌就餐，有8!/8=7!=5040种就座方式。</p><p>又有两人不愿坐在一起，不妨设此二人为A、B，当A、B坐在一起时，相当于7人围圆桌就餐，有7!/7=6!种就座方式。 而A、B坐在一起时，又有两种情况，或者A在B的左面，或者A在B的右面，因此A、B坐在一起时，共有2×6!种就座方式，因此如果有两人不愿坐在一起，就座方式为</p><p>7!-2×6!= 5×6!=3600</p><h4 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h4><p>4男4女围圆桌交替就座有多少种就座方式？</p><p>解：</p><p>显然，这是一个圆排列问题。首先让4个男的围圆桌就座，有4!/4=3!种就座方式。 因为要求男女围圆桌交替就座，在男的坐定后，两两之间均需留有一个空位，女的就座相当于一个4元素集合的全排列，就座方式数为4!。由乘法法则知，就座方式数为</p><p>3!×4!=144</p><h3 id="重排列"><a href="#重排列" class="headerlink" title="重排列"></a>重排列</h3><p>从n个不同元素中，可重复选取r个按一定顺序排列起来，称为重排列。</p><h4 id="集合论定义-3"><a href="#集合论定义-3" class="headerlink" title="集合论定义"></a>集合论定义</h4><p>从重集B={k1 <em> b1, k2 </em> b2, … , kn * bn}中选取r个按一定顺序排列起来。</p><h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>重集B={∞ <em> b1, ∞ </em> b2, … , ∞ * bn} 的r−排列的个数为nr。</p><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><p>构造B的r−排列如下：选择第一项时可从n个元素中任选一个，有n种选法，选择第二项时由于可以重复选取，仍有n种选法，…，同理，选择第r项时仍有n种选法，根据乘法法则，可得出r−排列的个数为nr。</p><h4 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h4><p>由数字1,2,3,4,5,6这六个数字能组成多少个五位数？又可组成多少大于34500的五位数？</p><p>解：</p><p>一个五位数的各位数字可重复出现，是一个典型的重排列问题，相当于重集B={∞ <em> 1,∞ </em> 2,…,∞*6}的5−排列，所求的五位数个数为6^5=7776。</p><p>大于34500的五位数可由下面三种情况组成：</p><p>万位选4,5,6中的一个，其余4位相当于重集B的4−排列，由乘法法则知，共有3×6^4个五位数；</p><p>万位是3，千位5,6中的一个，其余3位相当于重集B的3−排列，由乘法法则知，共有2×6^3个五位数；</p><p>万位是3，千位4中的一个，百位选5,6中的一个，其余2位相当于重集B的2−排列，由乘法法则知，共有2×6^2个五位数；</p><p>由加法法则知，大于34500的五位数个数为3×6^4 + 2×6^3 + 2×6^2=4392</p><h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>重集B={n1 <em> b1,n2 </em> b2,…,nk <em> bk}的全排列个数为n! / ( n1! </em> n2! <em> …… </em> nk! )，其中，n = n1 + n2 +…… +nk。</p><h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><p>将B中的ni个bi看作不同的ni个元素，赋予上标1,2,…, ni，即b(1,i),b(2,i)……,b(ni,i), i=1, 2,…… k，如此，重集B就变成具有n1+n2+…+nk=n个不同的元素集合A = {b(1,1),b(2,1)……,b(n1,1),b(1,2),b(2,2)……,b(n2,2),……b(1,k),b(2,k)……,b(nk,k,}</p><p>显然，集合A的全排列个数为n!。又由于ni个bi赋予上标的方法有ni!种，于是对重集B的任一个全排列，都可以产生集合A的n1!×n2!×…×nk!个排列（由乘法法则），故重集B的全排列个数为n! / ( n1! <em> n2! </em> …… * nk! )。</p><p>注：利用组合数的计数方法同样可以得出证明。</p><h4 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h4><p>有四面红旗，三面蓝旗，二面黄旗，五面绿旗可以组成多少种由14面旗子组成的一排彩旗？</p><p>解：</p><p>这是一个重排列问题，是求重集{4<em>红旗,3</em>蓝旗,2<em>黄旗,5</em>绿旗}的全排列个数，根据定理，一排彩旗的种数为</p><p>14! / ( 4! <em> 3! </em> 2! * 5! ) = 2522520。</p><h4 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h4><p>用字母A、B、C组成五个字母的符号，要求在每个符号里，A至多出现2次，B至多出现1次，C至多出现3次，求此类符号的个数。</p><p>解：</p><p>这也是一个重排列问题。根据分析，符合题意的符号个数相当于求重集M={2<em>A,1</em>B,3*C}的5−排列个数，可分为三种情况：需要分别求M-{A}、M-{B}和M-{C}的全排列个数。根据加法法则，此类符号个数为</p><p>5! / (1! <em> 1! </em> 3!) + 5! / (2! <em> 0! </em> 3!) + 5! / (2! <em> 1! </em> 2!) = 60</p><h3 id="项链排列"><a href="#项链排列" class="headerlink" title="项链排列"></a>项链排列</h3><p>对圆排列，通过转动、平移、翻转、可重合的，即可看作项链排列。</p><p>若n个不同元素的r−项链排列个数为P(n,r)/(2×r)，具体参照Pólya定理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排列组合&quot;&gt;&lt;a href=&quot;#排列组合&quot; class=&quot;headerlink&quot; title=&quot;排列组合&quot;&gt;&lt;/a&gt;排列组合&lt;/h1&gt;&lt;h2 id=&quot;加法-乘法法则&quot;&gt;&lt;a href=&quot;#加法-乘法法则&quot; class=&quot;headerlink&quot; title=&quot;加法/
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数论1(辗转相除法 + 欧拉筛 + 杜教筛 + 模运算 + 快速幂)</title>
    <link href="http://qianyouyou.cn/2018/08/15/2018-08-15/"/>
    <id>http://qianyouyou.cn/2018/08/15/2018-08-15/</id>
    <published>2018-08-15T15:29:57.000Z</published>
    <updated>2018-08-17T12:09:46.257Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论2（强连通 + 2-SAT + 欧拉图 + 着色问题）</title>
    <link href="http://qianyouyou.cn/2018/08/14/2018-08-14/"/>
    <id>http://qianyouyou.cn/2018/08/14/2018-08-14/</id>
    <published>2018-08-14T09:46:23.000Z</published>
    <updated>2018-08-18T03:56:46.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>所谓连通性，直观的讲，就是“连成一片”。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%9B%BE%E8%81%94%E9%80%9A%E5%88%A4%E6%96%AD.png" alt=""></p><p>我们发现，按照上面的划分方法，我们可以把G1分为三部分，因此，G1是不连通的，但是，这三个部分，我们把它们叫做图G1的三个连通分量。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>无向图G中，如果任意两顶点u和v，都能找到从一条u到v的路径。称无向图G是连通的。</p><p>当G为有向图时，若G中存在一条以 u为起点 v为终点的有向路P，则称从 u到 v是可达的。</p><p>如果G的任何两个顶点都是相互可达的 ，则称图G是强连通的；如果G的有向边被看作无向边时是连通的，则称有向图G是弱连通的 。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E8%BF%9E%E9%80%9A%E5%BC%BA%E5%BC%B1.png" alt=""></p><h4 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h4><p>所谓连通分量，指的是图中的极大连通子图。</p><p>有了连通分量的概念，我们可以对图的连通性换言之为：如果图G中只有唯一一个连通分量，那么G是连通的，我们称G为连通图。</p><h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="无向图连通性"><a href="#无向图连通性" class="headerlink" title="无向图连通性"></a>无向图连通性</h3><p>在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先遍历或广度优先遍历，便可访问到图中所有顶点；对于非连通图，则需从多个顶点出发进行遍历，而每次从一个新的起点出发进行遍历得到的顶点访问序列恰好是一个连通分量中的顶点集。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>对无向图的连通性判定，一般我们采用搜索的方法，这里我们首先要提到应用非常广泛的深度优先搜索算法DFS，DFS在图论算法中有非常重要的地位。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>对下图( a ) 所示无向图进行深度优先遍历，需分别从顶点 v 1 和 v 5 出发调用两次 DFS（或 BFS），得到的顶点序列分别为： v 1 v 2 v 3 v 4 和 v 5 v 6 。这两个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图 G  的两个连通分量，如下图 ( b ) 所示。 </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>因此，要想判定一个无向图是否为连通图，或有几个连通分量，可以设置一个计数器 count ，初始时取值为 0 ，每调用一次遍历算法，就给 count 增 1 。这样，当整个遍历算法结束时，依据 count 的值，就可确定图的连通性了。算法用伪代码描述如下：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E6%97%A0%E5%90%91%E5%9B%BE%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">无向图连通分支</span><br><span class="line">//无向图连通分支，dfs邻接阵形式，o（n^2）</span><br><span class="line">//返回分支数，id返回1..分支数的值</span><br><span class="line">//传入图的大小n和邻接阵mat，不相邻点边权0</span><br><span class="line">#define MAXN 100 </span><br><span class="line">void floodfill(int n,int mat[][MAXN],int* id,int now,int tag)&#123;</span><br><span class="line">int i; </span><br><span class="line">for (id[now]=tag,i=0;i&lt;n;i++) </span><br><span class="line">if (!id[i]&amp;&amp;mat[now][i]) </span><br><span class="line">floodfill(n,mat,id,i,tag); </span><br><span class="line">&#125;</span><br><span class="line">int find_components(int n,int mat[][MAXN],int* id)&#123; </span><br><span class="line">int count,i; </span><br><span class="line">for (i=0;i&lt;n;id[i++]=0); </span><br><span class="line">for (count=i=0;i&lt;n;i++) </span><br><span class="line">if (!id[i]) </span><br><span class="line">floodfill(n,mat,id,i,++count); </span><br><span class="line">return count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图连通性"><a href="#有向图连通性" class="headerlink" title="有向图连通性"></a>有向图连通性</h3><p>假设，我们把一张有向图的所有边看做无向的，然后对转化后的无向图进行一次DFS，是不是就可以判断无向图的连通性呢？显然可以。</p><p>对于采用邻接矩阵表示的有向图G=&lt;E，V&gt;，如果存在一条边e(u,v),那么在矩阵中e(u,v)&gt;0，我们令e(v,u)=e(u,v)，这样就可以将一条有向边变成无向边。</p><p>之后，对于这个转化后的矩阵进行一次DFS，这样既可以判断有向图是否连通。</p><p>需要注意的是，一般情况下，我们在题目中应用到得不是简单的有向图是否连通，而是：求有向图的强连通分量。</p><h4 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h4><p>有向图G的极大强连通子图称为G的强连通分量(SCC)。</p><p>下图中，子图{1,2,3,4}为一个强连通分量，因为顶点 1,2,3,4 两两可达。{5},{6}也分别是两个强连通分量。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt=""></p><p>直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为 O(N^2+M)。<br>更好的方法是 Kosaraju 算法或 和Tarjan 算法，两者的时间复杂度都是 O(N+M)。还有Gabow算法不介绍。</p><h4 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a>Kosaraju 算法</h4><p>Kosaraju算法的解释和实现都比较简单，为了找到强连通分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域。具体流程如图(1~4)。</p><p>上面我们提及原图G的逆图GT，其定义为GT=(V, ET)，ET={(u, v):(v, u)∈E}}。也就是说GT是由G中的边反向所组成的，通常也称之为图G的转置。在这里值得一提的是，逆图GT和原图G有着完全相同的连通分支，也就说，如果顶点s和t在G中是互达的，当且仅当s和t在GT中也是互达的。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-k%E7%AE%97%E6%B3%95.JPG" alt=""></p><p>在这里顺便提一下在调用dfs的过程中，几种添加顶点到集合的顺序。一共有四种顺序：</p><ul><li><p>Pre-Order，在递归调用dfs之前将当前顶点添加到queue中</p></li><li><p>Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中</p></li><li><p>Post-Order，在递归调用dfs之后将当前顶点添加到queue中</p></li><li>Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中</li></ul><p>最后一种的用途最广，至少目前看来是这样，比如步骤2-a以及拓扑排序中，都是利用的Reverse Post-Order来获取顶点集合。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p> (1)对G执行深度优先搜索，求出每个顶点的后序遍历顺序号postOrder。    </p><p>(2)反转有向图G中的边，构造一个新的有向图G*。</p><p>(3)由最高的postOrder编号开始，对G*执行深度优先搜索。如果深度优先搜索未达到所有顶点，由未访问的最高postOrder编号的顶点开始，继续深度优先搜索。    </p><p>(4)步骤三所产生的森林中的每一棵树，对应于一个强连通分支。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define maxN 1024</span><br><span class="line">int marked[maxN];//用于记录某个点是否被访问过，0为没有被临幸过，1为被临幸过</span><br><span class="line">int id[maxN];//记录每个点所属的连通分量</span><br><span class="line">int count;//记录连通分量总数目</span><br><span class="line">void kosaraju(graph *g)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    memset(marked,0,sizeof(marked));</span><br><span class="line">    memset(id,0,sizeof(id));</span><br><span class="line">    count=0;</span><br><span class="line">    for(i=0;i&lt;g-&gt;V;i++)&#123;//之所以这里用循环就是因为g指向的无向图可能不是一个连通图，而是由多个连同分量组成</span><br><span class="line">        if(!marked[i])&#123;dfs(g,i); count++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void dfs(graph *g,int v)&#123;</span><br><span class="line">    graphNode *t;</span><br><span class="line">    marked[v]=1;</span><br><span class="line">    id[v]=count;</span><br><span class="line">    t=g-&gt;adjlist[v].next;//t指向v的邻接点</span><br><span class="line">    while(t)&#123;</span><br><span class="line">        if(!marked[t-&gt;key])&#123;dfs(g,t-&gt;key);&#125;//这里是重点，就是你发现v到t-&gt;key有路径就把它算到跟自己在一个连通分量里了，这里有一个隐性前提，就是你提前知道t-&gt;key一定可以到v，所以你发现v可以到t-&gt;key的时候，你毫不犹豫把它算为跟自己一伙儿的了。Korasaju算法不同书上有不同的表述，区别是先遍历图g还是先遍历图g的逆向图，这只是顺序的区别。我把我看得版本完整说一下：（1）先DFS遍历图g的逆向图，记录遍历的逆后序。（什么叫逆后序？逆后序就是DFS时后序的逆序，注意逆后序不一定为DFS的前序。DFS前序为，访问某个顶点前，把它push进队列。DFS后序为访问完某个顶点后才把它push进队列。而DFS逆后序为访问完某个顶点后把它push进一个栈中。当DFS遍历完整个图后，后序队列的输出与逆后序栈的输出正好相反。）（2）然后按着图g逆向图的DFS遍历的逆后序序列遍历图g求所有的强连通分量，这一步的过程跟无向图求所有连通分量的算法一模一样！按着这里说的遍历顺序重复无向图求所有连通分量的步骤求出来的就是有向图的所有强连通分量，为什么呢？因为我们完成第一步后，按着第一步得到的逆后序要对有向图g进行DFS遍历的前一刻，前面这段过程就相当于我们完成了对这幅有向图g一个加工，把它加工成了一个无向图！也就是说，这个加工实现了我注释开头提到的那个隐性前提。所以后面按着无向图求所有连通分量的步骤求出来的就是有向图g的所有强连通分量。举个例子，比如有向图3-&gt;5-&gt;4-&gt;3，它的逆向图为3-&gt;4-&gt;5-&gt;3（你最好在纸上画下，就是个三角循环图），从逆向图的顶点3开始DFS，得到的逆后续为3，4,5 。按着这个顺序对原图进行DFS，DFS(3)时遇到5，则5肯定跟3在一个强连通分量中（为什么？因为我们逆向图DFS(5)时肯定能到达3，这就是隐形前提。所以正向图DFS(3)遇到5时，我们毫不犹豫把它算到自己一个强连通分量中。）</span><br><span class="line">        t=t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a>Tarjan 算法</h4><p>Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。定义 DFN(u)为节点 u 搜索的次序编号(时间戳)，Low(u)为 u 或 u 的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Low(u)=Min </span><br><span class="line">&#123; </span><br><span class="line"> DFN(u), </span><br><span class="line"> Low(v),(u,v)为树枝边，u为v的父节点</span><br><span class="line"> DFN(v),(u,v)为指向栈中节点的后向边(非横叉边) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 DFN(u)=Low(u)时，以 u 为根的搜索子树上所有节点是一个强连通分量。<br>算法伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u) </span><br><span class="line">&#123; </span><br><span class="line">DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值</span><br><span class="line">Stack.push(u) // 将节点u压入栈中</span><br><span class="line">for each (u, v) in E // 枚举每一条边</span><br><span class="line">if (v is not visted) // 如果节点v未被访问过</span><br><span class="line">tarjan(v) // 继续向下找</span><br><span class="line">Low[u] = min(Low[u], Low[v]) </span><br><span class="line">else if (v in S) // 如果节点v还在栈内</span><br><span class="line">Low[u] = min(Low[u], DFN[v]) </span><br><span class="line">if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根</span><br><span class="line"> repeat </span><br><span class="line">v = S.pop // 将v退栈，为该强连通分量中一个顶点</span><br><span class="line"> print v </span><br><span class="line">until (u== v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p>从节点 1 开 始 DFS ，把遍历到的节点加入栈中。搜索到节点 u=6 时 ，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到 u=v 为止，{6}为一个强连通分量。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-a.png" alt=""></p><p>返回节点 5，发现 DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-b.png" alt=""></p><p>返回节点 3，继续搜索到节点 4，把 4 加入堆栈。发现节点 4 向节点 1 有后向边，节点 1 还在栈中，所以 LOW[4]=1。节点 6 已经出栈，(4,6)是横叉边，返回 3，(3,4)为树枝边，所以 LOW[3]=LOW[4]=1。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-c.png" alt=""></p><p>继续回到节点 1 ，最后访问节点 2 。访问边 (2,4) ， 4 还在栈中，所以LOW[2]=DFN[4]=5。返回 1 后，发现 DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-d.png" alt=""></p><p>至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。可以发现，运行 Tarjan 算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为 O(N+M)。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void tarjan(int i)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    DFN[i]=LOW[i]=++Dindex;</span><br><span class="line">    instack[i]=true;</span><br><span class="line">    Stap[++Stop]==i;</span><br><span class="line">    for (edge *e=V[i]; e; e=e-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        j=e-&gt;t;</span><br><span class="line">        if (!DFN[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(j);</span><br><span class="line">            if (LOW[j]&lt;LOW[i])</span><br><span class="line">                LOW[i]=LOW[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i]</span><br><span class="line">                )</span><br><span class="line">            LOW[i]=DFN[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if (DFN[i]==LOW[i])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            j=Stap[Stop--];</span><br><span class="line">            instack[j]=false;</span><br><span class="line">            Belong[j]=Bcnt;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j!=i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    Stop=Bcnt=Dindex=0;</span><br><span class="line">    memset(DFN,0,sizeof(DFN));</span><br><span class="line">    for (i=1; i&lt;=N; i++)</span><br><span class="line">        if (!DFN[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Gabow算法"><a href="#Gabow算法" class="headerlink" title="Gabow算法"></a>Gabow算法</h4><p>这个算法其实就是Tarjan算法的变异体，我们观察一下，只是它用第二个堆栈来辅助求出强连通分量的根，而不是Tarjan算法里面的dfn[]和backn[]数组。那么，我们说一下如何使用第二个堆栈来辅助求出强连通分量的根。 </p><p>我们使用类比方法，在Tarjan算法中，每次backn[i]的修改都是由于环的出现(不然，backn[i]的值不可能变小)，每次出现环，在这个环里面只剩下一个backnk[i]没有被改变(深度最低的那个)，或者全部被改变，因为那个深度最低的节点在另一个环内。那么Gabow算法中的第二堆栈变化就是删除构成环的节点，只剩深度最低的节点，或者全部删除，这个过程是通过出栈来实现，因为深度最低的那个顶点一定比前面的先访问，那么只要出栈一直到栈顶那个顶点的访问时间不大于深度最低的那个顶点。其中每个被弹出的节点属于同一个强连通分量。那有人会问：为什么弹出的都是同一个强连通分量？因为在这个节点访问之前，能够构成强连通分量的那些节点已经被弹出了，这个对Tarjan算法有了解的都应该清楚，那么Tarjan算法中的判断根我们用什么来代替呢？想想，其实就是看看第二个堆栈的顶元素是不是当前顶点就可以了。 </p><p>现在，你应该明白其实Tarjan算法和Gabow算法其实是同一个思想的不同实现，但是，Gabow算法更精妙，时间更少(不用频繁更新backn[])。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool map[100][100];//记录图形</span><br><span class="line">bool visited[100];//记录点是不是已经被访问过了</span><br><span class="line">bool del[100];//记录点是不是已经删除了</span><br><span class="line">int dfn[100];//记录点访问的次序</span><br><span class="line">stack&lt;int&gt;s1,s2;</span><br><span class="line">int dotn;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    int line;</span><br><span class="line">    cin&gt;&gt;dotn&gt;&gt;line;</span><br><span class="line">    for(int i=1;i&lt;=line;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        map[u][v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visited,0,sizeof(visited));</span><br><span class="line">    memset(del,0,sizeof(del));</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int &amp;time)</span><br><span class="line">&#123;</span><br><span class="line">    visited[u]=1;</span><br><span class="line">    dfn[u]=++time;</span><br><span class="line">    s1.push(u);</span><br><span class="line">    s2.push(u);</span><br><span class="line">    for(int i=1;i&lt;=dotn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(map[u][i])</span><br><span class="line">        &#123;</span><br><span class="line">            if(!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i,time);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(!del[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    while(dfn[s2.top()]&gt;dfn[i])s2.pop();//注意这个地方</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(u==s2.top())</span><br><span class="line">    &#123;</span><br><span class="line">        while(u!=s1.top())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;s1.top()&lt;&lt;&quot;   &quot;;</span><br><span class="line">            del[s1.top()]=1;</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;u&lt;&lt;endl;</span><br><span class="line">        del[s1.top()]=1;</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Gadow()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    int time=0;</span><br><span class="line">    for(int i=1;i&lt;=dotn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(i,time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    Gadow();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>强连通分支问题的最大应用就在于两个字：缩点！</p><p>所谓缩点，就是把图中属于同一个强连通分支中的点缩为一个点，这样，我们就得到了一个新的有向图，而且图中不存在回路。</p><p>POJ 1236 - Network of Schools（最小点基）</p><h4 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h4><p>有向图缩点一个很大的应用，就是2-SAT问题(2判定性问题 )。</p><p>POJ 3678 - Katu Puzzle</p><p>POJ 3683 - Priest John’s Busiest Day</p><h1 id="2-SAT-1"><a href="#2-SAT-1" class="headerlink" title="2-SAT"></a>2-SAT</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 1:"></a>定义 1:</h2><p>布尔变量 x，假如逻辑运算“或”和“与”分别用“∨”和“∧ ”来表示，﹁x表示 x 的非，布尔表达式是用算术运算符号连接起来的变量所构成的代数表达式。给定每个变量 x 的一个值 p(x)，可以像计算代数表达式一样计算布表达式的值。如果存在一个真值分配，使得布尔表达式的取值为真，则这个布尔表达式称为可适定性的，简称 SAT。</p><p>例如（x1∨x2）∧(﹁x1∨﹁x2) 这个布尔表达式，如果 p(x1)=真，p(x2)=假，则表达式的值为真，则这个表达式是适定性的。不是所有的布尔表达式都是可适定的。</p><p>例如x1∧﹁x2∧(﹁x1∨x2)，则不管 p(x1),p(x2)取何值，表达式都不可能为真，因此这个布尔表达式是不可适定的。</p><p>适定性问题的一般形式 X=｛x1,x2..,xn｝为一个有限的布尔变量集，包含 x1,x2，..,xn的“或”和“与”，运算的 m 个句子 C1,C2,..,Cm,布尔表达式 C1∧C2∧,..,∧Cm 是否可适定。</p><p> 布尔表达式由用“与”连接起来的一些句子构成，则称这个表达式为“合取范式”。</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义 2:"></a>定义 2:</h2><p>对于给定的句子 C1,C2,..,Cm,如果 max{|Ci|}=k(1≦i≦m),则称此适定性问题为 k 适定性问题，简称 k-SAT。</p><p>当 k&gt;2 时，k-SAT 是 NP 完全的，所以我们一般讨论2-SAT问题。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>下面我们从一道例题来认识 2-SAT 问题，并提出对一类 2-SAT 问题通用的解法。<br>Poi 0106 Peaceful Commission [和平委员会] </p><p>某国有 n 个党派，每个党派在议会中恰有 2 个代表。现在要成立和平委员会 ，该会满足：</p><p>每个党派在和平委员会中有且只有一个代表<br>如果某两个代表不和，则他们不能都属于委员会<br>代表的编号从 1 到 2n，编号为 2a-1、2a 的代表属于第 a 个党派</p><p>输入 n（党派数），m（不友好对数）及 m 对两两不和的代表编号<br>其中 1≤n≤8000，0≤m ≤20000<br>求和平委员会是否能创立。<br>若能，求一种构成方式。 </p><p>例：</p><p>输入：</p><p>3 2</p><p>1 3</p><p>2 4</p><p>输出：</p><p>1</p><p>4</p><p>5</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>原题可描述为：</p><p>有 n 个组，第 i 个组里有两个节点 Ai, Ai’ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的 n 个点都能两两相容。（在这里把 Ai,Ai’ 的定义稍稍放宽一些，它们同时表示属于同一个组的两个节点。也就是说，如果我们描述 Ai，那么描述这个组的另一个节点就可以用 Ai’）</p><p>初步构图</p><p>如果 Ai 与 Aj 不相容，那么如果选择了 Ai，必须选择 Aj ‘ ；同样，如果选择了 Aj，就必须选择 Ai ’ 。</p><p>Ai → Aj<code>Aj → Ai</code></p><p>这样的两条边对称</p><p>我们从一个例子来看：</p><p>假设 4 个组，不和的代表为：1 和 4，2 和 3，7 和 3，那么构图：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-2-sat%E9%97%AE%E9%A2%981.png" alt=""></p><p>假设：</p><p>首先选 1<br>3 必须选，2 不可选<br>5、6 可以任选一个<br>8 必须选，4、7 不可选</p><p>矛盾的情况为：<br>存在 Ai，使得 Ai 既必须被选又不可选。<br>得到算法 1：<br>枚举每一对尚未确定的 Ai, Ai‘ ，任选 1 个，推导出相关的组，若不矛盾，则可选择；否则选选另 1 个，同样推导。若矛盾，问题必定无解。</p><p>此算法正确性简要说明：</p><p>由于 Ai,Ai’ 都是尚未确定的，它们不与之前的组相关联，前面的选择不会影响 Ai,Ai’ 。<br>算法的时间复杂度在最坏的情况下为 O(nm)。</p><p>在这个算法中，并没有很好的利用图中边的对称性<br>观察图（1）可以发现，1 和 3 构成一个环，这样 1 和 3 要么都被选中，要么都不选。2和 4 也同样如此。</p><p>在每个一个环里，任意一个点的选择代表将要选择此环里的每一个点。不妨把环收缩成一个子节点。新节点的选择表示选择这个节点所对应的环中的每一个节点。</p><p>对于原图中的每条边 Ai → Aj（设 Ai 属于环 Si，Aj 属于环 Sj）如果 Si≠Sj，则在新图中连边：</p><p>Si → Sj </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-2-sat%E9%97%AE%E9%A2%982.png" alt=""></p><p>这样构造的有向无环图和原图是等价的，这样我们就可以用之前介绍过的强连通分量的算法把图转化成有向无环图，在这个基础上，如果存在一对 Ai, Ai’属于同一个环，则判无解，否则将采用拓扑排序，以自底向上的顺序进行推导，一定能找到可行解。</p><p>下面给出 2-SAT 问题中常用的建边方式：</p><p>2-SAT 中元素关系常见有以下 11 种</p><p>A[x]</p><p>NOT A[x]</p><p>A[x] AND A[y]</p><p>A[x] AND NOT A[y]</p><p>A[x] OR A[y]</p><p>A[x] OR NOT A[y]</p><p>NOT (A[x] AND A[y]) </p><p>NOT (A[x] OR A[y]) </p><p>A[x] XOR A[y]</p><p>NOT (A[x] XOR A[y]) </p><p>A[x] XOR NOT A[y]</p><p>And 结果为 1：建边 ~x-&gt;y, ~y-&gt;x (两个数都为 1)<br>And 结果为 0：建边 y-&gt;~x , x-&gt;~y(两个数至少有一个为 0)<br>OR 结果为 1：建边 ~x-&gt;y ,  ~y-&gt;x(两个数至少有一个为 1)<br>OR 结果为 0：建边 x-&gt;~x , y-&gt;~y(两个数都为 0)<br>XOR 结果为 1：建边 x-&gt;~y , ~x-&gt;y , ~y-&gt;x , y -&gt; ~x (两个数一个为 0，一个为 1)<br>XOR 结果为 0：建边 x-&gt;y , ~x-&gt;~y , y-&gt;x ~y-&gt;~x(两个数同为 1 或者同为 0) </p><p>对于一般判定是不是有解的情况，我们可以直接采用 tarjan 算法求强联通，然后缩点，如果 x 与~x 染色相同，说明无解，否则有解。有的时候，可能需要用二分++tarjan 算法</p><h1 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h1><p>每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。</p><p> <img src="http://p7woygi8q.bkt.clouddn.com/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF.gif" alt=""></p><p>答案是肯定的。 math 版上的 <a href="https://www.reddit.com/r/math/comments/3hz9u9/will_each_jellyfish_in_this_gif_eventually_end_up/cubw779" target="_blank" rel="noopener">OmnipotentEntity</a> 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。</p><p>熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。</p><h2 id="欧拉图（E问题）"><a href="#欧拉图（E问题）" class="headerlink" title="欧拉图（E问题）"></a>欧拉图（E问题）</h2><h3 id="起源："><a href="#起源：" class="headerlink" title="起源："></a>起源：</h3><p>欧拉回路问题是图论中最古老的问题之一。它诞生于十八世纪的欧洲古城哥尼斯堡。普瑞格尔河流经这座城市，人们在两岸以及河中间的两个小岛之间建了七座桥（如图1）。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%981.png" alt=""></p><p>于是产生了这样一个问题：是否可以找到一种方案，使得人们从自己家里出发，不重复地走遍每一座桥，然后回到家中？这个问题如果用数学语言来描述，就是在图2中找出一条回路，使得它不重复地经过每一条边。这便是著名的“哥尼斯堡七桥问题”。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%982.png" alt=""></p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><p>​        欧拉回路：图G=(V,E) (无向图or有向图) 的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。</p><p>​        欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。</p><p>​    欧拉图与半欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉通路而无欧拉回路的图称为半欧拉图。</p><p>​    桥：设无向图G=&lt;V,E&gt;，若存在边集E的一个非空子集E1，使得p(G-E1)&gt;p(G)，而对于E1的任意真子集E2，均有p(G-E2)=p(G)，则称E1是G的边割集，或简称割集；若E1是单元集，即E1={e}，则称e为割边或桥。[p(G)表示图G的连通分支数.]</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E6%AC%A7%E6%8B%89%E5%9B%BE.png" alt=""></p><p>图中，图（4）为欧拉图，图（3）为半欧拉图，图（1）（2）不是欧拉图。</p><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a><strong>性质：</strong></h3><p>　　欧拉回路：一个欧拉回路，删掉一个点，仍然是一个欧拉回路。从一个欧拉回路拖走一个小欧拉回路，结果也是一个欧拉回路。</p><h3 id="判定（充要）："><a href="#判定（充要）：" class="headerlink" title="判定（充要）："></a><strong>判定（充要）：</strong></h3><p>　　欧拉回路：1:  图G是连通的，不能有孤立点存在。</p><p>　　　　　　　2:  对于无向图来说度数为奇数的点个数为0;对于有向图来说每个点的入度必须等于出度。</p><p>　　欧拉通路：1:  图G是连通的，无孤立点存在。</p><p>　　　　　　　2:  对于无向图来说，度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点。对于有向图来说，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。</p><h3 id="算法（求欧拉回路）："><a href="#算法（求欧拉回路）：" class="headerlink" title="算法（求欧拉回路）："></a><strong>算法（求欧拉回路）：</strong></h3><h4 id="Fleury算法"><a href="#Fleury算法" class="headerlink" title="Fleury算法:"></a><strong>Fleury算法:</strong></h4><p>设图G是一个无向欧拉图，则按照下面算法求欧拉回路:</p><p>1:任取G中一个顶点v0,令P0 = v0.</p><p>2:假设沿Pi = v0e1v1e2v2……eivi 走到了顶点 vi,按照下面方法从E(i) = E(G) -  {e1, e2, e3,…,ei} 中选e(i ＋　1),选择后删除e(i +１)这条边.</p><p>　　a):e(i+1)余vi关联</p><p>　　b):除非无别的边可选，否则e(i+1)不应是Gi = G – {e1,e2,…,ei} 中的桥.假若迫不得已选的是桥,除删除这条边之外,还应该再把孤立点从Gi中移除(选择桥边必然会形成孤立的点).</p><p>3:当步骤 2 无法继续执行时停止算法.</p><p>当算法停止时，所得到的简单回路 Pm = = v0e1v1e2v2e3v3……emvm  (vm = v0) 为图G的一条欧拉回路.</p><p><strong>下面用图来描述：</strong></p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093832441-1464795842.png" alt="img"></p><p>随便选择一个起点 v1。当前处在 v1 点，有两种走法 v1 – v9,v1 – v10，这俩条边都不是桥边，那么随便选择一个，&lt;v1, v10&gt;这条边吧。那么图就会成为这样.Eu = (走过的边集){&lt;v1, v10&gt;}</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833082-1968185223.png" alt="img"></p><p>当前到了 V10 点，有&lt;v10,v4&gt;,&lt;v10,v3&gt;,&lt;v10, v8&gt;，先看&lt;v10,v8&gt;这条边吧，如果选择了这条边那么图就会成为这样：</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833488-2076065400.png" alt="img"></p><p>很显然形成了两个图，上下两个图不连通，即&lt;v10, v8&gt;这条边就是所谓的桥边，算法中说除非别无他选，否则不应该选择桥边，那么这条边就不能选择。回到上面，由于&lt;v10,v4&gt;,&lt;v10,v3&gt;都不是桥边，所以随便选择&lt;v10,v4&gt;吧. Eu={&lt;v1, v10&gt;,&lt;v10,v4&gt;}</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093833910-319654348.png" alt="img"></p><p>到了 v4 这个点，&lt;v4, v2&gt;这条边是桥边,但是别无选择，只好选择这条边.选择完这条边这时不仅要从原图中删除这条边，由于点4成为了孤点，所以这个点也该从原图删除。Eu={&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834410-492154878.png" alt="img"></p><p>同理到达 v2 只好选择&lt;v2,v3&gt;，删除孤点 v2和边. Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093834941-273171314.png" alt="img"></p><p>别无他选，&lt;v3,v10&gt;。Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835473-1872025007.png" alt="img"></p><p>同样,选择&lt;v10, v8&gt;，Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093835941-942659814.png" alt="img"></p><p>此时到了 v8 同第一次到达v10时的情况，不能选择&lt;v8,v9&gt;这条桥边,选择&lt;v8,v6&gt;,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;}.</p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836457-215788402.png" alt="img"></p><p>到达v6，选择&lt;v6,v7&gt;,删点删边,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;}.以下就不给图了(逃;</p><p>然后接下来的选择都是别无他选,依次选择&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;，最后得到的欧拉边集Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;,&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;},于是我们就得到了一条欧拉回路.</p><h5 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h5><p>这个算法在实现时也有很巧妙的方法。因为DFS本身就是一个入栈出栈的过程，所以我们直接利用DFS的性质来实现栈，其伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DFS(u):</span><br><span class="line">While (u存在未被删除的边e(u,v))</span><br><span class="line">删除边e(u,v)</span><br><span class="line">DFS(v)</span><br><span class="line">End</span><br><span class="line">PathSize ← PathSize + 1</span><br><span class="line">Path[ PathSize ] ← u</span><br></pre></td></tr></table></figure><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Graph &amp;G,SqStack &amp;S,int x,int t)</span><br><span class="line">&#123;</span><br><span class="line">       k=0;//一个标志,来标记当前访问的节点是否还有邻接边可供访问</span><br><span class="line">       Push(S,x); //将本次遍历边所经由的点入栈</span><br><span class="line">       for(i=t;i&lt;v;i++) //v是顶点数,e是边数</span><br><span class="line">        if(G[i][x]&gt;0)  </span><br><span class="line">         &#123;</span><br><span class="line">          k=1;</span><br><span class="line">          G[i][x]=0; G[x][i]=0; //此边已访问,删除此边</span><br><span class="line">          DFS(G,S,i,0);//寻找下一条关联的边,本次找到的是与x关联的i,在</span><br><span class="line">                        //下一层中将寻找与i关联的边</span><br><span class="line">          break;</span><br><span class="line">         &#125;//if,for</span><br><span class="line">          if(k==0)       //如果k=0,说明与当前顶点关联的边已穷尽</span><br><span class="line">       &#123;</span><br><span class="line">              Pop(S);</span><br><span class="line">              GetTop(S,m);</span><br><span class="line">              G[x][m]=1;G[m][x]=1;//恢复在上一层中被删除的边</span><br><span class="line">              a=x+1;//如果可能的话,从当前节点的下一条关联边开始搜寻</span><br><span class="line">              if(StackLength(S)!=e)//继续搜寻,边还没有全部遍历完</span><br><span class="line">              &#123;</span><br><span class="line">                     Pop(S); //还原到上一步去</span><br><span class="line">                     DFS(G,S,m,a);//</span><br><span class="line">              &#125;//if</span><br><span class="line">              else   //搜寻完毕,将最后节点也入栈</span><br><span class="line">                     Push(S,x);</span><br><span class="line">       &#125;//if</span><br><span class="line">&#125;//DFS</span><br><span class="line">void Euler(Graph &amp;G,int x)</span><br><span class="line">&#123;</span><br><span class="line">//G是存储图的邻接矩阵,都处理成无向图形式,值为1代表有边,0代表无边,不包括自回路,x是出发点</span><br><span class="line">InitStack(S);//用来存放遍历边时依次走过的顶点</span><br><span class="line">DFS(G,S,x,0);//深度优先遍历查找,0是指查询的起点</span><br><span class="line">//输出</span><br><span class="line"> while(!StackEmpty(S))</span><br><span class="line"> &#123;</span><br><span class="line">  GetTop(S,m);</span><br><span class="line">  printf(&quot;-&gt;v%d&quot;,m);</span><br><span class="line">  Pop(S);</span><br><span class="line"> &#125;//while</span><br><span class="line">&#125;//Euler</span><br></pre></td></tr></table></figure><p><strong>代码：</strong>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1005;</span><br><span class="line">int n, m, flag, top, sum, du[N], ans[5005], map[N][N];</span><br><span class="line"></span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    ans[++top] = x;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(map[x][i] &gt;= 1)</span><br><span class="line">        &#123;</span><br><span class="line">            map[x][i]--;</span><br><span class="line">            map[i][x]--;</span><br><span class="line">            dfs(i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fleury(int x)</span><br><span class="line">&#123;</span><br><span class="line">    top = 1;</span><br><span class="line">    ans[top] = x;</span><br><span class="line">    while(top &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//判断是否可扩展</span><br><span class="line">        &#123;</span><br><span class="line">            if(map[ans[top]][i] &gt;= 1)//若存在一条从ans[top]出发的边  那么就是可扩展</span><br><span class="line">            &#123;k = 1; break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(k == 0)//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d &quot;, ans[top]);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(k == 1)//如可扩展， 则dfs可扩展的哪条路线</span><br><span class="line">        &#123;</span><br><span class="line">            top--;//这需要注意</span><br><span class="line">            dfs(ans[top+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(du, 0, sizeof(du));</span><br><span class="line">        memset(map, 0, sizeof(map));</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, y;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">            map[x][y]++; //记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边</span><br><span class="line">            map[y][x]++;</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = 1; // flag标记开始点。 如果所有点度数全为偶数那就从1开始搜</span><br><span class="line">        sum = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(du[i] % 2 == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                flag = i;// 若有奇数边， 从奇数边开始搜</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == 0 || sum == 2)</span><br><span class="line">            fleury(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本-套圈-法"><a href="#基本-套圈-法" class="headerlink" title="基本(套圈)法"></a><strong>基本(套圈)法</strong></h4><p>1.在图中任意找一个回路C；</p><p>2.将图中属于C的边删除；</p><p>3.在残留图的各个极大连通分量中求欧拉回路；</p><p>4.将各极大连通分量中的欧拉回路合并到C上。</p><h5 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h5><p>　　首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，所停止的点必然也是起点(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，然后停止时，走过的路径形成了一个圈，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。</p><p>　　总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。</p><p><strong>下面用图描述一遍：</strong></p><p><img src="https://images2015.cnblogs.com/blog/937718/201604/937718-20160416093836879-1824078027.png" alt="img"></p><p>假设我们选择从v1开始走,由于随便走，所以可能出现以下走法</p><p>第一步：v1 – v9</p><p>第二步：v9 – v8</p><p>第三步：v8 – v10</p><p>第四步：v10 – v1</p><p>此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么</p><p>第五步: v10 – v3</p><p>第六步: v3 – v2</p><p>第七步: v2 – v4</p><p>第八步: v4 – v10</p><p>发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么</p><p>第九步：v8 – v6</p><p>第十步：v6 –v7</p><p>第十一步：v7– v8</p><p>又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。</p><p><strong>具体实现与分析:</strong></p><p>使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV = 100 + 7;</span><br><span class="line">const int MAXE = 100 * 100 + 7;</span><br><span class="line">int head[MAXV];</span><br><span class="line">int V, E;</span><br><span class="line"></span><br><span class="line">typedef struct EdgeNode</span><br><span class="line">&#123;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int next;   </span><br><span class="line">&#125;edgeNode;</span><br><span class="line">edgeNode Edges[MAXE];</span><br><span class="line"></span><br><span class="line">bool visit[2 * MAXE];</span><br><span class="line">stack&lt;int&gt; stv;</span><br><span class="line">queue&lt;int&gt; quv;//点集</span><br><span class="line">queue&lt;int&gt; que;//边集</span><br><span class="line"></span><br><span class="line">void EulerDFS(int now)</span><br><span class="line">&#123;</span><br><span class="line">    st.push(now);//每访问一个点，就把该点压入栈</span><br><span class="line">    for(int k = head[now]; k != -1; k = Edges[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visit[k])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[k] = true;            //有向图每条边保存了两次，也要标记两次</span><br><span class="line">            if(k &amp; 1)</span><br><span class="line">                visit[k + 1] = true;</span><br><span class="line">            else</span><br><span class="line">                visit[k - 1] = true;</span><br><span class="line">            EulerDFS(Edges[k].to);</span><br><span class="line">            que.push(k);//回溯时记录边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    quv.push(stv.top());//记录点</span><br><span class="line">    stv.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;V, &amp;E);</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    for(int i = 1; i &lt;= E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        Edges[2 * i - 1].to = v;                //双向储存边</span><br><span class="line">        Edges[2 * i - 1].w = w;</span><br><span class="line">        Edges[2 * i - 1].next = head[u];</span><br><span class="line">        head[u] = 2 * i - 1;</span><br><span class="line">        Edges[2 * i].to = u;</span><br><span class="line">        Edges[2 * i].w = w;</span><br><span class="line">        Edges[2 * i].next = head[v];</span><br><span class="line">        head[v] = 2 * i;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(visit, false, sizeof(visit));</span><br><span class="line">    EulerDFS(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E4%BE%8B%E9%A2%981b.png" alt=""></p><p>有N个盘子，每个盘子上写着一个仅由小写字母组成的英文单词。你需要给这些盘子按照合适的顺序排成一行，使得相邻两个盘子中，前一个盘子上面单词的末字母等于后一个盘子上面单词的首字母。请你编写一个程序，判断是否能达到这一要求。如果能，请给出一个合适的顺序。</p><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>以26个英文字母作为顶点。对于每一个单词，在图中从它的首字母向末字母连一条有向边。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-14-%E4%BE%8B%E9%A2%981c.png" alt=""></p><p>问题转化为在图中寻找一条不重复地经过所有边的路径，即欧拉路径。这个问题能够在O(|E|)时间内解决。</p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><strong>PKU 2337</strong></p><p>问题描述</p><p>给出一些字符串，让你首尾串起来串成一串，并且输出一个字典序最小的方案。如果不能，输出“**”。否则输出字典序最小的回路。</p><p><strong><em>输入</em></strong></p><p>2</p><p>6</p><p>aloha</p><p>arachnid</p><p>dog</p><p>gopher</p><p>rat</p><p>tiger</p><p>3</p><p>oak</p><p>maple</p><p>elm</p><p><strong>输出</strong></p><p>aloha.arachnid.dog.gopher.rat.tiger</p><p>**</p><p><strong>分析</strong></p><p>在没有特殊要求的情况下，DFS遍历图的结点顺序是可以任选的。但是这里由于加上了字典序最小的要求，所以DFS遍历时需要按照以下的优先顺序：</p><p>如果有不是桥的边，遍历这些边中字典序最小的边。</p><p>否则，遍历这些这些桥中字典序最小的边。</p><p>比如一个单词，abcde，那么就连接一条a到e的有向边。如此构成的图一共最多有26个节点。每条边都代表一个单词，那么就转化成了：找一条路，遍历所有的边。就是欧拉通路问题。</p><p>遍历欧拉通路的方法：</p><p>确定一个起点（出度-入度=1，或者等于0（如果存在欧拉回路的话））</p><p>从起点开始深搜（首先要保证图中存在欧拉回路或者通路）</p><p>dfs(vid, eid)</p><p>其中vid表示当前搜到的点。eid表示当前搜到的边（一个点可能会有很多边）</p><p>对于每条边，都是等它搜索完了后，把它代表的内容（这里是单词）压入一个栈中。</p><p>最后深搜结束后，依次弹栈就是答案。</p><h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p><strong>DOOR MAN</strong></p><p>大意：给定N(&lt;=20)个房间,房间之间有门相隔，门的数目不超过100道，当前人在第M个房门，当前人每经过一道门的时候就把经过的门锁上，问有没有一条路可以使得我们走到第0个房门的时候所有的门都锁上了。 思路：我们可以把门看成是两个房间之间的边，那么问题可以转化成找一条欧拉路径。PS：判断的时候只要判断所有的边在一起就行了，所有的点不一定连通，当0点和M点不连通的时候，无解。注意这组数据。</p><h3 id="中国邮递员问题-CPP"><a href="#中国邮递员问题-CPP" class="headerlink" title="中国邮递员问题(CPP)"></a>中国邮递员问题(CPP)</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一个邮递员从邮局出发，要走完他所管辖范围内的每一条街道，至少一次再返回邮局，如何选择一条尽可能短的路线？这就是中国邮递员问题（CPP），其命名是因为中国数学家管梅谷在1962年首先提出了这个问题。如果用顶点表示交叉路口，用边表示街道，那么邮递员所管辖的范围可用一个赋权图来表示，其中边的权重表示对应街道的长度。 </p><h4 id="图论语言"><a href="#图论语言" class="headerlink" title="图论语言"></a>图论语言</h4><p>中国邮递员问题可用图论语言叙述为：在一个具有非负权的赋权连通图G中，找出一条权最小的环游。这种环游称为最优环游。若G是欧拉图，则G的任意欧拉环游都是最优环游，从而可利用弗勒里算法求解。若G不是欧拉图，则G的任意一个环游必定通过某些边不止一次。将边e的两个端点再用一条权为w(e)的新边连接时，称边e为重复的。此时CPP与下述问题等价，若G是给定的有非赋权的赋权连通图，</p><p>（1）用添加重复边的方法求G的一个欧拉赋权母图 <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D17/sign=f1b420a3edcd7b89ed6c3e840e244643/7acb0a46f21fbe094ed0e37d60600c338644adc8.jpg" alt="img"> ，使得  <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D76/sign=9ab06f680155b31998f9807342a9af83/2934349b033b5bb5fc9903973dd3d539b600bc08.jpg" alt="img"> 尽可能小； </p><p>（2）求  <img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D17/sign=f1b420a3edcd7b89ed6c3e840e244643/7acb0a46f21fbe094ed0e37d60600c338644adc8.jpg" alt="img"> 的欧拉环游。 </p><p>此图图论中和中国邮递员问题类似的是旅行商问题，区别于中国邮递员问题，旅行商问题是说在边赋权的完全图中找一个权和最小的哈密尔顿圈。</p><p>埃德蒙兹（J.Edmonds）和约翰逊（E.L.Johnson)在1973年给出了求解（1）的多项式时间算法。</p><p>如果邮递员所通过的街道都是单向道，则对应的图应为有向图。1973年，埃德蒙兹和约翰逊证明此时CPP也有多项式时间算法。帕帕季米特里屋（C.H.Papadimitrious）在1976年证明，如果既有双向道，又有单向道，则CPP是NP困难的。</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>由于每边至少遍历一次，所以最短路的瓶颈就在于重复遍历。由于图一直保持连通性，所以两两奇点之间都存在欧拉路；又两两奇点之间的最短路可求；奇点个数为偶数。所以问题就等价于找一个奇点构成的完全图G’(V,E)的最小权匹配(Perfect Matching in General Graph)。V(G’)为原图G中的奇点，每条边为两奇点对应原图的最短路长度。</p><h4 id="奇偶点图作业法"><a href="#奇偶点图作业法" class="headerlink" title="奇偶点图作业法"></a>奇偶点图作业法</h4><ol><li><p>确定G中的奇点，构成G’。</p></li><li><p>确定G’两两结点在G中的最短路作为它们在G’中的边权。</p></li><li><p>对G’进行最小权匹配。</p></li><li><p>最小权匹配里的各匹配边所对应的路径在G中被重复遍历一次,得到欧拉图G’’。</p></li><li><p>对G’’找一条欧拉路即可。</p></li></ol><p>有向的中国邮路问题，比较复杂。</p><h2 id="哈密顿图（H问题）"><a href="#哈密顿图（H问题）" class="headerlink" title="哈密顿图（H问题）"></a>哈密顿图（H问题）</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9C%88.png" alt=""></p><p>1857年，英国数学家汉密尔顿(Hamilton)提出了著名的汉密尔顿回路问题，其后，该问题进一步被发展成为所谓的“货郎担问题”，即赋权汉密尔顿回路最小化问题：这两个问题成为数学史上著名的难题。 </p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>汉密尔顿路：</strong>给定图G，若存在一条路，经过图中每个结点恰好一次，这条路称作汉密尔顿路。  </p><p><strong>汉密尔顿回路：</strong>给定图G，若存在一条回路，经过图中每个结点恰好一次，这条回路称作汉密尔顿回路。  </p><p><strong>汉密尔顿图：</strong>具有汉密尔顿回路的图，称作汉密尔顿图。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>必须说明，汉密尔顿回路问题是一个NP完全问题(NP-Complete)，也就是说，至今没有一个行之有效的多项式时间的算法能够找到这类问题的最优解，只有一些近似算法。关于NPC问题，我们这里不做讨论。我们一般情况下，直接用DFS进行搜索，当然，如果图的点比较多的时候(一般n&gt;10)，这个算法是不现实的。</p><h3 id="旅行商问题-TSP"><a href="#旅行商问题-TSP" class="headerlink" title="旅行商问题(TSP)"></a>旅行商问题(TSP)</h3><p><a href="https://baike.baidu.com/pic/%E4%B8%AD%E5%9B%BD%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98/11055168/0/d31b0ef41bd5ad6ea2c41f7288cb39dbb6fd3c6c?fr=lemma&amp;ct=single" target="_blank" rel="noopener"><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=ed589fa1bade9c82a265fe8d5c8080d2/d31b0ef41bd5ad6ea2c41f7288cb39dbb6fd3c6c.jpg" alt="img"></a></p><p>Traveling Salesman Problem，即旅行商问题， 旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值，这是一个NP难问题。 </p><p>TSP的历史很久，最早的描述是1759年欧拉研究的骑士周游问题，即对于国际象棋棋盘中的64个方格，走访64个方格一次且仅一次，并且最终返回到起始点。</p><p>TSP由美国RAND公司于1948年引入，该公司的声誉以及线形规划]这一新方法的出现使得TSP成为一个知名且流行的问题。</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>状压DP</p><h1 id="着色问题"><a href="#着色问题" class="headerlink" title="着色问题"></a>着色问题</h1><p>图的着色问题是由地图的着色问题引申而来的：用m种颜色为地图着色，使得地图上的每一个区域着一种颜色，且相邻区域颜色不同。问题处理：如果把每一个区域收缩为一个顶点，把相邻两个区域用一条边相连接，就可以把一个区域图抽象为一个平面图。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%9C%B0%E5%9B%BE%E9%97%AE%E9%A2%98.png" alt=""></p><p>通常所说的着色问题是指下述两类问题：</p><p>1．给定无环图G=(V,E)，用m种颜色为图中的每条边着色，要求每条边着一种颜色，并使相邻两条边有着不同的颜色，这个问题称为图的边着色问题。</p><p>2．给定无向图G=(V,E)，用m种颜色为图中的每个顶点着色，要求每个顶点着一种颜色，并使相邻两顶点之间有着不同的颜色，这个问题称为图的顶着色问题。</p><h2 id="边着色问题"><a href="#边着色问题" class="headerlink" title="边着色问题"></a>边着色问题</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>给图G的边着色，使得有共同顶点的边异色的最少颜色数，称为边色数。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E8%BE%B9%E7%9D%80%E8%89%B2%E5%9B%BE.png" alt=""></p><h4 id="妖怪图（snark-graph）"><a href="#妖怪图（snark-graph）" class="headerlink" title="妖怪图（snark graph）"></a>妖怪图（snark graph）</h4><p>妖怪图每个点都关联着3条边，用4种颜色可以把每条边涂上颜色，使得有公共端点的边异色，而用3种颜色办不到，切断任意3条边不会使它断裂成2个有边的图。</p><p><strong>单星妖怪和双星妖怪：</strong></p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E5%A6%96%E6%80%AA%E5%9B%BE.png" alt=""></p><h4 id="时间表问题；"><a href="#时间表问题；" class="headerlink" title="时间表问题；"></a>时间表问题；</h4><p>设x1,x2,…,xm为m个工作人员，y1,y2,…,yn表为n种设备，工作人员对设备提出要求，使用时间均假定以单位时间计算，自然每一个工作人员在同一个时间只能使用一种设备，某一种设备在同一时间里只能为一个工作人员使用，问应如何合理安排，使得尽可能短时间里满足工作人员的要求？       </p><p>问题转换为X={x1,x2,…,xm}，Y={y1,y2,…,yn}的二分图G，工作人员xi要求使用设备yj，每单位时间对应一条从xi到yj的边，这样所得的二分图过xi ，yj的边可能不止一条。问题变为对所得二分图G的边着色问题。有相同颜色的边可以安排在同一时间里。</p><h3 id="定理："><a href="#定理：" class="headerlink" title="定理："></a>定理：</h3><p>二分图G的边色数＝图中顶点的最大度。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E4%BA%8C%E5%88%86%E5%9B%BE%E8%BE%B9%E8%89%B2.png" alt=""></p><h4 id="定理-Vizing-1964-："><a href="#定理-Vizing-1964-：" class="headerlink" title="定理(Vizing 1964)："></a>定理(Vizing 1964)：</h4><p>若图G为简单图，图中顶点最大度为d，则G的边色数为d或d+1。</p><p><strong><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%B1%BB%E5%9B%BE.png" alt=""></strong></p><p>目前仍无有效区分(判别)任给定图属第几类图的有效方法。</p><h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>边的着色问题可以转化为顶点的着色问题。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-8-15-%E8%BE%B9%E7%82%B9%E7%9D%80%E8%89%B2.png" alt=""></p><h2 id="点着色问题"><a href="#点着色问题" class="headerlink" title="点着色问题"></a>点着色问题</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>给图G的顶点着色，使得相邻的顶点异色的最少颜色数，称为图G顶色数，简称色数；记作χ(G)。</p><h3 id="四色猜想："><a href="#四色猜想：" class="headerlink" title="四色猜想："></a>四色猜想：</h3><p>平面图的色数不大于5。</p><h3 id="色数的性质："><a href="#色数的性质：" class="headerlink" title="色数的性质："></a>色数的性质：</h3><p>（1）图G只有孤立点时，χ(G)=1；</p><p>（2）n个顶点的完全图G有χ(G)=n；</p><p>（3）若图G是n个顶点的回路，则χ(G)=2，        n为偶数。χ(G) =3，        n为奇数；</p><p>（4）图G是顶点数超过1的树时，χ(G)=2；</p><p>（5）若图G是二分图，则χ(G)=2。</p><h3 id="定理：-1"><a href="#定理：-1" class="headerlink" title="定理："></a>定理：</h3><p>图G=(V,E)的色数χ(G)=2的充要条件是：(1)|E|≥1；(2)G不存在边数为奇数的回路。</p><p>若图G=(V,E)，d=max{d(vi)},vi∈V，则χ(G)≤d+1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的连通性&quot;&gt;&lt;a href=&quot;#图的连通性&quot; class=&quot;headerlink&quot; title=&quot;图的连通性&quot;&gt;&lt;/a&gt;图的连通性&lt;/h1&gt;&lt;h2 id=&quot;连通图&quot;&gt;&lt;a href=&quot;#连通图&quot; class=&quot;headerlink&quot; title=&quot;连通图&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="欧拉图" scheme="http://qianyouyou.cn/tags/%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    
      <category term="哈密顿图" scheme="http://qianyouyou.cn/tags/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE/"/>
    
      <category term="连通图" scheme="http://qianyouyou.cn/tags/%E8%BF%9E%E9%80%9A%E5%9B%BE/"/>
    
      <category term="着色问题" scheme="http://qianyouyou.cn/tags/%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ccpc-wannafly秦皇岛站集训部分题解</title>
    <link href="http://qianyouyou.cn/2018/08/13/2018-08-12/"/>
    <id>http://qianyouyou.cn/2018/08/13/2018-08-12/</id>
    <published>2018-08-13T11:10:46.000Z</published>
    <updated>2018-08-15T02:35:43.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WANNAFLY-DAY1"><a href="#WANNAFLY-DAY1" class="headerlink" title="WANNAFLY_DAY1"></a>WANNAFLY_DAY1</h1><h2 id="Problem-A-Birthday"><a href="#Problem-A-Birthday" class="headerlink" title="Problem A. Birthday"></a>Problem A. Birthday</h2><p>恬恬的生日临近了。宇扬给她准备了一个大蛋糕。</p><p>正如往常一样，宇扬在蛋糕上插了n支蜡烛，并把蛋糕分为m个区域。因为某种原因，他必须把第i根蜡烛插在第ai个区域或第bi个区域。区域之间是不相交的。宇扬在一个区域内同时摆放x支蜡烛就要花费x2的时间。宇扬布置蛋糕所用的总时间是他在每个区域花的时间的和。</p><p>宇扬想快些见到恬恬，你能告诉他布置蛋糕最少需要多少时间吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数n，m（1 ≤ n ≤ 50， 2 ≤ m ≤ 50）。<br>接下来n行，每行两个整数ai, bi（1 ≤ ai, bi ≤ m）。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示答案</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>standard input<br>3 3<br>1 2<br>1 2<br>1 2</p><p>standard output</p><p>5</p><p>standard input </p><p>3 3<br>1 2<br>2 3<br>1 3</p><p>standard output</p><p>3</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>考虑费用流时把每个part拆成n个点，选择第i个点的代表为放置i块蛋糕和(i - 1)块蛋糕的时间差，这个时间差是增的，因此在费用流的过程中必定会从小到大选择<br>具体建图：左边n个点代表n个蛋糕，右边m * n个点代表m个part,每个part拆成n个点。源点向每个左边的点连一条流量1费用0的边，每个右边的点向汇点连一条流量1费用0的编。每个蛋糕向可以放的两个part的所有点连边，连向第i个点的费用为i^2 - (i - 1)^2，流量为1。这样求最小费用流既为答案。</p><h2 id="Problem-B-Board"><a href="#Problem-B-Board" class="headerlink" title="Problem B. Board"></a>Problem B. Board</h2><p>恬恬有一个n × n的数组。她在用这个数组玩游戏：</p><p>开始时，数组中每一个元素都是0。</p><p>恬恬会做某些操作。在一次操作中，她可以将某一行的所有元素同时加上一个值，也可以将某一列的所有元素同时加上一个值。</p><p>在几次操作后，一个元素被隐藏了。你能帮助她回忆隐藏的数是几吗？</p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n（1 ≤ n ≤ 1000）。<br>接下来n行每行n个整数表示数组a。<br>第(i + 1)行的第j个元素表示aij（aij = −1或0 ≤ aij ≤ 100000）。−1表示隐藏的元素</p><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>仅一个整数表示答案</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>3<br>1 2 1<br>0 -1 0<br>0 1 0</p><p> standard output</p><p>1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>把格子N染色，第i行第j列格子的颜色为(i + j) % N。那么每次操作时，必定是N种不同的颜色都有一格被操作到，因此最后任何颜色格子的和必定是相等的。因此只需要记录每种颜色格子的和，并算出缺失格子的颜色C，用其余颜色的和减去颜色C的和即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int x,y;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;map[i][j];</span><br><span class="line">if(map[i][j]==-1) </span><br><span class="line">&#123;</span><br><span class="line">x=i;</span><br><span class="line">y=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==x) continue;</span><br><span class="line">int minn=0x3f3f3f;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j]-=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==y) continue;</span><br><span class="line">int minn=0x3f3f3f;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,map[j][i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">map[j][i]-=minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans1=0,ans2=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(map[i][y]!=0 &amp;&amp; map[i][y]!=-1) ans1=map[i][y];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(map[x][i]!=0 &amp;&amp; map[x][i]!=-1) ans2=map[x][i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans1+ans2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C-Circle"><a href="#Problem-C-Circle" class="headerlink" title="Problem C. Circle"></a>Problem C. Circle</h2><p>现在我们要把1 . . . n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多。请输出最大对数。</p><h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>一行一个整数n(1 ≤ n ≤ 1000)。</p><h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>standard input </p><p>4</p><p>standard output<br>4</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>样例的一种构造方法为1 4 3 2。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为(i,i+1)=1且(1,n)=1，所以把1…n依次放进一个环，就可以啦。答案为n。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">while(cin&gt;&gt;t)&#123;</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-D-土龙弟弟"><a href="#Problem-D-土龙弟弟" class="headerlink" title="Problem D. 土龙弟弟"></a>Problem D. 土龙弟弟</h2><h2 id="Problem-E-Growth"><a href="#Problem-E-Growth" class="headerlink" title="Problem E. Growth"></a>Problem E. Growth</h2><p>弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。</p><p>为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a ≥ xi且b ≥ yi，则弱<br>弱在接下来的每一天都可以得到zi的分数。</p><p>问m天以后弱弱最多能得到多少分数。</p><h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>第一行一个两个整数n和m（1 ≤ n ≤ 1000，1 ≤ m ≤ 2000000000）。<br>接下来n行，每行三个整数xi，yi，zi（1 ≤ xi, yi ≤ 1000000000，1 ≤ zi ≤ 1000000）。</p><h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>2 4<br>2 1 10<br>1 2 20</p><p> standard output</p><p>50</p><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。<br>共获得0 + 0 + 20 + 30 = 50分</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>把奖励的x拿出来从小到大排序，得到x1,x2,…,xn。<br>把奖励的y拿出来从小到大排序，得到y1,y2,…,yn。<br>用v[i][j]表示a值到达xi，b值达到yi时接下来每天可以得到的奖励。<br>v[i][j] = v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1] + t[i][j]<br>其中t[i][j]为满足x=i，y=j的奖励的总和。<br>用f[i][j]表示a值达到xi，b值达到yj时已经拿到的奖励的最大值。<br>f[i][j] + (x[i + 1] - x[i] - 1) <em> t[i][j] + t[i + 1][j] -&gt; f[i + 1][j]<br>f[i][j] + (y[j + 1] - y[j] - 1) </em> t[i][j] + t[i][j + 1] -&gt; f[i][j + 1]<br>最后统计一下答案就可以了。</p><h2 id="Problem-F-Kingdom"><a href="#Problem-F-Kingdom" class="headerlink" title="Problem F. Kingdom"></a>Problem F. Kingdom</h2><p>X王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个<br>官员是这个上司的下属。上司的编号总比下属小。</p><p>我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力<br>是1。国王的影响力总是n。</p><p>任何一位有下属的官员总是选择他的下属中影响力最高的作为他的心腹（有若干下属影响力相同的话则<br>会选择编号最小的）。</p><p>一位官员得到一条消息后，他就要把消息传达给国王。我们定义一位官员的花费为他将消息传达给国王<br>的花费。国王自己的花费为0。如果一位官员是他上司的心腹，则他的花费等于他上司的花费，否则他<br>的花费为他上司的花费加1。</p><p>由于时代和平，消息并不需要传递的太快。我们希望你决定每位官员（除了国王）的上司，使得所有官<br>员的花费之和和尽量小。</p><h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>一个整数n（1 ≤ n ≤ 8000）表示包括国王在内的官员的总数。</p><h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示最大的花费之和。</p><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>4</p><p> standard output</p><p>2</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>f[i]代表i个点时的答案，g[i][j]代表若干颗树加起来，size和为i，每棵树size&lt;=j时，这些树的代价和最大是多少<br>从1到n枚举i，在i固定时枚举心腹的影响力大小更新f[i]，然后用类似背包的思路更新g[i][1]~g[i][i]<br>复杂度O(N^2)</p><h2 id="Problem-G-Matrix"><a href="#Problem-G-Matrix" class="headerlink" title="Problem G. Matrix"></a>Problem G. Matrix</h2><p>弱弱有一个n × m的矩阵，第i行第j列位置上的值为aij。<br>弱弱定义以(x, y)为顶点，大小为k的三角形为：</p><p>第x行y位置，<br>第x + 1行y − 1，y，y + 1位置，<br>. . .，<br>第x + k − 1行y − k + 1，. . .，y + k − 1位置组成的区域。</p><p>比如说，以(1, 3)为顶点，大小为3的三角形为</p><p>OOXOOOO<br>OXXXOOO<br>XXXXXOO<br>OOOOOOO<br>中打叉的位置。</p><p>现在弱弱想要知道所有大小为k的三角形中，重心位置离顶点最近的是哪个？重心是三角形中每个位置<br>按照它们的值加权平均所得的点。<br>请输出这个最小距离（欧几里得距离）。</p><h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>第一行一个三个整数n，m，k（1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，1 ≤ k ≤ min n,(m + 1)/2</p><p>接下来n行，每行m个整数aij（1 ≤ aij ≤ 1000）表示每个位置的重量。</p><h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>一行一个数表示答案。相对误差或绝对误差在10−5（1e-5）之内均会被判断为正确。</p><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>2 3 2<br>1 1 1<br>1 1 1</p><p>standard output</p><p>0.7500000000</p><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>只有一个大小为2的三角形。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>w个格子的重心的坐标为（∑xi<em>wi / ∑wi, ∑yi</em>wi / ∑wi)。<br>那么其实我们只要维护∑xi<em>wi，∑yi</em>wi，∑wi就可以了。<br>假设我们现在有一个顶点为(x, y)的三角形，我们想要推到顶点为(x, y+1)的三角形，观察两者之间的差异，会发现在推过去的过程中，其实就是删去了一个斜条，又加入了一个斜条。<br>同理，从(x, y)到(x+1, y)其实只是删去了两个斜条，加上了底上的横条，而这些关键的值都是可以通过前缀和的方法维护。</p><h2 id="Problem-H-Mountain"><a href="#Problem-H-Mountain" class="headerlink" title="Problem H. Mountain"></a>Problem H. Mountain</h2><p>平面上有n座山，每座山都有左右两面，第i座山的高度为ai，现在弱弱在第一座山的左边山脚下（高度为0），他想要依此爬过这些山，到达第n座山的右边山脚下。</p><p>除了简单的爬上爬下，还有一种特殊操作。</p><p>如果弱弱目前在第i座山右面的海拔x的位置，且第j(i &lt; j)座山的海拔大于等于x，且第i + 1, . . . , j − 1座山中没有一座山的海拔高于x，那么他可以使用绳索滑到第j座山左面海拔x的位置。</p><p>弱弱想找到一种方式，使得他在行程中海拔变化的幅度最小。请输出最小幅度。</p><h3 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n（1 ≤ n ≤ 1000）。<br>接下来一行n个整数ai（1 ≤ ai ≤ 1000）表示每座山的高度。</p><h3 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数表示答案。</p><h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h3><p>standard input<br>5<br>1 3 5 4 2</p><p>standard output</p><p>10</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>考虑山中最高的一座，最优操作一定是从第一座山的左下角开始不停地往上爬，然后从最高的山不停地往下爬爬到最后一座山的右下角。<br>所以答案为最高山的高度*2。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1007], n;</span><br><span class="line">int main()&#123;</span><br><span class="line"> while(cin&gt;&gt;n)&#123;</span><br><span class="line">  int cnt = 0;</span><br><span class="line">  a[0] = 0;</span><br><span class="line">  int cur = 0;</span><br><span class="line">  for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">   cin&gt;&gt;a[i];</span><br><span class="line">   if(a[i] &gt;= a[cur])&#123;</span><br><span class="line">    cnt += abs(a[i] - a[cur]);</span><br><span class="line">    cur = i;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while(cur&lt;n)&#123;</span><br><span class="line">   int cur2 = cur+1;</span><br><span class="line">   for(int i = cur2;i&lt;=n;i++)&#123;</span><br><span class="line">    if(a[i] &gt;= a[cur2])&#123;</span><br><span class="line">     cur2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cnt+=abs(a[cur2]-a[cur]);</span><br><span class="line">   cur = cur2;</span><br><span class="line">  &#125;</span><br><span class="line">  cnt+=a[n];</span><br><span class="line">  cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-I-清明梦超能力者黄"><a href="#Problem-I-清明梦超能力者黄" class="headerlink" title="Problem I. 清明梦超能力者黄"></a>Problem I. 清明梦超能力者黄</h2><p>黄YY是一个清明梦超能力者，同时也是一个记忆大师。他能够轻松控制自己在梦中的一切，在醒来之<br>后还能清晰的记得梦中所有的细节，这让他的朋友们都十分羡慕。</p><p>又是一个晚上，黄YY又到了自己的梦中，并且随手造出了一棵有n个点的树，树上每个点有一个初始颜<br>色0。为了让这棵树不那么单调，黄YY拿起了画笔在上面尽情上色。每一次上色可以用u, v, c来描述，代<br>表黄YY把u, v这条路径上的点都染色成了c。</p><p>正当黄YY开心的完成了m次染色，准备在早上醒来之时向朋友们炫耀。但现实中的黄YY由于过于兴奋<br>滚到了床下，撞到了脑袋，在剧痛中醒来。由于脑部受到了严重创伤，黄YY对刚才梦境中发生的一切<br>发生了严重的信息丢失。</p><p>但英俊潇洒的黄YY当然不希望自己的窘态被朋友们发现。为了证明自己还是那个清明梦超能力者，他<br>希望告诉朋友们自己上色后每个节点的颜色。同时为了更进一步证明他还是个记忆大师，他希望干脆直<br>接说出每个点在倒数第k次染色时的颜色。</p><p>当然，现在的黄YY已经成了弱智了，作为黄YY最亲密的朋友，你快来帮帮黄YY吧！</p><h3 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h3><p>第一行三个整数n, m, k，代表树的点数，黄YY染色的次数，以及最后求颜色时，倒数的次数<br>（1 ≤ n, m, k ≤ 100000）。</p><p>接下来n − 1行，每行u, v代表u, v两点之间有一条边。这里保证1 ≤ u, v ≤ n，且无重边与自环，是一棵<br>标准的树。</p><p>接下来m行，每一行三个数字u, v, c代表黄YY在第这次用c颜色的画笔从u涂到了v。</p><h3 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h3><p>一行n个数字，输出每个点倒数第k次染色时的颜色。如果本身不足k次，输出0。</p><h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h3><p>standard input </p><p>3 3 2</p><p>1 2</p><p>2 3</p><p>1 2 1</p><p>2 3 2</p><p>1 3 3</p><p>standard output</p><p>1 2 2</p><h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p>对于点1在第一次和第三次染色的时候分别被染色为1, 3，倒数第二次的颜色就是1。</p><p>对于点2在第一、二、三次染色的时候分别被染色为1, 2, 3，倒数第二次的颜色就是2。</p><p>对于点3在第二次和第三次染色的时候分别被染色为2, 3，倒数第二次的颜色就是2。</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>首先每条路径从LCA处分开可以拆成两条链<br>假设链A-&gt;B执行了第i次染色操作，假设A是B的祖先，那么我们在B点加入一个”插入i”的事件，在A的父亲点加入一个”删除i”的事件<br>然后dfs整颗树求解，每个点维护一个线段树。处理一个点时先合并所有儿子的线段树，然后再处理这个点上的事件，得到线段树之后询问第K大值既可得到答案。<br>复杂度分析：<br>Node<em> merge(Node</em> a, Node* b) {<br>    if (a == NULL) return b;<br>    if (b == NULL) return a;<br>    a-&gt;sum += b-&gt;sum;<br>    a-&gt;child[0] = merge(a-&gt;child[0], b-&gt;child[0]);<br>    a-&gt;child[1] = merge(a-&gt;child[1], b-&gt;child[1]);<br>    return a;<br>}<br>考虑以上的线段树合并，每次合并会减少一个区间。而在事件点插入、删除的时候会产生至多log个区间，因此复杂度为O(NLogN)</p><h2 id="Problem-J-最短路"><a href="#Problem-J-最短路" class="headerlink" title="Problem J. 最短路"></a>Problem J. 最短路</h2><p>给一个连通图，每次询问两点间最短路。每条边的长度都是1。</p><h3 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数n和m，表示图的点数和边数（1 ≤ n ≤ 100000, 1 ≤ m ≤ n + 100）。</p><p>接下来m行每行两个整数a和b，表示一条边（1 ≤ a, b ≤ n）。保证没有自环和重边。保证图连通。</p><p>接下来一个整数q表示询问的个数（1 ≤ q ≤ 100000）。</p><p>接下来q行每行两个整数a和b表示询问a和b之间的最短路。</p><h3 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h3><p>每个询问输出一行表示答案</p><h3 id="Example-7"><a href="#Example-7" class="headerlink" title="Example"></a>Example</h3><p>input</p><p>4 5<br>1 2<br>2 3<br>1 4<br>4 3<br>2 4<br>4<br>1 4<br>1 2<br>2 4<br>1 3</p><p>output</p><p>1<br>1<br>1<br>2</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>本题十分直接。我们不断地把度数为1的点删掉，把度数为2的点收缩，最后会得到一个图，和原图的点数与边数之差相同，且新图中每个点的度数都至少是3。这就是说我们会得到一个200个点300条边以内的图。新图可以用Floyd算法预处理所有点对之间最短路。询问时，将询问转化到新图上即可。转化时需要注意细节。</p><h1 id="WANNAFLY-DAY2"><a href="#WANNAFLY-DAY2" class="headerlink" title="WANNAFLY_DAY2"></a>WANNAFLY_DAY2</h1><h2 id="Problem-A-Tobaku-Mokushiroku-Kaiji"><a href="#Problem-A-Tobaku-Mokushiroku-Kaiji" class="headerlink" title="Problem A. Tobaku Mokushiroku Kaiji"></a>Problem A. Tobaku Mokushiroku Kaiji</h2><p>开司正在与另外一人玩石头剪刀布。双方各有一些代表石头、剪刀、布的卡牌，每局两人各出一张卡<br>牌，根据卡牌的内容决定这一局的胜负。胜负规则为：石头赢剪刀、剪刀赢布、布赢石头、相同为平<br>局。每张卡牌至多被使用一次。<br>已知双方的卡牌数量，问开司最多赢几局？</p><h3 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h3><p>一行六个数字a, b, c, d, e, f(0 ≤ a, b, c, d, e, f ≤ 50)，a, b, c分别表示开司的石头、剪刀、布的牌的数<br>量，d, e, f分别表示此时另一人的石头、剪刀、布的牌的数量。</p><h2 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h2><p>一个整数表示开司最多赢几局</p><h3 id="Example-8"><a href="#Example-8" class="headerlink" title="Example"></a>Example</h3><p>in</p><p>29 7 41 14 12 42</p><p>out</p><p>33</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[6];</span><br><span class="line">for(int i = 0;i&lt;6;i++)</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">cout&lt;&lt;min(a[0],a[4])+min(a[1],a[5])+min(a[2],a[3])&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-E-Eustia-of-the-Tarnished-Wings"><a href="#Problem-E-Eustia-of-the-Tarnished-Wings" class="headerlink" title="Problem E. Eustia of the Tarnished Wings"></a>Problem E. Eustia of the Tarnished Wings</h2><p>Novus Aither是一个潜藏着多个势力的城市。每个势力都有一个唯一的领导人，每个领导人有一个属性<br>值。如果两个势力的领导人的属性值分别为a, b，且|a − b| ≤ m，说明这两个领导人的思想有一定的相似<br>之处，这两个势力可以合并，新的领导人可以指定为原来的两个领导人中的任意一个。新产生的势力可<br>以依照相同的的规则，继续与其他势力合并。问在所有可能的合并情况中，最少会剩下几个势力。</p><h3 id="Input-10"><a href="#Input-10" class="headerlink" title="Input"></a>Input</h3><p>第一行两个空格隔开的整数n(1 ≤ n ≤ 106<br>), m(0 ≤ m109<br>)。n代表当前势力的个数。m的含义如题目描<br>述。<br>第二行n个空格隔开的整数di(0 ≤ di ≤ 109<br>)，代表第i个势力的领导人的属性值。</p><h3 id="Output-10"><a href="#Output-10" class="headerlink" title="Output"></a>Output</h3><p>输出一个数表示势力的最少数量。</p><p>Example<br>standard input<br>4 1<br>2 1 3 10</p><p>standard output</p><p>2</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const int maxn = 1e6+7;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">ll n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">int cnt = 1;</span><br><span class="line">for(int i = 1;i&lt;n;i++)&#123;</span><br><span class="line">if(a[i]-a[i-1]&gt;m)</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY3"><a href="#WANNAFLY-DAY3" class="headerlink" title="WANNAFLY_DAY3"></a>WANNAFLY_DAY3</h1><h2 id="Problem-D-Shopping"><a href="#Problem-D-Shopping" class="headerlink" title="Problem D. Shopping"></a>Problem D. Shopping</h2><p>你要买n件物品，其中有一些是凳子。<br>商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个<br>物品。<br>你有m辆购物车，请最小小化你的花费。</p><h3 id="Input-11"><a href="#Input-11" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数t表示数据组数(1 ≤ t ≤ 100)。</p><p>每组数据第一行两个整数n, m (1 ≤ n, m ≤ 1000)，接下来n行每行两个整数ai<br>, bi，分别表示第i件物品的<br>价格以及它是否是凳子(1 ≤ ai ≤ 105<br>, 0 ≤ bi ≤ 1)。</p><h3 id="Output-11"><a href="#Output-11" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出一行一个实数表示最小花费，保留一位小数。</p><p>Example<br>stdin<br>2<br>5 1<br>1 0<br>2 1<br>3 1<br>4 0<br>5 0<br>5 10<br>1 0<br>2 1<br>3 1<br>4 0<br>5 0</p><p>stdout</p><p>12.5<br>10.5</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">const int maxn = 1007;</span><br><span class="line">struct node&#123;</span><br><span class="line">double cost;</span><br><span class="line">int flag;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">int cmp(node a,node b)&#123;</span><br><span class="line">return a.cost&gt;b.cost;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">int cnt = 0;</span><br><span class="line">double all = 0;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].cost;</span><br><span class="line">cin&gt;&gt;a[i].flag;</span><br><span class="line">if(a[i].flag==1)</span><br><span class="line">cnt++;</span><br><span class="line">all+=a[i].cost;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt&gt;m)</span><br><span class="line">cnt = m;</span><br><span class="line">sort(a,a+n,cmp);</span><br><span class="line">for(int i = 0;i&lt;cnt;i++)&#123;</span><br><span class="line">all-=(a[i].cost/2.0);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.1lf\n&quot;,all);</span><br><span class="line">&#125;</span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY4"><a href="#WANNAFLY-DAY4" class="headerlink" title="WANNAFLY_DAY4"></a>WANNAFLY_DAY4</h1><h2 id="7-贵族用户"><a href="#7-贵族用户" class="headerlink" title="7 贵族用户"></a>7 贵族用户</h2><p>终于活成了自己讨厌的样子。<br>充钱能让你变得更强。</p><p>在暖婊这个游戏里面，如果你充了 x 元钱，那么你能获得 10x 个钻石。同时暖婊也有 m 档VIP，如果你往暖婊里面充了 ai 个钻石，那么你能成为第 i 档贵族用户。当你成为为第 i 档贵族用户。当你成为第 i 档贵族用户之后，那么你可以获得 pi% 的优惠。</p><p>你需要 k 件材料合成衣服，其中第 i 件材料原价为 di 个钻石，你一共需要 ci 件这种材料。<br>当你获得 p 的优惠时，这个材料的真实价格为 ⌈di(1 − p)⌉。<br>请问栗子米最少需要氪多少钱，这里我们规定只能氪整数的钱。</p><h3 id="7-2-输入格式"><a href="#7-2-输入格式" class="headerlink" title="7.2 输入格式"></a>7.2 输入格式</h3><p>第一行一个整数 T(T ≤ 1000)，表示数据组数。<br>每组数据第一行两个整数 m, k(1 ≤ m, k ≤ 15)。</p><p>接下来 m 行每行两个正整数 1 ≤ ai ≤ 105<br>, 1 ≤ pi ≤ 100，保证 ai &lt; ai+1, pi ≤ pi+1。<br>接下来 k 行每行两个正整数 1 ≤ ci<br>, di ≤ 1000。</p><h3 id="7-3-输出格式"><a href="#7-3-输出格式" class="headerlink" title="7.3 输出格式"></a>7.3 输出格式</h3><p>对于每组数据，输出一个整数，表示至少要氪多少钱。</p><h3 id="7-4-样例输入"><a href="#7-4-样例输入" class="headerlink" title="7.4 样例输入"></a>7.4 样例输入</h3><p>1<br>1 1<br>100 100<br>100 100</p><h3 id="7-5-样例输出"><a href="#7-5-样例输出" class="headerlink" title="7.5 样例输出"></a>7.5 样例输出</h3><p>10</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">int a;</span><br><span class="line">int p;</span><br><span class="line">&#125;vip[20];</span><br><span class="line">struct cost&#123;</span><br><span class="line">int cc;</span><br><span class="line">int dd;</span><br><span class="line">&#125;dim[20];</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;k;</span><br><span class="line">for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">cin&gt;&gt;vip[i].a&gt;&gt;vip[i].p;</span><br><span class="line">if(vip[i].a%10)</span><br><span class="line">vip[i].a+=10-(vip[i].a%10);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">cin&gt;&gt;dim[i].cc&gt;&gt;dim[i].dd;</span><br><span class="line">ans+=dim[i].cc*dim[i].dd;</span><br><span class="line">&#125;</span><br><span class="line">if(ans%10)</span><br><span class="line">ans+=10-(ans%10);</span><br><span class="line">int minx = ans;</span><br><span class="line">for(int u = 0;u&lt;m;u++)&#123;</span><br><span class="line">int ans2 = 0;</span><br><span class="line">for(int i = 0;i&lt;k;i++)&#123;</span><br><span class="line">ans2 += dim[i].cc*(ceil((1-((double)vip[u].p/100.0))*dim[i].dd));</span><br><span class="line">&#125;</span><br><span class="line">if(ans2%10)&#123;</span><br><span class="line">ans2+=10-(ans2%10);</span><br><span class="line">&#125;</span><br><span class="line">if(ans2&lt;=vip[u].a)&#123;</span><br><span class="line">ans2 = vip[u].a;</span><br><span class="line">&#125;</span><br><span class="line">minx = min(minx,ans2);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;minx/10&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY6"><a href="#WANNAFLY-DAY6" class="headerlink" title="WANNAFLY_DAY6"></a>WANNAFLY_DAY6</h1><h2 id="F平衡二叉树"><a href="#F平衡二叉树" class="headerlink" title="F平衡二叉树"></a>F平衡二叉树</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1%60_0EI$RPOB1E$BDXEDC2%25W.png" alt=""></p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 70;</span><br><span class="line">ll n,d;</span><br><span class="line">ll a,b;</span><br><span class="line">ll c[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;d;</span><br><span class="line">a = 1;</span><br><span class="line">b = 0;</span><br><span class="line">memset(c,0,sizeof(c));</span><br><span class="line">for(int i = 0;i&lt;n-1;i++)</span><br><span class="line">a*=2;</span><br><span class="line">a-=1;</span><br><span class="line">for(int i = 0;i&lt;=d;i++)&#123;</span><br><span class="line">c[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">c[d+1] = 2;</span><br><span class="line">for(int i = d+2;i&lt;n-1-d;i++)&#123;</span><br><span class="line">c[i] = c[i-1]+c[i-d-1];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0;i&lt;n-1-d;i++)</span><br><span class="line">b+=c[i];</span><br><span class="line">cout&lt;&lt;a-b&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H卡牌游戏"><a href="#H卡牌游戏" class="headerlink" title="H卡牌游戏"></a>H卡牌游戏</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1%25%7B0%29ORKZ_W%29T4%7B3$FKU3R9.png" alt=""></p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">for(int u = 1;u&lt;=t;u++)&#123;</span><br><span class="line">long double x,y;</span><br><span class="line">int z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">cin&gt;&gt;z;</span><br><span class="line">printf(&quot;Case #%d: &quot;,u);</span><br><span class="line">long double ans = 0;</span><br><span class="line">for(int i = 0;i&lt;z;i++)&#123;</span><br><span class="line">ans += x/y;</span><br><span class="line">x--;</span><br><span class="line">y--;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%Lf\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WANNAFLY-DAY7"><a href="#WANNAFLY-DAY7" class="headerlink" title="WANNAFLY_DAY7"></a>WANNAFLY_DAY7</h1><h2 id="A-机器学习"><a href="#A-机器学习" class="headerlink" title="A.机器学习"></a>A.机器学习</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/7WIGFX9JGWV%5DBD0A9XRS%5DG8.png" alt="http://p7woygi8q.bkt.clouddn.com/7WIGFX9JGWV%5DBD0A9XRS%5DG8.png"></p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">double n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">printf(&quot;%.2lf\n&quot;,n);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D最小生成树"><a href="#D最小生成树" class="headerlink" title="D最小生成树"></a>D最小生成树</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/3XW5G5R%7DEQ~Y6M%25%5BM4G6O1T.png" alt=""></p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ll minx = 0x3fffffff;</span><br><span class="line">ll sum = 0;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">minx = min(minx,a[i]);</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">sum += minx*(n-1);</span><br><span class="line">sum-=minx;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;endl;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G区间权值"><a href="#G区间权值" class="headerlink" title="G区间权值"></a>G区间权值</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1UEZSLL%25IWJN7N%60%7D~ID$R%5DQ.png" alt=""></p><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e7+7;</span><br><span class="line">const int maxn = 300007;</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">ll a[maxn] = &#123;0&#125;;</span><br><span class="line">ll w[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpa[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpb[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpl[maxn] = &#123;0&#125;;</span><br><span class="line">ll dpr[maxn] = &#123;0&#125;;</span><br><span class="line">int n;</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">int tmp = min(i,n-i+1);</span><br><span class="line">dpb[i] = tmp*dpa[n]%mod;</span><br><span class="line">dpb[i] -= dpl[tmp-1];</span><br><span class="line">dpb[i] -= dpr[n-tmp+2];</span><br><span class="line">dpb[i]%=mod;</span><br><span class="line">dpb[i] *= w[i];</span><br><span class="line">dpb[i]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">dpa[i] = a[i];</span><br><span class="line">dpa[i]+=dpa[i-1];</span><br><span class="line">dpa[i]%=mod;</span><br><span class="line">dpl[i] = dpl[i-1];</span><br><span class="line">dpl[i]+=dpa[i];</span><br><span class="line">dpl[i]%=mod;</span><br><span class="line">&#125; </span><br><span class="line">dpr[n+1] = 0;</span><br><span class="line">for(int i = n;i&gt;=1;i--)&#123;</span><br><span class="line">dpr[i] = dpr[i+1];</span><br><span class="line">dpr[i]+=dpa[n]-dpa[i-1];</span><br><span class="line">dpr[i]%=mod;</span><br><span class="line">&#125; </span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;w[i];</span><br><span class="line">&#125;</span><br><span class="line">ll ans = 0;</span><br><span class="line">init();</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=dpb[i];</span><br><span class="line">ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="I联通块计数"><a href="#I联通块计数" class="headerlink" title="I联通块计数"></a>I联通块计数</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1K%7DH9GVNQ5%2943T$8IZ3HUY7.png" alt=""></p><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e7+7;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const ll mod = 998244353;</span><br><span class="line">int n;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">dp[i] = a[i];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">if(i&gt;0)&#123;</span><br><span class="line">dp[i]*=dp[i-1];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">dp[i]+=a[i];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">dp[i]+=dp[i-1];</span><br><span class="line">dp[i]%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ll ans = 1;</span><br><span class="line">for(int i = 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">ans+=(a[i]*(a[i]+1)/2)%mod;</span><br><span class="line">ans%=mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line">if(n&gt;0)&#123;</span><br><span class="line">ans+=dp[n-1];</span><br><span class="line">ans%=mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans%mod&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J寻找复读机"><a href="#J寻找复读机" class="headerlink" title="J寻找复读机"></a>J寻找复读机</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/1GP5%60K5WW_NQ%60S%5B4GR8T%5B%29Y.png" alt=""></p><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n,m;</span><br><span class="line">int vis[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">string str1, tmp;</span><br><span class="line">int d;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">cin&gt;&gt;d;</span><br><span class="line">cin&gt;&gt;tmp;</span><br><span class="line">if(str1==tmp)&#123;</span><br><span class="line">if(vis[d]!=-1)</span><br><span class="line">vis[d]++;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">vis[d]=-1;</span><br><span class="line">&#125;</span><br><span class="line">str1 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int flag = 0;</span><br><span class="line">for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">if(vis[i]!=-1)&#123;</span><br><span class="line">if(flag==0)&#123;</span><br><span class="line">cout&lt;&lt;i;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&apos; &apos;&lt;&lt;i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WANNAFLY-DAY1&quot;&gt;&lt;a href=&quot;#WANNAFLY-DAY1&quot; class=&quot;headerlink&quot; title=&quot;WANNAFLY_DAY1&quot;&gt;&lt;/a&gt;WANNAFLY_DAY1&lt;/h1&gt;&lt;h2 id=&quot;Problem-A-Birthday&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="wannafly" scheme="http://qianyouyou.cn/tags/wannafly/"/>
    
      <category term="CCPC" scheme="http://qianyouyou.cn/tags/CCPC/"/>
    
  </entry>
  
  <entry>
    <title>7.26图论基础专项训练题解</title>
    <link href="http://qianyouyou.cn/2018/07/26/2018-07-26/"/>
    <id>http://qianyouyou.cn/2018/07/26/2018-07-26/</id>
    <published>2018-07-26T14:22:06.000Z</published>
    <updated>2018-08-18T04:05:29.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-A-签到题之青蛙爬楼梯"><a href="#问题-A-签到题之青蛙爬楼梯" class="headerlink" title="问题 A: 签到题之青蛙爬楼梯"></a>问题 A: 签到题之青蛙爬楼梯</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 117  解决: 37<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=0&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1784" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1784&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1784&amp;getkey=3D275E187A" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1784" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>楼梯有n阶台阶，青蛙每次可以跳1~n阶台阶，问青蛙共有多少种上楼梯的方法。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入仅一行，一个整数n（n&lt;=50）</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出n阶台阶对应上楼梯的方法。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题作为水题，不作为图论题。样例提示（1，1，1），（1，2），（2，1），（3）共4种方法</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第n阶台阶，我们可以从n-1跳到n，可以从n-2跳到n……可以从1跳到n，也可以从0跳到n。那么要求第n阶的数量，只需求前n-1阶，前n-2阶……前1阶的方法，所以我们列出关系式为F(n)=F(n-1)+F(n-2)+……+F(1)+1。同理，第n-1阶的关系式为F(n-2)+F(n-3)+……+F(1)+1。两个式子合并得F(n)=2*F(n-1)。由于F(1)=1,所以F(n)=2^(n-1)。</p><h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    ll a = pow(2,n-1);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-排名"><a href="#问题-B-排名" class="headerlink" title="问题 B: 排名"></a>问题 B: 排名</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 60  解决: 24<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1785" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1785&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1785&amp;getkey=40F8E5A0BF" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1785" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 N 个比赛队（1&lt;=N&lt;=500），编号依次为 1，2，3……N 进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即 P1 赢 P2，用 P1，P2 表示，排名时 P1 在 P2之前。现在请你编程序确定排名。</p><p>符合条件的排名可能不是唯一的。此时要求输出时编号小的队伍在前。输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>输入有若干组。每组中的第一行为二个数N（1&lt;=N&lt;=500）。M；当中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中。每行也有两个整数P1。P2表示即P1队赢了P2队。</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>给出一个符合要求的排名。输出时队伍号之间有空格。最后一名后面没有空格。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 4</span><br><span class="line">4 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>拓扑排序模板题，唯一可能出现问题的地方就是题目要求同样拓扑序的两个编号小的要在前面，这点可以通过将普通拓扑排序中的队列改为使用优先队列或者堆来实现。</p><h2 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line">int graph[maxn][maxn];//保存图</span><br><span class="line">int degree[maxn];//保存入度</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(graph,0,sizeof(graph));</span><br><span class="line">        memset(degree,0,sizeof(degree));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            if(!graph[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                graph[u][v]=1;</span><br><span class="line">                degree[v]++;//的入度++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(degree[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        bool first=1;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur=q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(first)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;cur;</span><br><span class="line">                first=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot; &quot;&lt;&lt;cur;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(graph[cur][i]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    degree[i]--;//相连的点的入度减1</span><br><span class="line">                    if(degree[i]==0)//假设入度为0，增加队列</span><br><span class="line">                        q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-系兄弟就来砍我"><a href="#问题-C-系兄弟就来砍我" class="headerlink" title="问题 C: 系兄弟就来砍我"></a>问题 C: 系兄弟就来砍我</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 34  解决: 10<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1787" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1787&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1787&amp;getkey=584D6A6FD5" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1787" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>渣渣灰因为一句“大家好，我系渣渣辉，系兄弟就来砍我”引得众粉丝纷纷拿两米长的大刀寻找。现有n个据点，编号（1~n），有m条单向路使据点相连。每个据点仅有一个人。这n个人中有k个粉丝。其中渣渣灰在s据点处。请问这k个粉丝到渣渣灰的最短距离是多少</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>首行输入nmks。(k&lt;=n&lt;=100m&lt;=500)s为渣渣灰所在位置</p><p>接下来m行，每行输入xyz，表示从x到y的距离是z，由于是单向边，则y到x的距离不一定是z。</p><p>接下来k个数字，表示粉丝所在据点。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>对于每一个粉丝，输出对应的最短距离。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3 2 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据保证k个粉丝均能到达渣渣灰的据点</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先，既然要求k个点到s点的最短路，我们可以反过来求s到这k个点的最短路。这样就变成了单源最短路问题，dijkstra算法和spfa算法都可以做。由于图为有向图，我们在存图时反向存图即可，原本a[i][j]表示i-&gt;j，我们可以将它重新定义为j-&gt;i，或者存图时直接写成a[j][i]即可。</p><h2 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 107;</span><br><span class="line">const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷inf</span><br><span class="line">int n,m,k,s;</span><br><span class="line">int dis[maxn];  //储存各个点到源点的最短距离,dis[s]为0</span><br><span class="line">int road[maxn][maxn];   //两点之间直接距离关系</span><br><span class="line">bool vis[maxn];     //判断源点到该点的距离是否为最短距离</span><br><span class="line">int fans[maxn];</span><br><span class="line">void dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)</span><br><span class="line">            &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    memset(road,inf,sizeof(road));</span><br><span class="line">    for(int i = 1; i&lt;=m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp;</span><br><span class="line">        int x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;tmp;</span><br><span class="line">        road[y][x]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    for(int i = 0; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;fans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i&lt;k-1; i++)</span><br><span class="line">        cout&lt;&lt;dis[fans[i]]&lt;&lt;&apos; &apos;;</span><br><span class="line">    cout&lt;&lt;dis[fans[k-1]]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-躁动的小Z"><a href="#问题-D-躁动的小Z" class="headerlink" title="问题 D: 躁动的小Z"></a>问题 D: 躁动的小Z</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 7  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1669" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1669&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:外部导入][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1669&amp;getkey=F81CC9CF2B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1669" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>你猜怎么样？小Z追到Gakki了！Gakki邀请小Z去她家共进晚餐，小Z喜出望外。小Z的家和Gakki的家隔着几个街区，所以他决定乘坐公交车前往</p><p>Gakki家赴约。小Z的家在公交站台的起始站（编号为1），而Gakki家正好在末站（编号为n）。城市中有许多公交站台，有些站台之间可以通过公交</p><p>线路互相到达。现在给你n个公交站台和m条不同的公交线路的时间花费，请你帮助小Z分析一下最短的可以从家里来到Gakki身边的路径？</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>有多组测试样例。</p><p>第一行两个正整数n,m(2≤n≤10^5,0≤m≤10^5)，代表站台数与公交线路数量。</p><p>接下来m行每行三个正整数a[i],b[i],w[i],代表从公交站a[i]到b[i]需要花费的时间为w[i]。(1≤a[i],b[i]≤n,1≤w[i]≤10^6)</p><p>注意：公交线路可能会产生环，并且两个站台之间可能有多条公交线路。</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>单独一行，输出花费时间最小时小Z经过的公交站台编号，以空格隔开；如果小Z无法到达Gakki的家，则输出-1.</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 2 2</span><br><span class="line">2 5 5</span><br><span class="line">2 3 4</span><br><span class="line">1 4 1</span><br><span class="line">4 3 3</span><br><span class="line">3 5 1</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 3 5</span><br></pre></td></tr></table></figure><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>半年前写的代码。其实原理很简单，在dijkstra算法模板的基础上加上一个pre数组，用于记录该节点的上一个节点，即该点是经过哪一点才到达该点的。pre数组具体在边松弛的过程中进行重新赋值，松弛成功就将pre值记录k点，及该点是由起点经过k点后所得到的。最后把pre数组中的值递归输出一遍即可。</p><h2 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 900000</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">int d; </span><br><span class="line">int pre;</span><br><span class="line">&#125;path;</span><br><span class="line">path to[1000 + 2];</span><br><span class="line">int g[1000 + 2][1000 + 2], vis[1000 + 2]; </span><br><span class="line">void fun(int ddd) &#123;</span><br><span class="line">if (ddd == 1) &#123;</span><br><span class="line">printf(&quot;%d&quot;, ddd);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int j= to[ddd].pre;</span><br><span class="line">fun(j);</span><br><span class="line">printf(&quot; %d&quot;, ddd);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m, a, b, v, i, j, min, k, from;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; </span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">for (j = 0; j &lt;= n; j++) &#123;</span><br><span class="line">g[i][j] = max;</span><br><span class="line">&#125;</span><br><span class="line">to[i].d = max;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; m; i++) &#123; </span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v);</span><br><span class="line">g[a][b] = v;</span><br><span class="line">g[b][a] = v;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">to[i].d = g[1][i];</span><br><span class="line">if (g[1][i] != max) &#123;</span><br><span class="line">to[i].pre = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[1] = 1;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">min = max;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123;</span><br><span class="line">min = to[j].d;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123;</span><br><span class="line">to[j].d = to[k].d + g[k][j];</span><br><span class="line">to[j].pre = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(n);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-逛街"><a href="#问题-E-逛街" class="headerlink" title="问题 E: 逛街"></a>问题 E: 逛街</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 8  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=4&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1788" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1788&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1788&amp;getkey=7BBB5CA0F9" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1788" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设渣渣灰有一个女朋友，他的女朋友要他陪着一起去公园。由于渣渣灰不喜欢运动，所以他想找一条最短的路到达公园。由于途中会有许多消费点，而每到一个消费点女朋友就要购物，而渣渣灰比较抠，所以假如有多条最短路，则他会选择途中消费点最便宜的。给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>输入nm，点的编号是1~n然后是m行，每行4个数 abdp，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 st;起点s，终点。n和m为0时输入结束。<br>(1&lt;n&lt;=1000 0&lt;m&lt;100000 s != t)</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出 一行有两个数， 最短距离及其花费。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 5 6</span><br><span class="line">2 3 4 5</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 11</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>输入样例的空行只是为了让大家分辨数据，输入有没有空行都没关系。输出样例没有空行。</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>同上一道题的方法，我们再创建一个value数组储存花费情况。在松弛时对value进行改变。松弛成功则value（s-&gt;i）=value(s-&gt;k-&gt;i)。若最短路相等则对value值进行比较，即value（s-&gt;i）=min(value(s-&gt;k-&gt;i),value（s-&gt;i))。s为源点，i为当前终点，k为中间点。最终输出最短路及对应value值即可。</p><h2 id="代码参考-4"><a href="#代码参考-4" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">#define Min(a,b) a&gt;b?b:a</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">int adj,val;</span><br><span class="line">&#125;g[1005][1005];</span><br><span class="line">int dist[1005];//距离</span><br><span class="line">int value[1005];//费用</span><br><span class="line">int used[1005];//标记</span><br><span class="line">int n,m,i,j;</span><br><span class="line">void Dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">memset(dist,0x3f,sizeof(dist));</span><br><span class="line">memset(value,0x3f,sizeof(value));</span><br><span class="line">memset(used,0,sizeof(used));</span><br><span class="line">dist[s]=0;//从起点开始</span><br><span class="line">value[s]=0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">int k,u=-1,d[1005];</span><br><span class="line">int min=INF;</span><br><span class="line">memset(d,0,sizeof(d));</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">if(used[i]==0&amp;&amp;dist[i]&lt;min)//找出从起点到下一个最小距离的顶点</span><br><span class="line">&#123;</span><br><span class="line">min=dist[i];</span><br><span class="line">u=i;//记录下标</span><br><span class="line">&#125;</span><br><span class="line">if(u==-1)//判断所有顶点是否都到达过</span><br><span class="line">return ;</span><br><span class="line">for(i=1,k=0;i&lt;=n;i++)</span><br><span class="line">if(dist[u]==dist[i]&amp;&amp;used[i]==0)</span><br><span class="line">d[k++]=i;//从起点到下一个要访问的顶点的最小距离可能有多个</span><br><span class="line">for(i=0;i&lt;k;i++)</span><br><span class="line">used[d[i]]=1;</span><br><span class="line">for(i=0;i&lt;k;i++)//多个满足的点分别进行迪杰斯特拉最短路查找</span><br><span class="line">for(j=1;j&lt;=n;j++)</span><br><span class="line">if(g[d[i]][j].adj!=INF &amp;&amp; (dist[d[i]]+g[d[i]][j].adj)&lt;=dist[j])</span><br><span class="line">&#123;//原理与 main()函数中建立邻接矩阵一样</span><br><span class="line">if((dist[d[i]]+g[d[i]][j].adj)&lt;dist[j])</span><br><span class="line">value[j]=value[d[i]]+g[d[i]][j].val;</span><br><span class="line">else</span><br><span class="line">value[j]=Min(value[j],value[d[i]]+g[d[i]][j].val);</span><br><span class="line">dist[j]=dist[d[i]]+g[d[i]][j].adj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (n||m))</span><br><span class="line">&#123;</span><br><span class="line">int a,b,d,p;</span><br><span class="line">memset(g,0x3f,sizeof(g));</span><br><span class="line">for(i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;d,&amp;p);</span><br><span class="line">if(d&lt;=g[a][b].adj)//处理路径距离问题</span><br><span class="line">&#123;</span><br><span class="line">if(d==g[a][b].adj)//如果距离相等，则存放最少的费用</span><br><span class="line">g[a][b].val=g[b][a].val=Min(p,g[a][b].val);</span><br><span class="line">else//否则，存放新路径距离的费用</span><br><span class="line">g[a][b].val=g[b][a].val=p;</span><br><span class="line">g[a][b].adj=g[b][a].adj=d;//填充路径距离</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int s,t;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;s,&amp;t);</span><br><span class="line">Dijkstra(s);</span><br><span class="line">printf(&quot;%d %d\n&quot;,dist[t],value[t]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-足球"><a href="#问题-F-足球" class="headerlink" title="问题 F: 足球"></a>问题 F: 足球</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 3  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1786" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1786&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1786&amp;getkey=C290CA1E34" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1786" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>yoyo得到了一个足球，这个足球与其他的足球一样，表面有 12 个正五边形和 20 个正六边形组成，足球的每个面初始的时候都为白色。现在yoyo把这个足球拆解开来，32个面编号为1~32。爱画画的yoyo希望将足球的某些面涂为黑色（可能是 0 个），在每次涂色操作中，慢慢只可以将某一些相邻或者联通的面一起涂为黑色（两个面相邻当且仅当他们共用一条边）。例如，yoyo可以在一次涂色操作中将面 1、2、3、4、5 涂为黑色，但是他不可以将面11 和 24 涂为白色，因为面 11 和 24 是不相邻也不联通的。求yoyo所需要的最少的涂色次数。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>第一行包含一个整数 t，表示有t组测试数据，对于每组测试数据：</p><p>输入包含一行，该行包含 32 个整数，每个数的值等于 0 时表示白色，等于 1 时表示黑色。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出Case c: ans，其中 c 为测试数据编号，ans 为最少的操作次数。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 0</span><br><span class="line">Case 3: 2</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>除了相邻的数面也相邻外，面 1 和面 13 是相邻的，面 13 和面 17 是相邻的，面 17 和面 32 是相邻的，面 15 和面 32 是相邻的，面 19 和面 32 是相邻的。</p><p>PS:1和32不相邻。</p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>先把所有相邻的点赋值为1，再用Floyd算法把所有点之间的最短距离打表求出来。之后每输入一组样例，则对样例中的1dfs深搜，然后深搜把所有相邻为1且值为1的点重新赋值为0。最后记录下主循环中dfs的次数即可。</p><h2 id="代码参考-5"><a href="#代码参考-5" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 32 + 1;</span><br><span class="line">int dis[maxn][maxn];</span><br><span class="line">int vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(dis,0x3f3f3f3f,sizeof(dis));</span><br><span class="line">    dis[32][32] = 0;</span><br><span class="line">    for(int i = 1; i &lt; maxn - 1; i++)&#123;</span><br><span class="line">        dis[i][i] = 0;</span><br><span class="line">        dis[i][i + 1] = 1;</span><br><span class="line">        dis[i + 1][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[1][13] = dis[13][1] = 1;</span><br><span class="line">    dis[17][13] = dis[13][17] = 1;</span><br><span class="line">    dis[17][32] = dis[32][17] = 1;</span><br><span class="line">    dis[15][32] = dis[32][15] = 1;</span><br><span class="line">    dis[19][32] = dis[32][19] = 1;</span><br><span class="line">    for(int k = 1; k &lt; maxn; k++)&#123;</span><br><span class="line">        for(int i = 1; i &lt; maxn; i++)</span><br><span class="line">            for(int j = 1; j &lt; maxn; j++)</span><br><span class="line">                if(dis[i][j] &gt; dis[i][k]+dis[k][j])</span><br><span class="line">                    dis[i][j] = dis[i][k]+dis[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">    vis[x] = 0;</span><br><span class="line">    for(int i = 1; i &lt; maxn; i++)&#123;</span><br><span class="line">        if(vis[i]&amp;&amp;dis[x][i]==1)</span><br><span class="line">            dfs(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int u = 1;u &lt;= t;u++)&#123;</span><br><span class="line">        for(int i = 1;i &lt; maxn; i++)</span><br><span class="line">            cin&gt;&gt;vis[i];</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 1; i &lt; maxn; i++)&#123;</span><br><span class="line">            if(vis[i])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;Case &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-牌"><a href="#问题-G-牌" class="headerlink" title="问题 G: 牌"></a>问题 G: 牌</h1><p>时间限制: 1 Sec  内存限制: 128 MB<br>提交: 2  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1009&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1789" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1789&amp;cid=1009" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1789&amp;getkey=86CA76A96B" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1789" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌i，j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>首行输入n，代表n个点</p><p>接下来n行，每一行两个属性ab第i行代表第i张牌，属性为ai，bi。数据范围保持在200以内。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>输出最大分数</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 4</span><br><span class="line">3 3</span><br><span class="line">1 7</span><br><span class="line">2 5</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">108</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p><h2 id="代码参考-6"><a href="#代码参考-6" class="headerlink" title="代码参考"></a>代码参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define max 900000</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">int d; </span><br><span class="line">int pre;</span><br><span class="line">&#125;path;</span><br><span class="line">path to[1000 + 2];</span><br><span class="line">int g[1000 + 2][1000 + 2], vis[1000 + 2]; </span><br><span class="line">void fun(int ddd) &#123;</span><br><span class="line">if (ddd == 1) &#123;</span><br><span class="line">printf(&quot;%d&quot;, ddd);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int j= to[ddd].pre;</span><br><span class="line">fun(j);</span><br><span class="line">printf(&quot; %d&quot;, ddd);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m, a, b, v, i, j, min, k, from;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; </span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">for (j = 0; j &lt;= n; j++) &#123;</span><br><span class="line">g[i][j] = max;</span><br><span class="line">&#125;</span><br><span class="line">to[i].d = max;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; m; i++) &#123; </span><br><span class="line">scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v);</span><br><span class="line">g[a][b] = v;</span><br><span class="line">g[b][a] = v;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">to[i].d = g[1][i];</span><br><span class="line">if (g[1][i] != max) &#123;</span><br><span class="line">to[i].pre = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[1] = 1;</span><br><span class="line">for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">min = max;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123;</span><br><span class="line">min = to[j].d;</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">for (j = 2; j &lt;= n; j++) &#123;</span><br><span class="line">if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123;</span><br><span class="line">to[j].d = to[k].d + g[k][j];</span><br><span class="line">to[j].pre = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(n);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用模板代码"><a href="#常用模板代码" class="headerlink" title="常用模板代码"></a>常用模板代码</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=510;</span><br><span class="line">int graph[maxn][maxn];//保存图</span><br><span class="line">int degree[maxn];//保存入度</span><br><span class="line">int TOP[maxn];//保存已删除点</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">    int now = 0；//指针作用记录TOP中可插入的位置</span><br><span class="line">        memset(graph,0,sizeof(graph));</span><br><span class="line">        memset(degree,0,sizeof(degree));</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            if(!graph[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                graph[u][v]=1;</span><br><span class="line">                degree[v]++;//v的入度++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            if(degree[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int cur=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TOP[now++]=cur;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(graph[cur][i]==1)</span><br><span class="line">                &#123;</span><br><span class="line">                    degree[i]--;//相连的点的入度减1</span><br><span class="line">                    if(degree[i]==0)//假设入度为0，增加队列</span><br><span class="line">                        q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里可以添加输出，排序已保存在TOP数组中</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dijkstra（单元最短路径）"><a href="#dijkstra（单元最短路径）" class="headerlink" title="dijkstra（单元最短路径）"></a>dijkstra（单元最短路径）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 107;</span><br><span class="line">const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷inf</span><br><span class="line">int n,m,k,s;</span><br><span class="line">int dis[maxn];  //储存各个点到源点的最短距离,dis[s]为0</span><br><span class="line">int road[maxn][maxn];   //两点之间直接距离关系</span><br><span class="line">bool vis[maxn];     //判断源点到该点的距离是否为最短距离</span><br><span class="line">int fans[maxn];</span><br><span class="line">void dijkstra(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    vis[s] = true;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        dis[i] = road[s][i];</span><br><span class="line">    for(int u = 1; u&lt;n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minD = inf,k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[i]&lt;minD)</span><br><span class="line">            &#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[k]+road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    memset(road,inf,sizeof(road));</span><br><span class="line">    //主函数添加程序与数据以及调用dijkstra</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA（单元最短路径，可带负环）"><a href="#SPFA（单元最短路径，可带负环）" class="headerlink" title="SPFA（单元最短路径，可带负环）"></a>SPFA（单元最短路径，可带负环）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define N 105</span><br><span class="line">int res[N];//存储源点到每个顶点的最短距离值</span><br><span class="line">int g[N][N];</span><br><span class="line">int cnt[N];//每个点入队次数，判断是否出现负环</span><br><span class="line">int que[N*N];//队列</span><br><span class="line">bool in_que[N];//标记一个点是否已在队列中</span><br><span class="line">int front;//队首位置</span><br><span class="line">int rear;//队尾位置</span><br><span class="line">void spfa(int n,int src)</span><br><span class="line">&#123;</span><br><span class="line">    rear=front=0;</span><br><span class="line">    que[++rear]=src;</span><br><span class="line">    memset(res,0x3f3f3f3f,sizeof(res));</span><br><span class="line">    memset(in_que,0,sizeof(in_que));</span><br><span class="line">    res[src]=0;</span><br><span class="line">    while(front&lt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        int cur=que[++front];</span><br><span class="line">        in_que[cur]=0;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(res[cur]+g[cur][i]&lt;res[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]=res[cur]+g[cur][i];</span><br><span class="line">                if(!in_que[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    que[++rear]=i;</span><br><span class="line">                    in_que=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyed（全源最短路径）"><a href="#Floyed（全源最短路径）" class="headerlink" title="Floyed（全源最短路径）"></a>Floyed（全源最短路径）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int k=0; k&lt;n; ++k)</span><br><span class="line">  for (int i=0; i&lt;n; ++i)</span><br><span class="line">    for (int j=0; j&lt;n; ++j)</span><br><span class="line">            /*</span><br><span class="line">            实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j]</span><br><span class="line">            都不是Inf ，只要一个是Inf，那么就肯定不必更新。 </span><br><span class="line">            */</span><br><span class="line">      if (dist[i][k] + dist[k][j] &lt; dist[i][j] )</span><br><span class="line">        dist[i][j] = dist[i][k] + dist[k][j];</span><br></pre></td></tr></table></figure><h2 id="Prim最小生成树"><a href="#Prim最小生成树" class="headerlink" title="Prim最小生成树"></a>Prim最小生成树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">int i,j,k,tmp,ans;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">dis[i]=inf;//初始化 </span><br><span class="line">dis[1]=0;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">tmp=inf;</span><br><span class="line">for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123;</span><br><span class="line">tmp=dis[j];</span><br><span class="line">k=j;</span><br><span class="line">&#125;//找出最小距离的节点 </span><br><span class="line">&#125;</span><br><span class="line">vis[k]=1;//把访问的节点做标记</span><br><span class="line">for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;dis[j]&gt;map[k][j])</span><br><span class="line">dis[j]=map[k][j];//更新最短距离 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1007;</span><br><span class="line">int n,m;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">    int l;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line">int fa[maxn];</span><br><span class="line">int init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i&lt;maxn; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">int findfa(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return fa[x] == x ? x : (fa[x] = findfa(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int merge_1(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    fa[findfa(x)] = findfa(y);</span><br><span class="line">&#125;</span><br><span class="line">int kruskal()</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = 0; i&lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int fx = findfa(edge[i].x);</span><br><span class="line">        int fy = findfa(edge[i].y);</span><br><span class="line">        if(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            merge_1(fx,fy);</span><br><span class="line">            cnt++;</span><br><span class="line">            sum+=edge[i].l;</span><br><span class="line">            if(cnt&gt;=n-1)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    //此处填写边以及点等待输入数据，填写完成后须对边的权值进行排序</span><br><span class="line">    kruskal();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题-A-签到题之青蛙爬楼梯&quot;&gt;&lt;a href=&quot;#问题-A-签到题之青蛙爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;问题 A: 签到题之青蛙爬楼梯&quot;&gt;&lt;/a&gt;问题 A: 签到题之青蛙爬楼梯&lt;/h1&gt;&lt;p&gt;时间限制: 1 Sec  内存限制: 1
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="最小生成树" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="拓扑排序" scheme="http://qianyouyou.cn/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>图论1（拓扑排序 + 最短路 + 最小生成树）</title>
    <link href="http://qianyouyou.cn/2018/07/26/2018-07-26-1/"/>
    <id>http://qianyouyou.cn/2018/07/26/2018-07-26-1/</id>
    <published>2018-07-26T04:26:14.000Z</published>
    <updated>2018-08-18T03:56:16.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>图论起源于著名的哥尼斯堡七桥问题。在哥尼斯堡的普莱格尔河上有七座桥将河中的岛及岛与河岸联结起来问题是要从这四块陆地中任何一块开始，通过每一座桥正好一次，再回到起点。然而无数次的尝试都没有成功。欧拉在1736年解决了这个问题，他用抽像分析法将这个问题化为第一个图论问题：即把每一块陆地用一个点来代替，将每一座桥用联接相应的两个点的一条线来代替，从而相当于得到一个“图”。欧拉证明了这个问题没有解，并且推广了这个问题，给出了对于一个给定的图可以某种方式走遍的判定法则。这就是后来的欧拉路径和欧拉回路。这项工作使欧拉成为图论〔及拓扑学〕的创始人。</p><h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>若图G中存在这样一条路径，使得它恰通过G中每条边一次,则称该路径为欧拉路径。若该路径是一个圈，则称为欧拉(Euler)回路。</p><p>定理：（一）一个图有欧拉回路当且仅当它是连通的且每个顶点都有偶数度。（二）一个图有欧拉通路当且经当它是连通的且除两个顶点外，其他顶点都有偶数度。</p><p>在第二个定理下，含奇数度的两个节点中，一个必为欧拉通路起点，另一个必为欧拉通路的终点。</p><h2 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么"></a>图是什么</h2><p>图的的定义      图是由顶点V的集合和边E的集合组成的二元组：             </p><p>记G=（V，E）    存在一个结点v，可能含有多个前驱结点和后继结点。</p><h2 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h2><p>有向图</p><p>无向图</p><p>无权图</p><p>带权图</p><p>连通图</p><p>二分图…</p><p>有向图:    点与有向边的集合</p><p>带权图（网）：图中的边加上表示某种含义的数值，数值称为边的权</p><p>连通：两顶点间有路可通。</p><p>连通图：能连成一片的图。</p><p>连通分量：无向图中的极大连通子图</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>​    在图G=（V，E）中，如果对于结点a，b，存在满足下述条件的结点序列x1……xk(k&gt;1)        ⑴ x1=a，xk=b     ⑵ (xi，xi+1)∈E         i=1‥k-1则称结点序列x1=a，x2，…，xk=b为结点a到结点b的一条路径，而路径上边的数目（k-1）称为该路径的长度。</p><p>图1: 1、(1,2,3,5)    长度=3        2、(1,2,3,5,2)  长度=4        3、(1,2,5,4,1)  长度=4</p><p>图2: (1,2,5,4) 长度=3</p><p>若起点与终点相同着为环（也叫做回路）</p><h3 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h3><p>在无向图中：顶点v的度是指与顶点v相连的边的数目。D( 2 )=3</p><p>在有向图中：入度——以该顶点为终点的边的数目 . ID(3)=2  出度——以该顶点为起点的边的数目 . OD(3)=1度：等于该顶点的入度与出度之和。D(5)=ID(5)+OD(5)=1+2=3 </p><h2 id="太多了，有时间再添加"><a href="#太多了，有时间再添加" class="headerlink" title="太多了，有时间再添加"></a>太多了，有时间再添加</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;图论起源于著名的哥尼斯堡七桥问题。在哥尼斯堡的普莱格尔河上有七座桥将河中的岛及岛与河岸联结起来问题是要从这四块陆地中任何一块开始，通过每一座
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="http://qianyouyou.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="最小生成树" scheme="http://qianyouyou.cn/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="拓扑排序" scheme="http://qianyouyou.cn/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>7.20-stl专项训练题解</title>
    <link href="http://qianyouyou.cn/2018/07/20/2018-07-20/"/>
    <id>http://qianyouyou.cn/2018/07/20/2018-07-20/</id>
    <published>2018-07-20T07:00:15.000Z</published>
    <updated>2018-08-18T04:06:09.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题A"><a href="#问题A" class="headerlink" title="问题A"></a>问题A</h1><p>问题A同问题B，具体方法在问题B中介绍，此处仅贴代码</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p><p>对于每一行，输入四个整数a，b，c，d</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每组样例，输出一个整数表示答案</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 9;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">init();//打表</span><br><span class="line">ll ans = 1;</span><br><span class="line">//这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">//将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-yoyo思维题-困难"><a href="#问题-B-yoyo思维题-困难" class="headerlink" title="问题 B: yoyo思维题(困难)"></a>问题 B: yoyo思维题(困难)</h1><p>问题A同问题B</p><p>提交: 4  解决: 2<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=1&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1731" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1731&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1731&amp;getkey=4DE1A19111" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1731" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小琳，小花，小薇，yoyo，他们每个人手上有一堆牌，牌的张数分别为x1，x2，x3，x4，每张牌都不一样。现有n名同学，n=x1+x2+x3+x4。每名同学均需要一张牌，于是他们按顺序每人随机到四个人那里拿取牌顶的一张牌，最后一个人刚好拿到剩下的最后一张牌。排队拿牌的同学的顺序是固定的，选择拿谁的牌是不确定的。假如发牌的人手上的牌发完了，则要拿牌的同学会选择其他发牌的人。请问有多少种取法取走所有的牌。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p><p>对于每一行，输入四个整数a，b，c，d，输入为均不超过500的正整数</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对于每组样例，输出一个整数表示答案，答案对10^9+7取模</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 4 2 3</span><br></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>本题作为思维题，并未用到stl，仅锻炼一下大家解决问题的能力。用到的数学知识相对多一点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是C(b,a+b);那么三堆的话我们可以把前两堆看成一堆，那么表达式就是C(c,a+b+c)，这是我们需要与前两堆的组成方法相乘，就是C(b,a+b)C(c,a+b+c)。4堆的话就是C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。所以答案就是C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。此外，有一公式C(a,b) = C(a,b-1)+C(a-1,b-1)，所以我们用数组来代替C(m,n)操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">init();//打表</span><br><span class="line">ll ans = 1;</span><br><span class="line">//这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">//将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-悠派计算器"><a href="#问题-C-悠派计算器" class="headerlink" title="问题 C: 悠派计算器"></a>问题 C: 悠派计算器</h1><p>提交: 4  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=2&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1732" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1732&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1732&amp;getkey=C0EA34F688" target="_blank" rel="noopener">Edit</a>][<a href="javascript:phpfm(1732" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>yoyo的小老弟小渣渣灰特别懒，兴趣爱好并不多，就睡觉一个。为了多睡会儿懒觉，他把数学老师布置的作业全部推给yoyo计算。yoyo很头疼，于是请你帮他写一个计算器帮忙计算。现有多个数学表达式，请你写一个计算器算出结果，表达式只包含’+’’-‘’*’’/‘’%’’(‘’)’操作，其中表达式中’-‘作为减运算符，不会作为负号出现，此外’/‘为整除运算符，’%’为取余运算符。表达式保证合法。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>输入第一行t，表示共有t行测试用例，接下来t行每一行均为一个合法的数学表达式。保证每个数在[09999]范围内，保证计算过程中不会出现超范围情况。（注：没有空格）</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出计算结果</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">0*1</span><br><span class="line">5%6</span><br><span class="line">1-2*(3+4*5%6)+7/8-9*10%11*12</span><br><span class="line">(1+2*3)</span><br><span class="line">1-(100%5)</span><br><span class="line">(3+2*5)/(5)</span><br><span class="line">(11-11)+(33)*64-11</span><br></pre></td></tr></table></figure><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">5</span><br><span class="line">-135</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2101</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据很水，不用考虑long long或取余等情况。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)<em>(c+d)转换为ab+cd+</em></p><p>如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。</p><p>例如(a+b)<em>(c+d)转换为ab+cd+</em>   计算机在计算普通表达式时，要对运算优先级用递归进行判断，对于更为复杂的表达式会使计算机运算效率变低甚至崩溃。而逆波兰表达式只需要进行简单的入栈出栈操作就可以完成任何普通表达式的运算。</p><p>普通表达式——&gt;逆波兰表达式</p><p>(1)a+b——&gt;a b +</p><p>(2)a+(b-c)——&gt;a b c - +</p><p>(3)a+(b-c)<em>d——&gt;a b c -  d </em> +</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 100007;</span><br><span class="line">map&lt;char,int&gt;Pri;//其实可以不必用map，只是为了方便大家理解map而多添加的一步</span><br><span class="line">stack&lt;int&gt;num;</span><br><span class="line">stack&lt;char&gt;Ope;</span><br><span class="line">char str[maxn];</span><br><span class="line">//初始化</span><br><span class="line">void init()&#123;</span><br><span class="line">    Pri[&apos;+&apos;] = Pri[&apos;-&apos;] = 1;</span><br><span class="line">    Pri[&apos;*&apos;] = Pri[&apos;/&apos;] = Pri[&apos;%&apos;] = Pri[&apos;(&apos;] = Pri[&apos;)&apos;] = 2;</span><br><span class="line">    while(!num.empty())</span><br><span class="line">        num.pop();</span><br><span class="line">    while(!Ope.empty())</span><br><span class="line">        Ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">//基本运算操作</span><br><span class="line">void operation_1(int &amp;a,int &amp;b, char c)&#123;</span><br><span class="line">    if(c == &apos;+&apos;)</span><br><span class="line">        a += b;</span><br><span class="line">    else if(c == &apos;-&apos;)</span><br><span class="line">        a = b-a;</span><br><span class="line">    else if(c == &apos;*&apos;)</span><br><span class="line">        a *= b;</span><br><span class="line">    else if(c == &apos;/&apos;)</span><br><span class="line">        a = b/a;</span><br><span class="line">    else if(c == &apos;%&apos;)</span><br><span class="line">        a = b%a;</span><br><span class="line">&#125;</span><br><span class="line">//遇到+或者)时执行的操作</span><br><span class="line">void operation_2()&#123;</span><br><span class="line">    char ch = Ope.top();</span><br><span class="line">        while(ch != &apos;(&apos;&amp;&amp;!Ope.empty())&#123;</span><br><span class="line">            Ope.pop();</span><br><span class="line">            int a = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            int b = num.top();</span><br><span class="line">            num.pop();</span><br><span class="line">            operation_1(a,b,ch);</span><br><span class="line">            num.push(a);</span><br><span class="line">            if(!Ope.empty())</span><br><span class="line">                ch = Ope.top();</span><br><span class="line">        &#125;</span><br><span class="line">        if(!Ope.empty()&amp;&amp;Ope.top() == &apos;(&apos;)</span><br><span class="line">            Ope.pop();</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;getchar();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin.getline(str,maxn);</span><br><span class="line">        stringstream s(str);</span><br><span class="line">        init();</span><br><span class="line">        char tmp;</span><br><span class="line">        while(s &gt;&gt; tmp)&#123;</span><br><span class="line">        //遇到数字字符时，需要判断下一位是否依旧是数字，是的话需要合并</span><br><span class="line">            if(tmp &gt;= &apos;0&apos; &amp;&amp; tmp &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                int t = 0;</span><br><span class="line">                do&#123;</span><br><span class="line">                    if(Pri[tmp])&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    t *= 10;</span><br><span class="line">                    t += tmp - &apos;0&apos;;</span><br><span class="line">                &#125;while(s &gt;&gt; tmp);</span><br><span class="line">                num.push(t);</span><br><span class="line">            &#125;</span><br><span class="line">            //遇到&apos;)&apos;时</span><br><span class="line">            if(tmp == &apos;)&apos;)&#123;</span><br><span class="line">                operation_2();</span><br><span class="line">            &#125;</span><br><span class="line">            //遇到&apos;+&apos; ‘-’时</span><br><span class="line">            else if(Pri[tmp]==1)&#123;</span><br><span class="line">                if(!Ope.empty()&amp;&amp;Ope.top()!=&apos;(&apos;)&#123;</span><br><span class="line">                    operation_2();</span><br><span class="line">                &#125;</span><br><span class="line">                Ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(Pri[tmp])&#123;</span><br><span class="line">                Ope.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = num.top();</span><br><span class="line">        num.pop();</span><br><span class="line">        while(!num.empty()&amp;&amp;!Ope.empty())&#123;</span><br><span class="line">            operation_1(ans,num.top(),Ope.top());</span><br><span class="line">            Ope.pop();</span><br><span class="line">            num.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-留胡子"><a href="#问题-D-留胡子" class="headerlink" title="问题 D: 留胡子"></a>问题 D: 留胡子</h1><p>提交: 53  解决: 6<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=3&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1733" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1733&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1733&amp;getkey=3B707F894D" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1733" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>众所周知，刘虎子同学爱留胡子，人送外号刘胡子。为了留一抹性感又忧郁的小胡子，刘虎子专门与yoyo合作研发了一套算法，俗称油胡子算法。油胡子算法原理很简单，要想获得油胡子，首先将胡子从左到右分为n撮胡子，第i撮胡子的平均长度为xi。现每次从n中选出最左边的相邻胡子长度之差的绝对值为1的两撮胡子，减掉较长的1撮胡子，减掉的那撮胡子可以认为从n撮胡子中删除，剩下n-1撮胡子待修剪，再将剩下的n-1撮胡子从左到右重新排列成相邻的数继续如此操作，直到没有两撮相邻差的绝对值为1的胡子为止。此时的胡子称为完美油胡子。请问刘虎子同学最多需要剪多少次才能得到自己心仪的性感小胡子。</p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p>输入第一行为n，接下来一行n个数x1x2…xi…xn。</p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>输出最多执行次数。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">3 2 3 1 0 1</span><br></pre></td></tr></table></figure><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p><strong>用栈来维护每次合并完的数，每入栈一个数以后栈顶和次栈顶比较，如果可以合并就合并为新的栈顶，并且再次与次栈顶比较直至无法合并，在合并过程中统计次数即可。</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,x;</span><br><span class="line">int ans=0;     //最大操作次数</span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">//将x与当前栈顶元素st.top()比较，若栈不空且st.top()比x大1，则合并一次(此时即当前栈顶元素出栈)</span><br><span class="line">//然后x与次栈顶比较，以此类推，直到不满足栈不空且st.top()比x大1</span><br><span class="line">while(!st.empty() &amp;&amp; st.top()-x==1)</span><br><span class="line">&#123;</span><br><span class="line">st.pop();</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">//若栈不空且x比st.top()大1，则合并一次</span><br><span class="line">//(此时即x&quot;出栈&quot;，也就是忽略此x继续看下一个输入的x 但栈不发生任何变化)</span><br><span class="line">if(!st.empty() &amp;&amp; x-st.top()==1)</span><br><span class="line">ans++;</span><br><span class="line">//其他情况(x为第一个元素或不满足上述两种情况)：将x入栈</span><br><span class="line">else</span><br><span class="line">st.push(x);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-卜卦"><a href="#问题-E-卜卦" class="headerlink" title="问题 E: 卜卦"></a>问题 E: 卜卦</h1><p>提交: 1  解决: 1<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?id=1734" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1734" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1734" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1734&amp;getkey=7E5D1F2620" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1734" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>赵神是一个特别特别闷骚的人。别看他平日表现很高冷，其实他一直暗恋着自己的小迷妹小花花，一日不见兮，思之如狂。马上快七夕了，赵神想卜一卦算一下他的爱情幸运数，于是他找到了yoyo半仙替他卜卦。yoyo半仙需要赵神的3个幸运数字以及小花花的3个幸运数字方可进行卜卦。已知赵神的3个幸运数字是’5’’2’’0’而小花花的幸运数字是abc，(保证由5，2，0，a，b，c，这6个数各不相同，且abc均为30以内的素数)。卜卦规则如下：<br>由{520abc}组成的6个各不相同数中选取最小的3个数作为加数，其余最大的3个数作为基数。每一个数若加上加数仅能被基数整除，其他素数均不能整除，则该数称为幸运数。其中第1314个幸运数为爱情幸运数。<br>现在你刚好知道小花花的幸运数，请你帮yoyo完成卜卦吧。PS：顺利完成任务后则会收获赵神珍藏版kiss一枚。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>首行输入t，代表t组测试样例</p><p>接下来t行输入三个数abc。</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>输出第1314个幸运值</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7 3 11</span><br><span class="line">7 11 13</span><br></pre></td></tr></table></figure><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">29541015622</span><br><span class="line">1775105893556</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>待写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int fort = 1314;</span><br><span class="line">ll coeff[6];</span><br><span class="line">int cmp(ll a,ll b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        cin&gt;&gt;coeff[0]&gt;&gt;coeff[1]&gt;&gt;coeff[2];</span><br><span class="line">        coeff[3] = 5;</span><br><span class="line">        coeff[4] = 2;</span><br><span class="line">        coeff[5] = 0;</span><br><span class="line">        sort(coeff,  coeff + 6, cmp);</span><br><span class="line">        priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;</span><br><span class="line">        set&lt;ll&gt;s;</span><br><span class="line">        set&lt;ll&gt;ans;</span><br><span class="line">        pq.push(1);</span><br><span class="line">        s.insert(1);</span><br><span class="line">        for(int i = 0;;i++)&#123;</span><br><span class="line">            ll x = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            if(i)&#123;</span><br><span class="line">                for(int k = 3;k &lt; 6;k++)&#123;</span><br><span class="line">                    ans.insert(x - coeff[k]);</span><br><span class="line">                    if(ans.size()==fort)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ans.size()==fort)&#123;</span><br><span class="line">                    /*int ttt = 1;</span><br><span class="line">                    for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++)</span><br><span class="line">                        cout&lt;&lt;ttt++&lt;&lt;&apos; &apos;&lt;&lt;*it&lt;&lt;endl;*/</span><br><span class="line">                    set&lt;ll&gt;::reverse_iterator it = ans.rbegin();</span><br><span class="line">                    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 0;j&lt;3;j++)&#123;</span><br><span class="line">                ll x2=x*coeff[j];</span><br><span class="line">                if(!s.count(x2))&#123;</span><br><span class="line">                    s.insert(x2);</span><br><span class="line">                    pq.push(x2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-成绩互评"><a href="#问题-F-成绩互评" class="headerlink" title="问题 F: 成绩互评"></a>问题 F: 成绩互评</h1><p>提交: 117  解决: 40<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=5&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1738" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1738&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1738&amp;getkey=9C71BFBEA7" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1738" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>学生互评作业的简单规则是这样定的：每个人的作业会被k个同学评审，得到k个成绩。系统需要去掉一个最高分和一个最低分，将剩下的分数取平均，就得到这个学生的最后成绩。本题就要求你编写这个互评系统的算分模块。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>输入第一行给出3个正整数N（3&lt; N &lt;= 104，学生总数）、k（3&lt;= k &lt;= 10，每份作业的评审数）、M（&lt;= 20，需要输出的学生数）。随后N行，每行给出一份作业得到的k个评审成绩（在区间[0 100]内），其间以空格分隔。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>按非递减顺序输出最后得分最高的M个成绩，保留小数点后3位。分数间有1个空格，行首尾不得有多余空格。</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 5 3</span><br><span class="line">88 90 85 99 60</span><br><span class="line">67 60 80 76 70</span><br><span class="line">90 93 96 99 99</span><br><span class="line">78 65 77 70 72</span><br><span class="line">88 88 88 88 88</span><br><span class="line">55 55 55 55 55</span><br></pre></td></tr></table></figure><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">87.667 88.000 96.000</span><br></pre></td></tr></table></figure><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p><strong>total数组保存各个同学的平均分，v数组保存每次接收得到的分数，排序后取前m名，按递增输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int cmp(double a, double b) &#123;</span><br><span class="line">return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int N, K, M;</span><br><span class="line">while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; M) &#123;</span><br><span class="line">vector&lt;double&gt;v(K);</span><br><span class="line">vector&lt;double&gt;v2(N);</span><br><span class="line">for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">double sum = 0;</span><br><span class="line">for (int j = 0; j &lt; K; j++) &#123;</span><br><span class="line">cin &gt;&gt; v[j];</span><br><span class="line">sum += v[j];</span><br><span class="line">&#125;</span><br><span class="line">sort(v.begin(), v.end(), cmp);</span><br><span class="line">sum -= v[0] + v[K - 1];</span><br><span class="line">sum /= K - 2;</span><br><span class="line">v2[i] = sum;</span><br><span class="line">&#125;</span><br><span class="line">sort(v2.begin(), v2.end(), cmp);</span><br><span class="line">for (int i = M - 1; i &gt; 0; i--)</span><br><span class="line">printf(&quot;%.3lf &quot;, v2[i]);</span><br><span class="line">printf(&quot;%.3lf\n&quot;, v2[0]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-列车"><a href="#问题-G-列车" class="headerlink" title="问题 G: 列车"></a>问题 G: 列车</h1><p>提交: 18  解决: 10<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=6&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1736" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1736&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1736&amp;getkey=EDCA6F0278" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1736" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>火车站的列车调度铁轨的结构如下图所示。<br><img src="http://www.liuchuo.net/wp-content/uploads/2016/07/Snip20160719_118.png" alt="img">tle=”” align=”” /&gt;</p><p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>输入第一行给出一个整数N (2 &lt;= N &lt;= 105)，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">8 4 2 5 3 9 1 6 7</span><br></pre></td></tr></table></figure><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p><strong>必须要车号大的先出，小的后出。所以列车排队的每一队必须是从大到小排列（从右往左看），才能保证开出去的车也是从大到小的。</strong> <strong>对于每一个想要进入并列铁轨的车，如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨</strong> <strong>否则，选择一个最接近它车号的尾部车号的队伍进入</strong> <strong>其实无需保存每一个并行队列的所有值，只需要保存当前队伍的车尾（就是每一列最左边 即 每一列的最小值）即可</strong> <strong>因为每一次都是需要排序比较大小的，所以用set自动排序</strong> <strong>首先把set里面放入一个0值。每一次set的最后一个值s.rbegin()都是当前所有队列队尾的最大值.</strong> <strong>如果当前想要进入排队队伍的t值比集合里面最大值小，就移除第一个比他大的值，然后把t插入集合中。表示的是将t值插入了最接近它车号的队伍的队尾</strong> <strong>否则就直接插入进去t值。作为新的队伍。</strong>s.upper_bound(t)返回的是第一个大于t的迭代器的位置<strong> </strong>在前面加星号表示取这个位置的值<strong> </strong>所以s.erase(*(s.upper_bound(t)));表示删除当前这个刚好大于t的位置处的值<strong> </strong>因为一开始插入了一个没有的0，所以最后输出是s.size()-1。** </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    s.insert(0);</span><br><span class="line">    for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        if(t &lt; *s.rbegin()) &#123;</span><br><span class="line">            s.erase(*(s.upper_bound(t)));</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.size() - 1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-H-新浪关注"><a href="#问题-H-新浪关注" class="headerlink" title="问题 H: 新浪关注"></a>问题 H: 新浪关注</h1><p>提交: 24  解决: 14<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=7&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1737" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1737&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1737&amp;getkey=EB2FC0BAF0" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1737" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入首先在第一行给出某用户的关注列表，格式如下：</p><p>人数N 用户1 用户2 …… 用户N</p><p>其中N是不超过5000的正整数，每个“用户i”（i=1 … N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。</p><p>之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao</span><br><span class="line">8</span><br><span class="line">Magi 50</span><br><span class="line">Pota 30</span><br><span class="line">LLao 3</span><br><span class="line">Ammy 48</span><br><span class="line">Dave 15</span><br><span class="line">GAO3 31</span><br><span class="line">Zoro 1</span><br><span class="line">Cath 60</span><br></pre></td></tr></table></figure><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ammy</span><br><span class="line">Cath</span><br><span class="line">Pota</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p><strong>将关注的人存储在集合set里，将点赞的人和点赞的次数存储在map中，并统计点赞的平均次数sum / M，遍历map，如果map的值大于平均次数，且在set中找不到该用户名，就输出当前用户名（因为map中的键是已经按照字典序排序过的，所以直接输出就可以），并用flag标记是否有过输出，如果从始至终没有输出，说明没有悄悄关注的人，就输出Bing Mei You</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int m, n;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">set&lt;string&gt;id;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">id.insert(name);</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">map&lt;string, int&gt;mm;</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">int cnt;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str &gt;&gt; cnt;</span><br><span class="line">mm[str] = cnt;</span><br><span class="line">sum += cnt;</span><br><span class="line">&#125;</span><br><span class="line">sum /= m;</span><br><span class="line">int flag = 0;</span><br><span class="line">for (auto it : mm) &#123;</span><br><span class="line">if (it.second &gt; sum&amp;&amp;id.find(it.first) == id.end()) &#123;</span><br><span class="line">cout &lt;&lt; it.first &lt;&lt; endl;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!flag)</span><br><span class="line">cout &lt;&lt; &quot;Bing Mei You&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-I-礼物"><a href="#问题-I-礼物" class="headerlink" title="问题 I: 礼物"></a>问题 I: 礼物</h1><p>提交: 94  解决: 44<br>[<a href="http://sustoj.com/JudgeOnline/submitpage.php?cid=1003&amp;pid=8&amp;langmask=0" target="_blank" rel="noopener">提交</a>][<a href="http://sustoj.com/JudgeOnline/problemstatus.php?id=1739" target="_blank" rel="noopener">状态</a>][<a href="http://sustoj.com/JudgeOnline/bbs.php?pid=1739&amp;cid=1003" target="_blank" rel="noopener">讨论版</a>][命题人:<a href="http://sustoj.com/JudgeOnline/userinfo.php?user=qianyouyou" target="_blank" rel="noopener">qianyouyou</a>][<a href="http://sustoj.com/JudgeOnline/admin/problem_edit.php?id=1739&amp;getkey=09962A88B1" target="_blank" rel="noopener">Edit</a>] [<a href="javascript:phpfm(1739" target="_blank" rel="noopener">TestData</a>)]</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>四月一日快到了，Vayko想了个愚人的好办法——送礼物。嘿嘿，不要想的太好，这礼物可没那么简单，Vayko为了愚人，准备了一堆盒子，其中有一个盒子里面装了礼物。盒子里面可以再放零个或者多个盒子。假设放礼物的盒子里不再放其他盒子。<br>用()表示一个盒子，B表示礼物，Vayko想让你帮她算出愚人指数，即最少需要拆多少个盒子才能拿到礼物。 </p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>本题目包含多组测试，请处理到文件结束。<br>每组测试包含一个长度不大于1000只包含’(‘’)’和’B’三种字符的字符串，代表Vayko设计的礼物透视图。<br>你可以假设，每个透视图画的都是合法的。 </p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试，请在一行里面输出愚人指数。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((((B)()))())</span><br><span class="line">(B)</span><br></pre></td></tr></table></figure><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p><strong>看上去像是编译原理的文法识别，要用到栈，其实不是，只要看准备上面红色的字，就知道，只有三种字符()B，且待处理的串为合法的文法，所以要知道包装盒的个数，只要知道B前面有多少(字符，但可能有(()B)这种情况，B前面有)，但因为合法，所以可以在B之前的找到(与)相匹配，就剔除掉了，所以盒子的个数就是B之前的串中(的个数减去)的个数。</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">string str;</span><br><span class="line">while (cin &gt;&gt; str) &#123;</span><br><span class="line">int sco = 0;</span><br><span class="line">for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">if (str[i] == &apos;(&apos;)</span><br><span class="line">sco++;</span><br><span class="line">else if (str[i] == &apos;)&apos;)</span><br><span class="line">sco--;</span><br><span class="line">else if (str[i] == &apos;B&apos;)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sco &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-J-Sunscreen"><a href="#问题-J-Sunscreen" class="headerlink" title="问题 J: Sunscreen"></a>问题 J: Sunscreen</h1><p>题意：有C头奶牛要去沐光浴，太阳光太强烈会晒坏皮肤，太弱又会没效果。每头牛都有一个太阳光适宜的范围经行沐光浴，分别给出minspf_i和maxspf_i。  有L种防晒霜，每种防晒霜可以把所受阳光固定于一个值spf_i，每种有cover_i瓶。  问最多会有几头牛得到合适的光晒强度？ </p><p><strong>题解：贪心策略，在满足minspf的条件下，尽量将spf的防晒霜涂到maxspf小的奶牛身上，因为maxspf大的奶牛有更多的选择。这里就需要一个优先队列来储存满足minspf的奶牛的maxspf的值。     具体解题步骤如下：</strong></p><p><strong>1.将奶牛按照minspf升序排列，将防晒霜按照spf升序排列。</strong></p><p><strong>2.枚举防晒霜，将minspf&lt;=spf的奶牛的maxspf存到优先队列中，然后值小的先出队列，看是否满足maxspf&gt;=spf，更新记录值。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 12505;</span><br><span class="line">struct spf &#123;</span><br><span class="line">int max;</span><br><span class="line">int min;</span><br><span class="line">friend bool operator &lt; (spf a, spf b) &#123;</span><br><span class="line">return a.min &lt; b.min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;cow[MAXN], bot[MAXN];</span><br><span class="line">struct cmp &#123;</span><br><span class="line">bool operator()(const int a, const int b)const &#123;</span><br><span class="line">return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int C, L, i;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;pq;</span><br><span class="line">while (cin &gt;&gt; C &gt;&gt; L) &#123;</span><br><span class="line">for (i = 0; i &lt; C; i++)</span><br><span class="line">cin &gt;&gt; cow[i].min &gt;&gt; cow[i].max;</span><br><span class="line">for (i = 0; i &lt; L;i++)</span><br><span class="line">cin &gt;&gt; bot[i].min &gt;&gt; bot[i].max;</span><br><span class="line">sort(cow, cow + C);</span><br><span class="line">sort(bot, bot + L);</span><br><span class="line">int cur = 0, ans = 0;</span><br><span class="line">for(int i=0;i&lt;L;i++)&#123;</span><br><span class="line">while(cur &lt; C&amp;&amp;cow[cur].min &lt;= bot[i].min) &#123; </span><br><span class="line">pq.push(cow[cur].max); </span><br><span class="line">cur++; </span><br><span class="line">&#125;</span><br><span class="line">while(!pq.empty()&amp;&amp;bot[i].max) &#123; </span><br><span class="line">int maxSPF = pq.top(); </span><br><span class="line">pq.pop();</span><br><span class="line">if(maxSPF &gt;= bot[i].min)&#123;</span><br><span class="line">ans++; </span><br><span class="line">bot[i].max--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题A&quot;&gt;&lt;a href=&quot;#问题A&quot; class=&quot;headerlink&quot; title=&quot;问题A&quot;&gt;&lt;/a&gt;问题A&lt;/h1&gt;&lt;p&gt;问题A同问题B，具体方法在问题B中介绍，此处仅贴代码&lt;/p&gt;
&lt;h2 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;he
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="stl" scheme="http://qianyouyou.cn/tags/stl/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[少年班]天分与平凡，青春与坚守</title>
    <link href="http://qianyouyou.cn/2018/07/14/2018-07-14/"/>
    <id>http://qianyouyou.cn/2018/07/14/2018-07-14/</id>
    <published>2018-07-14T14:15:12.000Z</published>
    <updated>2018-07-15T16:57:08.453Z</updated>
    
    <content type="html"><![CDATA[<p>好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初心呢；或许是经历过许许多多次起起伏伏，遇见过形形色色想遇或不想遇的人或事，又怀念起那段那段青涩的高中岁月；或许只是单纯的想再看看这部电影吧。不管为何，总之现在思绪万千。就让我将这万千的思绪草草记录一下吧。</p><p>这部电影剧情很简单，讲述的是几个天才少年与一个平凡少年被发掘功课数学难题却因青春的叛逆与时代的变迁而成长的故事。故事以主人公以吴未的少年班回忆而展开，主人公吴未就是那个平凡的少年。</p><p>少年班，顾名思义就是大学里专为年纪轻轻却智商非凡的天才们开设的精英班，某知名大学老师周知庸曾经就是少年班的成员，他的梦想是攻克IMC的题目，但曾经的他未能实现，于是将希望寄托在新时代的少年身上。在他的坚持下从全国各地找到了几名心仪的人选，其中包括了吴未。</p><p>然而，像其他天才系列电影一样，天才们拥有着平凡人所羡慕的才能之外，往往却拥有着平凡人所不能理解的烦恼。天才少年方厚政年纪最小，却智商超群，可谓前途无量，只是他IQ高。EQ却低，因此没有什么朋友。天才少年麦克因家庭原因而性格叛逆，打架斗殴无所不为。天才少年王大法无拘无束，自由散漫，因此总让别人捉摸不透，不想与之有交集。天才少女周兰品学兼优，是典型的别人家的子，但也是因为优秀而让所有人都敬而远之。但是和其他电影不同的是，这些天才们不可思议的烦恼其实我们都能理解。毕竟曾经或现在处于青春期的我们哪一个人曾经没有过类似的烦恼呢？他们的性格不过是我们所有人青春期各种性格的集合并放大罢了。</p><p>当然，我们的主人公也有着自己的烦恼，身为平凡人的代表，当他进入少年班后从之前的全校第二摇身一变变成班上的倒数第一，这种落差估计每个处于青春期的孩子都受不了吧。于是他一边仰望着天才们过人的天赋，一边忍受着天才们怪异的性格，一边照顾着正处于青春期幼稚的天才们，一边独自默默努力着，为了自己心中的荣誉。然而，努力在这满是天才的地方却显得那么多余。就在他一筹莫展，开始疑惑为何老师选中他的时候，周知庸老师出现，解开了她的心结。“运送金枪鱼的时候，要在里面混进几条鲶鱼，否则金枪鱼就会因懒惰而死，到不了岸。”老师鼓励他做好自己鲶鱼的身份，因为天才们离开了它的照顾就会堕入深渊。尽管是鲶鱼，但吴未却似乎找到了自己的归宿，并以此为荣，从此，吴未以天才们的快乐为快乐，以天才们的梦想为梦想，就在自己喜欢的人面前，也只能呼喊着天才们所喜欢的校花名字。</p><p>IMC马上开始了，老师想进各种办法激励着天才们去努力钻研，但是恃才傲物并且正处于青春期的天才们又怎会把新鲜的大学生活浪费在学习上呢？趁着大学生活的新鲜感犹在，天才们渐渐被校花江依琳所吸引，从此各种各样的新奇表白开始了。只有吴未从一开始就暗恋着同班的天才少女周兰。尽管周兰从来都看不起吴未，并且单恋这少年班的迈克。</p><p>比赛前一天，几名少年班朝夕相处的小伙伴们在酒后发泄着各种各样青春期的passion，来到女生宿舍楼下，大声表白校花，那一刻，漫天飞舞的纸花，洋洋洒洒，似乎整个世界都在期待着几个天才少年去改变。</p><p>比赛的一个月里，天才们尽管出现各种各样的矛盾，但在吴未的调节下，无伤大雅。但一次偶遇，校花与富家公子哥之间的隐曲之事深深刺激到了天才们。他们落荒而逃，逃得那么彻底。</p><p>老师闻讯，拿起了酒杯，向舞台赶去。天才们旧气难言，拿起了自制的化学炸药，向富二代的车赶去。老师将酒水泼向校花，门外传来雷鸣般的爆炸。这一刻，老师的梦想毁了，天才们的前途毁了，然而，世界依然有活力地在转，一如既往。</p><p>然而，老师仍心怀希望，尽力将此事最小化解决。这边，王大法作为被开除的学生被家人拖走，那边，吴未望向楼上的橱窗，老师站在橱窗望着吴未。这一刻，吴未明白，自己的价值将要发挥了。就这样，吴未顶替其他天才们而被学校开除。</p><p>奔驰的归家车上，吴未哭的撕心裂肺，将自己仅有的一枚荣誉勋章扔向窗外，像扔去回忆一样。身后周兰，方厚政，迈克，追的精疲力尽，他们将过去的笔记本扔向追不上的公交车，像追随友谊一样。</p><p>最终，天才们并没有解出题，也没有改变世界，但他们最终都找到了自己的方向。周知庸老师最后没能实现自己的天才梦，也丢掉了工作，像人间蒸发一样，随旧时代而去，但他却找到了自己的人生伴侣。吴未，平淡无味，但又快乐的漂浮着。</p><p>这部影片最大的亮点就在于其真实性。首先，少年班的故事从1978年起一直延续着。然而，随着时代的发展，如今的少年班已不复存在了。旧时代里，时代的推进是由天才们推进的，这就是为何周知庸老师为何执着于天才的原因之一。就像他说的，“高斯十七岁就发现了第二相反定理，这些天才当时他们不敢发表，因为怕人们不信。”因为这种理念的支撑，让他对所有平凡人带上了有色眼镜，以至于四十多岁依旧单身。然而，过去毕竟是过去，世界上有很多天才，但只有一个高斯，只有一个牛顿，只有一个爱因斯坦。牛顿他们所带表的这类基础科学并不是一个人所完成的，它需要所处时代的支持以及现有技术的支撑，就像牛顿自己也说过，自己是站在巨人肩膀上的，况且牛顿从未说过自己是天才，自己只是热爱探索而已，因此，想要天才改变世界的周知庸老师从一开始就错了，因为他不懂平凡人的价值，所以，他没有牛顿的成就，与牛顿唯一的共同点就是一直单身。世界是一个多元化的世界，不只是理论的世界，如果说基础科学是时代质的飞跃，那应用科学就是时代量的积累、倘若基础科学离开了应用科学，那么世界依旧停滞不前，基础科学反而成为了最没用的东西。故事的结尾，天才们并没有从事科研工作，而是选择了自己所喜欢的岗位，他们没有改变世界，只是生活的比平凡人更潇洒。平凡与天赋，其实离开谁都不行，正是因为天才们的研发，广大平凡的劳动者的坚持工作与制作，才使得这个世界不断推进向前。</p><p>然而，少年班不适宜于当下最主要的原因还是心智的为题。尽管天才们智商超群，但是年纪与经历更重要。十几岁就步入大学校门，尽管他们智商达标了，但心智并未达标。电影中表现的淋淋尽致。他们从未接触过社会，也并不懂得什么是责任，当然，那个时代的我们都一样，在心智上，人人都是平等的。我们就来分析一下各个主人公吧。</p><p>首先是主人公方厚政。作为年纪最小的天才，他的心情，性格，全都写在了脸上。目测智商150，心理年龄只有9岁。遇到委屈就哭，遇到自己看不上的事就挖苦，总之这个世界上只有自己是最厉害的，当面对丰富多彩的大学生活，他又怎会抵挡住各种各样的新鲜事物而去专心钻研呢。主人公迈克，看似成熟，其实心智同样幼稚，面对所有事第一个想到的就是用拳头来解决，从不会考虑后果。主人公王大法自由散漫，每天吃着馒头，听着经文，一副玩世不恭的样子。主人公周兰，可以说是所有优秀的女孩的代表，可以说是比较正常的一个，但正处于花季年纪的她并不适合大学生活，成绩优异不懂打扮的她让人只能敬而远之。尽管是天才，但是如今的大学并不只是学习知识的地方，如果说初中是每个人最会做梦的年纪，高中洋溢着每个人最具浓厚的青春，走向社会是一个人成长为打人的标志，那么大学时代则是每一个人从孩子长成大人的过度期，因此嚷处于做梦年纪的孩子直接去面向社会的残酷未免太过残忍。</p><p>校花江依琳可谓是剧中较完美的一个人，他承载着天才们对女性最完美的幻想。她可以说是剧中EQ最高的一位。尽管他是天才们放弃比赛的导火线，但是天才们又有几个真正懂得感情呢。她对方厚政的感情其实就是姐姐对弟弟的照顾，而对于心智只有9岁的方厚政来说，又怎会冬的何谓男女之情呢。方厚政对待像话的感觉也不过是弟弟对大姐姐的仰慕之情。王大法测试时便已说过他所期望的爱情是门当户对，显然校花并不是他所期待的人，因此他对校花的感情量自己都不会说清楚。至于迈克，校花也许的确对迈克有点好感，但迈克显然给不了校花幸福，首先，迈克并不知道什么是责任，测试时便已清楚他的情绪宣泄是暴力，倘若青春期那股passion磨灭了，后果自行脑补。其次迈克给不了校花真正需要的。之所以前期近似完美的校花最后会有那么一出戏，其实很容易看出的。江依琳需要一场舞蹈独秀以支撑日后的发展，身为天才的少年们有谁能给呢，因此江依琳选择了富家公子哥，这都是情理之中。而此时的天才们只顾自己的感受，仗着长久以来老师的庇护去炸车。所以，当看到周知庸老师泼江依琳水时，我倒有点替校花感到冤枉，自己争取来的前途就因为接近了天才们而被老师给毁了。而周老师之所以泼水，也许是曾经旧时代里被戏弄过，旧火新火全发泄在了江依琳身上。</p><p>周知庸老师，典型旧时代的人，因为自己未能拿奖的遗憾，而把希望寄托在新时代的少年天才们身上。也许努力学习没有错，但他忽略了当今世界已不是简简单单努力学习就能改变的了。当一个人不愿接受新时代时，他已经被这个时代所遗弃，成为旧时代的古董。当他最后不在从事教育事业，专心于交际时，此刻的他应该是幸福的。</p><p>不过，周老师错了吗，没人能说他错了。至少20多年来，他一直秉持着初心，坚守着梦想，对于现代人来说，这一点是多么的可贵呢。社会这个大染缸将每一个青春期怀穿着梦想的少年少女染成形形色色为生活而忙碌的机器，又有几个人能站出来说我要改变这个世界呢。我感觉说这话的人并不丢人，反而是那些早已面目全非的人让人可悲。</p><p>不知不觉，恭喜我又成功把我给绕进去了。我竟然有分不清自己的立场了，呵呵。不过不论什么样的人，坚持做好自己就好。正处于大学生活的我们，无论何时都要坚持自己的梦想，不必在意那些圆滑的人说你不够圆滑，不必在意那些所谓成熟的人说你不够成熟，不要照原样接受别人的生活。选择坚守，选择理想，选择倾听自己内心深处的呼唤。因为在这个充满怀疑的世界，我们依旧需要梦想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="影评" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>回忆若一指流沙，散落了谁的风华</title>
    <link href="http://qianyouyou.cn/2018/06/11/2018-06-11/"/>
    <id>http://qianyouyou.cn/2018/06/11/2018-06-11/</id>
    <published>2018-06-11T06:16:28.000Z</published>
    <updated>2018-06-11T09:23:54.552Z</updated>
    
    <content type="html"><![CDATA[<p>宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。</p><p>后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有一种壮志凌云。</p><p>在宁夏，没有高楼大厦，但远处的山峰鳞次栉比。没有车水马龙，但广阔的天空一碧如洗。一切都安顿好之后，我们便奔向当地特色小吃而去。宁夏理工学院，坐落在湖心的一座岛屿之上，可以说，一座岛屿即一座城。很快我们便摸不清方向了。此时，一个小姐姐跑过来跟我们搭讪。由于比赛都发的队服，很是显眼，显然，她是被我们的队服吸引而来的。就这样莫名其妙的，我们渐渐熟悉。在她的带领下，我们逛了校园，逛了小吃摊……</p><p>宁夏昼长夜短，即使到了晚上八九点，天依然为褪色。就这样逛着逛着，吃着吃着，天就黑了，当我们看时间时，已是十点多了。我们留下了联系方式，各自归宿。</p><p>第2天，宁夏理工学院组织我们所有参赛者一起去旅游，地点是沙湖，即沙漠中的一片绿洲。我们队和昨天的小姐姐约好今天一起游玩，而我们队刚好缺了一个教练，就这样理所当然的，她以我们教练的身份一起踏上了沙漠的旅程。</p><p>一路上，我们划过了湖泊，翻过了沙漠，跨过了沙丘，因为她的出现，在她的陪伴下，我们的旅程不再显得单调乏味。在沙漠中，偶然发现某片沙地里满是荆棘，当跨过荆棘之后，望到了一片花海。尽管花在强烈的阳光下已奄奄一息，然而它们仿佛在用生命证明自己存在的意义。同伴们纷纷前往亭下避暑，只有我守着安静的沙漠，等待着花开。</p><p>第3天，终于要比赛了。经过了上一次失败的经验，这次尽管最后一次提交因为时间到了没有提交成功，不过好在前两个半小时成功A了3道题，我们队最终斩获一枚铜奖，也算是这么多月的训练也算有了一个回报。</p><p>临别时，小姐姐教练来为我们送行，并带来当地的特产。因为赶飞机，我们草草照相留念之后，便踏上了返程的飞机。</p><p>戴上耳机，梳理着三天的回忆。其实我们每个人来到这个世界上，就只能义无反顾的前进。在人生的道路上，除了自己，其他人都只能伴我们走过一程。这一程，或长或短，也许转瞬已尽，也许直通彼岸，但永远不会是永远。当走完这一程，余下的路需由自己来走完。然而不必逗留着，因为每时每刻，都会有新的过客伴你走过新的一程。尽管离别之后，我们可能会永远不见，但彼此走过的那份欢乐，永远藏在心里。</p><p>谢谢你伴我们走过这三天，也许今后永远不会再见，但我们走过的那段旅程以及旅程中的你我永远不会失散。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。&lt;/p&gt;
&lt;p&gt;后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>API函数配置读写文件</title>
    <link href="http://qianyouyou.cn/2018/06/03/2018-06-03/"/>
    <id>http://qianyouyou.cn/2018/06/03/2018-06-03/</id>
    <published>2018-06-03T15:19:41.000Z</published>
    <updated>2018-06-03T15:32:58.144Z</updated>
    
    <content type="html"><![CDATA[<p>cfg_op.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">//获取配置项</span><br><span class="line">int GetCfgItem(char *pFileName/*in*/, char*pKey/*in*/, char *pValue/*in out*/, int *pValueLen/*out*/);</span><br><span class="line">//写配置项</span><br><span class="line">int WriteCfgItem(char*pFileName/*in*/, char *pKey/*in*/, char *pValue/*in*/, int *ValueLen/*in*/);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>cfg_op.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define Maxline 2048</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">int GetCfgItem(char *pFileName, char*pKey, char *pValue, int *pValueLen)</span><br><span class="line">&#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char lineBuf[Maxline];</span><br><span class="line">char *pTmp = NULL, *pEnd = NULL, *pBegin = NULL;</span><br><span class="line">fp = fopen(pFileName, &quot;r&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">ret = -1;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">while (!feof(fp)) &#123;</span><br><span class="line">memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">fgets(lineBuf, Maxline, fp);</span><br><span class="line">printf(&quot;lineBuf:%s &quot;, lineBuf);</span><br><span class="line"></span><br><span class="line">pTmp = strchr(lineBuf, &apos;=&apos;);</span><br><span class="line">if (pTmp == NULL) &#123;//没有=号</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp = strstr(lineBuf, pKey);</span><br><span class="line">if (pTmp == NULL) &#123;//判断key是不是在//所在行 是不是有key</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp = pTmp + strlen(pKey);//mykey1 = myvalue11111111==&gt;&quot;myvalue11111111&quot;</span><br><span class="line">pTmp = strchr(pTmp, &apos;=&apos;);</span><br><span class="line">if (pTmp == NULL) &#123;//判断所在行是不是有key</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp++;</span><br><span class="line">printf(&quot;pTmp:%s &quot;, pTmp);</span><br><span class="line">//获取value起点</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (*pTmp == &apos; &apos;) &#123;</span><br><span class="line">pTmp++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">pBegin = pTmp;</span><br><span class="line">if (*pBegin == &apos;\n&apos;) &#123;</span><br><span class="line">//没有配置value</span><br><span class="line">printf(&quot;配置项:%s 没有配置value \n&quot;, pKey);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取value结束点</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (*pTmp == &apos; &apos; || *pTmp == &apos;\n&apos;) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">pTmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pEnd = pTmp;</span><br><span class="line">//赋值</span><br><span class="line">*pValueLen = pEnd - pBegin;</span><br><span class="line">memcpy(pValue, pBegin, pEnd - pBegin);</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line">if (fp == NULL)</span><br><span class="line">fclose(fp);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">int WriteCfgItem(char*pFileName, char *pKey, char *pValue, int *ValueLen)</span><br><span class="line">&#123;</span><br><span class="line">int rv = 0, iTag = 0, length = 0;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char lineBuf[Maxline];</span><br><span class="line">char *pTmp = NULL, *pBegin = NULL, *pEnd = NULL;</span><br><span class="line">char filebuf[1024 * 8] = &#123; 0 &#125;;</span><br><span class="line">if (pFileName == NULL || pKey == NULL || pValue == NULL) &#123;</span><br><span class="line">rv = -1;</span><br><span class="line">printf(&quot;SetCfgItem() err. param err \n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(pFileName, &quot;r+&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -2;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -3;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fseek(fp, 0L, SEEK_END);//把文件指针从0位置开始，移动到文件末尾</span><br><span class="line">//获取文件长度</span><br><span class="line">length = ftell(fp);</span><br><span class="line">fseek(fp, 0L, SEEK_SET);</span><br><span class="line">if (length &gt; 1024 * 8) &#123;</span><br><span class="line">rv = -3;</span><br><span class="line">printf(&quot;文件超过1024*8,nunsupport&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">while (!feof(fp)) &#123;</span><br><span class="line">//读每一行</span><br><span class="line">memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">pTmp = fgets(lineBuf, Maxline, fp);</span><br><span class="line">if (pTmp == NULL) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//key关键字是否在本行</span><br><span class="line">pTmp = strstr(lineBuf, pKey);</span><br><span class="line">if (pTmp == NULL)//key关键字不在本行，copy到filebuf中</span><br><span class="line">&#123;</span><br><span class="line">strcat(filebuf, lineBuf);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else//key关键字在本行中，替换旧的行，再copy到filebuf中</span><br><span class="line">&#123;</span><br><span class="line">sprintf(lineBuf, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">strcat(filebuf, lineBuf);</span><br><span class="line">//若存在key</span><br><span class="line">iTag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//若key关键字，不存在 追加</span><br><span class="line">if (iTag == 0) &#123;</span><br><span class="line">fprintf(fp, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//若key关键字，存在，则重新创建文件</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">fclose(fp);</span><br><span class="line">fp = NULL;//避免野指针</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -4;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">fputs(filebuf, fp);</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line">return rv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&quot;cfg_op.h&quot;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define CFGNAME &quot;d:/mycfg.ini&quot;</span><br><span class="line">//读配置项</span><br><span class="line">int GetCfg() &#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">char name[1024] = &#123; 0 &#125;;</span><br><span class="line">char value[1024] = &#123; 0 &#125;;</span><br><span class="line">int vlen = 0;</span><br><span class="line">printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line">ret = GetCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">printf(&quot;func GetCfgItem err:%d \n&quot;, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;value:%s \n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">//写配置项</span><br><span class="line">int TWriteCfg() &#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">char name[1024] = &#123; 0 &#125;;</span><br><span class="line">char value[1024] = &#123; 0 &#125;;</span><br><span class="line">int vlen = 0;</span><br><span class="line">printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line">printf(&quot;\n请输入Value:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, value);</span><br><span class="line">WriteCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">printf(&quot;func WriteCfgItem err:%d \n&quot;, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;您的输入是：%s = %s \n&quot;, name, value);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show_menu() &#123;</span><br><span class="line">printf(&quot;==========================\n&quot;);</span><br><span class="line">printf(&quot;1.测试写配置文件\n&quot;);</span><br><span class="line">printf(&quot;2.测试读配置文件\n&quot;);</span><br><span class="line">printf(&quot;0.退出\n&quot;);</span><br><span class="line">printf(&quot;==========================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int choice;</span><br><span class="line">show_menu();</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;choice)) &#123;</span><br><span class="line">//显示一个菜单</span><br><span class="line">switch (choice) &#123;</span><br><span class="line">case 1:</span><br><span class="line">TWriteCfg();</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">GetCfg();</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">show_menu();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cfg_op.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="文件" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="API函数" scheme="http://qianyouyou.cn/tags/API%E5%87%BD%E6%95%B0/"/>
    
      <category term="文件" scheme="http://qianyouyou.cn/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>牛客训练赛19之托米专场</title>
    <link href="http://qianyouyou.cn/2018/06/01/2018-06-01/"/>
    <id>http://qianyouyou.cn/2018/06/01/2018-06-01/</id>
    <published>2018-06-01T15:42:31.000Z</published>
    <updated>2018-07-15T14:27:17.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="托米的简单表示法"><a href="#托米的简单表示法" class="headerlink" title="托米的简单表示法"></a><a href="https://www.nowcoder.com/acm/contest/111/A" target="_blank" rel="noopener">托米的简单表示法</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   作为故事主角的托米是一名老师。  </p></blockquote><p>  一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: </p><p>  几何表示的定义： </p><p>  <strong>1.</strong>          <strong>对于一个括号序列A，我们定义g(A)是A的几何表示形式,则          “()”的表示是一个1*1的方块，高度为1;</strong>            <strong>2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1; 3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。 其中+指的是字符串的连接符。</strong>  </p><p>​                              </p><p>  在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： </p><p>  <img src="https://uploadfiles.nowcoder.com/images/20180529/301599_1527594747449_9C23C3C01AAE429614DCD886F400FAF2" alt="img"></p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入的第一行包含一个整数T，表示指定测试用例的数量。</span><br><span class="line">每个测试用例前面都有一个空白行。</span><br><span class="line">每个测试用例由一个合法括号序列组成。 每行只包含字符&apos;(&apos;和&apos;)&apos;。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">((()))</span><br><span class="line"></span><br><span class="line">(())(()(()))</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二个测试案例是上图中显示的案例。</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1≤T≤10</span><br><span class="line">一个合法括号序列长度≤4 x 105</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题提交了好多次，一直WA。后来改成long long就过了。原理很简单，就是遇见左括号入栈，遇见右括号出栈。在入栈出栈时执行操作。先入栈的高度比后入栈的最高高度要高1，初始宽度为1，每执行一次出栈操作，出栈元素前一个元素的宽度等于他自身宽度加上出栈元素宽度再加1。而出栈元素的面积等于宽乘高减去包含元素的面积。就这样，每次出栈时，前一个元素宽度加上该元素宽度加1，前元素将要减去的面积area等于出栈元素的面积minu。而出栈元素的面积area等于高乘宽减去将要减去的面积minu。最终由于0位置没有面积，就是全域，那他的minu即将要减去的面积就是总面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200010;</span><br><span class="line">char str[maxn*2];</span><br><span class="line">ll high[maxn],wed[maxn],area[maxn],minu[maxn],mystack[maxn];</span><br><span class="line">ll fun()&#123;</span><br><span class="line">    int cnt = 1,head = 1,tail = 1,len = strlen(str);</span><br><span class="line">    memset(high,0,sizeof(high));</span><br><span class="line">    memset(wed,0,sizeof(wed));</span><br><span class="line">    memset(minu,0,sizeof(minu));</span><br><span class="line">    memset(mystack,0,sizeof(mystack));</span><br><span class="line">    for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">        if(str[i] == &apos;(&apos;)&#123;</span><br><span class="line">            mystack[tail++]=cnt++;</span><br><span class="line">            high[mystack[tail - 1]]++;</span><br><span class="line">            wed[mystack[tail - 1]] = 1;</span><br><span class="line">            if(high[mystack[tail - 2]] &lt;= high[mystack[tail - 1]])</span><br><span class="line">                high[mystack[tail - 2]] = high[mystack[tail - 1]] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(str[i] == &apos;)&apos;)&#123;</span><br><span class="line">            if(tail &gt; 1)&#123;</span><br><span class="line">                if(high[mystack[tail-2]] &lt;= high[mystack[tail-1]])</span><br><span class="line">                    high[mystack[tail-2]] = high[mystack[tail-1]] + 1;</span><br><span class="line">                tail--;</span><br><span class="line">                wed[mystack[tail - 1]] += wed[mystack[tail]] + 1;</span><br><span class="line">                area[mystack[tail]] = wed[mystack[tail]] * high[mystack[tail]] - minu[mystack[tail]];</span><br><span class="line">                minu[mystack[tail - 1]] += area[mystack[tail]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minu[0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        cout &lt;&lt; fun() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托米的饮料"><a href="#托米的饮料" class="headerlink" title="托米的饮料"></a><a href="https://www.nowcoder.com/acm/contest/111/E" target="_blank" rel="noopener">托米的饮料</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   好了，现在是小托米的故事啦~~~  </p></blockquote><p>  可爱的小托米得到了n瓶饮料. </p><p>但他不小心把开盖的工具弄丢了,所以他只能利用饮料瓶来开盖.</p><p>已知第i个瓶子的品牌为a</p><p>i</p><p>,且其能打开b</p><p>i</p><p>品牌的瓶子.</p><p>问有几瓶饮料托米无法喝到.</p><p><strong>被用于打开饮料瓶的瓶子不一定需要被打开.</strong></p><p><strong>一个瓶子不能打开其本身.</strong></p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n,表示饮料的瓶数.</span><br><span class="line">接下来n行,每行两个整数ai,bi.</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数,表示小托米无法喝到的饮料瓶数.</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1≤n≤100</span><br><span class="line">1≤ ai,bi≤ 1000</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>本题坑人之处在于理解题意。因为没理解题意导致提交了好多次才提交成功。本题实质很简单，就是每个瓶子对应有一个编号b，可以开这个编号b除了自己以外的所有的瓶子。但仅限于该瓶子，其他瓶子也只能执行自己的编号b。首先输入完成时记录下所有编号的瓶子个数，把n赋给瓶子个数cnt，因为一开始n个瓶子都没打开。接着对b按顺序进行遍历，如果对应编号的瓶子不存在，则不执行操作，否则接着判断，如果a和b不同，则cnt减去该瓶子的数量，然后数量置零，因为该类瓶子已经打开完了，之后不需要再打开，否则执行完操作后再加1，因为不能打开自己。最后cnt就是剩下没打开的数量。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1010]=&#123;0&#125;,a[1010],b[1010];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int cnt = n;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        vis[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[b[i]])&#123;</span><br><span class="line">            cnt-=vis[b[i]];</span><br><span class="line">            vis[b[i]]=0;</span><br><span class="line">            if(a[i]==b[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[b[i]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托米搭积木"><a href="#托米搭积木" class="headerlink" title="托米搭积木"></a><a href="https://www.nowcoder.com/acm/contest/111/F" target="_blank" rel="noopener">托米搭积木</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>  小托米真的很可爱呀(&gt;_&lt;) </p></blockquote><p>  这天,可爱的小托米得到了n堆积木,且第i堆积木初始时有ai块积木. </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一行两个整数n,m.</span><br><span class="line">第二行n个整数,第i个整数代表ai的值.</span><br><span class="line">接下来m行,每行代表一个操作:</span><br><span class="line">第一个整数t代表操作的类型</span><br><span class="line">若t=1,则接下来两个整数v,x,代表操作1.</span><br><span class="line">若t=2,则接下来一个整数y,代表操作2.</span><br><span class="line">若t=3,则接下来一个整数q,代表操作3.</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个操作3,输出其对应的答案.</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10 11</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">3 2</span><br><span class="line">3 9</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">1 1 10</span><br><span class="line">2 10</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">39</span><br></pre></td></tr></table></figure><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤ 105</span><br><span class="line">1≤ai≤109</span><br><span class="line">1≤t≤3</span><br><span class="line">1≤v≤ n,1≤ x≤109</span><br><span class="line">1≤y≤104</span><br><span class="line">1≤q≤n</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>很简单的一道题，3种操作，第1操作是把第i位置的数该为另一个数x，第2个操作是所有数加v，第3个操作是查询某一位置的数。首先分析，第1种操作和第3种操作时间复杂度都是O(1),第2中操作如果每位加v的话时间复杂度O(n)。所以优化在于第2操作。不过对于此操作我们可以降维优化，因为是所有数都加v，那么我们只需把v记录下来，每次查询时对查询的数直接加v就行了。这样就又遇到了一个问题，就是假如所有的数现在的状态是加v，而i位置元素现在变成了x，这样就会造成所有元素相加不一致。解决也很简单，只需每次变成x后，给x减去v就行了，这样查询时再加上v结果并没变。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">int a[100010], cnt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    int t,x,y;</span><br><span class="line">    cnt=0;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        if(t==3)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;a[x]+cnt&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==2)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cnt+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            a[x]=y;</span><br><span class="line">            a[x]-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;托米的简单表示法&quot;&gt;&lt;a href=&quot;#托米的简单表示法&quot; class=&quot;headerlink&quot; title=&quot;托米的简单表示法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/111/A&quot; target=&quot;_
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>[心路历程]心境决定处境，心界决定眼界</title>
    <link href="http://qianyouyou.cn/2018/05/31/2018-05-31/"/>
    <id>http://qianyouyou.cn/2018/05/31/2018-05-31/</id>
    <published>2018-05-31T04:51:35.000Z</published>
    <updated>2018-06-11T06:35:27.499Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸，但此刻的你并没有精力寻找彼岸的方向，因为你的心思全放在了如何不被突如其来的大水淹没，于是你拼命的寻找救命稻草，以阻止自己下沉。就这样，在慌乱的过程中，阻止了你上岸的步伐。</p><p>假如一开始你没有目标，那么此时这种状态并非坏事。因为当你在水里抓住救命稻草之后，会寻找彼岸的方向。如果你足够冷静，此刻你会总结你和他的差距在哪里，从而为自己确立目标，并参考他的经历为自己制定计划。如果你不够冷静，那此时你也许会照搬别人的做法，以别人的目标为自己的目标。这样也许会走很多弯路，做许多无用功，但至少比之前毫无目标浑浑噩噩要好得多，同时这段经历也会成为你如何成长道路上的一比财富。</p><p>倘若你一开始就有自己的目标，有属于自己的彼岸，而当你看到有人已经走到人生的彼岸时，你会怀疑自己走过的路，即使彼岸就在前方，你也会动摇，因为你还没有到达彼岸，没有见过彼岸的风景。假如此时的你停下脚步眺望对方的彼岸，那无疑是致命的。它就像突如其来的潮水，可能会拖延了你前行的道路，更有可能会动摇你前行路上的决心，甚至改变你前进的方向。</p><p>我有一个计算机系的舍友，他的目标是考研。自大一以来一直成绩优异，大二时便已轻松通过四六级，而且交际甚广，可谓前程平坦，身边阳光明媚。但此时，某人给他发了一个自己做的贺卡程序，看起来挺酷，此时他开始动摇了。因为自进校以来同学们一直都是面对黑窗口敲代码，敲出来的也是黑窗口，从来没有想过有人能够编出应用来。他说，当他收到那份礼物时，心中交错的并不是喜悦，而是迷惘。就好像春天的果树看着繁花满庭，而自己却总是开不出花，便开始抱怨自己的价值，而忘记了自己的果实要等到秋天才能品尝。于是当他看到别人已经拥有了强大的实力并且取得相应的成果，而自己还停留在课本中的C语言基础知识，不会应用，顿时思绪万千，怀疑自己走的道路，怀疑学校的课程安排。那种感觉，就像走着走着掉进水里一样。</p><p>此时，他拼命的寻找救命稻草。终于，他抓到了第一根救命稻草。他开始跟着别人做项目，一起写程序，别人打比赛，他便开始模拟比赛。在这段时间，他感到生活变得充实，做事也有动力，因为他也想拥有像那个人一样的实力，像那个人一样去打比赛。但正当他感觉找到目标时，选拔结果出来了，正式比赛的名额没有他，他落选了。此时的他顿时感觉自己又失去了方向。于是他又开始寻找救命稻草。他抓到的第二根救命稻草是校外的编程培训班。于是他果断交了大笔费用去报了培训班。在培训班里，他又燃起了希望，因为在这里，老师讲的一些东西都是课本上所没有的，老师还经常在课堂上带他们写一些小应用，这些都是他们以前不曾经历过的。由于这种模式以前没有接触过，所以便对学的东西燃起了兴趣，即使一切都是从头开始学习，即使许多东西以前都学过。就这样过了两个月，当他冷静下来，重新审视自己时，才发现自己真正要走的路的还是考研，而这段时间所学的技术只是就业路上的一个工具。而培训班中的许多东西其实学校的课程里都有，只是他从未重视过，没接触过的东西未来也会学习。就这样，他又开始了最初的考研复习之路。</p><p>那么，当我们在前行的路上看到别人已经到达人生的彼岸或者接近人生的彼岸时该怎么办呢。</p><p>其实，一个人的心境决定了这个人的处境。假如心中拥抱黑暗，那么眼之所见也会变得暗淡。即使前程平坦，阳光盎然，你也望不见人生的彼岸。假如心中充满光明，那么黑夜也会为你亮起星光。即使道路坎坷，前程黑暗，你也会收获自信坚定向前。</p><p>以我为例，记得之前比赛失利，没有获奖，而朋友却在其他项目中表现优异，此时的我就像《三体》中经历水滴之战惨败而侥幸逃跑的舰队队长一样，当看到章北海率领的舰队未雨绸缪时，眼前是一片黑暗，不由自主地感叹:”好黑，真tm的黑啊”。此刻的我早已迷失了方向，整日思绪想的是同样是付出，朋友们一个个却硕果累累，而我却像墙角的蘑菇怎么也沐浴不到阳光。为了这场比赛，准备了一个多月，那段时间翘了许多节课，一心研究算法，而最后连个证明自己这段时间的成果都没有。眼前面临的是各种各样的考试，以及英语四级考试，顿时怀疑自己之前的付出是否值得。其实在不久之后又有一次比赛，而此时的我却整日处于悲观之中，害怕下次比赛同样拿不到成绩，害怕考试失利，害怕英语四级。此刻的我，感到人人都各有所长，就只有自己一直处于失败当中，人人都比我成功。于是我把自己包裹起来，不喜欢与人交流，感觉每个人都很虚伪，从此变得越来越冷漠。就这样，我一边准备比赛，一边疯狂复习，一边孤独，一边迷惘。由于同时选择多种方向，最终也一事无成。马上就要比赛了，此刻的我偶然间望见教室的窗外阳光依旧明媚，回忆起之前努力奋斗的日子里也是同样的阳光，望着这从未消逝的阳光，我重新总结了一下这段时间的经历，终于明白，其实阳光很好，世界很好，所有人都很好，只是我的心态变得暗淡了。当我重新投入到阳光灿烂的日子里，此时发现，其实许多人都在羡慕我。尽管我没有拿到奖，但这段时间我的实力已经突飞猛进。虽然我没有收获奖杯，但我却收获了成长，坚定了方向。</p><p>所以，心界决定了眼界。当你凝视黑暗的时候，黑暗也在呼唤着你。倘若一个人心中见不到光，那么对他而言，整个世界都是黑暗的。当看到别人取得的成就时，只会是羡慕嫉妒恨，自怨自艾。也许有人会说，悲观，是一种远见。但当一个人始终以悲观的态度看待世界，那么所看到的整个世界只剩下冷漠，背叛，黑暗，而你收获的也只有孤独，失望，迷茫。</p><p>不妨敞开心扉，让阳光渗透到我们的心中。此时你会发现，当你看到别人的成就时，更多的是送去祝福，而不是怀疑自己。这样，就不会迷失方向，同时别人的经历中总结经验，化作自己前行的垫脚石。</p><p>阳光很好，我亦很好，整个世界更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>C/C++结构体中的深copy和浅copy&amp;&amp;结构体偏移量的两种求法</title>
    <link href="http://qianyouyou.cn/2018/05/30/2018-05-30/"/>
    <id>http://qianyouyou.cn/2018/05/30/2018-05-30/</id>
    <published>2018-05-30T11:56:43.000Z</published>
    <updated>2018-05-30T13:36:55.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅copy："><a href="#浅copy：" class="headerlink" title="浅copy："></a>浅copy：</h2><p>编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，拷贝之后释放内存就不会出现问题。但是如果结构体中含有指针变量的时候，编译器只会copy指针变量，而对应的内存空间却不会缺不再多分配。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">char a[64];</span><br><span class="line">int b;</span><br><span class="line">char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">*to = *from;</span><br><span class="line">//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">note d, e;</span><br><span class="line">strcpy(d.a, &quot;123&quot;);</span><br><span class="line">d.b = 456;</span><br><span class="line">while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(d.c, &quot;789&quot;);</span><br><span class="line">printf(&quot;d的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">my_copy(&amp;d, &amp;e);</span><br><span class="line">printf(&quot;e的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">if (d.c != NULL) &#123;</span><br><span class="line">free(d.c);</span><br><span class="line">d.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此样例为例，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br><span class="line">e的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure><p>然后接着某些编译器如vs的编译器就会报错。出错位置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是由于将结构体d内存元素直接赋给结构体e时，即进行 <em> e= </em> d操作时，由于结构体中含有指针元素，d结构体中的指针已经动态分配内存，而操作完成之后e中指针的值也会写上d动态分配内存的地址，因此d和e指向同一内存空间。这样当d中指针d.c释放内存之后，由于e.c仍然指向该部分内存，而不指向空，此时会强制释放掉e.c所指向内存，由于此处内存已经释放过了，处于不能被访问状态，而e.c又强制释放该内存，就会造成vs编译器报错。这就是前copy的弊端。</p><h2 id="深copy："><a href="#深copy：" class="headerlink" title="深copy："></a>深copy：</h2><p>编译器会为拷贝的对象分配一定的内存空间。</p><p>以上述代码为例，只需在进行 <em> e= </em> d操作之后再为e.c重新分配内存，然后执行strcpy(e,d)即可。这样e.c和d.c分别指向两块不同的内存，这样就不会出现上面那种错误。</p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">char a[64];</span><br><span class="line">int b;</span><br><span class="line">char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">*to = *from;</span><br><span class="line">//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">while ((to-&gt;c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(to-&gt;c, from-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">note d, e;</span><br><span class="line">strcpy(d.a, &quot;123&quot;);</span><br><span class="line">d.b = 456;</span><br><span class="line">while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(d.c, &quot;789&quot;);</span><br><span class="line">printf(&quot;d的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">my_copy(&amp;d, &amp;e);</span><br><span class="line">printf(&quot;e的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">if (d.c != NULL) &#123;</span><br><span class="line">free(d.c);</span><br><span class="line">d.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏移量的求法"><a href="#偏移量的求法" class="headerlink" title="偏移量的求法"></a>偏移量的求法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct note&#123;</span><br><span class="line">    char name[64];</span><br><span class="line">    int age;</span><br><span class="line">    int sex;</span><br><span class="line">&#125;a,*p;</span><br><span class="line">p=&amp;a;</span><br></pre></td></tr></table></figure><p>以p为例求p-&gt;age偏移量</p><h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsize = (int)&amp;(p-&gt;age)-(int)p;</span><br></pre></td></tr></table></figure><h3 id="间接法"><a href="#间接法" class="headerlink" title="间接法"></a>间接法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsize = (int)&amp;(((*note)0)-&gt;age);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅copy：&quot;&gt;&lt;a href=&quot;#浅copy：&quot; class=&quot;headerlink&quot; title=&quot;浅copy：&quot;&gt;&lt;/a&gt;浅copy：&lt;/h2&gt;&lt;p&gt;编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="结构体" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="结构体" scheme="http://qianyouyou.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>关于模拟或暴力类型题的时间复杂度降维优化举例</title>
    <link href="http://qianyouyou.cn/2018/05/29/2018-05-29/"/>
    <id>http://qianyouyou.cn/2018/05/29/2018-05-29/</id>
    <published>2018-05-29T12:39:04.000Z</published>
    <updated>2018-05-29T12:50:23.458Z</updated>
    
    <content type="html"><![CDATA[<p>首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即实现由0(…)0(N)-&gt;0(…)0(1)的降维过程。但推导公式往往是一件很麻烦的事情，因此推导公式是模拟类题的关键。以下两道题原本是用模拟或暴力来解决，但其实它们都是可以优化的，例如第一题只需要求周期内的数与周期即可，不用遍历全部数，第2题只需对该数n进行分析即可，时间复杂度0(1)，不用从1遍历到n一个个进行统计。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>百度熊对数学一直都非常感兴趣。最近在学习斐波那契数列的它，向你展示了一个数字串，它称之为“斐波那契”串：</p><p>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11235813471123581347112358…</span><br></pre></td></tr></table></figure><p>聪明的你当然一眼就看出了这个串是这么构造的：</p><ol><li><p>先写下两位在0~9范围内的数字a, b，构成串ab；</p></li><li><p>取串最后的两位数字相加，将和写在串的最后面。</p></li></ol><p>上面百度熊向你展示的串就是取a = b = 1构造出来的串。</p><p>显然，步骤1之后不停地进行步骤2，数字串可以无限扩展。现在，百度熊希望知道串的第n位是什么数字。</p><p>输入数据的第一行为一个整数T（1 ≤ T ≤1000）, 表示有T组测试数据；每组测试数据为三个正整数a, b, n（0 ≤ a, b &lt; 10, 0 &lt; n ≤109）。</p><p>对于每组测试数据，输出一行“Case #c: ans”（不包含引号） c是测试数据的组数，从1开始。</p><p>提示：</p><ol><li><p>对于第一、二组数据，串为112358134711235…</p></li><li><p>对于第三组数据，串为14591459145914…</p></li></ol><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">1 1 8</span><br><span class="line">1 4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 3</span><br><span class="line">Case #3: 9</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 500;</span><br><span class="line">int t, c, d, n, cyc, cnt;</span><br><span class="line">int a[maxn], vis[maxn];</span><br><span class="line">int init()&#123;</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    a[1] = c;</span><br><span class="line">    a[2] = d;</span><br><span class="line">    cnt = 2;</span><br><span class="line">    while(!vis[a[cnt-1]*10+a[cnt-0]])&#123;</span><br><span class="line">        vis[a[cnt-1]*10+a[cnt]] = cnt;</span><br><span class="line">        int tmp = a[cnt-1] + a[cnt];</span><br><span class="line">        if(tmp&lt;10)</span><br><span class="line">            a[++cnt]=tmp;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[++cnt]=tmp/10;</span><br><span class="line">            a[++cnt]=tmp%10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vis[a[cnt-1]*10+a[cnt]];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int i = 1;i&lt;=t;i++)&#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d &gt;&gt; n;</span><br><span class="line">        int res = init();</span><br><span class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;;</span><br><span class="line">        if(cnt&gt;=n)</span><br><span class="line">            cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;a[res+(n-res)%(cnt-res)]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h2><p>试计算在区间 11 到 nn 的所有整数中，数字 xx（0 \leq x \leq 90≤x≤9）共出现了多少次？例如，在 11 到 1111 中，即在 11、22、33、44、55、66、77、88、99、1010、1111 中，数字 11 出现了 4 次。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 1 行，包含 2 个整数 nn、xx，之间用一个空格隔开。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含一个整数，表示 xx 出现的次数。</p><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 100% 的数据，1 \leq n \leq 1,000,0001≤n≤1,000,000，0 \leq x \leq 90≤x≤9。</p><p>忽略每行输出的末尾多余空格</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    int cnt = 0, res = 1, re = 1;</span><br><span class="line">    int tmp = n;</span><br><span class="line">    if(x)&#123;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            int mod = tmp%10;</span><br><span class="line">            cnt+=(res-re)/10*mod;</span><br><span class="line">            if(mod&gt;x)</span><br><span class="line">                cnt+=re;</span><br><span class="line">            else if(mod==x)</span><br><span class="line">                cnt+=n%re+1;</span><br><span class="line">            re*=10;</span><br><span class="line">            res*=10;</span><br><span class="line">            res+=re;</span><br><span class="line">            tmp/=10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)</span><br><span class="line">            for(int j=i;j;j/=10)</span><br><span class="line">                if(j%10==x)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="暴力枚举" scheme="http://qianyouyou.cn/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>[C指针进阶]二级指针做输入的3种内存模型</title>
    <link href="http://qianyouyou.cn/2018/05/26/2018-05-26/"/>
    <id>http://qianyouyou.cn/2018/05/26/2018-05-26/</id>
    <published>2018-05-26T06:24:45.000Z</published>
    <updated>2018-05-30T13:30:40.171Z</updated>
    
    <content type="html"><![CDATA[<p>对于指针，我们只需要从两个角度进行分析即可。</p><p>第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） </p><p>第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一维的还是二维的。 </p><p>今天分析的二维指针三种内存模型都是指针做输入的情况，在主调函数中分配内存。 </p><p>在分析指针之前，先回顾一下内存四区的知识。首先我们知道内存分为5大区，我们暂把BSS段与数据段合称为全局区或者常量区，构成内存四区。以下是内存5大区具体概况。</p><h2 id="内存5大区"><a href="#内存5大区" class="headerlink" title="内存5大区"></a>内存5大区</h2><ul><li><p><strong>BSS段( bss segment )</strong></p><p>通常是指用来存放程序中<code>未初始化的全局变量和静态变量</code> （这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。既然都是0那么就<code>没必要把每个0都存储起来</code>,从而节省磁盘空间,这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。</p></li></ul><hr><ul><li><p><strong>数据段(data segment)</strong></p><p>通常是指用来存放程序中已经<code>初始化的全局变量和静态变量</code>的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,但一般都是放在只读数据段中。</p></li></ul><hr><ul><li><p><strong>代码段(code segment/text segment)</strong></p><p>通常是指用来存放<code>程序执行代码的一块内存区域</code>。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。</p></li></ul><hr><ul><li><p><strong>堆(heap)</strong></p><p>堆是用于存放进程运行中被<code>动态分配的内存段</code>,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减)</p></li></ul><hr><ul><li><p><strong>栈 (stack)</strong></p><p>栈又称堆栈, 是<code>用户存放程序临时创建的局部变量</code>,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在数据段中存放变 量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的先进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。 </p></li></ul><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-25-%E5%86%85%E5%AD%985%E5%8C%BA.png" alt="内存分区图"></p><h2 id="二阶指针做输入的3种内存模型"><a href="#二阶指针做输入的3种内存模型" class="headerlink" title="二阶指针做输入的3种内存模型"></a>二阶指针做输入的3种内存模型</h2><p>接下来我们来讨论二阶指针做输入的3种内存模型。</p><h3 id="第1种"><a href="#第1种" class="headerlink" title="第1种"></a>第1种</h3><p>首先第一种就是指针数组，以字符型指针数组为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char*p1[10];</span><br></pre></td></tr></table></figure><p>指针数组的实质是表示存放指针的数组。 </p><h3 id="第2种"><a href="#第2种" class="headerlink" title="第2种"></a>第2种</h3><p>第二种为二维数组，以字符型二维数组为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char p2[3][4];</span><br></pre></td></tr></table></figure><h3 id="第3种"><a href="#第3种" class="headerlink" title="第3种"></a>第3种</h3><p>第三种为二维指针，以字符型二维指针为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char **p3;</span><br></pre></td></tr></table></figure><p>二维指针是一个存放指针的指针，因此使用前需先开辟一段空间。 </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="指针数组与二维指针的区别："><a href="#指针数组与二维指针的区别：" class="headerlink" title="指针数组与二维指针的区别："></a>指针数组与二维指针的区别：</h4><p>由于二维指针储存的是指针，因此二维指针首先需要开辟空间，然后再在子元素上继续开辟空间，因此需要两步完成。</p><p>而指针数组由于本质上是数组，因此省略了第1步，只需在子元素上继续开辟空间。因此只需要1步完成。</p><p>以动态分配内存为例：</p><p>第1步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof(char *));//等价于 *ptr [3];</span><br></pre></td></tr></table></figure><p>第2步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof (char *));等价于 *ptr [3];</span><br><span class="line">for(i =0;i&lt;3;i++)</span><br><span class="line">    ptr[i] =malloc(sizeof(char)*10);//表示可以存放长度为10 的字符串。</span><br></pre></td></tr></table></figure><p>指针数组只需第2步，二维指针则需要1,2步。</p><p>而除此之外，基本再没有什么区别。他们的步长都是4，即一个指针的内存大小。</p><h4 id="指针数组与数组指针的区别："><a href="#指针数组与数组指针的区别：" class="headerlink" title="指针数组与数组指针的区别："></a>指针数组与数组指针的区别：</h4><p>首先，我们知道，二维数组ptr[2].[2]，ptr的实质是一个数组指针。我们知道，对于一维指针数组a[2]，a本质是指针，只不过a是一个常量指针，即a的值不能被修改。那么对于二维数组ptr[2].[2],ptr是一个常量数组指针，即ptr的值不可修改。</p><p>那么，他们本质的区别是什么呢。首先，对于char <em>p[3]，他的步长是4。即一个指针的内存大小。 </em> (p+1)=p[1],(int)(p+1)-(int)p=4。对于char( <em>p )[3],他的步长是3，即一个数组内存大小。 </em>(p+1) = p[1].[3],(int)(p+1)-(int)p=3。所以这就是为什么指针数组和数组指针不能相互赋值的原因。</p><h2 id="内存模型示意图"><a href="#内存模型示意图" class="headerlink" title="内存模型示意图"></a>内存模型示意图</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-26-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是针对二维指针的3种内存模型进行排序的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">/*排序并输出第1种内存模型:指针数组*/</span><br><span class="line">void sort_myArray1(char **myArray, int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针的指向*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char *tmp = myArray[j];</span><br><span class="line">myArray[j] = myArray[j - 1];</span><br><span class="line">myArray[j - 1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第2种内存模型：二维数组（数组指针）*/</span><br><span class="line">void sort_myArray2(char(*myArray)[4], int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针所指向内存的值*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char tmp[4];</span><br><span class="line">strcpy(tmp, myArray[j]);</span><br><span class="line">strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">strcpy(myArray[j - 1], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第3种内存模型：二维指针*/</span><br><span class="line">void sort_myArray3(char **myArray, int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针所指向内存的值，也可以改写成改变指针的指向*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char tmp[4];</span><br><span class="line">strcpy(tmp, myArray[j]);</span><br><span class="line">strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">strcpy(myArray[j - 1], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*为二级指针分配动态内存并赋值*/</span><br><span class="line">char**get_myArray3(int len) &#123;</span><br><span class="line">char**myArray = NULL;</span><br><span class="line">while ((myArray = (char**)malloc(3 * sizeof(char*))) == NULL) &#123;</span><br><span class="line">printf(&quot;Error.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">while ((myArray[i] = (char*)calloc(100, sizeof(char))) == NULL) &#123;</span><br><span class="line">printf(&quot;Error.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">sprintf(myArray[i], &quot;%d%d%d&quot;, i + 1, i + 2, i + 3);</span><br><span class="line">&#125;</span><br><span class="line">return myArray;</span><br><span class="line">&#125;</span><br><span class="line">/*将动态分配的内存空间释放掉*/</span><br><span class="line">void init_myArray3(char**myArray, int len) &#123;</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">if (myArray[i] != NULL) &#123;</span><br><span class="line">free(myArray[i]);</span><br><span class="line">myArray[i] = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">char*p1[] = &#123; &quot;123&quot;,&quot;456&quot;,&quot;789&quot; &#125;;/*第1种内存模型：指针数组*/</span><br><span class="line">char p2[3][4] = &#123; &quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot; &#125;;/*第2种内存模型：多维数组*/</span><br><span class="line">char**p3 = get_myArray3(3);/*第3种内存模型：二维指针*/</span><br><span class="line">sort_myArray1(p1, sizeof(p1) / sizeof(p1[0]));/*数组的指针个数*/</span><br><span class="line">sort_myArray2(p2, sizeof(p2) / sizeof(p2[0]));/*数组的行数*/</span><br><span class="line">sort_myArray3(p3, 3);/*由于sizeof(p3)为4，即一个指针的大小，故不能用sizeof(p3) / sizeof(p2[3])*/</span><br><span class="line">init_myArray3(p3, 3);</span><br><span class="line">if (p3 != NULL)</span><br><span class="line">free(p3);/*释放掉二维指针分配的内存*/</span><br><span class="line">p3 = NULL;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于指针，我们只需要从两个角度进行分析即可。&lt;/p&gt;
&lt;p&gt;第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） &lt;/p&gt;
&lt;p&gt;第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E6%8C%87%E9%92%88/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[C常量]C语言中的伪装大佬——伪常量const</title>
    <link href="http://qianyouyou.cn/2018/05/25/2018-05-25-1/"/>
    <id>http://qianyouyou.cn/2018/05/25/2018-05-25-1/</id>
    <published>2018-05-25T15:35:44.000Z</published>
    <updated>2018-08-18T04:02:24.943Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的const列出来，以免之后犯错。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先以int为例定义整形常量a的两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br></pre></td></tr></table></figure><p>当然，这两种方法其实是一样的，都代表的是整形常量。对于其他类型也是同样的方法。</p><p>不过对于指针，就有点特别了。首先强调，const和 <em> 的优先级是 </em> 优先级高于const。以下是以字符串为例的</p><p>3种定义方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *p;//char const *p;</span><br><span class="line">char * const p;</span><br><span class="line">const char * const p;//char const * const p;</span><br></pre></td></tr></table></figure><p>第一种指的是p是指向常量字符型数的指针，所指向的内存数据不可以被修改，但是本身可修改。</p><p>第2种指的是p是指向字符型数的常指针，所指向的内存数据可以被修改，但是本身不可被修改。</p><p>第3种是指向常量字符型数的常指针，所指向的内存数据补可被修改，本身也不可被修改。</p><h2 id="伪常量"><a href="#伪常量" class="headerlink" title="伪常量"></a>伪常量</h2><p>用法介绍完了，但为什么说C的const是伪常量呢？因为常量是不可被更改的，但const可以通过简介赋值所改变。我们首先说一下C中的const使用时需要注意的一些细节。</p><p>const是伪常量，无法用于数组的初始化和全局变量的初始化,本质就是限定一个变量不能直接赋值。</p><p>　　如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 #define A 10</span><br><span class="line">2 int arr[A];</span><br><span class="line">3 </span><br><span class="line">4 //const本质，伪常量 ,无法用于数组初始化和全局变量初始化</span><br><span class="line">5 /*</span><br><span class="line">6 const int B = 10;</span><br><span class="line">7 int arr[B];</span><br><span class="line">8 */</span><br></pre></td></tr></table></figure><p>　　但是如果局部变量是能够初始化编译并运行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 void main()</span><br><span class="line">2 &#123;</span><br><span class="line">3     const int B = 10;</span><br><span class="line">4     int arr[B];</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure><p>　　const是伪常量，都知道常量是不能改变值的。例如这样是根本无法编译的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 void main() &#123;</span><br><span class="line">2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line">3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line">4     const int num = 10;//num就是一个常量</span><br><span class="line">5     //num = 11; //const本质，限定一个变量不能直接赋值</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>　　前面一直强调const是伪常量，因为可以间接的去改变它的值。利用指针变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 void main() &#123;</span><br><span class="line"> 2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line"> 3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line"> 4     const int num = 10;//num就是一个常量</span><br><span class="line"> 5     //num = 11; //error const本质，限定一个变量不能直接赋值</span><br><span class="line"> 6 </span><br><span class="line"> 7     //间接改变常量值</span><br><span class="line"> 8     const int *p = &amp;num;//定义一个指针指向一个常量，存储num的地址</span><br><span class="line"> 9     int *pv = (int *)p;//对指向常量的指针进行强制转换</span><br><span class="line">10     *pv = 8;//对指针指向内容赋值</span><br><span class="line">11 </span><br><span class="line">12     printf(&quot;%d&quot;,num); //8</span><br><span class="line">13 </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>c语言的const是冒牌货。C语言const的含义是被称为一个不能被改变的普通变量 ，它会分配内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的cons
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="C语言基础" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="const" scheme="http://qianyouyou.cn/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>[组合数学]取石子</title>
    <link href="http://qianyouyou.cn/2018/05/25/2018-05-25/"/>
    <id>http://qianyouyou.cn/2018/05/25/2018-05-25/</id>
    <published>2018-05-25T14:42:37.000Z</published>
    <updated>2018-05-25T15:31:38.584Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。</p><h2 id="取石子"><a href="#取石子" class="headerlink" title="取石子"></a><a href="https://www.nowcoder.com/acm/contest/113/A" target="_blank" rel="noopener">取石子</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出四堆石子，石子数分别为a,b,c,d。规定每次只能从堆顶取走石子，问取走所有石子的方案数。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一行内读入四个由空格分隔的整数a,b,c,d， 输入均为不超过500的正整数</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示答案，答案对109+7取模</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5 4 2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p>输入均为不超过500的正整数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>我们一堆一堆的考虑。第一堆a，第2堆b，第3堆c，第4堆d。假如只有一堆，则只有1种情况，即C(a,a)。假如有两堆，我们可以当做这两堆石子的排列组合。可以算出两堆石子的方案数。即C(b,a+b)。第三堆我们可以把前两堆看成一堆，然后继续排列组合，即C(c,a+b+c)。第4队即C(d,a+b+c+d)。最后全部相乘即可，即C(a,a) <em> C(b,a+b) </em> C(c,a+b+c)*C(d,a+b+c+d)。</p><h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><p>首先想到暴力枚举，虽然一定超时。以下是代码。只需要把所有情况列一遍即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">ll a[4];</span><br><span class="line">ll cnt = 0;</span><br><span class="line">void dfs(ll a, ll b, ll c, ll d) &#123;</span><br><span class="line">if (!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!d) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">cnt %= 1000000000 + 7;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (a)</span><br><span class="line">dfs(a - 1, b, c, d);</span><br><span class="line">if (b)</span><br><span class="line">dfs(a, b - 1, c, d);</span><br><span class="line">if (c)</span><br><span class="line">dfs(a, b, c - 1, d);</span><br><span class="line">if (d)</span><br><span class="line">dfs(a, b, c, d - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">dfs(a[0], a[1], a[2], a[3]);</span><br><span class="line">printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>由于数据过大，c++没有大数类，所以用python首先A了一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = input().split()</span><br><span class="line">ans = 1</span><br><span class="line">sum = [int(f[0]),0,0,0]</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    sum[i]=sum[i-1]+int(f[i])</span><br><span class="line">    for j in range(sum[i]-int(f[i])+1,sum[i]+1):</span><br><span class="line">        ans*=j</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    for j in range(1,int(f[i])+1):</span><br><span class="line">        ans//=j</span><br><span class="line">ans%=1000000007</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><p>由于acm不能用python，所以只能再考虑c++。首先由于涉及到除法，所以不能直接取余。</p><p>我没知道公式：C(M,N)=C(M-1,N)+C(M-1，N-1)，这样把除法转化成加法，就可以模运算了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">init();</span><br><span class="line">ll ans = 1;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-M-N-模板"><a href="#C-M-N-模板" class="headerlink" title="C(M,N)模板"></a>C(M,N)模板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。&lt;/p&gt;
&lt;h2 id=&quot;取石子&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="http://qianyouyou.cn/tags/python/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="暴力枚举" scheme="http://qianyouyou.cn/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
</feed>
