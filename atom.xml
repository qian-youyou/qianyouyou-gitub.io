<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2019-08-28T13:20:08.883Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在任务跳转问题上，C#的委托delegate与工厂方法模式的异曲同工之妙</title>
    <link href="http://qianyouyou.cn/2019/08/28/2019-08-28/"/>
    <id>http://qianyouyou.cn/2019/08/28/2019-08-28/</id>
    <published>2019-08-28T12:56:41.000Z</published>
    <updated>2019-08-28T13:20:08.883Z</updated>
    
    <content type="html"><![CDATA[<p>在玩游戏时，常常会有任务跳转。但当跳转类型过多时，对游戏研发者来说，就是一件头疼的事了。之前在做游戏城镇等级模块时，就遇到了任务跳转过多的问题。刚接到任务跳转这个需求时，由于入门未深，便用if-else写的。可以想象一百多行的if-else或者switch是多么壮观啊。。。</p><p>但是当我们只为了完成当日任务，而不为长远维护考虑，那未来将是一件可怕的事情。而且那样的代码，像我这样的人看着也不舒服。</p><p>最近看了C#高级语法，赫然发现C#中的委托不就是C++中的函数指针嘛。于是，对于上述if-else，便有解了。</p><p>我们只需要写一个委托，对应创建一个数组对象，每个跳转类型封装一个方法，再用委托来回调，这样的代码，主方法里只需1行就搞定。</p><p>有没有发现，和设计模式中的工厂方法模式有异曲同工之妙呢。日后维护起来也方便许多。</p><p>接下来我们详细介绍下C#中的委托吧。</p><h1 id="C-委托（Delegate）"><a href="#C-委托（Delegate）" class="headerlink" title="C# 委托（Delegate）"></a>C# 委托（Delegate）</h1><p>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 <strong>System.Delegate</strong> 类。</p><h2 id="声明委托（Delegate）"><a href="#声明委托（Delegate）" class="headerlink" title="声明委托（Delegate）"></a>声明委托（Delegate）</h2><p>委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。</p><p>例如，假设有一个委托：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate int MyDelegate (string s);</span><br></pre></td></tr></table></figure><p>上面的委托可被用于引用任何一个带有一个单一的 <em>string</em> 参数的方法，并返回一个 <em>int</em> 类型变量。</p><p>声明委托的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;</span><br></pre></td></tr></table></figure><h2 id="实例化委托（Delegate）"><a href="#实例化委托（Delegate）" class="headerlink" title="实例化委托（Delegate）"></a>实例化委托（Delegate）</h2><p>一旦声明了委托类型，委托对象必须使用 <strong>new</strong> 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 <strong>new</strong> 语句的参数就像方法调用一样书写，但是不带有参数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public delegate void printString(string s);</span><br><span class="line">...</span><br><span class="line">printString ps1 = new printString(WriteToScreen);</span><br><span class="line">printString ps2 = new printString(WriteToFile);</span><br></pre></td></tr></table></figure><p>下面的实例演示了委托的声明、实例化和使用，该委托可用于引用带有一个整型参数的方法，并返回一个整型值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n);</span><br><span class="line">namespace DelegateAppl&#123;</span><br><span class="line">   class TestDelegate</span><br><span class="line">   &#123;  </span><br><span class="line">   static int num = 10;  </span><br><span class="line">   public static int AddNum(int p)  &#123; </span><br><span class="line">   num += p; return num;</span><br><span class="line">   &#125;</span><br><span class="line">   public static int MultNum(int q)  &#123;</span><br><span class="line">   num *= q; return num;</span><br><span class="line">   &#125;</span><br><span class="line">   public static int getNum()  &#123;</span><br><span class="line">   return num;</span><br><span class="line">   &#125;</span><br><span class="line">   static void Main(string[] args)  &#123; // 创建委托实例</span><br><span class="line">   NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">   NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法</span><br><span class="line">   nc1(25);</span><br><span class="line">   Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">   nc2(5);</span><br><span class="line">   Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 35</span><br><span class="line">Value of Num: 175</span><br></pre></td></tr></table></figure><h2 id="委托的多播（Multicasting-of-a-Delegate）"><a href="#委托的多播（Multicasting-of-a-Delegate）" class="headerlink" title="委托的多播（Multicasting of a Delegate）"></a>委托的多播（Multicasting of a Delegate）</h2><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。</p><p>使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。下面的程序演示了委托的多播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">delegate int NumberChanger(int n); namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">    class TestDelegate</span><br><span class="line">    &#123;</span><br><span class="line">        static int num = 10; public static int AddNum(int p) &#123; num += p; return num; &#125;</span><br><span class="line">        public static int MultNum(int q) &#123; num *= q; return num; &#125;</span><br><span class="line">        public static int getNum() &#123; return num; &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123; // 创建委托实例</span><br><span class="line">            NumberChanger nc;</span><br><span class="line">            NumberChanger nc1 = new NumberChanger(AddNum);</span><br><span class="line">            NumberChanger nc2 = new NumberChanger(MultNum);</span><br><span class="line">            nc = nc1; nc += nc2; // 调用多播</span><br><span class="line">            nc(5);</span><br><span class="line">            Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of Num: 75</span><br></pre></td></tr></table></figure><h2 id="委托（Delegate）的用途"><a href="#委托（Delegate）的用途" class="headerlink" title="委托（Delegate）的用途"></a>委托（Delegate）的用途</h2><p>下面的实例演示了委托的用法。委托 <em>printString</em> 可用于引用带有一个字符串作为输入的方法，并不返回任何东西。</p><p>我们使用这个委托来调用两个方法，第一个把字符串打印到控制台，第二个把字符串打印到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">    class PrintString</span><br><span class="line">    &#123;</span><br><span class="line">        static FileStream fs; static StreamWriter sw;  // 委托声明</span><br><span class="line">        public delegate void printString(string s);  // 该方法打印到控制台</span><br><span class="line">        public static void WriteToScreen(string str) &#123;</span><br><span class="line">            Console.WriteLine(&quot;The String is: &#123;0&#125;&quot;, str);</span><br><span class="line">        &#125;  // 该方法打印到文件</span><br><span class="line">        public static void WriteToFile(string s)  &#123;</span><br><span class="line">            fs = new FileStream(&quot;c:\\message.txt&quot;, FileMode.Append, FileAccess.Write);</span><br><span class="line">            sw = new StreamWriter(fs); sw.WriteLine(s); sw.Flush(); sw.Close(); fs.Close();</span><br><span class="line">        &#125;  // 该方法把委托作为参数，并使用它调用方法</span><br><span class="line">        public static void sendString(printString ps)  &#123;</span><br><span class="line">            ps(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)  &#123;</span><br><span class="line">            printString ps1 = new printString(WriteToScreen);</span><br><span class="line">            printString ps2 = new printString(WriteToFile);</span><br><span class="line">            sendString(ps1); sendString(ps2);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The String is: Hello World</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在玩游戏时，常常会有任务跳转。但当跳转类型过多时，对游戏研发者来说，就是一件头疼的事了。之前在做游戏城镇等级模块时，就遇到了任务跳转过多的问题。刚接到任务跳转这个需求时，由于入门未深，便用if-else写的。可以想象一百多行的if-else或者switch是多么壮观啊。。。
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C#" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C/"/>
    
    
      <category term="Unity3D" scheme="http://qianyouyou.cn/tags/Unity3D/"/>
    
      <category term="Unity" scheme="http://qianyouyou.cn/tags/Unity/"/>
    
      <category term="C#" scheme="http://qianyouyou.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>宽敞的心态，宽敞的世界</title>
    <link href="http://qianyouyou.cn/2019/07/28/2019-07-28/"/>
    <id>http://qianyouyou.cn/2019/07/28/2019-07-28/</id>
    <published>2019-07-28T06:00:49.000Z</published>
    <updated>2019-08-28T12:56:10.925Z</updated>
    
    <content type="html"><![CDATA[<p>忽然发现，来上海也有一段时间了。</p><p>还记得没来上海时，身边回荡着各种声音，上了年纪的长辈们鼓励我年轻人就应该出去闯一闯；父母则是抱着忧虑的念头，总说大城市生活压力大，骗子多，无时无刻都得防备；朋友们相对而言更担心的是我一个人出远门的安全。那时候，心中荡漾的，不清楚是期待，还是恐惧。</p><p>初来上海时，东奔西跑的找房租房，生活上高昂的消费让自己不得不开始学会记录支出，还有工作上初来乍到的各种不适应，总弄得自己身心疲惫；那时候，为最后一个挤上公交地铁而庆幸，为了早起而不得不早睡的无奈。心中徘徊的，应该是厌倦，还有抱怨吧。</p><p>现在呢，发现人们口中的大城市，并没有像人们所描述的那么繁华，也没有人们所描述的那样让人苦不堪言。渐渐地，我发现自己爱上了这里。</p><p>其实啊，上海没变，世界也没变，只有我们的心态变了。</p><p>就像人们议论程序员这个行业，一提到程序员，最多的话题就是996，也就是朝九晚九，每周6天。听到这词，即使没有工作，也难免会让人感觉疲惫。但是，真的如此吗。就像我，工作一段时间，感觉每天都很充实。每周有两天双休，但每次到了双休，玩一天游戏，或者什么也不干，剩下的只有空虚，所以周末能加班就加班，因为加班使自己感到生活的充实与价值。</p><p>还记得刚来学校时，因为热爱编程，而报了计算机专业。那时候，没日没夜敲代码是我的快乐。快找实习时，也是没日没夜敲代码，只是感觉到的是苦涩。而工作一段时间后，当我又开始忙碌地敲代码时，感觉到的是充实。同样是敲代码，在学校时因为热爱，在找实习时因为迷茫和环境的影响而决定苦涩，现在，是找到了方向。所以，所谓的忙碌，只不过是旁观者的看法。当一个人真正热爱自己的工作时，别人不要求你加班，你也想自己去加班。</p><p>人们都说上海节奏快，但我坚信时代造英雄。</p><p>昨天父亲又给我打了个电话，尽管只是平常地问候，但我却草草结束了话题。我后来发现，渐渐地，我越来越不怎么和父亲说话了。因为每次父亲跟我洽谈，总是告诫我一些关于社会让人多么的无奈，或者大城市节奏太快压力太大，亦或是社会上到处都是坏人，即使同一屋檐下也要上一把锁。这并不是我父亲一个人的想法，而是我们那个小城镇普遍的想法。</p><p>受我父亲的影响，刚上大学时，因为父亲说西安是贼城，当时我坐个公交都得把包背到前面。但久而久之，我发现并不是所有人都是坏人，那些不美好只不过是世界的冰山一角，但更多地是世界的美好，许多人身上都是有光的。只是这冰山一角给人的心理带来了防备，但当我们以这冰山一角来定义世界时，将必定错过整个世界。</p><p>2G时代，将互联网带上中国，成就了搜狐、新浪、网易。3G时代，将互联网带到了生活，成就了百度、阿里、腾讯，号称BAT。4G时代，将互联网带到了人们随身携带的手机，成就了头条、美团、滴滴，号称TMD。如今5G时代的到来，一切皆有可能，如果还停留在旧时代的舒适圈，不肯加快脚步，那么城乡差距就会越来越大。</p><p>放宽心态，多看看世界好的一面，那么哪来那么多烦恼呢。</p><p>如今，我每周周末都会去公寓周围的大超市去逛逛，有时候什么也不买，仅仅是因为里面的音乐让自己舒心。感受了一周的充实，偶尔给自己放个小假，你会发现，生活并不单调。</p><p>追随时代的大步伐，难免会疲惫。偶尔停下脚步，慢下来，感受自己心中所聆听到的声音，你会发现，快节奏的生活，也会有慢下来的情调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忽然发现，来上海也有一段时间了。&lt;/p&gt;
&lt;p&gt;还记得没来上海时，身边回荡着各种声音，上了年纪的长辈们鼓励我年轻人就应该出去闯一闯；父母则是抱着忧虑的念头，总说大城市生活压力大，骗子多，无时无刻都得防备；朋友们相对而言更担心的是我一个人出远门的安全。那时候，心中荡漾的，不清
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>风往何处吹</title>
    <link href="http://qianyouyou.cn/2019/07/08/2019-07-08/"/>
    <id>http://qianyouyou.cn/2019/07/08/2019-07-08/</id>
    <published>2019-07-08T14:07:46.000Z</published>
    <updated>2019-07-08T14:09:51.832Z</updated>
    
    <content type="html"><![CDATA[<p>浅悠悠 7-8</p><p>我不知道，<br>风在往何处吹，<br>吹散了无根的枝叶，<br>还有七月的蔷薇。</p><p>我不知道，<br>风会往何处吹。<br>吹向那紫陌的寂寥，<br>还是霓虹的余辉。</p><p>我不知道，<br>风该往何处吹。<br>吹散那远方的清梦，<br>还是脚下的尘灰。</p><p>我不知道，<br>风向往何处吹。<br>吹向了温存的故事，<br>还有光阴的慈悲。</p><p>我不知道，<br>我什么也不知道。</p><p>也许只有风儿知道方向，<br>那我便化作海浪随风依洄。<br>也许风儿也不知道方向，<br>那我将像那尘埃何处可归。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浅悠悠 7-8&lt;/p&gt;
&lt;p&gt;我不知道，&lt;br&gt;风在往何处吹，&lt;br&gt;吹散了无根的枝叶，&lt;br&gt;还有七月的蔷薇。&lt;/p&gt;
&lt;p&gt;我不知道，&lt;br&gt;风会往何处吹。&lt;br&gt;吹向那紫陌的寂寥，&lt;br&gt;还是霓虹的余辉。&lt;/p&gt;
&lt;p&gt;我不知道，&lt;br&gt;风该往何处吹。&lt;br&gt;吹散那远
      
    
    </summary>
    
      <category term="诗词歌赋" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
      <category term="摘星集" scheme="http://qianyouyou.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/%E6%91%98%E6%98%9F%E9%9B%86/"/>
    
    
      <category term="诗集" scheme="http://qianyouyou.cn/tags/%E8%AF%97%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>微信数据分析笔记</title>
    <link href="http://qianyouyou.cn/2019/06/24/2019-06-24/"/>
    <id>http://qianyouyou.cn/2019/06/24/2019-06-24/</id>
    <published>2019-06-24T00:48:36.000Z</published>
    <updated>2019-06-26T01:35:41.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6月24日"><a href="#6月24日" class="headerlink" title="6月24日"></a>6月24日</h1><h2 id="项目需求分析"><a href="#项目需求分析" class="headerlink" title="项目需求分析"></a>项目需求分析</h2><p>1、男女性别比例</p><p>2、各省好友数量</p><p>3、个性签名云图</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="pyecharts"><a href="#pyecharts" class="headerlink" title="pyecharts"></a>pyecharts</h3><p>一个商业级图表，纯Js图表库。用于生成Echarts图表的类库。</p><h3 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h3><p>中文分词组件。</p><h3 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h3><p>工程设计的Python工具包。包括统计、优化、整合、线性代数模块、傅里叶变换、信号和图像处理、长积分方程求解器等等。</p><h3 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h3><p>Python词云展示库，在一段文本中提取关键词进行扁平化的展示，更能吸引目标客户的眼球。</p><h3 id="wxpy"><a href="#wxpy" class="headerlink" title="wxpy"></a>wxpy</h3><p>微信个人API</p><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><p>Python的re模块提供了诸多正则表达式模块，使Python拥有了全部的正则表达式功能，库1方便检查一个字符串是否与某种模式匹配。</p><h2 id="登录并查看相关信息"><a href="#登录并查看相关信息" class="headerlink" title="登录并查看相关信息"></a>登录并查看相关信息</h2><p>1、登录</p><p>bot = Bot() #扫描二维码自动登录</p><p>2、获取登录账号的所有好友</p><p>bot.friends()</p><p>3、获取当前登录账号所关注的公众号</p><p>bot.mps()</p><p>4、获取当前登录账号群聊列表</p><p>bot.groups()</p><p>5、搜索好友：</p><p>bot.friends().search(‘好友备注名’)[0]</p><p>6、搜索好友并发送消息</p><p>bot.friends().search(‘好友备注名’)[0].send(‘str’)</p><p>7、向文件传输助手发送信息</p><p>bot.fle_helper.send(‘str’)</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>1、每个键值(key:value)对用冒号分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s = &#123;&apos;name&apos;:&apos;udbs&apos;, &apos;age&apos;:20&#125;</span><br><span class="line">&gt;&gt;&gt;a[&apos;age&apos;]</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt;print(a[&apos;age&apos;])</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><p>字典名[‘key’]</p><h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>字典名[‘key’] = ‘value’</p><h3 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h3><p>1、删除单一元素</p><p>格式：del 字典名[‘key’]</p><p>2、清空所有元素</p><p>格式：字典名.clear()</p><p>3、删除字典</p><p>格式：del 字典名</p><h1 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h1><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>open函数，必须先用Python内置的open()函数打开文件，创建一个file对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file object = open(file_name[, access_mode][, buffering])</span><br></pre></td></tr></table></figure><h2 id="with-as语句"><a href="#with-as语句" class="headerlink" title="with as语句"></a>with as语句</h2><p>try-finally语句可以处理异常。但较麻烦。</p><p>python提供了with语句语法，来构建对资源创建与释放方法，但功能与try相似。with语句后面跟着open方法，如果有返回值，可以使用as语句赋值给变量，退出时自动调用close。</p><h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>re.findall()方法</p><p>搜索整个字符串，返回匹配正则表达式的所有内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern,string)</span><br></pre></td></tr></table></figure><p>re.compile()方法</p><p>将正则字符串编译成正则表达式对象，以便后期匹配中复用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(&apos;正则表达式&apos;)</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>.匹配除了换行符之外的所有字符。</li><li>d数字</li><li>w字母</li></ul><p>join()方法</p><p>用于将序列中的元素以指定的字符连接生成一个新的字符串</p><h1 id="6月26日"><a href="#6月26日" class="headerlink" title="6月26日"></a>6月26日</h1><h2 id="jieba库"><a href="#jieba库" class="headerlink" title="jieba库"></a>jieba库</h2><ol><li><p>精确模式：jieba.lcut(str)</p><p>试图将语句最精确切分，不存在冗余数据，适合文本分析。</p></li><li><p>全模式：jieba.lcut(str,cut_all=True)</p><p>将与句中所有可能是词的词语都切分出来，速度快，但存在冗余数据</p></li><li><p>搜索引擎模式：jieba.lcut_for_search(str)</p><p>在精确模式的基础上·，对长词再次进行切分。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &apos;手持两把锟斤拷&apos;</span><br><span class="line">&gt;&gt;&gt; jieba.lcut(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;]</span><br><span class="line">&gt;&gt;&gt; str = &apos;手持两把锟斤拷，口中直呼烫烫烫。&apos;</span><br><span class="line">&gt;&gt;&gt; jieba.lcut(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;, &apos;，&apos;, &apos;口中&apos;, &apos;直呼&apos;, &apos;烫烫&apos;, &apos;烫&apos;, &apos;。&apos;]</span><br><span class="line">&gt;&gt;&gt; jieba.lcut_for_search(str)</span><br><span class="line">[&apos;手持&apos;, &apos;两把&apos;, &apos;锟&apos;, &apos;斤&apos;, &apos;拷&apos;, &apos;，&apos;, &apos;口中&apos;, &apos;直呼&apos;, &apos;烫烫&apos;, &apos;烫&apos;, &apos;。&apos;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="筛选函数isin-函数"><a href="#筛选函数isin-函数" class="headerlink" title="筛选函数isin()函数"></a>筛选函数isin()函数</h2><h3 id="isin"><a href="#isin" class="headerlink" title="isin()"></a>isin()</h3><p>功能：判断该列元素是否在某一个列表中。是True，否False。</p><h2 id="groupby函数和agg函数"><a href="#groupby函数和agg函数" class="headerlink" title="groupby函数和agg函数"></a>groupby函数和agg函数</h2><p>agg基于列的聚合操作</p><p>groupby基于行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;6月24日&quot;&gt;&lt;a href=&quot;#6月24日&quot; class=&quot;headerlink&quot; title=&quot;6月24日&quot;&gt;&lt;/a&gt;6月24日&lt;/h1&gt;&lt;h2 id=&quot;项目需求分析&quot;&gt;&lt;a href=&quot;#项目需求分析&quot; class=&quot;headerlink&quot; title=&quot;项
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="大数据" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Python" scheme="http://qianyouyou.cn/tags/Python/"/>
    
      <category term="数据分析" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="大数据" scheme="http://qianyouyou.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb网上购物系统的设计与实现</title>
    <link href="http://qianyouyou.cn/2019/06/02/2019-06-02/"/>
    <id>http://qianyouyou.cn/2019/06/02/2019-06-02/</id>
    <published>2019-06-02T02:20:25.000Z</published>
    <updated>2019-06-09T14:23:55.780Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/qian-youyou/ShoppingNet" target="_blank" rel="noopener">GitHub源码</a></p><p>1 课题简介    </p><p>1.1 背景及研究现状</p><p>在互联网高速发展的时代背景下，网络正以一种前所未有的冲击力在影响着人类的活动，包括人类的生产和日常生活。网络的诞生和发展，颠覆了传统的信息传播方式，冲破了存在于传统交流方式中时间和空间的种种壁垒，极大地改变了人类从物质到精神、从形式到内容、从生产到生活的各种活动，并且给人类带来了新的机遇和挑战。网络购物作为电子商务的一种形式正以其高效、低成本的优势，逐步成为新兴的经营模式和理念，人们已经不再满足用途信息的浏览和发布，而是渴望着能够充分享受网络所带来的更加多的便利。网络购物正适应了当今社会快节奏地生活，使顾客足不出户便可以方便快捷轻松地选购自己喜欢的商品。</p><p>本次网上购物系统基于课程设计以专业综合设计I的设计成果，对其进行Web服务器端功能的扩展与开发，将其设计成一个具有服务器端交互功能的完整的Web应用系统，并完成系统的测试、服务器端的部署与发布。</p><p>1.2 设计内容与设计思路    </p><p>网上购物系统主要是对后台管理和前台操作。后台管理是管理员对本网站的维护，通过商品资料(商品添加、商品修改)，等功能达到对网站的管理。前台操作是用户登录到本网站，可以进行用户注册，通过网站的热门商品推荐或商品分类查找功能实现商品搜索，找到自己想要买的商品，装入购物车，提交定单进行购买。</p><p>网上购物平台的特点是客户和电子商品信息量很大，管理员需要整理的信息很多，为让管理员轻松、方便、快捷的管理，该平台采用符合购买电子商品基本的原则，满足广大客户的日益增长的数量，并达到操作过程中的直观、方便、实用、安全等要求。</p><p>1.3 设计目的及意义</p><p>网上购物系统，是在网络上建立一个虚拟的购物商场，使消费者的购物过程变得轻松、快捷、方便，很适合现代人快节奏的生活；同时又有效的控制“商场”运营的成本，开辟了一个新的销售渠道。 </p><p>网上购物相较于实体店铺有着其独特的优势，首先相较于实体店铺网上店铺所需要的成本很小很多，网上购物不需要考虑门店等等的费用其次网上购物系统不存在店铺打样的问题延长了经营的时间无需专人看店节约成本的同时还能使得效益更大化。</p><p>本系统利用现代化的电子及网络技术，为消费者和企业搭建一个良好的互动平台。让用户享受快捷的购物方式，为企业提供不同于传统销售的崭新的销售模式。 该购物系统是一个中小型的电子商务系统，可以为各类用户提供方便的在线购物环境。用户可以在系统中实现注册、登录、修改个人信息、分类查询商品信息、购物、管理购物车、支付等功能。管理员可以通过后台管理模块实现商品的增删改查、种类的增删改查等，从而实现对于该购物系统的管理。</p><p>2 系统分析与设计</p><p>2.1 可行性分析    </p><p>可行性研究是为了弄清楚系统开发的项目是不是可以实现和值得进行研究的过程，实际上是一次大大简化系统分析和系统设计的过程，所以，进行可执行性的分析是非常必要的，也是很重要的，可行性研究阶段通过对系统目标进行市场调研和技术分析，提出了初步的可行性方案并进行了论证。这里主要从技术可行性、经济可行性以及操作可行性三方面进行分析。</p><p>2.1.1 经济可行性</p><p>该系统硬件只需要一台PC机，而且配置要求不高。软件方面用到的MySQL是免费开源的，Eclipse也是免费使用的，所以开发成本并不高。而该系统若投入运行之后不仅减少了人力、物力而且可以推动电影行业的发展，所带来的收益是巨大的，因此在经济上也是可行的。</p><p>2.1.2 技术可行性</p><p>技术可行性要考虑到现有的技术手段和能力能不能完成系统的开发，以免开发到一半出现现有技术无法解决的问题。本系统主要采用的是JAVAWeb和JSP技术。JAVA语言和JSP都是很成熟的技术，也是世界范围内应用最广泛的技术，所以用它们作为后台和前台的语言是没有任何问题的。而且集成开发工具Eclipse可以解决很多方面的问题，创造了良好的开发环境。由于JSP功能强大，而MySQL灵活易维护在开发方面具有方便快捷、使用灵活的特点，以及目前的广泛实际应用，因此使用JAVAWed、MySQL是开发轻平台的最佳组合从而说明本系统在技术方面可行。</p><p>硬件方面，科技飞速发展的今天，硬件更新的速度越来越快，容量越来越大，可靠性越来越高，价格越来越低，其硬件平台完全能满足此系统的需要。</p><p>2.2 需求分析</p><p>2.2.1 系统设计目标</p><p>此网络购物平台系统旨在为用户提供一个简易的具备一些基本功能的购物系统，通过这个系统用户可以轻松的获得自己想要的商品。存在两种类型用户，普通用户和管理员用户。普通用户在这个系统中注册过后进行登陆此时可以在平台中进行自由的选购自己想要的商品，将选购好的商品加入购物车，如果需要修改可以在购物车中更改所需的商品数量，当选择完成过后可以确认购买，也可以让所选物品一直处在购物车中，等待下次登陆时依然有效。管理员用户可以对商品进行管理，包括商品上架，商品下架，商品查询，商品修改等。</p><p>2.2.2 系统功能需求分析</p><p>（1）用户管理：注册会员、登录、管理员用户校验、激活、退出；</p><p>（2）商品显示：按分类查询商品、通过首页推荐查询商品、展示热门商品、展示最新商品、提交商品到购物车中等；</p><p>（3）购物车管理：向购物车中添加商品、修改购物车中商品数量、删除购物车中商品、我的购物车；</p><p>（4）订单管理：通过购物车中商品生成订单、查看我的订单、查看某个订单的详细、订单支付、确认收货。</p><p>（5）管理员：订单查询、商品和类别的增删改查。</p><p>2.2.3 系统性能需求分析</p><p>用户注册部分需要实时检验用户信息是否合格，否则用户提交后才检验，若不合格需重新填写，用户很快会厌倦，因此Ajax是不错的选择。</p><p>商品部份应该给用户提供推荐，比如最新商品和最热商品，给用户提供访问便利。</p><p>此外，分类部分不常改，且使用频繁，但每次若从数据库中读取会影响效率，因此使用redis缓存数据是个不错的选择，因为大大加快了访问效率。</p><p>订单部分由于支付功能需要第三方平台，所以可不必实现。</p><p>管理员部分需要对订单具有全权访问权限。</p><p>2.3 系统总体设计</p><p>2.3.1 系统总体结构设计</p><p>本项目采取MVC设计模式，分为model，view，controler三层。本项目包含dao，domain，service，web，utils五打包。</p><p>其中web包中包含各种servlet类和前端jsp进行交互，及view层。</p><p>Service为业务逻辑层，控制信息的权限以及信息在数据库与前端的交互，及controler层。Dao中主要负责与数据库进行交互，通过各种sql获取或添加信息到数据库，及model层。</p><p>Domain为基本类，共三大层创建对象进行层与层间的信息交互，作为信息载体的集合而存在。</p><p>Utils包中包含各种工具，例如数据库中的date类型需要string进行转换，或者id的生成，这些工具均包含于utils包中。基本模式如下图：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps1.jpg" alt="img"> </p><p>图2-1 系统总体结构设计图</p><p>B/S系统架构，简单点就是用户通过访问浏览器输入域名后，转入对应的前端html或jsp，然后通过http或https协议将信息报文传送给服务端，服务端进行相应之后做出一系列对数据或页面的响应。以下是B/S系统架构图。</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps2.jpg" alt="img"> </p><p>图2-2 B/S系统框架图</p><p>2.3.2 系统功能模块设计</p><p>（1）用户注册功能：发送邮件、激活用户、表单的校验、用户的登录功能、自动登录、用户的注销功能</p><p>（2）商品模块：首页热门商品和最新商品功能、商品分类、商品的列表（分页）、商品详细信息、浏览记录功能</p><p>（3）购物车模块：将商品加入购物车、展示购物车功能</p><p>（4）订单模块（多表和事务）：提交订单、展示订单、在线支付</p><p>（5）后台的分类的模块：分类信息的增删改查</p><p>（6）后台的商品模块：商品的信息的增删改查（文件上传）</p><p>（7）后台的订单的模块：所有的订单的信息展示</p><p>2.3.3 主要业务流程</p><p>用户的注册过程：</p><p>是首先进入主界面，点击注册按钮，跳转到注册页面，填写注册信息，ajax判断信息是否合格，然后跳转到注册servlet层，把信息传递给service层，service层通过dao层获取数据库信息，反馈是否成功给servlet层，最终按是否插入成功而跳转到注册成功或失败界面。之后介绍的流程大致如此，及MVC三层模型的传输过程。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps3.jpg" alt="img"></td></tr></tbody></table><p>图</p><p>2-3 程序包结构图</p><p>主界面显示：</p><p>首先index.jsp加载head.jsp，然后获取最热商品信息与最新商品信息，并显示在主界面，最后加载footer.jsp。</p><p>Head.jsp界面显示：</p><p>首先加载首页，然后访问redis数据库判断是否有种类信息，有则读取，无则访问MySQL数据库，读取数据后放到redis中。</p><p>用户注册分析：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps4.jpg" alt="img"> </p><p>图2-4 用户注册详情</p><p>商品设计：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps5.jpg" alt="img"> </p><p>图2-5 商品详情</p><p>通过浏览器访问商城，就相当于超市访问商品，因此我们需要购物车来装载商品以便对所需物品增删改查。<img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps6.jpg" alt="img"></p><p>图2-6 购物车设计</p><p>订单业务设计：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps7.jpg" alt="img"> </p><p>图2-7 订单业务设计</p><p>管理员管理流程：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps8.jpg" alt="img"> </p><p>图2-8 管理员管理</p><p>2.4 系统数据库设计</p><p>2.4.1 数据库概念模型设计</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps9.jpg" alt="img"> </p><p>图2-9  E-R图</p><p>2.4.2数据库逻辑结构设计</p><p>表2-1 category表结构</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>Cid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>Cname</td><td>varChar</td><td>20</td><td>默认为空</td></tr></tbody></table><p>表2-2 orderitem表结构</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>itemid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>count</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>subtotal</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>pid</td><td>varchar</td><td>50</td><td>可为空</td></tr><tr><td>oid</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>表2-3 order表</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>oid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>ordertime</td><td>datetime</td><td>0</td><td>可为空</td></tr><tr><td>total</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>state</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>address</td><td>varchar</td><td>30</td><td>可为空</td></tr><tr><td>name</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>telephone</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>uid</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>表2-4 product表</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>pid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>pname</td><td>Varchar</td><td>20</td><td>可为空</td></tr><tr><td>Market_price</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>Shop_price</td><td>double</td><td>0</td><td>可为空</td></tr><tr><td>pimage</td><td>varchar</td><td>30</td><td>可为空</td></tr><tr><td>pdate</td><td>date</td><td>20</td><td>可为空</td></tr><tr><td>Is_hot</td><td>int</td><td>20</td><td>可为空</td></tr><tr><td>pdesc</td><td>varchar</td><td>255</td><td>可为空</td></tr><tr><td>pflag</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>cid</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>表2-5 user表</p><table><thead><tr><th>Column Name</th><th>Date Type</th><th>Width</th><th>空值情况</th></tr></thead><tbody><tr><td>uid</td><td>varChar</td><td>50</td><td>主关键字</td></tr><tr><td>username</td><td>Varchar</td><td>20</td><td>可为空</td></tr><tr><td>password</td><td>Varchar</td><td>20</td><td>可为空</td></tr><tr><td>name</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>email</td><td>varchar</td><td>30</td><td>可为空</td></tr><tr><td>telephone</td><td>varchar</td><td>20</td><td>可为空</td></tr><tr><td>birthday</td><td>date</td><td>0</td><td>可为空</td></tr><tr><td>sex</td><td>varchar</td><td>10</td><td>可为空</td></tr><tr><td>state</td><td>int</td><td>11</td><td>可为空</td></tr><tr><td>code</td><td>varchar</td><td>50</td><td>可为空</td></tr></tbody></table><p>2.4.3 数据库关系设计</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps10.jpg" alt="img"> </p><p>图2-10 数据库关系图</p><p>3  系统详细设计</p><p>3.1 系统开发及运行环境</p><p>3.1.1 软件环境    </p><p>运行环境：Windows操作系统下eclipse</p><p>开发语言：JavaWeb</p><p>数据库：MySQL，redis</p><p>3.1.2 硬件环境    </p><p>阿里云服务器。</p><p>3.2 系统采用的关键技术</p><p>3.2.1页面显示逻辑与业务逻辑相分离</p><p><a href="https://baike.baidu.com/item/MVC" target="_blank" rel="noopener">MVC</a>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p><p>3.2.2数据库连接与访问    </p><p>C3P0是一个开源的JDBC<a href="https://baike.baidu.com/item/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1699713" target="_blank" rel="noopener">连接池</a>，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。</p><p>3.2.3 Ajax异步校验</p><p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p><p>3.3 系统框架的实现</p><p>本项目采取MVC设计模式，分为model，view，controler三层。本项目包含dao，domain，service，web，utils五大包。</p><p>其中web包中包含各种servlet类和前端jsp进行交互，及view层。</p><p>Service为业务逻辑层，控制信息的权限以及信息在数据库与前端的交互，及controler层。Dao中主要负责与数据库进行交互，通过各种sql获取或添加信息到数据库，及model层。</p><p>Domain为基本类，共三大层创建对象进行层与层间的信息交互，作为信息载体的集合而存在。</p><p>Utils包中包含各种工具，例如数据库中的date类型需要string进行转换，或者id的生成，这些工具均包含于utils包中。</p><p>3.3.1 主要的类与接口</p><p>表3-1 JSP清单</p><table><thead><tr><th>Jsp</th><th>说明</th></tr></thead><tbody><tr><td>admin/home.jsp</td><td>管理员界面</td></tr><tr><td>index.jsp</td><td>主界面</td></tr><tr><td>head.jsp</td><td>头界面</td></tr><tr><td>footer.jsp</td><td>尾界面</td></tr><tr><td>Product_list.jsp</td><td>商品栏界面</td></tr><tr><td>Product_info.jsp</td><td>单项商品信息界面</td></tr><tr><td>order_list.jsp</td><td>订单栏界面</td></tr><tr><td>order_info.jsp</td><td>订单项界面</td></tr><tr><td>cart.jsp</td><td>购物车界面</td></tr><tr><td>login.jsp</td><td>登陆界面</td></tr><tr><td>register.jsp</td><td>注册界面</td></tr></tbody></table><p>表3-2 MVC模式清单</p><table><thead><tr><th>Servlet</th><th>Service</th><th>Dao</th><th>Utils</th><th>Domain</th></tr></thead><tbody><tr><td>AutoLoginFilter</td><td>AdminService</td><td>AdminDao</td><td>BeanFactory</td><td>Cart</td></tr><tr><td>ActiveServlet</td><td>ProductService</td><td>ProductDao</td><td>CommonsUtils</td><td>CartItem</td></tr><tr><td>AdminServlet</td><td>UserService</td><td>UserDao</td><td>DataSourceUtils</td><td>Category</td></tr><tr><td>BaseServlet</td><td>AdminServiceImpl</td><td></td><td>JedisPoolUtils</td><td>Order</td></tr><tr><td>CallbackServlet</td><td></td><td></td><td>MailUtils</td><td>OrderItem</td></tr><tr><td>PrdocutServlet</td><td></td><td></td><td>MD5Utils</td><td>PageBean</td></tr><tr><td>RegisterServlet</td><td></td><td></td><td>PaymentUtil</td><td>Product</td></tr><tr><td>UserServlet</td><td></td><td></td><td></td><td>User</td></tr></tbody></table><p>3.3.2 系统主要配置文件</p><p>c3p0-config.xml负责数据库连接配置。</p><p>redis.properties负责redis端口属性配置。</p><p>Bean.xml配置AdminServiceImpl的清单。</p><p>Web.xml配置jsp清单。</p><p>3.4 具体功能模块的实现    </p><p>3.4.1前台分类信息展示</p><p>在head.jsp中有以下js代码：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps11.jpg" alt="img"> </p><p>图3-1 主页head栏</p><p>通过Ajax方式，首先访问CategoryServlet中的findCategory()方法，查询并以json格式返回Category的List集合db.cname即是最终导航栏显示的分类信息。</p><p>点击某一个分类后，会访问ProductServlet中的findPage()方法，传递当前页数：1和分类ID：cid。</p><p>3.4.2分类商品的分页展示</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps12.jpg" alt="img"> </p><p>图3-2 分类商品首页图</p><p>Dao层查询每页显示的数据（select * from product where cid = ? limit ?,?），Service层调用Dao后再进行条数页数的设置并封装进javabean，返回给servlet。</p><p>Servlet中的findPage()方法：</p><p>首先获取分类的ID：String cid = request.getParameter(“cid”);</p><p>然后获取当前页数：</p><p>int pageNumber =Integer.parseInt(request.getParameter(“pageNumber”));</p><p>之后设定每页显示的条数，带着参数调用service。将返回的PageBean对象和分类ID存储，供jsp页面使用。</p><p>Service层的findPage()方法：</p><p>List<product> list = pd.findPage(cid,pageNumber,pageSize);</product></p><p>封装的每页显示数据，按总条数和总页数进行封装。然后pageBean按每页显示的数据封装数据。</p><p>Servlet将pagebean存到request域中后，在jsp页面通过jstl遍历展示商品信息：</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps13.jpg" alt="img"> </p><p>图3-3 产品分类显示</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps14.jpg" alt="img"> </p><p>图3-4 产品分类jsp代码</p><p>3.4.3单个商品详情</p><p>在商品列表页面有：</p><p>&lt;ahref=”${pageContext.request.contextPath}/product?method=productList&amp;cid=${cid }¤tPage=${currentPage}”&gt;</p><p>这是定义在每个商品图片上的超链接，点击后访问ProductServlet中的findBypid()方法，查询单个商品的详情。</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps15.jpg" alt="img"> </p><p>图3-5 产品单件商品信息页面</p><p>3.4.4最新和热门商品展示</p><p>首先，每个商品有一个是否热门属性和一个上架时间属性。加载主页面时，会从数据库中读取is_hot为1的所有商品作为热门商品，并加载时间最近的商品作为最新商品。href为${pageContext.request.contextPath}/product?method=productInfo&amp;pid=${hotPro.pid}。项目运行后直接访问ProductServlet中的findByNew()方法，查询最新最热商品信息，然后跳转到/jsp/index.jsp页面进行展示。</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps16.jpg" alt="img"> </p><p>图3-6 热门商品展示</p><p><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml5384\wps17.jpg" alt="img"> </p><p>图3-7 最新商品展示</p><p>4 系统测试 </p><p>4.1 系统测试方法</p><p>测试方法采用了边界值，场景分析，等价类，用jmeter进行接测和压测。</p><p>4.2 系统测试用例</p><p>表4-1 系统测试</p><table><thead><tr><th>测试功能</th><th>测试用例序号</th><th>测试样例</th></tr></thead><tbody><tr><td>按类别查询商品首页</td><td>1</td><td>直接查询</td></tr><tr><td>分页展示分类商品</td><td>2</td><td>按种类添加删除商品信息</td></tr><tr><td>单个商品信息校验</td><td>3</td><td>修改部分商品信息</td></tr><tr><td>最热与最新商品展示</td><td>4</td><td>修改最热属性以及日期</td></tr></tbody></table><p>4.3 系统测试结果</p><p>表4-2 测试结果</p><table><thead><tr><th>测试用例序号</th><th>测试结果</th></tr></thead><tbody><tr><td>1</td><td>成功</td></tr><tr><td>2</td><td>成功</td></tr><tr><td>3</td><td>成功</td></tr><tr><td>4</td><td>成功</td></tr></tbody></table><p>5 总结</p><p>5.1 系统工作总结</p><p>​    我们这次首先应用到了MVC框架一开始使用的时候还有点生疏，但是在熟悉了以后，MVC框架的优点现了出来，它把前后台分开进行处理，我们在写后台逻辑的时候不需要考虑前端网页的布局，在写前端网页的时候也不需要在页面中插入后端的业务逻辑，这样让整个开发的过程变得十分明确，包括在查看源码的时候也不会眼花缭乱，当代码发生错误时，调试起来也能够快速的发现错误点，这是相较于之前没有框架使用的时候所没有的优越之处。同时，我们这次还用了C3P0的数据库池连接，它的优势之处就是比原本单纯的JDBC连接更加快捷，速度更快了。</p><p>5.2 存在的不足及改进</p><p>本系统由于涉及到支付功能，而支付又涉及到现金交易，因此该部分一直没有实现，经查阅资料了解到第三方支付平台的存在，但目前由于第三方支付平台账号问题目前支付功能具体还没有实现。之后会陆续对该部分进行改进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/qian-youyou/ShoppingNet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1 课题简介    &lt;/p&gt;
&lt;p&gt;1.1 背景及研究现状&lt;/p&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Java" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Java/"/>
    
    
      <category term="Java" scheme="http://qianyouyou.cn/tags/Java/"/>
    
      <category term="MVC" scheme="http://qianyouyou.cn/tags/MVC/"/>
    
      <category term="JavaWeb" scheme="http://qianyouyou.cn/tags/JavaWeb/"/>
    
      <category term="JSP" scheme="http://qianyouyou.cn/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>[转]unity pro 2019最新破解版 v2019.1.2f1</title>
    <link href="http://qianyouyou.cn/2019/05/29/2019-05-29/"/>
    <id>http://qianyouyou.cn/2019/05/29/2019-05-29/</id>
    <published>2019-05-29T13:58:15.000Z</published>
    <updated>2019-06-09T14:24:44.535Z</updated>
    
    <content type="html"><![CDATA[<p>由于unity更新，之前v2019.1.0a8破解版本更新为v2019.1.2f1，花了很长时间终于找到了破解方法。如下。</p><p>unity pro 2019破解版，其除了原程序还附带了破解补丁和许可文件，能够免费帮助用户破解得到一个可无限制免费使用所有功能的unity pro 2019，随后在下文会附上破解安装教程。</p><p>unity2019破解版安装说明</p><p>1、下载并解压本站提供的包，其包换了unity pro 2019原程序、破解补丁、许可文件。</p><p>2、先打开文件夹”addons”双击”UnityHubSetup-1.6.2.exe”依提示进行安装Unity Hub。</p><p>3、这里默认路径为【C:\Program Files\Unity Hub】</p><p>4、耐心等待安装完成后先不要运行该软件。</p><p>5、然后双击”UnitySetup64-2019.1.2f1.exe”依提示进行安装开始安装Unity。</p><p>6、这里默认路径为【C:\Program Files\Unity】</p><p>7、这里有点慢，请耐心等待安装。</p><p>8、安装完成后同样先不要运行该软件。</p><p>9、然后将本站提供的文件夹”crack”——“Hub”中的”app.asar”拖至【C:\Program Files\Unity Hub\resources】中并选择复制和替换即可。</p><p>10、接着选择”crack”进入到”Unity”选择用户自己需要的版本。</p><p>11、例如小编这里选择2019.1.0f2，那么就将文件夹里面的”Unity.exe”拖至【C:\Program Files\Unity\Editor】中并选择复制和替换即可。</p><p>12、然后将”2019.1.0f2”文件夹中的”Unity_lic.ulf”许可文件复制到【C:\ProgramData\Unity】中，如果C:驱动器没有ProgramData文件夹，则启用隐藏文件显示。是C:\ProgramData文件夹中没有Unity文件夹，那么就创建一个。</p><p>13、运行”Unity Hub”点击”Locate a Version”</p><p>14、找到unit.exe文件的路径即【C:\Program Files\Unity\Editor】点击”select sditor”</p><p>15、接着需要创建一个用于验证的新项目，点击”new”</p><p>16、安装所需的支持模块和附加组件。</p><p>17、耐心等待即可，到这里就已经全部破解完成了，用户就可以免费无限制使用unity pro 2019破解版了。</p><p><a href="https://pan.baidu.com/s/1Em7dYE8H8Q_EaUhqQIiv-Q?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=#list/path=%2F" target="_blank" rel="noopener">下载地址</a></p><p><a href="http://www.ddooo.com/softdown/144746.htm#dltab" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于unity更新，之前v2019.1.0a8破解版本更新为v2019.1.2f1，花了很长时间终于找到了破解方法。如下。&lt;/p&gt;
&lt;p&gt;unity pro 2019破解版，其除了原程序还附带了破解补丁和许可文件，能够免费帮助用户破解得到一个可无限制免费使用所有功能的uni
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Unity" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/Unity/"/>
    
    
      <category term="Unity3D" scheme="http://qianyouyou.cn/tags/Unity3D/"/>
    
      <category term="Unity" scheme="http://qianyouyou.cn/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb课程设计之网上商城</title>
    <link href="http://qianyouyou.cn/2019/05/25/2019-05-25/"/>
    <id>http://qianyouyou.cn/2019/05/25/2019-05-25/</id>
    <published>2019-05-25T04:19:27.000Z</published>
    <updated>2019-05-25T04:22:17.971Z</updated>
    
    <content type="html"><![CDATA[<p>最近一堆课设，总结随便写写吧。</p><h1 id="一、功能的演示"><a href="#一、功能的演示" class="headerlink" title="一、功能的演示"></a>一、功能的演示</h1><h3 id="1．用户模块"><a href="#1．用户模块" class="headerlink" title="1．用户模块"></a>1．用户模块</h3><p>用户注册功能</p><p>发送邮件</p><p>激活用户</p><p>表单的校验</p><p>用户的登录功能</p><p>自动登录</p><p>用户的注销功能</p><h3 id="2．商品模块"><a href="#2．商品模块" class="headerlink" title="2．商品模块"></a>2．商品模块</h3><p>首页热门商品和最新商品功能</p><p>商品分类</p><p>商品的列表（分页）</p><p>商品详细信息</p><p>浏览记录功能</p><h3 id="3．购物车模块"><a href="#3．购物车模块" class="headerlink" title="3．购物车模块"></a>3．购物车模块</h3><p>将商品加入购物车</p><p>展示购物车功能</p><h3 id="4．订单模块（多表和事务）"><a href="#4．订单模块（多表和事务）" class="headerlink" title="4．订单模块（多表和事务）"></a>4．订单模块（多表和事务）</h3><p>提交订单</p><p>展示订单</p><p>在线支付</p><h3 id="5．后台的分类的模块"><a href="#5．后台的分类的模块" class="headerlink" title="5．后台的分类的模块"></a>5．后台的分类的模块</h3><p>分类信息的增删改查</p><h3 id="6．后台的商品模块"><a href="#6．后台的商品模块" class="headerlink" title="6．后台的商品模块"></a>6．后台的商品模块</h3><p>商品的信息的增删改查（文件上传）</p><h3 id="7．后台的订单的模块"><a href="#7．后台的订单的模块" class="headerlink" title="7．后台的订单的模块"></a>7．后台的订单的模块</h3><p>所有的订单的信息展示</p><h1 id="二、一般项目开发流程（公司之间是有差异）"><a href="#二、一般项目开发流程（公司之间是有差异）" class="headerlink" title="二、一般项目开发流程（公司之间是有差异）"></a>二、一般项目开发流程（公司之间是有差异）</h1><p>1）确定项目需求—–拿下一个项目</p><p>2）编写《需求说明书》—-不涉及技术，只涉及业务需求</p><p>3）编写《概要设计说明书》—– 涉及技术的的宏观的内容，数据库设计，页面原型</p><p>4）编写《详细设计说明书》—– 相当于伪代码</p><p>5）编码阶段coding—-根据《详细设计说明书》— 单元测试</p><p>6）联测—–项目组内部的行为</p><p>7）测试组进行全面的专业测试—-《测试报告》</p><p>8）上线（测试阶段）</p><p>9）维护和二次开发</p><h1 id="三、网上商城项目的环境的搭建"><a href="#三、网上商城项目的环境的搭建" class="headerlink" title="三、网上商城项目的环境的搭建"></a>三、网上商城项目的环境的搭建</h1><p>(1) 创建项目Shop</p><p>(2) 创建项目的包结构</p><p>(3) 导入需要的jar/配置文件/工具/静态页面</p><p>(4) 编码</p><h1 id="四、业务分析与编码"><a href="#四、业务分析与编码" class="headerlink" title="四、业务分析与编码"></a>四、业务分析与编码</h1><h3 id="1．用户模块—注册"><a href="#1．用户模块—注册" class="headerlink" title="1．用户模块—注册"></a>1．用户模块—注册</h3><h4 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="(1)用户注册"></a>(1)用户注册</h4><p>基本点注册代码实现</p><p>分析：表单提交数据—-&gt;web层收集数据—-&gt;封装数据—–&gt;传递数据—&gt;三层架    构代码</p><h4 id="2-用户发送邮件"><a href="#2-用户发送邮件" class="headerlink" title="(2)用户发送邮件"></a>(2)用户发送邮件</h4><h4 id="3-用户激活"><a href="#3-用户激活" class="headerlink" title="(3)用户激活"></a>(3)用户激活</h4><p>邮箱中的链接</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td><img src="file:///C:\Users\DELL\AppData\Local\Temp\ksohtml12844\wps1.jpg" alt="img"></td></tr></tbody></table><p>点击时 访问服务端进行激活功能的ActiveServlet</p><h4 id="4-表单校验"><a href="#4-表单校验" class="headerlink" title="(4)表单校验"></a>(4)表单校验</h4><h4 id="5-短信验证码"><a href="#5-短信验证码" class="headerlink" title="(5)短信验证码"></a>(5)短信验证码</h4><h4 id="6-图片验证码"><a href="#6-图片验证码" class="headerlink" title="(6)图片验证码"></a>(6)图片验证码</h4><p>前台对表单已经进行进行校验了，后台好需要对数据进行校验吗？—-需要！</p><h3 id="2．用户模块—登录"><a href="#2．用户模块—登录" class="headerlink" title="2．用户模块—登录"></a>2．用户模块—登录</h3><h3 id="3．关于servlet的抽取（重构）"><a href="#3．关于servlet的抽取（重构）" class="headerlink" title="3．关于servlet的抽取（重构）"></a>3．关于servlet的抽取（重构）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一堆课设，总结随便写写吧。&lt;/p&gt;
&lt;h1 id=&quot;一、功能的演示&quot;&gt;&lt;a href=&quot;#一、功能的演示&quot; class=&quot;headerlink&quot; title=&quot;一、功能的演示&quot;&gt;&lt;/a&gt;一、功能的演示&lt;/h1&gt;&lt;h3 id=&quot;1．用户模块&quot;&gt;&lt;a href=&quot;#1．用户
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>戳气球问题</title>
    <link href="http://qianyouyou.cn/2019/05/20/2019-05-20/"/>
    <id>http://qianyouyou.cn/2019/05/20/2019-05-20/</id>
    <published>2019-05-20T07:02:20.000Z</published>
    <updated>2019-05-20T11:45:25.733Z</updated>
    
    <content type="html"><![CDATA[<p>有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</p><p>求所能获得硬币的最大数量。</p><p>说明:</p><p>你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>示例:</p><p>输入: [3,1,5,8]<br>输出: 167<br>解释: nums = [3,1,5,8] –&gt; [3,5,8] –&gt;   [3,8]   –&gt;  [8]  –&gt; []<br>     coins =  315      +  358    +  138      + 181   = 167</p><p>思路：</p><p>可以利用区间动态规划，dp[i][j]表示i到j之间的最优解（不包括i，j），那么dp[i][j]就等于max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k])。</p><p>即我们假设求i到j之间的最优解，k为i和j之间的数，那么当前i到j之间以k为基准将要戳k（也就是k是i到j中最后一个戳的）的最优解就等于k左半部分最优解加k右半部分最优解加k、j、i的乘积，遍历k求出最大的一个就好了。当然dp初始值要为0，这样第一次戳i时dp[i-1][i+1]就理所当然等于0 + nums[i+1] <em> nums[i] </em> nums[i - 1] + 0。</p><p>nums首部先插入1，再在末尾补1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.empty())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.insert(nums.begin(), 1);</span><br><span class="line">        nums.push_back(1);</span><br><span class="line">        dp.resize(nums.size(), vector&lt;int&gt;(nums.size(), 0));</span><br><span class="line">        for(int i = 2; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            for(int j = 0; j + i &lt; nums.size(); ++j)&#123;</span><br><span class="line">                for(int k = j + 1; k &lt; j + i; ++k)&#123;</span><br><span class="line">                    dp[j][j + i] = max(dp[j][j + i], dp[j][k] + dp[k][j + i] + nums[k] * nums[j] * nums[j + i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][nums.size() - 1];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。&lt;/p&gt;
&lt;p&gt;现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="区间dp" scheme="http://qianyouyou.cn/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>日常笔记</title>
    <link href="http://qianyouyou.cn/2019/05/18/2019-05-18/"/>
    <id>http://qianyouyou.cn/2019/05/18/2019-05-18/</id>
    <published>2019-05-18T12:47:33.000Z</published>
    <updated>2019-05-20T12:12:44.847Z</updated>
    
    <content type="html"><![CDATA[<p>由于写一篇博客很很费劲，经常学习一天的内容写博客就得花费一天，费时费力。所以本篇博客主要记录一些日常琐碎的笔记。</p><h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><h2 id="面向过程C语言"><a href="#面向过程C语言" class="headerlink" title="面向过程C语言"></a>面向过程C语言</h2><h2 id="面向对象C"><a href="#面向对象C" class="headerlink" title="面向对象C++"></a>面向对象C++</h2><h3 id="C与C-的区别"><a href="#C与C-的区别" class="headerlink" title="C与C++的区别"></a>C与C++的区别</h3><p>C为面向过程语言，C++与C不是对立关系，而是包容关系。C++不仅包含面向过程的C，还可以面向对象，也可以泛型编程。简而言之，C++分为面向过程，面向对象，泛型编程模板，STL标准模板库四部分。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="::运算符"></a>::运算符</h3><p>作用域运算符，全局作用域直接加::</p><h3 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h3><p><strong>用途</strong> 解决名称冲突问题</p><ul><li>必须在全局作用域下声明</li><li>命名空间下可以放入 函数、变量、结构体、类等。</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时加入新的成员，添加并合并</li><li>匿名命名空间 static</li><li>可以起别名</li></ul><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><h4 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h4><p>using std :: X，使用某变量或对象。如果该部分作用域已经存在同样的名称对象，则会产生二义性而报错。</p><h4 id="using编译命令"><a href="#using编译命令" class="headerlink" title="using编译命令"></a>using编译命令</h4><p>using namespace X，使用命名空间。跟编译器说的。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const int a = 10；不分配内存，只在编译器符号表中。</p><p>const int a = b；分配内存</p><p>C++默认const内链接，C外链接即默认extern。</p><h3 id="const与define"><a href="#const与define" class="headerlink" title="const与define"></a>const与define</h3><p>const有作用域，有类型。define无作用域，无类型</p><h2 id="泛型编程模板与STL"><a href="#泛型编程模板与STL" class="headerlink" title="泛型编程模板与STL"></a>泛型编程模板与STL</h2><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h2 id="系统编程"><a href="#系统编程" class="headerlink" title="系统编程"></a>系统编程</h2><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="web编程"><a href="#web编程" class="headerlink" title="web编程"></a>web编程</h2><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h2 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h2><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于写一篇博客很很费劲，经常学习一天的内容写博客就得花费一天，费时费力。所以本篇博客主要记录一些日常琐碎的笔记。&lt;/p&gt;
&lt;h1 id=&quot;C-C&quot;&gt;&lt;a href=&quot;#C-C&quot; class=&quot;headerlink&quot; title=&quot;C/C++&quot;&gt;&lt;/a&gt;C/C++&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自底向上优先分析</title>
    <link href="http://qianyouyou.cn/2019/05/13/2019-05-13/"/>
    <id>http://qianyouyou.cn/2019/05/13/2019-05-13/</id>
    <published>2019-05-13T12:18:37.000Z</published>
    <updated>2019-05-13T14:16:02.695Z</updated>
    
    <content type="html"><![CDATA[<ul><li>优先分析法<ul><li>简单优先分析法<ul><li>按一定规则求出该文法所有符号即包括终结符和非终结符之间的优先关系。</li><li>实质是一种规范规约。</li><li>准确，规范，但效率低。</li><li>实用性不大。</li></ul></li><li>算符优先分析法<ul><li>只规定算符之间的优先关系，即仅终结符之间的优先关系。</li><li>不是规范规约。</li><li>不准确规范，但效率高。</li><li>采用适当方法加以弥补缺点。</li></ul></li></ul></li></ul><h1 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h1><h2 id="算符与普通-gt-lt-区别"><a href="#算符与普通-gt-lt-区别" class="headerlink" title="算符与普通=,&gt;,&lt;区别"></a>算符与普通=,&gt;,&lt;区别</h2><p>算符有顺序，例如a·=b和b·=a不一样。</p><p>普通算符无顺序，例如a&lt;b和b&gt;a一样。</p><h2 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h2><ul><li>X ·= Y(A→…XY…)<ul><li>S→bAa。b ·= A，A ·= a。</li></ul></li><li>X ·&lt; Y(A → …XB…, B ⇨ Y…)<ul><li>S→bAb，A +⇨ (B, A+⇨a。b ·&lt; (，b ·= a。</li></ul></li><li>X ·&gt; Y(A → …BD…,  B +⇨ …X，D *⇨ Y…)<ul><li>S→bAb，A +⇨ …), A+⇨B,A+⇨a。) ·&gt; b，a ·&gt; b， B ·&gt; b。</li></ul></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。</li><li>在文法中任意两个产生式没有相同的右部。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>将输入符号串a1a…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性·&gt;下一个带输入符号aj为止。</p><p>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;·ak，为止。</p><p>由句柄ak…ai在文法产生式中查找右部尾ak…ai的产生式，若找到则用左部代替句柄，若找不到则为出错，断定不合法。</p><p>重复1，2，3.直到只剩开始符为止。</p><h1 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h1><h2 id="优先关系-1"><a href="#优先关系-1" class="headerlink" title="优先关系"></a>优先关系</h2><p>和简单优先分析相比仅有终结符才能有优先级比较。其余优先符关系同于上式。</p><ul><li>a ·= b(A→…ab…或A→…aBb…)</li><li>a ·&lt; b(A → …aB…, B ⇨ b…或B ⇨ Cb…)</li><li>a ·&gt; b(A → …Bb…,  B ⇨ …a或B ⇨ …aC)</li></ul><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol><li>若一文法G中<strong>不存在</strong>A→…BC…，其中B,C为非终极符，则G为<strong>算符文法</strong>。</li><li>G为不含ε文法，满足算符优先关系。</li><li>若a与b之间只存在一种优先关系，则G为算符优先文法。</li></ol><h2 id="算符优先关系表构造"><a href="#算符优先关系表构造" class="headerlink" title="算符优先关系表构造"></a>算符优先关系表构造</h2><p>FIRSTVT(B) = {b | B +⇨ b…或B +⇨ Cb…}</p><p>LASTVT(B) = {a | B +⇨ …a 或B +⇨ …aC}</p><ol><li>·=：A→…ab…，若或A→…aBb…,则a·=b</li><li>·&lt;：A→…aB…，若b∈FIRSTVT(B)，则a·&lt;b</li><li>·&gt;：A→…Bb…，若a∈LASTVT(B)，则a·&gt;b</li></ol><h2 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/20190513_213009.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;优先分析法&lt;ul&gt;
&lt;li&gt;简单优先分析法&lt;ul&gt;
&lt;li&gt;按一定规则求出该文法所有符号即包括终结符和非终结符之间的优先关系。&lt;/li&gt;
&lt;li&gt;实质是一种规范规约。&lt;/li&gt;
&lt;li&gt;准确，规范，但效率低。&lt;/li&gt;
&lt;li&gt;实用性不大。&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>最少区间覆盖问题</title>
    <link href="http://qianyouyou.cn/2019/05/09/2019-05-09/"/>
    <id>http://qianyouyou.cn/2019/05/09/2019-05-09/</id>
    <published>2019-05-09T14:56:46.000Z</published>
    <updated>2019-05-11T13:01:54.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。</p><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>[2,3,1,1,1]</p><p>输出：</p><p>2</p><p>解释：</p><p>0-&gt;1-&gt;4</p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>贪心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0, cnt = 0, maxn = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.size() - 1 &amp;&amp; i &lt;= cnt; ++i)&#123;</span><br><span class="line">            if(nums[i] + i &gt; maxn)&#123;</span><br><span class="line">                maxn = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            if(maxn &gt;= nums.size() - 1)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i == cnt)&#123;</span><br><span class="line">                if(cnt != maxn)&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt = maxn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>数组记录，及数组记录当前最优值，类似于筛法求素数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int solve(vector&lt;int&gt;v)&#123;</span><br><span class="line">    int len = v.size();</span><br><span class="line">    vector&lt;int&gt;dp(len, inf);</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 0; i &lt; len &amp;&amp; dp[i] != inf; ++i)&#123;</span><br><span class="line">        for(int j = 1; j &lt;= v[i]; ++j)&#123;</span><br><span class="line">            dp[j] = min(dp[j], dp[i] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[len - 1] != inf ? dp[len - 1] : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h2><p>排序，下标为左界，值＋下标为右值，构成区域块，选最少的块覆盖全部区域，覆盖不了等于到不了终点。左值（右值）排序后右值（左值）贪心比较。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>刚拿到该题，以为是做过的题，之前做的是能否到达终点。结果忽略了求最少的步数，写完才发现理解错了。然后就慌了，思路就混乱了。就没有然后了。</p><p>还是比较适合笔试题，一个人自在，心里有了包袱就自乱阵脚，好水的题都能出错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有一个包，若干路由器，包在每个路由器处有一个最大跳的步长，问至少几跳能到达终点。每一个数为正整数。&lt;/p&gt;
&lt;h2 id=&quot;样例：&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="动态规划" scheme="http://qianyouyou.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[转]探索C++虚函数在g++中的实现</title>
    <link href="http://qianyouyou.cn/2019/05/07/2019-05-07/"/>
    <id>http://qianyouyou.cn/2019/05/07/2019-05-07/</id>
    <published>2019-05-07T15:23:56.000Z</published>
    <updated>2019-05-07T15:37:30.142Z</updated>
    
    <content type="html"><![CDATA[<p>为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：</p><p>C++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base1::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base2::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::f()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void g() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::g()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void h() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Derived::h()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Derived ins;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"></span><br><span class="line">    b1.f();</span><br><span class="line">    b2.g();</span><br><span class="line">    d.f();</span><br><span class="line">    d.g();</span><br><span class="line">    d.h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码采用了多继承，是为了更多的分析出g++的实现本质，用UML简单的画一下继承关系：</p><p>示例代码UML图</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-3.png" alt=""></p><p>代码的输出结果和预期的一致，C++实现了虚函数覆盖功能，代码输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::f()</span><br><span class="line">Derived::g()</span><br><span class="line">Derived::h()</span><br></pre></td></tr></table></figure><h2 id="开始分析！"><a href="#开始分析！" class="headerlink" title="开始分析！"></a>开始分析！</h2><p>我写这篇文章的重点是尝试解释g++编译在底层是如何实现虚函数覆盖和动态绑定的，因此我假定你已经明白基本的虚函数概念以及虚函数表（vtbl）和虚函数表指针（vptr）的概念和在继承实现中所承担的作用，如果你还不清楚这些概念，建议你在继续阅读下面的分析前先补习一下相关知识，陈皓的 <a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="noopener">《C++虚函数表解析》</a> 系列是一个不错的选择。</p><p>通过本文，我将尝试解答下面这三个问题：</p><ol><li>g++如何实现虚函数的动态绑定？</li><li>vtbl在何时被创建？vptr又是在何时被初始化？</li><li>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</li></ol><p>首先是第一个问题：</p><h3 id="g-如何实现虚函数的动态绑定？"><a href="#g-如何实现虚函数的动态绑定？" class="headerlink" title="g++如何实现虚函数的动态绑定？"></a>g++如何实现虚函数的动态绑定？</h3><p>这个问题乍看简单，大家都知道是通过vptr和vtbl实现的，那就让我们刨根问底的看一看，g++是如何利用vptr和vtbl实现的。</p><p>第一步，使用 -fdump-class-hierarchy 参数导出g++生成的类内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Vtable for Base1</span><br><span class="line">Base1::_ZTV5Base1: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base1)</span><br><span class="line">8     Base1::f</span><br><span class="line"></span><br><span class="line">Class Base1</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base1 (0xb6acb438) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base1::_ZTV5Base1) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Base2</span><br><span class="line">Base2::_ZTV5Base2: 3u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI5Base2)</span><br><span class="line">8     Base2::g</span><br><span class="line"></span><br><span class="line">Class Base2</span><br><span class="line">   size=4 align=4</span><br><span class="line">   base size=4 base align=4</span><br><span class="line">Base2 (0xb6acb474) 0 nearly-empty</span><br><span class="line">    vptr=((&amp; Base2::_ZTV5Base2) + 8u)</span><br><span class="line"></span><br><span class="line">Vtable for Derived</span><br><span class="line">Derived::_ZTV7Derived: 8u entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">4     (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">8     Derived::f</span><br><span class="line">12    Derived::g</span><br><span class="line">16    Derived::h</span><br><span class="line">20    (int (*)(...))-0x000000004</span><br><span class="line">24    (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">28    Derived::_ZThn4_N7Derived1gEv</span><br><span class="line"></span><br><span class="line">Class Derived</span><br><span class="line">   size=8 align=4</span><br><span class="line">   base size=8 base align=4</span><br><span class="line">Derived (0xb6b12780) 0</span><br><span class="line">    vptr=((&amp; Derived::_ZTV7Derived) + 8u)</span><br><span class="line">  Base1 (0xb6acb4b0) 0 nearly-empty</span><br><span class="line">      primary-for Derived (0xb6b12780)</span><br><span class="line">  Base2 (0xb6acb4ec) 4 nearly-empty</span><br><span class="line">      vptr=((&amp; Derived::_ZTV7Derived) + 28u)</span><br></pre></td></tr></table></figure><p>如果看不明白这些乱七八糟的输出，没关系（当然能看懂更好），把上面的输出转换成图的形式就清楚了：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-2.png" alt=""></p><p>vptr和vtbl</p><p>其中有几点尤其值得注意：</p><ol><li>我用来测试的机器是32位机，所有vptr占4个字节，每个vtbl中的函数指针也是4个字节</li><li>每个类的主要（primal）vptr放在类内存空间的起始位置（由于我没有声明任何成员变量，可能看不清楚）</li><li>在多继承中，对应各个基类的vptr按继承顺序依次放置在类内存空间中，且子类与第一个基类共用同一个vptr</li><li>子类中声明的虚函数除了覆盖各个基类对应函数的指针外，还额外添加一份到第一个基类的vptr中（体现了共用的意义）</li></ol><p>有了内存布局后，接下来观察g++是如何在这样的内存布局上进行动态绑定的。</p><p>g++对每个类的指针或引用对象，如果是其类声明中虚函数，使用位于其内存空间首地址上的vptr寻找找到vtbl进而得到函数地址。如果是父类声明而子类未覆盖的虚函数，使用对应父类的vptr进行寻址。</p><p>先来验证一下，使用 objdump -S 得到 b1.f() 的汇编指令：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b1.f();</span><br><span class="line"> 8048734:       8b 44 24 24             mov    0x24(%esp),%eax    # 得到Base1对象的地址</span><br><span class="line"> 8048738:       8b 00                   mov    (%eax),%eax        # 对对象首地址上的vptr进行解引用，得到vtbl地址</span><br><span class="line"> 804873a:       8b 10                   mov    (%eax),%edx        # 解引用vtbl上第一个虚函数的地址</span><br><span class="line"> 804873c:       8b 44 24 24             mov    0x24(%esp),%eax</span><br><span class="line"> 8048740:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048743:       ff d2                   call   *%edx              # 调用函数</span><br></pre></td></tr></table></figure><p>其过程和我们的分析完全一致，聪明的你可能发现了，b2怎么办呢？Derived类的实例内存首地址上的vptr并不是Base2类的啊！答案实际上是因为g++在引用赋值语句 Base2 &amp;b2 = ins 上动了手脚：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Derived ins;</span><br><span class="line"> 804870d:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048711:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 8048714:       e8 c3 01 00 00          call   80488dc &lt;_ZN7DerivedC1Ev&gt;</span><br><span class="line">    Base1 &amp;b1 = ins;</span><br><span class="line"> 8048719:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 804871d:       89 44 24 24             mov    %eax,0x24(%esp)</span><br><span class="line">    Base2 &amp;b2 = ins;</span><br><span class="line"> 8048721:       8d 44 24 1c             lea    0x1c(%esp),%eax   # 获得ins实例地址</span><br><span class="line"> 8048725:       83 c0 04                add    $0x4,%eax         # 添加一个指针的偏移量</span><br><span class="line"> 8048728:       89 44 24 28             mov    %eax,0x28(%esp)   # 初始化引用</span><br><span class="line">    Derived &amp;d = ins;</span><br><span class="line"> 804872c:       8d 44 24 1c             lea    0x1c(%esp),%eax</span><br><span class="line"> 8048730:       89 44 24 2c             mov    %eax,0x2c(%esp)</span><br></pre></td></tr></table></figure><p>虽然是指向同一个实例的引用，根据引用类型的不同，g++编译器会为不同的引用赋予不同的地址。例如b2就获得一个指针的偏移量，因此才保证了vptr的正确性。</p><p>PS：我们顺便也证明了C++中的引用的真实身份就是指针…</p><p>接下来进入第二个问题：</p><h3 id="vtbl在何时被创建？vptr又是在何时被初始化？"><a href="#vtbl在何时被创建？vptr又是在何时被初始化？" class="headerlink" title="vtbl在何时被创建？vptr又是在何时被初始化？"></a>vtbl在何时被创建？vptr又是在何时被初始化？</h3><p>既然我们已经知道了g++是如何通过vptr和vtbl来实现虚函数魔法的，那么vptr和vtbl又是在什么时候被创建的呢？</p><p>vptr是一个相对容易思考的问题，因为vptr明确的属于一个实例，所以vptr的赋值理应放在类的构造函数中。 g++为每个有虚函数的类在构造函数末尾中隐式的添加了为vptr赋值的操作 。</p><p>同样通过生成的汇编代码验证：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line"> 80488dc:       55                      push   %ebp</span><br><span class="line"> 80488dd:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80488df:       83 ec 18                sub    $0x18,%esp</span><br><span class="line"> 80488e2:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488e5:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488e8:       e8 d3 ff ff ff          call   80488c0 &lt;_ZN5Base1C1Ev&gt;</span><br><span class="line"> 80488ed:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488f0:       83 c0 04                add    $0x4,%eax</span><br><span class="line"> 80488f3:       89 04 24                mov    %eax,(%esp)</span><br><span class="line"> 80488f6:       e8 d3 ff ff ff          call   80488ce &lt;_ZN5Base2C1Ev&gt;</span><br><span class="line"> 80488fb:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 80488fe:       c7 00 48 8a 04 08       movl   $0x8048a48,(%eax)</span><br><span class="line"> 8048904:       8b 45 08                mov    0x8(%ebp),%eax</span><br><span class="line"> 8048907:       c7 40 04 5c 8a 04 08    movl   $0x8048a5c,0x4(%eax)</span><br><span class="line"> 804890e:       c9                      leave</span><br><span class="line"> 804890f:       c3                      ret</span><br></pre></td></tr></table></figure><p>可以看到在代码中，Derived类的构造函数为实例的两个vptr赋初值，可是，这两个初值居然是立即数！立即数！立即数！ 这说明了vtbl的生成并不是运行时的，而是在编译期就已经确定了存放在这两个地址上的 ！</p><p>这个地址不出意料的属于.rodata（只读数据段），使用 objdump -s -j .rodata 提取出对应的内存观察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">80489e0 03000000 01000200 00000000 42617365  ............Base</span><br><span class="line"> 80489f0 313a3a66 28290042 61736532 3a3a6728  1::f().Base2::g(</span><br><span class="line"> 8048a00 29004465 72697665 643a3a66 28290044  ).Derived::f().D</span><br><span class="line"> 8048a10 65726976 65643a3a 67282900 44657269  erived::g().Deri</span><br><span class="line"> 8048a20 7665643a 3a682829 00000000 00000000  ved::h()........</span><br><span class="line"> 8048a30 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048a40 00000000 a08a0408 34880408 68880408  ........4...h...</span><br><span class="line"> 8048a50 94880408 fcffffff a08a0408 60880408  ............`...</span><br><span class="line"> 8048a60 00000000 c88a0408 08880408 00000000  ................</span><br><span class="line"> 8048a70 00000000 d88a0408 dc870408 37446572  ............7Der</span><br><span class="line"> 8048a80 69766564 00000000 00000000 00000000  ived............</span><br><span class="line"> 8048a90 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 8048aa0 889f0408 7c8a0408 00000000 02000000  ....|...........</span><br><span class="line"> 8048ab0 d88a0408 02000000 c88a0408 02040000  ................</span><br><span class="line"> 8048ac0 35426173 65320000 a89e0408 c08a0408  5Base2..........</span><br><span class="line"> 8048ad0 35426173 65310000 a89e0408 d08a0408  5Base1..........</span><br></pre></td></tr></table></figure><p>由于程序运行的机器是小端机，经过简单的转换就可以得到第一个vptr所指向的内存中的第一条数据为0x80488834，如果把这个数据解释为函数地址到汇编文件中查找，会得到：</p><p>Assembly (x86)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">08048834 &lt;_ZN7Derived1fEv&gt;:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base1, public Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void f() &#123;</span><br><span class="line"> 8048834:       55                      push   %ebp</span><br><span class="line"> 8048835:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048837:       83 ec 18                sub    $0x18,%esp</span><br></pre></td></tr></table></figure><p>Bingo！ g++在编译期就为每个类确定了vtbl的内容，并且在构造函数中添加相应代码使vptr能够指向已经填好的vtbl的地址 。</p><p>这也同时为我们解答了第三个问题：</p><p>在Linux中运行的C++程序虚拟存储器中，vptr、vtbl存放在虚拟存储的什么位置？</p><p>直接看图：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-07-1.png" alt=""></p><p>虚函数在虚拟存储器中的位置</p><p>图中灰色部分应该是你已经熟悉的，彩色部分内容和相关联的箭头描述了虚函数调用的过程（图中展示的是通过new在堆区创建实例的情况，与示例代码有所区别，小失误，不要在意）： 当调用虚函数时，首先通过位于栈区的实例的指针找到位于堆区中的实例地址，然后通过实例内存开头处的vptr找到位于.rodata段的vtbl，再根据偏移量找到想要调用的函数地址，最后跳转到代码段中的函数地址执行目标函数 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>研究这些问题的起因是因为公司代码出现了非常奇葩的行为，经过追查定位到虚函数表出了问题，因此才有机会脚踏实地的对虚函数实现进行一番探索。</p><p>也许你会想，即使我不明白这些底层原理，也一样可以正常的使用虚函数，也一样可以写出很好的面相对象的代码啊？</p><p>这一点儿也没有错，但是，C++作为全宇宙最复杂的程序设计语言，它提供的功能异常强大，无异于武侠小说中锋利无比的屠龙宝刀。但武功不好的菜鸟如果胡乱舞弄宝刀，却很容易反被其所伤。只有了解了C++底层的原理和机制，才能让我们把C++这把屠龙宝刀使用的更加得心应手，变化出更加华丽的招式，成为真正的武林高手。</p><h1 id="转"><a href="#转" class="headerlink" title="转"></a>转</h1><p>本文转自<a href="http://blog.kongfy.com/2015/08/%E6%8E%A2%E7%B4%A2c%E8%99%9A%E5%87%BD%E6%95%B0%E5%9C%A8g%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.kongfy.com/2015/08/探索c虚函数在g中的实现/</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了探索C++虚函数的实现，我们首先编写几个用来测试的类，代码如下：&lt;/p&gt;
&lt;p&gt;C++&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="多态" scheme="http://qianyouyou.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数表" scheme="http://qianyouyou.cn/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>自顶向下语法分析指北</title>
    <link href="http://qianyouyou.cn/2019/05/05/2019-05-05/"/>
    <id>http://qianyouyou.cn/2019/05/05/2019-05-05/</id>
    <published>2019-05-05T03:43:44.000Z</published>
    <updated>2019-05-05T12:14:24.265Z</updated>
    
    <content type="html"><![CDATA[<ul><li>语法分析<ul><li>自顶向下语法分析<ul><li>确定分析</li><li>不确定分析</li></ul></li><li>自底向上语法分析<ul><li>算符优先分析</li><li>LR分析</li></ul></li></ul></li></ul><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="确定分析-LL-1-文法"><a href="#确定分析-LL-1-文法" class="headerlink" title="确定分析(LL(1)文法)"></a>确定分析(LL(1)文法)</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>G[S]:</p><p>S -&gt; pA | qB</p><p>A -&gt; cAd | a</p><p>B -&gt; dB | b</p><p>W = pccadd。</p><p>推导过程如下：S =&gt; pA =&gt; pcAd =&gt; pccAdd =&gt; pccadd。</p><ul><li>​          S                      S                          S                          S<br> ​        /    \                    /    \                        /    \                        /    \<br> ​       p      A    =&gt;          p      A        =&gt;          p      A        =&gt;          p      A<pre><code>/   |   \                       /   |   \                      /   |   \</code></pre>  ​                        c     A     d                c     A     d                c     A     d<pre><code>/   |   \                      /   |   \</code></pre>  ​                                            c     A     d                c     A     d<br>  ​                                                                       |<pre><code>a</code></pre></li></ul><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>G[S]：</p><p>S-&gt;Ap</p><p>S-&gt;Bq</p><p>A-&gt;a</p><p>A-&gt;cA</p><p>B-&gt;b</p><p>B-&gt;dB</p><p>W = ccap，推导过程：</p><p>S =&gt; aP =&gt; cAp =&gt; ccAp =&gt; ccap。</p><h3 id="FIRST-a"><a href="#FIRST-a" class="headerlink" title="FIRST(a)"></a>FIRST(a)</h3><p>a的开始符号集或首符号集。</p><p>例2：FIRST(Ap) = {a, c}。</p><p>FIRST(Bq) = {b, d}。</p><p>FIRST(S) = {a, b, c, d}。</p><p>###FOLLOW(A)</p><p>若Aa，a ∈ FOLLOW(A)。若a = ε，则# ∈ FOLLOW(A)。</p><h3 id="SELECT-A-gt-a"><a href="#SELECT-A-gt-a" class="headerlink" title="SELECT(A-&gt;a)"></a>SELECT(A-&gt;a)</h3><p>a不为ε，则SELECT(A-&gt;a) = FIRST(a)。</p><p>否则，SELECT(A-&gt;a) = FIRST(a) - ε + FOLLOW(A)。</p><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>第1个L表示从左往右扫描字符串。</p><p>第2个L表示采用最左推导。</p><p>1表示只需向右看1个字符即可选择哪个产生式。（为了提高效率，最多为2）。</p><h4 id="充要条件："><a href="#充要条件：" class="headerlink" title="充要条件："></a>充要条件：</h4><p>SELLECT(A-&gt;a) ∩ SELECT(A-&gt;b) = 空集。（a，b不能同时能ε）。</p><p>通俗理解就是a和b不能有相同前缀。</p><h4 id="LL-1-文法判别步骤"><a href="#LL-1-文法判别步骤" class="headerlink" title="LL(1)文法判别步骤"></a>LL(1)文法判别步骤</h4><p>求出能推出 ε 的非终结符。（未定，是，否）</p><p>计算FIRST集</p><p>计算FOLLOW集</p><p>计算SELECT集</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="递归子程序法"><a href="#递归子程序法" class="headerlink" title="递归子程序法"></a>递归子程序法</h4><p>对应文法中每个非终结符编写一个递归过程，每个过程的功能是识别由非终结符推出的串，当某非终结符的产生式有多个候选时能够按LL(1)形式可唯一确定地选择某个候选进行推导。</p><p>当文法满足LL(1)条件时，构造不带回溯的自上而下分析程序。</p><p>该分析程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>不是所有的aij的first集的交集都为空，仅针对一个VN的候选式有如此的约定。</p><h4 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h4><h5 id="特征"><a href="#特征" class="headerlink" title="特征 :"></a>特征 :</h5><p>根据当前输入符号，为当前要处理的非终结符选择产生式。</p><p>表驱动的预测分析器包含：</p><ul><li>一个输入缓冲区</li><li>一个栈</li><li>一张分析表</li><li>一个输出流</li></ul><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-1.png" alt=""></p><h5 id="预测分析表M"><a href="#预测分析表M" class="headerlink" title="预测分析表M"></a>预测分析表M</h5><p>预测分析表是一个M[A，a]形式的矩阵。</p><p>其中： A为非终结符，a为终结符或#。</p><p>M[A，a]中存放着一条关于A的产生式，指出当A面临a时所应采取的候选；</p><p>M[A，a]中也可能存放一条“出错标志”，指出Ａ不应该面临a。</p><p>例：对于文法G       </p><ol><li>E→TE’</li><li>E’ → +TE’|ε</li><li>T →FT’</li><li>T’→*FT’| ε</li><li>F→(E)|id  </li></ol><p>其预测分析表为：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-2.png" alt="1557056948767"></p><p>解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FIRST(E)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(E’)=&#123;+, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T’)=&#123; *, ε&#125;</span><br><span class="line"></span><br><span class="line">FIRST(T)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FIRST(F)=&#123; (, id &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E) =&#123;#, )&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(E’)=&#123;), #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T’)=&#123;+, ),  # &#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(T) =&#123;+, ),  #&#125;</span><br><span class="line"></span><br><span class="line">FOLLOW(F) =&#123;id, ), *,  #&#125;</span><br></pre></td></tr></table></figure><h5 id="预测分析器"><a href="#预测分析器" class="headerlink" title="预测分析器"></a>预测分析器</h5><p>预测分析程序的算法：</p><ul><li><p>输入：串w和文法G的分析表M</p></li><li><p>输出：如果w属于L（G），则输出w的最左推导，否则报错</p></li><li><p>方法：开始时，#S在栈里，w#在输入缓冲区</p><p>令ip指向w #的第一个符号，令X是栈顶符号，a是ip指向的符号</p></li></ul><p>预测分析器的工作方式：当前栈顶符号X和当前输入符号为a，则语法分析器的动作为：</p><ol><li>如果X=a≠#，则POP，advance</li><li>如果X ∈VN,查M[X，a]表，若M[X，a]=X→UVW,则用WVU替换栈顶；若M[X，a]=error,则调用错误恢复程序。</li><li>如果X=a=#,分析成功。</li></ol><p>句子id+id*id的分析过程：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-05-3.png" alt="1557057317524"></p><h2 id="不确定分析（简）"><a href="#不确定分析（简）" class="headerlink" title="不确定分析（简）"></a>不确定分析（简）</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>匹配，匹配不了回溯继续匹配，直到全部匹配不了或匹配成功为止。（非常暴力）</p><ol><li><p>由于相同左部的产生式的右部FIRST集交集不为空而引起回溯。</p><p>S-&gt;xAy</p><p>S-&gt;ab|a</p></li><li><p>由于相同左部非终结符的右部可为 ε ，且非终结符的FOLLOW集中含有其他产生式右部FIRST集的元素。</p><p>S-&gt;aAS</p><p>S-&gt;b</p><p>A-&gt;bAS</p><p>A-&gt;ε</p></li><li><p>由于文法含有左递归。</p><p>S-&gt;Sa</p><p>S-&gt;b</p></li></ol><h2 id="部分不确定分析转确定分析"><a href="#部分不确定分析转确定分析" class="headerlink" title="部分不确定分析转确定分析"></a>部分不确定分析转确定分析</h2><h3 id="左递归消除"><a href="#左递归消除" class="headerlink" title="左递归消除"></a>左递归消除</h3><h4 id="直接左递归消除"><a href="#直接左递归消除" class="headerlink" title="直接左递归消除"></a>直接左递归消除</h4><p>采用下列变换公式消除直接左递归，把直接左递归改写为右递归。</p><p>如：G[S]： S→Sa | b</p><p>可改写为：</p><p>S→bS’</p><p>S’→aS’|ε </p><p>改写后的文法所描述的L(G)={ba^n| n&gt;=0}</p><p>一般而言，假定关于P的全部产生式是</p><p>P→Pa1 | Pa2 | … | Pam | b1 | b2|…|bn 其中，每个a都不等于ε，而每个都不以P开头，那么，消除P的直接左递归性就是改写这些规则：</p><p>P→b1P’ | b2P’ | … | bnP’</p><p>P’→a1P’ | a2P’ |… | amP’ | ε </p><h4 id="间接左递归消除"><a href="#间接左递归消除" class="headerlink" title="间接左递归消除"></a>间接左递归消除</h4><p>间接左递归的消除需先将间接左递归变为直接左递归，然后再按第1种方法消除直接左递归。</p><h5 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h5><p>将一个产生式规则右部的a中的Vn N替换为N的候选式。如果N有n个候选式，右边a重复n次，而且每一次重复都有N的不同候选式来代替N。</p><p>例如：N →a | Bc | ε  在S→Nq中的代入结果S→aq | Bcq | q。</p><h3 id="回溯消除"><a href="#回溯消除" class="headerlink" title="回溯消除"></a>回溯消除</h3><p>回溯产生的根源：头字符集合的问题。例如A-&gt;ab|a。</p><h4 id="提取公因子"><a href="#提取公因子" class="headerlink" title="提取公因子"></a>提取公因子</h4><p>经过反复提取左因子，就能够把每个非终结符（包括新引进者）的所有候选首符集变成为两两不相交。</p><p>例：考察文法G[S]:</p><p>S → iCtS | iCtSeS | aC → b </p><p>解：由于S的前两个候选项中含有左因子iCtS，提取左因子之后，等价文法G’如下：</p><p>S → iCtSS’ | a</p><p>S’ →eS |ε</p><p>C → b</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;语法分析&lt;ul&gt;
&lt;li&gt;自顶向下语法分析&lt;ul&gt;
&lt;li&gt;确定分析&lt;/li&gt;
&lt;li&gt;不确定分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自底向上语法分析&lt;ul&gt;
&lt;li&gt;算符优先分析&lt;/li&gt;
&lt;li&gt;LR分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="语法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>语法分析与词法分析指北</title>
    <link href="http://qianyouyou.cn/2019/05/01/2019-05-01/"/>
    <id>http://qianyouyou.cn/2019/05/01/2019-05-01/</id>
    <published>2019-05-01T13:41:32.000Z</published>
    <updated>2019-05-05T11:38:29.554Z</updated>
    
    <content type="html"><![CDATA[<p>程序编译过程：</p><p>源程序 -&gt; 词法分析程序 -&gt; <strong>语法分析程序</strong> -&gt; <strong>语义分析程序</strong> -&gt; 中间代码生成程序 -&gt; 代码优化程序 -&gt; 目标代码生成程序 -&gt; 目标程序</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>例：</p><p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p><p>&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;</p><p>&lt;代词&gt; → 你 | 我 | 他</p><p>&lt;名词&gt; → 老王 | 大学生 | 英语</p><p>&lt;谓语&gt; → &lt;动词&gt;&lt;直接宾语&gt;</p><p>&lt;动词&gt; → 是 | 学习 | 热爱</p><p>&lt;直接宾语&gt; → &lt;代词&gt; | &lt;名词&gt;</p><p>“我是大学生”符合以上规则，是句子。“我大学生是”不符合上面规则，不是句子。</p><p>&lt;句子&gt; → &lt;主语&gt;&lt;谓语&gt;</p><p>→ &lt;代词&gt;&lt;谓语&gt;</p><p>→ 我&lt;谓语&gt;</p><p>→ 我&lt;动词&gt;&lt;直接宾语&gt;</p><p>→ 我是&lt;直接宾语&gt;</p><p>→ 我是&lt;名词&gt;</p><p>→ 我是大学生</p><h2 id="符号和字符串"><a href="#符号和字符串" class="headerlink" title="符号和字符串"></a>符号和字符串</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表即符号集，例如汉字的字母表包括汉字，数字标点等，C语言包括if，while之类的保留字组成。</p><h3 id="符号串"><a href="#符号串" class="headerlink" title="符号串"></a>符号串</h3><p>由字母表中的符号组成的任何又穷序列（顺序很重要）。例如A = {a, b, c}的符号串有a，b，ab，ba， aa等等。</p><h3 id="符号串的头尾，固有头固有尾"><a href="#符号串的头尾，固有头固有尾" class="headerlink" title="符号串的头尾，固有头固有尾"></a>符号串的头尾，固有头固有尾</h3><p>abc的头是 ε, a, ab, abc，除abc外均为固有头。尾是ε, c, bc, abc，除abc外均为固有尾。</p><h3 id="符号串方幂"><a href="#符号串方幂" class="headerlink" title="符号串方幂"></a>符号串方幂</h3><p>x = AB。x^0 = ε。x^1 = AB。x^2 = ABAB。x^3 = ABABAB。</p><h3 id="符号串的集合"><a href="#符号串的集合" class="headerlink" title="符号串的集合"></a>符号串的集合</h3><p>A = {a, b}。B = {c, d}。AB = {ac, ad, bc, bd}。</p><h2 id="文法定义"><a href="#文法定义" class="headerlink" title="文法定义"></a>文法定义</h2><p>G(VN, VT, P, S)。</p><p>VN为非终结符（例如&lt;谓语&gt;，可以继续转换。通常用大写字母表示，例如A）</p><p>VT为终结符（例如“老王”，可直接匹配，不能再向下转换。通常用小写字母表示，例如a）</p><p>P（规则，例如&lt;主语&gt; → &lt;代词&gt;&lt;名词&gt;。又例如S →Aa）。</p><p>S起点（例如&lt;句子&gt;就是起点）</p><h2 id="文法类型"><a href="#文法类型" class="headerlink" title="文法类型"></a>文法类型</h2><p>3型∈2型∈1型∈0型，3型最严谨，向右兼容。</p><h3 id="0型递归文法"><a href="#0型递归文法" class="headerlink" title="0型递归文法"></a>0型递归文法</h3><p>a→b，a至少含1个非终结符，b为任意。</p><p>凡是递归可枚举的都是0型，包括A→ε，aA→aa等情况。</p><h3 id="1型上下文有关文法"><a href="#1型上下文有关文法" class="headerlink" title="1型上下文有关文法"></a>1型上下文有关文法</h3><p>a→b，a至少含1个非终结符，b不为ε。</p><p>0型除去ε的情况就是1型。也就是非终结符不能为ε。</p><p>包括aA→aa等情况。</p><h3 id="2型上下文无关文法"><a href="#2型上下文无关文法" class="headerlink" title="2型上下文无关文法"></a>2型上下文无关文法</h3><p>a→b，a必须是非终结符（only one）。</p><p>不包括aA→aa等情况。</p><p>可以A→aa。</p><h3 id="3型正规文法"><a href="#3型正规文法" class="headerlink" title="3型正规文法"></a>3型正规文法</h3><p>非终结符转换时头必须有一个终结符。例如：</p><p>S→aB</p><p>S→bA</p><p>A→a</p><p>A→aS</p><p>A→bAA</p><p>B→b</p><p>B→bS</p><p>B→aBB</p><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01.png" alt=""></p><h2 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h2><ul><li>自顶向下语法分析（由S向句子推，最终和句子匹配，看能否得到句子）</li><li>自底向上语法分析（由句子向S推，最终看能否得到S）</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>输入源程序；扫描、分解字符串，识别出一个个单词（定义符、标识符、运算符、界符、常数）</p><h2 id="词法分析输出"><a href="#词法分析输出" class="headerlink" title="词法分析输出"></a>词法分析输出</h2><p>读入源程序，输出担此符号。单词符号可分为以下5种：</p><p>关键字（if，else，while，int等）</p><p>标识符（a，fun，val等自定义的变量名）</p><p>常数（1，1.2，true，“abc”）</p><p>运算符（+，-，=，&lt;=，==）</p><p>界符（，；’)’）等。</p><p>词法分析输出单词符号常常采用二元组形式（单词种别，单词自身值）。</p><h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>扫描阶段：从左向右扫描输入源程序，删除注释、压缩空白字符；</p><p>词法分析阶段：按照语言的词法规则识别各类单词，并产生相应的单词符号。</p><h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>&lt;标识符&gt; → l | l &lt;字母数字&gt;</p><p>&lt;字母数字&gt; → l | d |l &lt;字母数字&gt; | d&lt;字母数字&gt;</p><p>（l字母，d数字）</p><p>例如:</p><p>A→aB</p><p>A→a</p><h2 id="正规式"><a href="#正规式" class="headerlink" title="正规式"></a>正规式</h2><p>a            {a}</p><p>a|b            {a,b}</p><p>ab            {ab}</p><p>(a|b)(a|b)    {aa,ab,ba,bb}</p><p>a*            {ε,a,aa,aaa…}</p><p>(a|b)*        {ε,a,aab,abaa…所有a,b组成的串}</p><p>(a|b)*(aa|bb)(a|b)*        {aaabbaab……}</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="确定有穷自动机-DFA"><a href="#确定有穷自动机-DFA" class="headerlink" title="确定有穷自动机(DFA)"></a>确定有穷自动机(DFA)</h3><p>DFA M = （K, ∑, f, S, Z）</p><p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p><p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p><p>f：转换函数，一个节点通过某条边到另一个结点（或自身）。</p><p>S：唯一一个初态（起点）</p><p>Z：终态集。（就是终点的集合）</p><h3 id="不确定有穷自动机-NFA"><a href="#不确定有穷自动机-NFA" class="headerlink" title="不确定有穷自动机(NFA)"></a>不确定有穷自动机(NFA)</h3><p>NFA M = （K, ∑, f, S, Z）</p><p>K：有穷集，每个元素称为一种状态（图表示就是点集）。</p><p>∑：有穷字母表，每个元素称为一个输入符号，所以也叫输入符号表（图表示就是边集）。</p><p>f：转换函数，一个节点通过某一类边到另外许多结点的集合（或自身）。</p><p>S：初态集（多个起点）</p><p>Z：终态集。（就是终点的集合）</p><p>很容易发现，不确定有穷自动机和确定有穷自动机的区别就是DFA每个结点每类单向边只有一条，且起点只有一个，而NFA可以有多条，且起点可以有多个。例如NFA中S—a—&gt;A，S—a,b—&gt;S，S—a,b—&gt;D，但DFA不允许，a，b由S指向其他结点（或自身）的话只能存在一条。</p><h2 id="正则式转自动机"><a href="#正则式转自动机" class="headerlink" title="正则式转自动机"></a>正则式转自动机</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-1.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-05-01-2.png" alt=""></p><h2 id="正规文法转自动机"><a href="#正规文法转自动机" class="headerlink" title="正规文法转自动机"></a>正规文法转自动机</h2><p>正规文法由于为第3型文法，所以S→aA，S为起点，→为边，a为边名，A为下一个结点。</p><h2 id="NFA转DFA"><a href="#NFA转DFA" class="headerlink" title="NFA转DFA"></a>NFA转DFA</h2><p><a href="https://blog.csdn.net/dala_da/article/details/78704560" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序编译过程：&lt;/p&gt;
&lt;p&gt;源程序 -&amp;gt; 词法分析程序 -&amp;gt; &lt;strong&gt;语法分析程序&lt;/strong&gt; -&amp;gt; &lt;strong&gt;语义分析程序&lt;/strong&gt; -&amp;gt; 中间代码生成程序 -&amp;gt; 代码优化程序 -&amp;gt; 目标代码生成程序 -&amp;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="词法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="语法分析" scheme="http://qianyouyou.cn/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统漫游——&quot;Hello,World&quot;的漫漫计算机旅程</title>
    <link href="http://qianyouyou.cn/2019/04/29/2019-04-29/"/>
    <id>http://qianyouyou.cn/2019/04/29/2019-04-29/</id>
    <published>2019-04-29T07:52:39.000Z</published>
    <updated>2019-05-14T15:04:48.469Z</updated>
    
    <content type="html"><![CDATA[<p>每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。</p><p>本文主要介绍一个简简单单的”Hello,World”程序是如何在计算机系统乃至网络跑起来的。（当然不会写的太复杂啦，毕竟这是一个漫长的过程）。</p><p>翠花，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;Hello,World\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>hello程序的生命周期是从一个hello.c的源文件开始的。而源程序实际是一个由0、1组成的位（比特）序列，8位一组，称为字节。每个字节表示程序中的某些文本字节。大多数系统以ASCII码表示文本字符。例如以上代码就可以ASII表示为：</p><table><thead><tr><th>#</th><th>i</th><th>n</th><th>c</th><th>l</th><th>u</th><th>d</th><th>e</th><th>SP</th><th>&lt;</th><th>s</th><th>t</th><th>d</th><th>i</th><th>o</th><th>.</th></tr></thead><tbody><tr><td>35</td><td>105</td><td>110</td><td>99</td><td>108</td><td>117</td><td>100</td><td>101</td><td>32</td><td>60</td><td>115</td><td>116</td><td>100</td><td>105</td><td>111</td><td>46</td></tr><tr><td>h</td><td>&gt;</td><td>\n</td><td>i</td><td>n</td><td>t</td><td>SP</td><td>m</td><td>a</td><td>i</td><td>n</td><td>(</td><td>）</td><td>{</td><td>\n</td><td>SP</td></tr><tr><td>104</td><td>62</td><td>10</td><td>105</td><td>110</td><td>116</td><td>32</td><td>109</td><td>97</td><td>105</td><td>110</td><td>40</td><td>41</td><td>123</td><td>10</td><td>32</td></tr><tr><td>SP</td><td>SP</td><td>SP</td><td>p</td><td>r</td><td>i</td><td>n</td><td>t</td><td>f</td><td>(</td><td>“</td><td>H</td><td>e</td><td>l</td><td>l</td><td>o</td></tr><tr><td>32</td><td>32</td><td>32</td><td>112</td><td>114</td><td>105</td><td>110</td><td>116</td><td>102</td><td>40</td><td>34</td><td>72</td><td>101</td><td>108</td><td>108</td><td>111</td></tr><tr><td>,</td><td>W</td><td>o</td><td>r</td><td>l</td><td>d</td><td>\</td><td>n</td><td>“</td><td>)</td><td>;</td><td>\n</td><td>SP</td><td>SP</td><td>SP</td><td>SP</td></tr><tr><td>44</td><td>87</td><td>111</td><td>114</td><td>108</td><td>100</td><td>92</td><td>110</td><td>34</td><td>41</td><td>59</td><td>10</td><td>32</td><td>32</td><td>32</td><td>32</td></tr><tr><td>r</td><td>e</td><td>t</td><td>u</td><td>r</td><td>n</td><td>SP</td><td>0</td><td>;</td><td>\n</td><td>}</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>114</td><td>101</td><td>116</td><td>117</td><td>114</td><td>110</td><td>32</td><td>48</td><td>59</td><td>10</td><td>125</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>hello.c是以字节序的方式存储在文件中的。系统中的所有信息（磁盘文件，用户信息，网络传输数据等）均由一串比特表示。区分不同数据对象的唯一方式是读这些数据对象时的上下文。比如不同的上下文中，一个同样的字节序列可能表示整数，浮点数，字符串或者机器指令。</p><h1 id="程序到可执行文件的过程"><a href="#程序到可执行文件的过程" class="headerlink" title="程序到可执行文件的过程"></a>程序到可执行文件的过程</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>cpp根据以字符#开头的命令，修改原始C程序。例如上例hello.c中#include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h中的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>ccl将文本文件hello.i翻译成汇编语言hello.s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">subq$8, %rsp</span><br><span class="line">movl$.LCO, %edi</span><br><span class="line">callputs</span><br><span class="line">movl$0, eax</span><br><span class="line">addq$8, %rsp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>as将hello.s翻译成机器语言指令，这些指令打包成hello.o中。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>hello程序调用了printf函数，存在于编译好的printf.o中，ld负责合并。它是一个可执行文件，可以被加载入内存，由系统执行。</p><h1 id="理解编译系统的好处"><a href="#理解编译系统的好处" class="headerlink" title="理解编译系统的好处"></a>理解编译系统的好处</h1><ul><li>优化程序性能。</li><li>理解链接时出现的错误。</li><li>避免安全漏洞。</li></ul><h1 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h1><p>Linux下，hello文件的执行过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; ./hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure><p>第一行与第三行是shell，shell是一个命令行解释器，它输出一个提示符，等待输入一个命令。如果shell命令行第一个单词不是一个内置shell命令，那么shell会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以上面案例shell加载并执行了当前目录下hello程序，然后等待程序终止。程序完成后，又切换回shell。</p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ul><li><strong>总线</strong>：贯穿整个系统的是一组电子管道，即总线。携带信息负责在各个部件间传递。</li><li><strong>I/O设备</strong>：系统与外部的联系通道。</li><li><strong>主存</strong>：临时存储设备，存储数据共处理器调用或修改。</li><li><strong>处理器</strong>：执行存储在主存中指令的引擎。</li></ul><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt=""></p><h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%201.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%202.png" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%20-%203.png" alt=""></p><h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>由上例可发现，系统花费了大量时间把信息从一个敌方搬到另一个地方。hello程序原本在磁盘上，加载时复制到主存，处理机运行时又由主存复杂到处理器。字符串原在主存上，后复制到内存，后复制到显示器。为了提高速度，便引入高速缓存。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.jpg" alt=""></p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt=""></p><h1 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h1><p>当shell加载和运行hello程序时，以及hello输出消息时，并没直接访问键盘，磁盘或主存，而是通过操作系统。所以说我们可以理解操作系统是应用程序与硬件之间插入的一层软件。</p><p>操作系统通过进程，虚拟内存和文件来实现硬件与应用程序间的交互。</p><p>进程（处理器+主存+I/O设备）</p><p>虚拟内存（主存+I/O设备）</p><p>文件（I/O设备）</p><h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/2019-04-29-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每一个Coder都是从”Hello,World”开始的。那么既然是修仙第一天，那我们就从”Hello,World”开始吧。&lt;/p&gt;
&lt;p&gt;本文主要介绍一个简简单单的”Hello,World”程序是如何在计算机系统乃至网络跑起来的。（当然不会写的太复杂啦，毕竟这是一个漫长的过
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="计算机系统" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="编译原理" scheme="http://qianyouyou.cn/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="存储器" scheme="http://qianyouyou.cn/tags/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>大话存储器与虚拟内存</title>
    <link href="http://qianyouyou.cn/2019/04/27/2019-04-27/"/>
    <id>http://qianyouyou.cn/2019/04/27/2019-04-27/</id>
    <published>2019-04-27T11:04:49.000Z</published>
    <updated>2019-05-18T12:29:56.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><p>首先得声明，在引入虚拟存储器之前，存储器通常是将整个进程所有资源引入内存的。</p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27.png" alt=""></p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><ol><li><p>绝对装入方式</p><p>编译程序将产生绝对地址的目标代码根据地址将程序和数据存入内存。</p><ol><li>编程人员要熟悉内存。</li><li>程序在内存中不能移动。</li><li>不适用于多道程序设计环境。</li></ol></li><li><p>可重定位装入方式（静态）</p><p>编译程序将产生相对地址的目标代码，装入时需要地址映射，地址变换只在装入时一次性完成，以后不再改变。</p><ol><li>适用于多道程序环境。</li><li>程序在内存中不能移动。</li></ol></li><li><p><strong>动态运行时装入方式</strong></p><p>编译程序将产生相对地址的目标代码，装入时并不立即把相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时才运行。</p><ol><li>程序装入内存后可移动。</li></ol></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ol><li><p>静态链接方式</p><p>程序运行前将各目标模块及所需库装配成一个完整模块且不再分开。</p></li><li><p>装入时动态链接</p><p>边装入边链接。（假如没有用到某一模块，也会装入内存，所有才有了方法3）</p></li><li><p><strong>运行时动态链接</strong></p><p>将链接推迟到程序运行时，如果链接到哪一模块，则再将该模块装入内存。（加快装入过程，节省空间）</p></li></ol><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol><li>单一连续分配</li><li>固定分区分配</li><li><strong>动态分区分配</strong></li></ol><h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><h4 id="首次适应算法-First-Fit"><a href="#首次适应算法-First-Fit" class="headerlink" title="首次适应算法(First Fit):"></a>首次适应算法(First Fit):</h4><p>从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。</p><p>特点<br>该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。</p><p>缺点<br>低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销</p><h4 id="下次适应（next-fit）算法"><a href="#下次适应（next-fit）算法" class="headerlink" title="下次适应（next fit）算法"></a>下次适应（next fit）算法</h4><p>也称“临近适应”算法，其工作方式和最先适应算法相同（最先适应也称首次适应算法。它总是最先找到的、满足存储要求的那个空闲分区作为分配对象。），不同的是每次找到合适的空闲的分区时就记住它的位置，以便下次就从该位置开始往下查找，而不是每次都像最先适应算法那样从头开始查找。这种算法的总体结果通常要比最先适应算法差。由于它经常会在内存的末尾分配存储分区，使位于存储空间末尾的最大分区被撕裂称小的外部碎片，因此必须经常不断地进行存储紧凑。在该算法中应采取循环查找方式，即最后上个空闲区的大小仍不能满足要求时，应再从第一个空闲区开始查找，故又称为循环造就算法。</p><h4 id="最佳适应算法（Best-Fit）："><a href="#最佳适应算法（Best-Fit）：" class="headerlink" title="最佳适应算法（Best Fit）："></a>最佳适应算法（Best Fit）：</h4><p>它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。</p><p>Best fit算法等价于装箱问题，举例如下：</p><p>装箱问题：有体积为V的箱子N个，体积为Vi的物品M个，求使得物品全部能够装入箱子，箱子数量的最小值。<br>假设 V=6 N=10，V1，V2，…,V10分别为：3 4 4 3 5 1 2 5 3 1。计算过程如下：<br>第一步按物品体积降序排序：5 5 4 4 3 3 3 2 1 1<br>第二步：取未装箱的最大值5装入第一个箱子。<br>第三步：判断第一个箱子是否已满，不满且剩余空间为1，搜寻剩下体积小于等于1的物品填入箱子1，箱子1填满。<br>第四步：重复第二，第三步，直到所有物品装入箱子为止，得到箱子数量为6.<br>6即时本例N的最小值。</p><h4 id="最坏适应算法（worst-fit）"><a href="#最坏适应算法（worst-fit）" class="headerlink" title="最坏适应算法（worst fit）"></a>最坏适应算法（worst fit）</h4><p>最坏适应分配算法要扫描整个空闲分区或链表，总是挑选一个最大的空闲分区分割给作业使用。该算法要求将所有的空闲分区按其容量从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。</p><p>优点：可使剩下的空闲分区不至于太小，产生碎片的几率最小，对中、小作业有利，同时该算法查找效率很高。</p><p>缺点：会使存储器中缺乏大的空闲分区。</p><p>最坏适应算法与首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。</p><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><h4 id="快速适应算法（分类搜索法）"><a href="#快速适应算法（分类搜索法）" class="headerlink" title="快速适应算法（分类搜索法）"></a>快速适应算法（分类搜索法）</h4><p>该算法就是将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样的系统中存在多个空闲分区链表。同时，在内存总设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。</p><p>该算法在搜索可分配的空闲分区时分为两步：第一步是根据进程的长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。另外，该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。优点是查找效率高。缺点是在分区归还时的算法复杂，系统开销大。此外，该算法在分配空闲分区时，是以进程为单位的，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少的存在一定的浪费。这是典型的以空间换时间的做法。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂，通常2的m次方是整个可分配内存的大小。假设系统的的可利用空间容量为2的m次方，则当系统开始运行时，整个内存区是一个大小为2的m次方的空闲分区。在系统运行过程中，由于不断地划分，将会形成若个个不连续的空闲分区，将这些分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。</p><p>当需要为进程分配一个长度大小为n的存储空间时，首先计算一个i值，使2的i-1次方小于n小于等于2的i次方，然后再空闲分区大小为2的i次方的空闲分区链表中查找。</p><p>在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法号。而其空间性能，由于对空闲分区进行合并，减少了空闲分区，提高了空间分区的可使用率，故由于快速适应算法，比顺序搜索法略差。</p><p>总结：虽然在当前的操作系统中，主要还是采用离散分配方式的分页和分段机制的虚拟内存机制，因为该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，目前仍然被广泛使用。</p><h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>由于分类搜索算法和伙伴系统算法中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在每一张管理索引表中查找到所需要的空间大小所对应的表项，从中得到对应的空间内分区链表表头指针，从而通过查找一个空闲分区。如果对空闲分区分类比较细，则相应索引表的表项也就较多，因此会显著的增加搜索索引表的表项的时间开销。</p><p>哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</p><p>当进行空闲分区分配时，根据所需要的空闲 分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol><li>紧凑</li><li>动态重定位</li><li>动态重定位分区分配算法</li></ol><h2 id="离散式存储管理方式"><a href="#离散式存储管理方式" class="headerlink" title="离散式存储管理方式"></a>离散式存储管理方式</h2><h3 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h3><h4 id="连续分配存储管理方式产生的问题"><a href="#连续分配存储管理方式产生的问题" class="headerlink" title="连续分配存储管理方式产生的问题"></a><strong>连续分配存储管理方式产生的问题</strong></h4><p>在分区存储管理中，要求把进程放在一个连续的存储区中，因而会产生许多碎片。</p><h4 id="碎片问题的解决方法"><a href="#碎片问题的解决方法" class="headerlink" title="碎片问题的解决方法"></a>碎片问题的解决方法</h4><p>（1）拼接/紧凑技术—-代价较高。</p><p>（2）离散分配方式—允许将作业/进程离散放到多个不相邻接的分区中，就可以避免拼接。</p><h4 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h4><p>分页式存储管理：离散分配的基本单位是页</p><p>分段式存储管理：离散分配的基本单位是段</p><p>段页式存储管理：离散分配的基本单位是段、页</p><h4 id="什么是页"><a href="#什么是页" class="headerlink" title="什么是页"></a>什么是页</h4><p>将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面,页面大小由地址结构（逻辑）决定 ，并为各页从0开始编号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-1.png" alt=""></p><h4 id="什么是块"><a href="#什么是块" class="headerlink" title="什么是块"></a>什么是块</h4><p>内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（frame），同样从0开始编号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-2.png" alt=""></p><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>在为进程分配内存时,以块为单位,将进程中若干页装入到多个不相邻的块中,最后一页常装不满一块而出现页内碎片。</p><h4 id="页表的出现"><a href="#页表的出现" class="headerlink" title="页表的出现"></a>页表的出现</h4><p>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。一个页表中包含若干个表目，1.表目的自然序号对应于用户程序中的页号。2.表目中的块号是该页对应的物理块号。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-3.png" alt=""></p><h4 id="内存地址的获取"><a href="#内存地址的获取" class="headerlink" title="内存地址的获取"></a>内存地址的获取</h4><p>以页号查页表，得到对应页装入内存的块号。即可求出：<strong>内存地址＝物理块号×页大小＋页内地址</strong>。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-4.png" alt=""></p><p>例:在采用页式存储管理的系统中,某作业J的逻辑地址空间为4页(每页2048字节),且已知该作业的页面映像表如下:</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>1</td><td>4</td></tr><tr><td>2</td><td>6</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><p>试借助地址变换图求出有效逻辑地址4865所对应的物理地址.</p><p>解:页号  4865/2048=2   页内位移   4865%2048=769，过程如下：</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-5.png" alt=""></p><p>从上面我们可以看出：CPU要想获取一个数据时，必须两次访问内存：</p><p>1、从内存中的页表中，寻找对应的物理块号，将物理块号与页内地址组合成物理地址。</p><p>2、根据组合成的物理地址，来获取数据。</p><p>为了提高效率呢，就引进了块表，什么是快表呢？</p><p>在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器”或“快表”。</p><p>在引入快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题，。总体上来说，还是减少了访问内存的时间。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-6.png" alt=""></p><h3 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h3><h4 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h4><p>引入分段存储管理方式，主要是为了满足用户和程序员的下述一系列需要：</p><p>1）<strong>方便编程</strong></p><p>通常，用户把自己的作业按照<strong>逻辑关系</strong>划分为若干个段，每个段都是<strong>从0开始</strong>编址，并有自己的<strong>名字</strong>和<strong>长度</strong>。</p><p>因此，希望要访问的逻辑地址是由<strong>段名</strong>（段号）和<strong>段内偏移量</strong>（段内地址）决定的。</p><p>2）<strong>信息共享</strong></p><p>在实现对<strong>程序和数据的共享</strong>时，是以<strong>信息的逻辑单位为基础的</strong>。比如共享某个例程和函数，分页系统中的“页”只是存放信息的<strong>物理单位</strong>（块），</p><p>并无完整的意义，不便于实现共享，然而<strong>段却是信息的逻辑单位</strong>。</p><p>3）<strong>信息保护</strong></p><p>信息保护同样是<strong>对信息的逻辑单位进行保护</strong>，因此，分段管理方式能更有效和方便的实现信息保护功能。</p><p>4）<strong>动态增长</strong></p><p>在实际应用中，往往有些段，特别是数据段，在使用过程中会<strong>不断地增长</strong>，而事先又无法确切地知道数据段会增长到多大。前面的几种存储</p><p>管理方式都难以应付这种动态增长的情况，分段存储管理方式能较好的解决这一问题。</p><p>5）<strong>动态链接</strong></p><p>动态链接是指<strong>在作业运行之前</strong>，并不把几个目标程序段链接起来。<strong>要运行时</strong>，先将<strong>主程序</strong>所对应的目标程序装入内存并启动运行，当运行过程</p><p>中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。<strong>可见，动态链接也要求以段作为管理的单位。</strong></p><h4 id="分段和段表"><a href="#分段和段表" class="headerlink" title="分段和段表"></a>分段和段表</h4><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，<strong>每个段</strong> 定义了一组<strong>逻辑信息</strong>。每个段都有自己的名字，通常可用一个<strong>段号</strong>来</p><p>代替<strong>段名</strong>，<strong>每个段都从0开始编址</strong>，并采用<strong>一段连续的地址空间</strong>。段的长度由相应的逻辑信息组的长度决定，因而<strong>各段长度不等</strong>。整个作业的</p><p>地址空间分成多个段，是<strong>二维的</strong>。</p><p>在<strong>动态分区</strong>（可变分区）分配方式中，系统为<strong>整个进程</strong>分配一个连续的内存空间。而在分段式存储管理系统中，则是为<strong>每个分段</strong>分配一个</p><p>连续的分区，而进程中的各个段可以离散地装入内存中不同的分区中。为使程序能正常运行，即能从物理内存中找出每个逻辑段所对应的位置，</p><p>应像分页系统那样，<strong>在系统中为每个进程建立一张段映射表</strong>，简称“<strong>段表</strong>”。</p><p>每个段在表中占有一个表项，其中记录了该段在内存中的<strong>起始地址</strong>（“基址”）和<strong>段长</strong>（字节）。段表一般放在内存中。在配置了段表后，</p><p>执行中的进程可通过查找段表找到每个段所对应的内存区。可见，段表是用于实现从<strong>逻辑段</strong>到<strong>物理内存区</strong>的映射。</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong>，用于存放<strong>段表始址</strong> 和<strong>段表长度TL</strong>。在进行地址变换时，</p><p>系统将逻辑地址中的<strong>段号S（0～TL-1）</strong>与<strong>段表长度TL</strong>进行比较。–  若S&gt;=TL，表示<strong>段号太大，</strong>是访问越界，于是产生越界中断信号；</p><p>若未越界，则根据段表的始址和该段的段号，计算出该段<strong>对应段表项的位置</strong>（段表的始址+段号x段表项的长度），从中读出该段在内存的</p><p>起始地址，然后再检查段内地址d是否超过该段的<strong>段长SL</strong>。若超过，即d&gt;SL,同样发出越界中断信号；若未越界，则将该段的<strong>基址</strong>与<strong>段内地址d</strong></p><p>相加，即可得到要访问的<strong>内存物理地址</strong>。</p><p>像分页系统一样，当段表放在内存中时，每当要访问一个数据，都需<strong>访问两次内存</strong>（第一次是得到物理地址，第二次是从地址中取数据），</p><p>从而极大地降低了计算机的速率。解决方法是再<strong>增设一个联想存储器</strong>（TLB），用于保存最近常用的段表项。一般情况下是段比页大，因而</p><p><strong>段表项</strong>的数目比页表项的数目少，需要的TLB也相对较小，可以显著的减少存取数据的时间。</p><h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><p>分页和分段系统都采用<strong>离散</strong>分配方式，且都要通过<strong>地址映射机构来</strong>实现地址变换。但在概念上两者完全不同，主要表现在3个方面：</p><p>– 1）页是信息的<strong>物理**</strong>单位<strong>，分页是为实现离散分配方式，消减外部碎片，提高内存的利用率。</strong>分页仅仅是由于系统管理的需要而不是用户的需要。**</p><p>段则是信息的<strong>逻辑单位</strong>，它含有一组其意义相对完整的信息。<strong>分段的目的是为了更好的满足用户的需要。</strong></p><p>– 2）页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；</p><p>而<strong>段的长度不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p><p>– 3）<strong>分页</strong>的作业地址空间是<strong>一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而<strong>分段</strong>的作业地址空间<strong>是二维的</strong>，</p><p>程序员在标识一个地址时，既需给出<strong>段名</strong>，又需给出<strong>段内地址</strong>。</p><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><p><strong>段的共享：即允许若干个进程共享一个或多个分段。</strong></p><p><strong>可重入代码</strong>（Reentrant Code）又称为“纯代码”（Pure Code），是一种<strong>允许多个进程同时访问的代码</strong>。为使各个进程所执行的代码完全相同，</p><p>绝对不允许可重入代码在执行中有任何改变。因此，<strong>可重入代码</strong>是一种<strong>不允许任何进程对它进行修改的代码</strong>。</p><p>—- 但事实上，大多数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量及数组等。为此，在每个进程中，都必</p><p>须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区，这样，程序在执行时，只需对该数据区（属于该进程私有）中的内容进行修改，并</p><p>不去改变共享的代码，这时的可共享代码即成为可重入码。</p><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><p>用户程序<strong>先分段</strong>，每个段内部<strong>再分页（内部原理同基本的分页、分段相同）</strong></p><p><strong><img src="http://img.blog.csdn.net/20131031091950640?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></strong></p><h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>分三部分：段号、段内页号、页内地址</p><p><img src="http://img.blog.csdn.net/20131031091956234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h4 id="地址映射（逻辑地址—-gt-物理地址）"><a href="#地址映射（逻辑地址—-gt-物理地址）" class="headerlink" title="地址映射（逻辑地址—&gt;物理地址）"></a>地址映射（逻辑地址—&gt;物理地址）</h4><p>³ <strong>逻辑地址</strong>—– &gt;段号、段内页号、业内地址</p><p>³ 段表寄存器— &gt;段表始址</p><p>³ 段号+段表始址—- &gt;页表始址</p><p>³ 页表始址+段内页号—–&gt;存储块号</p><p>³ 块号+页内地址——&gt;<strong>物理地址</strong></p><p> <img src="http://img.blog.csdn.net/20131031092005921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><h4 id="地址变换原理及步骤"><a href="#地址变换原理及步骤" class="headerlink" title="地址变换原理及步骤"></a>地址变换原理及步骤</h4><p><img src="http://img.blog.csdn.net/20131031092012156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZzM3OTI3NTYxNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>请看上图，给出逻辑地址的段号、页号、页内地址，开始进行地址变换：</p><p>1)       在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器</p><p>2)       段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续</p><p>3)       由段号结合段表始址求出页表始址和页表大小</p><p>4)       页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续</p><p>5)       由页表始址结合段内页号求出存储块号</p><p>6)       存储块号&amp;页内地址，即得物理地址</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存。</p><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>常规存储器要求将一个作业全部装入内存方能执行。而虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配方式，则需将作业装入一个连续的内存区域中。所以，虚拟存储器抖毫无例外建立在离散分配管理方式之上。</p><ol><li>请求分页存储管理方式。</li><li>请求分段存储管理方式。</li></ol><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>请求分页系统是建立在基本分页系统的基础上，为了能支持虚拟存储器功能而</p><p>添加了请求调页功能和页面置换功能。</p><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>在请求分页系统中所须要的主要数据结构是<strong>页表</strong>。其基本作用仍然是<strong>将用户地址空间中的逻辑地址变换为内存空间中的物理地址</strong>。因为仅仅将应用程序的一部分调入内存，另一部分仍在盘上，故须在页表中再添加若干项，供程序(数据)在换进、换出时參考。在请求分页系统中的每个页表项例如以下所看到的： </p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-0.png" alt="img"></p><ul><li><p>状态位 P：指示该页是否已调入内存。 供程序访问时参考</p></li><li><p>访问字段 A：记录本页在一段时间内被访问的次数或最近未被访问的时间。 供选择页面换出时参考</p></li><li><p>修改位 M：表示该页在调入内存后是否被修改过。若修改过，则置换该页时需重写该页至外存。 供置换页面时参考</p></li><li><p>外存地址：指出该页在外存上的地址。供调入该页时参考</p></li></ul><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当所要訪问的页面不在内存时，<strong>便产生一缺页中断，请求OS将所缺之页调入内存</strong>。缺页中断作为中断，它们相同须要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的差别，主要表如今以下两个方面：<br>(1) 在指令运行期间产生和处理中断信号。通常，<strong>CPU都是在一条指令运行完后，才检查是否有中断请求到达</strong>。若有，便去响应，否则，继续运行下一条指令。然而，缺页中断是在指令运行期间，发现所要訪问的指令或数据不在内存时所产生和处理的。 </p><p>(2) 一条指令在运行期间，可能产生多次缺页中断。在下图中示出了一个样例。如在运行一条指令COPY A TO B时，可能要产生6次缺页中断，当中指令本身跨了两个页面，A和B又分别各是一个数据块，也都跨了两个页面。基于这些特征，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续运行。 </p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-7.png" alt="img"></p><h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，再为实现虚拟存储器而添加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。下图表示出了请求分页系统中的地址变换过程。在进行地址变换时，首先去检索快表，试图从中找出所要訪问的页。若找到，便改动页表项中的訪问位。对于写指令，还须将改动位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-27-8.png" alt="img"></p><h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3><p>例：一个采用请求分页存储管理的计算机系统，其内存（实存）容量为 256M 字节，虚拟内存容量（给用户的最大地址空间）为 4G 字节，页面大小为 4K 字节，试问：</p><p>实存物理地址应设为多少位？<br>256M = 2^28，所以为28位</p><p>实存中有多少物理块？<br>256M/4K = 64K</p><p>实存中最大块号是多少？<br>64K-1</p><p>虚存地址应设多少位？<br>4G = 2^32，所以为32位</p><p>虚拟地址空间最多可以有多少页？<br>4G/4K = 1M</p><p>页内最大偏移量是多少？ </p><p>4k-1 = 4*1024-1 = 4095</p><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数指能保证进程正常运行所需的最小的物理块数，最小物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。</p><p>采用直接寻址方式，所需的最少物理块数为 2。一块是用于存放指令，另一块用于存放数据。</p><p>间接寻址时，至少要求有三个物理块。 （间接寻址中一些物理块放的是其它物理块的块号）</p><h4 id="物理块的分配策略"><a href="#物理块的分配策略" class="headerlink" title="物理块的分配策略"></a>物理块的分配策略</h4><h5 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h5><p>为每个进程分配固定数目 n 的物理块，在整个运行中都不改变。如出现缺页则从该进程的页面中置换一页。</p><p>每个进程分配多少个物理块难以确定.</p><p>若太少，会频繁地出现缺页中断，降低了系统的吞吐量。</p><p>若太多，内存中驻留的进程数目减少，可能造成 CPU空闲或其它资源空闲的情况。</p><h5 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h5><p>为每个进程分配一定数目的物理块，但 OS 自留一空闲块队列，若发现缺页，则从空闲块队列中分配一空闲块与该进程，并调入缺页于其中。当空闲块队列用完时，OS 才从内存中任选择一页置换。</p><h5 id="可变分配局部置换"><a href="#可变分配局部置换" class="headerlink" title="可变分配局部置换"></a>可变分配局部置换</h5><p>为每个进程分配一定数目的物理块，若发现缺页，则从该进程的页面中置换一页，不会影响其它进程的运行。根据进程缺页率高低，则可增加或减少分配给该进程的物理块。</p><h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><h5 id="预调页策略"><a href="#预调页策略" class="headerlink" title="预调页策略"></a>预调页策略</h5><p>预调页：将预计在不久之后便会被访问的页面预先调入内存。</p><p>进程的页一般存放在外存的一个连续区域中。一次调入若干个相邻的页会比一次调入一页更高效。</p><p>但如果调入的一批页面中的大多数都未被访问，则浪费了内存。</p><h5 id="请求调页策略"><a href="#请求调页策略" class="headerlink" title="请求调页策略"></a>请求调页策略</h5><p>当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。但这种策略每次仅调入一页，须花费较大的系统开销，增加了启动磁盘 I/O 的频率。</p><h5 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h5><p>在请求分页系统中，外存分成了按离散分配方式存放文件的文件区和按连续分配方式存放对换页的对换区。进程发出缺页请求时，从何处将缺页调入内存呢？</p><p>对换区：如果系统有足够的对换区空间，运行前可将与进程相关的文件从文件区复制至对换区，以后缺页时全部从对换区调页。</p><p>文件区：如果系统没有足够的对换区空间，凡是不会被修改的文件，直接从文件区调页，不必回写（换出） 。对可能会修改的文件第一次直接从文件区调页，换出时换至对换区，以后从对换区调页。</p><p>UNIX 方式：凡未运行过的页面均从文件区调页，运行过的页面和换出的页面均从对换区调页。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法（OPT）（理想置换算法）"><a href="#最佳置换算法（OPT）（理想置换算法）" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h4><p>从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 </p><p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：<br>    7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1<br>进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。<br>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td>2</td><td></td><td></td><td></td><td>7</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>4</td><td></td><td></td><td>0</td><td></td><td></td><td>0</td><td></td><td></td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td></td><td></td><td>3</td><td></td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td></td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td></td><td>√</td><td></td></tr></tbody></table><h4 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h4><p>是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 </p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td>2</td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>0</td><td>0</td><td></td><td></td><td>7</td><td>7</td><td>7</td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>1</td><td>1</td><td></td><td></td><td>1</td><td>0</td><td>0</td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>2</td><td></td><td></td><td>2</td><td>2</td><td>1</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。<br>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</p><table><thead><tr><th>访问页面</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>物理块1</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td><td>4</td><td>5</td><td></td><td></td><td>,5’</td><td>5</td><td></td></tr><tr><td>物理块2</td><td></td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td><td>1</td><td></td><td></td><td>3</td><td>3</td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td>4</td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td></tr><tr><td></td><td></td><td>1</td><td>1</td><td>1</td><td></td><td></td><td>5</td><td>5</td><td>5</td><td>5</td><td>4</td><td>4</td></tr><tr><td>物理块2*</td><td></td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td></tr><tr><td>物理块3*</td><td></td><td></td><td>3</td><td>3</td><td></td><td></td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>物理块4*</td><td></td><td></td><td></td><td>4</td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p><strong>注意：内存的页面中“最老“的页面，会被新的网页直接覆盖，而不是“最老“的页面先出队，然后新的网页从队尾入队。</strong></p><h4 id="最近最久未使用（LRU）算法"><a href="#最近最久未使用（LRU）算法" class="headerlink" title="最近最久未使用（LRU）算法"></a>最近最久未使用（LRU）算法</h4><p>这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 </p><p>再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。</p><table><thead><tr><th>访问页面</th><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>0</th><th>1</th><th>7</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>物理块1</td><td>7</td><td>7</td><td>7</td><td>2</td><td></td><td>2</td><td></td><td>4</td><td>4</td><td>4</td><td>0</td><td></td><td></td><td>1</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td></tr><tr><td>物理块2</td><td></td><td>0</td><td>0</td><td>0</td><td></td><td>0</td><td></td><td>0</td><td>0</td><td>3</td><td>3</td><td></td><td></td><td>3</td><td></td><td>0</td><td></td><td>0</td><td></td><td></td></tr><tr><td>物理块3</td><td></td><td></td><td>1</td><td>1</td><td></td><td>3</td><td></td><td>3</td><td>2</td><td>2</td><td>2</td><td></td><td></td><td>2</td><td></td><td>2</td><td></td><td>7</td><td></td><td></td></tr><tr><td>缺页否</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td><td></td></tr></tbody></table><p>实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。<br>***LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。</p><h4 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。<br>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。<br>CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一：</p><ol><li>最近未被访问，也未被修改(u=0, m=0)。</li><li>最近被访问，但未被修改(u=1, m=0)。</li><li>最近未被访问，但被修改(u=0, m=1)。</li><li>最近被访问，被修改(u=1, m=1)。</li></ol><p>算法执行如下操作步骤：</p><ol><li>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。</li><li>如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。</li><li>如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。</li></ol><p>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p><p>例题：</p><p>在5个页框上使用LRU页面替换算法，当页框初始为空时，引用序列为0、1、7、8、6、2、3、7、2、9、8、1、0、2，系统将发生（C）次缺页</p><p>​    A、13            B、12           C、11          D、8</p><p>解析：内存中驻留5个页框：</p><table><thead><tr><th>访问页面</th><th>0</th><th>1</th><th>7</th><th>8</th><th>6</th><th>2</th><th>3</th><th>7</th><th>2</th><th>9</th><th>8</th><th>1</th><th>0</th><th>2</th></tr></thead><tbody><tr><td>页框1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>页框2</td><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>页框3</td><td></td><td></td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>0</td><td>0</td></tr><tr><td>页框4</td><td></td><td></td><td></td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr><td>页框5</td><td></td><td></td><td></td><td></td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>是否缺页</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y(换页)</td><td>Y(换页)</td><td>N</td><td>N</td><td>Y(换页)</td><td>Y(换页)</td><td>Y(换页)</td><td>Y(换页)</td><td>N</td></tr></tbody></table><p> LRU是堆栈类的算法，最后访问的页面放在栈顶，可以得到答案为C。</p><p>编程思路：</p><p>1,用结构体成员记录访问的顺序，换页时选取times最大的那个替换掉。</p><p>struct LRU { int data; </p><p>　　　　　　　int times;};记录访问次序</p><p>struct queue{  LRU *p; int front; int rear</p><p>}Qe;</p><p>(1)队列未满时，依次添加新访问的页面，并Qe.p[i++].times++</p><p>(2)队列满了 a, 新访问的页面在队列中，times设为0，之前在它前面的LRU.times++</p><p>​                b, 新访问的页面不在队列中，需替换掉times最大的页面，并设新页面times=0，对列中其它页面times++</p><p>2,用队列中存放的位置表示最后访问时间（用线性表涉及大量元素移动，用链表好些）</p><p>队列未满时，依次压入；队列满，则查看对列中是否存在，若存在，将其移动到队尾，若不存在，删除队首页面，并在队尾加入新页面。</p><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="页面抖动（颠簸）"><a href="#页面抖动（颠簸）" class="headerlink" title="页面抖动（颠簸）"></a>页面抖动（颠簸）</h3><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p><p>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p><h3 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h3><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p><p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储器管理&quot;&gt;&lt;a href=&quot;#存储器管理&quot; class=&quot;headerlink&quot; title=&quot;存储器管理&quot;&gt;&lt;/a&gt;存储器管理&lt;/h1&gt;&lt;p&gt;首先得声明，在引入虚拟存储器之前，存储器通常是将整个进程所有资源引入内存的。&lt;/p&gt;
&lt;h2 id=&quot;存储器的层次结
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="操作系统" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟存储器" scheme="http://qianyouyou.cn/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
      <category term="分页" scheme="http://qianyouyou.cn/tags/%E5%88%86%E9%A1%B5/"/>
    
      <category term="分段" scheme="http://qianyouyou.cn/tags/%E5%88%86%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>向死而生，知菜而后勇</title>
    <link href="http://qianyouyou.cn/2019/04/24/2019-04-24/"/>
    <id>http://qianyouyou.cn/2019/04/24/2019-04-24/</id>
    <published>2019-04-24T03:46:37.000Z</published>
    <updated>2019-05-08T08:11:38.926Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。</p><p>回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)</p><p>回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起起伏伏，体验感极差。说到经历的话，可以一句话来形容，便是以腾讯起，以腾讯终。当然，不是以腾讯录用而终，而是以被腾讯pass为终QYQ</p><p>这一个月里，虽然各种面试东跑西跑面的身心疲惫，但总的来说还是有收获的，至少让自己认清自己很菜qyq，当然这是开玩笑的啦。首先现在的我已经清楚未来要去的敌方以及要走的路了，而且在其中收获的面试经验是无法替代的。</p><p>还记得三月初腾讯们各种投简历带的我还不明白为什么要找实习便也跟着一起投。还记得第一次收到腾讯的面试通知，既兴奋又恐惧，当时还很稚嫩的我（丢不丢脸啊）收面试官小哥哥的照顾竟然莫名其妙过了。还记得西山居经历四次面试本来以为稳了，结果因为没有什么面试经验导致实习时间上的问题最终被刷，之后好长一段时间恐惧面试，不想面试。直到前两天腾讯正式批二面结束后，状态变为了HR面试，当时那个兴奋与感激啊，结果没过两天就又由HR面试变成了初试（嘿嘿，面试本就是大起大落，大落最差不过从头再来，所以说只要没拿到offer就不存在稳不稳）。不过渐渐的，我也明白了实习的意义。其实当初找实习纯粹是被氛围带起的，经过这么多面试之后，一方面发现自己还有很多方面需要学习与总结，另一方面渐渐也发现其实实不实习都无关紧要，做项目的话自己也可以做嘛，只要自己实力够强。而找实习后反而有点浪费学习时间，反正暂时也找不到，不如静下心来好好学习，自己做项目积累经验吧，为秋招做好准备。毕竟这样就可以做自己想做的产品了（偷笑）</p><p>现在制定计划，并以今天为起点，抓紧学习，之后就不找实习了，直接面向秋招。</p><p>目标：C++，设计模式，Linux网络编程，操作系统，TCP/IP，编译原理，数据库，计算机组成原理。</p><p>重点学习内容：C++，Linux系统编程与网络编程，操作系统，计算机网络，编译原理，数据库。</p><p>项目：聊天室项目，云盘项目，内存池项目，5V5游戏项目</p><p>目前的资源：C++primer，Effictive C++，深入理解计算机系统，图解TCP/IP，图解HTTP，LINUX高性能服务器编程，HeadFirst设计模式，STL源码剖析，编程之美，Linux鸟哥的私房菜，UNIX环境高级编程，计算机网络，计算机操作系统，计算机组成原理等等。</p><p>计划：</p><p>4月末——计算机网络，计算机操作系统，黑马课程复习。</p><p>5月——EffictiveC++，HeadFirst设计模式，Linux高性能服务器编程，计算机网络，编译原理，计算机操作系统，计算机组成原理，黑马课程巩固。</p><p>6月——C++primer，STL源码剖析，深入了解计算机系统，编程之美。</p><p>7月——8月——项目，二遍课程复习</p><p>附上这一个月的心路历程（我的三体的一首词）</p><p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p><p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p><p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p><p>天才如我<br>蠢材如我<br>在梦里醒着<br>世人庸庸碌碌<br>求而不得<br>不多我一个<br>放纵了 颓废了<br>也当消解疑惑<br>笑命运管窥蠡测<br>沉迷过 入魔过 倾塌过<br>又能如何<br>这一杯谢你敬我<br>终将真相挑破<br>暗夜里挣不脱重重枷锁<br>百死也容易<br>难的是苟活<br>尘世中以血肉对撞漩涡<br>谁不是生于毫末<br>偏贪恋天地宏阔<br>第几道轮回都捱过<br>换浮生片刻<br>甘心不甘心<br>说来好似是心魔<br>可我陷了便陷了<br>就执念了生死存亡<br>表象声色<br>神明或虫豸<br>活下的才算幸运儿</p><p>借酒来遮<br>借梦来躲<br>借命来挥霍<br>如人饮水冷暖<br>各有所获<br>谁也别干涉<br>这世界 那世界<br>不过一念之隔<br>五十年等个结果<br>遗忘的 铭记的 美化的<br>也这么过<br>究竟谁是谁寄托<br>那就放下忐忑<br>来路来去处去都还不错<br>虚无如永生<br>年岁算偷得<br>到如今又哪敢贪求更多<br>纵然我生于毫末<br>也看了天地宏阔<br>下一道轮回该如何<br>便由它如何<br>真实里真实<br>虽惋惜不曾窥破<br>总有来者后来者<br>大道不离生死存亡<br>表象声色<br>神明或虫豸<br>时光中颠倒几回合</p><p>你也不必问我<br>这一生这条路值不值得<br>观者谈因果<br>后人论功过<br>横竖我听不见他们评说<br>面目虽扭曲映射<br>看去还不算太丑恶<br>至于鬓角那点斑驳<br>就一笑而过<br>倒也算有幸<br>在命途最后时刻<br>领教太悬殊强弱<br>扑面加身烧熔骨骼、<br>演化烟火<br>若蝉声戛然<br>先蹈此辙、<br>死神裙下客从来多<br>螳螂黄雀你又作哪个<br>宇宙再宏阔<br>真理共微尘一色<br>不都是死路上讨得生活</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。&lt;/p&gt;
&lt;p&gt;回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||)&lt;/p&gt;
&lt;p&gt;回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>进程的描述与控制VS处理机调度与死锁</title>
    <link href="http://qianyouyou.cn/2019/04/22/2019-04-22/"/>
    <id>http://qianyouyou.cn/2019/04/22/2019-04-22/</id>
    <published>2019-04-22T13:20:04.000Z</published>
    <updated>2019-05-18T12:30:34.160Z</updated>
    
    <content type="html"><![CDATA[<p>成也进程，败也进程，不为成败，只为进程。</p><h1 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h1><h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p>每个结点可用来表示一个进程或进程段，乃至一条语句，结点间的有向边则表示两个结点间存在偏序或前趋关系。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22-1.png" alt=""></p><p>例如上图P1与P2之间有前趋关系，所以P1与P2只能顺序执行。再如P2与P3之间没有前趋关系，所以P2与P3可以并发执行。</p><p>说白了就是有向无环图，可以利用拓扑排序进行执行。</p><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><p>简单理解，进程就是程序段+数据段+PCB。</p><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>由于多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并且具有间断性，以及运行结果不可在现性的特征。由此决定了程序是不能参与并发执行的，否则，程序的运行便失去了意义。为了能使程序并发执行，并且对并发执行的程序加以描述和控制，人们引入了进程。</p><p>为使每个并发执行程序（含数据）都能独立运行，在操作系统中加入一个专门的数据结构——进程控制块（Process Control Block，PCB）</p><p>系统利用PCB描述进程的基本情况和活动过程。一般情况下，我们把进程实体简称为进程，所谓创建进程就是创建进程实体中的PCB；撤销进程就是撤销进程的PCB。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机尚顺序执行是所发生的活动。</li><li>进程是具有独立功能的程序在一个数据集合上执行的过程，<strong>它是系统执行资源分配和调度的一个独立单位</strong>。</li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><strong>动态性</strong>：进程是进程实体的执行过程，由创建而生，调度而执行，撤销而亡。进程实体具有生命周期，而程序仅是一组有序命令的集合，存在于某种介质之上，因而是静态的。</li><li><strong>并发性</strong>：多个进程实体同存于内存之中，且能在一段时间同时运行。程序没有PCB，因而不能并发。</li><li><strong>独立性</strong>：进程实体是一个能独立运行，独立获得资源，独立接受调度的基本单位。而程序没有PCB，固不能执行以上操作。</li><li><strong>异步性</strong>：进程是按异步方式运行的，即按各自独立的、不可预知的速度推进，因而结果不可再现。为此，OS中引入进程的概念，并配置相应的同步机制。</li></ul><h3 id="状态及转换"><a href="#状态及转换" class="headerlink" title="状态及转换"></a>状态及转换</h3><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.png" alt=""></p><h4 id="三基态："><a href="#三基态：" class="headerlink" title="三基态："></a>三基态：</h4><ul><li><strong>就绪状态</strong>：进程已处于准备好运行的状态，只差CPU，在就绪队列等待调度。</li><li><strong>执行状态</strong>：进程已获得CPU，并立即执行。</li><li><strong>阻塞状态</strong>：正在运行的进程由于发生某种事件（I/O请求，申请缓冲区失败等）暂时无法继续执行，而让受阻进程处于暂停状态。进入阻塞队列。阻塞时进程自身的主动行为。</li></ul><h4 id="创建与终止状态："><a href="#创建与终止状态：" class="headerlink" title="创建与终止状态："></a>创建与终止状态：</h4><ul><li><strong>创建状态</strong>：申请空白PCB，并向PCB填写控制和管理进程的信息，然后分配资源，最后转入就绪队列中。</li><li><strong>终止状态</strong>：等待操作系统善后处理，然后PCB清零，返还系统。</li></ul><h4 id="挂起状态："><a href="#挂起状态：" class="headerlink" title="挂起状态："></a>挂起状态：</h4><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-04-22.jpg" alt=""></p><p>当操作作用于某个进程时，该进程处于静止状态。</p><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><ol><li>终端用户需要。例如运行时改bug。</li><li>父进程请求。</li><li>符合调节需要。</li><li>操作系统需要。例如检查运行情况。</li></ol><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><h4 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h4><ol><li><strong>进程描述符</strong>：进程标识符用于唯一标识进程。</li><li><strong>处理机状态</strong>：进程切换时保留现场以及现场恢复。</li><li><strong>进程调度信息</strong>：进程状态及相关进程调度信息。</li><li><strong>进程控制信息</strong>：用于进程控制所需信息。</li></ol><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制一般由OS原语实现。</p><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><ol><li>支撑功能<ul><li>中断处理。</li><li>始终处理。</li><li>原语操作。原语由若干指令组成，用于完成一定功能的过程。原子操作，一个操作中所有行动要么全做，要么不做。</li></ul></li><li>资源管理功能<ul><li>进程管理。</li><li>存储器管理。</li><li>设备管理。</li></ul></li></ol><h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p>创建原语：Creat</p><p>终止原语：Holt</p><h3 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h3><p>阻塞原语：block</p><p>唤醒原语：wakeup</p><h3 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h3><p>挂起原语：suspend</p><p>激活原语：active</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><ol><li>关中断</li><li>利用Test-and-Set指令实现互斥</li><li>利用Swap指令实现进程互斥</li></ol><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ol><li>整型信号量</li><li>记录型信号量</li><li>AND型信号量</li><li>信号量集</li></ol><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 </p><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a>经典进程同步问题</h3><p>生产者-消费者问题</p><p>读者-写者问题</p><p>哲学家进餐问题</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol><li><p>共享存储器系统</p></li><li><p>管道（pipe）通信系统</p></li><li><p>消息传递系统</p><ul><li><p>消息传递的实际功能以一对原语的形式提供：</p><ul><li>send(destination,message)</li><li>receive(source,message)</li></ul><p>这是进程间进程消息传递所需要的最小操作集。</p><p>一个进程以消息的形式给另一个指定的目标进程发送消息；</p><p>进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</p></li></ul></li><li><p>客户机-服务机系统</p><ul><li>套接字socket</li></ul></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>作为调度和分派的基本单位。</p><p>每个线程有一个线程控制块TCB。</p><h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p><h3 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h3><p><strong>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：</strong></p><p>高级调度：(High-Level Scheduling)又称为作业调度，它决定把外存上后备作业调入内存运行；</p><p>低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；</p><p>中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。把不能正常运行的进程调至外存等待。</p><h4 id="处理机调度算法"><a href="#处理机调度算法" class="headerlink" title="处理机调度算法"></a>处理机调度算法</h4><p>CPU利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间)</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>周转时间Ti = 完成时间 - 到达时间</p><p>平均周转时间T = 1/n( T1 + …… + Ti + …… + Tn )</p><p>带权周转时间为周转时间/运行时间（越小越好）</p><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>响应时间快，均衡性好。</p><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>考虑截至时间，提高可预测性。</p><h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><h4 id="作业（Job）"><a href="#作业（Job）" class="headerlink" title="作业（Job）"></a>作业（Job）</h4><p>程序的集合+数据的集合+作业说明书+JCB。</p><p>三个状态：后备状态，运行状态，收容状态。</p><p>三个阶段：收容阶段（创建JCB），运行阶段，完成阶段（回收JCB）。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><ol><li>接纳多少作业</li><li>接纳哪些作业</li></ol><h4 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h4><h5 id="先来先服务算法（first-come-first-served，FCFS）"><a href="#先来先服务算法（first-come-first-served，FCFS）" class="headerlink" title="先来先服务算法（first-come first-served，FCFS）"></a>先来先服务算法（first-come first-served，FCFS）</h5><p>系统按照作业到达的优先顺序调度。</p><p>不利于短作业。</p><h5 id="短作业优先算法（short-job-first，SJF）"><a href="#短作业优先算法（short-job-first，SJF）" class="headerlink" title="短作业优先算法（short job first，SJF）"></a>短作业优先算法（short job first，SJF）</h5><p>系统以作业长短为优先级。</p><p>不利于长作业，容易出现进程饥饿现象。</p><h5 id="优先级调度算法（priority-scheduling-algorithm，PSA）"><a href="#优先级调度算法（priority-scheduling-algorithm，PSA）" class="headerlink" title="优先级调度算法（priority-scheduling algorithm，PSA）"></a>优先级调度算法（priority-scheduling algorithm，PSA）</h5><p>根据作业紧迫程度，由外界赋予优先级。</p><h5 id="高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）"><a href="#高响应比有限调度算法（Highest-Rseponse-Ratio-Next，HRRN）" class="headerlink" title="高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）"></a>高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）</h5><p>动态优先级，根据长短赋初值，根据等待时间加权。作业越短，初值越大，等待时间越长，加权越大。</p><p>Rp = 响应时间/要求服务时间</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><h5 id="剥夺方式"><a href="#剥夺方式" class="headerlink" title="剥夺方式"></a>剥夺方式</h5><p>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。</p><h5 id="非剥夺方式"><a href="#非剥夺方式" class="headerlink" title="非剥夺方式"></a>非剥夺方式</h5><p>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。</p><h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><ol><li>保存处理机现场信息。</li><li>按某种算法选取进程。</li><li>把处理器分配给进程。</li></ol><h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><p>进程调度也称为低级调度，它所调度的对象为进程（或者内核级线程），而进程调度算法主要有以下几种：</p><h5 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h5><p>它的原理通俗来讲就是队列中每一个进程都获得了一定的执行时间，从几ms到几百ms，当一个执行时间结束，计时器会发出一个信号，此时正在执行的进程将被中断，同时此进程将被放在队列的末尾，然后执行这时候的队列的队首进程，因此队列中每一个进程都将获得一定时间执行。</p><h5 id="先来先服务调度算法（FCFS）"><a href="#先来先服务调度算法（FCFS）" class="headerlink" title="先来先服务调度算法（FCFS）"></a>先来先服务调度算法（FCFS）</h5><p>先来先服务调度算法是一种最简单的调度算法，可用于作业调度，也可用于进程调度。</p><h5 id="短作业优先调度算法（SJ-P-F）"><a href="#短作业优先调度算法（SJ-P-F）" class="headerlink" title="短作业优先调度算法（SJ(P)F）"></a>短作业优先调度算法（SJ(P)F）</h5><p>短作业（进程）优先调度算法是指短作业或者短进程的优先调度算法，它们分别作用于作业调度和进程调度，它是先来先服务调度算法的一种优化版本。</p><h5 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h5><p>为了解决在短作业优先调度算法中进程的紧迫程度问题，我们引入高优先权优先调度算法，高优先权调度算法的方法也很简单，就是在队列中选取优先权最高的进程装入内存，该算法又分为以下两类：</p><p>①非抢占式优先权算法<br>如果系统已经分配好一个优先权最高的进程，它会一直被执行，直到结束或者因为某事件放弃执行，此时系统才会选择另外一个优先权最高的进程，这种调度算法主要被用于批处理系统中。</p><p>②抢占式优先权算法<br>系统在队列中把一个优先权最高的进程执行，但如果在执行中又出现一个优先权更高的进程，此时当前进程被停止，换入另外一个优先权更高的进程，这种调度算法主要被用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统中。</p><p>优先权的类型：</p><p>优先权的类型被分为静态优先权和动态优先权。</p><p>静态优先权就是给定某个整形数字来表示进程的优先级，数字越小表示优先级越高，数字越大，进程优先级越低。</p><p>动态优先权随着进程的创建而被创建，可以随着进程的推进或者等待时间而变化。</p><h5 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h5><p>进程就绪队列由一个拆成多个，不同类型进程分配不同就绪队列，不同就绪队列采用不同算法。一个就绪队列可以设置不同优先级，不同就绪队列本身也可设优先级。</p><p>系统根据不同的用户选用不同的调度策略。</p><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p>设置多个就绪队列，每个队列的优先级逐渐降低，同时每个队列的执行时间也各不相同，优先级越高的队列，执行时间越短，优先级越低的队列，执行时间越长。<br>当一个进程进入内存后，首先进入第一个队列的末尾，按照先来先服务的调度算法进行调度，如果在第一个队列的执行时间内未执行完成，此时把此进程放入第二个队列的末尾，按照之前的方法进行执行，直到在某一个队列的队首执行完成。</p><p>当第一个队列全部执行完成，此时系统才会执行第二个队列，但是如果此时又有新的进程进入，此时执行完毕这个时间段，立刻把此进程分配给新的作业。</p><h5 id="根据公平原则的调度算法"><a href="#根据公平原则的调度算法" class="headerlink" title="根据公平原则的调度算法"></a>根据公平原则的调度算法</h5><p>公平分配每个进程相同的处理机时间，或按进程比例公平分配用户相同的处理机时间。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="锁与信号量"><a href="#锁与信号量" class="headerlink" title="锁与信号量"></a>锁与信号量</h3><p>锁强调于资源，信号量强调于执行次序。</p><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>重用性资源与消耗性资源</p><p>可抢占性资源与不可抢占资源</p><h3 id="死锁起因"><a href="#死锁起因" class="headerlink" title="死锁起因"></a>死锁起因</h3><p>源于多个进程对资源的争夺，不仅对<strong>不可抢占资源</strong>金进行争夺时容易产生死锁，而且对<strong>消耗性资源</strong>抢夺也会产生死锁。还有就是进程推进不当引起死锁。</p><h3 id="死锁产生必要条件"><a href="#死锁产生必要条件" class="headerlink" title="死锁产生必要条件"></a>死锁产生必要条件</h3><ol><li>互斥条件（不能破坏该条件）</li><li>请求与保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ol><h3 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h3><p>以下四种方法从上往下防范程度逐渐减弱，但资源利用率与并发程度逐渐提高。</p><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><h5 id="破坏”请求保持条件“"><a href="#破坏”请求保持条件“" class="headerlink" title="破坏”请求保持条件“"></a>破坏”请求保持条件“</h5><ol><li>一次性分配所有需要的资源。</li><li>用到时再调用资源，用完即释放资源。</li></ol><h5 id="破坏”不可抢占条件“"><a href="#破坏”不可抢占条件“" class="headerlink" title="破坏”不可抢占条件“"></a>破坏”不可抢占条件“</h5><p>调用资源时如果资源被占用，则必须释放已有所有资源，用时再调用。</p><h5 id="破坏”循环等待条件“"><a href="#破坏”循环等待条件“" class="headerlink" title="破坏”循环等待条件“"></a>破坏”循环等待条件“</h5><p>先给进程编号并排序，再按照顺序分配资源。</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><strong>银行家算法的数据结构</strong><br>可利用资源向量（Available）：系统还可以分配的资源</p><p>最大需求矩阵（Max）：进程的最大资源需要</p><p>分配矩阵（Alloction）：进程已经获得的资源</p><p>需求矩阵（Need）：进程还需要获得的资源</p><p><strong>银行家算法</strong></p><p>假设 P1 进程提出请求 K 个资源</p><p>如果 K &lt;= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源</p><p>如果 K &lt;= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 </p><p>Available系统试探分配资源，并修改下列数据</p><p>Available = Available - K；表示分配给 P1 K 个资源后，还剩多少系统可分配资源</p><p>Allocation = Allocation + K；表示 P1 已经获得的资源</p><p>Need = Need - K；表示进程 P1 还需要获得的资源</p><p>此时系统执行安全性算法，计算进程是否处于安全性状态</p><p>PS：此时是执行的试探分配，为的是检查进程是否处于安全状态，不处于则试探分配作废</p><p><strong>安全性算法</strong></p><p>安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态</p><p>两个向量</p><p>工作向量（Work）：系统提供给进程的各类资源数目</p><p>Finish：表示系统是否有足够的资源分配给进程，这是一个布尔值。初始化为 false。</p><p><strong>算法描述</strong></p><p>在进程集合中找到下述条件的进程</p><p>Finish[ i ] = false;</p><p>Need &lt;= Work</p><p>进程执行完毕</p><p>Work = Work + Allocation</p><p>Finish [ i ] = true</p><p>返回继续执行 1 ，寻找其他的进程分配资源</p><p>若所有的 Finish 为 true 则安全</p><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>资源分配图。</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>杀死进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;成也进程，败也进程，不为成败，只为进程。&lt;/p&gt;
&lt;h1 id=&quot;进程的描述与控制&quot;&gt;&lt;a href=&quot;#进程的描述与控制&quot; class=&quot;headerlink&quot; title=&quot;进程的描述与控制&quot;&gt;&lt;/a&gt;进程的描述与控制&lt;/h1&gt;&lt;h2 id=&quot;前驱图&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="操作系统" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://qianyouyou.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://qianyouyou.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="死锁" scheme="http://qianyouyou.cn/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="进程调度" scheme="http://qianyouyou.cn/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>[转]HashMap实现原理及源码分析</title>
    <link href="http://qianyouyou.cn/2019/04/20/2019-04-20-1/"/>
    <id>http://qianyouyou.cn/2019/04/20/2019-04-20-1/</id>
    <published>2019-04-20T11:55:55.000Z</published>
    <updated>2019-04-27T15:43:10.593Z</updated>
    
    <content type="html"><![CDATA[<p>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p><h1 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h1><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p>　　<strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p><p>　　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p><p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113180447499-1953916974.png" alt="img"></p><p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><p>　　<strong>哈希冲突</strong></p><p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p><h1 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h1><p>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。</span><br><span class="line">transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p> Entry是HashMap中的一个静态内部类。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构</span><br><span class="line">    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates new entry.</span><br><span class="line">     */</span><br><span class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 所以，HashMap的整体结构如下</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161113235348670-746615111.png" alt="img">　　</p><p>　　<strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong></p><p>其他几个重要字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//实际存储的key-value键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line">//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到</span><br><span class="line">int threshold;</span><br><span class="line">//负载因子，代表了table的填充度有多少，默认是0.75</span><br><span class="line">final float loadFactor;</span><br><span class="line">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span><br><span class="line">transient int modCount;</span><br></pre></td></tr></table></figure><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>我们看下其中一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">　　　　　</span><br><span class="line">        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong></p><p>　　OK,接下来我们来看看put操作的实现吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">   //如果key为null，存储位置为table[0]或table[0]的冲突链上</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀</span><br><span class="line">    int i = indexFor(hash, table.length);//获取在table中的实际位置</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span><br><span class="line">    addEntry(hash, key, value, i);//新增一个entry</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先来看看inflateTable这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂</span><br><span class="line">        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static int roundUpToPowerOf2(int number) &#123;</span><br><span class="line">       // assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br><span class="line">       return number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">               ? MAXIMUM_CAPACITY</span><br><span class="line">               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;</span><br><span class="line">   &#125;[​](javascript:void(0);)</span><br></pre></td></tr></table></figure><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p><p>hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span><br><span class="line">final int hash(Object k) &#123;</span><br><span class="line">        int h = hashSeed;</span><br><span class="line">        if (0 != h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">            return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　/**</span><br><span class="line"> * 返回数组下标</span><br><span class="line"> */</span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    1  0  0  1  0</span><br><span class="line">&amp;   0  1  1  1  1</span><br><span class="line">__________________</span><br><span class="line">    0  0  0  1  0    = 2</span><br></pre></td></tr></table></figure><p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p><p>所以最终存储位置的确定流程是这样的：</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115133556388-1098209938.png" alt="img"></p><p>再来看看addEntry的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</span><br><span class="line">            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容</span><br><span class="line">            hash = (null != key) ? hash(key) : 0;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">       Entry[] oldTable = table;</span><br><span class="line">       int oldCapacity = oldTable.length;</span><br><span class="line">       if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">       transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity = newTable.length;</span><br><span class="line">　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null != e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity);</span><br><span class="line">　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p>　　<img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115215812138-679881037.png" alt="img"></p><p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001404732-625340289.png" alt="img"></p><p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161116001717560-1455096254.png" alt="img"></p><p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><p>get方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">　　　　 //如果key为null,则直接去table[0]处去检索即可。</span><br><span class="line">       if (key == null)</span><br><span class="line">           return getForNullKey();</span><br><span class="line">       Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">       return null == entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">            </span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //通过key的hashcode值计算hash值</span><br><span class="line">        int hash = (key == null) ? 0 : hash(key);</span><br><span class="line">        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != null;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            if (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return e;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h1><p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by chengxiao on 2016/11/15.</span><br><span class="line"> */</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    private static class Person&#123;</span><br><span class="line">        int idCard;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Person(int idCard, String name) &#123;</span><br><span class="line">            this.idCard = idCard;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (this == o) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (o == null || getClass() != o.getClass())&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Person person = (Person) o;</span><br><span class="line">            //两个对象是否等值，通过idCard来确定</span><br><span class="line">            return this.idCard == person.idCard;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();</span><br><span class="line">        Person person = new Person(1234,&quot;乔峰&quot;);</span><br><span class="line">        //put到hashmap中去</span><br><span class="line">        map.put(person,&quot;天龙八部&quot;);</span><br><span class="line">        //get取出，从逻辑上讲应该能输出“天龙八部”</span><br><span class="line">        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：null</span><br></pre></td></tr></table></figure><p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
      <category term="HashMap" scheme="http://qianyouyou.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>C++常用知识点STL总结</title>
    <link href="http://qianyouyou.cn/2019/04/20/2019-04-20/"/>
    <id>http://qianyouyou.cn/2019/04/20/2019-04-20/</id>
    <published>2019-04-20T08:33:45.000Z</published>
    <updated>2019-04-27T15:42:33.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><h2 id="六大组件简介"><a href="#六大组件简介" class="headerlink" title="六大组件简介"></a>六大组件简介</h2><p>STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><p><strong>容器：</strong>各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</p><p><strong>算法：</strong>各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</p><p><strong>迭代器：</strong>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</p><p><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</p><p><strong>适配器：</strong>一种用来修饰容器或者仿函数或迭代器接口的东西。</p><p><strong>空间配置器：</strong>负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</p><p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。</p><h2 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h2><p>STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p><p>STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作</p><p>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。</p><p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><ul><li><p><strong>高可重用性</strong>：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p></li><li><p><strong>高性能</strong>：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。</p></li><li><p><strong>高移植性</strong>：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。</p></li></ul><h1 id="STL常用三大组件"><a href="#STL常用三大组件" class="headerlink" title="STL常用三大组件"></a>STL常用三大组件</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h3><p>序列式容器强调值的排序，序列式容器中的<strong>每个元素均有固定的位置</strong>，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。</p><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间<strong>没有严格的物理上的顺序关系</strong>，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="质变算法"><a href="#质变算法" class="headerlink" title="质变算法"></a>质变算法</h3><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。</p><h3 id="非质变算法"><a href="#非质变算法" class="headerlink" title="非质变算法"></a>非质变算法</h3><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等中会更改。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>提供一种方法，使之能够<strong>依序寻访某个容器所含的各个元素</strong>，而又无需暴露该容器的内部表示方式。</p><p>迭代器的种类:</p><table><thead><tr><th>输入迭代器</th><th>提供对数据的只读访问</th><th>只读，支持++、==、！=</th></tr></thead><tbody><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//STL 中的容器 算法 迭代器</span><br><span class="line">void test01()&#123;</span><br><span class="line">vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组</span><br><span class="line">v.push_back(1); //vector 容器提供的插入数据的方法</span><br><span class="line">v.push_back(5);</span><br><span class="line">v.push_back(3);</span><br><span class="line">v.push_back(7);</span><br><span class="line">//迭代器</span><br><span class="line">vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span><br><span class="line">vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//算法 count 算法 用于统计元素的个数</span><br><span class="line">int n = count(pStart, pEnd, 5);</span><br><span class="line">cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span><br><span class="line">class Teacher</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Teacher(int age) :age(age)&#123;&#125;;</span><br><span class="line">~Teacher()&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line">vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器</span><br><span class="line">Teacher t1(10), t2(20), t3(30);</span><br><span class="line">v.push_back(t1);</span><br><span class="line">v.push_back(t2);</span><br><span class="line">v.push_back(t3);</span><br><span class="line">vector&lt;Teacher&gt;::iterator pStart = v.begin();</span><br><span class="line">vector&lt;Teacher&gt;::iterator pEnd = v.end();</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//存储 Teacher 类型指针</span><br><span class="line">void test03()&#123;</span><br><span class="line">vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针</span><br><span class="line">Teacher* t1 = new Teacher(10);</span><br><span class="line">Teacher* t2 = new Teacher(20);</span><br><span class="line">Teacher* t3 = new Teacher(30);</span><br><span class="line">v.push_back(t1);</span><br><span class="line">v.push_back(t2);</span><br><span class="line">v.push_back(t3);</span><br><span class="line">//拿到容器迭代器</span><br><span class="line">vector&lt;Teacher*&gt;::iterator pStart = v.begin();</span><br><span class="line">vector&lt;Teacher*&gt;::iterator pEnd = v.end();</span><br><span class="line">//通过迭代器遍历</span><br><span class="line">while (pStart != pEnd)&#123;</span><br><span class="line">cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//容器嵌套容器 难点(不理解，可以跳过)</span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt; vector&lt;int&gt; &gt; v;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5;i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i * 10);</span><br><span class="line">v3.push_back(i * 100);</span><br><span class="line">&#125;</span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line"></span><br><span class="line">for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">//test01();</span><br><span class="line">//test02();</span><br><span class="line">//test03();</span><br><span class="line">test04();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><ul><li><strong>String和char*</strong>：<ul><li>Char*是一个指针，String是一个类。</li><li>string封装了char*，管理这个字符串，是一个char*型的容器。</li></ul></li><li>String封装了很多实用的成员方法：<ul><li>查找find，拷贝copy，删除delete，替换replace，插入insert。</li></ul></li><li>不用考虑内存释放和越界：<ul><li>string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li></ul></li></ul><h3 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string();//创建一个空的字符串 例如: string str;      </span><br><span class="line">string(const string&amp; str);//使用一个string对象初始化另一个string对象</span><br><span class="line">string(const string&amp; str, size_t pos, size_t n);//使用一个string对象的pos位及后n位初始化另一个对象</span><br><span class="line">string(const string&amp; str, size_t n);//使用一个string对象的前n位初始化另一个对象</span><br><span class="line">string(const char* s);//使用字符串s初始化</span><br><span class="line">string(size_t n, char c);//使用n个字符c初始化</span><br></pre></td></tr></table></figure><h3 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串</span><br><span class="line">string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; operator=(char c);//字符赋值给当前的字符串</span><br><span class="line">string&amp; assign(const char *s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串</span><br><span class="line">string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串</span><br><span class="line">string&amp; assign(int n, char c);//用n个字符c赋给当前字符串</span><br><span class="line">string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串</span><br></pre></td></tr></table></figure><h3 id="string获取字符操作"><a href="#string获取字符操作" class="headerlink" title="string获取字符操作"></a>string获取字符操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[](int n);//通过[]方式取字符</span><br><span class="line">char&amp; at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure><h3 id="string拼接操作"><a href="#string拼接操作" class="headerlink" title="string拼接操作"></a>string拼接操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator+=(const string&amp; str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char* str);//重载+=操作符</span><br><span class="line">string&amp; operator+=(const char c);//重载+=操作符</span><br><span class="line">string&amp; append(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line">string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(const string &amp;s);//同operator+=()</span><br><span class="line">string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span><br><span class="line">string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c</span><br></pre></td></tr></table></figure><h3 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos = 0) const;  //查找s第一次出现位置,从pos开始查找</span><br><span class="line">int find(const char* s, int pos, int n) const;  //从pos位置查找s的前n个字符第一次位置</span><br><span class="line">int find(const char c, int pos = 0) const;  //查找字符c第一次出现位置</span><br><span class="line">int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找</span><br><span class="line">int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置</span><br><span class="line">int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置</span><br><span class="line">string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str</span><br><span class="line">string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s</span><br></pre></td></tr></table></figure><h3 id="string比较操作"><a href="#string比较操作" class="headerlink" title="string比较操作"></a>string比较操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。</span><br><span class="line">比较区分大小写，比较时参考字典顺序，排越前面的越小。</span><br><span class="line">大写的A比小写的a小。</span><br><span class="line">*/</span><br><span class="line">int compare(const string &amp;s) const;//与字符串s比较</span><br><span class="line">int compare(const char *s) const;//与字符串s比较</span><br></pre></td></tr></table></figure><h3 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure><h3 id="string插入和删除"><a href="#string插入和删除" class="headerlink" title="string插入和删除"></a>string插入和删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string&amp; insert(int pos, const char* s); //插入字符串</span><br><span class="line">string&amp; insert(int pos, const string&amp; str); //插入字符串</span><br><span class="line">string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c</span><br><span class="line">string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符</span><br></pre></td></tr></table></figure><h3 id="string和c-type转换"><a href="#string和c-type转换" class="headerlink" title="string和c-type转换"></a>string和c-type转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//string 转 char*</span><br><span class="line">string str = &quot;itcast&quot;;</span><br><span class="line">const char* cstr = str.c_str();</span><br><span class="line">//char* 转 string </span><br><span class="line">char* s = &quot;itcast&quot;;</span><br><span class="line">string str(s);</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。</p><p>通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;abcdefg&quot;;</span><br><span class="line">char&amp; a = s[2];</span><br><span class="line">char&amp; b = s[3];</span><br><span class="line"></span><br><span class="line">a = &apos;1&apos;;</span><br><span class="line">b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = &quot;pppppppppppppppppppppppp&quot;;</span><br><span class="line"></span><br><span class="line">//a = &apos;1&apos;;</span><br><span class="line">//b = &apos;2&apos;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ab12efg</span><br><span class="line">0x6dfed4</span><br><span class="line">pppppppppppppppppppppppp</span><br><span class="line">0x1816b0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><h3 id="vector与Array数组"><a href="#vector与Array数组" class="headerlink" title="vector与Array数组"></a>vector与Array数组</h3><p>Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p><p>Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-vector_1.png" alt=""></p><h3 id="vector迭代器"><a href="#vector迭代器" class="headerlink" title="vector迭代器"></a>vector迭代器</h3><p>Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，所以vector提供的是随机访问迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector的数据结构"><a href="#vector的数据结构" class="headerlink" title="vector的数据结构"></a><strong>vector的数据结构</strong></h3><p>Vector所采用线性连续空间，它以两个迭代器Myfirst和Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。</p><p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这便是<strong>容量</strong>的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是分配一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数</span><br><span class="line">vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。</span><br><span class="line">vector(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">vector(const vector &amp;vec);//拷贝构造函数。</span><br><span class="line"></span><br><span class="line">//例子 使用第二个构造函数 我们可以...</span><br><span class="line">int arr[] = &#123;2,3,4,1,9&#125;;</span><br><span class="line">vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int));</span><br></pre></td></tr></table></figure><h4 id="vector常用赋值操作"><a href="#vector常用赋值操作" class="headerlink" title="vector常用赋值操作"></a>vector常用赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">vector&amp; operator=(const vector  &amp;vec);//重载等号操作符</span><br><span class="line">swap(vec);// 将vec与本身的元素互换。</span><br></pre></td></tr></table></figure><h4 id="vector大小操作"><a href="#vector大小操作" class="headerlink" title="vector大小操作"></a>vector大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。</span><br><span class="line">capacity();//容器的容量</span><br><span class="line">reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。</span><br></pre></td></tr></table></figure><h4 id="vector数据存取操作"><a href="#vector数据存取操作" class="headerlink" title="vector数据存取操作"></a>vector数据存取操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</span><br><span class="line">operator[];//返回索引idx所指的数据，越界时，运行直接报错</span><br><span class="line">front();//返回容器中第一个数据元素</span><br><span class="line">back();//返回容器中最后一个数据元素</span><br></pre></td></tr></table></figure><h4 id="vector插入和删除操作"><a href="#vector插入和删除操作" class="headerlink" title="vector插入和删除操作"></a>vector插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.</span><br><span class="line">push_back(ele); //尾部插入元素ele</span><br><span class="line">pop_back();//删除最后一个元素</span><br><span class="line">erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素</span><br><span class="line">erase(const_iterator pos);//删除迭代器指向的元素</span><br><span class="line">clear();//删除容器中所有元素</span><br></pre></td></tr></table></figure><h3 id="巧用swap收缩内存空间"><a href="#巧用swap收缩内存空间" class="headerlink" title="巧用swap收缩内存空间"></a>巧用swap收缩内存空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//此时 通过resize改变容器大小</span><br><span class="line">v.resize(10);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//容量没有改变</span><br><span class="line">vector&lt;int&gt;(v).swap(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reserve预留空间"><a href="#reserve预留空间" class="headerlink" title="reserve预留空间"></a>reserve预留空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">//预先开辟空间</span><br><span class="line">v.reserve(100000);</span><br><span class="line"></span><br><span class="line">int* pStart = NULL;</span><br><span class="line">int count = 0;</span><br><span class="line">for (int i = 0; i &lt; 100000;i ++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">if (pStart != &amp;v[0])&#123;</span><br><span class="line">pStart = &amp;v[0];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h2><h3 id="deque与vector"><a href="#deque与vector" class="headerlink" title="deque与vector"></a>deque与vector</h3><p>Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能.</p><p>虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque.</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_1.png" alt=""></p><h3 id="deque容器实现原理"><a href="#deque容器实现原理" class="headerlink" title="deque容器实现原理"></a><strong>deque容器实现原理</strong></h3><p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p><p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p><p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p><p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-deque_2.png" alt=""></p><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;T&gt; deqT;//默认构造形式</span><br><span class="line">deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">deque(n, elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">deque(const deque &amp;deq);//拷贝构造函数。</span><br></pre></td></tr></table></figure><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">deque&amp; operator=(const deque &amp;deq); //重载等号操作符 </span><br><span class="line">swap(deq);// 将deq与本身的元素互换</span><br></pre></td></tr></table></figure><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.size();//返回容器中元素的个数</span><br><span class="line">deque.empty();//判断容器是否为空</span><br><span class="line">deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h4 id="deque双端插入和删除操作"><a href="#deque双端插入和删除操作" class="headerlink" title="deque双端插入和删除操作"></a>deque双端插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);//在容器尾部添加一个数据</span><br><span class="line">push_front(elem);//在容器头部插入一个数据</span><br><span class="line">pop_back();//删除容器最后一个数据</span><br><span class="line">pop_front();//删除容器第一个数据</span><br></pre></td></tr></table></figure><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。</span><br><span class="line">operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</span><br><span class="line">front();//返回第一个数据。</span><br><span class="line">back();//返回最后一个数据</span><br></pre></td></tr></table></figure><h4 id="deque插入操作"><a href="#deque插入操作" class="headerlink" title="deque插入操作"></a>deque插入操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br></pre></td></tr></table></figure><h4 id="deque删除操作"><a href="#deque删除操作" class="headerlink" title="deque删除操作"></a>deque删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br></pre></td></tr></table></figure><h2 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h2><p>stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p><p>有元素推入栈的操作称为:push,将元素推出stack的操作称为pop.<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-stack_1.png" alt=""></p><h3 id="stack迭代器"><a href="#stack迭代器" class="headerlink" title="stack迭代器"></a>stack迭代器</h3><p>Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。</p><h3 id="stack常用API"><a href="#stack常用API" class="headerlink" title="stack常用API"></a><strong>stack常用API</strong></h3><h4 id="stack构造函数"><a href="#stack构造函数" class="headerlink" title="stack构造函数"></a>stack构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： </span><br><span class="line">stack(const stack &amp;stk);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="stack赋值操作"><a href="#stack赋值操作" class="headerlink" title="stack赋值操作"></a>stack赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&amp; operator=(const stack &amp;stk);//重载等号操作符</span><br></pre></td></tr></table></figure><h4 id="stack数据存取操作"><a href="#stack数据存取操作" class="headerlink" title="stack数据存取操作"></a>stack数据存取操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push(elem);//向栈顶添加元素</span><br><span class="line">pop();//从栈顶移除第一个元素</span><br><span class="line">top();//返回栈顶元素</span><br></pre></td></tr></table></figure><h4 id="stack大小操作"><a href="#stack大小操作" class="headerlink" title="stack大小操作"></a>stack大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断堆栈是否为空</span><br><span class="line">size();//返回堆栈的大小</span><br></pre></td></tr></table></figure><h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><p>Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。<img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-queue_1.png" alt=""></p><h3 id="queue迭代器"><a href="#queue迭代器" class="headerlink" title="queue迭代器"></a>queue迭代器</h3><p>Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。</p><h3 id="queue常用API"><a href="#queue常用API" class="headerlink" title="queue常用API"></a>queue常用API</h3><h4 id="queue构造函数"><a href="#queue构造函数" class="headerlink" title="queue构造函数"></a>queue构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：</span><br><span class="line">queue(const queue &amp;que);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="queue存取、插入和删除操作"><a href="#queue存取、插入和删除操作" class="headerlink" title="queue存取、插入和删除操作"></a>queue存取、插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push(elem);//往队尾添加元素</span><br><span class="line">pop();//从队头移除第一个元素</span><br><span class="line">back();//返回最后一个元素</span><br><span class="line">front();//返回第一个元素</span><br></pre></td></tr></table></figure><h4 id="queue赋值操作"><a href="#queue赋值操作" class="headerlink" title="queue赋值操作"></a>queue赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&amp; operator=(const queue &amp;que);//重载等号操作符</span><br></pre></td></tr></table></figure><h4 id="queue大小操作"><a href="#queue大小操作" class="headerlink" title="queue大小操作"></a>queue大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断队列是否为空</span><br><span class="line">size();//返回队列的大小</span><br></pre></td></tr></table></figure><h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><p>List容器是一个双向链表。</p><p><img src="https://qianyouyou-1258651414.cos.ap-chengdu.myqcloud.com/img/19-4-20-list_1.png" alt=""></p><p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出。</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。</li><li>链表灵活，但是空间和时间额外耗费较大。</li></ul><h3 id="list迭代器"><a href="#list迭代器" class="headerlink" title="list迭代器"></a>list迭代器</h3><p>由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators.</p><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p><h3 id="list容器的数据结构"><a href="#list容器的数据结构" class="headerlink" title="list容器的数据结构"></a><strong>list容器的数据结构</strong></h3><p>list容器不仅是一个双向链表，而且还是一个循环的双向链表。</p><h3 id="list常用API"><a href="#list常用API" class="headerlink" title="list常用API"></a><strong>list常用API</strong></h3><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：</span><br><span class="line">list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。</span><br><span class="line">list(n,elem);//构造函数将n个elem拷贝给本身。</span><br><span class="line">list(const list &amp;lst);//拷贝构造函数。</span><br></pre></td></tr></table></figure><h4 id="list数据元素插入和删除操作"><a href="#list数据元素插入和删除操作" class="headerlink" title="list数据元素插入和删除操作"></a>list数据元素插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);//在容器尾部加入一个元素</span><br><span class="line">pop_back();//删除容器中最后一个元素</span><br><span class="line">push_front(elem);//在容器开头插入一个元素</span><br><span class="line">pop_front();//从容器开头移除第一个元素</span><br><span class="line">insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</span><br><span class="line">insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</span><br><span class="line">insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</span><br><span class="line">clear();//移除容器的所有数据</span><br><span class="line">erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br><span class="line">erase(pos);//删除pos位置的数据，返回下一个数据的位置。</span><br><span class="line">remove(elem);//删除容器中所有与elem值匹配的元素。</span><br></pre></td></tr></table></figure><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的个数</span><br><span class="line">empty();//判断容器是否为空</span><br><span class="line">resize(num);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以默认值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(num, elem);//重新指定容器的长度为num，</span><br><span class="line">若容器变长，则以elem值填充新位置。</span><br><span class="line">如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><h4 id="list赋值操作"><a href="#list赋值操作" class="headerlink" title="list赋值操作"></a>list赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。</span><br><span class="line">assign(n, elem);//将n个elem拷贝赋值给本身。</span><br><span class="line">list&amp; operator=(const list &amp;lst);//重载等号操作符</span><br><span class="line">swap(lst);//将lst与本身的元素互换。</span><br></pre></td></tr></table></figure><h4 id="list数据的存取"><a href="#list数据的存取" class="headerlink" title="list数据的存取"></a>list数据的存取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front();//返回第一个元素。</span><br><span class="line">back();//返回最后一个元素。</span><br></pre></td></tr></table></figure><h4 id="list反转排序"><a href="#list反转排序" class="headerlink" title="list反转排序"></a>list反转排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</span><br><span class="line">sort(); //list排序</span><br></pre></td></tr></table></figure><h2 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h2><h3 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h3><p>Set的特性是<strong>所有元素都会根据元素的键值自动被排序</strong>。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。</p><p>我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator.</p><p>set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。</p><h3 id="multiset容器"><a href="#multiset容器" class="headerlink" title="multiset容器"></a>multiset容器</h3><p>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p><h3 id="set-multiset数据结构"><a href="#set-multiset数据结构" class="headerlink" title="set/multiset数据结构"></a>set/multiset数据结构</h3><p>set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。</p><h3 id="set常用API"><a href="#set常用API" class="headerlink" title="set常用API"></a>set常用API</h3><h4 id="set构造函数"><a href="#set构造函数" class="headerlink" title="set构造函数"></a>set构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; st;//set默认构造函数：</span><br><span class="line">mulitset&lt;T&gt; mst; //multiset默认构造函数: </span><br><span class="line">set(const set &amp;st);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="set赋值操作"><a href="#set赋值操作" class="headerlink" title="set赋值操作"></a>set赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&amp; operator=(const set &amp;st);//重载等号操作符</span><br><span class="line">swap(st);//交换两个集合容器</span><br></pre></td></tr></table></figure><h4 id="set大小操作"><a href="#set大小操作" class="headerlink" title="set大小操作"></a>set大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><h4 id="set插入和删除操作"><a href="#set插入和删除操作" class="headerlink" title="set插入和删除操作"></a>set插入和删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);//在容器中插入元素。</span><br><span class="line">clear();//清除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(elem);//删除容器中值为elem的元素。</span><br></pre></td></tr></table></figure><h4 id="set查找操作"><a href="#set查找操作" class="headerlink" title="set查找操作"></a>set查找操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</span><br><span class="line">count(key);//查找键key的元素个数</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure><p><strong>set的返回值    指定set排序规则:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">//插入操作返回值</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10);</span><br><span class="line">if (ret.second)&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(10);</span><br><span class="line">if(ret.second)&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MyCompare02&#123;</span><br><span class="line">bool operator()(int v1,int v2)&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//set从大到小</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">//我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt;</span><br><span class="line">set&lt;int, MyCompare02&gt; s;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">s.insert(rand() % 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//set容器中存放对象</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name,int age)&#123;</span><br><span class="line">this-&gt;mName = name;</span><br><span class="line">this-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string mName;</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct MyCompare03&#123;</span><br><span class="line">bool operator()(const Person&amp; p1,const Person&amp; p2)&#123;</span><br><span class="line">return p1.mAge &gt; p2.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test03()&#123;</span><br><span class="line">set&lt;Person, MyCompare03&gt; s;</span><br><span class="line"></span><br><span class="line">Person p1(&quot;aaa&quot;, 20);</span><br><span class="line">Person p2(&quot;bbb&quot;, 30);</span><br><span class="line">Person p3(&quot;ccc&quot;, 40);</span><br><span class="line">Person p4(&quot;ddd&quot;, 50);</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line">for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对组-pair"><a href="#对组-pair" class="headerlink" title="对组(pair)"></a>对组(pair)</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。</p><p>类模板：template \<class t1,="" class="" t2=""> struct pair.</class></p><p>如何创建对组?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法创建一个对组</span><br><span class="line">pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);</span><br><span class="line">cout &lt;&lt; pair1.first &lt;&lt; endl; //访问pair第一个值</span><br><span class="line">cout &lt;&lt; pair1.second &lt;&lt; endl;//访问pair第二个值</span><br><span class="line">//第二种</span><br><span class="line">pair&lt;string, int&gt; pair2 = make_pair(&quot;name&quot;, 30);</span><br><span class="line">cout &lt;&lt; pair2.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">//pair=赋值</span><br><span class="line">pair&lt;string, int&gt; pair3 = pair2;</span><br><span class="line">cout &lt;&lt; pair3.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pair3.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h2><h3 id="map-multimap基本概念"><a href="#map-multimap基本概念" class="headerlink" title="map/multimap基本概念"></a>map/multimap基本概念</h3><p>Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。</p><p>我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。</p><p>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p><p>Multimap和map的操作类似，唯一区别multimap键值可重复。</p><p>Map和multimap都是以红黑树为底层实现机制。</p><h3 id="map-multimap常用API"><a href="#map-multimap常用API" class="headerlink" title="map/multimap常用API"></a>map/multimap常用API</h3><h4 id="map构造函数"><a href="#map构造函数" class="headerlink" title="map构造函数"></a>map构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1, T2&gt; mapTT;//map默认构造函数: </span><br><span class="line">map(const map &amp;mp);//拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="map赋值操作"><a href="#map赋值操作" class="headerlink" title="map赋值操作"></a>map赋值操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&amp; operator=(const map &amp;mp);//重载等号操作符</span><br><span class="line">swap(mp);//交换两个集合容器</span><br></pre></td></tr></table></figure><h4 id="map大小操作"><a href="#map大小操作" class="headerlink" title="map大小操作"></a>map大小操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();//返回容器中元素的数目</span><br><span class="line">empty();//判断容器是否为空</span><br></pre></td></tr></table></figure><h4 id="map插入数据元素操作"><a href="#map插入数据元素操作" class="headerlink" title="map插入数据元素操作"></a>map插入数据元素操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;</span><br><span class="line">map&lt;int, string&gt; mapStu;</span><br><span class="line">// 第一种 通过pair的方式插入对象</span><br><span class="line">mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));</span><br><span class="line">// 第二种 通过pair的方式插入对象</span><br><span class="line">mapStu.inset(make_pair(-1, &quot;校长&quot;));</span><br><span class="line">// 第三种 通过value_type的方式插入对象</span><br><span class="line">mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));</span><br><span class="line">// 第四种 通过数组的方式插入值</span><br><span class="line">mapStu[3] = &quot;小刘&quot;;</span><br><span class="line">mapStu[5] = &quot;小王&quot;;</span><br></pre></td></tr></table></figure><h4 id="map删除操作"><a href="#map删除操作" class="headerlink" title="map删除操作"></a>map删除操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();//删除所有元素</span><br><span class="line">erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。</span><br><span class="line">erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</span><br><span class="line">erase(keyElem);//删除容器中key为keyElem的对组。</span><br></pre></td></tr></table></figure><h4 id="map查找操作"><a href="#map查找操作" class="headerlink" title="map查找操作"></a>map查找操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();</span><br><span class="line">count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</span><br><span class="line">lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。</span><br><span class="line">upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。</span><br><span class="line">equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。</span><br></pre></td></tr></table></figure><h2 id="STL容器使用时机"><a href="#STL容器使用时机" class="headerlink" title="STL容器使用时机"></a>STL容器使用时机</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言：快</td><td>对key而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><ul><li>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</li><li>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li><li>vector与deque的比较：<ul><li>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置    却是不固定的。</li><li>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li><li>三：deque支持头部的快速插入与快速移除，这是deque的优点。</li></ul></li><li>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</li><li>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </li><li>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p><p>注意:</p><p>1.函数对象(仿函数)是一个类，不是一个函数。</p><p>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</p><p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p><p>函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//函数对象是重载了函数调用符号的类</span><br><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">m_Num = 0;</span><br><span class="line">&#125;</span><br><span class="line">int m_Num;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">void operator() (int num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">m_Num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数对象</span><br><span class="line">//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 函数对象超出了普通函数的概念，可以保存函数的调用状态</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(20);</span><br><span class="line">myPrint(20);</span><br><span class="line">myPrint(20);</span><br><span class="line">cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doBusiness(MyPrint print,int num)</span><br><span class="line">&#123;</span><br><span class="line">print(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数对象作为参数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">//参数1：匿名函数对象</span><br><span class="line">doBusiness(MyPrint(),30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</p><p>2、函数对象超出普通函数的概念，函数对象可以有自己的状态</p><p>3、函数对象可内联编译，性能好。用函数指针几乎不可能</p><p>4、模版函数对象使函数对象具有通用性，这也是它的优势之一 </p><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class GreaterThenFive</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num)</span><br><span class="line">&#123;</span><br><span class="line">return num &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//一元谓词</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i ++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive());</span><br><span class="line"> if (it == v.end())</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> cout &lt;&lt; &quot;找到了: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(40);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(90);</span><br><span class="line">v.push_back(60);</span><br><span class="line"></span><br><span class="line">//默认从小到大</span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line">//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">sort(v.begin(), v.end(),MyCompare());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h2><p>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include\<functional>。</functional></p><ul><li><p>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; T plus&lt;T&gt;//加法仿函数</span><br><span class="line">template&lt;class T&gt; T minus&lt;T&gt;//减法仿函数</span><br><span class="line">template&lt;class T&gt; T multiplies&lt;T&gt;//乘法仿函数</span><br><span class="line">template&lt;class T&gt; T divides&lt;T&gt;//除法仿函数</span><br><span class="line">template&lt;class T&gt; T modulus&lt;T&gt;//取模仿函数</span><br><span class="line">template&lt;class T&gt; T negate&lt;T&gt;//取反仿函数</span><br></pre></td></tr></table></figure></li><li><p>6个关系运算类函数对象,每一种都是二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; bool equal_to&lt;T&gt;//等于</span><br><span class="line">template&lt;class T&gt; bool not_equal_to&lt;T&gt;//不等于</span><br><span class="line">template&lt;class T&gt; bool greater&lt;T&gt;//大于</span><br><span class="line">template&lt;class T&gt; bool greater_equal&lt;T&gt;//大于等于</span><br><span class="line">template&lt;class T&gt; bool less&lt;T&gt;//小于</span><br><span class="line">template&lt;class T&gt; bool less_equal&lt;T&gt;//小于等于</span><br></pre></td></tr></table></figure></li><li><p>逻辑运算类运算函数,not为一元运算，其余为二元运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; bool logical_and&lt;T&gt;//逻辑与</span><br><span class="line">template&lt;class T&gt; bool logical_or&lt;T&gt;//逻辑或</span><br><span class="line">template&lt;class T&gt; bool logical_not&lt;T&gt;//逻辑非</span><br></pre></td></tr></table></figure></li></ul><p>内建函数对象举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//取反仿函数</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">negate&lt;int&gt; n;</span><br><span class="line">cout &lt;&lt; n(50) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//加法仿函数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">plus&lt;int&gt; p;</span><br><span class="line">cout &lt;&lt; p(10, 20) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//大于仿函数</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(rand() % 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">sort(v.begin(), v.end(), greater&lt;int&gt;());</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">//函数适配器bind1st bind2nd</span><br><span class="line">//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？</span><br><span class="line">//我们直接给函数对象绑定参数 编译阶段就会报错</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd(myprint(),100));</span><br><span class="line">//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function</span><br><span class="line">//根据我们函数对象是一元函数对象 还是二元函数对象</span><br><span class="line">class MyPrint :public binary_function&lt;int,int,void&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void operator()(int v1,int v2) const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1 = : &quot; &lt;&lt; v1 &lt;&lt; &quot; v2 = :&quot; &lt;&lt;v2  &lt;&lt; &quot; v1+v2 = :&quot; &lt;&lt; (v1 + v2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//1、函数适配器</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;请输入起始值：&quot; &lt;&lt; endl;</span><br><span class="line">int x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind1st(MyPrint(), x));</span><br><span class="line">//for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));</span><br><span class="line">&#125;</span><br><span class="line">//总结：  bind1st和bind2nd区别?</span><br><span class="line">//bind1st ： 将参数绑定为函数对象的第一个参数</span><br><span class="line">//bind2nd ： 将参数绑定为函数对象的第二个参数</span><br><span class="line">//bind1st bind2nd将二元函数对象转为一元函数对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GreaterThenFive:public unary_function&lt;int,bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator ()(int v) const</span><br><span class="line">&#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//2、取反适配器</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器</span><br><span class="line">//vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(),  not1(GreaterThenFive())); //返回第一个小于5迭代器</span><br><span class="line">//自定义输入</span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;int&gt;(),5)));</span><br><span class="line">if (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//排序  二元函数对象</span><br><span class="line">sort(v.begin(), v.end(), not2(less&lt;int&gt;()));</span><br><span class="line">for_each(v.begin(), v.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//not1 对一元函数对象取反</span><br><span class="line">//not2 对二元函数对象取反</span><br><span class="line"></span><br><span class="line">void MyPrint03(int v,int v2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v + v2&lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3、函数指针适配器   ptr_fun</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">// ptr_fun( )把一个普通的函数指针适配成函数对象</span><br><span class="line">for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4、成员函数适配器</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印函数</span><br><span class="line">void ShowPerson()&#123;</span><br><span class="line">cout &lt;&lt; &quot;成员函数:&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; m_Name &lt;&lt; &quot; Age:&quot; &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void Plus100()</span><br><span class="line">&#123;</span><br><span class="line">m_Age += 100;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void MyPrint04(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt;  p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test04()</span><br><span class="line">&#123;</span><br><span class="line">vector &lt;Person&gt;v;</span><br><span class="line">Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4(&quot;ddd&quot;, 40);</span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line">//for_each(v.begin(), v.end(), MyPrint04);</span><br><span class="line">//利用 mem_fun_ref 将Person内部成员函数适配</span><br><span class="line">for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));</span><br><span class="line">// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test05()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person*&gt; v1;</span><br><span class="line">//创建数据</span><br><span class="line">Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">Person p4(&quot;ddd&quot;, 40);</span><br><span class="line"></span><br><span class="line">v1.push_back(&amp;p1);</span><br><span class="line">v1.push_back(&amp;p2);</span><br><span class="line">v1.push_back(&amp;p3);</span><br><span class="line">v1.push_back(&amp;p4);</span><br><span class="line"></span><br><span class="line">for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果容器存放的是对象指针，  那么用mem_fun</span><br><span class="line">//如果容器中存放的是对象实体，那么用mem_fun_ref</span><br></pre></td></tr></table></figure><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>算法主要是由头文件\<algorithm> \<functional> \<numeric>组成。</numeric></functional></algorithm></p><p>\<algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找，遍历，复制，修改，反转，排序，合并等…</algorithm></p><p>\<numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</numeric></p><p>\<functional> 定义了一些模板类,用以声明函数对象。</functional></p><h2 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    遍历算法 遍历容器元素</span><br><span class="line">@param beg 开始迭代器</span><br><span class="line">@param end 结束迭代器</span><br><span class="line">@param _callback  函数回调或者函数对象</span><br><span class="line">@return 函数对象</span><br><span class="line">*/</span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">transform算法 将指定容器区间元素搬运到另一容器中</span><br><span class="line">注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span><br><span class="line">@param beg1 源容器开始迭代器</span><br><span class="line">@param end1 源容器结束迭代器</span><br><span class="line">@param beg2 目标容器开始迭代器</span><br><span class="line">@param _cakkback 回调函数或者函数对象</span><br><span class="line">@return 返回目标容器迭代器</span><br><span class="line">*/</span><br><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each:"></a>for_each:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt,class _Fn1&gt; inline</span><br><span class="line">void for_each(_InIt _First, _InIt _Last, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line">for (; _First != _Last; ++_First)</span><br><span class="line">_Func(*_First);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//普通函数</span><br><span class="line">void print01(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//函数对象</span><br><span class="line">struct print001&#123;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each算法基本用法</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10;i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历算法</span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print001());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print02&#123;</span><br><span class="line">print02()&#123;</span><br><span class="line">mCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">mCount++;</span><br><span class="line">&#125;</span><br><span class="line">int mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each返回值</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print02 p = for_each(v.begin(), v.end(), print02());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.mCount &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct print03 : public binary_function&lt;int, int, void&gt;&#123;</span><br><span class="line">void operator()(int val,int bindParam) const&#123;</span><br><span class="line">cout &lt;&lt; val + bindParam &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//for_each绑定参数输出</span><br><span class="line">void test03()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), bind2nd(print03(),100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//transform 将一个容器中的值搬运到另一个容器中</span><br><span class="line">/*</span><br><span class="line">template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline </span><br><span class="line">_OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for (; _First != _Last; ++_First, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First);</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline</span><br><span class="line">_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span><br><span class="line">&#123;</span><br><span class="line">for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)</span><br><span class="line">*_Dest = _Func(*_First1, *_First2);</span><br><span class="line">return (_Dest);</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct transformTest01&#123;</span><br><span class="line">int operator()(int val)&#123;</span><br><span class="line">return val + 100;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct print01&#123;</span><br><span class="line">void operator()(int val)&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test01()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vSource;</span><br><span class="line">for (int i = 0; i &lt; 10;i ++)&#123;</span><br><span class="line">vSource.push_back(i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//目标容器</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">//给vTarget开辟空间</span><br><span class="line">vTarget.resize(vSource.size());</span><br><span class="line">//将vSource中的元素搬运到vTarget</span><br><span class="line">vector&lt;int&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01());</span><br><span class="line">//打印</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将容器1和容器2中的元素相加放入到第三个容器中</span><br><span class="line">struct transformTest02&#123;</span><br><span class="line">int operator()(int v1,int v2)&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test02()&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; vSource1;</span><br><span class="line">vector&lt;int&gt; vSource2;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">vSource1.push_back(i + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//目标容器</span><br><span class="line">vector&lt;int&gt; vTarget;</span><br><span class="line">//给vTarget开辟空间</span><br><span class="line">vTarget.resize(vSource1.size());</span><br><span class="line">transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02());</span><br><span class="line">//打印</span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">find算法 查找元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value 查找的元素</span><br><span class="line">@return 返回查找元素的位置</span><br><span class="line">*/</span><br><span class="line">find(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">find_if算法 条件查找</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">find_if(iterator beg, iterator end, _callback);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">adjacent_find算法 查找相邻重复元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return 返回相邻元素的第一个位置的迭代器</span><br><span class="line">*/</span><br><span class="line">adjacent_find(iterator beg, iterator end, _callback);</span><br><span class="line">/*</span><br><span class="line">binary_search算法 二分查找法</span><br><span class="line">注意: 在无序序列中不可用</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value 查找的元素</span><br><span class="line">@return bool 查找返回true 否则false</span><br><span class="line">*/</span><br><span class="line">bool binary_search(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">count算法 统计元素出现次数</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  value回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count(iterator beg, iterator end, value);</span><br><span class="line">/*</span><br><span class="line">count算法 统计元素出现次数</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param  callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">@return int返回元素个数</span><br><span class="line">*/</span><br><span class="line">count_if(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">merge算法 容器元素合并，并存储到另一容器中</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">*/</span><br><span class="line">merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">sort算法 容器元素排序</span><br><span class="line">注意:两个容器必须是有序的</span><br><span class="line">@param beg 容器1开始迭代器</span><br><span class="line">@param end 容器1结束迭代器</span><br><span class="line">@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span><br><span class="line">*/</span><br><span class="line">sort(iterator beg, iterator end, _callback)</span><br><span class="line">/*</span><br><span class="line">sort算法 对指定范围内的元素随机调整次序</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">random_shuffle(iterator beg, iterator end)</span><br><span class="line">/*</span><br><span class="line">reverse算法 反转指定范围的元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">*/</span><br><span class="line">reverse(iterator beg, iterator end)</span><br></pre></td></tr></table></figure><h2 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">copy算法 将容器内指定范围的元素拷贝到另一容器中</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param dest 目标起始迭代器</span><br><span class="line">*/</span><br><span class="line">copy(iterator beg, iterator end, iterator dest)</span><br><span class="line">/*</span><br><span class="line">replace算法 将容器内指定范围的旧元素修改为新元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param oldvalue 旧元素</span><br><span class="line">@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br><span class="line">/*</span><br><span class="line">replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param callback函数回调或者谓词(返回Bool类型的函数对象)</span><br><span class="line">@param oldvalue 新元素</span><br><span class="line">*/</span><br><span class="line">replace_if(iterator beg, iterator end, _callback, newvalue)</span><br><span class="line">/*</span><br><span class="line">swap算法 互换两个容器的元素</span><br><span class="line">@param c1容器1</span><br><span class="line">@param c2容器2</span><br><span class="line">*/</span><br><span class="line">swap(container c1, container c2)</span><br></pre></td></tr></table></figure><h2 id="常用算数生成算法"><a href="#常用算数生成算法" class="headerlink" title="常用算数生成算法"></a>常用算数生成算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">accumulate算法 计算容器元素累计总和</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value累加值</span><br><span class="line">*/</span><br><span class="line">accumulate(iterator beg, iterator end, value)</span><br><span class="line">/*</span><br><span class="line">fill算法 向容器中添加元素</span><br><span class="line">@param beg 容器开始迭代器</span><br><span class="line">@param end 容器结束迭代器</span><br><span class="line">@param value t填充元素</span><br><span class="line">*/</span><br><span class="line">fill(iterator beg, iterator end, value)</span><br></pre></td></tr></table></figure><h2 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">set_intersection算法 求两个set集合的交集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">set_union算法 求两个set集合的并集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br><span class="line">/*</span><br><span class="line">set_difference算法 求两个set集合的差集</span><br><span class="line">注意:两个集合必须是有序序列</span><br><span class="line">@param beg1 容器1开始迭代器</span><br><span class="line">@param end1 容器1结束迭代器</span><br><span class="line">@param beg2 容器2开始迭代器</span><br><span class="line">@param end2 容器2结束迭代器</span><br><span class="line">@param dest  目标容器开始迭代器</span><br><span class="line">@return 目标容器的最后一个元素的迭代器地址</span><br><span class="line">*/</span><br><span class="line">set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL标准模板库&quot;&gt;&lt;a href=&quot;#STL标准模板库&quot; class=&quot;headerlink&quot; title=&quot;STL标准模板库&quot;&gt;&lt;/a&gt;STL标准模板库&lt;/h1&gt;&lt;h2 id=&quot;六大组件简介&quot;&gt;&lt;a href=&quot;#六大组件简介&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="STL" scheme="http://qianyouyou.cn/tags/STL/"/>
    
  </entry>
  
</feed>
