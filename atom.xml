<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浅悠悠的个人博客</title>
  
  <subtitle>When there is no sunshine,talking to the moon.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qianyouyou.cn/"/>
  <updated>2018-07-15T16:47:27.065Z</updated>
  <id>http://qianyouyou.cn/</id>
  
  <author>
    <name>王骏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[少年班]天分与平凡，青春与坚守</title>
    <link href="http://qianyouyou.cn/2018/07/14/2018-07-14/"/>
    <id>http://qianyouyou.cn/2018/07/14/2018-07-14/</id>
    <published>2018-07-14T14:15:12.000Z</published>
    <updated>2018-07-15T16:47:27.065Z</updated>
    
    <content type="html"><![CDATA[<p>好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初心呢；或许是经历过许许多多次起起伏伏，遇见过形形色色想遇或不想遇的人或事，又怀念起那段那段青涩的高中岁月；或许只是单纯的想再看看这部电影吧。不管为何，总之现在思绪万千。就让我将这万千的思绪草草记录一下吧。</p><p>这部电影剧情很简单，讲述的是几个天才少年与一个平凡少年被发掘功课数学难题却因青春的叛逆与时代的变迁而成长的故事。故事以主人公以吴未的少年班回忆而展开，主人公吴未就是那个平凡的少年。</p><p>少年班，顾名思义就是大学里专为年纪轻轻却智商非凡的天才们开设的精英班，某知名大学老师周知庸曾经就是少年班的成员，他的梦想是攻克IMC的题目，但曾经的他未能实现，于是将希望寄托在新时代的少年身上。在他的坚持下从全国各地找到了几名心仪的人选，其中包括了吴未。</p><p>然而，像其他天才系列电影一样，天才们拥有着平凡人所羡慕的才能之外，往往却拥有着平凡人所不能理解的烦恼。天才少年方厚政年纪最小，却智商超群，可谓前途无量，只是他IQ高。EQ却低，因此没有什么朋友。天才少年麦克因家庭原因而性格叛逆，打架斗殴无所不为。天才少年王大法无拘无束，自由散漫，因此总让别人捉摸不透，不想与之有交集。天才少女周兰品学兼优，是典型的别人家的子，但也是因为优秀而让所有人都敬而远之。但是和其他电影不同的是，这些天才们不可思议的烦恼其实我们都能理解。毕竟曾经或现在处于青春期的我们哪一个人曾经没有过类似的烦恼呢？他们的性格不过是我们所有人青春期各种性格的集合并放大罢了。</p><p>当然，我们的主人公也有着自己的烦恼，身为平凡人的代表，当他进入少年班后从之前的全校第二摇身一变变成班上的倒数第一，这种落差估计每个处于青春期的孩子都受不了吧。于是他一边仰望着天才们过人的天赋，一边忍受着天才们怪异的性格，一边照顾着正处于青春期幼稚的天才们，一边独自默默努力着，为了自己心中的荣誉。然而，努力在这满是天才的地方却显得那么多余。就在他一筹莫展，开始疑惑为何老师选中他的时候，周知庸老师出现，解开了她的心结。“运送金枪鱼的时候，要在里面混进几条鲶鱼，否则金枪鱼就会因懒惰而死，到不了岸。”老师鼓励他做好自己鲶鱼的身份，因为天才们离开了它的照顾就会堕入深渊。尽管是鲶鱼，但吴未却似乎找到了自己的归宿，并以此为荣，从此，吴未以天才们的快乐为快乐，以天才们的梦想为梦想，就在自己喜欢的人面前，也只能呼喊着天才们所喜欢的校花名字。</p><p>IMC马上开始了，老师想进各种办法激励着天才们去努力钻研，但是恃才傲物并且正处于青春期的天才们又怎会把新鲜的大学生活浪费在学习上呢？趁着大学生活的新鲜感犹在，天才们渐渐被校花江依琳所吸引，从此各种各样的新奇表白开始了。只有吴未从一开始就暗恋着同班的天才少女周兰。尽管周兰从来都看不起吴未，并且单恋这少年班的迈克。</p><p>比赛前一天，几名少年班朝夕相处的小伙伴们在酒后发泄着各种各样青春期的passion，来到女生宿舍楼下，大声表白校花，那一刻，漫天飞舞的纸花，洋洋洒洒，似乎整个世界都在期待着几个天才少年去改变。</p><p>比赛的一个月里，天才们尽管出现各种各样的矛盾，但在吴未的调节下，无伤大雅。但一次偶遇，校花与富家公子哥之间的隐曲之事深深刺激到了天才们。他们落荒而逃，逃得那么彻底。</p><p>老师闻讯，拿起了酒杯，向舞台赶去。天才们旧气难言，拿起了自制的化学炸药，向富二代的车赶去。老师将酒水泼向校花，门外传来雷鸣般的爆炸。这一刻，老师的梦想毁了，天才们的前途毁了，然而，世界依然有活力地在转，一如既往。</p><p>然而，老师仍心怀希望，尽力将此事最小化解决。这边，王大法作为被开除的学生被家人拖走，那边，吴未望向楼上的橱窗，老师站在橱窗望着吴未。这一刻，吴未明白，自己的价值将要发挥了。就这样，吴未顶替其他天才们而被学校开除。</p><p>奔驰的归家车上，吴未哭的撕心裂肺，将自己仅有的一枚荣誉勋章扔向窗外，像扔去回忆一样。身后周兰，方厚政，迈克，追的精疲力尽，他们将过去的笔记本扔向追不上的公交车，像追随友谊一样。</p><p>最终，天才们并没有解出题，也没有改变世界，但他们最终都找到了自己的方向。周知庸老师最后没能实现自己的天才梦，也丢掉了工作，像人间蒸发一样，随旧时代而去，但他却找到了自己的人生伴侣。吴未，平淡无味，但又快乐的漂浮着。</p><p>这部影片最大的亮点就在于其真实性。首先，少年班的故事从1978年起一直延续着。然而，随着时代的发展，如今的少年班已不复存在了。旧时代里，时代的推进是由天才们推进的，这就是为何周知庸老师为何执着于天才的原因之一。就像他说的，“高斯十七岁就发现了第二相反定理，这些天才当时他们不敢发表，因为怕人们不信。”因为这种理念的支撑，让他对所有平凡人带上了有色眼镜，以至于四十多岁依旧单身。然而，过去毕竟是过去，世界上有很多天才，但只有一个高斯，只有一个牛顿，只有一个爱因斯坦。牛顿他们所带表的这类基础科学并不是一个人所完成的，它需要所处时代的支持以及现有技术的支撑，就像牛顿自己也说过，自己是站在巨人肩膀上的，况且牛顿从未说过自己是天才，自己只是热爱探索而已，因此，想要天才改变世界的周知庸老师从一开始就错了，因为他不懂平凡人的价值，所以，他没有牛顿的成就，与牛顿唯一的共同点就是一直单身。世界是一个多元化的世界，不只是理论的世界，如果说基础科学是时代质的飞跃，那应用科学就是时代量的积累、倘若基础科学离开了应用科学，那么世界依旧停滞不前，基础科学反而成为了最没用的东西。故事的结尾，天才们并没有从事科研工作，而是选择了自己所喜欢的岗位，他们没有改变世界，只是生活的比平凡人更潇洒。平凡与天赋，其实离开谁都不行，正是因为天才们的研发，广大平凡的劳动者的坚持工作与制作，才使得这个世界不断推进向前。</p><p>然而，少年班不适宜于当下最主要的原因还是心智的为题。尽管天才们智商超群，但是年纪与经历更重要。十几岁就步入大学校门，尽管他们智商达标了，但心智并未达标。电影中表现的淋淋尽致。他们从未接触过社会，也并不懂得什么是责任，当然，那个时代的我们都一样，在心智上，人人都是平等的。我们就来分析一下各个主人公吧。</p><p>首先是主人公方厚政。作为年纪最小的天才，他的心情，性格，全都写在了脸上。目测智商150，心理年龄只有9岁。遇到委屈就哭，遇到自己看不上的事就挖苦，总之这个世界上只有自己是最厉害的，当面对丰富多彩的大学生活，他又怎会抵挡住各种各样的新鲜事物而去专心钻研呢。主人公迈克，看似成熟，其实心智同样幼稚，面对所有事第一个想到的就是用拳头来解决，从不会考虑后果。主人公王大法自由散漫，每天吃着馒头，听着经文，一副玩世不恭的样子。主人公周兰，可以说是所有优秀的女孩的代表，可以说是比较正常的一个，但正处于花季年纪的她并不适合大学生活，成绩优异不懂打扮的她让人只能敬而远之。尽管是天才，但是如今的大学并不只是学习知识的地方，如果说初中是每个人最会做梦的年纪，高中洋溢着每个人最具浓厚的青春，走向社会是一个人成长为打人的标志，那么大学时代则是每一个人从孩子长成大人的过度期，因此嚷处于做梦年纪的孩子直接去面向社会的残酷未免太过残忍。</p><p>校花江依琳可谓是剧中较完美的一个人，他承载着天才们对女性最完美的幻想。她可以说是剧中EQ最高的一位。尽管他是天才们放弃比赛的导火线，但是天才们又有几个真正懂得感情呢。她对方厚政的感情其实就是姐姐对弟弟的照顾，而对于心智只有9岁的方厚政来说，又怎会冬的何谓男女之情呢。方厚政对待像话的感觉也不过是弟弟对大姐姐的仰慕之情。王大法测试时便已说过他所期望的爱情是门当户对，显然校花并不是他所期待的人，因此他对校花的感情量自己都不会说清楚。至于迈克，校花也许的确对迈克有点好感，但迈克显然给不了校花幸福，首先，迈克并不知道什么是责任，测试时便已清楚他的情绪宣泄是暴力，倘若青春期那股passion磨灭了，后果自行脑补。其次迈克给不了校花真正需要的。之所以前期近似完美的校花最后会有那么一出戏，其实很容易看出的。江依琳需要一场舞蹈独秀以支撑日后的发展，身为天才的少年们有谁能给呢，因此江依琳选择了富家公子哥，这都是情理之中。而此时的天才们只顾自己的感受，仗着长久以来老师的庇护去炸车。所以，当看到周知庸老师泼江依琳水时，我倒有点替校花感到冤枉，自己争取来的前途就因为接近了天才们而被老师给毁了。而周老师之所以泼水，也许是曾经旧时代里被戏弄过，旧火新火全发泄在了江依琳身上。</p><p>周知庸老师，典型旧时代的人，因为自己未能拿奖的遗憾，而把希望寄托在新时代的少年天才们身上。也许努力学习没有错，但他忽略了当今世界已不是简简单单努力学习就能改变的了。当一个人不愿接受新时代时，他已经被这个时代所遗弃，成为旧时代的古董。当他最后不在从事教育事业，专心于交际时，此刻的他应该是幸福的。</p><p>不过，周老师错了吗，没人能说他错了。至少20多年来，他一直秉持着初心，坚守着梦想，对于现代人来说，这一点是多么的可贵呢。社会这个大染缸将每一个青春期怀穿着梦想的少年少女染成形形色色为生活而忙碌的机器，又有几个人能站出来说我要改变这个世界呢。我感觉说这话的人并不丢人，反而是那些早已面目全非的人让人可悲。</p><p>不知不觉，恭喜我又成功把我给绕进去了。我竟然有分不清自己的立场了，呵呵。不过不论什么样的人，坚持做好自己就好。正处于大学生活的我们，无论何时都要坚持自己的梦想，不必在意那些圆滑的人说你不够圆滑，不必在意那些所谓成熟的人说你不够成熟，不要照原样接受别人的生活。选择坚守，选择理想，选择倾听自己内心深处的呼唤。因为在这个充满怀疑的世界，我们依旧需要梦想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="影评" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>回忆若一指流沙，散落了谁的风华</title>
    <link href="http://qianyouyou.cn/2018/06/11/2018-06-11/"/>
    <id>http://qianyouyou.cn/2018/06/11/2018-06-11/</id>
    <published>2018-06-11T06:16:28.000Z</published>
    <updated>2018-06-11T09:23:54.552Z</updated>
    
    <content type="html"><![CDATA[<p>宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。</p><p>后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有一种壮志凌云。</p><p>在宁夏，没有高楼大厦，但远处的山峰鳞次栉比。没有车水马龙，但广阔的天空一碧如洗。一切都安顿好之后，我们便奔向当地特色小吃而去。宁夏理工学院，坐落在湖心的一座岛屿之上，可以说，一座岛屿即一座城。很快我们便摸不清方向了。此时，一个小姐姐跑过来跟我们搭讪。由于比赛都发的队服，很是显眼，显然，她是被我们的队服吸引而来的。就这样莫名其妙的，我们渐渐熟悉。在她的带领下，我们逛了校园，逛了小吃摊……</p><p>宁夏昼长夜短，即使到了晚上八九点，天依然为褪色。就这样逛着逛着，吃着吃着，天就黑了，当我们看时间时，已是十点多了。我们留下了联系方式，各自归宿。</p><p>第2天，宁夏理工学院组织我们所有参赛者一起去旅游，地点是沙湖，即沙漠中的一片绿洲。我们队和昨天的小姐姐约好今天一起游玩，而我们队刚好缺了一个教练，就这样理所当然的，她以我们教练的身份一起踏上了沙漠的旅程。</p><p>一路上，我们划过了湖泊，翻过了沙漠，跨过了沙丘，因为她的出现，在她的陪伴下，我们的旅程不再显得单调乏味。在沙漠中，偶然发现某片沙地里满是荆棘，当跨过荆棘之后，望到了一片花海。尽管花在强烈的阳光下已奄奄一息，然而它们仿佛在用生命证明自己存在的意义。同伴们纷纷前往亭下避暑，只有我守着安静的沙漠，等待着花开。</p><p>第3天，终于要比赛了。经过了上一次失败的经验，这次尽管最后一次提交因为时间到了没有提交成功，不过好在前两个半小时成功A了3道题，我们队最终斩获一枚铜奖，也算是这么多月的训练也算有了一个回报。</p><p>临别时，小姐姐教练来为我们送行，并带来当地的特产。因为赶飞机，我们草草照相留念之后，便踏上了返程的飞机。</p><p>戴上耳机，梳理着三天的回忆。其实我们每个人来到这个世界上，就只能义无反顾的前进。在人生的道路上，除了自己，其他人都只能伴我们走过一程。这一程，或长或短，也许转瞬已尽，也许直通彼岸，但永远不会是永远。当走完这一程，余下的路需由自己来走完。然而不必逗留着，因为每时每刻，都会有新的过客伴你走过新的一程。尽管离别之后，我们可能会永远不见，但彼此走过的那份欢乐，永远藏在心里。</p><p>谢谢你伴我们走过这三天，也许今后永远不会再见，但我们走过的那段旅程以及旅程中的你我永远不会失散。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。&lt;/p&gt;
&lt;p&gt;后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>API函数配置读写文件</title>
    <link href="http://qianyouyou.cn/2018/06/03/2018-06-03/"/>
    <id>http://qianyouyou.cn/2018/06/03/2018-06-03/</id>
    <published>2018-06-03T15:19:41.000Z</published>
    <updated>2018-06-03T15:32:58.144Z</updated>
    
    <content type="html"><![CDATA[<p>cfg_op.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">//获取配置项</span><br><span class="line">int GetCfgItem(char *pFileName/*in*/, char*pKey/*in*/, char *pValue/*in out*/, int *pValueLen/*out*/);</span><br><span class="line">//写配置项</span><br><span class="line">int WriteCfgItem(char*pFileName/*in*/, char *pKey/*in*/, char *pValue/*in*/, int *ValueLen/*in*/);</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>cfg_op.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define Maxline 2048</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">int GetCfgItem(char *pFileName, char*pKey, char *pValue, int *pValueLen)</span><br><span class="line">&#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char lineBuf[Maxline];</span><br><span class="line">char *pTmp = NULL, *pEnd = NULL, *pBegin = NULL;</span><br><span class="line">fp = fopen(pFileName, &quot;r&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">ret = -1;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">while (!feof(fp)) &#123;</span><br><span class="line">memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">fgets(lineBuf, Maxline, fp);</span><br><span class="line">printf(&quot;lineBuf:%s &quot;, lineBuf);</span><br><span class="line"></span><br><span class="line">pTmp = strchr(lineBuf, &apos;=&apos;);</span><br><span class="line">if (pTmp == NULL) &#123;//没有=号</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp = strstr(lineBuf, pKey);</span><br><span class="line">if (pTmp == NULL) &#123;//判断key是不是在//所在行 是不是有key</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp = pTmp + strlen(pKey);//mykey1 = myvalue11111111==&gt;&quot;myvalue11111111&quot;</span><br><span class="line">pTmp = strchr(pTmp, &apos;=&apos;);</span><br><span class="line">if (pTmp == NULL) &#123;//判断所在行是不是有key</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">pTmp++;</span><br><span class="line">printf(&quot;pTmp:%s &quot;, pTmp);</span><br><span class="line">//获取value起点</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (*pTmp == &apos; &apos;) &#123;</span><br><span class="line">pTmp++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">pBegin = pTmp;</span><br><span class="line">if (*pBegin == &apos;\n&apos;) &#123;</span><br><span class="line">//没有配置value</span><br><span class="line">printf(&quot;配置项:%s 没有配置value \n&quot;, pKey);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取value结束点</span><br><span class="line">while (1) &#123;</span><br><span class="line">if (*pTmp == &apos; &apos; || *pTmp == &apos;\n&apos;) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">pTmp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pEnd = pTmp;</span><br><span class="line">//赋值</span><br><span class="line">*pValueLen = pEnd - pBegin;</span><br><span class="line">memcpy(pValue, pBegin, pEnd - pBegin);</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line">if (fp == NULL)</span><br><span class="line">fclose(fp);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">int WriteCfgItem(char*pFileName, char *pKey, char *pValue, int *ValueLen)</span><br><span class="line">&#123;</span><br><span class="line">int rv = 0, iTag = 0, length = 0;</span><br><span class="line">FILE *fp = NULL;</span><br><span class="line">char lineBuf[Maxline];</span><br><span class="line">char *pTmp = NULL, *pBegin = NULL, *pEnd = NULL;</span><br><span class="line">char filebuf[1024 * 8] = &#123; 0 &#125;;</span><br><span class="line">if (pFileName == NULL || pKey == NULL || pValue == NULL) &#123;</span><br><span class="line">rv = -1;</span><br><span class="line">printf(&quot;SetCfgItem() err. param err \n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(pFileName, &quot;r+&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -2;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -3;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fseek(fp, 0L, SEEK_END);//把文件指针从0位置开始，移动到文件末尾</span><br><span class="line">//获取文件长度</span><br><span class="line">length = ftell(fp);</span><br><span class="line">fseek(fp, 0L, SEEK_SET);</span><br><span class="line">if (length &gt; 1024 * 8) &#123;</span><br><span class="line">rv = -3;</span><br><span class="line">printf(&quot;文件超过1024*8,nunsupport&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">while (!feof(fp)) &#123;</span><br><span class="line">//读每一行</span><br><span class="line">memset(lineBuf, 0, sizeof(lineBuf));</span><br><span class="line">pTmp = fgets(lineBuf, Maxline, fp);</span><br><span class="line">if (pTmp == NULL) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//key关键字是否在本行</span><br><span class="line">pTmp = strstr(lineBuf, pKey);</span><br><span class="line">if (pTmp == NULL)//key关键字不在本行，copy到filebuf中</span><br><span class="line">&#123;</span><br><span class="line">strcat(filebuf, lineBuf);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else//key关键字在本行中，替换旧的行，再copy到filebuf中</span><br><span class="line">&#123;</span><br><span class="line">sprintf(lineBuf, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">strcat(filebuf, lineBuf);</span><br><span class="line">//若存在key</span><br><span class="line">iTag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//若key关键字，不存在 追加</span><br><span class="line">if (iTag == 0) &#123;</span><br><span class="line">fprintf(fp, &quot;%s = %s\n&quot;, pKey, pValue);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//若key关键字，存在，则重新创建文件</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">fclose(fp);</span><br><span class="line">fp = NULL;//避免野指针</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(pFileName, &quot;w+t&quot;);</span><br><span class="line">if (fp == NULL) &#123;</span><br><span class="line">rv = -4;</span><br><span class="line">printf(&quot;fopen() err.\n&quot;);</span><br><span class="line">goto End;</span><br><span class="line">&#125;</span><br><span class="line">fputs(filebuf, fp);</span><br><span class="line">&#125;</span><br><span class="line">End:</span><br><span class="line">if (fp != NULL) &#123;</span><br><span class="line">fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line">return rv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include&quot;cfg_op.h&quot;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define CFGNAME &quot;d:/mycfg.ini&quot;</span><br><span class="line">//读配置项</span><br><span class="line">int GetCfg() &#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">char name[1024] = &#123; 0 &#125;;</span><br><span class="line">char value[1024] = &#123; 0 &#125;;</span><br><span class="line">int vlen = 0;</span><br><span class="line">printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line">ret = GetCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">printf(&quot;func GetCfgItem err:%d \n&quot;, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;value:%s \n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">//写配置项</span><br><span class="line">int TWriteCfg() &#123;</span><br><span class="line">int ret = 0;</span><br><span class="line">char name[1024] = &#123; 0 &#125;;</span><br><span class="line">char value[1024] = &#123; 0 &#125;;</span><br><span class="line">int vlen = 0;</span><br><span class="line">printf(&quot;\n请输入Key:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, name);</span><br><span class="line">printf(&quot;\n请输入Value:&quot;);</span><br><span class="line">scanf(&quot;%s&quot;, value);</span><br><span class="line">WriteCfgItem(CFGNAME, name, value, &amp;vlen);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">printf(&quot;func WriteCfgItem err:%d \n&quot;, ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;您的输入是：%s = %s \n&quot;, name, value);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show_menu() &#123;</span><br><span class="line">printf(&quot;==========================\n&quot;);</span><br><span class="line">printf(&quot;1.测试写配置文件\n&quot;);</span><br><span class="line">printf(&quot;2.测试读配置文件\n&quot;);</span><br><span class="line">printf(&quot;0.退出\n&quot;);</span><br><span class="line">printf(&quot;==========================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int choice;</span><br><span class="line">show_menu();</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;choice)) &#123;</span><br><span class="line">//显示一个菜单</span><br><span class="line">switch (choice) &#123;</span><br><span class="line">case 1:</span><br><span class="line">TWriteCfg();</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">GetCfg();</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">system(&quot;cls&quot;);</span><br><span class="line">show_menu();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cfg_op.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="文件" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="API函数" scheme="http://qianyouyou.cn/tags/API%E5%87%BD%E6%95%B0/"/>
    
      <category term="文件" scheme="http://qianyouyou.cn/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>牛客训练赛19之托米专场</title>
    <link href="http://qianyouyou.cn/2018/06/01/2018-06-01/"/>
    <id>http://qianyouyou.cn/2018/06/01/2018-06-01/</id>
    <published>2018-06-01T15:42:31.000Z</published>
    <updated>2018-07-15T14:27:17.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="托米的简单表示法"><a href="#托米的简单表示法" class="headerlink" title="托米的简单表示法"></a><a href="https://www.nowcoder.com/acm/contest/111/A" target="_blank" rel="noopener">托米的简单表示法</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   作为故事主角的托米是一名老师。  </p></blockquote><p>  一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: </p><p>  几何表示的定义： </p><p>  <strong>1.</strong>          <strong>对于一个括号序列A，我们定义g(A)是A的几何表示形式,则          “()”的表示是一个1*1的方块，高度为1;</strong>            <strong>2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1; 3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。 其中+指的是字符串的连接符。</strong>  </p><p>​                              </p><p>  在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： </p><p>  <img src="https://uploadfiles.nowcoder.com/images/20180529/301599_1527594747449_9C23C3C01AAE429614DCD886F400FAF2" alt="img"></p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入的第一行包含一个整数T，表示指定测试用例的数量。</span><br><span class="line">每个测试用例前面都有一个空白行。</span><br><span class="line">每个测试用例由一个合法括号序列组成。 每行只包含字符&apos;(&apos;和&apos;)&apos;。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line"></span><br><span class="line">((()))</span><br><span class="line"></span><br><span class="line">(())(()(()))</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二个测试案例是上图中显示的案例。</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1≤T≤10</span><br><span class="line">一个合法括号序列长度≤4 x 105</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题提交了好多次，一直WA。后来改成long long就过了。原理很简单，就是遇见左括号入栈，遇见右括号出栈。在入栈出栈时执行操作。先入栈的高度比后入栈的最高高度要高1，初始宽度为1，每执行一次出栈操作，出栈元素前一个元素的宽度等于他自身宽度加上出栈元素宽度再加1。而出栈元素的面积等于宽乘高减去包含元素的面积。就这样，每次出栈时，前一个元素宽度加上该元素宽度加1，前元素将要减去的面积area等于出栈元素的面积minu。而出栈元素的面积area等于高乘宽减去将要减去的面积minu。最终由于0位置没有面积，就是全域，那他的minu即将要减去的面积就是总面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200010;</span><br><span class="line">char str[maxn*2];</span><br><span class="line">ll high[maxn],wed[maxn],area[maxn],minu[maxn],mystack[maxn];</span><br><span class="line">ll fun()&#123;</span><br><span class="line">    int cnt = 1,head = 1,tail = 1,len = strlen(str);</span><br><span class="line">    memset(high,0,sizeof(high));</span><br><span class="line">    memset(wed,0,sizeof(wed));</span><br><span class="line">    memset(minu,0,sizeof(minu));</span><br><span class="line">    memset(mystack,0,sizeof(mystack));</span><br><span class="line">    for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">        if(str[i] == &apos;(&apos;)&#123;</span><br><span class="line">            mystack[tail++]=cnt++;</span><br><span class="line">            high[mystack[tail - 1]]++;</span><br><span class="line">            wed[mystack[tail - 1]] = 1;</span><br><span class="line">            if(high[mystack[tail - 2]] &lt;= high[mystack[tail - 1]])</span><br><span class="line">                high[mystack[tail - 2]] = high[mystack[tail - 1]] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(str[i] == &apos;)&apos;)&#123;</span><br><span class="line">            if(tail &gt; 1)&#123;</span><br><span class="line">                if(high[mystack[tail-2]] &lt;= high[mystack[tail-1]])</span><br><span class="line">                    high[mystack[tail-2]] = high[mystack[tail-1]] + 1;</span><br><span class="line">                tail--;</span><br><span class="line">                wed[mystack[tail - 1]] += wed[mystack[tail]] + 1;</span><br><span class="line">                area[mystack[tail]] = wed[mystack[tail]] * high[mystack[tail]] - minu[mystack[tail]];</span><br><span class="line">                minu[mystack[tail - 1]] += area[mystack[tail]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return minu[0];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        cout &lt;&lt; fun() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托米的饮料"><a href="#托米的饮料" class="headerlink" title="托米的饮料"></a><a href="https://www.nowcoder.com/acm/contest/111/E" target="_blank" rel="noopener">托米的饮料</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   好了，现在是小托米的故事啦~~~  </p></blockquote><p>  可爱的小托米得到了n瓶饮料. </p><p>但他不小心把开盖的工具弄丢了,所以他只能利用饮料瓶来开盖.</p><p>已知第i个瓶子的品牌为a</p><p>i</p><p>,且其能打开b</p><p>i</p><p>品牌的瓶子.</p><p>问有几瓶饮料托米无法喝到.</p><p><strong>被用于打开饮料瓶的瓶子不一定需要被打开.</strong></p><p><strong>一个瓶子不能打开其本身.</strong></p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n,表示饮料的瓶数.</span><br><span class="line">接下来n行,每行两个整数ai,bi.</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行一个整数,表示小托米无法喝到的饮料瓶数.</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1≤n≤100</span><br><span class="line">1≤ ai,bi≤ 1000</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>本题坑人之处在于理解题意。因为没理解题意导致提交了好多次才提交成功。本题实质很简单，就是每个瓶子对应有一个编号b，可以开这个编号b除了自己以外的所有的瓶子。但仅限于该瓶子，其他瓶子也只能执行自己的编号b。首先输入完成时记录下所有编号的瓶子个数，把n赋给瓶子个数cnt，因为一开始n个瓶子都没打开。接着对b按顺序进行遍历，如果对应编号的瓶子不存在，则不执行操作，否则接着判断，如果a和b不同，则cnt减去该瓶子的数量，然后数量置零，因为该类瓶子已经打开完了，之后不需要再打开，否则执行完操作后再加1，因为不能打开自己。最后cnt就是剩下没打开的数量。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1010]=&#123;0&#125;,a[1010],b[1010];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int cnt = n;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">        vis[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(vis[b[i]])&#123;</span><br><span class="line">            cnt-=vis[b[i]];</span><br><span class="line">            vis[b[i]]=0;</span><br><span class="line">            if(a[i]==b[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[b[i]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="托米搭积木"><a href="#托米搭积木" class="headerlink" title="托米搭积木"></a><a href="https://www.nowcoder.com/acm/contest/111/F" target="_blank" rel="noopener">托米搭积木</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>  小托米真的很可爱呀(&gt;_&lt;) </p></blockquote><p>  这天,可爱的小托米得到了n堆积木,且第i堆积木初始时有ai块积木. </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一行两个整数n,m.</span><br><span class="line">第二行n个整数,第i个整数代表ai的值.</span><br><span class="line">接下来m行,每行代表一个操作:</span><br><span class="line">第一个整数t代表操作的类型</span><br><span class="line">若t=1,则接下来两个整数v,x,代表操作1.</span><br><span class="line">若t=2,则接下来一个整数y,代表操作2.</span><br><span class="line">若t=3,则接下来一个整数q,代表操作3.</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个操作3,输出其对应的答案.</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10 11</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">3 2</span><br><span class="line">3 9</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">1 1 10</span><br><span class="line">2 10</span><br><span class="line">2 10</span><br><span class="line">3 1</span><br><span class="line">3 10</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">39</span><br></pre></td></tr></table></figure><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤ 105</span><br><span class="line">1≤ai≤109</span><br><span class="line">1≤t≤3</span><br><span class="line">1≤v≤ n,1≤ x≤109</span><br><span class="line">1≤y≤104</span><br><span class="line">1≤q≤n</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>很简单的一道题，3种操作，第1操作是把第i位置的数该为另一个数x，第2个操作是所有数加v，第3个操作是查询某一位置的数。首先分析，第1种操作和第3种操作时间复杂度都是O(1),第2中操作如果每位加v的话时间复杂度O(n)。所以优化在于第2操作。不过对于此操作我们可以降维优化，因为是所有数都加v，那么我们只需把v记录下来，每次查询时对查询的数直接加v就行了。这样就又遇到了一个问题，就是假如所有的数现在的状态是加v，而i位置元素现在变成了x，这样就会造成所有元素相加不一致。解决也很简单，只需每次变成x后，给x减去v就行了，这样查询时再加上v结果并没变。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">int a[100010], cnt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    int t,x,y;</span><br><span class="line">    cnt=0;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        if(t==3)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;a[x]+cnt&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==2)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            cnt+=x;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(t==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            a[x]=y;</span><br><span class="line">            a[x]-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;托米的简单表示法&quot;&gt;&lt;a href=&quot;#托米的简单表示法&quot; class=&quot;headerlink&quot; title=&quot;托米的简单表示法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/111/A&quot; target=&quot;_
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>[心路历程]心境决定处境，心界决定眼界</title>
    <link href="http://qianyouyou.cn/2018/05/31/2018-05-31/"/>
    <id>http://qianyouyou.cn/2018/05/31/2018-05-31/</id>
    <published>2018-05-31T04:51:35.000Z</published>
    <updated>2018-06-11T06:35:27.499Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸，但此刻的你并没有精力寻找彼岸的方向，因为你的心思全放在了如何不被突如其来的大水淹没，于是你拼命的寻找救命稻草，以阻止自己下沉。就这样，在慌乱的过程中，阻止了你上岸的步伐。</p><p>假如一开始你没有目标，那么此时这种状态并非坏事。因为当你在水里抓住救命稻草之后，会寻找彼岸的方向。如果你足够冷静，此刻你会总结你和他的差距在哪里，从而为自己确立目标，并参考他的经历为自己制定计划。如果你不够冷静，那此时你也许会照搬别人的做法，以别人的目标为自己的目标。这样也许会走很多弯路，做许多无用功，但至少比之前毫无目标浑浑噩噩要好得多，同时这段经历也会成为你如何成长道路上的一比财富。</p><p>倘若你一开始就有自己的目标，有属于自己的彼岸，而当你看到有人已经走到人生的彼岸时，你会怀疑自己走过的路，即使彼岸就在前方，你也会动摇，因为你还没有到达彼岸，没有见过彼岸的风景。假如此时的你停下脚步眺望对方的彼岸，那无疑是致命的。它就像突如其来的潮水，可能会拖延了你前行的道路，更有可能会动摇你前行路上的决心，甚至改变你前进的方向。</p><p>我有一个计算机系的舍友，他的目标是考研。自大一以来一直成绩优异，大二时便已轻松通过四六级，而且交际甚广，可谓前程平坦，身边阳光明媚。但此时，某人给他发了一个自己做的贺卡程序，看起来挺酷，此时他开始动摇了。因为自进校以来同学们一直都是面对黑窗口敲代码，敲出来的也是黑窗口，从来没有想过有人能够编出应用来。他说，当他收到那份礼物时，心中交错的并不是喜悦，而是迷惘。就好像春天的果树看着繁花满庭，而自己却总是开不出花，便开始抱怨自己的价值，而忘记了自己的果实要等到秋天才能品尝。于是当他看到别人已经拥有了强大的实力并且取得相应的成果，而自己还停留在课本中的C语言基础知识，不会应用，顿时思绪万千，怀疑自己走的道路，怀疑学校的课程安排。那种感觉，就像走着走着掉进水里一样。</p><p>此时，他拼命的寻找救命稻草。终于，他抓到了第一根救命稻草。他开始跟着别人做项目，一起写程序，别人打比赛，他便开始模拟比赛。在这段时间，他感到生活变得充实，做事也有动力，因为他也想拥有像那个人一样的实力，像那个人一样去打比赛。但正当他感觉找到目标时，选拔结果出来了，正式比赛的名额没有他，他落选了。此时的他顿时感觉自己又失去了方向。于是他又开始寻找救命稻草。他抓到的第二根救命稻草是校外的编程培训班。于是他果断交了大笔费用去报了培训班。在培训班里，他又燃起了希望，因为在这里，老师讲的一些东西都是课本上所没有的，老师还经常在课堂上带他们写一些小应用，这些都是他们以前不曾经历过的。由于这种模式以前没有接触过，所以便对学的东西燃起了兴趣，即使一切都是从头开始学习，即使许多东西以前都学过。就这样过了两个月，当他冷静下来，重新审视自己时，才发现自己真正要走的路的还是考研，而这段时间所学的技术只是就业路上的一个工具。而培训班中的许多东西其实学校的课程里都有，只是他从未重视过，没接触过的东西未来也会学习。就这样，他又开始了最初的考研复习之路。</p><p>那么，当我们在前行的路上看到别人已经到达人生的彼岸或者接近人生的彼岸时该怎么办呢。</p><p>其实，一个人的心境决定了这个人的处境。假如心中拥抱黑暗，那么眼之所见也会变得暗淡。即使前程平坦，阳光盎然，你也望不见人生的彼岸。假如心中充满光明，那么黑夜也会为你亮起星光。即使道路坎坷，前程黑暗，你也会收获自信坚定向前。</p><p>以我为例，记得之前比赛失利，没有获奖，而朋友却在其他项目中表现优异，此时的我就像《三体》中经历水滴之战惨败而侥幸逃跑的舰队队长一样，当看到章北海率领的舰队未雨绸缪时，眼前是一片黑暗，不由自主地感叹:”好黑，真tm的黑啊”。此刻的我早已迷失了方向，整日思绪想的是同样是付出，朋友们一个个却硕果累累，而我却像墙角的蘑菇怎么也沐浴不到阳光。为了这场比赛，准备了一个多月，那段时间翘了许多节课，一心研究算法，而最后连个证明自己这段时间的成果都没有。眼前面临的是各种各样的考试，以及英语四级考试，顿时怀疑自己之前的付出是否值得。其实在不久之后又有一次比赛，而此时的我却整日处于悲观之中，害怕下次比赛同样拿不到成绩，害怕考试失利，害怕英语四级。此刻的我，感到人人都各有所长，就只有自己一直处于失败当中，人人都比我成功。于是我把自己包裹起来，不喜欢与人交流，感觉每个人都很虚伪，从此变得越来越冷漠。就这样，我一边准备比赛，一边疯狂复习，一边孤独，一边迷惘。由于同时选择多种方向，最终也一事无成。马上就要比赛了，此刻的我偶然间望见教室的窗外阳光依旧明媚，回忆起之前努力奋斗的日子里也是同样的阳光，望着这从未消逝的阳光，我重新总结了一下这段时间的经历，终于明白，其实阳光很好，世界很好，所有人都很好，只是我的心态变得暗淡了。当我重新投入到阳光灿烂的日子里，此时发现，其实许多人都在羡慕我。尽管我没有拿到奖，但这段时间我的实力已经突飞猛进。虽然我没有收获奖杯，但我却收获了成长，坚定了方向。</p><p>所以，心界决定了眼界。当你凝视黑暗的时候，黑暗也在呼唤着你。倘若一个人心中见不到光，那么对他而言，整个世界都是黑暗的。当看到别人取得的成就时，只会是羡慕嫉妒恨，自怨自艾。也许有人会说，悲观，是一种远见。但当一个人始终以悲观的态度看待世界，那么所看到的整个世界只剩下冷漠，背叛，黑暗，而你收获的也只有孤独，失望，迷茫。</p><p>不妨敞开心扉，让阳光渗透到我们的心中。此时你会发现，当你看到别人的成就时，更多的是送去祝福，而不是怀疑自己。这样，就不会迷失方向，同时别人的经历中总结经验，化作自己前行的垫脚石。</p><p>阳光很好，我亦很好，整个世界更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸
      
    
    </summary>
    
      <category term="心路历程" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    
      <category term="散文" scheme="http://qianyouyou.cn/categories/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/%E6%95%A3%E6%96%87/"/>
    
    
      <category term="散文" scheme="http://qianyouyou.cn/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>C/C++结构体中的深copy和浅copy&amp;&amp;结构体偏移量的两种求法</title>
    <link href="http://qianyouyou.cn/2018/05/30/2018-05-30/"/>
    <id>http://qianyouyou.cn/2018/05/30/2018-05-30/</id>
    <published>2018-05-30T11:56:43.000Z</published>
    <updated>2018-05-30T13:36:55.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浅copy："><a href="#浅copy：" class="headerlink" title="浅copy："></a>浅copy：</h2><p>编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，拷贝之后释放内存就不会出现问题。但是如果结构体中含有指针变量的时候，编译器只会copy指针变量，而对应的内存空间却不会缺不再多分配。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">char a[64];</span><br><span class="line">int b;</span><br><span class="line">char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">*to = *from;</span><br><span class="line">//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">note d, e;</span><br><span class="line">strcpy(d.a, &quot;123&quot;);</span><br><span class="line">d.b = 456;</span><br><span class="line">while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(d.c, &quot;789&quot;);</span><br><span class="line">printf(&quot;d的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">my_copy(&amp;d, &amp;e);</span><br><span class="line">printf(&quot;e的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">if (d.c != NULL) &#123;</span><br><span class="line">free(d.c);</span><br><span class="line">d.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此样例为例，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br><span class="line">e的值为：</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure><p>然后接着某些编译器如vs的编译器就会报错。出错位置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是由于将结构体d内存元素直接赋给结构体e时，即进行 <em> e= </em> d操作时，由于结构体中含有指针元素，d结构体中的指针已经动态分配内存，而操作完成之后e中指针的值也会写上d动态分配内存的地址，因此d和e指向同一内存空间。这样当d中指针d.c释放内存之后，由于e.c仍然指向该部分内存，而不指向空，此时会强制释放掉e.c所指向内存，由于此处内存已经释放过了，处于不能被访问状态，而e.c又强制释放该内存，就会造成vs编译器报错。这就是前copy的弊端。</p><h2 id="深copy："><a href="#深copy：" class="headerlink" title="深copy："></a>深copy：</h2><p>编译器会为拷贝的对象分配一定的内存空间。</p><p>以上述代码为例，只需在进行 <em> e= </em> d操作之后再为e.c重新分配内存，然后执行strcpy(e,d)即可。这样e.c和d.c分别指向两块不同的内存，这样就不会出现上面那种错误。</p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECUFE_NO_WARNINGS</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct note &#123;</span><br><span class="line">char a[64];</span><br><span class="line">int b;</span><br><span class="line">char*c;</span><br><span class="line">&#125;note;</span><br><span class="line">void my_copy(note*from, note*to) &#123;</span><br><span class="line">*to = *from;</span><br><span class="line">//memcpy(to,from,sizeof(note));//和上述操作等效</span><br><span class="line">while ((to-&gt;c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(to-&gt;c, from-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">note d, e;</span><br><span class="line">strcpy(d.a, &quot;123&quot;);</span><br><span class="line">d.b = 456;</span><br><span class="line">while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL)</span><br><span class="line">exit(1);</span><br><span class="line">strcpy(d.c, &quot;789&quot;);</span><br><span class="line">printf(&quot;d的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c);</span><br><span class="line">my_copy(&amp;d, &amp;e);</span><br><span class="line">printf(&quot;e的值为：\n&quot;);</span><br><span class="line">printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c);</span><br><span class="line">if (d.c != NULL) &#123;</span><br><span class="line">free(d.c);</span><br><span class="line">d.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">if (e.c != NULL) &#123;</span><br><span class="line">free(e.c);</span><br><span class="line">e.c = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="偏移量的求法"><a href="#偏移量的求法" class="headerlink" title="偏移量的求法"></a>偏移量的求法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct note&#123;</span><br><span class="line">    char name[64];</span><br><span class="line">    int age;</span><br><span class="line">    int sex;</span><br><span class="line">&#125;a,*p;</span><br><span class="line">p=&amp;a;</span><br></pre></td></tr></table></figure><p>以p为例求p-&gt;age偏移量</p><h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsize = (int)&amp;(p-&gt;age)-(int)p;</span><br></pre></td></tr></table></figure><h3 id="间接法"><a href="#间接法" class="headerlink" title="间接法"></a>间接法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsize = (int)&amp;(((*note)0)-&gt;age);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浅copy：&quot;&gt;&lt;a href=&quot;#浅copy：&quot; class=&quot;headerlink&quot; title=&quot;浅copy：&quot;&gt;&lt;/a&gt;浅copy：&lt;/h2&gt;&lt;p&gt;编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="结构体" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="结构体" scheme="http://qianyouyou.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>关于模拟或暴力类型题的时间复杂度降维优化举例</title>
    <link href="http://qianyouyou.cn/2018/05/29/2018-05-29/"/>
    <id>http://qianyouyou.cn/2018/05/29/2018-05-29/</id>
    <published>2018-05-29T12:39:04.000Z</published>
    <updated>2018-05-29T12:50:23.458Z</updated>
    
    <content type="html"><![CDATA[<p>首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即实现由0(…)0(N)-&gt;0(…)0(1)的降维过程。但推导公式往往是一件很麻烦的事情，因此推导公式是模拟类题的关键。以下两道题原本是用模拟或暴力来解决，但其实它们都是可以优化的，例如第一题只需要求周期内的数与周期即可，不用遍历全部数，第2题只需对该数n进行分析即可，时间复杂度0(1)，不用从1遍历到n一个个进行统计。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>百度熊对数学一直都非常感兴趣。最近在学习斐波那契数列的它，向你展示了一个数字串，它称之为“斐波那契”串：</p><p>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11235813471123581347112358…</span><br></pre></td></tr></table></figure><p>聪明的你当然一眼就看出了这个串是这么构造的：</p><ol><li><p>先写下两位在0~9范围内的数字a, b，构成串ab；</p></li><li><p>取串最后的两位数字相加，将和写在串的最后面。</p></li></ol><p>上面百度熊向你展示的串就是取a = b = 1构造出来的串。</p><p>显然，步骤1之后不停地进行步骤2，数字串可以无限扩展。现在，百度熊希望知道串的第n位是什么数字。</p><p>输入数据的第一行为一个整数T（1 ≤ T ≤1000）, 表示有T组测试数据；每组测试数据为三个正整数a, b, n（0 ≤ a, b &lt; 10, 0 &lt; n ≤109）。</p><p>对于每组测试数据，输出一行“Case #c: ans”（不包含引号） c是测试数据的组数，从1开始。</p><p>提示：</p><ol><li><p>对于第一、二组数据，串为112358134711235…</p></li><li><p>对于第三组数据，串为14591459145914…</p></li></ol><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">1 1 8</span><br><span class="line">1 4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case #1: 1</span><br><span class="line">Case #2: 3</span><br><span class="line">Case #3: 9</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 500;</span><br><span class="line">int t, c, d, n, cyc, cnt;</span><br><span class="line">int a[maxn], vis[maxn];</span><br><span class="line">int init()&#123;</span><br><span class="line">    memset(a,0,sizeof(a));</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    a[1] = c;</span><br><span class="line">    a[2] = d;</span><br><span class="line">    cnt = 2;</span><br><span class="line">    while(!vis[a[cnt-1]*10+a[cnt-0]])&#123;</span><br><span class="line">        vis[a[cnt-1]*10+a[cnt]] = cnt;</span><br><span class="line">        int tmp = a[cnt-1] + a[cnt];</span><br><span class="line">        if(tmp&lt;10)</span><br><span class="line">            a[++cnt]=tmp;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[++cnt]=tmp/10;</span><br><span class="line">            a[++cnt]=tmp%10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return vis[a[cnt-1]*10+a[cnt]];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    for(int i = 1;i&lt;=t;i++)&#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; d &gt;&gt; n;</span><br><span class="line">        int res = init();</span><br><span class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;;</span><br><span class="line">        if(cnt&gt;=n)</span><br><span class="line">            cout&lt;&lt;a[n]&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;a[res+(n-res)%(cnt-res)]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h2><p>试计算在区间 11 到 nn 的所有整数中，数字 xx（0 \leq x \leq 90≤x≤9）共出现了多少次？例如，在 11 到 1111 中，即在 11、22、33、44、55、66、77、88、99、1010、1111 中，数字 11 出现了 4 次。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入共 1 行，包含 2 个整数 nn、xx，之间用一个空格隔开。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出共 1 行，包含一个整数，表示 xx 出现的次数。</p><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 100% 的数据，1 \leq n \leq 1,000,0001≤n≤1,000,000，0 \leq x \leq 90≤x≤9。</p><p>忽略每行输出的末尾多余空格</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    int cnt = 0, res = 1, re = 1;</span><br><span class="line">    int tmp = n;</span><br><span class="line">    if(x)&#123;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            int mod = tmp%10;</span><br><span class="line">            cnt+=(res-re)/10*mod;</span><br><span class="line">            if(mod&gt;x)</span><br><span class="line">                cnt+=re;</span><br><span class="line">            else if(mod==x)</span><br><span class="line">                cnt+=n%re+1;</span><br><span class="line">            re*=10;</span><br><span class="line">            res*=10;</span><br><span class="line">            res+=re;</span><br><span class="line">            tmp/=10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(int i = 1;i&lt;=n;i++)</span><br><span class="line">            for(int j=i;j;j/=10)</span><br><span class="line">                if(j%10==x)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟" scheme="http://qianyouyou.cn/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="暴力枚举" scheme="http://qianyouyou.cn/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>[C指针进阶]二级指针做输入的3种内存模型</title>
    <link href="http://qianyouyou.cn/2018/05/26/2018-05-26/"/>
    <id>http://qianyouyou.cn/2018/05/26/2018-05-26/</id>
    <published>2018-05-26T06:24:45.000Z</published>
    <updated>2018-05-30T13:30:40.171Z</updated>
    
    <content type="html"><![CDATA[<p>对于指针，我们只需要从两个角度进行分析即可。</p><p>第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） </p><p>第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一维的还是二维的。 </p><p>今天分析的二维指针三种内存模型都是指针做输入的情况，在主调函数中分配内存。 </p><p>在分析指针之前，先回顾一下内存四区的知识。首先我们知道内存分为5大区，我们暂把BSS段与数据段合称为全局区或者常量区，构成内存四区。以下是内存5大区具体概况。</p><h2 id="内存5大区"><a href="#内存5大区" class="headerlink" title="内存5大区"></a>内存5大区</h2><ul><li><p><strong>BSS段( bss segment )</strong></p><p>通常是指用来存放程序中<code>未初始化的全局变量和静态变量</code> （这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。既然都是0那么就<code>没必要把每个0都存储起来</code>,从而节省磁盘空间,这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。</p></li></ul><hr><ul><li><p><strong>数据段(data segment)</strong></p><p>通常是指用来存放程序中已经<code>初始化的全局变量和静态变量</code>的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,但一般都是放在只读数据段中。</p></li></ul><hr><ul><li><p><strong>代码段(code segment/text segment)</strong></p><p>通常是指用来存放<code>程序执行代码的一块内存区域</code>。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。</p></li></ul><hr><ul><li><p><strong>堆(heap)</strong></p><p>堆是用于存放进程运行中被<code>动态分配的内存段</code>,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减)</p></li></ul><hr><ul><li><p><strong>栈 (stack)</strong></p><p>栈又称堆栈, 是<code>用户存放程序临时创建的局部变量</code>,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在数据段中存放变 量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的先进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。 </p></li></ul><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-25-%E5%86%85%E5%AD%985%E5%8C%BA.png" alt="内存分区图"></p><h2 id="二阶指针做输入的3种内存模型"><a href="#二阶指针做输入的3种内存模型" class="headerlink" title="二阶指针做输入的3种内存模型"></a>二阶指针做输入的3种内存模型</h2><p>接下来我们来讨论二阶指针做输入的3种内存模型。</p><h3 id="第1种"><a href="#第1种" class="headerlink" title="第1种"></a>第1种</h3><p>首先第一种就是指针数组，以字符型指针数组为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char*p1[10];</span><br></pre></td></tr></table></figure><p>指针数组的实质是表示存放指针的数组。 </p><h3 id="第2种"><a href="#第2种" class="headerlink" title="第2种"></a>第2种</h3><p>第二种为二维数组，以字符型二维数组为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char p2[3][4];</span><br></pre></td></tr></table></figure><h3 id="第3种"><a href="#第3种" class="headerlink" title="第3种"></a>第3种</h3><p>第三种为二维指针，以字符型二维指针为例定义方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char **p3;</span><br></pre></td></tr></table></figure><p>二维指针是一个存放指针的指针，因此使用前需先开辟一段空间。 </p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="指针数组与二维指针的区别："><a href="#指针数组与二维指针的区别：" class="headerlink" title="指针数组与二维指针的区别："></a>指针数组与二维指针的区别：</h4><p>由于二维指针储存的是指针，因此二维指针首先需要开辟空间，然后再在子元素上继续开辟空间，因此需要两步完成。</p><p>而指针数组由于本质上是数组，因此省略了第1步，只需在子元素上继续开辟空间。因此只需要1步完成。</p><p>以动态分配内存为例：</p><p>第1步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof(char *));//等价于 *ptr [3];</span><br></pre></td></tr></table></figure><p>第2步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr =malloc(3 *sizeof (char *));等价于 *ptr [3];</span><br><span class="line">for(i =0;i&lt;3;i++)</span><br><span class="line">    ptr[i] =malloc(sizeof(char)*10);//表示可以存放长度为10 的字符串。</span><br></pre></td></tr></table></figure><p>指针数组只需第2步，二维指针则需要1,2步。</p><p>而除此之外，基本再没有什么区别。他们的步长都是4，即一个指针的内存大小。</p><h4 id="指针数组与数组指针的区别："><a href="#指针数组与数组指针的区别：" class="headerlink" title="指针数组与数组指针的区别："></a>指针数组与数组指针的区别：</h4><p>首先，我们知道，二维数组ptr[2].[2]，ptr的实质是一个数组指针。我们知道，对于一维指针数组a[2]，a本质是指针，只不过a是一个常量指针，即a的值不能被修改。那么对于二维数组ptr[2].[2],ptr是一个常量数组指针，即ptr的值不可修改。</p><p>那么，他们本质的区别是什么呢。首先，对于char <em>p[3]，他的步长是4。即一个指针的内存大小。 </em> (p+1)=p[1],(int)(p+1)-(int)p=4。对于char( <em>p )[3],他的步长是3，即一个数组内存大小。 </em>(p+1) = p[1].[3],(int)(p+1)-(int)p=3。所以这就是为什么指针数组和数组指针不能相互赋值的原因。</p><h2 id="内存模型示意图"><a href="#内存模型示意图" class="headerlink" title="内存模型示意图"></a>内存模型示意图</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-26-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是针对二维指针的3种内存模型进行排序的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">/*排序并输出第1种内存模型:指针数组*/</span><br><span class="line">void sort_myArray1(char **myArray, int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针的指向*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char *tmp = myArray[j];</span><br><span class="line">myArray[j] = myArray[j - 1];</span><br><span class="line">myArray[j - 1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第2种内存模型：二维数组（数组指针）*/</span><br><span class="line">void sort_myArray2(char(*myArray)[4], int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针所指向内存的值*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char tmp[4];</span><br><span class="line">strcpy(tmp, myArray[j]);</span><br><span class="line">strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">strcpy(myArray[j - 1], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*排序并输出第3种内存模型：二维指针*/</span><br><span class="line">void sort_myArray3(char **myArray, int len) &#123;</span><br><span class="line">printf(&quot;排序前：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;******************\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)/*改变指针所指向内存的值，也可以改写成改变指针的指向*/</span><br><span class="line">for (int j = len - 1; j &gt; i; j--) &#123;</span><br><span class="line">if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123;</span><br><span class="line">char tmp[4];</span><br><span class="line">strcpy(tmp, myArray[j]);</span><br><span class="line">strcpy(myArray[j], myArray[j - 1]);</span><br><span class="line">strcpy(myArray[j - 1], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;排序后：\n&quot;);</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">printf(&quot;%s\n&quot;, myArray[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/*为二级指针分配动态内存并赋值*/</span><br><span class="line">char**get_myArray3(int len) &#123;</span><br><span class="line">char**myArray = NULL;</span><br><span class="line">while ((myArray = (char**)malloc(3 * sizeof(char*))) == NULL) &#123;</span><br><span class="line">printf(&quot;Error.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">while ((myArray[i] = (char*)calloc(100, sizeof(char))) == NULL) &#123;</span><br><span class="line">printf(&quot;Error.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">sprintf(myArray[i], &quot;%d%d%d&quot;, i + 1, i + 2, i + 3);</span><br><span class="line">&#125;</span><br><span class="line">return myArray;</span><br><span class="line">&#125;</span><br><span class="line">/*将动态分配的内存空间释放掉*/</span><br><span class="line">void init_myArray3(char**myArray, int len) &#123;</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">if (myArray[i] != NULL) &#123;</span><br><span class="line">free(myArray[i]);</span><br><span class="line">myArray[i] = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">char*p1[] = &#123; &quot;123&quot;,&quot;456&quot;,&quot;789&quot; &#125;;/*第1种内存模型：指针数组*/</span><br><span class="line">char p2[3][4] = &#123; &quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot; &#125;;/*第2种内存模型：多维数组*/</span><br><span class="line">char**p3 = get_myArray3(3);/*第3种内存模型：二维指针*/</span><br><span class="line">sort_myArray1(p1, sizeof(p1) / sizeof(p1[0]));/*数组的指针个数*/</span><br><span class="line">sort_myArray2(p2, sizeof(p2) / sizeof(p2[0]));/*数组的行数*/</span><br><span class="line">sort_myArray3(p3, 3);/*由于sizeof(p3)为4，即一个指针的大小，故不能用sizeof(p3) / sizeof(p2[3])*/</span><br><span class="line">init_myArray3(p3, 3);</span><br><span class="line">if (p3 != NULL)</span><br><span class="line">free(p3);/*释放掉二维指针分配的内存*/</span><br><span class="line">p3 = NULL;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于指针，我们只需要从两个角度进行分析即可。&lt;/p&gt;
&lt;p&gt;第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） &lt;/p&gt;
&lt;p&gt;第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E6%8C%87%E9%92%88/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>[C常量]C语言中的伪装大佬——伪常量const</title>
    <link href="http://qianyouyou.cn/2018/05/25/2018-05-25-1/"/>
    <id>http://qianyouyou.cn/2018/05/25/2018-05-25-1/</id>
    <published>2018-05-25T15:35:44.000Z</published>
    <updated>2018-05-26T10:44:02.243Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的const列出来，以免之后犯错。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先以int为例定义整形常量a的两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br></pre></td></tr></table></figure><p>当然，这两种方法其实是一样的，都代表的是整形常量。对于其他类型也是同样的方法。</p><p>不过对于指针，就有点特别了。首先强调，const和 <em> 的优先级是 </em> 优先级高于const。以下是以字符串为例的</p><p>3种定义方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *p;//char const *p;</span><br><span class="line">char * const p;</span><br><span class="line">const char * const p;//char const * const p;</span><br></pre></td></tr></table></figure><p>第一种指的是p是指向常量字符型数的指针，所指向的内存数据不可以被修改，但是本身可修改。</p><p>第2种指的是p是指向字符型数的常指针，所指向的内存数据可以被修改，但是本身不可被修改。</p><p>第3种是指向常量字符型数的常指针，所指向的内存数据补可被修改，本身也不可被修改。</p><h2 id="伪常量"><a href="#伪常量" class="headerlink" title="伪常量"></a>伪常量</h2><p>用法介绍完了，但为什么说C的const是伪常量呢？因为常量是不可被更改的，但const可以通过简介赋值所改变。我们首先说一下C中的const使用时需要注意的一些细节。</p><p>const是伪常量，无法用于数组的初始化和全局变量的初始化,本质就是限定一个变量不能直接赋值。</p><p>　　如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 #define A 10</span><br><span class="line">2 int arr[A];</span><br><span class="line">3 </span><br><span class="line">4 //const本质，伪常量 ,无法用于数组初始化和全局变量初始化</span><br><span class="line">5 /*</span><br><span class="line">6 const int B = 10;</span><br><span class="line">7 int arr[B];</span><br><span class="line">8 */</span><br></pre></td></tr></table></figure><p>　　但是如果局部变量是能够初始化编译并运行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 void main()</span><br><span class="line">2 &#123;</span><br><span class="line">3     const int B = 10;</span><br><span class="line">4     int arr[B];</span><br><span class="line">5 &#125;</span><br></pre></td></tr></table></figure><p>　　const是伪常量，都知道常量是不能改变值的。例如这样是根本无法编译的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 void main() &#123;</span><br><span class="line">2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line">3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line">4     const int num = 10;//num就是一个常量</span><br><span class="line">5     //num = 11; //const本质，限定一个变量不能直接赋值</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>　　前面一直强调const是伪常量，因为可以间接的去改变它的值。利用指针变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 void main() &#123;</span><br><span class="line"> 2     //num在栈区，只有栈区会自动回收释放</span><br><span class="line"> 3     //局部const常量在栈区，而不在静态区(静态区会一直存在)</span><br><span class="line"> 4     const int num = 10;//num就是一个常量</span><br><span class="line"> 5     //num = 11; //error const本质，限定一个变量不能直接赋值</span><br><span class="line"> 6 </span><br><span class="line"> 7     //间接改变常量值</span><br><span class="line"> 8     const int *p = &amp;num;//定义一个指针指向一个常量，存储num的地址</span><br><span class="line"> 9     int *pv = (int *)p;//对指向常量的指针进行强制转换</span><br><span class="line">10     *pv = 8;//对指针指向内容赋值</span><br><span class="line">11 </span><br><span class="line">12     printf(&quot;%d&quot;,num); //8</span><br><span class="line">13 </span><br><span class="line">14 &#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>c语言的const是冒牌货。C语言const的含义是被称为一个不能被改变的普通变量 ，它会分配内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的cons
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="C/C++" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/"/>
    
      <category term="常量" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/C-C/%E5%B8%B8%E9%87%8F/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="指针" scheme="http://qianyouyou.cn/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="const" scheme="http://qianyouyou.cn/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>[组合数学]取石子</title>
    <link href="http://qianyouyou.cn/2018/05/25/2018-05-25/"/>
    <id>http://qianyouyou.cn/2018/05/25/2018-05-25/</id>
    <published>2018-05-25T14:42:37.000Z</published>
    <updated>2018-05-25T15:31:38.584Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。</p><h2 id="取石子"><a href="#取石子" class="headerlink" title="取石子"></a><a href="https://www.nowcoder.com/acm/contest/113/A" target="_blank" rel="noopener">取石子</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出四堆石子，石子数分别为a,b,c,d。规定每次只能从堆顶取走石子，问取走所有石子的方案数。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一行内读入四个由空格分隔的整数a,b,c,d， 输入均为不超过500的正整数</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示答案，答案对109+7取模</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5 4 2</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2522520</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p>输入均为不超过500的正整数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>我们一堆一堆的考虑。第一堆a，第2堆b，第3堆c，第4堆d。假如只有一堆，则只有1种情况，即C(a,a)。假如有两堆，我们可以当做这两堆石子的排列组合。可以算出两堆石子的方案数。即C(b,a+b)。第三堆我们可以把前两堆看成一堆，然后继续排列组合，即C(c,a+b+c)。第4队即C(d,a+b+c+d)。最后全部相乘即可，即C(a,a) <em> C(b,a+b) </em> C(c,a+b+c)*C(d,a+b+c+d)。</p><h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><p>首先想到暴力枚举，虽然一定超时。以下是代码。只需要把所有情况列一遍即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">ll a[4];</span><br><span class="line">ll cnt = 0;</span><br><span class="line">void dfs(ll a, ll b, ll c, ll d) &#123;</span><br><span class="line">if (!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!d) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">cnt %= 1000000000 + 7;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (a)</span><br><span class="line">dfs(a - 1, b, c, d);</span><br><span class="line">if (b)</span><br><span class="line">dfs(a, b - 1, c, d);</span><br><span class="line">if (c)</span><br><span class="line">dfs(a, b, c - 1, d);</span><br><span class="line">if (d)</span><br><span class="line">dfs(a, b, c, d - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">dfs(a[0], a[1], a[2], a[3]);</span><br><span class="line">printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>由于数据过大，c++没有大数类，所以用python首先A了一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = input().split()</span><br><span class="line">ans = 1</span><br><span class="line">sum = [int(f[0]),0,0,0]</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    sum[i]=sum[i-1]+int(f[i])</span><br><span class="line">    for j in range(sum[i]-int(f[i])+1,sum[i]+1):</span><br><span class="line">        ans*=j</span><br><span class="line">for i in range(1,4):</span><br><span class="line">    for j in range(1,int(f[i])+1):</span><br><span class="line">        ans//=j</span><br><span class="line">ans%=1000000007</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><p>由于acm不能用python，所以只能再考虑c++。首先由于涉及到除法，所以不能直接取余。</p><p>我没知道公式：C(M,N)=C(M-1,N)+C(M-1，N-1)，这样把除法转化成加法，就可以模运算了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 501;</span><br><span class="line">const ll mod = 1000000007;</span><br><span class="line">ll a[4], sum[4] = &#123; 0 &#125;;</span><br><span class="line">ll dp[maxn * 4][maxn * 4];</span><br><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">init();</span><br><span class="line">ll ans = 1;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">!i ? sum[i] = 0 : sum[i] = sum[i - 1];</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += a[i];</span><br><span class="line">if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">ans *= dp[sum[i]][a[i]];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="C-M-N-模板"><a href="#C-M-N-模板" class="headerlink" title="C(M,N)模板"></a>C(M,N)模板</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">dp[0][0] = 0;</span><br><span class="line">for (int i = 1; i &lt; 4 * maxn; i++) &#123;</span><br><span class="line">dp[i][0] = 1;</span><br><span class="line">for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">dp[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。&lt;/p&gt;
&lt;h2 id=&quot;取石子&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="http://qianyouyou.cn/tags/python/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="暴力枚举" scheme="http://qianyouyou.cn/tags/%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>[数据库]关系数据库标准语言sql</title>
    <link href="http://qianyouyou.cn/2018/05/22/2018-05-22/"/>
    <id>http://qianyouyou.cn/2018/05/22/2018-05-22/</id>
    <published>2018-05-22T04:39:35.000Z</published>
    <updated>2018-05-22T06:18:34.144Z</updated>
    
    <content type="html"><![CDATA[<p>有些人生而成功，像你。有些人生而失败，像我。——随笔</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SQL（Structured Query Language）</p><p>结构化查询语言，是关系数据库的标准语言。</p><p>SQL是一个通用的、功能极强的关系数据库语言。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="综合统一"><a href="#综合统一" class="headerlink" title="综合统一"></a>综合统一</h4><p>集数据查询，数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。</p><p>可以独立完成数据库生命周期中的全部活动：</p><ul><li>定义关系模式，插入数据，建立数据库； </li><li>对数据库中的数据进行查询和更新； </li><li>数据库重构和维护 </li><li>数据库安全性、完整性控制等</li></ul><p>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。</p><p>数据操作符统一</p><h4 id="高度非过程化"><a href="#高度非过程化" class="headerlink" title="高度非过程化"></a>高度非过程化</h4><p>非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径。</p><p>SQL只要提出“做什么”，无须了解存取路径。</p><p>存取路径的选择以及SQL的操作过程由系统自动完成。</p><h4 id="面向集合的操作方式"><a href="#面向集合的操作方式" class="headerlink" title="面向集合的操作方式"></a>面向集合的操作方式</h4><p>非关系数据模型采用面向记录的操作方式，操作对象是一条记录。</p><p>SQL采用集合操作方式 </p><ul><li><p>操作对象、查找结果可以是元组的集合 </p></li><li><p>一次插入、删除、更新操作的对象可以是元组的集合</p></li></ul><h4 id="以同一种语法结构提供多种使用方式"><a href="#以同一种语法结构提供多种使用方式" class="headerlink" title="以同一种语法结构提供多种使用方式"></a>以同一种语法结构提供多种使用方式</h4><p>SQL是独立的语言，能够独立地用于联机交互的使用方式。</p><p>SQL又是嵌入式语言，SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用。</p><h4 id="语言简洁，易学易用"><a href="#语言简洁，易学易用" class="headerlink" title="语言简洁，易学易用"></a>语言简洁，易学易用</h4><p>SQL功能极强，完成核心功能只用了9个动词。</p><table><thead><tr><th>SQL功能</th><th>动词</th></tr></thead><tbody><tr><td>数据查询</td><td>SELECT</td></tr><tr><td>数据定义</td><td>CREATE, DROP, ALTER</td></tr><tr><td>数据操纵</td><td>INSERT, UPDATE, DELETE</td></tr><tr><td>数据控制</td><td>GRANT, REVOKE</td></tr></tbody></table><h3 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h3><p>SQL支持关系数据库三级模式结构</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-22-sql%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" alt=""></p><h4 id="基本表"><a href="#基本表" class="headerlink" title="基本表"></a>基本表</h4><p>本身独立存在的表</p><p>SQL中一个关系就对应一个基本表</p><p>一个(或多个)基本表对应一个存储文件</p><p>一个表可以带若干索引</p><h4 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h4><p>逻辑结构组成了关系数据库的内模式</p><p>物理结构是任意的，对用户透明</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>从一个或几个基本表</p><p>导出的表数据库中只存放视图的定义而不存放视图对应的数据</p><p>视图是一个虚表</p><p>用户可以在视图上再定义视图</p><h2 id="学生-课程数据库"><a href="#学生-课程数据库" class="headerlink" title="学生-课程数据库"></a>学生-课程数据库</h2><h3 id="学生-课程模式-S-T"><a href="#学生-课程模式-S-T" class="headerlink" title="学生-课程模式 S-T :"></a>学生-课程模式 S-T :</h3><p>学生表：Student(Sno,Sname,Ssex,Sage,Sdept)    </p><p>课程表：Course(Cno,Cname,Cpno,Ccredit)    </p><p>学生选课表：SC(Sno,Cno,Grade)</p><h3 id="Student表"><a href="#Student表" class="headerlink" title="Student表"></a>Student表</h3><table><thead><tr><th style="text-align:center">学  号 Sno</th><th style="text-align:center">姓  名 Sname</th><th style="text-align:center">性  别  Ssex</th><th style="text-align:center">年  龄  Sage</th><th style="text-align:center">所 在 系  Sdept</th></tr></thead><tbody><tr><td style="text-align:center">200215121</td><td style="text-align:center">李勇</td><td style="text-align:center">男</td><td style="text-align:center">20</td><td style="text-align:center">CS</td></tr><tr><td style="text-align:center">200215122</td><td style="text-align:center">刘晨</td><td style="text-align:center">女</td><td style="text-align:center">19</td><td style="text-align:center">CS</td></tr><tr><td style="text-align:center">200215123</td><td style="text-align:center">王敏</td><td style="text-align:center">女</td><td style="text-align:center">18</td><td style="text-align:center">MA</td></tr><tr><td style="text-align:center">200515125</td><td style="text-align:center">张立</td><td style="text-align:center">男</td><td style="text-align:center">19</td><td style="text-align:center">IS</td></tr></tbody></table><h3 id="Course表"><a href="#Course表" class="headerlink" title="Course表"></a>Course表</h3><table><thead><tr><th style="text-align:center">课程号 Cno</th><th style="text-align:center">课程名 Cname</th><th style="text-align:center">先行课 Cpno</th><th style="text-align:center">学分 Ccredit</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">数据库</td><td style="text-align:center">5</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">数学</td><td style="text-align:center"></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">信息系统</td><td style="text-align:center">1</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">操作系统</td><td style="text-align:center">6</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">数据结构</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">数据处理</td><td style="text-align:center"></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">PASCAL语言</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr></tbody></table><h3 id="SC表"><a href="#SC表" class="headerlink" title="SC表"></a>SC表</h3><table><thead><tr><th style="text-align:center">学 号 Sno</th><th style="text-align:center">课程号   Cno</th><th style="text-align:center">成绩     Grade</th></tr></thead><tbody><tr><td style="text-align:center">200215121</td><td style="text-align:center">1</td><td style="text-align:center">92</td></tr><tr><td style="text-align:center">200215121</td><td style="text-align:center">2</td><td style="text-align:center">85</td></tr><tr><td style="text-align:center">200215121</td><td style="text-align:center">3</td><td style="text-align:center">88</td></tr><tr><td style="text-align:center">200215122</td><td style="text-align:center">2</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">200215122</td><td style="text-align:center">3</td><td style="text-align:center">80</td></tr></tbody></table><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL的数据定义功能: 模式定义、表定义、视图和索引的定义</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-22-sql%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89.png" alt=""></p><h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>[例1]定义一个学生-课程模式S-T</p><p><strong>CREATE SCHEMA “S-T” AUTHORIZATION WANG;</strong></p><p>为用户WANG定义了一个模式S-T</p><p>[例2]<strong>CREATE SCHEMA AUTHORIZATION WANG；</strong></p><p>&lt;模式名&gt;隐含为用户名WANG</p><p>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</p><h4 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h4><p>定义模式实际上定义了一个<strong>命名空间</strong></p><p>在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。</p><p>在<strong>CREATE SCHEMA</strong>中可以接受<strong>CREATE TABLE</strong>，<strong>CREATE VIEW</strong>和<strong>GRANT</strong>子句。</p><p><strong>CREATE SCHEMA [&lt;模式名&gt;] AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</strong></p><p>[例3]</p><p><strong>CREATE SCHEMA TEST AUTHORIZATION ZHANG</strong></p><p>​     <strong>CREATE TABLE TAB1(COL1 SMALLINT，</strong></p><p>​                                             <strong>COL2 INT，</strong></p><p>​                                            <strong>COL3 CHAR(20)，</strong></p><p>​                                            <strong>COL4 NUMERIC(10，3)，</strong></p><p>​                                            <strong>COL5 DECIMAL(5，2)</strong></p><p>​                                          <strong>)；</strong></p><p>​    为用户ZHANG创建了一个模式TEST，并在其中定义了一个表TAB1。</p><h4 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h4><p><strong>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</strong></p><p>CASCADE(级联)    </p><p>删除模式的同时把该模式中所有的数据库对象全部删除RESTRICT(限制)   </p><p>如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。</p><p>当该模式中没有任何下属的对象时才能执行。</p><p>[例4]  <strong>DROP SCHEMA TEST CASCADE；</strong></p><p>​         删除模式ZHANG</p><p>​         同时该模式中定义的表TAB1也被删除</p><h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><h4 id="定义基本表"><a href="#定义基本表" class="headerlink" title="定义基本表"></a>定义基本表</h4><p><strong>CREATE TABLE &lt;表名&gt;</strong></p><p>​      <strong>（&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ]</strong></p><p>​    <strong>[，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] …</strong></p><p>​    <strong>[，&lt;表级完整性约束条件&gt; ] ）；</strong></p><p>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。</p><p>[例5]  建立“学生”表Student，学号是主码，姓名取值唯一。</p><p>CREATE TABLE Student</p><p>​                    (Sno   CHAR(9) <strong>PRIMARY KEY</strong>， /<em> 列级完整性约束条件 </em>/</p><p>​            Sname  CHAR(20) <strong>UNIQUE</strong>，     /<em> Sname取唯一值</em>/  </p><p>​            Ssex    CHAR(2)，</p><p>​            Sage   SMALLINT，</p><p>​             Sdept  CHAR(20)</p><p>​            )；</p><p>​            [，<strong>PRIMARY KEY （Sno）</strong>] </p><p>[例6] 建立一个“课程”表Course</p><p>CREATE TABLE  Course</p><p>​               ( Cno       CHAR(4) PRIMARY KEY，</p><p>​                 Cname  CHAR(40)，</p><p>​                 Cpno     CHAR(4) ，    /<em> 先行课 </em>/</p><p>​                    Ccredit  SMALLINT，</p><p>​                FOREIGN KEY (Cpno) REFERENCES  Course(Cno)    /<em> Cpno是外码，被参照表是Course，被参照列是Cno </em>/</p><p>​             ); </p><p>[例7]  建立一个“学生选课”表SC</p><p>CREATE TABLE  SC</p><p>​           (Sno  CHAR(9)，</p><p>​        Cno  CHAR(4)，</p><p>​        Grade    SMALLINT，</p><p>​           PRIMARY KEY (Sno，Cno)，/<em> 主码由两个属性构成，必须作为表级完整性进行定义</em>/</p><p>​    FOREIGN KEY (Sno) REFERENCES Student(Sno)，    /<em> 表级完整性约束条件，Sno是外码，被参照表是Student </em>/ </p><p>​    FOREIGN KEY (Cno) REFERENCES Course(Cno)     /<em> 表级完整性约束条件， Cno是外码，被参照表是Course</em>/    </p><p>); </p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>SQL中域的概念用数据类型来实现</p><p>定义表的属性时 需要指明其数据类型及长度</p><p>选用哪种数据类型</p><ul><li><p>取值范围</p></li><li><p>要做哪些运算</p></li></ul><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>CHAR(n)</td><td>长度为n的定长字符串</td></tr><tr><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr><td>INT</td><td>长整数（也可以写作INTEGER）</td></tr><tr><td>SMALLINT</td><td>短整数</td></tr><tr><td>NUMERIC(p，d)</td><td>定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字</td></tr><tr><td>REAL</td><td>取决于机器精度的浮点数</td></tr><tr><td>Double Precision</td><td>取决于机器精度的双精度浮点数</td></tr><tr><td>FLOAT(n)</td><td>浮点数，精度至少为n位数字</td></tr><tr><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr></tbody></table><h4 id="模式与表"><a href="#模式与表" class="headerlink" title="模式与表"></a>模式与表</h4><p>每一个基本表都属于某一个模式</p><p>一个模式包含多个基本表</p><h5 id="定义基本表所属模式"><a href="#定义基本表所属模式" class="headerlink" title="定义基本表所属模式"></a>定义基本表所属模式</h5><p>方法一：在表名中明显地给出模式名 </p><p>Create table “S-T”.Student（……）;   /<em>模式名为 S-T</em>/</p><p>Create table “S-T”.Cource（……）;</p><p>Create table “S-T”.SC（……）; </p><p>方法二：在创建模式语句中同时创建表 </p><p>方法三：设置所属的模式</p><p>创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p><p>RDBMS会使用模式列表中第一个存在的模式作为数据库对象的模式名 。</p><p>若搜索路径中的模式名都不存在，系统将给出错误 </p><p>显示当前的搜索路径： SHOW search_path; </p><p>搜索路径的当前默认值是：$user， PUBLIC</p><p>先搜索与用户名相同的模式，若不存在，则使用PUBLIC </p><h5 id="模式与表-1"><a href="#模式与表-1" class="headerlink" title="模式与表"></a>模式与表</h5><p>DBA用户可以设置搜索路径，然后定义基本表</p><p>​      <strong>SET search_path TO “S-T”，PUBLIC；</strong></p><p>​     <strong>Create table Student（……）;</strong> </p><p>  结果建立了S-T.Student基本表。</p><p>RDBMS发现搜索路径中第一个模式名S-T存在，就把该模式作为基本表Student所属的模式。</p><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><p>ALTER TABLE &lt;表名&gt;</p><p>[ ADD [&lt;新列名&gt; &lt;数据类型&gt;].[完整性约束 ]]</p><p>[ DROP &lt;完整性约束名&gt; ]</p><p>[ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]；</p><p>  <strong>MODIFY</strong></p><p>  <strong>约束（属性名）</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有些人生而成功，像你。有些人生而失败，像我。——随笔&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SQL（Structured Query Language）&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="关系数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="sql语言" scheme="http://qianyouyou.cn/tags/sql%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>[数据库]数据库概论基础整理</title>
    <link href="http://qianyouyou.cn/2018/05/21/2018-05-21/"/>
    <id>http://qianyouyou.cn/2018/05/21/2018-05-21/</id>
    <published>2018-05-21T05:29:08.000Z</published>
    <updated>2018-05-21T14:52:40.030Z</updated>
    
    <content type="html"><![CDATA[<p>努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔</p><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><h4 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h4><p>数据(Data)：数据库中存储的基本对象。</p><p>定义：描述事物的符号记录</p><p>种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>数据与其语义是不可分的。</p><p>eg：</p><p>54是一个数据</p><p>语义1：学生某门课的成绩</p><p>语义2：某人的体重</p><p>语义3：计算机系2011级学生人数</p><p>eg:</p><p>学生档案中的学生记录</p><p>（张三，男，19941014，陕西西安市，计算机系，2011）</p><p>语义：学生姓名、性别、出生年月、籍贯、所在院系、入学时间</p><p>解释：张三是个大学生，1994年10月14日出生，陕西省西安市人，2011年考入计算机系</p><h4 id="数据库（DB）"><a href="#数据库（DB）" class="headerlink" title="数据库（DB）"></a>数据库（DB）</h4><p>数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>数据按一定的数据模型组织、描述和储存</p><p>可为各种用户共享</p><p>冗余度较小</p><p>数据独立性较高</p><p>易扩展</p><h4 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>位于用户与操作系统之间的一层数据管理软件。</p><p>是基础软件，是一个大型复杂的软件系统</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>科学地组织和存储数据、高效地获取和维护数据。</p><h5 id="数据库在计算机系统中的位置"><a href="#数据库在计算机系统中的位置" class="headerlink" title="数据库在计算机系统中的位置"></a>数据库在计算机系统中的位置</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-DBMS.png" alt=""></p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><table><thead><tr><th><strong>数据定义功能</strong></th><th>提供数据定义语言(DDL)</th><th>定义数据库中的数据对象</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>数据组织、存储和管理</strong></td><td>分类组织、存储和管理各种数据</td><td>确定组织数据的文件结构和存取方式</td><td>实现数据之间的联系</td><td>提供多种存取方法提高存取效率</td><td></td></tr><tr><td><strong>数据操纵功能</strong></td><td>提供数据操纵语言(DML)</td><td>实现对数据库的基本操作  (增删改查)</td><td></td><td></td><td></td></tr><tr><td><strong>数据库的事务管理和运行管理</strong></td><td>数据库在建立、运行和维护时由DBMS统一管理和控制</td><td>保证数据的安全性、完整性、多用户对数据的并发使用</td><td>发生故障后的系统恢复</td><td></td><td></td></tr><tr><td><strong>数据库的建立和维护功能(实用程序和管理工具)</strong></td><td>数据库初始数据装载转换</td><td>数据库转储</td><td>介质故障恢复</td><td>数据库的重组织</td><td>性能监视分析等</td></tr><tr><td><strong>其它功能</strong></td><td>DBMS与网络中其它软件系统的通信</td><td>两个DBMS系统的数据转换</td><td>异构数据库之间的互访和互操作</td><td></td></tr></tbody></table><h4 id="数据库系统（DBS"><a href="#数据库系统（DBS" class="headerlink" title="数据库系统（DBS)"></a>数据库系统（DBS)</h4><p>Database System，在计算机系统中引入数据库后的系统。</p><h5 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h5><p>数据库</p><p>数据库管理系统（及其开发工具）</p><p>应用系统</p><p>数据库管理员</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-05-21-DBS.png" alt=""></p><h3 id="数据管理技术的产生和发展"><a href="#数据管理技术的产生和发展" class="headerlink" title="数据管理技术的产生和发展"></a>数据管理技术的产生和发展</h3><h4 id="什么是数据管理"><a href="#什么是数据管理" class="headerlink" title="什么是数据管理"></a>什么是数据管理</h4><p>对数据进行分类、组织、编码、存储、检索和维护</p><p>是数据处理的中心问题</p><p>数据处理：对各种数据进行收集、存储、加工和传播。</p><h4 id="数据管理技术的发展过程"><a href="#数据管理技术的发展过程" class="headerlink" title="数据管理技术的发展过程"></a>数据管理技术的发展过程</h4><p>人工管理阶段(20世纪40年代中–50年代中)</p><p>文件系统阶段(20世纪50年代末–60年代中)</p><p>数据库系统阶段(20世纪60年代末–现在)</p><h4 id="数据管理技术的发展动力"><a href="#数据管理技术的发展动力" class="headerlink" title="数据管理技术的发展动力"></a>数据管理技术的发展动力</h4><p>应用需求的推动</p><p>计算机硬件的发展</p><p>计算机软件的发展</p><h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><h4 id="数据结构化"><a href="#数据结构化" class="headerlink" title="数据结构化"></a>数据结构化</h4><p>整体数据的结构化是数据库的主要特征之一。</p><h5 id="整体结构化"><a href="#整体结构化" class="headerlink" title="整体结构化"></a>整体结构化</h5><p>不再仅仅针对某一个应用，而是面向全组织</p><p>不仅数据内部结构化，整体是结构化的，数据之间具有联系</p><h5 id="数据库中实现的是数据的真正结构化"><a href="#数据库中实现的是数据的真正结构化" class="headerlink" title="数据库中实现的是数据的真正结构化"></a>数据库中实现的是数据的真正结构化</h5><p>数据的结构用数据模型描述，无需程序定义和解释</p><p>数据可以变长</p><p>数据的最小存取单位是数据项</p><h4 id="数据的共享性高，冗余度低，易扩充"><a href="#数据的共享性高，冗余度低，易扩充" class="headerlink" title="数据的共享性高，冗余度低，易扩充"></a>数据的共享性高，冗余度低，易扩充</h4><p>数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。</p><h5 id="数据共享的好处"><a href="#数据共享的好处" class="headerlink" title="数据共享的好处"></a>数据共享的好处</h5><p>减少数据冗余，节约存储空间</p><p>避免数据之间的不相容性与不一致性</p><p>使系统易于扩充</p><h4 id="数据独立性高"><a href="#数据独立性高" class="headerlink" title="数据独立性高"></a>数据独立性高</h4><p>数据独立性是由DBMS的二级映像功能来保证的。</p><h5 id="物理独立性"><a href="#物理独立性" class="headerlink" title="物理独立性"></a>物理独立性</h5><p>指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</p><h5 id="逻辑独立性"><a href="#逻辑独立性" class="headerlink" title="逻辑独立性"></a>逻辑独立性</h5><p>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</p><h4 id="数据由DBMS统一管理和控制"><a href="#数据由DBMS统一管理和控制" class="headerlink" title="数据由DBMS统一管理和控制"></a>数据由DBMS统一管理和控制</h4><h5 id="DBMS提供的数据控制功能"><a href="#DBMS提供的数据控制功能" class="headerlink" title="DBMS提供的数据控制功能"></a>DBMS提供的数据控制功能</h5><p>(1)数据的安全性（Security）</p><p>保护保护数据，以防止不合法的使用造成的数据的泄密和破坏。</p><p>(2)数据的完整性（Integrity）</p><p>检查将数据控制在有效的范围内，或保证数据之间满足一定的关系。</p><p>(3)并发（Concurrency）</p><p>控制对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</p><p>(4)数据库恢复（Recovery）</p><p>将数据库从错误状态恢复到某一已知的正确状态。</p><h5 id="应用程序与数据的对应关系-数据库系统"><a href="#应用程序与数据的对应关系-数据库系统" class="headerlink" title="应用程序与数据的对应关系(数据库系统)"></a>应用程序与数据的对应关系(数据库系统)</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-05-21-DBS2.png" alt=""></p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="两大类数据模型"><a href="#两大类数据模型" class="headerlink" title="两大类数据模型"></a>两大类数据模型</h3><p>数据模型分为两类（分属两个不同的层次）</p><p>(1) 概念模型</p><p>也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</p><p>(2) 逻辑模型和物理模型</p><p>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。</p><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</p><p>设计人员了解和选择物理模型。</p><p><strong>客观对象的抽象过程—两步抽象</strong></p><p>现实世界中的客观对象抽象为概念模型；</p><p>把概念模型转换为某一DBMS支持的数据模型。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E4%B8%A4%E5%A4%A7%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="数据模型组成元素"><a href="#数据模型组成元素" class="headerlink" title="数据模型组成元素"></a>数据模型组成元素</h3><p>数据结构，数据操作，完整性约束条件</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>描述数据库的组成对象，以及对象之间的联系</p><p>数据结构是对系统静态特性的描述（描述对象类型的集合）</p><h5 id="描述的内容"><a href="#描述的内容" class="headerlink" title="描述的内容"></a>描述的内容</h5><p>与数据类型、内容、性质有关的对象（域、属性、关系）</p><p>与数据之间联系有关的对象</p><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则</p><h5 id="数据操作的类型"><a href="#数据操作的类型" class="headerlink" title="数据操作的类型"></a>数据操作的类型</h5><p>查询</p><p>更新(包括插入、删除、修改)</p><h5 id="数据模型对操作的定义"><a href="#数据模型对操作的定义" class="headerlink" title="数据模型对操作的定义"></a>数据模型对操作的定义</h5><p>操作的确切含义</p><p>操作符号</p><p>操作规则（如优先级）</p><p>实现操作的语言</p><p><strong>数据操作是对系统动态特性的描述</strong></p><h4 id="数据的完整性约束条件"><a href="#数据的完整性约束条件" class="headerlink" title="数据的完整性约束条件"></a>数据的完整性约束条件</h4><p>一组完整性规则的集合。</p><p>完整性规则：给定的数据模型中数据及其联系所具有的制约和储存规则</p><p>用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</p><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>反映和规定本数据模型必须遵守的基本的通用的完整性约束条件。例如在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。</p><p>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。如：退休</p><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>概念模型用于信息世界的建模</p><p>是现实世界到机器世界的一个中间层次</p><p>是数据库设计的有力工具</p><p>数据库设计人员和用户之间进行交流的语言</p><h4 id="对概念模型的基本要求"><a href="#对概念模型的基本要求" class="headerlink" title="对概念模型的基本要求"></a>对概念模型的基本要求</h4><p>较强的语义表达能力</p><p>能够方便、直接地表达应用中的各种语义知识</p><p>简单、清晰、易于用户理解</p><h4 id="信息世界中的基本概念"><a href="#信息世界中的基本概念" class="headerlink" title="信息世界中的基本概念"></a>信息世界中的基本概念</h4><h5 id="实体（Entity）"><a href="#实体（Entity）" class="headerlink" title="实体（Entity）"></a>实体（Entity）</h5><p>客观存在并可相互区别的事物称为实体。</p><p>可以是具体的人、事、物或抽象的概念。如：选课</p><h5 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h5><p>实体所具有的某一特性称为属性。</p><p>一个实体可以由若干个属性来刻画。</p><h5 id="码（Key）"><a href="#码（Key）" class="headerlink" title="码（Key）"></a>码（Key）</h5><p> 唯一标识实体的属性集称为码。如：Snum</p><h5 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h5><p>属性的取值范围称为该属性的域。  如：Grade</p><h5 id="实体型（Entity-Type）"><a href="#实体型（Entity-Type）" class="headerlink" title="实体型（Entity Type）"></a>实体型（Entity Type）</h5><p> 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 如：Student(Snum,Sname,Grade )</p><h5 id="实体集（Entity-Set）"><a href="#实体集（Entity-Set）" class="headerlink" title="实体集（Entity Set）"></a>实体集（Entity Set）</h5><p>同一类型实体的集合称为实体集</p><h5 id="联系（Relationship）"><a href="#联系（Relationship）" class="headerlink" title="联系（Relationship）"></a>联系（Relationship）</h5><p>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。</p><p>实体内部的联系通常是指组成实体的各属性之间的联系</p><p>实体之间的联系通常是指不同实体集之间的联系</p><h4 id="两个实体型之间的联系"><a href="#两个实体型之间的联系" class="headerlink" title="两个实体型之间的联系"></a>两个实体型之间的联系</h4><p>用图形来表示两个实体型之间的这三类联系</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E4%B8%A4%E5%A4%A7%E5%AE%9E%E4%BD%93.png" alt=""></p><h5 id="一对一联系（1-1）"><a href="#一对一联系（1-1）" class="headerlink" title="一对一联系（1:1）"></a>一对一联系（1:1）</h5><p> 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1</p><p>实例</p><p>一个班级只有一个正班长，一个班长只在一个班中任职</p><h5 id="一对多联系（1：n）"><a href="#一对多联系（1：n）" class="headerlink" title="一对多联系（1：n）"></a>一对多联系（1：n）</h5><p>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n</p><p>实例</p><p>一个班级中有若干名学生，每个学生只在一个班级中学习</p><h5 id="多对多联系（m-n）"><a href="#多对多联系（m-n）" class="headerlink" title="多对多联系（m:n）"></a>多对多联系（m:n）</h5><p>如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n</p><p>实例</p><p>课程与学生之间的联系：一门课程同时有若干个学生选修，一个学生可以同时选修多门课程</p><h4 id="两个以上实体型之间的联系"><a href="#两个以上实体型之间的联系" class="headerlink" title="两个以上实体型之间的联系"></a>两个以上实体型之间的联系</h4><h5 id="两个以上实体型之间一对多联系"><a href="#两个以上实体型之间一对多联系" class="headerlink" title="两个以上实体型之间一对多联系"></a>两个以上实体型之间一对多联系</h5><p>若实体集E1，E2，…，En存在联系，对于实体集Ej（j=1，2，…，i-1，i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的</p><p>实例</p><p>课程、教师与参考书三个实体型一门课程可以有若干个教师讲授，使用若干本参考书，每一个教师只讲授一门课程，每一本参考书只供一门课程使用课程与教师、参考书之间1：n</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A1%EF%BC%9An.png" alt=""></p><h5 id="两个以上实体型间的多对多联系"><a href="#两个以上实体型间的多对多联系" class="headerlink" title="两个以上实体型间的多对多联系"></a>两个以上实体型间的多对多联系</h5><p>两个以上实体型间的多对多联系</p><p>实例</p><p>供应商、项目、零件三个实体型,一个供应商可以供给多个项目多种零件,每个项目可以使用多个供应商供应的零件,每种零件可由不同供应商供给</p><h4 id="单个实体型内的联系"><a href="#单个实体型内的联系" class="headerlink" title="单个实体型内的联系"></a>单个实体型内的联系</h4><h5 id="一对一联系"><a href="#一对一联系" class="headerlink" title="一对一联系"></a>一对一联系</h5><h5 id="一对多联系"><a href="#一对多联系" class="headerlink" title="一对多联系"></a>一对多联系</h5><p>实例</p><p>职工实体型内部具有领导与被领导的联系,某一职工（干部）“领导”若干名职工,一个职工仅被另外一个职工直接领导,这是一对多的联系</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E5%AE%9E%E4%BD%93%E5%86%85%E9%83%A8-1%EF%BC%9An.png" alt=""></p><h5 id="多对多联系"><a href="#多对多联系" class="headerlink" title="多对多联系"></a>多对多联系</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E5%AE%9E%E4%BD%93%E5%86%85%E9%83%A8-m%EF%BC%9An.png" alt=""></p><h4 id="概念模型的一种表示方法"><a href="#概念模型的一种表示方法" class="headerlink" title="概念模型的一种表示方法"></a>概念模型的一种表示方法</h4><h5 id="实体－联系方法-E-R方法"><a href="#实体－联系方法-E-R方法" class="headerlink" title="实体－联系方法(E-R方法)"></a>实体－联系方法(E-R方法)</h5><p>用E-R图来描述现实世界的概念模型</p><p>E-R方法也称为E-R模型</p><h5 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h5><p><strong>实体型</strong></p><p>用矩形表示，矩形框内写明实体名。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21%E5%AE%9E%E4%BD%93%E5%9E%8B.png" alt=""></p><p><strong>属性</strong></p><p>用椭圆形表示，并用无向边将其与相应的实体连接起来</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-ER%E5%B1%9E%E6%80%A7.png" alt=""></p><p><strong>联系</strong></p><p>联系本身：   用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n）</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-ER%E5%85%B3%E7%B3%BB.png" alt=""></p><p>联系的属性：</p><p>联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-ER%E8%81%94%E7%B3%BB%E5%B1%9E%E6%80%A7.png" alt=""></p><h3 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h3><h4 id="非关系模型（格式化模型）"><a href="#非关系模型（格式化模型）" class="headerlink" title="非关系模型（格式化模型）"></a>非关系模型（格式化模型）</h4><p>层次模型(Hierarchical Model)  实体-&gt;记录</p><p>网状模型(Network Model)       属性-&gt;字段（数据项）</p><h5 id="非关系模型中数据结构基本单位"><a href="#非关系模型中数据结构基本单位" class="headerlink" title="非关系模型中数据结构基本单位"></a>非关系模型中数据结构基本单位</h5><p>基本层次联系：两个记录以及它们之间的一对多（包括一对一）的联系。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-%E5%9F%BA%E6%9C%AC%E5%B1%82%E6%AC%A1%E8%81%94%E7%B3%BB.png" alt=""></p><h4 id="关系模型-Relational-Model"><a href="#关系模型-Relational-Model" class="headerlink" title="关系模型(Relational Model)"></a>关系模型(Relational Model)</h4><h4 id="面向对象模型-Object-Oriented-Model）"><a href="#面向对象模型-Object-Oriented-Model）" class="headerlink" title="面向对象模型(Object Oriented Model）"></a>面向对象模型(Object Oriented Model）</h4><h4 id="对象关系模型-Object-Relational-Model"><a href="#对象关系模型-Object-Relational-Model" class="headerlink" title="对象关系模型(Object Relational Model)"></a>对象关系模型(Object Relational Model)</h4><h3 id="层次模型-最早的模型"><a href="#层次模型-最早的模型" class="headerlink" title="层次模型(最早的模型)"></a>层次模型(最早的模型)</h3><p>层次模型用树形结构来表示各类实体以及实体间的联系  </p><p><strong>满足下面两个条件的基本层次联系的集合为层次模型</strong></p><ol><li>有且只有一个结点没有双亲结点，这个结点称为根结点</li><li>根以外的其它结点有且只有一个双亲结点</li></ol><p><strong>层次模型中的几个术语</strong></p><p>根结点，双亲结点，兄弟结点（同一双亲的节点），叶结点（没有子女的节点）</p><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>网状数据库系统采用网状模型作为数据的组织方式</p><p>满足下面两个条件的基本层次联系的集合：</p><ol><li>允许一个以上的结点无双亲；</li><li>一个结点可以有多于一个的双亲。</li></ol><p>表示方法(与层次数据模型相同)</p><p>实体型：用记录类型描述每个结点表示一个记录类型（实体）</p><p>属性：用字段描述每个记录类型可包含若干个字段</p><p>联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系数据库系统采用关系模型作为数据的组织方式。</p><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><h4 id="关系（Relation）"><a href="#关系（Relation）" class="headerlink" title="关系（Relation）"></a>关系（Relation）</h4><p>一个关系对应通常说的一张表</p><h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>表中的一行即为一个元组</p><h4 id="属性（Attribute）-1"><a href="#属性（Attribute）-1" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h4><p>表中的一列即为一个属性，给每一个属性起一个名称即属性名</p><h4 id="主码（Key）"><a href="#主码（Key）" class="headerlink" title="主码（Key）"></a>主码（Key）</h4><p>表中的某个属性或属性组，它可以唯一确定一个元组。</p><h4 id="域（Domain）-1"><a href="#域（Domain）-1" class="headerlink" title="域（Domain）"></a>域（Domain）</h4><p>属性的取值范围。</p><h4 id="分量"><a href="#分量" class="headerlink" title="分量"></a>分量</h4><p>元组中的一个属性值。</p><h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>对关系的描述</p><p>关系名（属性1，属性2，…，属性n）</p><p>学生（学号，姓名，年龄，性别，系，年级）</p><h4 id="术语对比"><a href="#术语对比" class="headerlink" title="术语对比"></a>术语对比</h4><table><thead><tr><th>关系术语</th><th>一般表格的术语</th></tr></thead><tbody><tr><td>关系名</td><td>表名</td></tr><tr><td>关系模式</td><td>表头（表格的描述）</td></tr><tr><td>关系</td><td>（一张）二维表</td></tr><tr><td>元组</td><td>记录或行</td></tr><tr><td>属性</td><td>列</td></tr><tr><td>属性名</td><td>列名</td></tr><tr><td>属性值</td><td>列值</td></tr><tr><td>分量</td><td>一条记录中的一个列值</td></tr><tr><td>非规范关系</td><td>表中有表（大表中嵌有小表）</td></tr></tbody></table><p>关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。</p><h4 id="数据操作-1"><a href="#数据操作-1" class="headerlink" title="数据操作"></a>数据操作</h4><p>查询</p><p>插入</p><p>删除</p><p>更新</p><p>数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合</p><p>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</p><h4 id="关系的完整性约束条件"><a href="#关系的完整性约束条件" class="headerlink" title="关系的完整性约束条件"></a>关系的完整性约束条件</h4><p>实体完整性</p><p>参照完整性</p><p>用户定义的完整性</p><h2 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h2><p>从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。</p><p>从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为:</p><p>单用户结构</p><p>主从式结构分布式结构</p><p>客户／服务器</p><p>浏览器／应用服务器／数据库服务器多层结构等</p><h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><h4 id="“型”-和“值”-的概念"><a href="#“型”-和“值”-的概念" class="headerlink" title="“型” 和“值” 的概念"></a>“型” 和“值” 的概念</h4><h5 id="型-Type"><a href="#型-Type" class="headerlink" title="型(Type)"></a>型(Type)</h5><p>对某一类数据的结构和属性的说明</p><h5 id="值-Value"><a href="#值-Value" class="headerlink" title="值(Value)"></a>值(Value)</h5><p>是型的一个具体赋值例如学生记录</p><p>型：  （学号，姓名，性别，系别，年龄，籍贯）一个记录</p><p>值：  （900201，李明，男，计算机，22，江苏）</p><h4 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h4><p>数据库逻辑结构和特征的描述</p><p>是型的描述</p><p>反映的是数据的结构及其联系</p><p>模式是相对稳定的</p><h4 id="实例（Instance）"><a href="#实例（Instance）" class="headerlink" title="实例（Instance）"></a>实例（Instance）</h4><p>模式的一个具体值</p><p>反映数据库某一时刻的状态</p><p>同一个模式可以有很多实例实例</p><p>随数据库中的数据的更新而变动</p><p>例如：在学生选课数据库模式中，包含学生记录、课程记录和学生选课记录 </p><p>2013年的一个学生数据库实例，包含：</p><p>2013年学校中所有学生的记录</p><p>学校开设的所有课程的记录</p><p>所有学生选课的记录 </p><p>2012年度学生数据库模式对应的实例与2013年度学生数据库模式对应的实例是不同的 </p><h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-21-%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.png" alt=""></p><h4 id="模式（Schema也称逻辑模式）"><a href="#模式（Schema也称逻辑模式）" class="headerlink" title="模式（Schema也称逻辑模式）"></a>模式（Schema也称逻辑模式）</h4><p>数据库中全体数据的逻辑结构和特征的描述</p><p>所有用户的公共数据视图，综合了所有用户的需求</p><p><strong>一个数据库只有一个模式</strong></p><h5 id="模式的地位："><a href="#模式的地位：" class="headerlink" title="模式的地位："></a>模式的地位：</h5><p>是数据库系统模式结构的中间层与数据的物理存储细节和硬件环境无关</p><p>与具体的应用程序、开发工具及高级程序设计语言无关</p><h5 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h5><p>数据的逻辑结构（数据项的名字、类型、取值范围等）</p><p>数据之间的联系</p><p>数据有关的安全性、完整性要求</p><h4 id="外模式（External-Schema也称子模式或用户模式）"><a href="#外模式（External-Schema也称子模式或用户模式）" class="headerlink" title="外模式（External Schema也称子模式或用户模式）"></a>外模式（External Schema也称子模式或用户模式）</h4><p>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</p><p>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p><h5 id="模式与外模式的关系：一对多"><a href="#模式与外模式的关系：一对多" class="headerlink" title="模式与外模式的关系：一对多"></a>模式与外模式的关系：一对多</h5><p>外模式通常是模式的子集</p><p>一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</p><p>对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同</p><h5 id="外模式与应用的关系：一对多"><a href="#外模式与应用的关系：一对多" class="headerlink" title="外模式与应用的关系：一对多"></a>外模式与应用的关系：一对多</h5><p>同一外模式也可以为某一用户的多个应用系统所使用</p><p>但一个应用程序只能使用一个外模式</p><h5 id="外模式的用途"><a href="#外模式的用途" class="headerlink" title="外模式的用途"></a>外模式的用途</h5><p>保证数据库安全性的一个有力措施</p><p>每个用户只能看见和访问所对应的外模式中的数据</p><h4 id="内模式（Internal-Schema也称存储模式）"><a href="#内模式（Internal-Schema也称存储模式）" class="headerlink" title="内模式（Internal Schema也称存储模式）"></a>内模式（Internal Schema也称存储模式）</h4><p>一个数据库只有一个内模式</p><h5 id="是数据物理结构和存储方式的描述"><a href="#是数据物理结构和存储方式的描述" class="headerlink" title="是数据物理结构和存储方式的描述"></a>是数据物理结构和存储方式的描述</h5><h5 id="是数据在数据库内部的表示方式"><a href="#是数据在数据库内部的表示方式" class="headerlink" title="是数据在数据库内部的表示方式"></a>是数据在数据库内部的表示方式</h5><p>记录的存储方式（堆存储，顺序存储，聚簇存储）</p><p> 索引的组织方式（B+树索引，按hash索引存储）</p><p>数据是否压缩存储</p><p>数据是否加密</p><p>数据存储记录结构的规定</p><p>数据库的二级映像功能与数据独立性</p><h3 id="数据库的二级映像功能与数据独立性"><a href="#数据库的二级映像功能与数据独立性" class="headerlink" title="数据库的二级映像功能与数据独立性"></a>数据库的二级映像功能与数据独立性</h3><p>三级模式是对数据的三个抽象级别</p><p>二级映象在DBMS内部实现这三个抽象层次的联系和转换</p><h4 id="外模式／模式映象"><a href="#外模式／模式映象" class="headerlink" title="外模式／模式映象"></a>外模式／模式映象</h4><p>模式：描述的是数据的全局逻辑结构</p><p>外模式：描述的是数据的局部逻辑结构 </p><p>同一个模式可以有任意多个外模式 </p><p>每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系</p><p>映象定义通常包含在各自外模式的描述中</p><h5 id="保证数据的逻辑独立性"><a href="#保证数据的逻辑独立性" class="headerlink" title="保证数据的逻辑独立性"></a>保证数据的逻辑独立性</h5><p>当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变</p><p>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</p><h4 id="模式／内模式映像"><a href="#模式／内模式映像" class="headerlink" title="模式／内模式映像"></a>模式／内模式映像</h4><p>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的</p><p>数据库中模式／内模式映象是唯一的</p><p>该映象定义通常包含在模式描述中</p><h5 id="保证数据的物理独立性"><a href="#保证数据的物理独立性" class="headerlink" title="保证数据的物理独立性"></a>保证数据的物理独立性</h5><p>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变</p><p>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</p><h5 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h5><p>即全局逻辑结构是数据库的中心与关键 </p><p>独立于数据库的其他层次 </p><p>设计数据库模式结构时应首先确定数据库的逻辑模式</p><h5 id="数据库的内模式"><a href="#数据库的内模式" class="headerlink" title="数据库的内模式"></a>数据库的内模式</h5><p>依赖于它的全局逻辑结构</p><p>独立于数据库的用户视图，即外模式</p><p>独立于具体的存储设备  </p><p>将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 </p><h5 id="数据库的外模式"><a href="#数据库的外模式" class="headerlink" title="数据库的外模式"></a>数据库的外模式</h5><p>面向具体的应用程序</p><p>定义在逻辑模式之上</p><p>独立于存储模式和存储设备</p><p>当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 </p><p>设计外模式时应充分考虑到应用的扩充性 </p><h5 id="特定的应用程序"><a href="#特定的应用程序" class="headerlink" title="特定的应用程序"></a>特定的应用程序</h5><p>在外模式描述的数据结构上编制的</p><p>依赖于特定的外模式</p><p>与数据库的模式和存储结构独立</p><p>不同的应用程序有时可以共用同一个外模式</p><h5 id="数据库的二级映像"><a href="#数据库的二级映像" class="headerlink" title="数据库的二级映像"></a>数据库的二级映像</h5><p>保证了数据库外模式的稳定性</p><p>从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 </p><p><strong>数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去</strong> </p><h5 id="数据的存取由DBMS管理"><a href="#数据的存取由DBMS管理" class="headerlink" title="数据的存取由DBMS管理"></a>数据的存取由DBMS管理</h5><p>用户不必考虑存取路径等细节</p><p>简化了应用程序的编制</p><p>大大减少了应用程序的维护和修改</p><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>数据库</p><p>数据库管理系统（及其开发工具）</p><p>应用系统</p><p>数据库管理员</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔&lt;/p&gt;
&lt;h2 id=&quot;数据库系统概述&quot;&gt;&lt;a href=&quot;#数据库系统概述&quot; class=&quot;headerlink&quot; title=&quot;数据库系统概述&quot;&gt;&lt;/a&gt;数据库系统概述&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据库" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库概论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="数据库" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ACM全国邀请赛热身赛题2并查集</title>
    <link href="http://qianyouyou.cn/2018/05/19/2018-05-19/"/>
    <id>http://qianyouyou.cn/2018/05/19/2018-05-19/</id>
    <published>2018-05-19T15:37:32.000Z</published>
    <updated>2018-05-19T15:45:48.164Z</updated>
    
    <content type="html"><![CDATA[<p>真是糟糕的一天，愿不要影响到明天邀请赛发挥。</p><p>题意：</p><p>有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可能叛徒数，否则输出-1，遇到第几条时判断是谎言。</p><p>例：</p><p>输入</p><p>3 3</p><p>1 2</p><p>2 3</p><p>3 1</p><p>输出</p><p>-1 3</p><p>输入</p><p>5 4</p><p>1 2</p><p>2 3</p><p>3 4</p><p>4 1</p><p>输出</p><p>1 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXX = 100010;</span><br><span class="line">int fa[MAXX], r[MAXX];</span><br><span class="line">int vis[MAXX];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if (fa[x] == x) return fa[x];</span><br><span class="line">int tmp = fa[x];</span><br><span class="line">fa[x] = find(fa[x]);</span><br><span class="line">r[x] = (r[tmp] + r[x]) % 2;</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void fun(int x, int y)&#123;</span><br><span class="line">int fx = find(x), fy = find(y);</span><br><span class="line">if (fx == fy)   return;</span><br><span class="line">fa[fy] = fx;</span><br><span class="line">r[fy] = (r[x] + 1 - r[y]) % 2;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">int N, M, x, y, flag = 0, cnt = 0;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;N, &amp;M);</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for (int i = 0; i &lt;= N; i++)   fa[i] = i, r[i] = 0;</span><br><span class="line">for (int i = 1; i &lt;= M; i++) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">if (!vis[x])</span><br><span class="line">cnt++;</span><br><span class="line">if (!vis[y])</span><br><span class="line">cnt++;</span><br><span class="line">vis[x] = vis[y] = 1;</span><br><span class="line">if (flag)</span><br><span class="line">continue;</span><br><span class="line">if (find(x) == find(y)) &#123;</span><br><span class="line">if (r[x] == r[y])</span><br><span class="line">flag = i;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">fun(x, y);</span><br><span class="line">&#125;</span><br><span class="line">if (flag)</span><br><span class="line">printf(&quot;-1 %d\n&quot;, flag);</span><br><span class="line">else &#123;</span><br><span class="line">int cnt2 = 0;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">find(i);</span><br><span class="line">if (r[i] == 1 || !vis[i])</span><br><span class="line">cnt2++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;1 %d\n&quot;, cnt - cnt2 &gt; cnt2 ? cnt - cnt2 : cnt2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真是糟糕的一天，愿不要影响到明天邀请赛发挥。&lt;/p&gt;
&lt;p&gt;题意：&lt;/p&gt;
&lt;p&gt;有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://qianyouyou.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>牛客小白月赛&amp;&amp;艾教习题总结</title>
    <link href="http://qianyouyou.cn/2018/05/16/2018-05-16/"/>
    <id>http://qianyouyou.cn/2018/05/16/2018-05-16/</id>
    <published>2018-05-16T14:51:02.000Z</published>
    <updated>2018-05-17T05:19:32.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管道取珠"><a href="#管道取珠" class="headerlink" title="管道取珠"></a>管道取珠</h2><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_1.jpg" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%E5%8F%96%E7%8F%A0_2.jpg" alt=""></p><p><strong>输入</strong></p><p>第一行包含两个整数n, m，分别表示上下两个管道中球的数目。 第二行为一个AB字符串，长度为n，表示上管道中从左到右球的类型。其中A表示浅色球，B表示深色球。 第三行为一个AB字符串，长度为m，表示下管道中的情形。</p><p><strong>输出</strong></p><p>仅包含一行，即为 Sigma(Ai^2) i从1到k 除以1024523的余数。</p><p><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">AB</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>数据规模及约定</strong></p><p>约30%的数据满足 n, m ≤ 12；<br>约100%的数据满足n, m ≤ 500。</p><p><strong>题解</strong></p><p>这题思路比较妙，我们需要先想想 ∑ai2 有什么意义。如果我们构造出这样一个游戏场景，即两个人同时玩两份同样的如题目所述的管道取珠的游戏，那么这两个人游戏结束后取到的珠子颜色序列一模一样的方案数就是题目里要求的答案。</p><p>令这两个人分别是 p1 和 p2。于是设 f[i][j][k] 表示 p1 取了第二个管道中的前 i 个珠子，第一个管道中的前 j 个珠子；p2 取了第一个管道的前 k 个珠子，这个状态下颜色序列相同的方案数，转移显然。</p><p>注：n为12以内一般是阶乘的题，n为30以内可以考虑状态压缩，莫队，线段树等各种情况，50左右选择二分，100以上需要另想方法。</p><h2 id="问号猜数"><a href="#问号猜数" class="headerlink" title="问号猜数"></a>问号猜数</h2><p>有一堆数按照递增的顺序排列，然而这些数的某些位我们并不知道，我们知道的只是这些数是从小到大排列的，现在依次给出这些数，不知道的位用？表示。我们需要猜这个数能满足递增条件的最小数。例如：</p><p>??</p><p>1?</p><p>?1</p><p>???</p><p>?99</p><p>?9?</p><p>?4?5</p><p>第一个数是10，第2个11，第3个21，第4个100，第5个199，第6个290，第7个1405。</p><p><strong>题解</strong></p><p>用贪心虽然比较快，但代码不容易写，须考虑情况挺多。因此我们分析一下。首先n&lt;=6，代表最大位数是6，也就是说最大的数也就是百万位。因此直接从1枚举，另设指针指向第1个数，每枚举到某个数满足该指针指向的数，则将指针指向下一个数，然后继续枚举，因此扫描一遍之后就得到所有的答案了。</p><p>接下来，假如n&lt;=15，由于数是递增的，则将枚举用二分来完成。假如n&gt;=100，这时再考虑贪心。</p><h2 id="取牌去牌"><a href="#取牌去牌" class="headerlink" title="取牌去牌"></a>取牌去牌</h2><p>有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌ii.j，得到一个ai <em> bj + bi </em> aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。</p><p><strong>题解</strong></p><p>主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。</p><h2 id="铁索连环"><a href="#铁索连环" class="headerlink" title="铁索连环"></a>铁索连环</h2><p>有n个数，现在有m次查询，每次查询[l,r]范围所有不同的数。假设n很大</p><p><strong>题解</strong></p><p>我的思路是打表记录上一个相同元素的位置，比如a[1-10]=1,2,4,3,2,4,5,6,3,4,那么b[1-10]=0,0,0,0,2,3,0,0,4,6。这样l，r的范围内只需扫描1遍即可，扫到0结果加1，扫到非0的数看该下标是否 &lt; l，是则加1，否则不处理。时间复杂度是0mn。</p><p>艾教的方法不是很懂，不过举了一个例子，假如(3(3(3(3(3)))))，查询范围为括号所示，那么只需将第5个3赋为1，其他3赋为0即可。看起来最后就像一条链子捆绑着相同的元素。</p><h2 id="狭路相逢"><a href="#狭路相逢" class="headerlink" title="狭路相逢"></a>狭路相逢</h2><p>有一个图，每条路上都有强盗，每个节点都有驴友，假如到某条路上，该路上的强盗抢劫你的条件是强盗人数大于等于你们人数。你们每经过一个节点可以拉驴友入伍结伴而行，问（忘记问什么了，尴尬~QAQ~）</p><p><strong>题解</strong></p><p>并查集</p><h2 id="区间gcd"><a href="#区间gcd" class="headerlink" title="区间gcd"></a>区间gcd</h2><p>给定l，r，问多少种gcd(l,r)==gcd(l2.r2)</p><p><strong>题解</strong></p><p>1、两个条件，从1到n，最大公约数呈递减阶梯式。</p><p>2、gcd(gcd（a,b）,gcd(c,d))==gcd(a,d)</p><p>根据性质2可以用st表列出范围内l，r的最大公约数，即1，n最大公约数</p><p>根据性质1，二分求解</p><h2 id="信号误差"><a href="#信号误差" class="headerlink" title="信号误差"></a>信号误差</h2><p>艾教给女朋友传情发信号，信号是01串（16位）组成的字母，但是有情敌的干扰，途中可能至多会有两位进制会发生改变。问如何设置01串才能无视干扰准确将信号传给女盆友。例如1111111111111111，那么该2个1也是比0多，所以无视干扰。但每次只能处理一个字母，效率太慢。</p><p><strong>题解</strong></p><p>图论。将距离2以内的所有结点全部连起来。贪心选取结点，可以直接选择第一个结点开始。</p><h2 id="牛客小白月赛"><a href="#牛客小白月赛" class="headerlink" title="牛客小白月赛"></a>牛客小白月赛</h2><h3 id="音标"><a href="#音标" class="headerlink" title="音标"></a><a href="https://www.nowcoder.com/acm/contest/87/A" target="_blank" rel="noopener">音标</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>  我们规定元音字母有a、e、i、o、u，并且规定半元音字母y也是元音字母。 </p><p>  Cwbc在学习英语，XHRlyb为了让Cwbc的记忆更加深刻，于是她让Cwbc把每个字符串的所有字母都变成一个<strong>恰好**</strong>不大于它本身的小写元音字母**。 </p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有一个仅包含小写字母的字符串。</span><br></pre></td></tr></table></figure><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，每行有一个变化后的字符串。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元音字母变为一个恰好不大于它本身的字母，也就是元音字母本身</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfjpv</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeiou</span><br></pre></td></tr></table></figure><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入样例是由元音字母a、e、i、o、u的后一个字母组成，每个字母变为一个恰好不大于它本身的字母，也就是a、e、i、o、u。</span><br></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>upper_bound的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">char s[210000];</span><br><span class="line">char a[]=&quot;aeiouy&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;s[i];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]=a[upper_bound(a,a+6,s[i])-a-1];</span><br><span class="line">        &#125;</span><br><span class="line">        puts(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="躲藏"><a href="#躲藏" class="headerlink" title="躲藏"></a><a href="https://www.nowcoder.com/acm/contest/87/B" target="_blank" rel="noopener">躲藏</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>XHRlyb和她的小伙伴Cwbc在玩捉迷藏游戏。<br> Cwbc藏在多个不区分大小写的字符串中。<br> 好奇的XHRlyb想知道，在每个字符串中Cwbc作为子序列分别出现了多少次。<br> 由于Cwbc可能出现的次数过多，你只需要输出每个答案对<strong>2000120420010122</strong>取模后的结果。<br> 聪明的你在仔细阅读题目后，一定可以顺利的解决这个问题！</p><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有一个字符串。</span><br></pre></td></tr></table></figure><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，每行表示一个答案取模后的结果。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc作为子序列仅出现了1次。</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acdcecfwgwhwibjbkblcmcnco</span><br></pre></td></tr></table></figure><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">81</span><br></pre></td></tr></table></figure><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc作为子序列出现了34=81次。</span><br></pre></td></tr></table></figure><h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行字符串长度不超过2×105，字符串总长度不超过106。</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>一个memset导致超时，也是够无语。时间复杂度4 <em> On，加上memset是5 </em> On，就差1个On就超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">char str[200010];</span><br><span class="line">long long dp[5][200010];</span><br><span class="line">int main() &#123;</span><br><span class="line">int i;</span><br><span class="line">while (scanf(&quot;%s&quot;, str + 2) != EOF) &#123;</span><br><span class="line">dp[1][0] = &apos;c&apos;, dp[2][0] = &apos;w&apos;, dp[3][0] = &apos;b&apos;,dp[4][0] = &apos;c&apos;;</span><br><span class="line">for (i = 2; str[i]; i++) &#123;</span><br><span class="line">dp[0][i] = 1;</span><br><span class="line">str[i] = tolower(str[i]);</span><br><span class="line">for (int k = 1; k &lt; 5; k++) &#123;</span><br><span class="line">dp[k][i] = dp[k][i - 1];</span><br><span class="line">if (str[i] == dp[k][0]) &#123;</span><br><span class="line">dp[k][i] += dp[k - 1][i];</span><br><span class="line">dp[k][i] %= 2000120420010122;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;, dp[4][i - 1]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a><a href="https://www.nowcoder.com/acm/contest/87/C" target="_blank" rel="noopener">博弈</a></h3><p> 博弈双方都是绝顶聪明的，并且XHRlyb先手，请你来帮XHRlyb预测这一局游戏谁会获胜。 </p><p>  如果博弈双方谁也无法取胜，那么判定为平局。 </p><h4 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多行，每行有三个正整数，l，r，k。</span><br></pre></td></tr></table></figure><h4 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出数据应有多行，如果这一局XHRlyb获胜，那么请输出XHRlyb；如果Cwbc获胜，请输出Cwbc；如果两人平局，请输出Draw。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 2</span><br></pre></td></tr></table></figure><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XHRlyb</span><br></pre></td></tr></table></figure><p> 示例2 </p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cwbc</span><br></pre></td></tr></table></figure><h4 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ≤ l ≤ r ≤ 105。</span><br><span class="line">1 ≤ k ≤ 100。</span><br><span class="line">1 ≤ T ≤ 1000。</span><br></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>水dp，l，r写反了，一直报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[100005];</span><br><span class="line">int sum[100005];</span><br><span class="line">int main() &#123;</span><br><span class="line">int l, r, k;</span><br><span class="line">while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; k) &#123;</span><br><span class="line">memset(dp, 0, sizeof(dp));</span><br><span class="line">memset(sum, 0, sizeof(sum));</span><br><span class="line">if (k == 1) &#123;</span><br><span class="line">cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt; k; i++) &#123;</span><br><span class="line">dp[i] = 1;</span><br><span class="line">sum[i] = (sum[i - 1] + 1);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = k; i &lt;= r; i++) &#123;</span><br><span class="line">dp[i] = (dp[i / k] * k + 1);</span><br><span class="line">sum[i] = (sum[i - 1] + dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">if (abs(sum[r] - sum[l - 1]) % 2 == 1)</span><br><span class="line">cout &lt;&lt; &quot;XHRlyb&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;Cwbc&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;管道取珠&quot;&gt;&lt;a href=&quot;#管道取珠&quot; class=&quot;headerlink&quot; title=&quot;管道取珠&quot;&gt;&lt;/a&gt;管道取珠&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://p7woygi8q.bkt.clouddn.com/%E7%AE%A1%E9%81%93%
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="线性dp" scheme="http://qianyouyou.cn/tags/%E7%BA%BF%E6%80%A7dp/"/>
    
  </entry>
  
  <entry>
    <title>陕西师范大学第七届程序设计竞赛题解</title>
    <link href="http://qianyouyou.cn/2018/05/14/2018-05-14/"/>
    <id>http://qianyouyou.cn/2018/05/14/2018-05-14/</id>
    <published>2018-05-14T08:42:18.000Z</published>
    <updated>2018-05-14T10:53:18.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WWX的520"><a href="#WWX的520" class="headerlink" title="WWX的520"></a><a href="https://www.nowcoder.com/acm/contest/121/A" target="_blank" rel="noopener">WWX的520</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>520，因为谐音为我爱你，所以也被称之为表白日。</p><p>这一天，人们借机把藏在心底的洪荒之力通过表白、撒娇、传情、送礼、结婚等形式释放出来，商家也会趁势开展各类优惠促销活动，掀起一波或浪漫或虐狗的节日热浪。</p><p>这一天，也是送男朋友礼物、送女朋友礼物、送自己礼物、送亲朋好友礼物的好时机。</p><p>在520即将到来之际，wwx准备为她的女朋友购买一批礼物。于是他列出了一份礼物清单，但由于预算有限，必须删掉一种礼物。经过深思熟虑，他决定删掉价格第k高的礼物，你能帮帮他，找出是哪一种礼物吗?</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一行是一个整数T（1&lt;=T&lt;=80），表示有T组数据.</span><br><span class="line">对于每一组数据，首先一行输入N(3&lt;=N&lt;=1000)，接下来的N行每行输入一个字符串和一个整数，以空格间隔，分别作为每种礼物的名字和价格。</span><br><span class="line">接下来一行输入k，表示要删去第k(1&lt;=&lt;=N)高的礼物</span><br><span class="line">礼物的名字的长度不超过30，礼物的价格不超过1000，且均为整数。</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于每组输入数据，依次输出它的组号和要删去的礼物的名字和价格,以空格间隔。</span><br><span class="line">若两种商品的价格相同，则比较礼物名字的字典序大小。即:两种礼物的价格相同时，字典序大者若为第k高，字典序小者则为第k+1高。</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Apple 18</span><br><span class="line">Book 30</span><br><span class="line">Milk 8000</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">Apple 300</span><br><span class="line">Bananas  200</span><br><span class="line">Bracelet 200</span><br><span class="line">Candy 200</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1: Apple 18</span><br><span class="line">#2: Bracelet 200</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">可用strcmp(s1,s2)函数进行字符串的比较。</span><br><span class="line">2.</span><br><span class="line">对于样例一中第二组数据:Apple 300是价格第一大，Candy 200是价格第二高，Bracelet</span><br><span class="line">200是价格第三大。</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>直接按照价格从大到小排序，如果价格相同按照字母序从大到小排序。排完序之后直接输出第k位的礼物名称与价格即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">string str;</span><br><span class="line">int v;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">if (a.v == b.v) &#123;</span><br><span class="line">return a.str&gt;b.str;</span><br><span class="line">&#125;</span><br><span class="line">return a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">for (int z = 1; z &lt;= t; z++) &#123;</span><br><span class="line">int n, k;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i].str;</span><br><span class="line">cin &gt;&gt; a[i].v;</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + n, cmp);</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; &quot;#&quot; &lt;&lt; z &lt;&lt; &quot;: &quot; &lt;&lt; a[k - 1].str &lt;&lt; &quot; &quot; &lt;&lt; a[k - 1].v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配环境"><a href="#配环境" class="headerlink" title="配环境"></a><a href="https://www.nowcoder.com/acm/contest/121/B" target="_blank" rel="noopener">配环境</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      黑猫在给校赛配环境，结果被服务器的各种入站规则出站规则搞得头疼，想到自己要上传GVIM、EMACS、VSCODE、Jetbrain全家桶、Visual Studio、Gedit、Microsoft Office Word、Eclipse等等，完全不知道要要花费多少时间才能上传完校赛需要的环境。 </p><p>​      黑猫跑去问ddjing，谁知道ddjing说：“我要去实习了，没功夫解决这个问题，你去问问其他人吧。“ </p><p>​      于是黑猫想请你帮他解决这个问题。 </p><p>​      服务器总传输速度为每秒M个单位（本题出现的所有单位都统一），黑猫现在需要上传总共n个软件（按优先级顺序从高到低给出），每个软件的大小分别为v1、v2….vn，每个软件为保持稳定连接，上传需要一个最小的传输速度为m1、m2…mn。 </p><p>​      服务器带宽分配的策略是：按优先级满足每一个软件要求的传输速度。如果服务器剩余的带宽不能满足某个软件最小传输速度的话，服务器将继续寻找下去，直到找到能满足最小传输速度的软件。 </p><p>​      如果目前服务器的总传输速度不能满足所有还需要上传的软件的话，服务器将把传输速度全部给予当前优先级最高的（即使不能满足其最小传输速度）。 </p><p>​      如果目前对所有软件都满足了其最小传输速度的话，服务器将把剩余所有传输速度全部给予当前优先级最高的软件。 </p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行给出一个正整数，表示服务器总带宽M</span><br><span class="line">第二行给出整数n，表示需要上传的n个软件。</span><br><span class="line">第三行为n个正整数，第i个数表示vi。</span><br><span class="line">第四行为n个正整数，第i个数表示mi。</span><br><span class="line">( 1 &lt;= M &lt;= 1000,  1 &lt;= n &lt;= 100 , 1 &lt;=  vi &lt;= 1000 ,  1 &lt;= mi &lt;= 1000 )</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行，为上传完毕所有软件所需要的时间，保留两位小数。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">1 1 4 5 1 4 </span><br><span class="line">10 9 8 7 6 5</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.60</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">6</span><br><span class="line">10 9 8 7 6 5</span><br><span class="line">1 1 4 5 1 4</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.50</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>原本是一道水题，结果成功被题面绕进去了。其实只需要把所有软件的大小V加起来除以宽带大小M即可。所谓最小速度都是迷惑人的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int M, n;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;M, &amp;n);</span><br><span class="line">double tmp, ans = 0;</span><br><span class="line">for (int i = 0; i &lt; n;i++) &#123;</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">ans += tmp;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">scanf(&quot;%lf&quot;, &amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line">ans /= M;</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一段超时代码，成功将题面的过程给模拟了出来，当时没仔细看数据是怎么得到的，一直超时很不可思议。因此总结出了经验，以后做题一定得分析出数据是怎么得到的，有时候就很容易找到规律或者发现玄机。另外下面的代码总结出了一个新的方法，就是利用滚动数组实现删除元素，虽然vector有删除功能，但删除效率低。以下的方法是利用滚动数组，将未删除的元素重新压入数组，删除的元素不进行操作，然后清空数组，这样循环操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int M, n;</span><br><span class="line">struct node&#123;</span><br><span class="line">double v;</span><br><span class="line">int m;</span><br><span class="line">&#125;a[1005];</span><br><span class="line">int vis[1005];</span><br><span class="line">vector&lt;int&gt;vv[2];</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; n;</span><br><span class="line">double ans = 0, wei;</span><br><span class="line">int ff[2] = &#123; 0,1 &#125;;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; a[i].v;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i].m;</span><br><span class="line">vv[ff[0]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while (flag &gt;= 0) &#123;</span><br><span class="line">flag = -1;</span><br><span class="line">wei = M;</span><br><span class="line">double mint = inf;</span><br><span class="line">vv[ff[1]].clear();</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">for (it = vv[ff[0]].begin(); it != vv[ff[0]].end(); it++) &#123;</span><br><span class="line">if (a[*it].v &lt;= 0) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;vis[*it] = 0;</span><br><span class="line">vv[ff[1]].push_back(*it);</span><br><span class="line">if (flag &lt; 0)</span><br><span class="line">flag = *it;</span><br><span class="line">if (a[*it].v &lt;= wei) &#123;</span><br><span class="line">vis[*it] = 1;</span><br><span class="line">wei -= a[*it].m;</span><br><span class="line">if (*it != flag)</span><br><span class="line">mint = min(mint, a[*it].v / a[*it].m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag &lt; 0)</span><br><span class="line">break;</span><br><span class="line">mint = min(mint, a[flag].v / (vis[flag] ? a[flag].m + wei : wei));</span><br><span class="line">for (it = vv[ff[1]].begin(); it != vv[ff[1]].end(); it++) &#123;</span><br><span class="line">if (a[*it].v &lt;= 0 || !vis[*it] || flag == *it)</span><br><span class="line">continue;</span><br><span class="line">a[*it].v -= a[*it].m*mint;</span><br><span class="line">&#125;</span><br><span class="line">a[flag].v -= (vis[flag] ? a[flag].m + wei : wei)*mint;</span><br><span class="line">ans += mint;</span><br><span class="line">ff[0] = ff[0] ^ ff[1];</span><br><span class="line">ff[1] = ff[0] ^ ff[1];</span><br><span class="line">ff[0] = ff[0] ^ ff[1];</span><br><span class="line">//cout &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; mint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iko和她的糖"><a href="#iko和她的糖" class="headerlink" title="iko和她的糖"></a><a href="https://www.nowcoder.com/acm/contest/121/C" target="_blank" rel="noopener">iko和她的糖</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      iko超级超级喜欢吃糖，有一天iko想出去玩，她计划从1点走到N点（按1,2,3，…，n的顺序走），每个点都有一个补给站，第i点的补给站有a[i]颗糖，从i点走到i+1点会消耗掉b[i]颗糖，iko在出游的途中可以选择三个补给站，iko想知道她走完全程到达N点时口袋里最多还能剩下几颗糖（初始时iko的口袋里一颗糖都没有）。 </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入N（3&lt;=N&lt;=1000）</span><br><span class="line">第二行输入N个数代表a[1].......a[N]  (0&lt;=a[i]&lt;=1000 )</span><br><span class="line">第三行输入N-1个数代表b[1]......b[N-1]  ( 1&lt;=b[i]&lt;=1000 )</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出一个数字表示iko到达n点时口袋里最多剩下的糖，</span><br><span class="line">若不能到达N点输出-1。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p> 示例2 </p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 5 2 4</span><br><span class="line">3 2 2 2</span><br></pre></td></tr></table></figure><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先，3个补给站必须得选择第1个，因为一开始没有糖，而每条路都需要消耗糖，所以必须拿起点的糖。之后就很好理解了，每走一条路记录当前走过的补给站最大的两个，如果哪一条路糖果不够了，就把最大的补给站加上，如果还不够就把次大的也加上。每次记录走到这条路经过的最大补给站记录下来，然后现有糖果减去消耗的糖果，如果为负就把之前的最大补给站的糖果加上。例如第2组数据，初始是3，走到第1条路剩余糖果为0，此时记录的最大补给站是4，然后走到下一条路糖果变成了-2，那就把最大补给站的加上，现在剩余糖果是2。此时最大补给站记录5，再往下走是2，剩余糖果是0，继续走，消耗2个为-2，则加上最大补给站的糖5。最终就是3。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int N, cur, MAX1, MAX2, flag, a[maxn];</span><br><span class="line">void check(int &amp;cnt) &#123;</span><br><span class="line">while (cnt&amp;&amp;cur &lt; 0) &#123;</span><br><span class="line">cur += MAX1;</span><br><span class="line">MAX1 = MAX2;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fun(int i) &#123;</span><br><span class="line">if (MAX1 &lt;= a[i]) &#123;</span><br><span class="line">MAX2 = MAX1;</span><br><span class="line">MAX1 = a[i];</span><br><span class="line">&#125;</span><br><span class="line">else if (MAX2 &lt; a[i]) &#123;</span><br><span class="line">MAX2 = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N) &#123;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">MAX1 = -1, MAX2 = -1, flag = 0;</span><br><span class="line">int tmp, cnt = 3;</span><br><span class="line">cur = 0;</span><br><span class="line">for (int i = 0; i &lt; N; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">for (int i = 0; i &lt; N - 1; i++) &#123;</span><br><span class="line">fun(i);</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">cur -= tmp;</span><br><span class="line">if (cur &lt; 0) &#123;</span><br><span class="line">check(cnt);</span><br><span class="line">&#125;</span><br><span class="line">if (cur &lt; 0)</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">fun(N - 1);</span><br><span class="line">if (flag)</span><br><span class="line">printf(&quot;-1\n&quot;);</span><br><span class="line">else &#123;</span><br><span class="line">if (cnt == 2)</span><br><span class="line">cur += MAX1 + MAX2;</span><br><span class="line">else if (cnt == 1)</span><br><span class="line">cur += MAX1;</span><br><span class="line">printf(&quot;%d\n&quot;, cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZQ的睡前故事"><a href="#ZQ的睡前故事" class="headerlink" title="ZQ的睡前故事"></a><a href="https://www.nowcoder.com/acm/contest/121/D" target="_blank" rel="noopener">ZQ的睡前故事</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>​      ZQ是一个拥有n女朋友的万人迷，她的每一个女朋友每天晚上都会挨个给他打电话，要他讲了睡前故事才能睡觉。可是，每次他的女朋友都会挑他在吃鸡的时候打电话，ZQ总是因为挂机被舍友赶出宿舍，于是，ZQ告诉他的女朋友们，别打电话了，他会主动打过去给他们讲故事，再打电话就分手！ </p><p>​      于是，ZQ把他的女朋友名字写在纸上，画成一圈，顺时针编号为1~n，然后从1开始顺时针数。在每一次数数中，ZQ数k个就停下来，然后给选中的女朋友打电话讲故事。   </p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先输入一个t，然后t组数据，每行包含两个数字n,k，n&lt;20,k&gt;0</span><br></pre></td></tr></table></figure><h3 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按顺序输出每轮被选中的女朋友的编号。</span><br></pre></td></tr></table></figure><p> 示例1 </p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 3</span><br><span class="line">5 2</span><br><span class="line">11 4</span><br></pre></td></tr></table></figure><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br><span class="line">2 4 1 5 3</span><br><span class="line">4 8 1 6 11 7 3 2 5 10 9</span><br></pre></td></tr></table></figure><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>约瑟夫环。由于数据比较水，所以多种方法求解，这里不介绍了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, k, t;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">int i = 0;</span><br><span class="line">int cnt = n;</span><br><span class="line">int vis[20] = &#123; 0 &#125;;</span><br><span class="line">while (cnt) &#123;</span><br><span class="line">int kk = k;</span><br><span class="line">while (vis[i%n])</span><br><span class="line">i++;</span><br><span class="line">for (int j = 1; j &lt; kk; j++) &#123;</span><br><span class="line">i++;</span><br><span class="line">while (vis[i%n])</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">vis[i%n] = 1;</span><br><span class="line">cnt--;</span><br><span class="line">cnt ? printf(&quot;%d &quot;, i%n + 1) : printf(&quot;%d\n&quot;, i%n + 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附加：hdu5135-Little-Zu-Chongzhi’s-Triangles"><a href="#附加：hdu5135-Little-Zu-Chongzhi’s-Triangles" class="headerlink" title="附加：hdu5135 Little Zu Chongzhi’s Triangles"></a>附加：hdu5135 Little Zu Chongzhi’s Triangles</h2><p>题意：</p><p>有n条边组三角形，每个三角形必须由3条边组成，三角形边不可以重复利用，不可以共线，只能是分开的三角形。问这n条边组成的所有三角形的面积和最大为多少。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>原本状压dp求解，但数据比较水，因此递归还没有记忆化搜索直接就过了。每次从n条边里面选择3条边组成三角形，方程maxx[i],[j] = max(maxx[i-1],[j],[1~n] );由于状态是集合，因此需要状压以下。这里主要说的是一个常犯的错误。我没找到vis是当前状态是否已经选过，尤其是搜索时vis的作用非常重要。但本题用深搜时犯了一个错误，就是在vis=1,与vis=0之间多了一个continue，即vis=1，continue，dfs，vis=0，导致状态更改，数据一直错误。正确顺序应该是continue，vis=1，dfs，vis=0。因此之后比赛时一定要注意此细节。在vis=1与vis=0之间一定要注意是否有其他条件导致循环结束而状态还未还原。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int vis[15];</span><br><span class="line">double a[15];</span><br><span class="line">double dfs(int x) &#123;</span><br><span class="line">double ans = 0, maxx = 0;</span><br><span class="line">for (int i = x; i&lt;n; i++) &#123;</span><br><span class="line">if (vis[i])</span><br><span class="line">continue;</span><br><span class="line">vis[i] = 1;</span><br><span class="line">for (int j = i + 1; j&lt; n; j++) &#123;</span><br><span class="line">if (vis[j])</span><br><span class="line">continue;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">for (int k = j + 1; k&lt;n; k++) &#123;</span><br><span class="line">if (vis[k])</span><br><span class="line">continue;</span><br><span class="line">if (a[k] &gt;= a[i] + a[j] || a[j] &gt;= a[i] + a[k] || a[i] &gt;= a[j] + a[k])</span><br><span class="line">continue;</span><br><span class="line">vis[k] = 1;</span><br><span class="line">double c = (a[i] + a[k] + a[j]) / 2.0;</span><br><span class="line">ans = sqrt(c*(c - a[i])*(c - a[j])*(c - a[k]));</span><br><span class="line">ans += dfs(i + 1);</span><br><span class="line">maxx = max(maxx, ans);</span><br><span class="line"></span><br><span class="line">vis[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">vis[j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">vis[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">return maxx;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">if (!n)</span><br><span class="line">break;</span><br><span class="line">memset(a, 0, sizeof(a));</span><br><span class="line">for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">double ans = dfs(0);</span><br><span class="line">printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WWX的520&quot;&gt;&lt;a href=&quot;#WWX的520&quot; class=&quot;headerlink&quot; title=&quot;WWX的520&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/121/A&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>2018计蒜之道初赛第一场A题百度无人车</title>
    <link href="http://qianyouyou.cn/2018/05/12/2018-05-12/"/>
    <id>http://qianyouyou.cn/2018/05/12/2018-05-12/</id>
    <published>2018-05-12T14:53:29.000Z</published>
    <updated>2018-05-12T15:20:58.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百度无人车"><a href="#百度无人车" class="headerlink" title="百度无人车"></a><a href="https://nanti.jisuanke.com/t/26980" target="_blank" rel="noopener">百度无人车</a></h2><p>百度一共制造了 n 辆无人车，其中第 ii 辆车的重量为 a_i\ \mathrm{kg}ai kg。</p><p>由于车辆过重会增大轮胎的磨损程度，现在要给这 n 辆车减轻重量。每将一辆车减轻 1\ \mathrm{kg}1 kg需要消耗 p 万百度币，总预算为 s 万百度币。</p><p>现在希望你设计一种最优的减重方案，使得最重的车辆的重量是所有减重方案中最小的。任何时候，每辆车的重量必须大于等于 1\ \mathrm{kg}1 kg。并且减重方案只能减轻整数 \mathrm{kg}kg。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入一个整数 n，表示百度无人车的数量。</p><p>接下来一行输入 n 个整数，其中第 ii 个整数 a_iai表示第 ii 辆车的重量。</p><p>接着一行输入两个整数 p,s，分别表示把一辆车减重 1\ \mathrm{kg}1 kg 需要花费 p 万百度币，总的预算是 s 万百度币。</p><p>保证 1 \le n \le 200001≤n≤20000，1 \le a_i \le 200001≤ai≤20000，1 \le p \le 200001≤p≤20000，1 \le s \le 10^{18}1≤s≤1018。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示经过你设计的最优减重方案后，最重的车辆的重量是多少 \mathrm{kg}kg。</p><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6 7 8 9</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">11 14 6 13 11</span><br><span class="line">4 68</span><br></pre></td></tr></table></figure><h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>每1kg消耗p元，一共s元，因此一共可以减s/p（kg），直接s=s/p就行了。先对整个数组进行排序，然后再进行操作。一开始用二分，时间复杂度Onlogn，通不过，因此换了一种线性的方法，时间复杂度On。首先建一个差分数组，储存该元素和前一个元素的差值。以1， 2， 4， 6， 9为例，差分数组为1,1,2,2,3。然后从后往前操作。假设s=s/p之后s为10，首先s与第n个元素差分数组比较，如果大，则s-3=7。再和第n-1比较，由于该位置后面还有一个元素，因此若要改变该元素使最大值变小，需同时改变这两个数，后面以此类推三个四个数等等。s和b[n-1]<em>2即2 </em> 2比较，大，则s=7-2<em>2=3。再和b[n-2] </em> 3比较。比它小，则证明最大部分再该部分。b[n-2]=b[n-2]-s/3即1，结束循环。现在的差分数组为1,1,1,0,0，现在依次从从b[1]加到b[n就好了，即3。另外由于最小值为1，因此需要对第一个元素特判一下，如果小于1需改为1。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 200007;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">ll p, s, n;</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">a[0] = 0;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a + 1, a + n + 1);</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">b[i] = a[i] - a[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; p &gt;&gt; s;</span><br><span class="line">s /= p;</span><br><span class="line">ll ans = 0;</span><br><span class="line">for (int i = n; i&gt;0; i--) &#123;</span><br><span class="line">if (s &gt;= b[i] * (n - i + 1)) &#123;</span><br><span class="line">s -= b[i] * (n - i + 1);</span><br><span class="line">b[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">b[i] -= s / (n - i + 1);</span><br><span class="line">for (int j = 2; j &lt;= i; j++)</span><br><span class="line">ans += b[j];</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i == 1 &amp;&amp; b[i] &lt;= 1)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (b[1] &lt;= 1)</span><br><span class="line">b[1] = 1;</span><br><span class="line">ans += b[1];</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百度无人车&quot;&gt;&lt;a href=&quot;#百度无人车&quot; class=&quot;headerlink&quot; title=&quot;百度无人车&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://nanti.jisuanke.com/t/26980&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="贪心" scheme="http://qianyouyou.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="差分数组" scheme="http://qianyouyou.cn/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Wannafly挑战赛15</title>
    <link href="http://qianyouyou.cn/2018/05/11/2018-05-11/"/>
    <id>http://qianyouyou.cn/2018/05/11/2018-05-11/</id>
    <published>2018-05-11T15:55:45.000Z</published>
    <updated>2018-05-11T17:55:19.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最小化价格"><a href="#最小化价格" class="headerlink" title="最小化价格"></a>最小化价格</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  要求一种方式，使得每组人都到一个各不相同的地点，最小化选择的价格 </p><p>  每个队伍的人都要在同一个地方每个地方只能有一个队伍</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行n,m</span><br><span class="line">第二行n个数，表示每组的人数</span><br><span class="line">接下来m行，每行两个数，表示可容纳的最大人数和选择的价格</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出最小化选择的价格，无解输出-1</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">2 3 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有数据小于1e5</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先对地点以价格从小到大排序，如果相同按容量从小到大排序。由于集合每次插入自动排序，而且可以执行删除操作，因此我们可以用集合储存队伍。然后将队伍放入集合中。对排完序的地点进行遍历，每个地点对容量进行判断，直接对集合up_bound-1操作，就是能被该地点容纳的人数最多的队伍。若存在该队伍，将该队伍从集合中删除，意为该队伍匹配到该地点。然后将总价格加上该地点所需的价格。否则不执行操作，意为当前没有队伍能和该地点匹配。最后对集合判断是否为空，若为空，则证明队伍已经匹配完毕，输出总价格即可，否则意为不是所有队伍都能被容纳，输出-1。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int const maxn = 100020;</span><br><span class="line">struct node &#123;</span><br><span class="line">int pri;</span><br><span class="line">int num;</span><br><span class="line">&#125;loc[maxn];</span><br><span class="line">int cmp(node a, node b) &#123;</span><br><span class="line">if (a.pri == b.pri)</span><br><span class="line">return a.num &lt; b.num;</span><br><span class="line">else</span><br><span class="line">return a.pri &lt; b.pri;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, tmp, ans = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">multiset&lt;int&gt;a;</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">a.insert(tmp);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">cin &gt;&gt; loc[i].num &gt;&gt; loc[i].pri;</span><br><span class="line">&#125;</span><br><span class="line">sort(loc, loc + m, cmp);</span><br><span class="line">multiset&lt;int&gt;::iterator it;</span><br><span class="line">for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">if (a.empty())</span><br><span class="line">break;</span><br><span class="line">it = a.upper_bound(loc[i].num);</span><br><span class="line">if (it == a.begin())</span><br><span class="line">continue;</span><br><span class="line">it--;</span><br><span class="line">ans += loc[i].pri;</span><br><span class="line">a.erase(it);</span><br><span class="line">&#125;</span><br><span class="line">if (a.empty())</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="车辆安排"><a href="#车辆安排" class="headerlink" title="车辆安排"></a>车辆安排</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有n个队伍，每个队伍的人数小于等于5，每辆车最多坐5个人，要求一个队伍的人都在一辆车上，求最少的车数</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行n</span><br><span class="line">第二行n个数，表示每个队伍的人数</span><br></pre></td></tr></table></figure><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出最少车数</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n≤1e5</span><br><span class="line">每个数小于等于5</span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>设置一个数组，分别储存1,2,3,4,5人队伍的个数。总车数=人数为5的队伍数+（人数为4+1或4的队伍数）+（人数为3+2或3+1+1或3的队伍数）+（人数为2+2+1或2+1+1+1或2的队伍数）+（人数为1*5或1的队伍数），（组合方式按优先级排列）。时间复杂度O(1)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, tmp;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">int a[6] = &#123; 0 &#125;, sum = 0;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">a[tmp]++;</span><br><span class="line">&#125;</span><br><span class="line">sum += a[5] + a[4] + a[3];</span><br><span class="line">a[1] = a[1] - a[4];</span><br><span class="line">if (a[3] - a[2] &gt; 0)</span><br><span class="line">a[1] -= 2 * (a[3] - a[2]);</span><br><span class="line">a[2] -= a[3];</span><br><span class="line">if (a[2] &lt; 0)</span><br><span class="line">a[2] = 0;</span><br><span class="line">a[1] -= a[2] / 2;</span><br><span class="line">if (a[2] % 2 == 0) &#123;</span><br><span class="line">sum += a[2] / 2;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">sum += a[2] / 2 + 1;</span><br><span class="line">a[1] -= 3;</span><br><span class="line">&#125;</span><br><span class="line">if (a[1] &lt; 0)</span><br><span class="line">a[1] = 0;</span><br><span class="line">a[1] % 5 == 0 ? sum += a[1] / 5 : sum += a[1] / 5 + 1;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>约瑟夫问题(约瑟夫问题)，n个人，1 2报数 1出队( 就是体育课的时候1 2报数 1出队，2留下)，q次询问，每次求第x个人是第几个出队的</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行两个数n,q</span><br><span class="line">接下来q行，每行一个数x，表示询问</span><br></pre></td></tr></table></figure><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行输出一个询问的答案</span><br></pre></td></tr></table></figure><p>示例1</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4围成一圈，第一轮：1 2报数，1出队，2留下，3出队，4留下，第二轮，2出队，4留下</span><br></pre></td></tr></table></figure><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q≤500000</span><br><span class="line">n和x≤1e18</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll unsigned long long int</span><br><span class="line">map&lt;ll, ll&gt;ma;</span><br><span class="line">vector&lt;ll&gt;v;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, q , cnt;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">ma[1] = 1;</span><br><span class="line">cnt = 1;</span><br><span class="line">for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">if (i % 2 == 0)</span><br><span class="line">v.push_back(i);</span><br><span class="line">else &#123;</span><br><span class="line">ma[i] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll it = 0;</span><br><span class="line">if (n % 2)</span><br><span class="line">it++;</span><br><span class="line">while (!v.empty()) &#123;</span><br><span class="line">if (it == v.size())</span><br><span class="line">it = 0;</span><br><span class="line">ma[*(v.begin() + it)] = ++cnt;</span><br><span class="line">v.erase(v.begin() + it);</span><br><span class="line">if (v.empty())</span><br><span class="line">break;</span><br><span class="line">if (it == v.size())</span><br><span class="line">it = 0;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">while (q--) &#123;</span><br><span class="line">int x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; ma[x] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最小化价格&quot;&gt;&lt;a href=&quot;#最小化价格&quot; class=&quot;headerlink&quot; title=&quot;最小化价格&quot;&gt;&lt;/a&gt;最小化价格&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;
      
    
    </summary>
    
      <category term="训练之路" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="题解" scheme="http://qianyouyou.cn/categories/%E8%AE%AD%E7%BB%83%E4%B9%8B%E8%B7%AF/%E7%AE%97%E6%B3%95/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>[计算几何]二维计算几何基础</title>
    <link href="http://qianyouyou.cn/2018/05/09/2018-05-09/"/>
    <id>http://qianyouyou.cn/2018/05/09/2018-05-09/</id>
    <published>2018-05-09T13:42:37.000Z</published>
    <updated>2018-05-12T06:16:14.200Z</updated>
    
    <content type="html"><![CDATA[<p>三寸青笺，写不尽对你的思念。——随笔</p><p>用解析几何借助计算机处理几何问题存在着两大缺陷：</p><p>1）方程解的情况复杂，例如Ax+By+C=0；</p><p>2）存在着浮点误差积累。</p><p>计算几何采用了介于代数与几何之间的方式解决几何问题。它利用几何特性辅助简单的代数运算解决几何问题，既能精确求解，有提高了算法效率，并且不失几何的优美特性。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="向量-1"><a href="#向量-1" class="headerlink" title="向量"></a>向量</h3><p>向量：既有大小又有方向的量。</p><h4 id="向量的比较"><a href="#向量的比较" class="headerlink" title="向量的比较"></a>向量的比较</h4><p>在平面坐标系下，某点的坐标用（x，y）表示，向量和点一样，也可以用x,y表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;//点</span><br><span class="line">    double x,y;</span><br><span class="line">    Point(double x=0,double y=0):x(x),y(y) &#123;&#125;//构造函数方便代码编写</span><br><span class="line">&#125;;</span><br><span class="line">typedef Point Vector;//向量。从程序实现上，Vector只是Point的别名</span><br></pre></td></tr></table></figure><h4 id="向量的加减乘除"><a href="#向量的加减乘除" class="headerlink" title="向量的加减乘除"></a>向量的加减乘除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//向量+向量=向量，点+向量=点</span><br><span class="line">Vector operator + (Vector A, Vector B) &#123;</span><br><span class="line">return Vector(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br><span class="line">//点-点=向量</span><br><span class="line">Vector operator - (Point A, Point B) &#123;</span><br><span class="line">return Vector(A.x - B.x, A.y - B.y);</span><br><span class="line">&#125;</span><br><span class="line">//向量*数=向量</span><br><span class="line">Vector operator * (Vector A, double p) &#123;</span><br><span class="line">return Vector(A.x * p, A.y * p);</span><br><span class="line">&#125;</span><br><span class="line">//向量/数=向量</span><br><span class="line">Vector operator / (Vector A, double p) &#123;</span><br><span class="line">return Vector(A.x / p, A.y / p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向量的比较-1"><a href="#向量的比较-1" class="headerlink" title="向量的比较"></a>向量的比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool operator &lt; (const Point&amp; a, const Point&amp; b) &#123;</span><br><span class="line">return a.x &lt; b.x || (a.x == b.x&amp;&amp;a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line">//减下误差的必要比较</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">int dcmp(double x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fabs(x)&lt;eps) return 0;</span><br><span class="line">    if(x&gt;0) return 1;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">bool operator ==(const point&amp; a,const point&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的“相等”函数用到“三态函数”dcmp,减少了精度问题。另外，向量有一个所谓的“极角”，即从x轴正半轴旋转到该向量方向所需要的角度。C标注库里的atan2函数就是用来求极角的。如向量（x,y）的极角就是atan2（y，x）（单位：弧度）</p><h3 id="向量內积（点积）"><a href="#向量內积（点积）" class="headerlink" title="向量內积（点积）"></a>向量內积（点积）</h3><p>点积，向量α和β的点积等于二者长度的乘积再乘上它们夹角的余弦。当夹角大于90°时点积为负。两向量的点积为一个标量 α·β，它的大小为α·β=|α||β|cosθ，其中θ是&lt;α,β&gt;</p><p>余弦为偶函数，因此点积满足交换率。如果两向量垂直，点积为0。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%82%B9%E7%A7%AF%E5%85%AC%E5%BC%8F.png" alt=""></p><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>α在β的投影α’与β的长度乘积</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E7%82%B9%E7%A7%AF%E5%9B%BE%E7%A4%BA.png" alt=""></p><p>由定义易知当两向量夹角为锐角时点积值为正，夹角钝角为负，垂直为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double dot(Vector A,Vector B)&#123;    //向量点积</span><br><span class="line">    return A.x*B.x+A.y*B.y;</span><br><span class="line">&#125;</span><br><span class="line">double Length(Vector A)&#123;    //向量A长度</span><br><span class="line">    return sqrt(dot(A,A));</span><br><span class="line">&#125;</span><br><span class="line">double angle(Vector A,Vector B)&#123;    //向量A和B夹角</span><br><span class="line">    return acos(dot(A,B)/Length(A)/Length(B));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向量外积（叉积）"><a href="#向量外积（叉积）" class="headerlink" title="向量外积（叉积）"></a>向量外积（叉积）</h3><p>简单地说，两个向量u和w得叉积等于u和w组成的三角形的有向面积的两倍。</p><p>叉积的二维意义—-有向面积：外积大小为由u，w这两个向量围成的平行四边形有向面积。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%8F%89%E7%A7%AF%E5%9B%BE%E7%A4%BA.png" alt=""></p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%8F%89%E7%A7%AF%E5%85%AC%E5%BC%8F.png" alt=""></p><p>两向量的叉积为一个矢量 a×b，设向量 P(x1,y1),Q(x2,y2)，向量 a 和向量 b 的叉积还是一个向量，长度为|PQ|=x1y2-x2y1;即为向量 P,Q 围成的四边形的面积。它的方向与向量PQ 垂直，并且使(P,Q,P×Q)成右手系。 </p><h4 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%8F%89%E7%A7%AF%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89.png" alt=""></p><p>不难发现，叉积不满足交换率，cross（u，w）=-corss（w，u）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double cross(Vector A,Vector B)  //叉积</span><br><span class="line">&#123;</span><br><span class="line">    return A.x*B.y-A.y*B.x;</span><br><span class="line">&#125;</span><br><span class="line">double area(point A,point B,point C)//已知三个点 p0,p1,p2 的叉积函数</span><br><span class="line">&#123;</span><br><span class="line">    return cross(B-A,C-A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叉积的一个重要性质，判断两向量互相之间的顺逆时针关系。<br>若 P×Q&gt;0，则P在Q 的顺时针方向；<br>若 P×Q&lt;0，则P在Q 的逆时针方向；<br>若 P×Q=0，则P和Q 共线，但可能同向也可能反向；</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-9-1.png" alt=""></p><p>利用这一性质，可以将一个多边形的顶点按照顺时针或者逆时针方向排序，这就是极角排序。利用 sort 或者 qsort 函数，自己定义 cmp 函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//逆时针极角排序比较函数(double) </span><br><span class="line">bool cmp(const point &amp;a, const point &amp;b) &#123; </span><br><span class="line">double x = atan2(a.y, a.x), y = atan2(b.y, b.x); </span><br><span class="line">return x &lt; y; </span><br><span class="line">&#125; </span><br><span class="line">//象限极角排序比较函数(int)，不失精度 </span><br><span class="line">int cross(point p1,point p2,point p0)&#123; </span><br><span class="line">return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y); </span><br><span class="line">&#125; </span><br><span class="line">sort(p+1,p+n,cmp);</span><br></pre></td></tr></table></figure><h3 id="两向量的位置关系"><a href="#两向量的位置关系" class="headerlink" title="两向量的位置关系"></a>两向量的位置关系</h3><p>把叉积和点积组合在一起，很容易判断两向量的位置关系。如图所示，括号第一个数是点积的符号，第二个是叉积的符号。第一个向量u总是向右，另一个向量w的各种情况都包含在了图中。比如当w的中点在下图左上方的第二象限时点积为负担叉积均为正，用（-，+）表示。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/5-9-2.png" alt=""></p><h2 id="点和直线"><a href="#点和直线" class="headerlink" title="点和直线"></a>点和直线</h2><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>点到直线的距离是一个常用函数，可以用叉积求出，即用平行四边形的面积除以底。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double DistoLine(point P,point A,point B) //点p到直线AB距离</span><br><span class="line">&#123;</span><br><span class="line">    Vector v1=B-A,v2=P-A;</span><br><span class="line">    return fabs(cross(v1,v2))/Length(v1);//如果不取绝对值，得到的是有向距离</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h3><p>点到线段有两种可能：</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E7%82%B9%E5%88%B0%E7%BA%BF%E6%AE%B5%E8%B7%9D%E7%A6%BB.png" alt=""></p><p>简单地说，设投影点为Q，如果Q在线段AB上，则所求距离就是P点直线AB的距离（右）。如果Q在射线BA上，则所求为PA距离；否则为PB距离。判断Q的位置可以用点积进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double DistoSegment(point P,point A,point B)&#123;</span><br><span class="line">    if(A==B) return Length(P-A);</span><br><span class="line">    Vector v1=B-A,v2=P-A,v3=P-B;</span><br><span class="line">    if(dcmp(dot(v1,v2))&lt;0) return Length(v2);</span><br><span class="line">    if(dcmp(dot(v1,v3))&gt;0) return Length(v3);</span><br><span class="line">    return fabs(cross(v1,v2))/Length(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a>判断点是否在线段上</h4><p>判断点 Q 在线段 P1P2 上的两条依据：<br>①(Q-P1)*(P2-P1)=0;<br>②Q 在以 P1,P2 为对角顶点的矩形内。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool onSegment(point p1,point p2,point Q)&#123;</span><br><span class="line">if( (Q.x-p1.x)*(p2.y-p1.y)==(p2.x-p1.x)*(Q.y-p1.y)&amp;&amp;min(p1.x,p2.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(p1.x,p2.x)&amp;&amp;min(p1.y,p2.y)&lt;=Q.y&amp;&amp;Q.y&lt;= max(p1.y,p2.y) )</span><br><span class="line">return 1;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段相交"><a href="#线段相交" class="headerlink" title="线段相交"></a>线段相交</h3><p>最为直观的想法：解析几何法</p><p>弊端：运算误差大，运算次数多</p><p>误差来源：浮点运算</p><p>另外，编程难度事实上也很大（区域判断）</p><p>计算几何做法：运用叉积点积和位置关系</p><h4 id="线段规范相交"><a href="#线段规范相交" class="headerlink" title="线段规范相交"></a>线段规范相交</h4><p>定义线段规范相交为两线段相交恰好有一个公共点且不是任一线段的端点</p><p>充要条件：每条线段的两个端点都在另一条线段的两侧</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E8%A7%84%E8%8C%83%E7%9B%B8%E4%BA%A4%E4%B8%8E%E9%9D%9E%E8%A7%84%E8%8C%83%E7%9B%B8%E4%BA%A4.png" alt=""></p><p>只有（1）是规范相交，其它是非规范相交。非规范相交的情况还有很多。</p><h5 id="跨立实验"><a href="#跨立实验" class="headerlink" title="跨立实验"></a>跨立实验</h5><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E8%B7%A8%E7%AB%8B%E5%AE%9E%E9%AA%8C.png" alt=""></p><h5 id="规范相交"><a href="#规范相交" class="headerlink" title="规范相交"></a>规范相交</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool SegmentItersection(point a1, point a2, point b1, point b2)</span><br><span class="line">&#123;</span><br><span class="line">    double c1 = cross(a2-a1, b1-a1), c2 = cross(a2-a1, b2-a1),</span><br><span class="line">    c3 = cross(b2-b1, a1-b1), c4 = cross(b2-b1, a2-b1);</span><br><span class="line">    return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线段相交-1"><a href="#线段相交-1" class="headerlink" title="线段相交"></a>线段相交</h5><p>如果允许在端点处相交怎么办？</p><p>首先可能共线重叠</p><p>其次就是交点是端点</p><p>如果交点是端点</p><p>就判断几次点是否在线段上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断点p是否在线段a1 a2上</span><br><span class="line">bool OnSegment(point p,point a1,point a2)</span><br><span class="line">&#123;</span><br><span class="line">  return dcmp(cross(a1-p,a2-p))==0&amp;&amp;dcmp(dot(a1-p,a2-p))&lt;0; //线段包含端点时改成&lt;=</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形问题"><a href="#多边形问题" class="headerlink" title="多边形问题"></a>多边形问题</h2><h3 id="多边形面积"><a href="#多边形面积" class="headerlink" title="多边形面积"></a>多边形面积</h3><p>两向量的叉积的几何意义是以这两个向量为邻边的平行四边形的有向面积，我们可以利用这一点来求简单多边形的面积。所谓简单多边形就是任何不相邻的两条边都没有交点，包括凸多边形和凹多边形。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%87%B8.png" alt=""><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%87%B9.png" alt=""></p><p>求下面多边形的面积，已知个顶点的坐标。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF.png" alt=""></p><p>注意：在引入叉积后，面积就可以为负值，就有了“负面积”的概念。“负面积”方便了我们的运算。</p><p>可以取p[0]点为划分顶点，一方面可以少算两个叉积（0和任何向量的叉积都等于0），另一方面也减少乘法溢出的可能性，还不用特殊处理（i=n-1时，下一个顶点p[0]而不是p[n]，因为p[n]不存在）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//取p[0]为划分顶点</span><br><span class="line">double PolygonArea(vector&lt;Point&gt; p) &#123;</span><br><span class="line">  int n = p.size();</span><br><span class="line">  double area = 0;</span><br><span class="line">  for(int i = 1; i &lt; n-1; i++)</span><br><span class="line">    area += Cross(p[i]-p[0], p[i+1]-p[0]);</span><br><span class="line">  return area/2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以取坐标原点为划分点，乘法次数减少。</p><h3 id="点在多边形内外判断"><a href="#点在多边形内外判断" class="headerlink" title="点在多边形内外判断"></a>点在多边形内外判断</h3><h4 id="判断点是否在三角形内"><a href="#判断点是否在三角形内" class="headerlink" title="判断点是否在三角形内"></a>判断点是否在三角形内</h4><p>点 P 在三角形 ABC 内部常用的又两种方法，面积法和叉积法，面积法即为 </p><p>S△PAB+S△PAC+S△PBC=S△ABC </p><p>其中三角形面积计算公式为 S=1/2×|cross(a,b)| </p><p>叉积法 </p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E7%82%B9%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt=""></p><p>利用叉积的正负号判断，如图所示，AP 在向量 AC 的顺时针方向，CP 在向量 BC 的顺时针方向，BP 在向量 BC 的顺时针方向，利用这一性质推广，那么可以利用叉积的正负号来判断一个点是否在一个凸多边形内部。</p><h4 id="判断点是否在多边形内"><a href="#判断点是否在多边形内" class="headerlink" title="判断点是否在多边形内"></a>判断点是否在多边形内</h4><p>一般而言，该问题有射线法和转角法两种处理手段</p><p>射线法：从这个点出发引向无穷远点一条直线，根据交点情况确定点的位置</p><p>转角法：计算多边形每条边的转角，若最后相消为0则在外部，否则在内部</p><p>射线法：特殊情况不易处理</p><p>转角法：三角运算时间开销大</p><h5 id="射线法"><a href="#射线法" class="headerlink" title="射线法"></a>射线法</h5><p>以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。</p><p>若有偶数个交点则在形外，否则在形内。</p><p>若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。</p><h5 id="转角法"><a href="#转角法" class="headerlink" title="转角法"></a>转角法</h5><p>把多边形每条边的转角加起来，如果是360度，就在多边形内，如果是0度就在外面，180度则是在边界上</p><p>直接最要求角度用到反三角函数精度差且费时</p><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>假设有一条向右的射线，统计多边形穿过这条射线正反多少次，把这个数记为绕数wn，逆时针穿过时，wn加1，顺时针穿过时，wn减1。</p><p>注意在程序实现时，判断是否穿过，以及穿过方向时，需要用叉积判断输入点在左边还是右边。</p><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int isPointinPolygon(point p,vector&lt;point&gt;poly)</span><br><span class="line">&#123;</span><br><span class="line">    int wn=0;</span><br><span class="line">    int n=poly.size();</span><br><span class="line">    for (int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (OnSegment(p,poly[i],poly[(i+1)%n])) return -1;    //边界</span><br><span class="line">        int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));</span><br><span class="line">        int d1=dcmp(poly[i].y-p.y);</span><br><span class="line">        int d2=dcmp(poly[(i+1)%n].y - p.y);</span><br><span class="line">        if (k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++;</span><br><span class="line">        if (k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (wn!=0) return 1;  //内部</span><br><span class="line">    return 0;   //外部</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点在凸多边形内的判定更简单，只需判断是否在所有边的左边（假设各个顶点按照逆时针顺序排列）</p><h3 id="多边形重心"><a href="#多边形重心" class="headerlink" title="多边形重心"></a>多边形重心</h3><h4 id="三角形重心"><a href="#三角形重心" class="headerlink" title="三角形重心"></a>三角形重心</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83.png" alt=""></p><h4 id="多边形重心-1"><a href="#多边形重心-1" class="headerlink" title="多边形重心"></a>多边形重心</h4><p>将多边形拆分为N个三角形，分别求其重心和面积，可以想象，原来的质量均匀分布在内部的区域上，而现在质量仅分布在这N个重心点上（等价变换），这时就可以利用刚才猜想的公式了。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%87%8D%E5%BF%83.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">point PolyGravity(point *p,int n)</span><br><span class="line">&#123;</span><br><span class="line">    point ans=point(0,0);</span><br><span class="line">    double sumArea=0,area;</span><br><span class="line">    for(int i=2;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        area=cross(p[i-1]-p[0],p[i]-p[0]);</span><br><span class="line">        sumArea+=area;</span><br><span class="line">        ans.x+=(p[0].x+p[i-1].x+p[i].x)*area;</span><br><span class="line">        ans.y+=(p[0].y+p[i-1].y+p[i].y)*area;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans/(sumArea*3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析几何"><a href="#解析几何" class="headerlink" title="解析几何"></a>解析几何</h2><p>交点的计算：求两线段，两直线，线段和直线的交点<br>①判断两线段是否相交：<br>我们分两步确定两条线段是否相交：<br>(1)快速排斥试验<br>设以线段 P1P2 为对角线的矩形为 R， 设以线段 Q1Q2 为对角线的矩形为 T，如果R和T不相交，显然两线段不会相交。<br>(2)跨立试验<br>如果两线段相交，则两线段必然相互跨立对方。若 P1P2 跨立 Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，即 ( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( P2 - Q1 ) × ( Q2 - Q1 ) &lt; 0。<br>上式可改写成 ( P1 - Q1 ) × ( Q2 - Q1 ) </em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt; 0。<br>当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2 上；同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2 上。所以判断 P1P2 跨立 Q1Q2 的依据是： </p><p>( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。<br>同理判断 Q1Q2 跨立 P1P2 的依据是：<br>( Q1 - P1 ) × ( P2 - P1 ) </em> ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/2018-5-11-%E5%AE%9E%E9%AA%8C.png" alt=""></p><p>另外，“规范相交”指的是两条线段恰有唯一一个不是端点的公共点；而如果一条线段的一个端点在另一条线段上，或者两条线段部分重合，则视为“非规范相交”，以下代码是“非规范相交”。 </p><p>结合 poj2653 练习，代码可参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const double eps = 1e-10;</span><br><span class="line">struct point &#123; double x, y; &#125;;</span><br><span class="line">struct Line &#123; point begin, end; &#125;line[100001];</span><br><span class="line">double min(double a, double b) &#123; return a&lt;b ? a : b; &#125;</span><br><span class="line">double max(double a, double b) &#123; return a&gt;b ? a : b; &#125;</span><br><span class="line">bool inter(const Line &amp; M, const Line &amp; N) &#123;</span><br><span class="line">point a = M.begin; point b = M.end;</span><br><span class="line">point c = N.begin; point d = N.end;</span><br><span class="line">if (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y)&gt;max(c.y, d.y) || min(c.x, d.x)&gt;max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y)) return 0;</span><br><span class="line">double h, i, j, k;</span><br><span class="line">h = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);</span><br><span class="line">i = (b.x - a.x)*(d.y - a.y) - (b.y - a.y)*(d.x - a.x);</span><br><span class="line">j = (d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x);</span><br><span class="line">k = (d.x - c.x)*(b.y - c.y) - (d.y - c.y)*(b.x - c.x);</span><br><span class="line">return h*i &lt;= eps&amp;&amp;j*k &lt;= eps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②判断两直线是否相交：<br>首先判断两条直线是否在一条直线上，或者两条直线平行，否则一定相交，不平行且不在一条直线上则相交并且求出交点。<br>可结合 hrbustoj1104 练习，代码可参考： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">int main() &#123;</span><br><span class="line">int t;</span><br><span class="line">double x1, x2, x3, x4, y1, y2, y3, y4, x, y;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--) &#123;</span><br><span class="line">scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x3, &amp;y3, &amp;x4, &amp;y4);</span><br><span class="line">if ((x2 - x1)*(y4 - y3) == (x4 - x3)*(y2 - y1)) &#123;</span><br><span class="line">if ((x3 - x1)*(y4 - y2) == (x4 - x2)*(y3 - y1) &amp;&amp; (y4 - y3) != 0)</span><br><span class="line">puts(&quot;LINE&quot;);//在一条直线的情况 </span><br><span class="line">else</span><br><span class="line">puts(&quot;NONE&quot;);//平行的情况 </span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">x = ((y1*(x2 - x1) - x1*(y2 - y1))*(x4 - x3) - (y3*(x4 - x3) - x3*(y4 -</span><br><span class="line">y3))*(x2 - x1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3));</span><br><span class="line">y = ((y1*(x2 - x1) - x1*(y2 - y1))*(y4 - y3) - (y3*(x4 - x3) - x3*(y4 -</span><br><span class="line">y3))*(y2 - y1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3));</span><br><span class="line">printf(&quot;POINT %.2f %.2f\n&quot;, x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③判断线段和直线的交点：<br>poj1039 判断直线和线段是否相交并求出交点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#define eps 1.0e-8 </span><br><span class="line">struct Point &#123;</span><br><span class="line">double x, y;</span><br><span class="line">&#125; point[25];</span><br><span class="line">int n;</span><br><span class="line">double ans;</span><br><span class="line">bool ok;</span><br><span class="line">double intersect(Point a1, Point b1, Point a2, Point b2) &#123;</span><br><span class="line">double x1 = a1.x, x2 = b1.x, x3 = a2.x, x4 = b2.x;</span><br><span class="line">double y1 = a1.y, y2 = b1.y, y3 = a2.y, y4 = b2.y;</span><br><span class="line">double x = (y3 - y1 + x1*(y2 - y1) / (x2 - x1) - x3*(y4 - y3) / (x4 - x3)) / ((y2 -</span><br><span class="line">y1) / (x2 - x1) - (y4 - y3) / (x4 - x3));</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">void work(Point a, Point b) &#123;</span><br><span class="line">b.y -= 1;</span><br><span class="line">for (int i = 0; i&lt;n; i++) &#123;</span><br><span class="line">Point p, q1, q2;</span><br><span class="line">p.x = point[i].x;</span><br><span class="line">p.y = a.y - (b.y - a.y) / (b.x - a.x)*(a.x - p.x);</span><br><span class="line">if ((p.y + eps&lt;point[i].y&amp;&amp;p.y - eps&gt;point[i].y - 1) ||</span><br><span class="line">abs(p.y - point[i].y)&lt;eps || abs(p.y - point[i].y + 1)&lt;eps)</span><br><span class="line">continue;</span><br><span class="line">if (i == 0) return;</span><br><span class="line">if (p.y - eps&gt;point[i].y)</span><br><span class="line">ans = max(ans, intersect(a, b, point[i - 1], point[i]));</span><br><span class="line">else &#123;</span><br><span class="line">q1 = point[i - 1];</span><br><span class="line">q1.y -= 1;</span><br><span class="line">q2 = point[i];</span><br><span class="line">q2.y -= 1;</span><br><span class="line">ans = max(ans, intersect(a, b, q1, q2));</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">ok = true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n), n) &#123;</span><br><span class="line">for (int i = 0; i&lt;n; i++)</span><br><span class="line">scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y);</span><br><span class="line">ans = point[0].x;</span><br><span class="line">ok = false;</span><br><span class="line">for (int i = 0; i&lt;n; i++)</span><br><span class="line">for (int j = 0; j&lt;n; j++)</span><br><span class="line">if (i != j&amp;&amp;!ok)</span><br><span class="line">work(point[i], point[j]);</span><br><span class="line">if (ok)</span><br><span class="line">printf(&quot;Through all the pipe.\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%.2f\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三寸青笺，写不尽对你的思念。——随笔&lt;/p&gt;
&lt;p&gt;用解析几何借助计算机处理几何问题存在着两大缺陷：&lt;/p&gt;
&lt;p&gt;1）方程解的情况复杂，例如Ax+By+C=0；&lt;/p&gt;
&lt;p&gt;2）存在着浮点误差积累。&lt;/p&gt;
&lt;p&gt;计算几何采用了介于代数与几何之间的方式解决几何问题。它利
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="计算几何" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
    
      <category term="C/C++" scheme="http://qianyouyou.cn/tags/C-C/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="计算几何" scheme="http://qianyouyou.cn/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="点积/叉积" scheme="http://qianyouyou.cn/tags/%E7%82%B9%E7%A7%AF-%E5%8F%89%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>[博弈论]博弈论基本题型及5大常见博弈论原理</title>
    <link href="http://qianyouyou.cn/2018/05/08/2018-05-08/"/>
    <id>http://qianyouyou.cn/2018/05/08/2018-05-08/</id>
    <published>2018-05-08T14:20:44.000Z</published>
    <updated>2018-06-02T05:25:48.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><p>根据题目的意思，看它属于哪种博弈，属于哪种博弈的变形。 然后根据对应的博弈模型的解题策略来求解， 有时候并不一定能够直接看出它属于哪种模型，那这个时候就可以通过判断自己每步可选的策略，对于自己每步走的，对当前局势的影响。然后推断出与之相对应的博弈模型。</p><h3 id="巴什博奕（Bash-Game）"><a href="#巴什博奕（Bash-Game）" class="headerlink" title="巴什博奕（Bash Game）"></a>巴什博奕（Bash Game）</h3><p>有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。</p><p>假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。</p><p>胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int iCase;</span><br><span class="line">cin &gt;&gt; iCase;</span><br><span class="line">while (iCase--) &#123;</span><br><span class="line">int n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="威佐夫博奕（Wythoff-Game）"><a href="#威佐夫博奕（Wythoff-Game）" class="headerlink" title="威佐夫博奕（Wythoff Game）"></a>威佐夫博奕（Wythoff Game）</h3><p>有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p><p>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 </p><p> 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质：</p><p>1。任何自然数都包含在一个且仅有一个奇异局势中。</p><p>2。任意操作都可将奇异局势变为非奇异局势。</p><p>3。采用适当的方法，可以将非奇异局势变为奇异局势。</p><p>两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。</p><p>如何判定是否是奇异局势呢？</p><p>有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) </p><p>其中（1+√5）/2 = 1.618…,即为黄金分割数。因此,由 ak，bk 组成的矩形近似为黄金矩形，由于 2/（1+√5）=（√5-1）/2，可以先求出 j=[a（√5-1）/2]，若a=[ j（1+√5）/2]，那么 a = aj，bj = aj + j，若不等于，那么 a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;math.h&gt; </span><br><span class="line">const double ep1 = (sqrt(5.0) - 1.0) / 2.0;</span><br><span class="line">const double ep2 = (sqrt(5.0) + 1.0) / 2.0;</span><br><span class="line">int main() &#123;</span><br><span class="line">int m, n;</span><br><span class="line">while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123;</span><br><span class="line">if (m &gt; n) &#123;</span><br><span class="line">int tmp;</span><br><span class="line">tmp = m, m = n, n = tmp;</span><br><span class="line">&#125;</span><br><span class="line">int id = m * ep1;</span><br><span class="line">int tmp1 = ep2 * id, tmp2 = id + tmp1;</span><br><span class="line">int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3;</span><br><span class="line">if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;);</span><br><span class="line">else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;);</span><br><span class="line">else printf(&quot;1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契博弈（Fibonacci-Nim）"><a href="#斐波那契博弈（Fibonacci-Nim）" class="headerlink" title="斐波那契博弈（Fibonacci Nim）"></a>斐波那契博弈（Fibonacci Nim）</h3><p>有一堆个数为 n 的石子，游戏双方轮流取石子，满足</p><p>1)先手不能在第一次把所有的石子取完； </p><p>2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。</p><p>约定取走最后一个石子的人为赢家，求必败态。</p><p>这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 </p><p>胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 </p><p>证明：</p><p>这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 </p><p> FIB 数列的必败证明：</p><p>1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 </p><p>2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">long long int f[50];</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, i;</span><br><span class="line">f[0] = f[1] = 1;</span><br><span class="line">for (i = 2; i &lt; 50; i++) &#123;</span><br><span class="line">f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">if (n == 0) break;</span><br><span class="line">for (i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">if (f[i] == n) break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K倍博弈"><a href="#K倍博弈" class="headerlink" title="K倍博弈"></a>K倍博弈</h3><p>共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。</p><p>当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1，然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 </p><p>当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。</p><p>当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。</p><p>设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2000000;</span><br><span class="line">int a[maxn], b[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k;</span><br><span class="line">int cas = 0, cass;</span><br><span class="line">for (scanf(&quot;%d&quot;, &amp;cass); cass--;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">++cas;</span><br><span class="line">printf(&quot;Case %d: &quot;, cas);</span><br><span class="line">int i = 0, j = 0;</span><br><span class="line">a[0] = b[0] = 1;</span><br><span class="line">while (a[i]&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">a[i] = b[i - 1] + 1;</span><br><span class="line">while (a[j + 1] * k&lt;a[i])</span><br><span class="line">j++;</span><br><span class="line">if (a[j] * k&lt;a[i])</span><br><span class="line">b[i] = a[i] + b[j];</span><br><span class="line">else</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">if (a[i] == n)</span><br><span class="line">puts(&quot;lose&quot;);</span><br><span class="line">else puts(&quot;win&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SG函数的求解-SG博弈）"><a href="#SG函数的求解-SG博弈）" class="headerlink" title="ＳＧ函数的求解(SG博弈）"></a>ＳＧ函数的求解(SG博弈）</h3><p>给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。</p><p>这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。</p><p>下 面我们就在有向无环图的顶点上定义 Sprague-Garundy 函数。首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 </p><p>对于一个给定的有向无环图，定义关于图的每个顶点的 Sprague-Grundy 函数 g如下：<strong>g(x)=mex{ g(y) | y 是 x 的后继 }</strong>。</p><p>SG 函数的性质：</p><p>1.首先，所有的 terminal position 所对应的顶点，也就是没有出边的顶点，其 SG 值为 0，因为它的后继集合是空集。</p><p>2.然后对于一个 g(x)=0 的顶点 x，它的所有后继 y 都满足 g(y)!=0。</p><p>3.对于一个 g(x)!=0 的顶点，必定存在一个后继 y 满足 g(y)=0。 </p><p>以上这三句话表明，顶点 x 所代表的 postion 是 P-position 当且仅当 g(x)=0。我们通过计算有向无环图的每个顶点的 SG 值，就可以对每种局面找到必胜策略了。</p><h4 id="Nim-游戏的规则："><a href="#Nim-游戏的规则：" class="headerlink" title="Nim 游戏的规则："></a>Nim 游戏的规则：</h4><p>每次选择 一堆数量为 k 的石子，可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k不变。</p><h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>假设不是一枚棋子，而是n枚棋子，如何获胜？</p><p>让我们再来考虑一下顶点的 SG 值的意义。当 g(x)=k 时，表明对于任意一个0&lt;=i&lt;k，都存在 x 的一个后继 y 满足 g(y)=i。也 就是说，当某枚棋子的 SG 值是 k 时，我们可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k 不变。</p><p>这表明，如果将 n 枚棋子所在的顶 点的 SG 值看作 n 堆相应数量的石子，那么这个 Nim 游戏的每个必胜策略都对应于原来这 n 枚棋子的必胜策略！</p><p>对于 n 个棋子，设它们对应的顶点的 SG 值分别为(a1,a2,…,an)，再设局面(a1,a2,…,an)时的 Nim 游戏的一种必胜策略是把 ai 变成 k，那么原游戏的一种必胜策略就是把第 i 枚棋子移动到一个 SG 值为 k 的顶点。</p><p>其实我们还是只要证明这种多棋子的有向图游戏的局面是 P-position 当且仅当所有棋子所在的位置的 SG 函数的异或为 0。这个证明与上节的 Bouton’s Theorem 几乎是完全相同的，只需要适当的改几个名词就行了。</p><p>刚才，我为了使问题看上去更容易一些，认为 n 枚棋子是在一个有向图上移动，但如果不是在一个有向图上，而是每个棋子在一个有向图上，每次可 以任选一个棋子（也就是任选一个有向图）进行移动，这样也不会给结论带来任何变化。 所以我们可以定义有向图游戏的和(Sum of Graph Games)：设 G1、G2、……、Gn是 n 个有向图游戏，定义游戏 G 是 G1、G2、……、Gn 的和(Sum)，游戏 G的移动规则是：任选一个子游戏 Gi 并移动上面的棋子。Sprague-Grundy Theorem 就是：<strong>g(G)=g(G1)^g(G2)^…^g(Gn)</strong>。也就是说，游戏的和的 SG 函数值是它的所有子游戏的 SG 函数值的异或。 </p><p>再考虑在本文一开头的一句话：任何一个 ICG 都可以抽象成一个有向图游戏。所以“SG 函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每 个 ICG 的每个 position 定义 SG 值，也可以定义 n 个 ICG 的和。所以说当我们面对由 n 个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个 局面的 SG 值的方法，就可以把这些 SG 值全部看成 Nim 的石子堆，然后依照找 Nim 的必胜策略的方法来找这个游戏的必胜策略了！</p><h4 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h4><p>有 n 堆石子，每次可以从第 1 堆石子里取 1 颗、2 颗或 3颗，可以从第 2 堆石子里取奇数颗，可以从第 3 堆及以后石子里取任意颗… … 我们可以把它看作 3 个子游戏，第 1 个子游戏只有一堆石子，每次可以取 1、2、3颗，很容易看出 x 颗石子的局面的 SG 值是 x%4。第 2 个子游戏也是只有一 堆 石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有 x 颗石子时的 SG值是 x%2。第 3 个游戏有 n-2 堆石子，就是一个 Nim 游戏。对于原游戏的每 个局面，把三个子游戏的 SG 值异或一下就得到了整个游戏的 SG 值，然后就可以根据这个 SG 值判断是否有必胜策略以及做出决策了。其实看作 3 个子游戏还是保守了些，干脆看作 n 个子游戏，其中第 1、2 个子游戏如上所述，第 3 个及以后的子游戏都是“1 堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简 单的游戏有 x 颗石子的 SG 值显然就是 x。其实，n 堆石子的 Nim 游戏本身不就是 n 个“任取石子游戏”的和吗？</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SG 函数与“游戏的和”的概念不是让我们去组合、制造稀奇古怪的游戏，而是把遇到的看上去有些复杂的游戏试图分成若干个子游戏，对于每个比原游戏简化很多的子游戏找出它的 SG 函数，然后全部异或起来就得到了原游戏的 SG 函数，就可以解决原游戏了。</p><h4 id="HDU-3032-Nim-or-not-Nim"><a href="#HDU-3032-Nim-or-not-Nim" class="headerlink" title="HDU 3032 Nim or not Nim"></a>HDU 3032 Nim or not Nim</h4><p>Lasker’s Nim 游戏：每一轮允许两会中操作之一：①、从一堆石子中取走任意多个，②、将一堆数量不少于 2 的石子分成都不为空的两堆。</p><p>很明显：sg(0) = 0，sg(1) = 1。  状态 2 的后继有：0，1 和（1，1），他们的 SG 值分别为 0，1，0，所以 sg(2)=2。 状态 3 的后继有：0、1、2、（1，2），他们的 SG 值分别为 0、1、2、3，所以sg(3) = 4。 状态 4 的后继有：0、1、2、3、（1，3）和（2，2），他们的 SG 值分别为 0，1，2，4，5，0，所以 sg(4) = 3. 由数学归纳法可以得出 sg(4k)=4k-1;sg(4k+1)=4k+1;sg(4k+2)=4k+2;sg(4k+3)=4k+4;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int iCase;</span><br><span class="line">cin &gt;&gt; iCase;</span><br><span class="line">while (iCase--) &#123;</span><br><span class="line">int n, cnt = 0, num;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while (n--) &#123;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">if (num % 4 == 0) num--;</span><br><span class="line">else if (num % 4 == 3) num++;</span><br><span class="line">cnt ^= num;</span><br><span class="line">&#125;</span><br><span class="line">if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找必败态"><a href="#寻找必败态" class="headerlink" title="寻找必败态"></a>寻找必败态</h2><p>必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。</p><p>必败态和胜态有着如下性质： </p><p>1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 </p><p>2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 </p><p>3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 </p><p>这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;取石子游戏&quot;&gt;&lt;a href=&quot;#取石子游戏&quot; class=&quot;headerlink&quot; title=&quot;取石子游戏&quot;&gt;&lt;/a&gt;取石子游戏&lt;/h2&gt;&lt;p&gt;根据题目的意思，看它属于哪种博弈，属于哪种博弈的变形。 然后根据对应的博弈模型的解题策略来求解， 有时候并不一定能够
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="博弈论" scheme="http://qianyouyou.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>[数论]数论与组合数学中的常用算法总结</title>
    <link href="http://qianyouyou.cn/2018/05/07/2018-05-07/"/>
    <id>http://qianyouyou.cn/2018/05/07/2018-05-07/</id>
    <published>2018-05-07T10:08:16.000Z</published>
    <updated>2018-05-08T14:15:54.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="欧几里得算法（gcd）"><a href="#欧几里得算法（gcd）" class="headerlink" title="欧几里得算法（gcd）"></a>欧几里得算法（gcd）</h3><p>欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b)</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b)</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">return b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">//非递归版</span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">if (!a)</span><br><span class="line">return b;</span><br><span class="line">while (b) &#123;</span><br><span class="line">int temp = b;</span><br><span class="line">b = a%b;</span><br><span class="line">a = temp;</span><br><span class="line">&#125;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h3><p>若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb<br>对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1<em>a+0</em>b,因为 gcd(a,b)=gcd(b,a%b)则有 x<em>a+y</em>b=x1<em>b+y1</em>(a%b) 。将等式右边变形，b<em>x1+(a%b)</em>y1=b<em>x1+(a-(a/b)</em>b)<em>y1=a</em>y1+b<em>(x1-(a/b)</em>y1)<br>则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)<em>t,y-y0-a/gcd(a,b)</em>t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int exgcd(int a, int b, int &amp;x, int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">if (b == 0)</span><br><span class="line">&#123;</span><br><span class="line">x = 1;</span><br><span class="line">y = 0;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int d = exgcd(b, a%b, x, y);</span><br><span class="line">int t = x;</span><br><span class="line">x = y;</span><br><span class="line">y = t - a / b*y;</span><br><span class="line">return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><p>筛素数的基本方法是用来筛选出一定范围内的素数</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool isprime[N];//N 表示范围</span><br><span class="line">int prime[N], cnt;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">cnt = 0;</span><br><span class="line">memset(isprime, true, sizeof(isprime));</span><br><span class="line">isprime[1] = false;</span><br><span class="line">for (i = 2; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (isprime[i])</span><br><span class="line">&#123;</span><br><span class="line">prime[cnt++] = i;//记录素数</span><br><span class="line">for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了</span><br><span class="line">isprime[j] = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0<em>a2^1</em>a2^3，也就是a1 <em> a2 </em> a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int poww(int a, int b) &#123;</span><br><span class="line">    int ans = 1, base = a;</span><br><span class="line">    while (b != 0) &#123;</span><br><span class="line">        if (b &amp; 1 != 0)</span><br><span class="line">            ans *= base;</span><br><span class="line">        base *= base;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)<em>a^(2^1)</em>a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。</p><p>　　其中要理解base <em> =base这一步：因为 base </em> base==base2，下一步再乘，就是base2 <em> base2==base4，然后同理  base4 </em> base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1<em>a2</em>a8，这三项就可以完美解决了</p><h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p><strong>矩阵乘法</strong></p><p>简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C</p><p><strong><img src="http://p7woygi8q.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.png" alt="img"></strong></p><p>其中c[i][j]为A的第i行与B的第j列对应乘积的和，即:<img src="http://p7woygi8q.bkt.clouddn.com/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%85%AC%E5%BC%8F.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int N=100;  </span><br><span class="line">int c[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(c,0,sizeof c);  </span><br><span class="line">    for(int i=1;i&lt;=n;i++)  </span><br><span class="line">        for(int j=1;j&lt;=n;j++)  </span><br><span class="line">        for(int k=1;k&lt;=n;k++)  </span><br><span class="line">        c[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放一个求斐波那契数列的矩阵快速幂模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 10000;</span><br><span class="line">const int maxn = 35;</span><br><span class="line">int N;</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    int mat[maxn][maxn];</span><br><span class="line">    int x, y;</span><br><span class="line">    Matrix() &#123;</span><br><span class="line">        memset(mat, 0, sizeof(mat));</span><br><span class="line">        for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123;</span><br><span class="line">    memset(c.mat, 0, sizeof(c.mat));</span><br><span class="line">    c.x = a.x; c.y = b.y;</span><br><span class="line">    for (int i = 1; i &lt;= c.x; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= c.y; j++) &#123;</span><br><span class="line">            for (int k = 1; k &lt;= a.y; k++) &#123;</span><br><span class="line">                c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod;</span><br><span class="line">                c.mat[i][j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">inline void mat_pow(Matrix &amp;a, int z) &#123;</span><br><span class="line">    Matrix ans, base = a;</span><br><span class="line">    ans.x = a.x; ans.y = a.y;</span><br><span class="line">    while (z) &#123;</span><br><span class="line">        if (z &amp; 1 == 1) mat_mul(ans, base, ans);</span><br><span class="line">        mat_mul(base, base, base);</span><br><span class="line">        z &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    a = ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    while (cin &gt;&gt; N) &#123;</span><br><span class="line">        switch (N) &#123;</span><br><span class="line">            case -1: return 0;</span><br><span class="line">            case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">            case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Matrix A, B;</span><br><span class="line">        A.x = 2; A.y = 2;</span><br><span class="line">        A.mat[1][1] = 1; A.mat[1][2] = 1;</span><br><span class="line">        A.mat[2][1] = 1; A.mat[2][2] = 0;</span><br><span class="line">        B.x = 2; B.y = 1;</span><br><span class="line">        B.mat[1][1] = 1; B.mat[2][1] = 1;</span><br><span class="line">        mat_pow(A, N - 1);</span><br><span class="line">        mat_mul(A, B, B);</span><br><span class="line">        cout &lt;&lt; B.mat[1][1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。</p><p>设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n <em> sum(1-1/pi)/</em>pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><h4 id="基本的模运算"><a href="#基本的模运算" class="headerlink" title="基本的模运算"></a>基本的模运算</h4><p>(a + b)mod n=((a mod n) + (b mod n))mod n;</p><p>(a - b)mod n=((a mod n) - (b mod n))mod n;</p><p>(a <em> b)mod n=((a mod n) </em> (b mod n))mod n;</p><h3 id="数论4大定理"><a href="#数论4大定理" class="headerlink" title="数论4大定理"></a>数论4大定理</h3><h4 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h4><p>若p为质数，则p可整除(p-1)!+1。</p><h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n)</p><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><p>设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。</p><p>于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n），</p><p>所以a^φ(n) ≡ 1 (mod n)。</p><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。</p><p>若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。</p><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a><strong>证明</strong></h5><p>因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。</p><h4 id="孙子定理（中国剩余定理）"><a href="#孙子定理（中国剩余定理）" class="headerlink" title="孙子定理（中国剩余定理）"></a>孙子定理（中国剩余定理）</h4><p><img src="http://p7woygi8q.bkt.clouddn.com/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt=""></p><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。</p><p>要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。</p><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><h4 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h4><p>加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。</p><p>分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏）</p><h4 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h4><p>乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。</p><p>合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 </p><p>组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) </p><p>其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。</p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|<br>这个定理，常称作包含排斥原理，也就是容斥原理。</p><p><img src="http://p7woygi8q.bkt.clouddn.com/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86.png" alt=""></p><p>对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数论&quot;&gt;&lt;a href=&quot;#数论&quot; class=&quot;headerlink&quot; title=&quot;数论&quot;&gt;&lt;/a&gt;数论&lt;/h2&gt;&lt;h3 id=&quot;欧几里得算法（gcd）&quot;&gt;&lt;a href=&quot;#欧几里得算法（gcd）&quot; class=&quot;headerlink&quot; title=&quot;欧几里
      
    
    </summary>
    
      <category term="程序人生" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="算法" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="http://qianyouyou.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM/ICPC" scheme="http://qianyouyou.cn/tags/ACM-ICPC/"/>
    
      <category term="数论" scheme="http://qianyouyou.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数学" scheme="http://qianyouyou.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高斯消元" scheme="http://qianyouyou.cn/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="容斥原理" scheme="http://qianyouyou.cn/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
