<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大话存储器]]></title>
    <url>%2F2019%2F04%2F27%2F2019-04-27%2F</url>
    <content type="text"><![CDATA[面试时总在这里吃亏，对此，本人花了两天时间彻彻底底把操作系统书进程与存储器部分看了一遍，废话不多说，直接进入正题吧。 存储器管理首先得声明，在引入虚拟存储器之前，存储器通常是将整个进程所有资源引入内存的。 存储器的层次结构 程序的装入和链接装入 绝对装入方式 编译程序将产生绝对地址的目标代码根据地址将程序和数据存入内存。 编程人员要熟悉内存。 程序在内存中不能移动。 不适用于多道程序设计环境。 可重定位装入方式（静态） 编译程序将产生相对地址的目标代码，装入时需要地址映射，地址变换只在装入时一次性完成，以后不再改变。 适用于多道程序环境。 程序在内存中不能移动。 动态运行时装入方式 编译程序将产生相对地址的目标代码，装入时并不立即把相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时才运行。 程序装入内存后可移动。 链接 静态链接方式 程序运行前将各目标模块及所需库装配成一个完整模块且不再分开。 装入时动态链接 边装入边链接。（假如没有用到某一模块，也会装入内存，所有才有了方法3） 运行时动态链接 将链接推迟到程序运行时，如果链接到哪一模块，则再将该模块装入内存。（加快装入过程，节省空间） 连续分配存储管理方式方式 单一连续分配 固定分区分配 动态分区分配 基于顺序搜索的动态分区分配算法首次适应算法(First Fit):从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 特点该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。 缺点低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销 下次适应（next fit）算法也称“临近适应”算法，其工作方式和最先适应算法相同（最先适应也称首次适应算法。它总是最先找到的、满足存储要求的那个空闲分区作为分配对象。），不同的是每次找到合适的空闲的分区时就记住它的位置，以便下次就从该位置开始往下查找，而不是每次都像最先适应算法那样从头开始查找。这种算法的总体结果通常要比最先适应算法差。由于它经常会在内存的末尾分配存储分区，使位于存储空间末尾的最大分区被撕裂称小的外部碎片，因此必须经常不断地进行存储紧凑。在该算法中应采取循环查找方式，即最后上个空闲区的大小仍不能满足要求时，应再从第一个空闲区开始查找，故又称为循环造就算法。 最佳适应算法（Best Fit）：它从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。 Best fit算法等价于装箱问题，举例如下： 装箱问题：有体积为V的箱子N个，体积为Vi的物品M个，求使得物品全部能够装入箱子，箱子数量的最小值。假设 V=6 N=10，V1，V2，…,V10分别为：3 4 4 3 5 1 2 5 3 1。计算过程如下：第一步按物品体积降序排序：5 5 4 4 3 3 3 2 1 1第二步：取未装箱的最大值5装入第一个箱子。第三步：判断第一个箱子是否已满，不满且剩余空间为1，搜寻剩下体积小于等于1的物品填入箱子1，箱子1填满。第四步：重复第二，第三步，直到所有物品装入箱子为止，得到箱子数量为6.6即时本例N的最小值。 最坏适应算法（worst fit）最坏适应分配算法要扫描整个空闲分区或链表，总是挑选一个最大的空闲分区分割给作业使用。该算法要求将所有的空闲分区按其容量从大到小的顺序形成一空闲分区链，查找时只要看第一个分区能否满足作业要求。 优点：可使剩下的空闲分区不至于太小，产生碎片的几率最小，对中、小作业有利，同时该算法查找效率很高。 缺点：会使存储器中缺乏大的空闲分区。 最坏适应算法与首次适应算法、循环首次适应算法、最佳适应算法一起，也称为顺序搜索法。 基于索引搜索的动态分区分配算法快速适应算法（分类搜索法）该算法就是将空闲分区根据容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样的系统中存在多个空闲分区链表。同时，在内存总设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。 该算法在搜索可分配的空闲分区时分为两步：第一步是根据进程的长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。另外，该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。优点是查找效率高。缺点是在分区归还时的算法复杂，系统开销大。此外，该算法在分配空闲分区时，是以进程为单位的，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少的存在一定的浪费。这是典型的以空间换时间的做法。 伙伴系统该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂，通常2的m次方是整个可分配内存的大小。假设系统的的可利用空间容量为2的m次方，则当系统开始运行时，整个内存区是一个大小为2的m次方的空闲分区。在系统运行过程中，由于不断地划分，将会形成若个个不连续的空闲分区，将这些分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。 当需要为进程分配一个长度大小为n的存储空间时，首先计算一个i值，使2的i-1次方小于n小于等于2的i次方，然后再空闲分区大小为2的i次方的空闲分区链表中查找。 在伙伴系统中，其分配和回收的时间性能取决于查找空闲分区的位置和分割、合并空闲分区所花费的时间。在回收空闲分区时，需要对空闲分区进行合并，所以其时间性能比快速适应算法差，但由于它采用了索引搜索算法，比顺序搜索算法号。而其空间性能，由于对空闲分区进行合并，减少了空闲分区，提高了空间分区的可使用率，故由于快速适应算法，比顺序搜索法略差。 总结：虽然在当前的操作系统中，主要还是采用离散分配方式的分页和分段机制的虚拟内存机制，因为该机制较伙伴算法更为合理和高效，但在多处理机系统中，伙伴系统仍不失为一种有效的内存分配和释放的方法，目前仍然被广泛使用。 哈希算法由于分类搜索算法和伙伴系统算法中，都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表。在为进程分配空间时，需要在每一张管理索引表中查找到所需要的空间大小所对应的表项，从中得到对应的空间内分区链表表头指针，从而通过查找一个空闲分区。如果对空闲分区分类比较细，则相应索引表的表项也就较多，因此会显著的增加搜索索引表的表项的时间开销。 哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲分区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。 当进行空闲分区分配时，根据所需要的空闲 分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。 动态可重定位分区分配 紧凑 动态重定位 动态重定位分区分配算法 离散式存储管理方式分页存储管理方式连续分配存储管理方式产生的问题在分区存储管理中，要求把进程放在一个连续的存储区中，因而会产生许多碎片。 碎片问题的解决方法（1）拼接/紧凑技术—-代价较高。 （2）离散分配方式—允许将作业/进程离散放到多个不相邻接的分区中，就可以避免拼接。 离散分配方式分页式存储管理：离散分配的基本单位是页 分段式存储管理：离散分配的基本单位是段 段页式存储管理：离散分配的基本单位是段、页 什么是页将一个用户进程的地址空间（逻辑）划分成若干个大小相等的区域，称为页或页面,页面大小由地址结构（逻辑）决定 ，并为各页从0开始编号。 什么是块内存空间也分成若干个与页大小相等的区域，称为（存储、物理）块或页框（frame），同样从0开始编号。 内存分配在为进程分配内存时,以块为单位,将进程中若干页装入到多个不相邻的块中,最后一页常装不满一块而出现页内碎片。 页表的出现在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。一个页表中包含若干个表目，1.表目的自然序号对应于用户程序中的页号。2.表目中的块号是该页对应的物理块号。 内存地址的获取以页号查页表，得到对应页装入内存的块号。即可求出：内存地址＝物理块号×页大小＋页内地址。 例:在采用页式存储管理的系统中,某作业J的逻辑地址空间为4页(每页2048字节),且已知该作业的页面映像表如下: 页号 块号 0 2 1 4 2 6 3 8 试借助地址变换图求出有效逻辑地址4865所对应的物理地址. 解:页号 4865/2048=2 页内位移 4865%2048=769，过程如下： 从上面我们可以看出：CPU要想获取一个数据时，必须两次访问内存： 1、从内存中的页表中，寻找对应的物理块号，将物理块号与页内地址组合成物理地址。 2、根据组合成的物理地址，来获取数据。 为了提高效率呢，就引进了块表，什么是快表呢？ 在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器”或“快表”。 在引入快表的分页存储管理方式中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题，。总体上来说，还是减少了访问内存的时间。 分段存储管理方式分段存储管理方式的引入引入分段存储管理方式，主要是为了满足用户和程序员的下述一系列需要： 1）方便编程 通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。 因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。 2）信息共享 在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如共享某个例程和函数，分页系统中的“页”只是存放信息的物理单位（块）， 并无完整的意义，不便于实现共享，然而段却是信息的逻辑单位。 3）信息保护 信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便的实现信息保护功能。 4）动态增长 在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前面的几种存储 管理方式都难以应付这种动态增长的情况，分段存储管理方式能较好的解决这一问题。 5）动态链接 动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程 中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。 分段和段表在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段 定义了一组逻辑信息。每个段都有自己的名字，通常可用一个段号来 代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的 地址空间分成多个段，是二维的。 在动态分区（可变分区）分配方式中，系统为整个进程分配一个连续的内存空间。而在分段式存储管理系统中，则是为每个分段分配一个 连续的分区，而进程中的各个段可以离散地装入内存中不同的分区中。为使程序能正常运行，即能从物理内存中找出每个逻辑段所对应的位置， 应像分页系统那样，在系统中为每个进程建立一张段映射表，简称“段表”。 每个段在表中占有一个表项，其中记录了该段在内存中的起始地址（“基址”）和段长（字节）。段表一般放在内存中。在配置了段表后， 执行中的进程可通过查找段表找到每个段所对应的内存区。可见，段表是用于实现从逻辑段到物理内存区的映射。 地址变换机构为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址 和段表长度TL。在进行地址变换时， 系统将逻辑地址中的段号S（0～TL-1）与段表长度TL进行比较。– 若S&gt;=TL，表示段号太大，是访问越界，于是产生越界中断信号； 若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置（段表的始址+段号x段表项的长度），从中读出该段在内存的 起始地址，然后再检查段内地址d是否超过该段的段长SL。若超过，即d&gt;SL,同样发出越界中断信号；若未越界，则将该段的基址与段内地址d 相加，即可得到要访问的内存物理地址。 像分页系统一样，当段表放在内存中时，每当要访问一个数据，都需访问两次内存（第一次是得到物理地址，第二次是从地址中取数据）， 从而极大地降低了计算机的速率。解决方法是再增设一个联想存储器（TLB），用于保存最近常用的段表项。一般情况下是段比页大，因而 段表项的数目比页表项的数目少，需要的TLB也相对较小，可以显著的减少存取数据的时间。 分页和分段的主要区别分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换。但在概念上两者完全不同，主要表现在3个方面： – 1）页是信息的物理**单位，分页是为实现离散分配方式，消减外部碎片，提高内存的利用率。分页仅仅是由于系统管理的需要而不是用户的需要。** 段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好的满足用户的需要。 – 2）页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面； 而段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。 – 3）分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的， 程序员在标识一个地址时，既需给出段名，又需给出段内地址。 信息共享段的共享：即允许若干个进程共享一个或多个分段。 可重入代码（Reentrant Code）又称为“纯代码”（Pure Code），是一种允许多个进程同时访问的代码。为使各个进程所执行的代码完全相同， 绝对不允许可重入代码在执行中有任何改变。因此，可重入代码是一种不允许任何进程对它进行修改的代码。 —- 但事实上，大多数代码在执行时都可能有些改变，例如，用于控制程序执行次数的变量以及指针、信号量及数组等。为此，在每个进程中，都必 须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区，这样，程序在执行时，只需对该数据区（属于该进程私有）中的内容进行修改，并 不去改变共享的代码，这时的可共享代码即成为可重入码。 段页式存储管理方式用户程序先分段，每个段内部再分页（内部原理同基本的分页、分段相同） 地址结构分三部分：段号、段内页号、页内地址 地址映射（逻辑地址—&gt;物理地址）³ 逻辑地址—– &gt;段号、段内页号、业内地址 ³ 段表寄存器— &gt;段表始址 ³ 段号+段表始址—- &gt;页表始址 ³ 页表始址+段内页号—–&gt;存储块号 ³ 块号+页内地址——&gt;物理地址 地址变换原理及步骤 请看上图，给出逻辑地址的段号、页号、页内地址，开始进行地址变换： 1) 在被调进程的PCB中取出段表始址和段表长度，装入段表寄存器 2) 段号与控制寄存器的页表长度比较，若页号大于等于段表长度，发生地址越界中断，停止调用，否则继续 3) 由段号结合段表始址求出页表始址和页表大小 4) 页号与段表的页表大小比较，若页号大于等于页表大小，发生地址越界中断，停止调用，否则继续 5) 由页表始址结合段内页号求出存储块号 6) 存储块号&amp;页内地址，即得物理地址 总结在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存。 虚拟存储器常规存储器要求将一个作业全部装入内存方能执行。而虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配方式，则需将作业装入一个连续的内存区域中。所以，虚拟存储器抖毫无例外建立在离散分配管理方式之上。 请求分页存储管理方式。 请求分段存储管理方式。 请求分页存储管理方式定义：请求分页系统是建立在基本分页系统的基础上，为了能支持虚拟存储器功能而 添加了请求调页功能和页面置换功能。 页表机制在请求分页系统中所须要的主要数据结构是页表。其基本作用仍然是将用户地址空间中的逻辑地址变换为内存空间中的物理地址。因为仅仅将应用程序的一部分调入内存，另一部分仍在盘上，故须在页表中再添加若干项，供程序(数据)在换进、换出时參考。在请求分页系统中的每个页表项例如以下所看到的： 现对当中各字段说明例如以下：(1) 状态位P：用于指示该页是否已调入内存，供程序訪问时參考。(2) 訪问字段A：用于记录本页在一段时间内被訪问的次数，或记录本页近期已有多长时间未被訪问，供选择换出页面时參考。 (3) 改动位M：表示该页在调入内存后是否被改动过。因为内存中的每一页都在外存上保留一份副本，因此，若未被改动，在置换该页时就不需再将该页写回到外存上，以降低系统的开销和启动磁盘的次数；若已被改动，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本 。简言之，M位供置换页面时參考。(4) 外存地址：用于指出该页在外存上的地址，一般是物理块号，供调入该页时參考。 缺页中断机构在请求分页系统中，每当所要訪问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存。缺页中断作为中断，它们相同须要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的差别，主要表如今以下两个方面：(1) 在指令运行期间产生和处理中断信号。通常，CPU都是在一条指令运行完后，才检查是否有中断请求到达。若有，便去响应，否则，继续运行下一条指令。然而，缺页中断是在指令运行期间，发现所要訪问的指令或数据不在内存时所产生和处理的。 (2) 一条指令在运行期间，可能产生多次缺页中断。在下图中示出了一个样例。如在运行一条指令COPY A TO B时，可能要产生6次缺页中断，当中指令本身跨了两个页面，A和B又分别各是一个数据块，也都跨了两个页面。基于这些特征，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续运行。 地址变换机构请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，再为实现虚拟存储器而添加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。下图表示出了请求分页系统中的地址变换过程。在进行地址变换时，首先去检索快表，试图从中找出所要訪问的页。若找到，便改动页表项中的訪问位。对于写指令，还须将改动位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。 页面置换算法最佳置换算法（OPT）（理想置换算法）从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串： 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图3-26所示。从图中可以看出釆用最佳置换算法时的情况。可以看到，发生缺页中断的次数为9，页面置换的次数为6。 访问页面 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 物理块1 7 7 7 2 2 2 2 2 7 物理块2 0 0 0 0 4 0 0 0 物理块3 1 1 3 3 3 1 1 缺页否 √ √ √ √ √ √ √ √ 先进先出置换算法（FIFO）是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 访问页面 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 物理块1 7 7 7 2 2 2 4 4 4 0 0 0 7 7 7 物理块2 0 0 0 3 3 3 2 2 2 1 1 1 0 0 物理块3 1 1 1 0 0 0 3 3 3 2 2 2 1 缺页否 √ √ √ √ √ √ √ √ √ √ √ √ √ √ √ 这里仍用上面的实例，釆用FIFO算法进行页面置换。进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图 3-27可以看出，利用FIFO算法时进行了 12次页面置换，比最佳置换算法正好多一倍。FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常，如图3-28所示。只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。 访问页面 1 2 3 4 1 2 5 1 2 3 4 5 物理块1 1 1 1 4 4 4 5 ,5’ 5 物理块2 2 2 2 1 1 1 3 3 物理块3 3 3 3 2 2 2 4 缺页否 √ √ √ √ √ √ √ √ √ 1 1 1 5 5 5 5 4 4 物理块2* 2 2 2 2 1 1 1 1 5 物理块3* 3 3 3 3 2 2 2 2 物理块4* 4 4 4 4 3 3 3 缺页否 √ √ √ √ √ √ √ √ √ 注意：内存的页面中“最老“的页面，会被新的网页直接覆盖，而不是“最老“的页面先出队，然后新的网页从队尾入队。 最近最久未使用（LRU）算法这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。 再对上面的实例釆用LRU算法进行页面置换，如图3-29所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。 访问页面 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1 物理块1 7 7 7 2 2 4 4 4 0 1 1 1 物理块2 0 0 0 0 0 0 3 3 3 0 0 物理块3 1 1 3 3 2 2 2 2 2 7 缺页否 √ √ √ √ √ √ √ √ √ √ √ √ 实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。***LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。 时钟(CLOCK)置换算法LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可以使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都处于以下四种情况之一： 最近未被访问，也未被修改(u=0, m=0)。 最近被访问，但未被修改(u=1, m=0)。 最近未被访问，但被修改(u=0, m=1)。 最近被访问，被修改(u=1, m=1)。 算法执行如下操作步骤： 从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。 如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。 如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，并且如果有必要，重复第2步。这样将可以找到供替换的帧。 改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。 例题： 在5个页框上使用LRU页面替换算法，当页框初始为空时，引用序列为0、1、7、8、6、2、3、7、2、9、8、1、0、2，系统将发生（C）次缺页 ​ A、13 B、12 C、11 D、8 解析：内存中驻留5个页框： 访问页面 0 1 7 8 6 2 3 7 2 9 8 1 0 2 页框1 0 0 0 0 0 2 2 2 2 2 2 2 2 2 页框2 1 1 1 1 1 3 3 3 3 3 1 1 1 页框3 7 7 7 7 7 7 7 7 7 7 0 0 页框4 8 8 8 8 8 8 9 9 9 9 9 页框5 6 6 6 6 6 6 8 8 8 8 是否缺页 Y Y Y Y Y Y(换页) Y(换页) N N Y(换页) Y(换页) Y(换页) Y(换页) N LRU是堆栈类的算法，最后访问的页面放在栈顶，可以得到答案为C。 编程思路： 1,用结构体成员记录访问的顺序，换页时选取times最大的那个替换掉。 struct LRU { int data; int times;};记录访问次序 struct queue{ LRU *p; int front; int rear }Qe; (1)队列未满时，依次添加新访问的页面，并Qe.p[i++].times++ (2)队列满了 a, 新访问的页面在队列中，times设为0，之前在它前面的LRU.times++ ​ b, 新访问的页面不在队列中，需替换掉times最大的页面，并设新页面times=0，对列中其它页面times++ 2,用队列中存放的位置表示最后访问时间（用线性表涉及大量元素移动，用链表好些） 队列未满时，依次压入；队列满，则查看对列中是否存在，若存在，将其移动到队尾，若不存在，删除队首页面，并在队尾加入新页面。 抖动与工作集页面抖动（颠簸）在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。 频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 工作集（驻留集）工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。]]></content>
      <categories>
        <category>程序人生</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚拟存储器</tag>
        <tag>分页</tag>
        <tag>分段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向死而生，知菜而后勇]]></title>
    <url>%2F2019%2F04%2F24%2F2019-04-24%2F</url>
    <content type="text"><![CDATA[不知不觉间，搭建的博客已经有一周年了，首先为自己的博客庆个生吧(^人^)嘿嘿。 回首一年间，太多感慨已成云烟，就不多说了（其实是忘得差不多了QYQ）。那就回首一月间吧(￣_￣|||) 回首一月间，可谓一直在找实习从未间断。说到体验的话，可以说是起起伏伏，体验感极差。说到经历的话，可以一句话来形容，便是以腾讯起，以腾讯终。当然，不是以腾讯录用而终，而是以被腾讯pass为终QYQ 这一个月里，虽然各种面试东跑西跑面的身心疲惫，但总的来说还是有收获的，至少让自己认清自己很菜qyq，当然这是开玩笑的啦。首先现在的我已经清楚未来要去的敌方以及要走的路了，而且在其中收获的面试经验是无法替代的。 还记得三月初腾讯们各种投简历带的我还不明白为什么要找实习便也跟着一起投。还记得第一次收到腾讯的面试通知，既兴奋又恐惧，当时还很稚嫩的我（丢不丢脸啊）收面试官小哥哥的照顾竟然莫名其妙过了。还记得西山居经历四次面试本来以为稳了，结果因为没有什么面试经验导致实习时间上的问题最终被刷，之后好长一段时间恐惧面试，不想面试。直到前两天腾讯正式批二面结束后，状态变为了HR面试，当时那个兴奋与感激啊，结果没过两天就又由HR面试变成了初试（嘿嘿，面试本就是大起大落，大落最差不过从头再来，所以说只要没拿到offer就不存在稳不稳）。不过渐渐的，我也明白了实习的意义。其实当初找实习纯粹是被氛围带起的，经过这么多面试之后，一方面发现自己还有很多方面需要学习与总结，另一方面渐渐也发现其实实不实习都无关紧要，做项目的话自己也可以做嘛，只要自己实力够强。而找实习后反而有点浪费学习时间，反正暂时也找不到，不如静下心来好好学习，自己做项目积累经验吧，为秋招做好准备。毕竟这样就可以做自己想做的产品了（偷笑） 现在制定计划，并以今天为起点，抓紧学习，之后就不找实习了，直接面向秋招。 重点学习内容：C++，Linux系统编程与网络编程，操作系统，计算机网络，编译原理，数据库。 项目：聊天室项目，云盘项目，内存池项目，5V5游戏项目 目前的资源：C++primer，深入理解计算机系统，图解TCP/IP，图解HTTP，LINUX高性能服务器编程，HeadFirst设计模式，STL源码剖析等等。 计划： 4月末——Linux系统编程与网络编程，操作系统 5月——深入了解计算机系统（操作系统，网络与编译原理） 6月——C++primer 7月——8月——项目，二遍复习 附上这一个月的心路历程（我的三体的一首词） 天才如我蠢材如我在梦里醒着世人庸庸碌碌求而不得不多我一个放纵了 颓废了也当消解疑惑笑命运管窥蠡测沉迷过 入魔过 倾塌过又能如何这一杯谢你敬我终将真相挑破暗夜里挣不脱重重枷锁百死也容易难的是苟活尘世中以血肉对撞漩涡谁不是生于毫末偏贪恋天地宏阔第几道轮回都捱过换浮生片刻甘心不甘心说来好似是心魔可我陷了便陷了就执念了生死存亡表象声色神明或虫豸活下的才算幸运儿 借酒来遮借梦来躲借命来挥霍如人饮水冷暖各有所获谁也别干涉这世界 那世界不过一念之隔五十年等个结果遗忘的 铭记的 美化的也这么过究竟谁是谁寄托那就放下忐忑来路来去处去都还不错虚无如永生年岁算偷得到如今又哪敢贪求更多纵然我生于毫末也看了天地宏阔下一道轮回该如何便由它如何真实里真实虽惋惜不曾窥破总有来者后来者大道不离生死存亡表象声色神明或虫豸时光中颠倒几回合 你也不必问我这一生这条路值不值得观者谈因果后人论功过横竖我听不见他们评说面目虽扭曲映射看去还不算太丑恶至于鬓角那点斑驳就一笑而过倒也算有幸在命途最后时刻领教太悬殊强弱扑面加身烧熔骨骼、演化烟火若蝉声戛然先蹈此辙、死神裙下客从来多螳螂黄雀你又作哪个宇宙再宏阔真理共微尘一色不都是死路上讨得生活 天才如我蠢材如我在梦里醒着世人庸庸碌碌求而不得不多我一个放纵了 颓废了也当消解疑惑笑命运管窥蠡测沉迷过 入魔过 倾塌过又能如何这一杯谢你敬我终将真相挑破暗夜里挣不脱重重枷锁百死也容易难的是苟活尘世中以血肉对撞漩涡谁不是生于毫末偏贪恋天地宏阔第几道轮回都捱过换浮生片刻甘心不甘心说来好似是心魔可我陷了便陷了就执念了生死存亡表象声色神明或虫豸活下的才算幸运儿 借酒来遮借梦来躲借命来挥霍如人饮水冷暖各有所获谁也别干涉这世界 那世界不过一念之隔五十年等个结果遗忘的 铭记的 美化的也这么过究竟谁是谁寄托那就放下忐忑来路来去处去都还不错虚无如永生年岁算偷得到如今又哪敢贪求更多纵然我生于毫末也看了天地宏阔下一道轮回该如何便由它如何真实里真实虽惋惜不曾窥破总有来者后来者大道不离生死存亡表象声色神明或虫豸时光中颠倒几回合 你也不必问我这一生这条路值不值得观者谈因果后人论功过横竖我听不见他们评说面目虽扭曲映射看去还不算太丑恶至于鬓角那点斑驳就一笑而过倒也算有幸在命途最后时刻领教太悬殊强弱扑面加身烧熔骨骼、演化烟火若蝉声戛然先蹈此辙、死神裙下客从来多螳螂黄雀你又作哪个宇宙再宏阔真理共微尘一色不都是死路上讨得生活]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程的描述与控制VS处理机调度与死锁]]></title>
    <url>%2F2019%2F04%2F22%2F2019-04-22%2F</url>
    <content type="text"><![CDATA[成也进程，败也进程，不为成败，只为进程。这是一篇凉文，面试正挂于此。哎，不多说了，直接进入正题吧。 进程的描述与控制前驱图每个结点可用来表示一个进程或进程段，乃至一条语句，结点间的有向边则表示两个结点间存在偏序或前趋关系。 例如上图P1与P2之间有前趋关系，所以P1与P2只能顺序执行。再如P2与P3之间没有前趋关系，所以P2与P3可以并发执行。 说白了就是有向无环图，可以利用拓扑排序进行执行。 进程概述简单理解，进程就是程序段+数据段+PCB。 由来由于多道程序环境下，程序的执行属于并发执行，此时它们将失去封闭性，并且具有间断性，以及运行结果不可在现性的特征。由此决定了程序是不能参与并发执行的，否则，程序的运行便失去了意义。为了能使程序并发执行，并且对并发执行的程序加以描述和控制，人们引入了进程。 为使每个并发执行程序（含数据）都能独立运行，在操作系统中加入一个专门的数据结构——进程控制块（Process Control Block，PCB） 系统利用PCB描述进程的基本情况和活动过程。一般情况下，我们把进程实体简称为进程，所谓创建进程就是创建进程实体中的PCB；撤销进程就是撤销进程的PCB。 定义 进程是程序的一次执行。 进程是一个程序及其数据在处理机尚顺序执行是所发生的活动。 进程是具有独立功能的程序在一个数据集合上执行的过程，它是系统执行资源分配和调度的一个独立单位。 特征 动态性：进程是进程实体的执行过程，由创建而生，调度而执行，撤销而亡。进程实体具有生命周期，而程序仅是一组有序命令的集合，存在于某种介质之上，因而是静态的。 并发性：多个进程实体同存于内存之中，且能在一段时间同时运行。程序没有PCB，因而不能并发。 独立性：进程实体是一个能独立运行，独立获得资源，独立接受调度的基本单位。而程序没有PCB，固不能执行以上操作。 异步性：进程是按异步方式运行的，即按各自独立的、不可预知的速度推进，因而结果不可再现。为此，OS中引入进程的概念，并配置相应的同步机制。 状态及转换 三基态： 就绪状态：进程已处于准备好运行的状态，只差CPU，在就绪队列等待调度。 执行状态：进程已获得CPU，并立即执行。 阻塞状态：正在运行的进程由于发生某种事件（I/O请求，申请缓冲区失败等）暂时无法继续执行，而让受阻进程处于暂停状态。进入阻塞队列。阻塞时进程自身的主动行为。 创建与终止状态： 创建状态：申请空白PCB，并向PCB填写控制和管理进程的信息，然后分配资源，最后转入就绪队列中。 终止状态：等待操作系统善后处理，然后PCB清零，返还系统。 挂起状态： 当操作作用于某个进程时，该进程处于静止状态。 引入 终端用户需要。例如运行时改bug。 父进程请求。 符合调节需要。 操作系统需要。例如检查运行情况。 PCBPCB中的信息 进程描述符：进程标识符用于唯一标识进程。 处理机状态：进程切换时保留现场以及现场恢复。 进程调度信息：进程状态及相关进程调度信息。 进程控制信息：用于进程控制所需信息。 进程控制进程控制一般由OS原语实现。 操作系统内核 支撑功能 中断处理。 始终处理。 原语操作。原语由若干指令组成，用于完成一定功能的过程。原子操作，一个操作中所有行动要么全做，要么不做。 资源管理功能 进程管理。 存储器管理。 设备管理。 进程的创建与终止创建原语：Creat 终止原语：Holt 进程的阻塞与唤醒阻塞原语：block 唤醒原语：wakeup 进程的挂起与激活挂起原语：suspend 激活原语：active 进程同步硬件同步机制 关中断 利用Test-and-Set指令实现互斥 利用Swap指令实现进程互斥 信号量 整型信号量 记录型信号量 AND型信号量 信号量集 管程信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 经典进程同步问题生产者-消费者问题 读者-写者问题 哲学家进餐问题 进程间通信 共享存储器系统 管道（pipe）通信系统 消息传递系统 消息传递的实际功能以一对原语的形式提供： send(destination,message) receive(source,message) 这是进程间进程消息传递所需要的最小操作集。 一个进程以消息的形式给另一个指定的目标进程发送消息； 进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。 客户机-服务机系统 套接字socket 线程作为调度和分派的基本单位。 每个线程有一个线程控制块TCB。 处理机调度与死锁处理机调度无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。 处理机调度层次高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度： 高级调度：(High-Level Scheduling)又称为作业调度，它决定把外存上后备作业调入内存运行； 低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU； 中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。把不能正常运行的进程调至外存等待。 处理机调度算法CPU利用率 = CPU有效工作时间 / (CPU有效工作时间 + CPU空闲等待时间) 批处理系统周转时间Ti = 完成时间 - 到达时间 平均周转时间T = 1/n( T1 + …… + Ti + …… + Tn ) 带权周转时间为周转时间/运行时间（越小越好） 分时系统响应时间快，均衡性好。 实时系统考虑截至时间，提高可预测性。 作业与作业调度作业（Job）程序的集合+数据的集合+作业说明书+JCB。 三个状态：后备状态，运行状态，收容状态。 三个阶段：收容阶段（创建JCB），运行阶段，完成阶段（回收JCB）。 任务 接纳多少作业 接纳哪些作业 作业调度算法先来先服务算法（first-come first-served，FCFS）系统按照作业到达的优先顺序调度。 不利于短作业。 短作业优先算法（short job first，SJF）系统以作业长短为优先级。 不利于长作业，容易出现进程饥饿现象。 优先级调度算法（priority-scheduling algorithm，PSA）根据作业紧迫程度，由外界赋予优先级。 高响应比有限调度算法（Highest Rseponse Ratio Next，HRRN）动态优先级，根据长短赋初值，根据等待时间加权。作业越短，初值越大，等待时间越长，加权越大。 Rp = 响应时间/要求服务时间 进程调度方式剥夺方式当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。 非剥夺方式分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理机分配给另一个进程。 任务 保存处理机现场信息。 按某种算法选取进程。 把处理器分配给进程。 进程调度算法进程调度也称为低级调度，它所调度的对象为进程（或者内核级线程），而进程调度算法主要有以下几种： 基于时间片的轮转调度算法它的原理通俗来讲就是队列中每一个进程都获得了一定的执行时间，从几ms到几百ms，当一个执行时间结束，计时器会发出一个信号，此时正在执行的进程将被中断，同时此进程将被放在队列的末尾，然后执行这时候的队列的队首进程，因此队列中每一个进程都将获得一定时间执行。 先来先服务调度算法（FCFS）先来先服务调度算法是一种最简单的调度算法，可用于作业调度，也可用于进程调度。 短作业优先调度算法（SJ(P)F）短作业（进程）优先调度算法是指短作业或者短进程的优先调度算法，它们分别作用于作业调度和进程调度，它是先来先服务调度算法的一种优化版本。 高优先权优先调度算法为了解决在短作业优先调度算法中进程的紧迫程度问题，我们引入高优先权优先调度算法，高优先权调度算法的方法也很简单，就是在队列中选取优先权最高的进程装入内存，该算法又分为以下两类： ①非抢占式优先权算法如果系统已经分配好一个优先权最高的进程，它会一直被执行，直到结束或者因为某事件放弃执行，此时系统才会选择另外一个优先权最高的进程，这种调度算法主要被用于批处理系统中。 ②抢占式优先权算法系统在队列中把一个优先权最高的进程执行，但如果在执行中又出现一个优先权更高的进程，此时当前进程被停止，换入另外一个优先权更高的进程，这种调度算法主要被用于要求比较严格的实时系统，以及对性能要求较高的批处理和分时系统中。 优先权的类型： 优先权的类型被分为静态优先权和动态优先权。 静态优先权就是给定某个整形数字来表示进程的优先级，数字越小表示优先级越高，数字越大，进程优先级越低。 动态优先权随着进程的创建而被创建，可以随着进程的推进或者等待时间而变化。 多队列调度算法进程就绪队列由一个拆成多个，不同类型进程分配不同就绪队列，不同就绪队列采用不同算法。一个就绪队列可以设置不同优先级，不同就绪队列本身也可设优先级。 系统根据不同的用户选用不同的调度策略。 多级反馈队列调度算法设置多个就绪队列，每个队列的优先级逐渐降低，同时每个队列的执行时间也各不相同，优先级越高的队列，执行时间越短，优先级越低的队列，执行时间越长。当一个进程进入内存后，首先进入第一个队列的末尾，按照先来先服务的调度算法进行调度，如果在第一个队列的执行时间内未执行完成，此时把此进程放入第二个队列的末尾，按照之前的方法进行执行，直到在某一个队列的队首执行完成。 当第一个队列全部执行完成，此时系统才会执行第二个队列，但是如果此时又有新的进程进入，此时执行完毕这个时间段，立刻把此进程分配给新的作业。 根据公平原则的调度算法公平分配每个进程相同的处理机时间，或按进程比例公平分配用户相同的处理机时间。 死锁锁与信号量锁强调于资源，信号量强调于执行次序。 资源分类重用性资源与消耗性资源 可抢占性资源与不可抢占资源 死锁起因源于多个进程对资源的争夺，不仅对不可抢占资源金进行争夺时容易产生死锁，而且对消耗性资源抢夺也会产生死锁。还有就是进程推进不当引起死锁。 死锁产生必要条件 互斥条件（不能破坏该条件） 请求与保持条件 不可抢占条件 循环等待条件 处理死锁的方法以下四种方法从上往下防范程度逐渐减弱，但资源利用率与并发程度逐渐提高。 预防死锁破坏”请求保持条件“ 一次性分配所有需要的资源。 用到时再调用资源，用完即释放资源。 破坏”不可抢占条件“调用资源时如果资源被占用，则必须释放已有所有资源，用时再调用。 破坏”循环等待条件“先给进程编号并排序，再按照顺序分配资源。 避免死锁银行家算法银行家算法的数据结构可利用资源向量（Available）：系统还可以分配的资源 最大需求矩阵（Max）：进程的最大资源需要 分配矩阵（Alloction）：进程已经获得的资源 需求矩阵（Need）：进程还需要获得的资源 银行家算法 假设 P1 进程提出请求 K 个资源 如果 K &lt;= Need，就继续步骤；否则出错，因为请求资源 K 不能超过还需要获得的资源 如果 K &lt;= Available，就继续步骤；否则出错，因为请求资源 K 不能超过系统还可以分配的资源 Available系统试探分配资源，并修改下列数据 Available = Available - K；表示分配给 P1 K 个资源后，还剩多少系统可分配资源 Allocation = Allocation + K；表示 P1 已经获得的资源 Need = Need - K；表示进程 P1 还需要获得的资源 此时系统执行安全性算法，计算进程是否处于安全性状态 PS：此时是执行的试探分配，为的是检查进程是否处于安全状态，不处于则试探分配作废 安全性算法 安全性算法是银行家算法在第五步执行的子算法，用于检查进程的安全状态 两个向量 工作向量（Work）：系统提供给进程的各类资源数目 Finish：表示系统是否有足够的资源分配给进程，这是一个布尔值。初始化为 false。 算法描述 在进程集合中找到下述条件的进程 Finish[ i ] = false; Need &lt;= Work 进程执行完毕 Work = Work + Allocation Finish [ i ] = true 返回继续执行 1 ，寻找其他的进程分配资源 若所有的 Finish 为 true 则安全 检测死锁资源分配图。 解除死锁杀死进程。]]></content>
      <categories>
        <category>程序人生</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>死锁</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]HashMap实现原理及源码分析]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-20-1%2F</url>
    <content type="text"><![CDATA[哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。 一、什么是哈希表 在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) 线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。 我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。 比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。 存储位置 = f(关键字) 其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作： 查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。 哈希冲突 然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式， 二、HashMap实现原理 HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。 12//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; Entry是HashMap中的一个静态内部类。代码如下 123456789101112131415static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构 int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算 /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; 所以，HashMap的整体结构如下 简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 其他几个重要字段 12345678//实际存储的key-value键值对的个数transient int size;//阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount; HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值 initialCapacity默认为16，loadFactory默认为0.75 我们看下其中一个 12345678910111213141516public HashMap(int initialCapacity, float loadFactor) &#123; //此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230) if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现 &#125; 从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组 OK,接下来我们来看看put操作的实现吧 123456789101112131415161718192021222324public V put(K key, V value) &#123; //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; //如果key为null，存储位置为table[0]或table[0]的冲突链上 if (key == null) return putForNullKey(value); int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀 int i = indexFor(hash, table.length);//获取在table中的实际位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败 addEntry(hash, key, value, i);//新增一个entry return null;&#125; 先来看看inflateTable这个方法 123456private void inflateTable(int toSize) &#123; int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂 threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 table = new Entry[capacity]; initHashSeedAsNeeded(capacity); &#125; inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32. 123456private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : &quot;number must be non-negative&quot;; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1; &#125;[​](javascript:void(0);) roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值. hash函数 123456789101112//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; 以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置 123456 /** * 返回数组下标 */static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为 1234 1 0 0 1 0&amp; 0 1 1 1 1__________________ 0 0 0 1 0 = 2 最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算） 所以最终存储位置的确定流程是这样的： 再来看看addEntry的实现： 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; 通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。 三、为何HashMap的数组长度一定是2的次幂？我们来继续看上面提到的resize方法 12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); &#125; 如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法 1234567891011121314151617void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; //for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已） for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。 e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; 这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。 hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如： 我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。 如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。 get方法 1234567public V get(Object key) &#123; //如果key为null,则直接去table[0]处去检索即可。 if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125; get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法 123456789101112131415161718final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; //通过key的hashcode值计算hash值 int hash = (key == null) ? 0 : hash(key); //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。 四、重写equals方法需同时重写hashCode方法 关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题 1234567891011121314151617181920212223242526272829303132333435/** * Created by chengxiao on 2016/11/15. */public class MyTest &#123; private static class Person&#123; int idCard; String name; public Person(int idCard, String name) &#123; this.idCard = idCard; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass())&#123; return false; &#125; Person person = (Person) o; //两个对象是否等值，通过idCard来确定 return this.idCard == person.idCard; &#125; &#125; public static void main(String []args)&#123; HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;(); Person person = new Person(1234,&quot;乔峰&quot;); //put到hashmap中去 map.put(person,&quot;天龙八部&quot;); //get取出，从逻辑上讲应该能输出“天龙八部” System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;))); &#125;&#125; 实际输出结果： 1结果：null 如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。） 所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。 五、总结 本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常用知识点STL总结]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-20%2F</url>
    <content type="text"><![CDATA[STL标准模板库六大组件简介STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。 算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte. 迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。 仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte. STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。 STL优点STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作 程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。 STL 具有高可重用性，高性能，高移植性，跨平台的优点。 高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。 高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。 STL常用三大组件容器序列式容器序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。 关联式容器关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器。 算法质变算法质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等。 非质变算法非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等中会更改。 迭代器提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 迭代器的种类: 输入迭代器 提供对数据的只读访问 只读，支持++、==、！= 输出迭代器 提供对数据的只写访问 只写，支持++ 前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++、==、！= 双向迭代器 提供读写操作，并能向前和向后操作 读写，支持++、–， 随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;= 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;//STL 中的容器 算法 迭代器void test01()&#123; vector&lt;int&gt; v; //STL 中的标准容器之一 ：动态数组 v.push_back(1); //vector 容器提供的插入数据的方法 v.push_back(5); v.push_back(3); v.push_back(7); //迭代器 vector&lt;int&gt;::iterator pStart = v.begin(); //vector 容器提供了 begin()方法 返回指向第一个元素的迭代器 vector&lt;int&gt;::iterator pEnd = v.end(); //vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器 //通过迭代器遍历 while (pStart != pEnd)&#123; cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;; pStart++; &#125; cout &lt;&lt; endl; //算法 count 算法 用于统计元素的个数 int n = count(pStart, pEnd, 5); cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;&#125;//STL 容器不单单可以存储基础数据类型，也可以存储类对象class Teacher&#123;public: Teacher(int age) :age(age)&#123;&#125;; ~Teacher()&#123;&#125;;public: int age;&#125;;void test02()&#123; vector&lt;Teacher&gt; v; //存储 Teacher 类型数据的容器 Teacher t1(10), t2(20), t3(30); v.push_back(t1); v.push_back(t2); v.push_back(t3); vector&lt;Teacher&gt;::iterator pStart = v.begin(); vector&lt;Teacher&gt;::iterator pEnd = v.end(); //通过迭代器遍历 while (pStart != pEnd)&#123; cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;; pStart++; &#125; cout &lt;&lt; endl;&#125;//存储 Teacher 类型指针void test03()&#123; vector&lt;Teacher*&gt; v; //存储 Teacher 类型指针 Teacher* t1 = new Teacher(10); Teacher* t2 = new Teacher(20); Teacher* t3 = new Teacher(30); v.push_back(t1); v.push_back(t2); v.push_back(t3); //拿到容器迭代器 vector&lt;Teacher*&gt;::iterator pStart = v.begin(); vector&lt;Teacher*&gt;::iterator pEnd = v.end(); //通过迭代器遍历 while (pStart != pEnd)&#123; cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;; pStart++; &#125; cout &lt;&lt; endl;&#125;//容器嵌套容器 难点(不理解，可以跳过)void test04()&#123; vector&lt; vector&lt;int&gt; &gt; v; vector&lt;int&gt;v1; vector&lt;int&gt;v2; vector&lt;int&gt;v3; for (int i = 0; i &lt; 5;i++) &#123; v1.push_back(i); v2.push_back(i * 10); v3.push_back(i * 100); &#125; v.push_back(v1); v.push_back(v2); v.push_back(v3); for (vector&lt; vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end();it++) &#123; for (vector&lt;int&gt;::iterator subIt = (*it).begin(); subIt != (*it).end(); subIt ++) &#123; cout &lt;&lt; *subIt &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125; int main()&#123; //test01(); //test02(); //test03(); test04(); system(&quot;pause&quot;); return EXIT_SUCCESS;&#125; 常用容器string容器 String和char*： Char*是一个指针，String是一个类。 string封装了char*，管理这个字符串，是一个char*型的容器。 String封装了很多实用的成员方法： 查找find，拷贝copy，删除delete，替换replace，插入insert。 不用考虑内存释放和越界： string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。 string构造函数123456string();//创建一个空的字符串 例如: string str; string(const string&amp; str);//使用一个string对象初始化另一个string对象string(const string&amp; str, size_t pos, size_t n);//使用一个string对象的pos位及后n位初始化另一个对象string(const string&amp; str, size_t n);//使用一个string对象的前n位初始化另一个对象string(const char* s);//使用字符串s初始化string(size_t n, char c);//使用n个字符c初始化 string赋值操作12345678string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串string&amp; operator=(char c);//字符赋值给当前的字符串string&amp; assign(const char *s);//把字符串s赋给当前的字符串string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串string&amp; assign(int n, char c);//用n个字符c赋给当前字符串string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串 string获取字符操作12char&amp; operator[](int n);//通过[]方式取字符char&amp; at(int n);//通过at方法获取字符 string拼接操作12345678string&amp; operator+=(const string&amp; str);//重载+=操作符string&amp; operator+=(const char* str);//重载+=操作符string&amp; operator+=(const char c);//重载+=操作符string&amp; append(const char *s);//把字符串s连接到当前字符串结尾string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾string&amp; append(const string &amp;s);//同operator+=()string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c string查找和替换12345678910int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置int find(const char c, int pos = 0) const; //查找字符c第一次出现位置int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串strstring&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s string比较操作1234567/*compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。*/int compare(const string &amp;s) const;//与字符串s比较int compare(const char *s) const;//与字符串s比较 string子串1string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串 string插入和删除1234string&amp; insert(int pos, const char* s); //插入字符串string&amp; insert(int pos, const string&amp; str); //插入字符串string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符cstring&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 string和c-type转换123456//string 转 char*string str = &quot;itcast&quot;;const char* cstr = str.c_str();//char* 转 string char* s = &quot;itcast&quot;;string str(s); 提示在c++中存在一个从const char*到string的隐式类型转换，却不存在从一个string对象到C_string的自动类型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string。 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char*时才将其转换为C_string。 注意为了修改string字符串的内容，下标操作符[]和at都会返回字符的引用。但当字符串的内存被重新分配之后，可能发生错误。 123456789101112131415161718192021222324string s = &quot;abcdefg&quot;;char&amp; a = s[2];char&amp; b = s[3];a = &apos;1&apos;;b = &apos;2&apos;;cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;s = &quot;pppppppppppppppppppppppp&quot;;//a = &apos;1&apos;;//b = &apos;2&apos;;cout &lt;&lt; s &lt;&lt; endl;cout &lt;&lt; (int*)s.c_str() &lt;&lt; endl;/*ab12efg0x6dfed4pppppppppppppppppppppppp0x1816b0*/ vector容器vector与Array数组Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。 Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要求一个大块头的array了。 vector迭代器Vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，所以vector提供的是随机访问迭代器。 12 vector的数据结构Vector所采用线性连续空间，它以两个迭代器Myfirst和Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。 为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这便是容量的概念。换句话说，一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。 注意所谓动态增加大小，并不是在原空间之后续接新空间(因为无法保证原空间之后尚有可配置的空间)，而是分配一块更大的内存空间，然后将原数据拷贝新空间，并释放原空间。因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector的所有迭代器就都失效了。 APIvector构造函数12345678vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。vector(n, elem);//构造函数将n个elem拷贝给本身。vector(const vector &amp;vec);//拷贝构造函数。//例子 使用第二个构造函数 我们可以...int arr[] = &#123;2,3,4,1,9&#125;;vector&lt;int&gt; v1(arr, arr + sizeof(arr) / sizeof(int)); vector常用赋值操作1234assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。vector&amp; operator=(const vector &amp;vec);//重载等号操作符swap(vec);// 将vec与本身的元素互换。 vector大小操作123456size();//返回容器中元素的个数empty();//判断容器是否为空resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。capacity();//容器的容量reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 vector数据存取操作1234at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。operator[];//返回索引idx所指的数据，越界时，运行直接报错front();//返回容器中第一个数据元素back();//返回容器中最后一个数据元素 vector插入和删除操作123456insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.push_back(ele); //尾部插入元素elepop_back();//删除最后一个元素erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素erase(const_iterator pos);//删除迭代器指向的元素clear();//删除容器中所有元素 巧用swap收缩内存空间12345678910111213141516171819202122232425262728293031#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000;i ++)&#123; v.push_back(i); &#125; cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl; //此时 通过resize改变容器大小 v.resize(10); cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl; //容量没有改变 vector&lt;int&gt;(v).swap(v); cout &lt;&lt; &quot;capacity:&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;size:&quot; &lt;&lt; v.size() &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS;&#125; reserve预留空间123456789101112131415161718192021222324252627#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; //预先开辟空间 v.reserve(100000); int* pStart = NULL; int count = 0; for (int i = 0; i &lt; 100000;i ++)&#123; v.push_back(i); if (pStart != &amp;v[0])&#123; pStart = &amp;v[0]; count++; &#125; &#125; cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS;&#125; deque容器deque与vectorDeque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能. 虽然deque容器也提供了Random Access Iterator,但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，我们应该尽可能的使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque. deque容器实现原理Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。 Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。 既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。 Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。 APIdeque构造函数1234deque&lt;T&gt; deqT;//默认构造形式deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。deque(n, elem);//构造函数将n个elem拷贝给本身。deque(const deque &amp;deq);//拷贝构造函数。 deque赋值操作1234assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 swap(deq);// 将deq与本身的元素互换 deque大小操作1234deque.size();//返回容器中元素的个数deque.empty();//判断容器是否为空deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。 deque双端插入和删除操作1234push_back(elem);//在容器尾部添加一个数据push_front(elem);//在容器头部插入一个数据pop_back();//删除容器最后一个数据pop_front();//删除容器第一个数据 deque数据存取1234at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。front();//返回第一个数据。back();//返回最后一个数据 deque插入操作123insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 deque删除操作123clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。 stack容器stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。 有元素推入栈的操作称为:push,将元素推出stack的操作称为pop. stack迭代器Stack所有元素的进出都必须符合”先进后出”的条件，只有stack顶端的元素，才有机会被外界取用。Stack不提供遍历功能，也不提供迭代器。 stack常用APIstack构造函数12stack&lt;T&gt; stkT;//stack采用模板类实现， stack对象的默认构造形式： stack(const stack &amp;stk);//拷贝构造函数 stack赋值操作1stack&amp; operator=(const stack &amp;stk);//重载等号操作符 stack数据存取操作123push(elem);//向栈顶添加元素pop();//从栈顶移除第一个元素top();//返回栈顶元素 stack大小操作12empty();//判断堆栈是否为空size();//返回堆栈的大小 queue容器Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。 queue迭代器Queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。Queue不提供遍历功能，也不提供迭代器。 queue常用APIqueue构造函数12queue&lt;T&gt; queT;//queue采用模板类实现，queue对象的默认构造形式：queue(const queue &amp;que);//拷贝构造函数 queue存取、插入和删除操作1234push(elem);//往队尾添加元素pop();//从队头移除第一个元素back();//返回最后一个元素front();//返回第一个元素 queue赋值操作1queue&amp; operator=(const queue &amp;que);//重载等号操作符 queue大小操作12empty();//判断队列是否为空size();//返回队列的大小 list容器List容器是一个双向链表。 相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。 采用动态存储分配，不会造成内存浪费和溢出。 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素。 链表灵活，但是空间和时间额外耗费较大。 list迭代器由于list是一个双向链表，迭代器必须能够具备前移、后移的能力，所以list容器提供的是Bidirectional Iterators. List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效。这在vector是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致原有的迭代器全部失效，甚至List元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。 list容器的数据结构list容器不仅是一个双向链表，而且还是一个循环的双向链表。 list常用APIlist构造函数1234list&lt;T&gt; lstT;//list采用采用模板类实现,对象的默认构造形式：list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。list(n,elem);//构造函数将n个elem拷贝给本身。list(const list &amp;lst);//拷贝构造函数。 list数据元素插入和删除操作1234567891011push_back(elem);//在容器尾部加入一个元素pop_back();//删除容器中最后一个元素push_front(elem);//在容器开头插入一个元素pop_front();//从容器开头移除第一个元素insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。remove(elem);//删除容器中所有与elem值匹配的元素。 list大小操作12345678size();//返回容器中元素的个数empty();//判断容器是否为空resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。resize(num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 list赋值操作1234assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem);//将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst);//重载等号操作符swap(lst);//将lst与本身的元素互换。 list数据的存取12front();//返回第一个元素。back();//返回最后一个元素。 list反转排序12reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。sort(); //list排序 set/multiset容器set容器Set的特性是所有元素都会根据元素的键值自动被排序。Set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。Set不允许两个元素有相同的键值。 我们可以通过set的迭代器改变set元素的值吗？不行，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种const_iterator. set拥有和list某些相同的性质，当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效，被删除的那个元素的迭代器必然是一个例外。 multiset容器multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。 set/multiset数据结构set和multiset的底层实现是红黑树，红黑树为平衡二叉树的一种。 set常用APIset构造函数123set&lt;T&gt; st;//set默认构造函数：mulitset&lt;T&gt; mst; //multiset默认构造函数: set(const set &amp;st);//拷贝构造函数 set赋值操作12set&amp; operator=(const set &amp;st);//重载等号操作符swap(st);//交换两个集合容器 set大小操作12size();//返回容器中元素的数目empty();//判断容器是否为空 set插入和删除操作12345insert(elem);//在容器中插入元素。clear();//清除所有元素erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(elem);//删除容器中值为elem的元素。 set查找操作12345find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key);//查找键key的元素个数lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 set的返回值 指定set排序规则: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//插入操作返回值void test01()&#123; set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator,bool&gt; ret = s.insert(10); if (ret.second)&#123; cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl; &#125; ret = s.insert(10); if(ret.second)&#123; cout &lt;&lt; &quot;插入成功:&quot; &lt;&lt; *ret.first &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; &quot;插入失败:&quot; &lt;&lt; *ret.first &lt;&lt; endl; &#125;&#125;struct MyCompare02&#123; bool operator()(int v1,int v2)&#123; return v1 &gt; v2; &#125;&#125;;//set从大到小void test02()&#123; srand((unsigned int)time(NULL)); //我们发现set容器的第二个模板参数可以设置排序规则，默认规则是less&lt;_Kty&gt; set&lt;int, MyCompare02&gt; s; for (int i = 0; i &lt; 10;i++)&#123; s.insert(rand() % 100); &#125; for (set&lt;int, MyCompare02&gt;::iterator it = s.begin(); it != s.end(); it ++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//set容器中存放对象class Person&#123;public: Person(string name,int age)&#123; this-&gt;mName = name; this-&gt;mAge = age; &#125;public: string mName; int mAge;&#125;;struct MyCompare03&#123; bool operator()(const Person&amp; p1,const Person&amp; p2)&#123; return p1.mAge &gt; p2.mAge; &#125;&#125;;void test03()&#123; set&lt;Person, MyCompare03&gt; s; Person p1(&quot;aaa&quot;, 20); Person p2(&quot;bbb&quot;, 30); Person p3(&quot;ccc&quot;, 40); Person p4(&quot;ddd&quot;, 50); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, MyCompare03&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; cout &lt;&lt; &quot;Name:&quot; &lt;&lt; it-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; it-&gt;mAge &lt;&lt; endl; &#125;&#125; 对组(pair)对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。 类模板：template \ struct pair. 如何创建对组? 123456789101112//第一种方法创建一个对组pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);cout &lt;&lt; pair1.first &lt;&lt; endl; //访问pair第一个值cout &lt;&lt; pair1.second &lt;&lt; endl;//访问pair第二个值//第二种pair&lt;string, int&gt; pair2 = make_pair(&quot;name&quot;, 30);cout &lt;&lt; pair2.first &lt;&lt; endl;cout &lt;&lt; pair2.second &lt;&lt; endl;//pair=赋值pair&lt;string, int&gt; pair3 = pair2;cout &lt;&lt; pair3.first &lt;&lt; endl;cout &lt;&lt; pair3.second &lt;&lt; endl; map/multimap容器map/multimap基本概念Map的特性是，所有元素都会根据元素的键值自动排序。Map所有的元素都是pair,同时拥有实值和键值，pair的第一元素被视为键值，第二元素被视为实值，map不允许两个元素有相同的键值。 我们可以通过map的迭代器改变map的键值吗？答案是不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。 Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。 Multimap和map的操作类似，唯一区别multimap键值可重复。 Map和multimap都是以红黑树为底层实现机制。 map/multimap常用APImap构造函数12map&lt;T1, T2&gt; mapTT;//map默认构造函数: map(const map &amp;mp);//拷贝构造函数 map赋值操作12map&amp; operator=(const map &amp;mp);//重载等号操作符swap(mp);//交换两个集合容器 map大小操作12size();//返回容器中元素的数目empty();//判断容器是否为空 map插入数据元素操作1234567891011map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;map&lt;int, string&gt; mapStu;// 第一种 通过pair的方式插入对象mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));// 第二种 通过pair的方式插入对象mapStu.inset(make_pair(-1, &quot;校长&quot;));// 第三种 通过value_type的方式插入对象mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));// 第四种 通过数组的方式插入值mapStu[3] = &quot;小刘&quot;;mapStu[5] = &quot;小王&quot;; map删除操作1234clear();//删除所有元素erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(keyElem);//删除容器中key为keyElem的对组。 map查找操作12345find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。 STL容器使用时机 vector deque list set multiset map multimap 典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树 可随机存取 是 是 否 否 否 对key而言：不是 否 元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快 元素安插移除 尾端 头尾两端 任何位置 - - - - vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。 deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。 vector与deque的比较： 一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。 二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。 三：deque支持头部的快速插入与快速移除，这是deque的优点。 list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。 set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。 常用算法函数对象重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。 注意: 1.函数对象(仿函数)是一个类，不是一个函数。 2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。 分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。 函数对象的作用主要是什么？STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//函数对象是重载了函数调用符号的类class MyPrint&#123;public: MyPrint() &#123; m_Num = 0; &#125; int m_Num;public: void operator() (int num) &#123; cout &lt;&lt; num &lt;&lt; endl; m_Num++; &#125;&#125;;//函数对象//重载了()操作符的类实例化的对象，可以像普通函数那样调用,可以有参数 ，可以有返回值void test01()&#123; MyPrint myPrint; myPrint(20);&#125;// 函数对象超出了普通函数的概念，可以保存函数的调用状态void test02()&#123; MyPrint myPrint; myPrint(20); myPrint(20); myPrint(20); cout &lt;&lt; myPrint.m_Num &lt;&lt; endl;&#125;void doBusiness(MyPrint print,int num)&#123; print(num);&#125;//函数对象作为参数void test03()&#123; //参数1：匿名函数对象 doBusiness(MyPrint(),30);&#125; 总结： 1、函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。 2、函数对象超出普通函数的概念，函数对象可以有自己的状态 3、函数对象可内联编译，性能好。用函数指针几乎不可能 4、模版函数对象使函数对象具有通用性，这也是它的优势之一 谓词谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class GreaterThenFive&#123;public: bool operator()(int num) &#123; return num &gt; 5; &#125;&#125;;//一元谓词void test01()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10;i ++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterThenFive()); if (it == v.end()) &#123; cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到了: &quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;//二元谓词class MyCompare&#123;public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125;&#125;;void test02()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(90); v.push_back(60); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(),MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 内建函数对象STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include\。 6个算数类函数对象,除了negate是一元运算，其他都是二元运算。 123456template&lt;class T&gt; T plus&lt;T&gt;//加法仿函数template&lt;class T&gt; T minus&lt;T&gt;//减法仿函数template&lt;class T&gt; T multiplies&lt;T&gt;//乘法仿函数template&lt;class T&gt; T divides&lt;T&gt;//除法仿函数template&lt;class T&gt; T modulus&lt;T&gt;//取模仿函数template&lt;class T&gt; T negate&lt;T&gt;//取反仿函数 6个关系运算类函数对象,每一种都是二元运算。 123456template&lt;class T&gt; bool equal_to&lt;T&gt;//等于template&lt;class T&gt; bool not_equal_to&lt;T&gt;//不等于template&lt;class T&gt; bool greater&lt;T&gt;//大于template&lt;class T&gt; bool greater_equal&lt;T&gt;//大于等于template&lt;class T&gt; bool less&lt;T&gt;//小于template&lt;class T&gt; bool less_equal&lt;T&gt;//小于等于 逻辑运算类运算函数,not为一元运算，其余为二元运算。 123template&lt;class T&gt; bool logical_and&lt;T&gt;//逻辑与template&lt;class T&gt; bool logical_or&lt;T&gt;//逻辑或template&lt;class T&gt; bool logical_not&lt;T&gt;//逻辑非 内建函数对象举例: 1234567891011121314151617181920212223242526272829303132333435//取反仿函数void test01()&#123; negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl;&#125;//加法仿函数void test02()&#123; plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;//大于仿函数void test03()&#123; vector&lt;int&gt; v; srand((unsigned int)time(NULL)); for (int i = 0; i &lt; 10; i++)&#123; v.push_back(rand() % 100); &#125; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 函数对象适配器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159//函数适配器bind1st bind2nd//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做？//我们直接给函数对象绑定参数 编译阶段就会报错//for_each(v.begin(), v.end(), bind2nd(myprint(),100));//如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function//根据我们函数对象是一元函数对象 还是二元函数对象class MyPrint :public binary_function&lt;int,int,void&gt;&#123;public: void operator()(int v1,int v2) const &#123; cout &lt;&lt; &quot;v1 = : &quot; &lt;&lt; v1 &lt;&lt; &quot; v2 = :&quot; &lt;&lt;v2 &lt;&lt; &quot; v1+v2 = :&quot; &lt;&lt; (v1 + v2) &lt;&lt; endl; &#125;&#125;;//1、函数适配器void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;请输入起始值：&quot; &lt;&lt; endl; int x; cin &gt;&gt; x; for_each(v.begin(), v.end(), bind1st(MyPrint(), x)); //for_each(v.begin(), v.end(), bind2nd( MyPrint(),x ));&#125;//总结： bind1st和bind2nd区别?//bind1st ： 将参数绑定为函数对象的第一个参数//bind2nd ： 将参数绑定为函数对象的第二个参数//bind1st bind2nd将二元函数对象转为一元函数对象class GreaterThenFive:public unary_function&lt;int,bool&gt;&#123;public: bool operator ()(int v) const &#123; return v &gt; 5; &#125;&#125;;//2、取反适配器void test02()&#123; vector &lt;int&gt; v; for (int i = 0; i &lt; 10;i++) &#123; v.push_back(i); &#125; // vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterThenFive()); //返回第一个大于5的迭代器// vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1(GreaterThenFive())); //返回第一个小于5迭代器 //自定义输入 vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1 ( bind2nd(greater&lt;int&gt;(),5))); if (it == v.end()) &#123; cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到&quot; &lt;&lt; *it &lt;&lt; endl; &#125; //排序 二元函数对象 sort(v.begin(), v.end(), not2(less&lt;int&gt;())); for_each(v.begin(), v.end(), [](int val)&#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;);&#125;//not1 对一元函数对象取反//not2 对二元函数对象取反void MyPrint03(int v,int v2)&#123; cout &lt;&lt; v + v2&lt;&lt; &quot; &quot;;&#125;//3、函数指针适配器 ptr_funvoid test03()&#123; vector &lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; // ptr_fun( )把一个普通的函数指针适配成函数对象 for_each(v.begin(), v.end(), bind2nd( ptr_fun( MyPrint03 ), 100));&#125;//4、成员函数适配器class Person&#123;public: Person(string name, int age) &#123; m_Name = name; m_Age = age; &#125; //打印函数 void ShowPerson()&#123; cout &lt;&lt; &quot;成员函数:&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; m_Name &lt;&lt; &quot; Age:&quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; void Plus100() &#123; m_Age += 100; &#125;public: string m_Name; int m_Age;&#125;;void MyPrint04(Person &amp;p)&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;;void test04()&#123; vector &lt;Person&gt;v; Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); //for_each(v.begin(), v.end(), MyPrint04); //利用 mem_fun_ref 将Person内部成员函数适配 for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::Plus100));// for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::ShowPerson));&#125;void test05()&#123; vector&lt;Person*&gt; v1; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v1.push_back(&amp;p1); v1.push_back(&amp;p2); v1.push_back(&amp;p3); v1.push_back(&amp;p4); for_each(v1.begin(), v1.end(), mem_fun(&amp;Person::ShowPerson));&#125;//如果容器存放的是对象指针， 那么用mem_fun//如果容器中存放的是对象实体，那么用mem_fun_ref 算法概述算法主要是由头文件\ \ \组成。 \是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找，遍历，复制，修改，反转，排序，合并等… \体积很小，只包括在几个序列容器上进行的简单运算的模板函数. \ 定义了一些模板类,用以声明函数对象。 常用遍历算法123456789101112131415161718/* 遍历算法 遍历容器元素 @param beg 开始迭代器 @param end 结束迭代器 @param _callback 函数回调或者函数对象 @return 函数对象*/for_each(iterator beg, iterator end, _callback);/* transform算法 将指定容器区间元素搬运到另一容器中 注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存 @param beg1 源容器开始迭代器 @param end1 源容器结束迭代器 @param beg2 目标容器开始迭代器 @param _cakkback 回调函数或者函数对象 @return 返回目标容器迭代器*/transform(iterator beg1, iterator end1, iterator beg2, _callbakc) for_each:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*template&lt;class _InIt,class _Fn1&gt; inlinevoid for_each(_InIt _First, _InIt _Last, _Fn1 _Func)&#123; for (; _First != _Last; ++_First) _Func(*_First);&#125;*///普通函数void print01(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;//函数对象struct print001&#123; void operator()(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;//for_each算法基本用法void test01()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10;i++)&#123; v.push_back(i); &#125; //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print001()); cout &lt;&lt; endl;&#125;struct print02&#123; print02()&#123; mCount = 0; &#125; void operator()(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; mCount++; &#125; int mCount;&#125;;//for_each返回值void test02()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++)&#123; v.push_back(i); &#125; print02 p = for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl; cout &lt;&lt; p.mCount &lt;&lt; endl;&#125;struct print03 : public binary_function&lt;int, int, void&gt;&#123; void operator()(int val,int bindParam) const&#123; cout &lt;&lt; val + bindParam &lt;&lt; &quot; &quot;; &#125;&#125;;//for_each绑定参数输出void test03()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++)&#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), bind2nd(print03(),100));&#125; transform:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//transform 将一个容器中的值搬运到另一个容器中/* template&lt;class _InIt, class _OutIt, class _Fn1&gt; inline _OutIt _Transform(_InIt _First, _InIt _Last,_OutIt _Dest, _Fn1 _Func) &#123; for (; _First != _Last; ++_First, ++_Dest) *_Dest = _Func(*_First); return (_Dest); &#125; template&lt;class _InIt1,class _InIt2,class _OutIt,class _Fn2&gt; inline _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,_InIt2 _First2, _OutIt _Dest, _Fn2 _Func) &#123; for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest) *_Dest = _Func(*_First1, *_First2); return (_Dest); &#125;*/struct transformTest01&#123; int operator()(int val)&#123; return val + 100; &#125;&#125;;struct print01&#123; void operator()(int val)&#123; cout &lt;&lt; val &lt;&lt; &quot; &quot;; &#125;&#125;;void test01()&#123; vector&lt;int&gt; vSource; for (int i = 0; i &lt; 10;i ++)&#123; vSource.push_back(i + 1); &#125; //目标容器 vector&lt;int&gt; vTarget; //给vTarget开辟空间 vTarget.resize(vSource.size()); //将vSource中的元素搬运到vTarget vector&lt;int&gt;::iterator it = transform(vSource.begin(), vSource.end(), vTarget.begin(), transformTest01()); //打印 for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl; &#125;//将容器1和容器2中的元素相加放入到第三个容器中struct transformTest02&#123; int operator()(int v1,int v2)&#123; return v1 + v2; &#125;&#125;;void test02()&#123; vector&lt;int&gt; vSource1; vector&lt;int&gt; vSource2; for (int i = 0; i &lt; 10; i++)&#123; vSource1.push_back(i + 1); &#125; //目标容器 vector&lt;int&gt; vTarget; //给vTarget开辟空间 vTarget.resize(vSource1.size()); transform(vSource1.begin(), vSource1.end(), vSource2.begin(),vTarget.begin(), transformTest02()); //打印 for_each(vTarget.begin(), vTarget.end(), print01()); cout &lt;&lt; endl;&#125; 常用查找算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* find算法 查找元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value 查找的元素 @return 返回查找元素的位置*/find(iterator beg, iterator end, value)/* find_if算法 条件查找 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback 回调函数或者谓词(返回bool类型的函数对象) @return bool 查找返回true 否则false*/find_if(iterator beg, iterator end, _callback);/* adjacent_find算法 查找相邻重复元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param _callback 回调函数或者谓词(返回bool类型的函数对象) @return 返回相邻元素的第一个位置的迭代器*/adjacent_find(iterator beg, iterator end, _callback);/* binary_search算法 二分查找法 注意: 在无序序列中不可用 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value 查找的元素 @return bool 查找返回true 否则false*/bool binary_search(iterator beg, iterator end, value);/* count算法 统计元素出现次数 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value回调函数或者谓词(返回bool类型的函数对象) @return int返回元素个数*/count(iterator beg, iterator end, value);/* count算法 统计元素出现次数 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback 回调函数或者谓词(返回bool类型的函数对象) @return int返回元素个数*/count_if(iterator beg, iterator end, _callback); 常用排序算法1234567891011121314151617181920212223242526272829/* merge算法 容器元素合并，并存储到另一容器中 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器*/merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)/* sort算法 容器元素排序 注意:两个容器必须是有序的 @param beg 容器1开始迭代器 @param end 容器1结束迭代器 @param _callback 回调函数或者谓词(返回bool类型的函数对象)*/sort(iterator beg, iterator end, _callback)/* sort算法 对指定范围内的元素随机调整次序 @param beg 容器开始迭代器 @param end 容器结束迭代器*/random_shuffle(iterator beg, iterator end)/* reverse算法 反转指定范围的元素 @param beg 容器开始迭代器 @param end 容器结束迭代器*/reverse(iterator beg, iterator end) 常用拷贝和替换算法1234567891011121314151617181920212223242526272829/* copy算法 将容器内指定范围的元素拷贝到另一容器中 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param dest 目标起始迭代器*/copy(iterator beg, iterator end, iterator dest)/* replace算法 将容器内指定范围的旧元素修改为新元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param oldvalue 旧元素 @param oldvalue 新元素*/replace(iterator beg, iterator end, oldvalue, newvalue)/* replace_if算法 将容器内指定范围满足条件的元素替换为新元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param callback函数回调或者谓词(返回Bool类型的函数对象) @param oldvalue 新元素*/replace_if(iterator beg, iterator end, _callback, newvalue)/* swap算法 互换两个容器的元素 @param c1容器1 @param c2容器2*/swap(container c1, container c2) 常用算数生成算法1234567891011121314/* accumulate算法 计算容器元素累计总和 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value累加值*/accumulate(iterator beg, iterator end, value)/* fill算法 向容器中添加元素 @param beg 容器开始迭代器 @param end 容器结束迭代器 @param value t填充元素*/fill(iterator beg, iterator end, value) 常用集合算法123456789101112131415161718192021222324252627282930313233/* set_intersection算法 求两个set集合的交集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址*/set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)/* set_union算法 求两个set集合的并集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址*/set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)/* set_difference算法 求两个set集合的差集 注意:两个集合必须是有序序列 @param beg1 容器1开始迭代器 @param end1 容器1结束迭代器 @param beg2 容器2开始迭代器 @param end2 容器2结束迭代器 @param dest 目标容器开始迭代器 @return 目标容器的最后一个元素的迭代器地址*/set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer题解及源码(C++完整版)]]></title>
    <url>%2F2019%2F04%2F13%2F2019-04-13%2F</url>
    <content type="text"><![CDATA[GitHub源码地址：https://github.com/qian-youyou/jzOffer 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解析首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 例如，我们要在上述的二维数组中查找数字7的步骤如下图所示： （矩阵中加阴影背景的区域是下一步查找的范围） 代码123456789101112131415161718192021class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int y = array.size(); int x = array[0].size(); int j = x - 1; int i = 0; while(j &gt;=0 &amp;&amp; i &lt; y)&#123; if(array[i][j] == target)&#123; return true; &#125; while(j &gt;= 0 &amp;&amp; array[i][j] &gt; target)&#123; j--; &#125; while(i &lt; y &amp;&amp; array[i][j] &lt; target)&#123; i++; &#125; &#125; return false; &#125;&#125;; 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解析将长度为1的空格替换为长度为3的“%20”，字符差的产度变长。如果允许我们开辟一个新的数组来存放替换空格后的字符串，那么这道题目就非常简 单。设置两个指针分别指向新旧字符串首元素，遍历原字符串，如果碰到空格就在新字符串上填入“%20”，否则就复制元字符串上的内容。但是如果面试官要求在原先的字符串上操作，并且保证原字符串有足够长的空间来存放替换后的字符串，那么我们就得另想方法。如果从前往后替换字符串，那么保存在空格后面的字符串肯定会被覆盖，那么我们就考虑从后往前进行替换。首先遍历原字符串，找出字符串的长度以及其中的空格数量，根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度。设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置。如果point1指向内容不为空格，那么将内容赋值给point2指向的位置，如果point1指向为空格，那么从point2开始赋值“02%”直到point1==point2时表明字符串中的所有空格都已经替换完毕。 代码12345678910111213141516171819202122class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int cnt = 0; for(int i = 0; i &lt; length; i++)&#123; if(str[i] == &apos; &apos;)&#123; cnt++; &#125; &#125; int j = length + cnt * 2; for(int i = length; j&gt;=0 &amp;&amp; i &gt;= 0; i--)&#123; if(str[i] != &apos; &apos;)&#123; str[j--] = str[i]; &#125; else&#123; str[j--] = &apos;0&apos;; str[j--] = &apos;2&apos;; str[j--] = &apos;%&apos;; &#125; &#125; &#125;&#125;; 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解析遍历一遍链表，将每个结点value入栈。最后依次从栈中取出元素即可。 代码1234567891011121314151617181920212223242526/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; ListNode* p = head; stack&lt;int&gt;s; vector&lt;int&gt;v; while(p != NULL)&#123; s.push(p-&gt;val); p = p-&gt;next; &#125; while(!s.empty())&#123; v.push_back(s.top()); s.pop(); &#125; return v; &#125;&#125;; 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解析在二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。 如下图所示，前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。 同样，在前序遍历的序列中，根结点后面的3个数字就是3个左子树结点的值，再后面的所有数字都是右子树结点的值。这样我们就在前序遍历和中序遍历两个序列中，分别找到了左右子树对应的子序列。 既然我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列，我们可以用同样的方法分别去构建左右子树。也就是说，接下来的事情可以用递归的方法去完成。 代码12345678910111213141516171819202122232425262728293031323334353637/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(pre.size() == 0 || vin.size() == 0)&#123; return NULL; &#125; TreeNode* T; int index = 0; buildTree(T, pre, vin, 0, 0, pre.size(), index); return T; &#125; void buildTree(TreeNode* &amp;T, vector&lt;int&gt; pre,vector&lt;int&gt; vin, int cur, int left, int right, int &amp;index)&#123; T = new TreeNode(pre[cur]); ++index; int i; for(i = left; i &lt; right; i++)&#123; if(vin[i] == pre[cur])&#123; break; &#125; &#125; if(i &gt; left &amp;&amp; i &lt; right)&#123; buildTree(T-&gt;left, pre, vin, cur + 1, left, i, index); &#125; if(i &lt; right - 1)&#123; buildTree(T-&gt;right, pre, vin, index, i + 1, right, index); &#125; &#125;&#125;; 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解析用stack1来实现队列的push操作，用stack2来实现队列的pop操作，当stack2为空时，将stack1的数据全部压入stack2，等待队列的pop操作。 代码1234567891011121314151617181920212223242526272829303132class Solution&#123;public: void push(int node) &#123; if(stack1.empty())&#123; while(!stack2.empty())&#123; stack1.push(stack2.top()); stack2.pop(); &#125; &#125; stack1.push(node); &#125; int pop() &#123; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; if(!stack2.empty())&#123; int ans = stack2.top(); stack2.pop(); return ans; &#125; return 0; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解析由于数组非递减，那么旋转后的除了最小元素以外其他元素一定大于等于上一个元素，最小元素小于等于它上一个元素。遍历一遍查找哪个元素比上一元素小即可。若遍历完也没有，就输出第一个元素。 代码123456789101112131415161718class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int len = rotateArray.size(); if(!len)&#123; return 0; &#125; else if (len == 1)&#123; return rotateArray[0]; &#125; for(int i = 1; i &lt; len; i++)&#123; if(rotateArray[i] &lt; rotateArray[i - 1])&#123; return rotateArray[i]; &#125; &#125; return 0; &#125;&#125;; 斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 解析斐波那契数列。F(N) = F(N - 1) + F(N - 2) 代码123456789101112class Solution &#123;public: int Fibonacci(int n) &#123; int a[40]; a[0] = 0; a[1] = 1; for(int i = 2; i &lt; 40; i++)&#123; a[i] = a[i-1] + a[i-2]; &#125; return a[n]; &#125;&#125;; 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解析斐波那契数列。假设青蛙在第N阶，且第N-1阶跳法与第N-2阶跳法已经求出，则第N阶就是N-1阶的跳法加上第N-2阶的跳法。F(N) = F(N - 1) + F(N - 2)。 代码123456789101112131415class Solution &#123;public: int jumpFloor(int number) &#123; if(number &lt; 1)&#123; return 0; &#125; vector&lt;int&gt;v(number + 1); v[0] = 1; v[1] = 1; for(int i = 2; i &lt;= number; i++)&#123; v[i] = v[i-1] + v[i-2]; &#125; return v[number]; &#125;&#125;; 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解析第N阶等于第1阶 + 第2阶 + …… + 第N-1阶。即2^(n-1)。 代码123456789101112131415161718class Solution &#123;public: int quick_pow(int n)&#123; int ans = 2, res = 1; while(n)&#123; if(n &amp; 1)&#123; res *= ans; &#125; ans *= ans; n &gt;&gt;= 1; &#125; return res; &#125; int jumpFloorII(int number) &#123; number = quick_pow(number - 1); return number; &#125;&#125;; 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解析骨牌最最简单的问题。依旧是斐波那契数列。 代码123456789101112131415class Solution &#123;public: int rectCover(int number) &#123; if(number &lt; 1)&#123; return 0; &#125; vector&lt;int&gt;v(number + 1); v[0] = 1; v[1] = 1; for(int i = 2; i &lt;= number; i++)&#123; v[i] = v[i-1] + v[i-2]; &#125; return v[number]; &#125;&#125;; 二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解析位运算。时间复杂度为有几个1就执行几次。 代码1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; int cnt = 0; while(n)&#123; cnt++; n = n &amp; (n - 1); &#125; return cnt; &#125;&#125;; 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解析快速幂。 代码12345678910111213141516171819202122class Solution &#123;public: double quick_pow(double base, int n)&#123; double ans = 1; while(n)&#123; if(n&amp;1)&#123; ans *= base; &#125; base*=base; n&gt;&gt;=1; &#125; return ans; &#125; double Power(double base, int exponent) &#123; if(exponent &gt;= 0)&#123; return quick_pow(base, exponent); &#125; else&#123; return pow(base, exponent); &#125; &#125;&#125;; 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解析奇数储存于一个数组，偶数储存于一个数组。最后合并。 代码123456789101112131415161718192021222324class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; const int len = array.size(); int a[len], b[len]; int aa = 0; int bb = 0; for(int i = 0; i &lt; len; i++)&#123; if(array[i]%2)&#123; a[aa++] = array[i]; &#125; else&#123; b[bb++] = array[i]; &#125; &#125; for(int i = 0; i &lt; aa; i++)&#123; array[i] = a[i]; &#125; bb = 0; for(int i = aa; i &lt; len; i++)&#123; array[i] = b[bb++]; &#125; &#125;&#125;; 链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解析两个指针，一个指针先走k步，然后两个指针同时走，这样第1个指针走到头，第2给个指针刚好剩k个结点。 代码123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode* p = pListHead; ListNode* q = pListHead; unsigned int cnt = 0; while(p != NULL)&#123; if(cnt &gt;= k)&#123; q = q-&gt;next; &#125; ++cnt; p = p-&gt;next; &#125; if(cnt &lt; k)&#123; return NULL; &#125; return q; &#125;&#125;; 反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解析将前一个节点与后一个节点断开，然后让前一个节点指向后一个节点，这个过程就需要节点引用（可以理解为指针）来确定记录当前操作节点的前一个节点和后一个节点。 代码12345678910111213141516171819202122/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode* p = NULL; ListNode* q = pHead; while(q)&#123; pHead = q; q = q-&gt;next; pHead-&gt;next = p; p = pHead; &#125; return pHead; &#125;&#125;; 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解析归并排序基本操作。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool check(ListNode *a, ListNode *b)&#123; if(a == NULL || b == NULL)&#123; if(a != NULL)&#123; return true; &#125;else&#123; return false; &#125; &#125; return a-&gt;val &lt; b-&gt;val; &#125; void fun(ListNode* &amp;p, ListNode* &amp;pHead)&#123; ListNode* tmp = pHead; pHead = pHead-&gt;next; p-&gt;next = tmp; p = p-&gt;next; &#125; ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; ListNode* pHead = NULL; ListNode* p = pHead; while(pHead1 != NULL || pHead2 != NULL)&#123; if(check(pHead1, pHead2))&#123; if(!pHead)&#123; pHead = pHead1; p = pHead; &#125; else&#123; fun(p, pHead1); &#125; &#125; else&#123; if(!pHead)&#123; pHead = pHead2; p = pHead; &#125; else&#123; fun(p, pHead2); &#125; &#125; &#125; return pHead; &#125;&#125;; 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解析递归设计思路： A、判断子树根值是否相等。 A1、如果是相等，需要一个可以判断该根左右孩子结点是否相等的递归函数。 A2、如果不等，找大树的左右孩子结点当根结点，递归到A步骤。 代码123456789101112131415161718192021222324252627282930313233343536373839404142/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool dfs(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot1 == NULL || pRoot2 == NULL)&#123; if(pRoot2 == NULL)&#123; return true; &#125;else&#123; return false; &#125; &#125; if(pRoot1-&gt;val == pRoot2-&gt;val)&#123; if(dfs(pRoot1-&gt;left, pRoot2-&gt;left))&#123; if(dfs(pRoot1-&gt;right, pRoot2-&gt;right))&#123; return true; &#125; &#125; &#125; return false; &#125; bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if(pRoot1 == NULL || pRoot2 == NULL)&#123; return false; &#125; if(pRoot1-&gt;val == pRoot2-&gt;val)&#123; if(dfs(pRoot1, pRoot2))&#123; return true; &#125; &#125; bool flag = HasSubtree(pRoot1-&gt;left, pRoot2)||HasSubtree(pRoot1-&gt;right, pRoot2); return flag; &#125;&#125;; 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解析递归： A：遍历左子树。 B：遍历右子树。 C：左子树和右子树交换。 代码1234567891011121314151617181920212223242526/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(pRoot == NULL)&#123; return; &#125; if(pRoot-&gt;left != NULL)&#123; Mirror(pRoot-&gt;left); &#125; if(pRoot-&gt;right != NULL)&#123; Mirror(pRoot-&gt;right); &#125; TreeNode *tmp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = tmp; &#125;&#125;; 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解析用vis数组储存访问状态。每次直线走n-1个，如果vis已访问就改变方向。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; vector&lt;int&gt;ans; const int len1 = matrix.size(); if(!len1)&#123; return ans; &#125; const int len2 = matrix[0].size(); vector&lt;bool&gt;vis(len1*len2, false); int a[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; bool flag = true; int x = 0, y = 0; ans.push_back(matrix[x][y]); vis[0] = true; while(flag)&#123; flag = false; for(int i = 0; i &lt; 4; ++i)&#123; while(x + a[i][0] &gt;= 0 &amp;&amp; x + a[i][0] &lt; len1 &amp;&amp; y + a[i][1] &gt;= 0 &amp;&amp; y + a[i][1] &lt; len2 &amp;&amp; !vis[(x + a[i][0]) * len2 + y + a[i][1]])&#123; flag = true; x += a[i][0]; y += a[i][1]; ans.push_back(matrix[x][y]); vis[x*len2 + y] = true; &#125; &#125; &#125; return ans; &#125;&#125;; 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解析两个栈，一个储存最小值，一个储存源数据。弹出的话两个一起弹出。 代码12345678910111213141516171819202122232425262728class Solution &#123;public: void push(int value) &#123; StackInt.push(value); if(StackMin.empty()) StackMin.push(value); else if(StackMin.top()&lt;value) StackMin.push(StackMin.top()); else StackMin.push(value); &#125; void pop() &#123; if(!StackInt.empty()) &#123; StackInt.pop(); StackMin.pop(); &#125; &#125; int top() &#123; return StackInt.top(); &#125; int min() &#123; return StackMin.top(); &#125;private: stack&lt;int&gt; StackInt; stack&lt;int&gt; StackMin;&#125;; 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解析栈模拟一遍即可。 代码1234567891011121314151617181920class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; stack&lt;int&gt; s; int len = pushV.size(), i = 0, j = 0; while(i &lt; len &amp;&amp; j &lt; len)&#123; while(s.empty() || i &lt; len &amp;&amp; s.top() != popV[j])&#123; s.push(pushV[i++]); &#125; while(j &lt; len &amp;&amp; !s.empty() &amp;&amp; s.top() == popV[j])&#123; s.pop(); ++j; &#125; &#125; if(j &lt; len)&#123; return false; &#125; return true; &#125;&#125;; 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解析广度优先遍历。queue储存数据。 代码1234567891011121314151617181920212223242526272829303132/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt;v; queue&lt;TreeNode*&gt;q; if(root == NULL)&#123; return v; &#125; q.push(root); while(!q.empty())&#123; TreeNode* tmp = q.front(); q.pop(); v.push_back(tmp-&gt;val); if(tmp-&gt;left != NULL)&#123; q.push(tmp-&gt;left); &#125; if(tmp-&gt;right != NULL)&#123; q.push(tmp-&gt;right); &#125; &#125; return v; &#125;&#125;; 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解析对于一个二叉树的后序遍历序列来说，最后一个数一定是根节点，然后前面的数中，从最开始到第一个大于根节点的数都是左子树中的数，而后面到倒数第二个数应该都是大于根节点的，是右子树，如果后面的数中有小于根节点的，那么说明这个序列不是二叉搜索树的后序遍历序列。 代码12345678910111213141516171819202122232425262728class Solution &#123;public: bool check(vector&lt;int&gt; &amp;sequence, int left, int right)&#123; bool flag = false; if(left &gt;= right)&#123; return true; &#125; int mindle = left; int cur = sequence[right]; for(int i = left; i &lt; right; ++i)&#123; if(!flag &amp;&amp; sequence[i] &gt; cur)&#123; flag = true; mindle = i; &#125;else if(flag &amp;&amp; sequence[i] &lt; cur)&#123; return false; &#125; &#125; flag = check(sequence, left, mindle - 1) &amp;&amp; check(sequence, mindle, right - 1); return flag; &#125; bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; const int len = sequence.size(); if(!len)&#123; return false; &#125; return check(sequence, 0, len - 1); &#125;&#125;; 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解析首先思考节点值的和为输入的整数，每条路径都一定是从根节点到叶子节点，在数据结构中从根节点到叶子节点的遍历称之为深度优先遍历DFS。因此整个过程可以采用先序遍历方式的DFS，即根节点》左子树》右子树。随后考虑一次遍历完成后的处理，当一次遍历完成后，如果输入整数值恰好等于节点值之和，则输出这条路径并且回退一个节点；如果不等于则直接回退一个节点，即回退到当前节点的父节点，如果该父节点有右孩子，则继续遍历，否则继续回退。考虑回退到根节点，此时如果它有右孩子，则继续遍历，否则整个DFS结束。 代码1234567891011121314151617181920212223242526272829/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; buffer; vector&lt;int&gt; tmp; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; if(root==NULL)&#123; return buffer; &#125; tmp.push_back(root-&gt;val); if((expectNumber-root-&gt;val)==0 &amp;&amp; root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL)&#123; buffer.push_back(tmp); &#125; FindPath(root-&gt;left,expectNumber-root-&gt;val); FindPath(root-&gt;right,expectNumber-root-&gt;val); if(tmp.size()!=0)&#123; tmp.pop_back(); &#125; return buffer; &#125;&#125;; 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解析第一步仍然是根据原始链表的每个结点N创建对应的N’。（把N’链接在N的后面） 第二步设置复制出来的结点的Sibling。（把N’的Sibling指向N的Sibling） 第三步把这个长链表拆分成两个链表：把奇数位置的结点用Next链接起来就是原始链表，偶数数值的则是复制链表。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; RandomListNode *pHead2 = pHead, *p2, *tmp = pHead; while(tmp)&#123; p2 = new RandomListNode(tmp-&gt;label); p2-&gt;next = tmp-&gt;next; tmp-&gt;next = p2; tmp = p2-&gt;next; &#125; if(pHead)&#123; pHead2 = pHead-&gt;next; &#125; tmp = pHead; while(tmp)&#123; if(tmp-&gt;random)&#123; tmp-&gt;next-&gt;random = tmp-&gt;random-&gt;next; &#125; tmp = tmp-&gt;next-&gt;next; &#125; tmp = pHead; p2 = pHead2; while(tmp)&#123; tmp-&gt;next = tmp-&gt;next-&gt;next; tmp = tmp-&gt;next; if(p2-&gt;next)&#123; p2-&gt;next = p2-&gt;next-&gt;next; p2 = p2-&gt;next; &#125; &#125; return pHead2; &#125;&#125;; 二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解析步骤1：递归左子树，使左子树为有序双向链表。 步骤2：递归右子树，使右子树为有序双向链表。 步骤3：左子树尾节点和根节点连接，右子树头节点和根节点连接。返回左子树头节点或根节点。 代码123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree)&#123; if(pRootOfTree)&#123; TreeNode* left = Convert(pRootOfTree-&gt;left); TreeNode* right = Convert(pRootOfTree-&gt;right); TreeNode* tail = left; if(right)&#123; right-&gt;left = pRootOfTree; pRootOfTree-&gt;right = right; &#125; if(left)&#123; while(tail-&gt;right)&#123; tail = tail-&gt;right; &#125; tail-&gt;right = pRootOfTree; pRootOfTree-&gt;left = tail; return left; &#125; return pRootOfTree; &#125; return NULL; &#125;&#125;; 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述:1输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解析把一个字符串看成两部分组成：第一部分为第一个字符，第二部分为后面的所有字符。 求整个字符串的排列，可以看出两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；然后固定第一个字符，求后面所有字符的排序。此时仍把后面的字符看成两部分，第一个字符和后面的字符，然后重复上述步骤。（递归） 在后面的在线测试中，要求输入字符串可能有重复的字符，输出按照字典顺序，排序即可。 代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt;v; void dfs(string str, int cur)&#123; if(cur &lt; str.size() - 1)&#123; for(int i = cur; i &lt; str.size(); ++i)&#123; if(i == cur || str[i] != str[cur])&#123; swap(str[cur], str[i]); dfs(str, cur + 1); swap(str[cur], str[i]); &#125; &#125; &#125;else&#123; v.push_back(str); &#125; &#125; vector&lt;string&gt; Permutation(string str) &#123; dfs(str, 0); sort(v.begin(), v.end()); return v; &#125;&#125;; 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解析 当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1； 如果下一个数字和我们之前保存的数字不同，则次数减1。 如果次数为零，我们需要保存下一个数字，并把次数设为1。 最后遍历一遍，统计该数出现的次数。 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; const int len = numbers.size(); if(!len)&#123; return 0; &#125; int ans = numbers[0], cnt = 1; for(int i = 1; i &lt; len; ++i)&#123; if(numbers[i] == ans)&#123; ++cnt; &#125;else&#123; if(!cnt)&#123; ans = numbers[i]; cnt = 1; &#125; --cnt; &#125; &#125; cnt = 0; for(int i = 0; i &lt; len; ++i)&#123; if(numbers[i] == ans)&#123; ++cnt; &#125; &#125; if(cnt &lt;= len / 2)&#123; ans = 0; &#125; return ans; &#125;&#125;; 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解析建一个容量k的大根堆。 代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt;v; priority_queue&lt;int&gt;que; int len = input.size(); if(len &lt; k)&#123; return v; &#125; for(int i = 0; i &lt; len; ++i)&#123; que.push(input[i]); while(que.size() &gt; k)&#123; que.pop(); &#125; &#125; while(!que.empty())&#123; v.push_back(que.top()); que.pop(); &#125; return v; &#125;&#125;; 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解析直接遍历，如果上一个数加上这个数变小了就不加，否则加上。 代码123456789101112class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int len = array.size(); int ans = array[0]; for(int i = 1; i &lt; len; ++i)&#123; array[i] = max(array[i], array[i] + array[i - 1]); ans = max(ans, array[i]); &#125; return ans; &#125;&#125;; 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解析总结一下以上的算法，可以看到，当计算右数第 i 位包含的 x 的个数时： 取第 i位左边(高位)的数字，乘以 10i-1，得到基础值 a 取第 i 位数字，计算修正值 如果大于 x , 则结果为 a + 10i-1 如果小于 x，则结果为 a 如果等于 x，则取第 i 位右边(低位)数字，设为 b，最后结果为 a + b + 1 代码123456789101112131415161718192021class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int cnt = n, ans = 0, res = 1; while(cnt)&#123; if(cnt % 10)&#123; if(cnt % 10 &gt; 1)&#123; ans += res; &#125;else&#123; ans += n % res + 1; &#125; &#125; cnt /= 10; ans += cnt * res; res *= 10; &#125; return ans; &#125;&#125;; 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解析sort排序即可，cmp由我们写，可以转成字符串，然后利用字符串进行比较。 代码123456789101112131415161718192021class Solution &#123;public: static bool cmp(int a, int b)&#123; string str1 = to_string(a); string str2 = to_string(b); return str1 + str2 &lt; str2 + str1; &#125; string PrintMinNumber(vector&lt;int&gt; numbers) &#123; int tmp; string str; int len = numbers.size(); sort(numbers.begin(), numbers.end(), cmp); for(int i = 0; i &lt; len; ++i)&#123; while(numbers[i] == 0)&#123; continue; &#125; str += to_string(numbers[i]); &#125; return str; &#125;&#125;; 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解析优先队列+集合+选择性插入 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;que; que.push(1); int i = 0; int MAXN = 0; set&lt;int&gt;s; while(!que.empty())&#123; int ans = que.top(); que.pop(); if(s.count(ans)||ans &lt; 0)&#123; continue; &#125; s.insert(ans); ++i; s.insert(ans); if(i == index)&#123; return ans; &#125; if(que.size() &lt; index)&#123; que.push(ans*2); que.push(ans*3); que.push(ans*5); MAXN = max(MAXN, ans * 5); &#125; else&#123; if(ans*2&lt;MAXN)&#123; que.push(ans*2); &#125; if(ans*3&lt;MAXN)&#123; que.push(ans*3); &#125; if(ans*5&lt;MAXN)&#123; que.push(ans*5); &#125; &#125; &#125; return 0; &#125;&#125;; 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解析哈希表，可用map统计。 代码123456789101112131415class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; map&lt;char, int&gt;m; for(int i = 0; i &lt; str.length(); i++)&#123; m[str[i]]++; &#125; for(int i = 0; i &lt; str.length(); i++)&#123; if(m[str[i]] == 1)&#123; return i; &#125; &#125; return -1; &#125;&#125;; 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述:1题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例1输入11,2,3,4,5,6,7,0 输出17 解析归并排序。先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: const long long mod = 1e9 + 7; int my_merge(vector&lt;int&gt; &amp;data, int left, int mindle, int right)&#123; vector&lt;int&gt;A(mindle - left + 1); vector&lt;int&gt;B(right - mindle); long long ans = 0; for(int i = left; i &lt;= mindle; ++i)&#123; A[i - left] = data[i]; &#125; for(int i = mindle + 1; i &lt;= right; ++i)&#123; B[i - mindle - 1] = data[i]; &#125; int x = 0, y = 0; for(int i = left; i &lt;= right; ++i)&#123; if(x &gt;= A.size())&#123; data[i] = B[y++]; &#125;else if(y &gt;= B.size())&#123; data[i] = A[x++]; &#125;else&#123; if(A[x] &gt; B[y])&#123; data[i] = B[y++]; ans += A.size() - x; &#125;else&#123; data[i] = A[x++]; &#125; &#125; &#125; ans %= mod; return ans; &#125; int mergeSort(vector&lt;int&gt;&amp;data, int left, int right)&#123; long long ans = 0; if(left &lt; right)&#123; int mindle = (left + right) / 2; ans += mergeSort(data, left, mindle); ans += mergeSort(data, mindle + 1, right); ans += my_merge(data, left, mindle, right); &#125; ans %= mod; return ans; &#125; int InversePairs(vector&lt;int&gt; data) &#123; int ans = mergeSort(data, 0, data.size() - 1); return ans; &#125;&#125;; 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解析如果两链表有交点，则必然是“Y”型或“V”型。 如何判断两个单向链表有没有公共结点？如果两个链表有一个公共结点，那么 该公共结点之后的所有结点都是重合的。那么，它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分，只要分别遍历两个链表到最后一 个结点。如果两个尾结点是一样的，说明它们用重合；否则两个链表没有公共的结点。 在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长l个结点，我们先在长的链表上遍历l个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点考试到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。 在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，知道找到相同的结点，或者一直到链表结束。此时，如果第一个链表的长度为m，第二个链表的长度为n，该方法的时间复杂度为O(m+n)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* fun(ListNode* &amp;pHead, ListNode* p)&#123; ListNode* q = pHead; while(p != NULL)&#123; p = p-&gt;next; q = q-&gt;next; &#125; return q; &#125; ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; ListNode* p1 = pHead1; ListNode* p2 = pHead2; while(p1 != NULL &amp;&amp; p2 != NULL)&#123; if(p1 == p2)&#123; return p1; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; if(p1 == NULL &amp;&amp; p2 == NULL)&#123; return NULL; &#125;else&#123; if(p1 != NULL)&#123; p1 = fun(pHead1, p1); p2 = pHead2; &#125;else&#123; p2 = fun(pHead2, p2); p1 = pHead1; &#125; &#125; return FindFirstCommonNode(p1, p2); &#125;&#125;; 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解析我的方法直接遍历。更高效的方法是二分查找两遍，先找到该数字的左边界，再找到该数字的右边界，然后下标相减。 代码123456789101112class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int cnt = 0; for(int i = 0; i &lt; data.size(); ++i)&#123; if(data[i] == k)&#123; ++cnt; &#125; &#125; return cnt; &#125;&#125;; 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解析遍历一遍即可。 代码1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; int cnt = 0; if(pRoot != NULL)&#123; cnt += max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)) + 1; &#125; return cnt; &#125;&#125;; 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解析递归判断左子树深度和右子树深度差是否不大于1。 代码123456789101112131415161718192021class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; if(pRoot == NULL) return true; int leftDepth = getDepth(pRoot -&gt; left); int rightDepth = getDepth(pRoot -&gt; right); if(leftDepth &gt; rightDepth + 1 || leftDepth + 1 &lt; rightDepth) return false; else return IsBalanced_Solution(pRoot -&gt; left) &amp;&amp; IsBalanced_Solution(pRoot -&gt; right); &#125; int getDepth(TreeNode* pRoot)&#123; if(pRoot == NULL) return 0; int leftDepth = getDepth(pRoot -&gt; left); int rightDepth = getDepth(pRoot -&gt; right); return leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1; &#125;&#125;; 数组中只出现一次的数字题目描述一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 解析我用的map。可以用位运算。 代码123456789101112131415161718192021class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int len = data.size(); bool flag = false; map&lt;int, int&gt;m; for(int i = 0; i &lt; len; ++i)&#123; m[data[i]]++; &#125; for(int i = 0; i &lt; len; ++i)&#123; if(m[data[i]] == 1)&#123; if(flag)&#123; *num2 = data[i]; &#125;else&#123; flag = true; *num1 = data[i]; &#125; &#125; &#125; &#125;&#125;; 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述:1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解析在序列首部各定义指针left, right，如果和超过s，left往右移，如果和小于s，right往右移。 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;int&gt; v; vector&lt;vector&lt;int&gt; &gt;ans; for(int i = 1; i &lt;= sum; ++i)&#123; v.push_back(i); &#125; int left = 1, right = 1; int cnt = 1; while(right &lt; sum &amp;&amp; left &lt; sum)&#123; if(cnt == sum)&#123; ans.push_back(vector&lt;int&gt;(v.begin() + left - 1, v.begin() + right)); &#125; if(cnt &gt; sum)&#123; cnt -= left; ++left; &#125;else if(cnt &lt;= sum)&#123; ++right; cnt += right; &#125; &#125; return ans; &#125;&#125;; 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述:1对应每个测试案例，输出两个数，小的先输出。 解析在序列首尾各定义指针p1, p2，如果和超过s，p2往中间移，如果和小于s，p1往中间移。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt;v; int left = 0; int right = array.size() - 1; while(left &lt; right)&#123; if(array[left] + array[right] == sum)&#123; v.push_back(array[left]); v.push_back(array[right]); break; &#125;else if(array[left] + array[right] &gt; sum)&#123; --right; &#125;else&#123; ++left; &#125; &#125; return v; &#125;&#125;; 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解析先取余，再字符串分割。 代码123456789101112class Solution &#123;public: string LeftRotateString(string str, int n) &#123; unsigned int len = str.size(); if(!len)&#123; return &quot;&quot;; &#125; n %= len; string str2 = str.substr(size_t(n)) + str.substr(0, n); return str2; &#125;&#125;; 翻转单词顺序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解析用栈储存单词，存完了再输出。 代码123456789101112131415161718192021222324class Solution &#123;public: string ReverseSentence(string str) &#123; stack&lt;string&gt;s; istringstream istring; istring.str(str); string tmp; while(istring &gt;&gt; tmp)&#123; s.push(tmp); &#125; if(!s.empty())&#123; s.pop(); &#125;else&#123; if(str.size())&#123; return str; &#125; &#125; while(!s.empty())&#123; tmp += &quot; &quot; + s.top(); s.pop(); &#125; return tmp; &#125;&#125;; 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解析暴力做的。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if(numbers.empty())&#123; return false; &#125; int cnt = 0, cur = 0; sort(numbers.begin(), numbers.end()); for(int i = 0; i &lt; numbers.size(); ++i)&#123; if(numbers[i] == 0)&#123; ++cnt; &#125;else&#123; if(cur)&#123; while(numbers[i] != cur + 1)&#123; cur += 1; --cnt; if(cnt &lt; 0)&#123; return false; &#125; &#125; cur += 1; &#125; else&#123; cur = numbers[i]; &#125; &#125; &#125; return true; &#125;&#125;; 孩子们的游戏(圆圈中最后剩下的数)题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解析现在我们把他们的编号做一下转换： k –&gt; 0k+1 –&gt; 1k+2 –&gt; 2……k-2 –&gt; n-2k-1 –&gt; n-1解x’ —-&gt; 解为x注意&lt; x’就是最终的解 &gt; 变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k)%n 如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的情况 —- 这显然就是一个倒推问题！下面举例说明： 假设现在是6个人（编号从0到5）报数，报到（2-1）的退出，即 &lt; m=2&gt;。那么第一次编号为1的人退出圈子，从他之后的人开始算起，序列变为2,3,4,5,0，即问题变成了这5个人报数的问题，将序号做一下转换：2 –&gt;03 –&gt;14 –&gt;25 –&gt;30 –&gt;4现在假设x为0,1,2,3,4的解，x’设为那么原问题的解（这里注意，2,3,4,5,0的解就是0,1,2,3,4,5的解，因为1出去了，结果还是一个），根据观察发现，x与x’关系为x’=(x+m)%n，因此只要求出x，就可以求x’。x怎么求出呢？继续推导吧。0,1,2,3,4,，同样是第二个1出列，变为（2,3,4,0），转换下为2 –&gt;03 –&gt;14 –&gt;20 –&gt;3很简单，同样的道理，公式又出来了，x=(x”+m)%5，这里变成5了。即求n-1个人的问题就是找出n-2的人的解，n-2就是要找出n-3，等等因此，就可以回去看上面的推导过程了。 好了，思路出来了，下面写递推公式：令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n] 递推公式f[1]=0;f[i]=(f[i-1]+m)%i; (i&gt;1) 有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1由于是逐级递推，不需要保存每个f[i]。 代码1234567891011121314class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if(n + m == 0)&#123; return -1; &#125; int s = 0; for(int i = 2; i &lt;= n; ++i)&#123; s = (s + m) % i; &#125; return s; &#125;&#125;; 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解析利用逻辑运算符&amp;&amp;的性质。 代码12345678910class Solution &#123;public: int Sum_Solution(int n) &#123; return fun(n); &#125; int fun(int n)&#123; n &amp;&amp; (n += fun(n-1)); return n; &#125;&#125;; 不用加减乘除做加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解析位运算，先异或，再右移。 代码1234567891011121314class Solution &#123;public: int Add(int num1, int num2) &#123; while(num2)&#123; int a1 = num1 ^ num2; int a2 = num1 &amp; num2; a2 &lt;&lt;= 1; num1 = a1; num2 = a2; &#125; return num1; &#125;&#125;; 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 输入描述:1输入一个字符串,包括数字字母符号,可以为空 输出描述:1如果是合法的数值表达则返回该数字，否则返回0 示例1输入12+2147483647 1a33 输出122147483647 0 解析暴力 代码1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int StrToInt(string str) &#123; int ans = 0; int flag = 0; for(int i = 0; i &lt; str.length(); i++)&#123; while(str[i] == &apos; &apos;)&#123; continue; &#125; if(str[i] &lt;= &apos;9&apos; &amp;&amp; str[i] &gt;= &apos;0&apos;)&#123; ans *= 10; ans += str[i] - &apos;0&apos;; &#125;else&#123; if(!flag)&#123; if(str[i] == &apos;-&apos;)&#123; flag = -1; &#125;else if(str[i] == &apos;+&apos;)&#123; flag = 1; &#125;else&#123; return 0; &#125; &#125;else&#123; return 0; &#125; &#125; &#125; if(flag)&#123; ans *= flag; &#125; return ans; &#125;&#125;; 数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 解析0~n-1正常的排序应该是A[i]=i；因此可以通过交换的方式，将它们都各自放回属于自己的位置； 从头到尾扫描数组A，当扫描到下标为i的数字m时，首先比较这个数字m是不是等于i， 如果是，则继续扫描下一个数字； 如果不是，则判断它和A[m]是否相等，如果是，则找到了第一个重复的数字（在下标为i和m的位置都出现了m）；如果不是，则把A[i]和A[m]交换，即把m放回属于它的位置； 重复上述过程，直至找到一个重复的数字； 时间复杂度：O(n)，空间复杂度：O(1) 注：张氏排序法 代码123456789101112131415161718192021class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; for(int i = 0; i &lt; length; ++i)&#123; while(numbers[i] != i)&#123; if(numbers[i] == numbers[numbers[i]])&#123; *duplication = numbers[i]; return true; &#125; swap(numbers[i], numbers[numbers[i]]); &#125; &#125; return false; &#125;&#125;; 构建乘积数组题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解析 B[i]的值可以看做下图的矩阵中每行的乘积。 下三角用连乘可以很容易求得，先算下三角中的连乘，即先计算出B[i]中的一部分，然后将上三角中的数也乘进去。这样一来就只需要两个循环就可以解决这个问题。时间复杂度是O(n); 其实你只需要知道这个是形成一个矩阵，然后每一行是用来计算B[i],每一行的内容则是A[0]到A[n-1]。利用上三角和下三角进行计算。 代码1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt;B(A.size(), 1); int tmp = 1; for(int i = 0; i &lt; A.size() - 1; ++i)&#123; tmp *= A[i]; B[i + 1] *= tmp; &#125; tmp = 1; for(int i = A.size() - 1; i &gt; 0; --i)&#123; tmp *= A[i]; B[i - 1] *= tmp; &#125; return B; &#125;&#125;; 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解析“.”按任意字符匹配。如果模式串遇到*字符则有两种状态，第一匹配字符，则字符串后移一位，模式串不变，第二，模式串后移俩位和字符串后移一位，第三，忽略星号。 代码1234567891011121314151617class Solution &#123;public: bool match(char* str, char* pattern)&#123; if(str[0] == 0 &amp;&amp; pattern[0] == 0)&#123; return true; &#125;else if(pattern[0] &amp;&amp; pattern[1] == &apos;*&apos; &amp;&amp; match(str, pattern + 2))&#123; return true; &#125;else if(str[0] &amp;&amp; pattern[0] == &apos;.&apos; || str[0] == pattern[0])&#123; if(match(str + 1, pattern + 1))&#123; return true; &#125;else if(pattern[1] == &apos;*&apos; &amp;&amp; match(str + 1, pattern))&#123; return true; &#125; &#125; return false; &#125;&#125;; 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解析暴力 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool isNumeric(char* string) &#123; int len = strlen(string); int cur = 0; bool a = false, b = false, c = false, ans = true; while(string[cur] == &apos; &apos;)&#123; ++cur; &#125; for(; cur &lt; len; ++cur)&#123; if(string[cur] &gt;= &apos;0&apos; &amp;&amp; string[cur] &lt;= &apos;9&apos;)&#123; ans = true; a = true; &#125;else if(string[cur] == &apos;+&apos; || string[cur] == &apos;-&apos;)&#123; if(a)&#123; return false; &#125;else&#123; a = true; &#125; &#125;else if(string[cur] == &apos;e&apos; || string[cur] == &apos;E&apos;)&#123; if(b)&#123; return false; &#125;else&#123; b = true; a = false; ans = false; &#125; &#125;else if(string[cur] == &apos;.&apos;)&#123; if(c || b)&#123; return false; &#125;else&#123; c = true; ans = false; &#125; &#125;else&#123; return false; &#125; &#125; return ans; &#125;&#125;; 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述:1如果当前字符流没有存在出现一次的字符，返回#字符。 解析哈希表。 代码1234567891011121314151617181920212223242526class Solution&#123;public: //Insert one char from stringstream Solution():cur(0)&#123;&#125; void Insert(char ch) &#123; str += ch; ++mp[ch]; while(cur &lt; str.size() &amp;&amp; mp[str[cur]] &gt; 1)&#123; ++cur; &#125; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; if(cur &gt;= str.size())&#123; return &apos;#&apos;; &#125; return str[cur]; &#125;private: map&lt;char, int&gt;mp; string str; int cur;&#125;; 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解析转：a、第一步，找环中相汇点。分别用fast，slow指向链表头部，slow每次走一步，fast每次走二步，直到fast==slow找到在环中的相汇点。 b、第二步，找环的入口。接上步，当fast==slow时，fast所经过节点数为2x,slow所经过节点数为x,设环中有n个节点，fast比slow多走r圈有2x=rn+x; x=rn;（r为圈数，n为一圈的结点数） 可以看出slow实际走了多个环的步数，再让fast指向链表头部，slow位置不变。 假设链表开头到环接口的距离是y，那么x-y表示slow指针走过的除链表开头y在环中走过的距离，那么slow再走y步，此时fast结点与slow结点相遇，fast == slow ，x-y+y=x = rn，即此时slow指向环的入口。 代码1234567891011121314151617181920212223242526272829303132333435/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; ListNode* pFast = pHead; ListNode* pSlow = pHead; do&#123; if(pSlow &amp;&amp; pSlow-&gt;next)&#123; pSlow = pSlow-&gt;next; &#125;else&#123; return NULL; &#125; if(pFast &amp;&amp; pFast-&gt;next &amp;&amp; pFast-&gt;next-&gt;next)&#123; pFast = pFast-&gt;next-&gt;next; &#125;else&#123; return NULL; &#125; &#125;while(pFast != pSlow); pFast = pHead; while(pFast != pSlow)&#123; pFast = pFast-&gt;next; pSlow = pSlow-&gt;next; &#125; return pSlow; &#125;&#125;; 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 解析不多说了，因为是排序的链表。 代码12345678910111213141516171819202122232425262728293031323334353637/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (pHead == NULL) &#123; return NULL; &#125; ListNode* preNode = NULL; ListNode* node = pHead; while (node != NULL) &#123; if (node-&gt;next != NULL &amp;&amp; node-&gt;val == node-&gt;next-&gt;val) &#123; int value = node-&gt;val; while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;val == value) &#123; node = node-&gt;next; &#125; if (preNode == NULL) &#123; pHead = node-&gt;next; &#125; else &#123; preNode-&gt;next = node-&gt;next; &#125; &#125; else &#123; preNode = node; &#125; node = node-&gt;next; &#125; return pHead; &#125;&#125;; 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解析我们可发现分成两大类：1、有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） 2、没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。 代码123456789101112131415161718192021222324252627282930313233343536/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if(pNode == NULL)&#123; return pNode; &#125; if(pNode-&gt;right)&#123; TreeLinkNode* p = pNode-&gt;right; while(p-&gt;left)&#123; p = p-&gt;left; &#125; return p; &#125; else&#123; TreeLinkNode* p = pNode-&gt;next; while(p &amp;&amp; p-&gt;right == pNode)&#123; pNode = p; p = p-&gt;next; &#125; return p; &#125; return NULL; &#125;&#125;; 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解析【分析1】首先我们需要明确一下镜像二叉树的概念，简单来说就是左子树与右子树对调。而根据树的递归定义可以，左子树和右子树的定义也是递归而言的。 【分析2】接下来我们需要明确两棵二叉树什么时候相同。显然，根结点的值相等，左右子树相同，则这两颗二叉树相同。显然，在判断两棵二叉树是否相同时也需要递归地进行判断。 【分析3】题目中并不是想让我们判断任意两棵二叉树是否相同，而是要求我们判断一棵二叉树和它的镜像二叉树是否相同。因此我们判断相同的条件不就很明显的变成了：根结点对应的值相等，原二叉树Root的左子树与其镜像二叉树Root’的右子树相同，且原二叉树Root的右子树与其镜像二叉树Root’的左子树相同。如此递归下去。直到① 如果Root和Root’均为空，则返回true；② 如果Root为空或者Root’为空，则返回false；③ 如果Root对应的值与Root’对应的值不相等，则返回false。 代码12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool check(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123; return pRoot_1-&gt;val == pRoot_2-&gt;val; &#125; bool isSymmetrical(TreeNode* pRoot) &#123; if(pRoot == NULL)&#123; return true; &#125; return dfs(pRoot-&gt;left, pRoot-&gt;right); &#125; bool dfs(TreeNode* pRoot_1, TreeNode* pRoot_2)&#123; if(pRoot_1 == NULL || pRoot_2 == NULL)&#123; if(pRoot_1 == NULL &amp;&amp; pRoot_2 == NULL)&#123; return true; &#125; return false; &#125; if(check(pRoot_1, pRoot_2))&#123; if(dfs(pRoot_1-&gt;left, pRoot_2-&gt;right))&#123; return dfs(pRoot_1-&gt;right, pRoot_2-&gt;left); &#125; &#125; return false; &#125;&#125;; 按之字形顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解析广度优先遍历。两个栈代替队列储存数据。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; stack&lt;TreeNode*&gt;que; stack&lt;TreeNode*&gt;stk; vector&lt;vector&lt;int&gt; &gt;vv; if(!pRoot)&#123; return vv; &#125; que.push(pRoot); while(!que.empty() || !stk.empty())&#123; vector&lt;int&gt;v; if(!que.empty())&#123; while(!que.empty())&#123; TreeNode* tmp = que.top(); que.pop(); v.push_back(tmp-&gt;val); if(tmp-&gt;left)&#123; stk.push(tmp-&gt;left); &#125; if(tmp-&gt;right)&#123; stk.push(tmp-&gt;right); &#125; &#125; &#125; else&#123; while(!stk.empty())&#123; TreeNode* tmp = stk.top(); stk.pop(); v.push_back(tmp-&gt;val); if(tmp-&gt;right)&#123; que.push(tmp-&gt;right); &#125; if(tmp-&gt;left)&#123; que.push(tmp-&gt;left); &#125; &#125; &#125; vv.push_back(v); &#125; return vv; &#125;&#125;; 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解析带属性的广度优先遍历。 代码123456789101112131415161718192021222324252627282930313233343536373839404142/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; vv; vector&lt;int&gt; ve; queue&lt;TreeNode*&gt; que; queue&lt;int&gt; dque; int depth=0; que.push(pRoot); dque.push(depth); TreeNode *node; while(!que.empty())&#123; node=que.front(); if(depth!=dque.front())&#123; vv.push_back(ve); ve.clear(); depth=dque.front(); &#125; que.pop(); dque.pop(); if(node)&#123; que.push(node-&gt;left); que.push(node-&gt;right); dque.push(depth+1); dque.push(depth+1); ve.push_back(node-&gt;val); &#125; &#125; return vv; &#125;&#125;; 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解析 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。 序列化可以基于 先序、中序、后序、按层 的二叉树遍历方式来进行修改。原理都是一样的（即遍历顺序不同而已，对每个结点的处理都是一样的），序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 这里以先序遍历的方式进行序列化举例： 先序序列化二叉树==定义一个stringbuilder保存序列过程中的结果：按照先序遍历方式遍历二叉树，若结点非空则把 “结点值!” append到builder中；若结点空则把 “#!” append到builder中；最后用builder生成字符串就是序列化结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: char* Serialize(TreeNode *root) &#123; string str; if(root)&#123; str = to_string(root-&gt;val); str = str + &quot;,&quot; + Serialize(root-&gt;left); str = str + &quot;,&quot; + Serialize(root-&gt;right); &#125;else&#123; str = &quot;#&quot;; &#125; char* ret = new char[str.size()]; strcpy(ret,str.c_str()); return ret; &#125; TreeNode* dfs(char * &amp;str) &#123; if(*str == &apos;,&apos;)&#123; ++str; &#125; if(str)&#123; TreeNode* Tree = new TreeNode(0); if(str &amp;&amp; *str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123; while(*str &gt;= &apos;0&apos; &amp;&amp; *str &lt;= &apos;9&apos;)&#123; Tree-&gt;val *= 10; Tree-&gt;val += *str - &apos;0&apos;; ++str; &#125; Tree-&gt;left = dfs(str); Tree-&gt;right = dfs(str); return Tree; &#125;else if(*str == &apos;#&apos;)&#123; ++str; return NULL; &#125; &#125; return NULL; &#125; TreeNode* Deserialize(char * str)&#123; return dfs(str); &#125;&#125;; 二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 解析搜索树按从小到大的顺序排列正好就是中序遍历； 所以按照中序遍历查找，第k个节点就是结果。 代码1234567891011121314151617181920212223242526272829303132333435363738394041/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int cnt; TreeNode* KthNode(TreeNode* pRoot, int k) &#123; cnt = 0; return dfs(pRoot, k); &#125; TreeNode* dfs(TreeNode* pRoot, int k)&#123; if(pRoot == NULL)&#123; return NULL; &#125; if(pRoot-&gt;left)&#123; TreeNode* tmp = dfs(pRoot-&gt;left, k); if(tmp)&#123; return tmp; &#125; &#125; ++cnt; if(cnt == k)&#123; return pRoot; &#125; if(pRoot-&gt;right)&#123; TreeNode* tmp = dfs(pRoot-&gt;right, k); if(tmp)&#123; return tmp; &#125; &#125; return NULL; &#125;&#125;; 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解析最大堆和最小堆结合。最大堆储存前n/2个数，最小堆储存后n/2个数。偶数个数据，那么中位数可以由大小堆堆顶的数得到，如果数据的数目是奇数，那么输出最大堆堆顶。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: void Insert(int num) &#123; if(max_que.size() == min_que.size())&#123; if(max_que.empty() || max_que.top() &gt;= num || min_que.top() &gt;= num)&#123; max_que.push(num); &#125;else&#123; max_que.push(min_que.top()); min_que.pop(); min_que.push(num); &#125; &#125;else&#123; if(max_que.top() &gt;= num)&#123; min_que.push(max_que.top()); max_que.pop(); max_que.push(num); &#125;else&#123; min_que.push(num); &#125; &#125; &#125; double GetMedian() &#123; if(max_que.size() == min_que.size())&#123; return (min_que.top() + max_que.top()) / 2.0; &#125;else&#123; return max_que.top(); &#125; &#125;private: priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;min_que; priority_queue&lt;int&gt;max_que;&#125;; 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解析我们可以用STL中的deque，以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。 数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。 第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。 但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。 代码1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size)&#123; deque&lt;int&gt;dq, vis; vector&lt;int&gt;v; for(unsigned int i = 0; i &lt; num.size(); ++i)&#123; if(!vis.empty() &amp;&amp; i - vis.front() &gt;= size)&#123; dq.pop_front(); vis.pop_front(); &#125; while(!dq.empty() &amp;&amp; dq.back() &lt;= num[i])&#123; dq.pop_back(); vis.pop_back(); &#125; dq.push_back(num[i]); vis.push_back(i); if(i &gt;= size - 1)&#123; v.push_back(dq.front()); &#125; &#125; return v; &#125;&#125;; 矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解析dfs(回溯)。创建一个状态数组对访问的字符进行标记。首先，遍历这个矩阵，如果矩阵中某字符和目标字符首字母相等，则以该字符为起点dfs深搜，否则继续遍历。一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置。 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: bool dfs(char* matrix, int x, int y, char* str, int cur, int rows, int cols)&#123; if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] == true || str[cur] != matrix[x * cols + y])&#123; return false; &#125; vis[x * cols + y] = true; if(cur &gt;= len - 1)&#123; return true; &#125; for(int i = 0; i &lt; 4; ++i)&#123; if(dfs(matrix, x + road[i][0], y + road[i][1], str, cur + 1, rows, cols) == true)&#123; return true; &#125; &#125; vis[x * cols + y] = false; return false; &#125; bool hasPath(char* matrix, int rows, int cols, char* str)&#123; if(matrix[0] == 0)&#123; return false; &#125; len = strlen(str); vis.resize(cols * rows, false); for(int i = 0; i &lt; rows; ++i)&#123; for(int j = 0; j &lt; cols; ++j)&#123; if(matrix[i* cols + j] == str[0])&#123; if(dfs(matrix, i, j, str, 0, rows, cols) == true)&#123; return true; &#125; &#125; &#125; &#125; return false; &#125;private: int len; vector&lt;bool&gt;vis; int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;&#125;; 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解析dfs(回溯)。创建一个状态数组对访问的格子进行标记，但是这里需要计算所有能够走的格子总数，实际上只需要对下一个进行访问的格子进行计算，进行从上、下、左、右四个方向进行递归，就可以计算出可以达到的格子总数了。 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: int movingCount(int threshold, int rows, int cols)&#123; vis.resize(rows * cols, false); return dfs(threshold, rows, cols, 0, 0); &#125;private: int dfs(int threshold, int rows, int cols, int x, int y)&#123; if(x &lt; 0 || y &lt; 0 || x &gt;= rows || y &gt;= cols || vis[x * cols + y] || threshold &lt; check(x) + check(y))&#123; return 0; &#125; vis[x * cols + y] = true; int ans = 1; for(int i = 0; i &lt; 4; ++i)&#123; ans += dfs(threshold, rows, cols, x + road[i][0], y + road[i][1]); &#125; return ans; &#125; int check(int num)&#123; int res = 0; while(num)&#123; res += num % 10; num /= 10; &#125; return res; &#125; vector&lt;bool&gt;vis; int road[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;&#125;;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
        <tag>树</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言实现Linux下读取指定目录下普通文件的个数]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-1%2F</url>
    <content type="text"><![CDATA[打开一个目录 DIR opendir(const char name); 参数: 目录名 返回值: 指向目录的指针 FILE* fp = fopen（） fread（buf， len， len，fp）； 读目录12345678struct dirent&#123; ino_t d_ino; // 此目录进入点的inode ff_t d_off; // 目录文件开头至此目录进入点的位移 signed short int d_reclen; // d_name 的长度, 不包含NULL 字符 unsigned char d_type; // d_name 所指的文件类型 har d_name[256]; // 文件名&#125;; d_type DT_BLK - 块设备 DT_CHR - 字符设备 DT_DIR - 目录 DT_LNK - 软连接 DT_FIFO - 管道 DT_REG - 普通文件 DT_SOCK - 套接字 DT_UNKNOWN - 未知 struct dirent readdir(DIR dirp); 参数: opendir的返回值 返回值: 目录项结构体 关闭目录 int closedir(DIR *dirp); 独立完成递归读目录中指定类型文件个数的操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/types.h&gt;int get_file_num(char* root)&#123; int total = 0; DIR* dir = NULL; // 打开目录 dir = opendir(root); // 循环从目录中读文件 char path[1024]; // 定义记录xiang指针 struct dirent* ptr = NULL; while( (ptr = readdir(dir)) != NULL)&#123; // 跳过. he .. if(strcmp(ptr-&gt;d_name, &quot;.&quot;) == 0 || strcmp(ptr-&gt;d_name, &quot;..&quot;) == 0)&#123; continue; &#125; // 判断是不是目录 if(ptr-&gt;d_type == DT_DIR)&#123; sprintf(path, &quot;%s/%s&quot;, root, ptr-&gt;d_name); // 递归读目录 total += get_file_num(path); &#125; // 如果是普通文件 if(ptr-&gt;d_type == DT_REG)&#123; total ++; &#125; &#125; closedir(dir); return total;&#125;int main(int argc, char* argv[])&#123; if(argc &lt; 2)&#123; printf(&quot;./a.out path&quot;); exit(1); &#125; int total = get_file_num(argv[1]); printf(&quot;%s has regfile number: %d\n&quot;, argv[1], total); return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件和目录操作函数总结]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16%2F</url>
    <content type="text"><![CDATA[01-文件IO123#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; open/close 函数原型: int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); 参数: flags 必选项 O_RDONLY, O_WRONLY, O_RDWR 可选项 创建文件: O_CREAT 创建文件时检测文件是否存在: O_EXCL 如果文件存在, 返回-1 必须与O_CREAT一起使用 追加文件: O_APPEND 文件截断: O_TRUNC 设置非阻塞: O_NONBLOCK mode – 指定0777 八进制数 最终权限: mode &amp; ~umaks umask 0002 000000010 ~ 111111101 111111111 &amp; 111111101 775 read 函数原型: ssize_t read(int fd, void *buf, size_t count); 参数: fd – open的返回值 buf - 缓冲区, 存放读取的数据 count – 缓冲区的最大容量 sizeof(buf) 返回值: -1: 失败 >0: 读出的字节数 =0: 文件读完了 write 函数原型: ssize_t write(int fd, const void *buf, size_t count); 参数: fd: 文件描述符, open 返回值 buf: 要往文件中写的数据 count: 有效数据的长度 返回值: -1: 失败 >0: 写入的字节数 lseek 函数原型: off_t lseek(int fd, off_t offset, int whence); SEEK_SET SEEK_CUR SEEK_END 使用: 文件指针移动到头部: lseek(fd, 0, SEEK_SET); 获取文件指针当前的位置: int len = lseek(fd, 0, SEEK_CUR); 获取文件长度: int len = lseek(fd, 0, SEEK_END); 文件拓展 文件原大小100k， 拓展为1100k lseek(fd, 1000, SEE_END); 最后做一次写操作write(fd, “a”, 1); 阻塞和非阻塞 阻塞和非阻塞是文件的属性还是read函数的属性? 文件的属性 普通文件：hello.c 默认不阻塞 终端设备：/dev/tty 默认阻塞 管道 套接字 02-stat/lstat函数获取文件属性123#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt; st_mode – 16位整数 0-2 bit – 其他人权限 S_IROTH 00004 读权限 S_IWOTH 00002 写权限 S_IXOTH 00001 执行权限 S_IRWXO 00007 掩码, 过滤 st_mode中除其他人权限以外的信息 3-5 bit – 所属组权限 S_IRGRP 00040 读权限 S_IWGRP 00020 写权限 S_IXGRP 00010 执行权限 S_IRWXG 00070 掩码, 过滤 st_mode中除所属组权限以外的信息 6-8 bit – 文件所有者权限 S_IRUSR 00400 读权限 S_IWUSR 00200 写权限 S_IXUSR 00100 执行权限 S_IRWXU 00700 掩码, 过滤 st_mode中除文件所有者权限以外的信息 12-15 bit – 文件类型 S_IFSOCK 0140000 套接字 S_IFLNK 0120000 符号链接（软链接） S_IFREG 0100000 普通文件 S_IFBLK 0060000 块设备 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符设备 S_IFIFO 0010000 管道 S_IFMT 0170000 掩码,过滤 st_mode中除文件类型以外的信息(st_mode &amp; S_IFMT) == S_IFREG int stat(const char path, struct stat buf); int lstat(const char path, struct stat buf); lstat读取的链接文件本身的属性 stat读取的是连接文件指向的文件的属性 追踪，穿透 03-文件属性函数测试当前用户指定文件是否具有某种属性 当前用户, 使用哪个用户调用这个函数, 这个用户就是当前用户 int access(const char *pathname, int mode); 参数: pathname: 文件名 mode: 4种权限 R_OK – 读 W_OK – 写 X_OK – 执行 F_OK – 文件是否存在 返回值: 0 - 有某种权限, 或者文件存在 1 - 没有, 或文件不存在 修改文件权限 int chmod(const char *filename, int mode); 参数: filename: 文件名 mode: 文件权限, 八进制数 修改文件所有者和所属组 int chown(const char *path, uid_t owner, gid_t group); 函数参数: path – 文件路径 owner – 整形值, 用户ID /etc/passwd group – ….., 组ID /etc/group 修改文件大小 int truncate(const char *path, off_t length); 参数: path – 文件名 length – 文件的最终大小 \1. 比原来小, 删掉后边的部分 \2. 比原来大, 向后拓展 04-目录操作相关函数 文件重命名 int rename(const char oldpath, const char newpath); 修改当前进程(应用程序)的路径 cd int chdir(const char *path); 参数: 切换的路径 获取当前进程的工作目录 pwd char getcwd(char buf, size_t size); 返回值: 成功: 当前的工作目录 失败: NULL 参数: buf: 缓冲区, 存储当前的工作目录 size: 缓冲区大小 创建目录 mkdir int mkdir(const char *pathname, mode_t mode); 参数: pathname: 创建的目录名 mode: 目录权限, 八进制的数, 实际权限: mode &amp; ~umask 删除一个空目录 int rmdir(const char *pathname); 参数: 空目录的名字 05-目录遍历相关函数 打开一个目录 DIR opendir(const char name); 参数: 目录名 返回值: 指向目录的指针 FILE* fp = fopen（） fread（buf， len， len，fp）； 读目录12345678struct dirent&#123; ino_t d_ino; // 此目录进入点的inode ff_t d_off; // 目录文件开头至此目录进入点的位移 signed short int d_reclen; // d_name 的长度, 不包含NULL 字符 unsigned char d_type; // d_name 所指的文件类型 har d_name[256]; // 文件名&#125;; d_type DT_BLK - 块设备 DT_CHR - 字符设备 DT_DIR - 目录 DT_LNK - 软连接 DT_FIFO - 管道 DT_REG - 普通文件 DT_SOCK - 套接字 DT_UNKNOWN - 未知 struct dirent readdir(DIR dirp); 参数: opendir的返回值 返回值: 目录项结构体 关闭目录 int closedir(DIR *dirp); 独立完成递归读目录中指定类型文件个数的操作. 06-dup-dup2-fcntl 复制文件描述符 int dup(int oldfd); oldfd - 要复制的文件描述符 返回值: 新的文件描述符 dup调用成功: 有两个文件描述符指向同一个文件 返回值: 取最小的且没被占用的文件描述符 int dup2(int oldfd, int newfd); oldfd -》hello newfd -》world 假设newfd已经指向了一个文件，首先断开close与那个文件的链接，newfd指向oldfd指向的文件 文件描述符重定向 oldfd和newfd指向同一个文件 newfd没有被占用，newfd指向oldfd指向的文件 改变已经打开的文件的属性: fcntl 变参函数 复制一个已有的文件描述符 1int ret = fcntl(fd, F_DUPFD); 获取/设置文件状态标志 open 的flags参数 获取文件状态标识 1int flag = fcntl(fd, F_GETFL) 设置文件状态标识 flag = flag | O_APPEND; fcntl(fd, F_SETFL, flag) 可以更改的几个标识: O_APPEND、O_NONBLOCK （常用）]]></content>
      <categories>
        <category>程序人生</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春招面经（2019.3.15日起）]]></title>
    <url>%2F2019%2F03%2F15%2F2019-03-15%2F</url>
    <content type="text"><![CDATA[3.15腾讯提前批一面第一次电话面试，而且是腾讯的，真的感觉特别紧张。虽然面试官小哥哥人特别好，一直在缓解气氛，但总体还是感觉状态不是很好。不管结果怎么样，先记录下这次所涉及到的知识点吧。 自我介绍：有点紧张，把大概经历说了一下。 为什么投腾讯，以及企业文化：谈到了百度狼性文化，其实之前看过一些相关的企业文化，但没有太深入取看。整体感觉有点不好。 问题1：C++和Python有什么区别?各有什么特点。答：有点记不太清楚怎么回答的了。总之答得很不专业。 总结：程序有两种执行方式，解释执行和编译执行。PYTHON是一种脚本语言，是解释执行的，不需要经过编译，所以很方便快捷，且能够很好地跨平台，写一些小工具小程序特别合适。而C++则是一种需要编译后运行语言，在特定的机器上编译后在特定的机上运行，运行效率高，安全稳定。但编译后的程序一般是不跨平台的。 学习一种编程语言不能看它热不热。而是要看它在某个领域的作用。就像汇编，虽然现在不热了，但是它在某些行业内还是很吃香的。PYTHON确实很强大，但在三五年内，不会作为一种主流的编程语言。至少在Windows程序开发领域内不会。 A、解释程序所谓解释程序是高级语言翻译程序的一种，它将源语言(如BASIC)书写的源程序作为输入，解释一句后就提交计算机执行一句，并不形成目标程序。就像外语翻译中的“口译”一样，说一句翻一句，不产生全文的翻译文本。这种工作方式非常适合于人通过终端设备与计算机会话，如在终端上打一条命令或语句，解释程序就立即将此语句解释成一条或几条指令并提交硬件立即执行且将执行结果反映到终端，从终端把命令打入后，就能立即得到计算结果。这的确是很方便的，很适合于一些小型机的计算问题。但解释程序执行速度很慢，例如源程序中出现循环，则解释程序也重复地解释并提交执行这一组语句，这就造成很大浪费。B、编译程序这是一类很重要的语言处理程序，它把高级语言(如FORTRAN、COBOL、Pascal、C等)源程序作为输入，进行翻译转换，产生出机器语言的目标程序，然后再让计算机去执行这个目标程序，得到计算结果。编译程序工作时，先分析，后综合，从而得到目标程序。所谓分析，是指词法分析和语法分析；所谓综合是指代码优化，存储分配和代码生成。为了完成这些分析综合任务，编译程序采用对源程序进行多次扫描的办法，每次扫描集中完成一项或几项任务，也有一项任务分散到几次扫描去完成的。下面举一个四遍扫描的例子：第一遍扫描做词法分析；第二遍扫描做语法分析；第三遍扫描做代码优化和存储分配；第四遍扫描做代码生成。值得一提的是，大多数的编译程序直接产生机器语言的目标代码，形成可执行的目标文件，但也有的编译程序则先产生汇编语言一级的符号代码文件，然后再调用汇编程序进行翻译加工处理，最后产生可执行的机器语言目标文件。在实际应用中，对于需要经常使用的有大量计算的大型题目，采用招待速度较快的编译型的高级语言较好，虽然编译过程本身较为复杂，但一旦形成目标文件，以后可多次使用。相反，对于小型题目或计算简单不太费机时的题目，则多选用解释型的会话式高级语言，如BASIC，这样可以大大缩短编程及调试的时 简短概述解释执行:由解释器根据输入的数据当场执行而不生成任何的目标程序编译执行: 先将源代码编译成目标语言(如:机器语言)之后通过连接程序连接到生成的目标程序进行执行 问题2：网络传输 层的协议，概述UDP与TCP。答：举了电话通话与邮件发送的例子，由于紧张有些语无伦次。 总结：1.TCP面向连接（如打电话前需拨号确认连接）；UDP是无连接的（发送数据前不需要建立连接）2.TCP提供可靠服务（数据无差错，不流失，不重复，有重传机制，且按序到达）；UDP尽力最大交付（不保证可靠，无重传机制，无序）3.TCP面向字节流（把数据看成一连串无结构的字符流，每次取多少由主机决定）；UDP面向报文（发送多少接收多少）4.TCP无界（通过字节流传输，字节流太长会拆分，太短会等待，接收方确认才会删除缓冲区；如服务器缓冲区足够大，则多次传输一次接收，被认为无界）； UDP有界（不拆分不合并，几次传输几次接收，被认为有界）5.TCP有流量控制和拥塞控制（接收方让发送方的速度调节）；UDP没有流量控制（不会改变） 6.TCP的头部（20bytes）比UDP大 问题3：UDP与TCP协议应用举例答：举了IP电话与在线传输文件的例子，感觉答得不是很好。 总结：什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率 项目相关：问到是否做过web项目，谈到了项目，其实之前跟着网课做过一些小项目，但自我感觉不是什么大项目，就没敢说。后来说了一些爬虫时的经历，以及自己搭建的博客。 问题4：git相关命令答：好久没用过git，许多命令其实忘得差不多了。 总结： ACM比赛相关：一些比赛经历以及有什么帮助。 问题5：快排与堆排答：数据结构部分还是比较擅长的，虽然优化部分由于紧张有点记不太清楚了。 总结：快速排序使用了分治法的策略。它的基本思想是，选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。可以看出，快速排序很重要的一点就是对基准数的选择。影响快速排序性能的因素除了本身数组的有序程度，还和这个基准数有关。在下面的代码中，我们使用最经典的，选择数组的第一个数作为基准数。 快速排序流程如下： (1)从数列中挑出一个基准值。 (2)将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。 (3)递归地把”基准值前面的子数列”和”基准值后面的子数列”进行排序。 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 学习情况：浏览CSDN博客，看网课，看书。 3.18作业帮笔试作业帮笔试问题11~2048有多少个1。 解法：千位上为1共有1000个（1000~1999） 百位上为1共有2 * 100 = 200个（100~199， 1100~1199） 十位上为1共有21 * 10 = 210个（XX10~XX19，XX∈[0，20]） 个位上为1共有205个（不多说了，自行脑补） 一共有1000+200+210+205 = 1615个 问题2给出树的前序与中序遍历，求后序。 解法：不多说了，不会的话自行面壁。 问题3死锁产生的条件。 解法：互斥条件，请求与保持条件，不可抢夺条件，循环等待条件。 问题40，2，3，5，9，17，31，57，___ 解法：105（17+31+57） 问题52019！末尾有多少个0 解法：重点在于质因数的运用，要点如下 1、基本的一点，25=10，得到1个0 可以写成2^15^1=10^1 2、进一步，425=100，得到2个0 可以写成2^25^2=10^2 3、进一步，8125=1000，得到3个0 可以写成2^35^3=10^3 4、进一步，16625=10000，得到4个0 可以写成2^45^4=10^4 5、5^5=3125超过2015了，所以5次方以上不考虑 6、不要担心双数的个数不够用，它会多出很多 7、有了上面的1到4条，就可以计算了 (运算符表示乘法，^表示乘方) 第一步，计算1到2015里多少个5,25,125,625 1、2015÷5=403 记作A1； 2、2015÷25=80.6取整得80 记作A2； 3、2015÷125=16.12取整得16 记作A3； 4、2015÷625=3.224取整得3 记作A4； 第二步，计算上述A1到A4中重复的部分 1、能被5整除的数里包含的能被25整除的数，记作B1 B1=A1-A2=403-80=323； 2、能被25整除的数里包含的能被125整除的数，记作B2 B2=A2-A3=80-16=64； 3、能被125整除的数里包含的能被625整除的数，记作B3 B3=A3-A4=16-3=13； 4、能被625整除的数里没有重复其它情况，直接计入结果，记作B4 B4=A4； 第三步，最终结果是 B11+B22+B33+B44=323+128+39+12=502………(1) 【答案】502个 最终结果也可以这样算： A1+A2+A3+A4=403+80+16+3=502 ………(2） 也就是 2015÷5+2015÷25+2015÷125+2015÷625 =403+80+16+3=502 问题6给出一列数，将其中所有的0放置末尾 例如1，2，0，3，0，4，则为1，2，3，4，0，0 解法：两个指针，一个快指针，一个慢指针，如果快指针指向的数不为0，则快指针的值赋给慢指针，快指针慢指针均前进一步，否则快指针前进一步，慢指针不动。最后快指针指向尾了，如果慢指针没指向尾，之后的值全部为0。 问题7判断字符串是否为合法密码（长度大于8，含三类不同字符，且长度大于2的子串不能出现相同情况，例如A1abcdabc不合法，abc出现两次） 解法：前两点太简单就不说了，第3点可以使用set每一次储存3个连续的字符，如果重复就不是合法的字符。 问题85张牌斗牛，其中三张牌之和取余为0即为牛，剩余两张牌之和取余为几结果即为牛几。 解法：5张牌只取个位数，然map记录下来，5张牌相加取余，然后依次减去其中一张牌，看得到的数字在map里存不存在，如果存在就说明有牛，牛就是5张牌相加的结果。也就是5张只和减两张看是不是0。相当于一层循环 ，On时间复杂度 3.19腾讯提前批二面腾讯二面面试官好像是个技术总监，声音特别小，听的不是很清楚。总之10分钟结束，什么问题也没问，只留下一句之后等结果。然后就挂了，挂的莫名其妙。总结一下教训： 自我介绍尽量2分钟左右。要提到很高兴参加贵公司的面试。结尾尽量要客气。 项目情况千万不要说项目少，小项目也可以提及，不然对方真以为自己没项目了。（惨痛的教训） 比赛情况其实敲代码没什么不好的，我们实习生本来就是应该干底层的（qyq） 岗位期望后台研发，我期望做……当然具体还是听从部门的安排，如果部门安排我做哪一块那我会听从部门的安排，然后尽快学习相关技能，尽快融入其中。 实习计划1.首先尽快了解企业文化，了解部门规章制度，以便争取未来尽快融入。 2.了解所在团队的成员情况，分工，自己的角色和职责，以便更好的配合。 3.了解岗前应会的内容，及团队当前的主要工作及进展。 4.拟定工作计划，经组长审阅后按照计划推进。 5.自己会不断学习，积极寻求同事和领导的帮助。以达成更好的业绩。 兴趣爱好切忌书生气，不能高谈阔论，一副兴趣广泛的样子。尽量要和职业贴近，否则就不要说的太多。 然后面试结束，没问任何专业相关问题，GG。 3.20阿里一面阿里首面问题1C++指针与引用的区别及内存情况 思路：问题2智能指针问题 思路：问题3hash_map与map的区别，底层构造，时间复杂度，选择 思路：问题4手写代码树的中序遍历 思路：问题5vector的机制 思路：问题6堆排序原理 思路：问题7集合中，输出所有子集。 思路：问题8红墨水蓝墨水问题 思路：一样多。 问题9智能指针 现状及项目问题10预处理以及#ifdef 思路：选择性编译 问题11awk命令 思路：3.22西科具体不多说了，培训班一样。 3.25旷世笔试3.26虎牙笔试3.27西山居笔试3.28西山居一面 类内const如何初始化 代码规范化问题，以及析构函数与构造函数调用问题 1、C++中, 构造函数和析构函数可以被显示调用. 显示调用默认构造函数的语法: a.A::A();(不能写成a.A();) , 显示调用非默认构造函数的语法: a.A::A(7);(不能写成a.A(7);); 显示调用析构函数的语法: a.A::~A();(可以写成a.~A();) . 2、显示调用构造函数和析构函数就像调用一般的函数一样, 并不意味着创建或销毁对象; 3、如果构造函数中动态分配了空间, 则显示调用构造函数会造成内存泄露. 创建对象时的隐式构造函数调用已经为对象分配了动态内存，当用创建好的对象显示调用构造函数时, 对象指向的动态内存更新为显示调用时所分配的, 对象生命周期结束时析构函数所释放掉的是后一次分配的动态内存, 也就是说创建对象时隐式构造函数调用所分配的那块内存泄漏了. 4、如果析构函数中释放动态分配的空间, 则会造成多次释放同一内存, 会出现严重错误. 三子棋问题 C++虚函数及底层实现 虚函数表 容器及各自底层实现 结构体对齐 C++11特性 内联函数与宏定义 连连看寻路问题 双属性排序问题 字符串最大值问题 找bug，野指针问题 研发岗难度在哪方面（哪些方向） 3.29西山居二三四面二面项目 三面笔试题 智能指针 四面项目 比赛担当角色 虚函数表 模板 Dijkstra算法分析 Linux下两个pthread如何实现同步 socket编程IO多路复用 如何看待自己的组织能力 上岗时间 4.1东方财富一面使用过哪些API 知道哪些设计模式 单例设计模式讲解 101个数(0, 100]，只有一个数出现两次，找出这个数。 4.4声网一面4.5腾讯笔试4.9声网二面项目 聊天室项目 找中位数 第k大数 矩阵n次方 4.12阿里二面多态 调试 服务器正在运行程序如何调试 vector的reserve与resize区别 链表交叉结点 找中位数 n个硬盘每个损坏概率p，且m个硬盘坏掉概率——(p^m)*((1-p)^(n-m)) 4.14腾讯正式批一面爬虫项目介绍 如何反爬（不知道） 智能指针概述 遇到异常处理如何解决内存释放问题 如何处理未知异常（不知道） 仿函数（不知道） 用过stl哪些算法 A*搜索 Linux相关命令 如何判断某目录下某文件是否存在（find –name） 如何计算某目录下文件个数（C语言实现readdir） 多进程多线程相关 进程间通信方式 详细概述epoll read返回值（返回值为长度。为0断开连接，-1为异常） 边沿触发（阻塞，非阻塞） 数据库了解多少 4.21腾讯正式批二面操作系统部分基本没答上一个，答到最后都以为必挂了。真心感谢面试官小哥哥手下留情(^人^) 网络TCP与UDP概述 可靠的UDP协议（不知道） 四次挥手过程 timewait在第几次挥手 timewait作用 C++智能指针相关 STL容器用过哪些 vector机制 deque机制 delete数组（好久没怎么复习了） 算法集合求子集 输出数组中唯一只有一个不重复元素 操作系统分页与分段的区别（有点印象） 概述进程（经常使用，却不清楚概念QYQ） 进程调度算法（完全忘记了）]]></content>
      <categories>
        <category>心路历程</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[温习C++继承与多态之打造简易回合制5V5小游戏]]></title>
    <url>%2F2019%2F03%2F11%2F2019-03-11%2F</url>
    <content type="text"><![CDATA[曾几何时，网页游戏风靡整个网络世界，然而手机游戏的出现，如今的网页游戏已经渐渐销声匿迹了。 还记得我玩的第一款时间较长的网页游戏——龙将，如今服务器已关闭了，包括代理商“风行”如今也鲜为人知。其实那款游戏很简单，两个玩家对弈，双方每人出场5个英雄，按回合制以英雄的速度为先后顺序，每个英雄普通攻击或使用技能，直到一方的所有英雄全部死亡为止。所有攻击操作都是自动的，不需要我们操作，我们只需选择英雄上阵即可。 曾经想着什么时候能自己编一款类似的游戏，以便属性按照自己的想法设定。如今就简简单单实现一下吧。（超级粗略哦） 首先，我们来分析一下，每个英雄都有攻击属性，防御属性，速度，生命值，还有一些特殊的效果（暴击，吸血什么的啦），英雄可以装备武器，可以对敌方英雄造成伤害。那么我们先创建一个Hero类，它包含上述所有属性及方法。然后，每个英雄不同之处在于技能与被动技能，那我们利用多态来实现不同的技能。 再来分析一下武器，武器有基础属性和特殊属性，不同的武器属性不同，那么我们先创建一个基类Weapon类，该类函数声明为纯虚类，不可被继承，由派生来来实现具体功能即可。 英雄和武器写完之后，再创建一个国家类。由于英雄以国家而划分，所以每个国家由许多英雄类指针组成。 每个玩家有5个英雄，具体实现同国家类。 图示如下 由于本人比较懒，写着写着又犯懒了，所以技能方面还没实现，每次都是普通攻击触发各种效果。不过目前可以正常运行。等哪天有时间了再继续改进吧。以下是代码： Weapon.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#pragma once#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//抽象类class Weapon &#123;public: //获取基础伤害 virtual int getBaceDamage() = 0; //获取防御 virtual int getBaceDef() = 0; //获取吸血 virtual bool getSuckBlood() = 0; //获取流血 virtual bool getHold() = 0; static bool isTrigger(int rate); string m_WeaponName; //武器名 int m_BaceDamage; //基础伤害 int BaceDef; //基础防御&#125;;class Knife :public Weapon &#123;public: Knife(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold(); int holdRate;&#125;;class DragonSword :public Weapon &#123;public: DragonSword(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold(); int holdRate;&#125;;class Sword :public Weapon &#123;public: Sword(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold(); int suckRate; int holdRate;&#125;;class Shield :public Weapon &#123;public: Shield(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold();&#125;;class Spear :public Weapon &#123;public: Spear(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold(); int suckRate;&#125;;class Bow :public Weapon &#123;public: Bow(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold();&#125;;class Book :public Weapon &#123;public: Book(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold(); int suckRate;&#125;;class Fan :public Weapon &#123;public: Fan(); //获取基础伤害 virtual int getBaceDamage(); //获取防御 virtual int getBaceDef(); //获取吸血 virtual bool getSuckBlood(); //获取流血 virtual bool getHold(); int holdRate; int suckRate;&#125;; Weapon.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#include &quot;Weapon.h&quot;Knife::Knife()&#123; this-&gt;m_BaceDamage = 10; this-&gt;BaceDef = 0; this-&gt;holdRate = 30; this-&gt;m_WeaponName = &quot;锋利匕首&quot;;&#125;int Knife::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Knife::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Knife::getSuckBlood()&#123; return false;&#125;bool Knife::getHold()&#123; return isTrigger(this-&gt;holdRate);&#125;DragonSword::DragonSword()&#123; this-&gt;m_BaceDamage = 20; this-&gt;m_WeaponName = &quot;屠龙宝刀&quot;; this-&gt;BaceDef = 10; this-&gt;holdRate = 20;&#125;int DragonSword::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int DragonSword::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool DragonSword::getSuckBlood()&#123; return false;&#125;bool DragonSword::getHold()&#123; return isTrigger(this-&gt;holdRate);&#125;bool Weapon::isTrigger(int rate)&#123; if (rate &gt;= rand() % 100 + 1) &#123; return true; &#125; return false;&#125;Sword::Sword()&#123; this-&gt;m_BaceDamage = 20; this-&gt;m_WeaponName = &quot;倚天神剑&quot;; this-&gt;BaceDef = 10; this-&gt;suckRate = 10; this-&gt;holdRate = 10;&#125;int Sword::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Sword::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Sword::getSuckBlood()&#123; return isTrigger(this-&gt;suckRate);&#125;bool Sword::getHold()&#123; return isTrigger(this-&gt;holdRate);&#125;Shield::Shield()&#123; this-&gt;m_BaceDamage = 0; this-&gt;m_WeaponName = &quot;刑天巨盾&quot;; this-&gt;BaceDef = 70;&#125;int Shield::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Shield::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Shield::getSuckBlood()&#123; return false;&#125;bool Shield::getHold()&#123; return false;&#125;Spear::Spear()&#123; this-&gt;m_BaceDamage = 10; this-&gt;m_WeaponName = &quot;亮银长枪&quot;; this-&gt;BaceDef =20; this-&gt;suckRate = 20;&#125;int Spear::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Spear::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Spear::getSuckBlood()&#123; return isTrigger(this-&gt;suckRate);&#125;bool Spear::getHold()&#123; return false;&#125;Bow::Bow()&#123; this-&gt;m_BaceDamage = 70; this-&gt;m_WeaponName = &quot;射日神弓&quot;; this-&gt;BaceDef = 0;&#125;int Bow::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Bow::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Bow::getSuckBlood()&#123; return false;&#125;bool Bow::getHold()&#123; return false;&#125;Book::Book()&#123; this-&gt;m_BaceDamage = 0; this-&gt;m_WeaponName = &quot;遁甲天书&quot;; this-&gt;BaceDef = 10; this-&gt;suckRate = 30;&#125;int Book::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Book::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Book::getSuckBlood()&#123; return isTrigger(this-&gt;suckRate);&#125;bool Book::getHold()&#123; return false;&#125;Fan::Fan()&#123; this-&gt;m_BaceDamage = 30; this-&gt;m_WeaponName = &quot;朱雀羽扇&quot;; this-&gt;BaceDef = 0; this-&gt;suckRate = 10; this-&gt;holdRate = 10;&#125;int Fan::getBaceDamage()&#123; return this-&gt;m_BaceDamage;&#125;int Fan::getBaceDef()&#123; return this-&gt;BaceDef;&#125;bool Fan::getSuckBlood()&#123; return isTrigger(this-&gt;suckRate);&#125;bool Fan::getHold()&#123; return isTrigger(this-&gt;holdRate);&#125; Hero.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#pragma once#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;Weapon.h&quot;using namespace std;class Hero &#123;public: Hero(); int getHP(); int getMP(); int getAtk(); int getDef(); string getName(); bool action(); void getInf(); void attack(Hero*hero); bool isRate(int rate); void init_property(); virtual void skill(Hero * hero) = 0; virtual void passive_skill() = 0; bool isDeath; //是否死亡 Weapon*weapon;protected: int max_HP; int HP; //血量 int MP; //蓝量 int atk; //攻击力 int def; //防御力 int vel; //速度 string name; //姓名 string ctry; //国家 int id; //编号 string sex; //性别 string skill_show; string skill_name; int wisdom; //智慧 int strategy; //谋略 int force; //力量 int agility; //敏捷 int crit; //暴击 int stun; //重击 int suckBlood; //回血 int miss; //闪避 bool isDiz; //眩晕 bool isBleed; //流血&#125;; Hero.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&quot;hero.h&quot;#include &quot;Monster.h&quot;Hero::Hero()&#123; this-&gt;m_HP = 500; this-&gt;m_Atk = 50; this-&gt;m_Def = 50; this-&gt;m_Name = &quot;靓仔&quot;; this-&gt;weapon = NULL;&#125;void Hero::EquipWeapon(Weapon * weapon)&#123; this-&gt;weapon = weapon; cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;装备了&quot; &lt;&lt; this-&gt;weapon-&gt;m_WeaponName &lt;&lt; endl;&#125;void Hero::Attack(Monster * monster)&#123; int damage = 0; int addHP = 0; bool isHold = false; bool isCrit = false; if (this-&gt;weapon == NULL) &#123; damage = this-&gt;m_Atk; &#125; else &#123; damage = this-&gt;m_Atk + this-&gt;weapon-&gt;getBaceDamage(); addHP = this-&gt;weapon-&gt;getSuckBlood(); isHold = this-&gt;weapon-&gt;getHold(); isCrit = this-&gt;weapon-&gt;getCrit(); if (addHP) &#123; cout &lt;&lt; &quot;英雄触发吸血效果，回血&quot; &lt;&lt; addHP &lt;&lt; endl; &#125; if (isCrit) &#123; damage *= 2; cout &lt;&lt; &quot;英雄触发暴击效果，怪兽受到双倍伤害&quot; &lt;&lt; endl; &#125; if (isHold) &#123; monster-&gt;m_Hold = isHold; cout &lt;&lt; &quot;英雄触发定身效果，怪兽停止行动一回合&quot; &lt;&lt; endl; &#125; &#125; damage = damage &gt; monster-&gt;m_Def ? damage - monster-&gt;m_Def : 1; monster-&gt;m_HP -= damage; this-&gt;m_HP += addHP; cout &lt;&lt; &quot;英雄&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;对怪兽&quot; &lt;&lt; monster-&gt;m_Name &lt;&lt; &quot;造成了&quot; &lt;&lt; damage &lt;&lt; &quot;点伤害。&quot; &lt;&lt; endl;&#125; Country.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#pragma once#include&quot;Hero.h&quot;#include&quot;Wei.h&quot;#include&quot;Shu.h&quot;#include&quot;Wu.h&quot;#include&quot;Qun.h&quot;#define NUM_HERO 12class Wei&#123;public: Wei() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; wei[i]-&gt;getInf(); &#125; &#125; &#125; ~Wei() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; delete wei[i]; &#125; &#125; &#125; Hero*wei[NUM_HERO] = &#123; new(CaoCao), new(DianWei), new(XuChu), new(GuoJia), new(XiaHouDun), new(XiaHouYuan), new(CaoRen), new(ZhangLiao), new(SiMaYi), new(XuHuang), new(ZhenJi), new(CaiWenJi) &#125;; int vis[NUM_HERO] = &#123; false &#125;;&#125;;class Shu&#123;public: Shu() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; shu[i]-&gt;getInf(); &#125; &#125; &#125; ~Shu() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; delete shu[i]; &#125; &#125; &#125; Hero*shu[NUM_HERO] = &#123; new(LiuBei), new(GuanYu), new(ZhangFei), new(ZhuGeLiang), new(ZhaoYun), new(MaChao), new(HuangZhong), new(WeiYan), new(HuangYueYing), new(JiangWei), new(PangTong), new(SunShangXiang) &#125;; int vis[NUM_HERO] = &#123;false&#125;;&#125;;class Wu&#123;public: Wu() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; wu[i]-&gt;getInf(); &#125; &#125; &#125; ~Wu() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; delete wu[i]; &#125; &#125; &#125; Hero*wu[NUM_HERO] = &#123; new(SunCe), new(ZhouYu), new(SunQuan), new(DaQiao), new(XiaoQiao), new(HuangGai), new(TaiShiCi), new(GanNing), new(LuSu), new(LvMeng), new(ZhangZhao), new(ZhouTai) &#125;; int vis[NUM_HERO] = &#123; false &#125;;&#125;;class Qun &#123;public: Qun() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; qun[i]-&gt;getInf(); &#125; &#125; &#125; ~Qun() &#123; for (int i = 0; i &lt; NUM_HERO; i++) &#123; if (!vis[i]) &#123; delete qun[i]; &#125; &#125; &#125; Hero*qun[NUM_HERO] = &#123; new(LvBu), new(DiaoChan), new(HuaTuo), new(YuanShao), new(YanLiang), new(WenChou), new(ZuoCi), new(HuaXiong), new(GongSunZan), new(ZhangJiao), new(YuJi), new(LingJu) &#125;; int vis[NUM_HERO] = &#123; false &#125;;&#125;; User.h 123456#pragma once#include&quot;Country.h&quot;class User &#123;public: Hero * hero[5];&#125;; main.cpp 123456#include&quot;Play.h&quot;int main() &#123; play(); system(&quot;pause&quot;); return 0;&#125; Play.h 12345678#pragma once#include&lt;iostream&gt;#include&quot;Country.h&quot;#include&quot;User.h&quot;void test();void play();void show(User &amp;user);bool isDeath(User &amp; user); Play.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&quot;Play.h&quot;#include&lt;time.h&gt;void test() &#123; Hero * hero_1 = new(ZhangFei); Hero *hero_2 = new(GuanYu); int round = 0; while (true) &#123; getchar(); system(&quot;cls&quot;); cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl; hero_1-&gt;attack(hero_2); if (hero_2-&gt;getHP() &lt;= 0) &#123; cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你赢了&quot; &lt;&lt; endl; break; &#125; hero_2-&gt;attack(hero_1); if (hero_1-&gt;getHP() &lt;= 0) &#123; cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;已死，游戏结束，你输了&quot; &lt;&lt; endl; break; &#125; cout &lt;&lt; &quot;英雄&quot; &lt;&lt; hero_1-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_1-&gt;getHP() &lt;&lt; endl; cout &lt;&lt; &quot;怪兽&quot; &lt;&lt; hero_2-&gt;getName() &lt;&lt; &quot;剩余血量：&quot; &lt;&lt; hero_2-&gt;getHP() &lt;&lt; endl; &#125; delete(hero_1); delete(hero_2);&#125;void play() &#123; srand(time(NULL)); User user_1; cout &lt;&lt; &quot;玩家一选择&quot; &lt;&lt; endl; show(user_1); User user_2; cout &lt;&lt; &quot;玩家二选择&quot; &lt;&lt; endl; show(user_2); int round = 0; while (true) &#123; getchar(); system(&quot;cls&quot;); cout &lt;&lt; &quot;当前第&quot; &lt;&lt; ++round &lt;&lt; &quot;回合开始&quot; &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; if (!user_1.hero[i]-&gt;isDeath) &#123; int Tmp = rand() % 5; while (user_2.hero[Tmp]-&gt;isDeath) &#123; if (isDeath(user_2)) &#123; break; &#125; Tmp = rand() % 5; &#125; user_1.hero[i]-&gt;attack(user_2.hero[Tmp]); &#125; else &#123; cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl; if (!user_2.hero[i]-&gt;isDeath) &#123; int Tmp = rand() % 5; while (user_1.hero[Tmp]-&gt;isDeath) &#123; if (isDeath(user_1)) &#123; break; &#125; Tmp = rand() % 5; &#125; user_2.hero[i]-&gt;attack(user_1.hero[Tmp]); &#125; else &#123; cout &lt;&lt; &quot;英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;**********&quot; &lt;&lt; endl; &#125; if (isDeath(user_2)) &#123; cout &lt;&lt; &quot;Victory！&quot; &lt;&lt; endl; break; &#125; if (isDeath(user_1)) &#123; cout &lt;&lt; &quot;Defeat！&quot; &lt;&lt; endl; break; &#125; cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; if (!user_1.hero[i]-&gt;isDeath) &#123; cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_1.hero[i]-&gt;getHP() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;玩家1英雄&quot; &lt;&lt; user_1.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl; &#125; &#125; cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; if (!user_2.hero[i]-&gt;isDeath) &#123; cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;剩余血量&quot; &lt;&lt; user_2.hero[i]-&gt;getHP() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;玩家2英雄&quot; &lt;&lt; user_2.hero[i]-&gt;getName() &lt;&lt; &quot;已阵亡。&quot; &lt;&lt; endl; &#125; &#125; &#125;&#125;bool isDeath(User &amp; user) &#123; int cnt; for (cnt = 0; cnt &lt; 5; cnt++) &#123; if (!user.hero[cnt]-&gt;isDeath) &#123; break; &#125; &#125; if (cnt &gt;= 5) &#123; return true; &#125; return false;&#125;void show(User &amp;user)&#123; int flag; cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;请选择您的阵营&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;---&quot; &lt;&lt; &quot;1.魏----2.蜀----3.吴----4.群&quot; &lt;&lt; &quot;---&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;----------&quot; &lt;&lt; &quot;--------------&quot; &lt;&lt; &quot;----------&quot; &lt;&lt; endl; cin &gt;&gt; flag; int tmp[5]; Wei *wei; Shu *shu; Wu *wu; Qun *qun; switch (flag) &#123; case 1: cout &lt;&lt; &quot;您已加入魏国阵营，请选择5位武将&quot; &lt;&lt; endl; wei = new Wei; for (int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; tmp[i]; user.hero[i] = wei-&gt;wei[tmp[i]-1]; wei-&gt;vis[tmp[i]-1] = true; &#125; delete wei; break; case 2: cout &lt;&lt; &quot;您已加入蜀国阵营，请选择5位武将&quot; &lt;&lt; endl; shu = new Shu; for (int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; tmp[i]; user.hero[i] = shu-&gt;shu[tmp[i]-1]; shu-&gt;vis[tmp[i]-1] = true; &#125; delete shu; break; case 3: cout &lt;&lt; &quot;您已加入吴国阵营，请选择5位武将&quot; &lt;&lt; endl; wu = new Wu; for (int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; tmp[i]; user.hero[i] = wu-&gt;wu[tmp[i]-1]; wu-&gt;vis[tmp[i]-1] = true; &#125; delete wu; break; default: cout &lt;&lt; &quot;您已加入群雄阵营，请选择5位武将&quot; &lt;&lt; endl; qun = new Qun; for (int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; tmp[i]; user.hero[i] = qun-&gt;qun[tmp[i]-1]; qun-&gt;vis[tmp[i]-1] = true; &#125; delete qun; break; &#125;&#125; Wei.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma once#include&quot;Hero.h&quot;class CaoCao : public Hero &#123;public: CaoCao(); void skill(Hero * hero); void passive_skill();&#125;;class DianWei :public Hero &#123;public: DianWei(); void skill(Hero * hero); void passive_skill();&#125;;class XuChu : public Hero &#123;public: XuChu(); void skill(Hero * hero); void passive_skill();&#125;;class GuoJia : public Hero &#123;public: GuoJia(); void skill(Hero * hero); void passive_skill();&#125;;class XiaHouDun : public Hero &#123;public: XiaHouDun(); void skill(Hero * hero); void passive_skill();&#125;;class XiaHouYuan : public Hero &#123;public: XiaHouYuan(); void skill(Hero * hero); void passive_skill();&#125;;class CaoRen : public Hero &#123;public: CaoRen(); void skill(Hero * hero); void passive_skill();&#125;;class ZhangLiao : public Hero &#123;public: ZhangLiao(); void skill(Hero * hero); void passive_skill();&#125;;class SiMaYi : public Hero &#123;public: SiMaYi(); void skill(Hero * hero); void passive_skill();&#125;;class XuHuang : public Hero &#123;public: XuHuang(); void skill(Hero * hero); void passive_skill();&#125;;class ZhenJi : public Hero &#123;public: ZhenJi(); void skill(Hero * hero); void passive_skill();&#125;;class CaiWenJi : public Hero &#123;public: CaiWenJi(); void skill(Hero * hero); void passive_skill();&#125;; Wei.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359#include &quot;Wei.h&quot;CaoCao::CaoCao()&#123; name = &quot;曹操&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 1; //编号 wisdom = 90; //智慧 strategy = 92; //谋略 force = 55; //力量 agility = 28; //敏捷 skill_name = &quot;天下归心&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Sword;&#125;void CaoCao::skill(Hero * hero)&#123;&#125;void CaoCao::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;atk += this-&gt;force;&#125;DianWei::DianWei()&#123; name = &quot;典韦&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 2; //编号 wisdom = 54; //智慧 strategy = 32; //谋略 force = 100; //力量 agility = 80; //敏捷 skill_name = &quot;古之恶来&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void DianWei::skill(Hero * hero)&#123;&#125;void DianWei::passive_skill()&#123; this-&gt;HP = ceil(this-&gt;HP*1.4); this-&gt;max_HP = this-&gt;HP; this-&gt;def += floor(this-&gt;force*0.7); this-&gt;atk = ceil(this-&gt;atk * 0.9); this-&gt;suckBlood += 10;&#125;XuChu::XuChu()&#123; name = &quot;许褚&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 3; //编号 wisdom = 50; //智慧 strategy = 20; //谋略 force = 98; //力量 agility = 72; //敏捷 skill_name = &quot;虎痴卸甲&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new DragonSword;&#125;void XuChu::skill(Hero * hero)&#123;&#125;void XuChu::passive_skill()&#123; this-&gt;atk = floor(this-&gt;atk*1.3); this-&gt;crit += 30;&#125;GuoJia::GuoJia()&#123; name = &quot;郭嘉&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 4; //编号 wisdom = 100; //智慧 strategy = 98; //谋略 force = 5; //力量 agility = 10; //敏捷 skill_name = &quot;鬼才&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void GuoJia::skill(Hero * hero)&#123;&#125;void GuoJia::passive_skill()&#123; this-&gt;vel += this-&gt;wisdom; this-&gt;stun += 30;&#125;XiaHouDun::XiaHouDun()&#123; name = &quot;夏侯惇&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 5; //编号 wisdom = 78; //智慧 strategy = 56; //谋略 force = 85; //力量 agility = 72; //敏捷 skill_name = &quot;&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new DragonSword;&#125;void XiaHouDun::skill(Hero * hero)&#123;&#125;void XiaHouDun::passive_skill()&#123; this-&gt;atk += 20; this-&gt;stun += 50;&#125;XiaHouYuan::XiaHouYuan()&#123; name = &quot;夏侯渊&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 6; //编号 wisdom = 72; //智慧 strategy = 65; //谋略 force = 80; //力量 agility = 95; //敏捷 skill_name = &quot;&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Bow;&#125;void XiaHouYuan::skill(Hero * hero)&#123;&#125;void XiaHouYuan::passive_skill()&#123; this-&gt;vel = ceil(this-&gt;vel*1.3); this-&gt;atk += this-&gt;strategy;&#125;CaoRen::CaoRen()&#123; name = &quot;曹仁&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 7; //编号 wisdom = 77; //智慧 strategy = 80; //谋略 force = 72; //力量 agility = 70; //敏捷 skill_name = &quot;无懈可击&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Shield;&#125;void CaoRen::skill(Hero * hero)&#123;&#125;void CaoRen::passive_skill()&#123; this-&gt;HP += 2000; this-&gt;max_HP = HP; this-&gt;def = ceil(this-&gt;def*1.2); this-&gt;atk = floor(this-&gt;atk*0.4); this-&gt;suckBlood += 80;&#125;ZhangLiao::ZhangLiao()&#123; name = &quot;张辽&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 8; //编号 wisdom = 82; //智慧 strategy = 80; //谋略 force = 78; //力量 agility = 80; //敏捷 skill_name = &quot;&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void ZhangLiao::skill(Hero * hero)&#123;&#125;void ZhangLiao::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;miss += 20;&#125;SiMaYi::SiMaYi()&#123; name = &quot;司马懿&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 9; //编号 wisdom = 99; //智慧 strategy = 100; //谋略 force = 34; //力量 agility = 45; //敏捷 skill_name = &quot;狼顾之相&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Fan;&#125;void SiMaYi::skill(Hero * hero)&#123;&#125;void SiMaYi::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;atk += this-&gt;agility;&#125;XuHuang::XuHuang()&#123; name = &quot;徐晃&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;男&quot;; //性别 id = 10; //编号 wisdom = 75; //智慧 strategy = 82; //谋略 force = 82; //力量 agility = 75; //敏捷 skill_name = &quot;兵粮寸断&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new DragonSword;&#125;void XuHuang::skill(Hero * hero)&#123;&#125;void XuHuang::passive_skill()&#123; this-&gt;atk += this-&gt;force; this-&gt;stun += 15;&#125;ZhenJi::ZhenJi()&#123; name = &quot;甄姬&quot;; //姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;女&quot;; //性别 id = 11; //编号 wisdom = 80; //智慧 strategy = 25; //谋略 force = 20; //力量 agility = 100; //敏捷 skill_name = &quot;洛神降临&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void ZhenJi::skill(Hero * hero)&#123;&#125;void ZhenJi::passive_skill()&#123; this-&gt;def += this-&gt;strategy * 0.5 + this-&gt;wisdom * 0.2; this-&gt;miss += 30;&#125;CaiWenJi::CaiWenJi()&#123; name = &quot;蔡文姬&quot;;//姓名 ctry = &quot;魏&quot;; //国家 sex = &quot;女&quot;; //性别 id = 12; //编号 wisdom = 95; //智慧 strategy = 35; //谋略 force = 25; //力量 agility = 55; //敏捷 skill_name = &quot;胡笳之音&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void CaiWenJi::skill(Hero * hero)&#123;&#125;void CaiWenJi::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;stun += 20;&#125; Shu.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma once#include&quot;Hero.h&quot;class LiuBei : public Hero &#123;public: LiuBei(); void skill(Hero * hero); void passive_skill();&#125;;class GuanYu :public Hero &#123;public: GuanYu(); void skill(Hero * hero); void passive_skill();&#125;;class ZhangFei : public Hero &#123;public: ZhangFei(); void skill(Hero * hero); void passive_skill();&#125;;class ZhuGeLiang : public Hero &#123;public: ZhuGeLiang(); void skill(Hero * hero); void passive_skill();&#125;;class ZhaoYun : public Hero &#123;public: ZhaoYun(); void skill(Hero * hero); void passive_skill();&#125;;class MaChao : public Hero &#123;public: MaChao(); void skill(Hero * hero); void passive_skill();&#125;;class HuangZhong : public Hero &#123;public: HuangZhong(); void skill(Hero * hero); void passive_skill();&#125;;class WeiYan : public Hero &#123;public: WeiYan(); void skill(Hero * hero); void passive_skill();&#125;;class HuangYueYing : public Hero &#123;public: HuangYueYing(); void skill(Hero * hero); void passive_skill();&#125;;class JiangWei : public Hero &#123;public: JiangWei(); void skill(Hero * hero); void passive_skill();&#125;;class PangTong : public Hero &#123;public: PangTong(); void skill(Hero * hero); void passive_skill();&#125;;class SunShangXiang : public Hero &#123;public: SunShangXiang(); void skill(Hero * hero); void passive_skill();&#125;; Shu.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include &quot;Shu.h&quot;LiuBei::LiuBei()&#123; name = &quot;刘备&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 1; //编号 wisdom = 72; //智慧 strategy = 62; //谋略 force = 60; //力量 agility = 25; //敏捷 skill_name = &quot;唯贤唯德&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Sword;&#125;void LiuBei::skill(Hero * hero)&#123; this-&gt;MP = 0;&#125;void LiuBei::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;atk += this-&gt;strategy;&#125;GuanYu::GuanYu()&#123; name = &quot;关羽&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 2; //编号 wisdom = 60; //智慧 strategy = 60; //谋略 force = 98; //力量 agility = 90; //敏捷 skill_name = &quot;春秋偃月&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new DragonSword;&#125;void GuanYu::skill(Hero * hero)&#123; this-&gt;MP = 0;&#125;void GuanYu::passive_skill()&#123; this-&gt;stun += 50;&#125;ZhangFei::ZhangFei()&#123; name = &quot;张飞&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 3; //编号 wisdom = 70; //智慧 strategy = 77; //谋略 force = 100; //力量 agility = 72; //敏捷 skill_name = &quot;雷霆咆哮&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void ZhangFei::skill(Hero * hero)&#123; this-&gt;MP = 0;&#125;void ZhangFei::passive_skill()&#123; this-&gt;atk = floor(this-&gt;atk*0.9); this-&gt;crit += 50;&#125;ZhuGeLiang::ZhuGeLiang()&#123; name = &quot;诸葛亮&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 4; //编号 wisdom = 100; //智慧 strategy = 100; //谋略 force = 10; //力量 agility = 32; //敏捷 skill_name = &quot;卧龙啸天&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Fan;&#125;void ZhuGeLiang::skill(Hero * hero)&#123; this-&gt;MP = 0;&#125;void ZhuGeLiang::passive_skill()&#123; this-&gt;vel += 50; this-&gt;atk += 50; this-&gt;miss += 30;&#125;ZhaoYun::ZhaoYun()&#123; name = &quot;赵云&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 5; //编号 wisdom = 75; //智慧 strategy = 80; //谋略 force = 98; //力量 agility = 100; //敏捷 skill_name = &quot;七探蛇盘&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void ZhaoYun::skill(Hero * hero)&#123; this-&gt;MP = 0;&#125;void ZhaoYun::passive_skill()&#123; this-&gt;miss += 50;&#125;MaChao::MaChao()&#123; name = &quot;马超&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 6; //编号 wisdom = 42; //智慧 strategy = 20; //谋略 force = 95; //力量 agility = 94; //敏捷 skill_name = &quot;西凉铁骑&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void MaChao::skill(Hero * hero)&#123;&#125;void MaChao::passive_skill()&#123; this-&gt;vel *= 2; this-&gt;crit += 30; this-&gt;stun += 10;&#125;HuangZhong::HuangZhong()&#123; name = &quot;黄忠&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 7; //编号 wisdom = 50; //智慧 strategy = 45; //谋略 force = 98; //力量 agility = 72; //敏捷 skill_name = &quot;百步穿杨&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Bow;&#125;void HuangZhong::skill(Hero * hero)&#123;&#125;void HuangZhong::passive_skill()&#123; this-&gt;atk += 20; this-&gt;stun += 50;&#125;WeiYan::WeiYan()&#123; name = &quot;魏延&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 8; //编号 wisdom = 25; //智慧 strategy = 75; //谋略 force = 80; //力量 agility = 75; //敏捷 skill_name = &quot;傲骨风凉&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Shield;&#125;void WeiYan::skill(Hero * hero)&#123;&#125;void WeiYan::passive_skill()&#123; this-&gt;atk *= 1.5;&#125;HuangYueYing::HuangYueYing()&#123; name = &quot;黄月英&quot;;//姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;女&quot;; //性别 id = 9; //编号 wisdom = 99; //智慧 strategy = 90; //谋略 force = 5; //力量 agility = 65; //敏捷 skill_name = &quot;奇门遁甲&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void HuangYueYing::skill(Hero * hero)&#123;&#125;void HuangYueYing::passive_skill()&#123; this-&gt;def += 50; this-&gt;miss += 30;&#125;JiangWei::JiangWei()&#123; name = &quot;姜维&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 10; //编号 wisdom = 80; //智慧 strategy = 92; //谋略 force = 80; //力量 agility = 90; //敏捷 skill_name = &quot;幼麟之风&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void JiangWei::skill(Hero * hero)&#123;&#125;void JiangWei::passive_skill()&#123;&#125;PangTong::PangTong()&#123; name = &quot;庞统&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;男&quot;; //性别 id = 11; //编号 wisdom = 90; //智慧 strategy = 94; //谋略 force = 5; //力量 agility = 18; //敏捷 skill_name = &quot;火凤燎原&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Fan;&#125;void PangTong::skill(Hero * hero)&#123;&#125;void PangTong::passive_skill()&#123; this-&gt;atk *= 1.2; this-&gt;vel *= 1.2; this-&gt;def *= 1.2; this-&gt;miss += 10;&#125;SunShangXiang::SunShangXiang()&#123; name = &quot;孙尚香&quot;; //姓名 ctry = &quot;蜀&quot;; //国家 sex = &quot;女&quot;; //性别 id = 12; //编号 wisdom = 56; //智慧 strategy = 42; //谋略 force = 65; //力量 agility = 80; //敏捷 skill_name = &quot;枭姬联姻&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Bow;&#125;void SunShangXiang::skill(Hero * hero)&#123;&#125;void SunShangXiang::passive_skill()&#123; this-&gt;miss += 20; this-&gt;stun += 20; this-&gt;atk += 20;&#125; Wu.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma once#include&quot;Hero.h&quot;class SunCe : public Hero &#123;public: SunCe(); void skill(Hero * hero); void passive_skill();&#125;;class ZhouYu :public Hero &#123;public: ZhouYu(); void skill(Hero * hero); void passive_skill();&#125;;class SunQuan : public Hero &#123;public: SunQuan(); void skill(Hero * hero); void passive_skill();&#125;;class DaQiao : public Hero &#123;public: DaQiao(); void skill(Hero * hero); void passive_skill();&#125;;class XiaoQiao : public Hero &#123;public: XiaoQiao(); void skill(Hero * hero); void passive_skill();&#125;;class HuangGai : public Hero &#123;public: HuangGai(); void skill(Hero * hero); void passive_skill();&#125;;class TaiShiCi : public Hero &#123;public: TaiShiCi(); void skill(Hero * hero); void passive_skill();&#125;;class GanNing : public Hero &#123;public: GanNing(); void skill(Hero * hero); void passive_skill();&#125;;class LuSu : public Hero &#123;public: LuSu(); void skill(Hero * hero); void passive_skill();&#125;;class LvMeng : public Hero &#123;public: LvMeng(); void skill(Hero * hero); void passive_skill();&#125;;class ZhangZhao : public Hero &#123;public: ZhangZhao(); void skill(Hero * hero); void passive_skill();&#125;;class ZhouTai : public Hero &#123;public: ZhouTai(); void skill(Hero * hero); void passive_skill();&#125;; Wu.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#include &quot;Wu.h&quot;SunCe::SunCe()&#123; name = &quot;孙策&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 1; //编号 wisdom = 78; //智慧 strategy = 65; //谋略 force = 100; //力量 agility = 85; //敏捷 skill_name = &quot;力拔山河&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void SunCe::skill(Hero * hero)&#123;&#125;void SunCe::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;atk += this-&gt;wisdom;&#125;ZhouYu::ZhouYu()&#123; name = &quot;周瑜&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 2; //编号 wisdom = 90; //智慧 strategy = 98; //谋略 force = 70; //力量 agility = 80; //敏捷 skill_name = &quot;业火焚天&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Sword;&#125;void ZhouYu::skill(Hero * hero)&#123;&#125;void ZhouYu::passive_skill()&#123;&#125;SunQuan::SunQuan()&#123; name = &quot;孙权&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 3; //编号 wisdom = 80; //智慧 strategy = 80; //谋略 force = 50; //力量 agility = 60; //敏捷 skill_name = &quot;气势汹汹&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Sword;&#125;void SunQuan::skill(Hero * hero)&#123;&#125;void SunQuan::passive_skill()&#123;&#125;DaQiao::DaQiao()&#123; name = &quot;大乔&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;女&quot;; //性别 id = 4; //编号 wisdom = 85; //智慧 strategy = 45; //谋略 force = 30; //力量 agility = 75; //敏捷 skill_name = &quot;国色天香&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void DaQiao::skill(Hero * hero)&#123;&#125;void DaQiao::passive_skill()&#123;&#125;XiaoQiao::XiaoQiao()&#123; name = &quot;小乔&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;女&quot;; //性别 id = 5; //编号 wisdom = 80; //智慧 strategy = 40; //谋略 force = 25; //力量 agility = 85; //敏捷 skill_name = &quot;玲珑之花&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void XiaoQiao::skill(Hero * hero)&#123;&#125;void XiaoQiao::passive_skill()&#123;&#125;HuangGai::HuangGai()&#123; name = &quot;黄盖&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 6; //编号 wisdom = 65; //智慧 strategy = 65; //谋略 force = 85; //力量 agility = 35; //敏捷 skill_name = &quot;苦肉之计&quot;; skill_show = &quot;&quot;; this-&gt;weapon = new Shield; this-&gt;init_property(); this-&gt;passive_skill();&#125;void HuangGai::skill(Hero * hero)&#123;&#125;void HuangGai::passive_skill()&#123;&#125;TaiShiCi::TaiShiCi()&#123; name = &quot;太史慈&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 7; //编号 wisdom = 70; //智慧 strategy = 50; //谋略 force = 90; //力量 agility = 90; //敏捷 skill_name = &quot;受宠打击&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Bow;&#125;void TaiShiCi::skill(Hero * hero)&#123;&#125;void TaiShiCi::passive_skill()&#123;&#125;GanNing::GanNing()&#123; name = &quot;甘宁&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 8; //编号 wisdom = 65; //智慧 strategy = 75; //谋略 force = 76; //力量 agility = 80; //敏捷 skill_name = &quot;百骑袭营&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Bow;&#125;void GanNing::skill(Hero * hero)&#123;&#125;void GanNing::passive_skill()&#123;&#125;LuSu::LuSu()&#123; name = &quot;鲁肃&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 9; //编号 wisdom = 80; //智慧 strategy = 90; //谋略 force = 40; //力量 agility = 60; //敏捷 skill_name = &quot;大智若愚&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Fan;&#125;void LuSu::skill(Hero * hero)&#123;&#125;void LuSu::passive_skill()&#123;&#125;LvMeng::LvMeng()&#123; name = &quot;吕蒙&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 10; //编号 wisdom = 80; //智慧 strategy = 80; //谋略 force = 80; //力量 agility = 80; //敏捷 skill_name = &quot;白衣渡江&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new DragonSword;&#125;void LvMeng::skill(Hero * hero)&#123;&#125;void LvMeng::passive_skill()&#123;&#125;ZhangZhao::ZhangZhao()&#123; name = &quot;张昭&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 11; //编号 wisdom = 80; //智慧 strategy = 95; //谋略 force = 25; //力量 agility = 55; //敏捷 skill_name = &quot;制衡之道&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void ZhangZhao::skill(Hero * hero)&#123;&#125;void ZhangZhao::passive_skill()&#123;&#125;ZhouTai::ZhouTai()&#123; name = &quot;周泰&quot;; //姓名 ctry = &quot;吴&quot;; //国家 sex = &quot;男&quot;; //性别 id = 12; //编号 wisdom = 60; //智慧 strategy = 45; //谋略 force = 90; //力量 agility = 80; //敏捷 skill_name = &quot;&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Shield;&#125;void ZhouTai::skill(Hero * hero)&#123;&#125;void ZhouTai::passive_skill()&#123;&#125; Qun.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#pragma once#include&quot;Hero.h&quot;class LvBu : public Hero &#123;public: LvBu(); void skill(Hero * hero); void passive_skill();&#125;;class DiaoChan :public Hero &#123;public: DiaoChan(); void skill(Hero * hero); void passive_skill();&#125;;class HuaTuo : public Hero &#123;public: HuaTuo(); void skill(Hero * hero); void passive_skill();&#125;;class YuanShao : public Hero &#123;public: YuanShao(); void skill(Hero * hero); void passive_skill();&#125;;class YanLiang : public Hero &#123;public: YanLiang(); void skill(Hero * hero); void passive_skill();&#125;;class WenChou : public Hero &#123;public: WenChou(); void skill(Hero * hero); void passive_skill();&#125;;class ZuoCi : public Hero &#123;public: ZuoCi(); void skill(Hero * hero); void passive_skill();&#125;;class HuaXiong : public Hero &#123;public: HuaXiong(); void skill(Hero * hero); void passive_skill();&#125;;class GongSunZan : public Hero &#123;public: GongSunZan(); void skill(Hero * hero); void passive_skill();&#125;;class ZhangJiao : public Hero &#123;public: ZhangJiao(); void skill(Hero * hero); void passive_skill();&#125;;class YuJi : public Hero &#123;public: YuJi(); void skill(Hero * hero); void passive_skill();&#125;;class LingJu : public Hero &#123;public: LingJu(); void skill(Hero * hero); void passive_skill();&#125;; Qun.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328#include &quot;Qun.h&quot;LvBu::LvBu()&#123; name = &quot;吕布&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 1; //编号 wisdom = 35; //智慧 strategy = 10; //谋略 force = 100; //力量 agility = 100; //敏捷 skill_name = &quot;方天画斩&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void LvBu::skill(Hero * hero)&#123;&#125;void LvBu::passive_skill()&#123; this-&gt;HP += this-&gt;strategy * 15 + this-&gt;wisdom * 10; this-&gt;max_HP = this-&gt;HP; this-&gt;atk += this-&gt;agility;&#125;DiaoChan::DiaoChan()&#123; name = &quot;貂蝉&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;女&quot;; //性别 id = 2; //编号 wisdom = 96; //智慧 strategy = 60; //谋略 force = 10; //力量 agility = 100; //敏捷 skill_name = &quot;闭月羞花&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void DiaoChan::skill(Hero * hero)&#123;&#125;void DiaoChan::passive_skill()&#123;&#125;HuaTuo::HuaTuo()&#123; name = &quot;华佗&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 3; //编号 wisdom = 80; //智慧 strategy = 37; //谋略 force = 60; //力量 agility = 60; //敏捷 skill_name = &quot;妙手回天&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void HuaTuo::skill(Hero * hero)&#123;&#125;void HuaTuo::passive_skill()&#123;&#125;YuanShao::YuanShao()&#123; name = &quot;袁绍&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 4; //编号 wisdom = 27; //智慧 strategy = 20; //谋略 force = 44; //力量 agility = 55; //敏捷 skill_name = &quot;万箭齐发&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Sword;&#125;void YuanShao::skill(Hero * hero)&#123;&#125;void YuanShao::passive_skill()&#123;&#125;YanLiang::YanLiang()&#123; name = &quot;颜良&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 5; //编号 wisdom = 60; //智慧 strategy = 60; //谋略 force = 90; //力量 agility = 90; //敏捷 skill_name = &quot;致命一击&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void YanLiang::skill(Hero * hero)&#123;&#125;void YanLiang::passive_skill()&#123;&#125;WenChou::WenChou()&#123; name = &quot;文丑&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 6; //编号 wisdom = 66; //智慧 strategy = 66; //谋略 force = 88; //力量 agility = 88; //敏捷 skill_name = &quot;暗箭难防&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Bow;&#125;void WenChou::skill(Hero * hero)&#123;&#125;void WenChou::passive_skill()&#123;&#125;ZuoCi::ZuoCi()&#123; name = &quot;左慈&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 7; //编号 wisdom = 100; //智慧 strategy = 90; //谋略 force = 55; //力量 agility = 20; //敏捷 skill_name = &quot;道法自然&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void ZuoCi::skill(Hero * hero)&#123;&#125;void ZuoCi::passive_skill()&#123;&#125;HuaXiong::HuaXiong()&#123; name = &quot;华雄&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 8; //编号 wisdom = 60; //智慧 strategy = 67; //谋略 force = 90; //力量 agility = 70; //敏捷 skill_name = &quot;豪情万丈&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new DragonSword;&#125;void HuaXiong::skill(Hero * hero)&#123;&#125;void HuaXiong::passive_skill()&#123;&#125;GongSunZan::GongSunZan()&#123; name = &quot;公孙瓒&quot;;//姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 9; //编号 wisdom = 60; //智慧 strategy = 65; //谋略 force = 80; //力量 agility = 90; //敏捷 skill_name = &quot;白马义从&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Spear;&#125;void GongSunZan::skill(Hero * hero)&#123;&#125;void GongSunZan::passive_skill()&#123;&#125;ZhangJiao::ZhangJiao()&#123; name = &quot;张角&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 10; //编号 wisdom = 45; //智慧 strategy = 65; //谋略 force = 55; //力量 agility = 70; //敏捷 skill_name = &quot;天公降雷&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Fan;&#125;void ZhangJiao::skill(Hero * hero)&#123;&#125;void ZhangJiao::passive_skill()&#123;&#125;YuJi::YuJi()&#123; name = &quot;于吉&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;男&quot;; //性别 id = 11; //编号 wisdom = 90; //智慧 strategy = 80; //谋略 force = 40; //力量 agility = 10; //敏捷 skill_name = &quot;太平要术&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Book;&#125;void YuJi::skill(Hero * hero)&#123;&#125;void YuJi::passive_skill()&#123;&#125;LingJu::LingJu()&#123; name = &quot;灵雎&quot;; //姓名 ctry = &quot;群&quot;; //国家 sex = &quot;女&quot;; //性别 id = 12; //编号 wisdom = 90; //智慧 strategy = 40; //谋略 force = 60; //力量 agility = 70; //敏捷 skill_name = &quot;涅槃&quot;; skill_show = &quot;&quot;; this-&gt;init_property(); this-&gt;passive_skill(); this-&gt;weapon = new Knife;&#125;void LingJu::skill(Hero * hero)&#123;&#125;void LingJu::passive_skill()&#123;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>继承</tag>
        <tag>项目</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++运算符重载之智能指针]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04%2F</url>
    <content type="text"><![CDATA[C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 既然有了需求，对此，我们可以自行打造智能指针。 Person类有show_age()成员函数。 如果new出来的Person对象，那么必须由我们自行delete。 有了智能指针，就可以让智能指针托管这个对象，这个对象的释放就不用担心了，由智能指针自动进行管理。 为了让智能指针像普通指针一样方便实用，就要重载 -&gt; 与解引用 * 运算符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;class Person &#123;public: Person():age(0)&#123;&#125; Person(int age):age(age)&#123;&#125; ~Person() &#123; cout &lt;&lt; &quot;析构调用&quot; &lt;&lt; endl; &#125; void show_age() &#123; cout &lt;&lt; &quot;我的年龄是&quot; &lt;&lt; this-&gt;age &lt;&lt; endl; &#125;private: int age;&#125;;class SmartPointer &#123;public: SmartPointer():person(NULL)&#123;&#125; SmartPointer(Person*person) &#123; this-&gt;person = person; &#125; ~SmartPointer() &#123; if (person != NULL) &#123; delete person; person = NULL; &#125; cout &lt;&lt; &quot;智能指针析构调用&quot; &lt;&lt; endl; &#125; Person* operator -&gt;() &#123; return this-&gt;person; &#125; Person&amp; operator *() &#123; return *this-&gt;person; &#125;private: Person *person;&#125;;void test() &#123; //Person p1(10); //p1.show_age(); //Person *p1 = new Person(10); //p1-&gt;show_age(); //delete p1; SmartPointer sp(new Person(10)); sp-&gt;show_age(); (*sp).show_age();&#125;int main() &#123; test(); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
        <tag>智能指针</tag>
        <tag>重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F02%2F28%2F2019-02-28%2F</url>
    <content type="text"><![CDATA[王 骏 邮箱：15249144478@163.com 电话：152-0292-4489 个人简介 专 业：陕西科技大学/计算机科学与技术 学 历：本科/2016.9~2020.6GitHub：http://github.com/qian-youyou技术博客：http://qianyouyou.cn#### 获奖经历——- 2018.11.25 亚洲区域赛铜奖 第43届ACM-ICPC国际大学生程序设计竞赛亚洲区域赛 2018.06.10 全国邀请赛铜奖 第43届ACM-ICPC国际大学生程序设计竞赛全国邀请赛 2018.04.01 省级二等奖 2018第九届蓝桥杯大赛 2018.03.31 省级三等奖 团体程序设计天梯赛 2018.03 校级二等奖 第4届陕西科技大学C语言大赛 2018.11 校级三等奖 第5届陕西科技大学C语言大赛#### 项目经验——##### 网络爬虫2017.11 ~ 2017.12 该项目主要建立中小型的文件分享站点，由学校外包项目小组负责。本人在项目小组内主要负责网络爬虫工作，利用Python的BeautifulSoup库抓取静态URL，爬取工标网上的信息到MySQL数据库。之后方便小组搭网站。 技能清单 语言：熟练使用C/C++进行项目开发，了解Python编程语言。 熟悉C++封装，继承，多态等基础知识及应用，熟练使用STL库，掌握C++异常捕捉和处理。 算法：擅长数据结构与算法优化，尤其擅长图论与数论算法分析。 例如网络流(最大流，费用流等)，最短路SPFA+SLF与LLL优化，Dijkstra+heap优化，Tarjan算法，A*搜索，KM+slack优化，匈牙利算法+时间戳优化，KMP+Trie树，线段树，加权并查集，矩阵快速幂等。 系统：熟悉Linux操作系统， 了解Linux环境下编程及进程间通信，多线程编程。 网络：具有网络基础知识， 熟悉TCP/IP协议，了解Socket网络编程。 前端：熟悉HTML5、CSS等前端语言，能够独立制作静态网页。 其他：了解MySQL基本操作。熟悉Git使用。 自我评价一个爱学习，知上进，善总结，重思考，懂感恩的人。]]></content>
  </entry>
  <entry>
    <title><![CDATA[[设计模式]单例模式案例之打印机案例]]></title>
    <url>%2F2019%2F02%2F27%2F2019-02-27%2F</url>
    <content type="text"><![CDATA[当我们启动某一个进程时，就会显示在任务管理器进程管理处；当我们关闭他后再次打开它时，发现启动进程和上次一模一样。也就是说我们启动时它只是在任务管理器上显示了出来，当我们关闭它后它实质上并没有终止，还在继续运行，只不过隐藏了起来。其实这就是单例设计模式。生活中有很多单例设计模式的案例，比如一个国家只有一个主席，即使主席替换，依然只有一个主席。比如某个教室只有一台打印机，那么无论多少人需要使用打印机，都将只能使用这一台打印机。也就是说该对象有且只能创建一个。 接下来我们总结一下单例模式的流程： 1.目的让类中只有一个对象，对象不需要自己释放。 2.将默认构造函数与拷贝构造函数私有化。 3.内部维护一个对象指针。 4.私有化唯一指针。 5.对外提供方法访问该指针。 6.保证了类中只能实例化唯一对象。 我们以打印机为例，某教室只有一台打印机，该打印机一次只能供一个人使用。 我们先来分析打印机，打印机具有打印功能，具有启动功能，具有关闭功能。而且具有一次只能供一人使用的特性，因此创建类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class PrintingPress &#123;public: static PrintingPress*getInstance() &#123; return unique; &#125; bool check() &#123; return flag; &#125; void openPrinting() &#123; if (flag == false) &#123; cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl; flag = true; &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void closePrinting() &#123; if (flag == true) &#123; flag = false; cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl; &#125; &#125; void usingPrinting(string str) &#123; if (flag == false) &#123; cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; &#125;private: PrintingPress() &#123; cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl; flag = false; &#125; PrintingPress(const PrintingPress&amp; p) &#123; cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl; flag = false; &#125; static PrintingPress* unique; bool flag = false;&#125;;PrintingPress* PrintingPress::unique = new PrintingPress; 用户具有使用打印机打印内容的功能，具有关闭打印机的功能，具有打开打印机的功能。因此创建用户类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class user &#123;public: void us() &#123; if (flag == true) &#123; string str; cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl; cin &gt;&gt; str; p-&gt;usingPrinting(str); &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void us(string str) &#123; if (flag == true) &#123; cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl; p-&gt;usingPrinting(str); &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void op() &#123; if (p-&gt;check() == false) &#123; p-&gt;openPrinting(); flag = true; &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void cl() &#123; if (flag = true) &#123; p-&gt;closePrinting(); flag = false; &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125;private: PrintingPress* p = PrintingPress::getInstance(); bool flag = false;&#125;; 以下代码是用C++写的一个简单的打印机案例测试代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#define CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class PrintingPress &#123;public: static PrintingPress*getInstance() &#123; return unique; &#125; bool check() &#123; return flag; &#125; void openPrinting() &#123; if (flag == false) &#123; cout &lt;&lt; &quot;打印机已启动&quot; &lt;&lt; endl; flag = true; &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void closePrinting() &#123; if (flag == true) &#123; flag = false; cout &lt;&lt; &quot;打印机已关闭&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;打印机已关闭，无需执行该操作&quot; &lt;&lt; endl; &#125; &#125; void usingPrinting(string str) &#123; if (flag == false) &#123; cout &lt;&lt; &quot;很抱歉，打印机被占用。&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; &#125;private: PrintingPress() &#123; cout &lt;&lt; &quot;打印机可正常使用&quot; &lt;&lt; endl; flag = false; &#125; PrintingPress(const PrintingPress&amp; p) &#123; cout &lt;&lt; &quot;打印机违规使用&quot; &lt;&lt; endl; flag = false; &#125; static PrintingPress* unique; bool flag = false;&#125;;PrintingPress* PrintingPress::unique = new PrintingPress;class user &#123;public: void us() &#123; if (flag == true) &#123; string str; cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl; cin &gt;&gt; str; p-&gt;usingPrinting(str); &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void us(string str) &#123; if (flag == true) &#123; cout &lt;&lt; &quot;请输入要打印的内容：&quot; &lt;&lt; endl; p-&gt;usingPrinting(str); &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void op() &#123; if (p-&gt;check() == false) &#123; p-&gt;openPrinting(); flag = true; &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125; void cl() &#123; if (flag = true) &#123; p-&gt;closePrinting(); flag = false; &#125; else &#123; cout &lt;&lt; &quot;打印机暂时被占用，无法打印&quot; &lt;&lt; endl; &#125; &#125;private: PrintingPress* p = PrintingPress::getInstance(); bool flag = false;&#125;;void test() &#123; user tmp[3]; tmp[1].op(); tmp[2].op(); tmp[1].us(&quot;lalalalala&quot;); tmp[2].op(); tmp[1].cl(); tmp[2].op(); tmp[2].us(&quot;22222222&quot;); tmp[2].cl();&#125;int main() &#123; test(); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]const指针与指向const的指针]]></title>
    <url>%2F2019%2F02%2F23%2F2019-02-23%2F</url>
    <content type="text"><![CDATA[最近在复习Ｃ＋＋，指针这块真的是重难点，很久了也没有去理会，今晚好好总结一下const指针，好久没有写过博客了，记录一下~ const指针的定义： const指针是指针变量的值一经初始化，就不可以改变指向，初始化是必要的。其定义形式如下： type *const 指针名称; 声明指针时，可以在类型前或后使用关键字const，也可在两个位置都使用。例如，下面都是合法的声明，但是含义大不同： const int * pOne; //指向整形常量 的指针，它指向的值不能修改 int * const pTwo; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。 const int *const pThree; //指向整形常量 的常量指针 。它既不能再指向别的常量，指向的值也不能修改。 理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。下面的代码有助于说明这一点： 123const int *p1; //the int pointed to is constantint * const p2; // p2 is constant, it can&apos;t point to anything else const指针和const成员函数 可以将关键字用于成员函数。例如： ;) 123456789101112131415161718192021class Rectangle&#123; pubilc: ..... void SetLength(int length)&#123;itslength = length;&#125; int GetLength() const &#123;return itslength;&#125; //成员函数声明为常量 ..... private: int itslength; int itswidth;&#125;; ;) 当成员函数被声明为const时，如果试图修改对象的数据，编译器将视为错误。 如果声明了一个指向const对象的指针，则通过该指针只能调用const方法（成员函数）。 示例声明三个不同的Rectangle对象： ;) 1234567Rectangle* pRect = new Rectangle;const Rectangle * pConstRect = new Rectangle; //指向const对象Rectangle* const pConstPtr = new Rectangle;// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。 ;) const指针和指向const的指针当使用带有const的指针时其实有两种意思。一种指的是你不能修改指针本身的内容，另一种指的是你不能修改指针指向的内容。听起来有点混淆一会放个例子上来就明白了。 先说指向const的指针，它的意思是指针指向的内容是不能被修改的。它有两种写法。 const int p; （推荐） int const p; 第一种可以理解为，p是一个指针，它指向的内容是const int 类型。p本身不用初始化它可以指向任何标示符，但它指向的内容是不能被改变的。 第二种很容易被理解成是p是一个指向int的const指针（指针本身不能被修改），但这样理解是错误的，它也是表示的是指向const的指针（指针指向的内容是不能被修改的），它跟第一种表达的是一个意思。为了避免混淆推荐大家用第一种。 再说const指针，它的意思是指针本身的值是不能被修改的。它只有一种写法 int const p=一个地址; (因为指针本身的值是不能被修改的所以它必须被初始化） 这种形式可以被理解为，p是一个指针，这个指针是指向int 的const指针。它指向的值是可以被改变的如p=3; 还有一种情况是这个指针本身和它指向的内容都是不能被改变的，请往下看。 const int const p=一个地址; int const const p=一个地址; 看了上面的内容是不是有点晕，没关系，你不用去背它，用的多了就知道了，还有个技巧，通过上面的观察我们不难总结出一点规律，是什么呢？这个规律就是： 指向const的指针（指针指向的内容不能被修改）const关健字总是出现在的左边而const指针（指针本身不能被修改）const关健字总是出现在的右边，那不用说两个const中间加个*肯定是指针本身和它指向的内容都是不能被改变的。有了这个规则是不是就好记多了。 ;) 12345678910111213141516171819202122232425262728293031Code highlighting produced by Actipro CodeHighlighter (freeware)http://www.CodeHighlighter.com/--&gt; 1 #include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123; int a=3; int b; /*定义指向const的指针（指针指向的内容不能被修改）*/ const int* p1; int const* p2; /*定义const指针(由于指针本身的值不能改变所以必须得初始化）*/ int* const p3=&amp;a; /*指针本身和它指向的内容都是不能被改变的所以也得初始化*/ const int* const p4=&amp;a; int const* const p5=&amp;b; p1=p2=&amp;a; //正确 *p1=*p2=8; //不正确（指针指向的内容不能被修改） *p3=5; //正确 p3=p1; //不正确（指针本身的值不能改变） p4=p5;//不正确 （指针本身和它指向的内容都是不能被改变） *p4=*p5=4; //不正确（指针本身和它指向的内容都是不能被改变） return 0; &#125; ;) const用法小结：const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。\1. const修饰函数的参数如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。const 只能修饰输入参数：如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。将“const &amp;”修饰输入参数的用法总结如下：(1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。(2)对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。 \2. const 修饰函数的返回值如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数const char GetString(void);如下语句将出现编译错误：char str = GetString();正确的用法是const char *str = GetString();如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。例如： ;) 1234567class A&#123;A &amp; operate = (const A &amp;other); // 赋值函数&#125;;A a, b, c; // a, b, c 为A 的对象a = b = c; // 正常的链式赋值(a = b) = c; // 不正常的链式赋值，但合法 ;) 如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。 \3. const修饰成员函数关于Const函数的几点规则：a. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.b. const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.c. const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.d. 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的 版权所有，转载请注明转载地址：http://www.cnblogs.com/lihuidashen/p/4378884.html]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>const</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]#pragma命令详解]]></title>
    <url>%2F2019%2F02%2F22%2F2019-02-22%2F</url>
    <content type="text"><![CDATA[每种C和C++的实现支持对其宿主机或操作系统唯一的功能。例如，一些程序需要精确控制超出数据所在的储存空间，或着控制特定函数接受参数的方式。#pragma指示使每个编译程序在保留C和C++语言的整体兼容性时提供不同机器和操作系统特定的功能。编译指示被定义为机器或操作系统特定的，并且通常每种编译程序是不同的。 语法： #pragma token_string “token_string”是一系列字符用来给出所需的特定编译程序指令和参数。数字符号“#”必须是包含编译指令的行中第一个非空白字符；而空白字符可以隔开数字符号“#”和关键字“pragma”。在#pragma后面，写任何翻译程序能够作为预处理符号分析的文本。#pragma的参数类似于宏扩展。 如果编译程序发现它不认得一个编译指示，它将给出一个警告，可是编译会继续下去。 为了提供新的预处理功能，或者为编译程序提供由实现定义的信息，编译指示可以用在一个条件语句内。C和C++编译程序可以识别下列编译程序指令。 alloc_text comment init_seg* optimize auto_inline component inline_depth pack bss_seg data_seg inline_recursion pointers_to_members* check_stack function intrinsic setlocale code_seg hdrstop message vtordisp* const_seg include_alias once warning *仅用于C++编译程序。 1 alloc_text #pragma alloc_text( “textsection”, function1, … ) 命名特别定义的函数驻留的代码段。该编译指示必须出现在函数说明符和函数定义之间。 alloc_text编译指示不处理C++成员函数或重载函数。它仅能应用在以C连接方式说明的函数——就是说，函数是用extern “C”连接指示符说明的。如果你试图将这个编译指示应用于一个具有C++连接方式的函数时，将出现一个编译程序错误。 由于不支持使用__based的函数地址，需要使用alloc_text编译指示来指定段位置。由textsection指定的名字应该由双引号括起来。 alloc_text编译指示必须出现在任何需要指定的函数说明之后，以及这些函数的定义之前。 在alloc_text编译指示中引用的函数必须和该编译指示处于同一个模块中。如果不这样做，使以后一个未定义的函数被编译到一个不同的代码段时，错误会也可能不会被捕获。即使程序一般会正常运行，但是函数不会分派到应该在的段。 alloc_text的其它限制如下： 它不能用在一个函数内部。 它必须用于函数说明以后，函数定义以前。 2 auto_inline #pragma auto_inline( [{on | off}] ) 当指定off时将任何一个可以被考虑为作为自动嵌入扩展候选的函数排除出该范围。为了使用auto_inline编译指示，将其紧接着写在一个函数定义之前或之后（不是在其内部）。该编译指示将在其出现以后的第一个函数定义开始起作用。auto_inline编译指示对显式的inline函数不起作用。 3 bss_seg #pragma data_seg( [“section-name”[, “section-class”] ] ) 为未初始化数据指定缺省段。data_seg编译指示除了工作于已初始化数据而不是未初始化的以外具有一样的效果。在一些情况下，你能使用bss_seg将所有未初始化数据安排在一个段中来加速你的装载时间。 #pragma bss_seg( “MY_DATA” ) 将导致把#pragma语句之后的未初始化的数据安排在一个叫做MY_DATA的段中。 用bss_seg编译指示分配的数据不包含任何关于其位置的信息。 第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。 4 check_stack #pragma check_stack([ {on | off}] ) #pragma check_stack{+ | –} 如果指定off（或者“-”）指示编译程序关闭堆栈探测，或者指定on（或“+”）打开堆栈探测。如果没有给出参数，堆栈探测将根据默认设置决定。该编译指示将在出现该指示之后的第一个函数开始生效。堆栈探测既不是宏和能够生成嵌入代码函数的一部分。 如果你没有给出check­_stack编译指示的参数，堆栈检查将恢复到在命令行指定的行为。详细情况见编译程序参考。#pragma check_stack和/Gs选项的互相作用情况在表2.1中说明。 表 2.1 使用check_stack编译指示 编译指示 用/Gs选项编译？ 行为 #pragma check_stack()或#pragma check_stack 是 后续的函数关闭堆栈检查 #pragma check_stack()或#pragma check_stack 否 后续的函数打开堆栈检查 #pragma check_stack(on)或#pragma check_stack(+) 是或者否 后续的函数打开堆栈检查 #pragma check_stack(off)或#pragma check_stack(-) 是或者否 后续的函数关闭堆栈检查 5 code_seg #pragma code_seg( [“section-name”[,”section-class”] ] ) 指定分配函数的代码段。code_seg编译指示为函数指定默认的段。你也能够像段名一样指定一个可选的类名。使用没有段名字符串的#pragma code_seg将恢复分配到编译开始时候的状态。 6 const_seg #pragma const_seg( [“section-name”[, “section-class”] ] ) 指定用于常量数据的默认段。data_seg编译指示除了可以工作于所有数据以外具有一样的效果。你能够使用该编译指示将你的常量数据保存在一个只读的段中。 #pragma const_seg( “MY_DATA” ) 导致在#pragma语句后面的常量数据分配在一个叫做MY_DATA的段中。 用const_seg编译指示分配的数据不包含任何关于其位置的信息。 第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。 7 comment #pragma comment( comment-type [, commentstring] ) 将描述记录安排到目标文件或可执行文件中去。comment-type是下面说明的五个预定义标识符中的一个，用来指定描述记录的类型。可选的commentstring是一个字符串文字值用于为一些描述类型提供附加的信息。因为commentstring是一个字符串文字值，所以它遵从字符串文字值的所有规则，例如换码字符、嵌入的引号（”）和联接。 7-1 compiler 在目标文件中放置编译程序名和版本号。该描述记录被连接程序忽略。如果你为这个记录类型提供一个commentstring参数，编译程序将生成一个警告。 7-2 exestr 将commentstring放置到目标文件中去。在连结时，这个字符串再被放到可执行文件去中。当可执行文件被装载时这个字符串不会被装入内存，然而，它可以被一个能够在文件中搜索可打印字符串的程序找到。该描述记录的一个用处是在可执行文件中嵌入版本号或者类似的信息。 7-3 lib 将一个库搜索记录放置到目标文件中去。该描述类型必须有包含你要连接程序搜索的库名（和可能的路径）的commentstring参数。因为在目标文件中该库名先于默认的库搜索记录，所以连接程序将如同你在命令行输入这些库一样来搜索它们。你可以在一个源文件中放置多个库搜索记录，每个记录将按照它们出现在源文件中的顺序出现在目标文件中。 7-4 linker 在目标文件中放置连接程序选项。你可以用这个描述类型指定连接程序选项来代替在Project Setting对话框中Link页内的选项。例如，你可以指定/include选项以强迫包含一个符号： #pragma comment(linker, “/include:__mySymbol”) 7-5 user 在目标文件中包含一个普通描述记录。commentstring参数包含描述的文本。该描述记录将被连接程序忽略。 下面的编译指示导致连接程序在连接时搜索EMAPI.LIB库。连接程序首先在当前工作目录然后在LIB环境变量指定的路径中搜索。 #pragma comment( lib, “emapi” ) 下面的编译指示导致编译程序将其名字和版本号放置到目标文件中去。 The following pragma causes the compiler to place the name and version number of the compiler in the object file: #pragma comment( compiler ) 注意，对于具有commentstring参数的描述记录，你可以使用其它用作字符串文字量的宏来提供宏扩展为字符串文字量。你也能够联结任何字符串文字量和宏的组合来扩展成为一个字符串文字量。例如，下面的语句是可以接受的： #pragma comment( user, “Compiled on “ DATE “ at “ TIME ) 8 component #pragma component( browser, { on | off }[, references [, name ]] ) #pragma component( minrebuild, on | off ) 从源文件内控制浏览信息和依赖信息的收集。 8-1 浏览信息（Browser） 你可以将收集打开或关闭，你也可以指定收集时忽略特别的名字。 使用on或off在编译指示以后控制浏览信息的收集。例如： #pragma component(browser, off) 终止编译程序收集浏览信息。 注意，为了用这个编译指示打开浏览信息的收集，必须先从Project Setting对话框或者命令行允许浏览信息。 references选项可以有也可以没有name参数。使用没有name参数的references选项将打开或者关闭引用信息的收集（然而继续收集其它浏览信息）。例如： #pragma component(browser, off, references) 终止编译程序收集引用信息。 使用有name和off参数的references选项将阻止从浏览信息窗口中出现引用到的名字。用这个语法将忽略你不感兴趣的名字和类型从而减少浏览信息文件的大小。例如： #pragma component(browser, off, references, DWORD) 从这一点以后忽略DWORD的引用。你能够用on恢复DWORD的引用收集： #pragma component(browser, on, references, DWORD) 这是唯一的方法可以恢复收集指定名字的引用，你必须显式地打开任何你关闭的名字。 为了防止预处理程序扩展名字（就像扩展NULL到0），用引号括起来： #pragma component(browser, off, references, “NULL”) 8-2 最小化重建（Minimal Rebuild） Visual C++的最小化重建功能要求编译程序创建并保存需要大量磁盘空间的C++类依赖信息。为了节省磁盘空间，你能够在你不需要收集依赖信息时使用#pragma component(minrebuild,off)，例如，没有改变过头文件。在未修改过的类之后插入#pragma component(minrebuild,on)重新打开依赖信息。 详见Enable Minimal Rebuild(/Gm)编译程序选项。 9 data_seg #pragma data_seg( [“section-name”[, “section-class”] ] ) 指定数据的默认段。例如： #pragma data_seg( “MY_DATA” ) 导致在#pragma语句后分配的数据保存在一个叫做MY_DATA的段中。 用data_seg编译指示分配的数据不包含任何关于其位置的信息。 第二个参数section-class是用于兼容2.0版本以前的Visual C++的，现在将忽略它。 10 function #pragma function( function1 [, function2, …] ) 指定必须生成对编译指示中参数列表内函数的调用。如果你使用intrinsic编译指示（或者/Oi）来告诉编译程序生成内含函数（内含函数如同嵌入代码一样生成，不作为一个函数调用），你能够用function编译指示显式地强迫函数调用。当遇到一个function编译指示，它将在其后面遇到的第一个包含有内含函数的函数定义处生效。其持续作用到源文件的尾部或者出现对同一个内含函数指定intrinsic编译指示。function编译指示只能用于函数外——在全局层次。 为了列出具有内含形式的函数表，参见#pragma intrinsic。 11 hdrstop #pragma hdrstop [( “filename” )] 控制预编译头文件的工作方式。filename是要使用或者创建（依赖于是否指定了/Yu或/Yc）预编译头文件的名字。如果 filename不包括一个指定路径，将假定预编译头文件和源文件处于同一个目录中。当指定自动预编译头文件选项/YX时，所有指定的文件名将被忽略。 如果有/YX或者/Yc选项，而且C或C++文件包含了一个hdrstop编译指示时，编译程序保存编译指示之前的编译状态。编译指示之后的编译状态不被保存。 hdrstop编译选项不能出现在一个头文件内。它只能出现在源文件的文件级，它也不能出现在任何数据或者函数的说明或定义之中。 注意，除非指定没有文件名的/YX选项或者/Yu或/Yc选项，否则hdrstop编译指示将被忽略。 用一个文件名命名要保存编译状态的预编译头文件。在hdrstop和filename之间的空格是可选的。在hdrstop编译指示中的文件名是一个字符串，这样它服从于C或C++的字符串规则。特别的，你必须像下面例子里面显示的用引号括起来。 #pragma hdrstop( “c:\projects\include\myinc.pch” ) 预编译头文件的文件名按照如下规则决定，按照优先次序： /Fp编译程序选项的参数； 由#pragma hdrstop的filename参数； 原文件名的基本文件名加上.PCH扩展名。 12 include_alias #pragma include_alias( “long_filename”, “short_filename” ) #pragma include_alias( &lt;long_filename&gt;, &lt;short_filename&gt; ) 指定作为long_filename别名的short_filename。一些文件系统允许超出8.3FAT文件系统限制的长头文件名。编译程序不能简单地将长文件名截断为8.3名字，因为长头文件名的前8个字符可能不是唯一的。无论何时编译程序遇到long_filename串，它代替short_filename，并且用short_filename搜索头文件。这个编译指示必须出现在相应的#include指示之前。例如： // First eight characters of these two files not unique. #pragma include_alias( “AppleSystemHeaderQuickdraw.h”, “quickdra.h” ) #pragma include_alias( “AppleSystemHeaderFruit.h”, “fruit.h” ) #pragma include_alias( “GraphicsMenu.h”, “gramenu.h” ) #include “AppleSystemHeaderQuickdraw.h” #include “AppleSystemHeaderFruit.h” #include “GraphicsMenu.h” 这个别名在搜索时精确匹配，包括拼写和双引号、尖括号。include_alias编译指示在文件名上执行简单的字符串匹配，不进行其它的文件名验证。例如，给出下列指示： #pragma include_alias(“mymath.h”, “math.h”) #include “./mymath.h” #include “sys/mymath.h” 并不执行别名替代，因为头文件名字符串没有精确匹配。另外，在/Yu，/Yc和/YX编译程序选项，或hdrstop编译指示中作为参数的头文件名不被替换。例如，如果你的源文件包含下列指示： #include &lt;AppleSystemHeaderStop.h&gt; 相应的编译程序选项必须是： /YcAppleSystemHeaderStop.h 你能够用include­_alias编译指示将任何头文件映射到其它文件。例如： #pragma include_alias( “api.h”, “c:\version1.0\api.h” ) #pragma include_alias( &lt;stdio.h&gt;, &lt;newstdio.h&gt; ) #include “api.h” #include &lt;stdio.h&gt; 不要混淆用双引号和尖括号括起来的文件名。例如，给出上面的#pragma include_alias指示时，在下面的#include指示中编译程序不执行替换。 #include &lt;api.h&gt; #include “stdio.h” 还有，下面的指示将产生一个错误： #pragma include_alias(&lt;header.h&gt;, “header.h”) // Error 注意，在错误信息中报告的文件名，或者预定义宏FILE的值，是执行替换以后的文件名。例如，在下列指示之后： #pragma include_alias( “VeryLongFileName.H”, “myfile.h” ) #include “VeryLongFileName.H” 文件VeryLongFileName.H产生下列错误信息： myfile.h(15) : error C2059 : syntax error 还要注意的是不支持传递性。给出下面的指示： #pragma include_alias( “one.h”, “two.h” ) #pragma include_alias( “two.h”, “three.h” ) #include “one.h” 编译程序将搜索two.h而不是three.h。 13 init_seg C++特有 #pragma init_seg({ compiler | lib | user | “section-name” [, “func-name”]} ) 指定影响启动代码执行的关键字或代码段。因为全局静态对象的初始化可以包含执行代码，所以你必须指定一个关键字来定义什么时候构造对象。在使用需要初始化的动态连接库（DLL）或程序库时使用init_seg编译指示是尤其重要的。 init_seg编译指示的选项有： 13-1 compiler 由Microsoft C运行时间库保留。在这个组中的对象将第一个构造。 13-2 lib 用于第三方类库开发者的初始化。在这个组中的对象将在标记为构造compiler的对象之后，其它对象之前构造。 13-3 user 用于任何其它用户。在这个组中的对象将最后构造。 13-4 section-name 允许显式地指定初始化段。在用户指定的section-name中的对象将不会隐式地构造，而它们的地址将会被放置在由section-name命名的段中。 13-5 func-name 指定当程序退出时，作为atexit函数调用的函数。这个函数必须具有和atexit函数相同的形式： int funcname(void (__cdecl *)(void)); 如果你需要延迟初始化，你能够选择指定显式的段名。随后你必须调用每个静态对象的构造函数。 14 inline_depth #pragma inline_depth( [0… 255] ) 通过控制能够被扩展的一系列函数调用（从0到255次）来控制嵌入函数扩展的发生次数，这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。 inline_depth编译指示控制能够被扩展的一系列函数调用。例如，如果嵌入深度是4，并且如果A调用B然后调用C，所有的3次调用都将做嵌入扩展。然而，如果设置的最近一次嵌入深度是2，则只有A和B被扩展，而C仍然作为函数调用。 为了使用这个编译指示，你必须设置编译程序选项/Ob为1或者2。用这个编译指示指定的深度设定在该指示后面的第一个函数开始生效。如果你在括号内不指定一个值，inline_depth设置嵌入深度到默认值8。 在扩展时，嵌入深度可以被减少而不能被增加。如果嵌入深度是6，同时在扩展过程中预处理程序遇到一个inline_depth编译指示设置为8，则深度保持为6。 嵌入深度0将拒绝嵌入扩展，深度255将设置在嵌入扩展时没有限制。如果用一个没有指定值的编译指示，则使用为默认值。 15 inline_recursion #pragma inline_recursion( [{on | off}] ) 控制直接或者相互间的递归函数调用式的嵌入扩展。用这个编译指示控制用inline，__inline标记的或在/Ob2选项下能自动嵌入的嵌入函数。使用这个编译指示需要设置编译程序选项/Ob为1或者2。默认的inline_recursion状态是off。这个编译指示在出现该编译指示之后第一个函数调用起作用，并不影响函数的定义。 inline_recursion编译指示控制如何扩展递归函数。如果inline_recursion是off，并且如果一个嵌入函数调用了它自己（直接的或者间接的），函数将仅仅扩展一次。如果inline_recursion是on,函数将扩展多次直到达到inline_depth的值或者容量限制。 16 intrinsic #pragma intrinsic( function1 [, function2, …] ) 指定对在编译指示参数表中函数调用是内含的。编译程序像嵌入代码一样生成内含函数，而不是函数调用。下面列出了具有内含形式的库函数。一旦遇到intrinsic编译指示，它从第一个包含指定内含函数的函数定义开始起作用。作用持续到源文件尾部或者出现包含相同内含函数的function编译指示。intrinsic编译指示只能用在函数定义外——在全局层次。 下列函数具有内含形式： _disable _enable _inp _inpw _lrotl _lrotr _outp _outpw _rotl _rotr _strset abs fabs labs memcmp memcpy memset strcat strcmp strcpy strlen 使用内含函数的程序更快，因为它们没有函数调用的额外代价，然而因为有附加的代码生成，可能比较大。 注意，_alloca和setjmp函数总是内含的，这个行为不受intrinsic编译指示影响。 下列浮点函数没有内含形式。然而它们具有直接将参数通过浮点芯片传送而不是推入程序堆栈的版本。 acos asin cosh fmod pow sinh tanh 当你同时指定/Oi和/Og编译程序选项（或者任何包含/Og，/Ox，/O1和/O2的选项）时下列浮点函数具有真正的内含形式。 atan exp log10 sqrt atan2 log sin tan cos 你可以用编译程序选项/Op或/Za来覆盖真内含浮点选项的生成。在这种情况下，函数会像一般库函数一样被生成，同时直接将参数通过浮点芯片传送而不是推入程序堆栈。 17 message #pragma message( messagestring ) 不中断编译，发送一个字符串文字量到标准输出。message编译指示的典型运用是在编译时显示信息。 下面的代码段用message编译指示在编译过程中显示一条信息： #if _M_IX86 == 500 #pragma message( “Pentium processor build” ) #endif messagestring参数可以是一个能够扩展成字符串文字量的宏，并且你能够用字符串文字量和宏的任何组合来构造。例如，下面的语句显示被编译文件的文件名和文件最后一次修改的日期和时间。 #pragma message( “Compiling “ FILE ) #pragma message( “Last modified on “ TIMESTAMP ) 18 once #pragma once 指定在创建过程中该编译指示所在的文件仅仅被编译程序包含（打开）一次。该编译指示的一种常见用法如下： //header.h #pragma once // Your C or C++ code would follow: 19 optimize 仅在专业版和企业版中存在 #pragma optimize( “[optimization-list]”, {on | off} ) 代码优化仅有Visual C++专业版和企业版支持。详见Visual C++ Edition。 指定在函数层次执行的优化。optimize编译选项必须在函数外出现，并且在该编译指示出现以后的第一个函数定义开始起作用。on和off参数打开或关闭在optimization-list指定的选项。 optimization-list能够是0或更多个在表2.2中给出的参数： 表 2.2 optimize编译指示的参数 参数 优化类型 a 假定没有别名。 g 允许全局优化。 p 增强浮点一致性。 s 或 t 指定更短或者更快的机器代码序列。 w 假定在函数调用中没有别名。 y 在程序堆栈中生成框架指针。 这些和在/O编译程序选项中使用的是相同的字母。例如： #pragma optimize( “atp”, on ) 用空字符串（””）的optimize编译指示是一种特别形式。它要么关闭所有的优化选项，要么恢复它们到原始（或默认）的设定。 #pragma optimize( “”, off ) #pragma optimize( “”, on ) 20 pack #pragma pack( [ n] ) 指定结构和联合成员的紧缩对齐。尽管用/Zp选项设定整个翻译单元的结构和联合成员的紧缩对齐，可以用pack编译指示在数据说明层次设定紧缩对齐。从出现该编译指示后的第一个结构或者联合说明开始生效。这个编译指示不影响定义。 当你使用#pragma pack(n)，其中n是1，2，4，8或者16，第一个以后的每个结构成员保存在较小的成员类型或者n字节边界上。如果你使用没有参数的#pragma pack，结构成员将被紧缩到由/Zp指定的值。默认的/Zp紧缩的大小是/Zp8。 编译程序还支持下面的增强语法： #pragma pack( [ [ { push | pop}, ] [ identifier, ] ] [ n ] ) 该语法允许你将使用不同紧缩编译指示的组件合并到同一个翻译单元内。 每次出现有push参数的pack编译指示将保存当前的紧缩对齐值到一个内部的编译程序堆栈。编译指示的参数列表从左向右读取。如果你使用了push，当前紧缩值被保存。如果你提供了一个n值，这个值将成为新的紧缩值。如果你指定了一个你选定的标示符，这个标示符将和新的紧缩值关联。 每次出现有pop参数的pack编译指示从内部编译程序堆栈顶部取出一个值并将那个值作为新的紧缩对齐。如果你用了pop，而内部编译程序堆栈是空的，对齐值将从命令行得到，同时给出一个警告。如果你用了pop并指定了n的值，那个值将成为新的紧缩值。如果你用了pop并指定了一个标示符，将移去所有保存在堆栈中的的值直到匹配的找到匹配的标示符，和该标示符关联的紧缩值也被从堆栈中移出来成为新的紧缩值。如果没有找到匹配的标示符，将从命令行获取紧缩值并产生一个1级警告。默认的紧缩对齐是8。 pack编译指示的新的增强功能允许你编写头文件保证在使用头文件之前和其后的紧缩值是一样的： /* File name: include1.h */ #pragma pack( push, enter_include1 ) / Your include-file code … / #pragma pack( pop, enter_include1 ) / End of include1.h / 在前面的例子中，进入头文件时将当前紧缩值和标示符enter_include1关联并推入，被记住。在头文件尾部的pack编译选项移去所有在头文件中可能遇到的紧缩值并移去和enter_include1关联的紧缩值。这样头文件保证了在使用头文件之前和其后的紧缩值是一样的。 新功能也允许你在你的代码内用pack编译指示为不同的代码，例如头文件设定不同的紧缩对齐。 #pragma pack( push, before_include1 ) #include “include1.h” #pragma pack( pop, before_include1 ) 在上一个例子中，你的代码受到保护，防止了在include.h中的任何紧缩值的改变。 21 pointers_to_members C++特有 #pragma pointers_to_members(pointer-declaration, [most-general-representation] ) 指定是否能够在相关类定义之前说明一个指向类成员的指针，并且用于控制指针的大小和解释指针的代码。你能够在你的源代码中使用pointers_to_members编译知识来代替/vmx编译程序选项。 pointer-declaration参数指出是否在相关函数定义之前或其后你已经说明了一个指向成员的指针。pointer-declaration参数是下面两个符号之一： 参数 说明 full_generality 生成安全的，但是有时不能优化的代码。如果有一些指向成员的指针在相关类定义之前说明，你要用full_generality。这个参数总是使用由most-general-representation指定的指针表示方式。 best_case 对于所有指向成员的指针用最佳的表示方式生成安全的，优化的代码。需要在说明一个指向类成员指针之前定义类。默认是best_case。 most-general-representaion参数指出在一个翻译单元中编译程序能够安全引用任何指向类成员指针的最小指针表示方式。这个参数可以是下列之一： 参数 说明 single_inheritance 最普通的表示方式是单继承，指向成员函数。如果用于指向具有多重或者虚拟继承方式类成员的指针，将产生一个错误。 multi_inheritance 最普通的表示方式是多重继承，指向成员函数。如果用于指向具有虚拟继承方式类成员的指针，将产生一个错误。 virtual_inheritance 最普通的表示方式是虚拟继承，指向成员函数。不会产生错误。当使用#pragma pointers_to_members (full_generality)时这是默认的参数。 22 setlocale #pragma setlocale( “locale-string” ) 定义用于翻译宽字符常数和字符串文字量时用的地区（国家和语言）。由于用于从多字节字符转换到宽字符的算法根据地区或者由于在运行可执行程序不同的地方进行编译而不同，这个编译指示提供一种在编译时指定目标地区的方式。这保证宽字符字符串将以正确的格式保存。默认的locale-string是“C”。“C”地区将字符串中的每个字符作为wchar_t（即unsigned int）映射其值。 23 vtordisp C++特有 #pragma vtordisp({on | off} ) 允许隐藏的附加vtordisp构造函数/析构函数替换成员。vtordisp编译指示仅能够用于具有虚拟基类的代码。如果派生类从一个虚拟基类重载了一个虚拟函数，并且如果派生类的构造函数或析构函数用指向虚拟基类的指针调用了这个函数，编译程序将根据虚拟基类在类中引入一个附加的隐藏“vtordisp”域。 vtodisp编译选项影响它后面的类布局。/vd0和/vd1选项为整个模块指定了相同的行为。指定off将禁止隐藏的vtordisp成员，指定on（默认）将在它们需要的时候允许vtordisp。仅在不可能出现类的构造函数和析构函数通过this指针调用其指向对象中的虚拟函数时才关闭vtordisp。 #pragma vtordisp( off ) class GetReal : virtual public { … }; #pragma vtordisp( on ) 24 warning #pragma warning( warning-specifier : warning-number-list [,warning-specifier : warning-number-list…] ) #pragma warning( push[ , n ] ) #pragma warning( pop ) 允许有选择地修改编译程序警告信息的行为。 warning-specifier能够是下列值之一： warning-specifier 含义 once 只显示指定信息一次。 default 对指定信息应用默认的编译程序选项。 1,2,3,4 对指定信息引用给定的警告等级。 disable 不显示指定信息。 error 对指定信息作为错误显示。 warning-number_list能够包含任何警告编号。如下，在一个编译指示中可以指定多个选项： #pragma warning( disable : 4507 34; once : 4385; error : 164 ) 这等价于： #pragma warning( disable : 4507 34 ) // Disable warning messages ​ // 4507 and 34. #pragma warning( once : 4385 ) // Issue warning 4385 ​ // only once. #pragma warning( error : 164 ) // Report warning 164 ​ // as an error. 对于那些关于代码生成的，大于4699的警告标号，warning编译指示仅在函数定义外时有效。如果指定的警告编号大于4699并且用于函数内时被忽略。下面例子说明了用warning编译指示禁止、然后恢复有关代码生成警告信息的正确位置： int a; #pragma warning( disable : 4705 ) void func() { ​ a; } #pragma warning( default : 4705 ) warning编译指示也支持下面语法： #pragma warning( push [ ,n ] ) #pragma warning( pop ) 这里n表示警告等级（1到4）。 warning(push)编译指示保存所有警告的当前警告状态。warning(push,n)保存所有警告的当前状态并将全局警告等级设置为n。 warning(pop)弹出最后一次推入堆栈中的警告状态。任何在push和pop之间改变的警告状态将被取消。考虑下面的例子： #pragma warning( push ) #pragma warning( disable : 4705 ) #pragma warning( disable : 4706 ) #pragma warning( disable : 4707 ) // Some code #pragma warning( pop ) 在这些代码的结束，pop恢复了所有警告的状态（包括4705，4706和4707）到代码开始时候的样子。 当你编写头文件时，你能用push和pop来保证任何用户修改的警告状态不会影响正常编译你的头文件。在头文件开始的地方使用push，在结束地方使用pop。例如，假定你有一个不能顺利在4级警告下编译的头文件，下面的代码改变警告等级到3，然后在头文件的结束时恢复到原来的警告等级。 #pragma warning( push, 3 ) // Declarations/ definitions #pragma warning( pop )]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试常用命令总结]]></title>
    <url>%2F2019%2F02%2F17%2F2019-02-17%2F</url>
    <content type="text"><![CDATA[1 简介​ GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下： GDB主要帮忙你完成下面四个方面的功能： 1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3.当程序被停住时，可以检查此时你的程序中所发生的事。 4.动态的改变你程序的执行环境。 2 生成调试信息​ 一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如： ​ gcc -g hello.c -o hello ​ g++ -g hello.cpp -o hello ​ 如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 3 启动GDB的方法​ gdb program ​ program 也就是你的执行文件，一般在当前目录下。 4 程序运行上下文4.1 程序运行参数​ set args 可指定运行时参数。（如：set args 10 20 30 40 50 ） ​ show args 命令可以查看设置好的运行参数。 ​ run 启动程序 4.2 工作目录​ cd 相当于shell的cd命令。 ​ pwd 显示当前的所在目录。 5 设置断点5.1 简单断点​ break 设置断点，可以简写为b ​ b 10 设置断点，在源程序第10行 ​ b func 设置断点，在func函数入口处 5.2 多文件设置断点​ 在进入指定函数时停住: ​ C++中可以使用class::function或function(type,type)格式来指定函数名。如果有名称空间，可以使用namespace::class::function或者function(type,type)格式来指定函数名。 ​ break filename:linenum – 在源文件filename的linenum行处停住 ​ break filename:function – 在源文件filename的function函数的入口处停住 ​ break class::function或function(type,type) – 在类class的function函数的入口处停住 ​ break namespace::class::function – 在名称空间为namespace的类class的function函数的入口处停住 5.3 查询所有断点​ info b 6条件断点​ 一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。 ​ 设置一个条件断点 ​ b test.c:8 if intValue == 5 7 维护停止点​ delete [range…] 删除指定的断点，如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。 ​ 比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。 ​ disable [range…] ​ disable所指定的停止点，如果什么都不指定，表示disable所有的停止点。简写命令是dis. ​ enable [range…] ​ enable所指定的停止点，如果什么都不指定，表示enable所有的停止点。简写命令是ena. 8 调试代码​ run 运行程序，可简写为r ​ next 单步跟踪，函数调用当作一条简单语句执行，可简写为n ​ step 单步跟踪，函数调进入被调用函数体内，可简写为s ​ finish 退出进入的函数 ​ until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。 ​ continue 继续运行程序，可简写为c 9 查看运行时数据​ print 打印变量、字符串、表达式等的值，可简写为p ​ p count 打印count的值 10 自动显示​ 你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。 ​ display 变量名 ​ info display – 查看display设置的自动显示的信息。 ​ undisplay num（info display时显示的编号） ​ delete display dnums… – 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5） ​ disable display dnums… ​ enable display dnums… ​ disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。 11. 查看修改变量的值​ (gdb) ptype width – 查看变量width的类型 ​ type = double ​ (gdb) p width – 打印变量width 的值 ​ $4 = 13 ​ 你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如： ​ (gdb) set var width=47 ​ 在你改变程序变量取值时，最好都使用set var格式的GDB命令。 12 显示源代码​ GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上 –g 的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后， ​ GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。默认打印10行，还是来看一看查看源代码的GDB命令吧。 ​ list linenum ​ Print lines centered around line number linenum in the current source file. ​ list function ​ 显示函数名为function的函数的源程序。 ​ list ​ 显示当前行后面的源程序。 ​ list - ​ 显示当前行前面的源程序。 ​ 一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。 ​ set listsize count ​ 设置一次显示源代码的行数。(unless the list argument explicitly specifies some other number) ​ show listsize ​ 查看当前listsize的设置。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>gdb调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛云测试域名到期图片转移腾讯云COS过程]]></title>
    <url>%2F2019%2F02%2F16%2F2019-02-16-1%2F</url>
    <content type="text"><![CDATA[今天终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用，希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～ 备份七牛云图片到本地批量下载七牛云图片到本地的步骤1、下载以下工具包解压到当地硬盘，比如 D 盘，那么解压之后就获得一个 qiniu 文件夹，里面包含有两个文件，分别是 qshell.conf 和 qshell.exe 文件。 批量下载七牛云图片到本地工具包（密码: xp1p） 2、用记事本或者 Notepad++ 软件打开 qshell.conf 文件，然后根据里面的要求填写相应的内容并保存。完成之后大概如下： 123456789101. &#123;2. &quot;dest_dir&quot; : &quot;//images&quot;,3. &quot;bucket&quot; : &quot;blog&quot;,4. &quot;domain&quot; : &quot;http://********.com&quot;,5. &quot;access_key&quot; :&quot;******************&quot;,6. &quot;secret_key&quot; :&quot;******************&quot;,7. &quot;is_private&quot; :false,8. &quot;prefix&quot; : &quot;&quot;,9. &quot;suffix&quot; : &quot;&quot;10. &#125; 其中 access_key 和 secret_key 的值可以在七牛云后台中的个人中心的密钥管理中获得。 3、运行电脑的 CMD，比如刚才我们是解压在 D 盘，那么就在CMD 中分别输入 d:、cd qiniu 和 qshell qdownload 10 qshell.conf 命令后即可自动下载七牛云的图片到本地指定的文件夹中，其中最后一条命令的 10 就是 10 线程的意思，一般是越大越快。 一般情况下等待一段时间就会自动下载完毕，我这次下载了带有前缀 boke112 的图片，图片不多，所以很快就下载完了。 申请腾讯云自行申请。 批量替换文章里的图片链接本人参考网上一篇批量修改文件内容的Python代码，魔改后。成功实现了批量修改本地Markdown文章图片链接。下面把Python代码贴出来供大家参考，轻拍～（Python版本2.7） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding=utf-8#可加入中文注释#!/usr/bin/python# -*- coding: UTF-8 -*-#函数功能：将指定文件夹下所有文件和子文件夹下的文件遍历，并修改文件内容import osfpath =&quot;/Users/fsf/PycharmProjects/Python2_tencentcloud/test&quot;#这里是你的第一级文件夹的路径def filechanger(path): filenames = os.listdir(path)#将path路径下的所有文件名存入列表filenames for filename in filenames:#循环遍历每个文件 domain = os.path.abspath(path)#获取规范的路径 filename = os.path.join(domain,filename)#带路径的文件名 if os.path.isdir(filename): # 如果是文件夹进入递归 filechanger(filename) continue fread = open(filename,&apos;r&apos;) fwrite = open(&quot;%s.backup&quot;%filename,&apos;w&apos;) for line in fread.readlines(): src_str = line if src_str.find(&apos;![&apos;) != -1: start = src_str.index(&apos;![&apos;) + 2 end = src_str.index(&apos;](&apos;) sub = src_str[start:end] start1 = end + 2 end1 = src_str.index(&apos;)&apos;) sub1 = src_str[start1:end1] sub2 = src_str[(end1 - 4):end1] s1 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/&apos; s11 = &apos;https://xxxxxxxxx-3334.cos.ap-hongkong.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7&apos; # sub3 = src_str[:start1] + &apos;../images/&apos; + sub + sub2 + src_str[end1] + src_str[(end1+1):] s2 = sub + sub2 + src_str[end1] + src_str[(end1+1):] if src_str[start:(start + 12)] == &apos;屏幕快照&apos;: s22 = s11 + src_str[(start + 12):end] + sub2 + src_str[end1] + src_str[(end1+1):] sub3 = src_str[:start1] + s22.replace(&apos; &apos;, &apos;%20&apos;) else: sub3 = src_str[:start1] + s1 + s2.replace(&apos; &apos;,&apos;%20&apos;) fwrite.write(sub3) # 修改后写入新文件 print(sub3) else: fwrite.write(src_str) print(src_str) continue fread.close() fwrite.close() os.remove(filename)#如果想更改数据后想保留原文件以及修改文件名可屏蔽这一句和下一句 os.rename(&quot;%s.backup&quot; % filename, filename)#filechanger(fpath) 自18年9月，终于把七牛云到期的测试域名所属空间的博客照片迁移到腾讯云。腾讯云有一定量免费空间供用户使用（发博文时免费额度：50 GB 标准存储容量，10 GB CDN 回源流量，100 万次读请求，100 万次写请求。费用实例），希望腾讯云短期内不要出对没钱用户的制裁条款。当然，出了我们也不用慌，再迁移便是，正所谓不折腾不舒服斯基。果然免费的都是要付出其它代价的～]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不蒜子统计失效问题解决]]></title>
    <url>%2F2019%2F02%2F16%2F2019-02-16%2F</url>
    <content type="text"><![CDATA[关于hexo想要开启站点统计，只需找到_config.yml配置文件，把busuanzi_count的enable设置为true即可。但近期，这个不蒜子的统计功能就失效了。查阅了不蒜子官方的说法， “因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！” 由于七牛云9月底强行关闭测试域名，导致本博客在七牛云存的所有图片也无法正常加载了。 具体操作找到原来不蒜子的域名文件，并替换掉旧的域名。 文件路径：\themes\next\layout_third-party\analytics\busuanzi-counter.swig，只需要替换src对应的域名即可，如下是替换后的域名。 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[默剧]]></title>
    <url>%2F2018%2F12%2F11%2F2018-12-11%2F</url>
    <content type="text"><![CDATA[默剧 浅悠悠(摘星集)12.11 1 霏霏思雨， 雨里等你， 不念凄寂， 只念你。 2 借一方清水涟漪， 泛起眷恋的气息。 你无声色的思绪， 是我解不开的迷。 3 你我此刻的局， 像演一出默剧。 静静观戏的你， 从不发表建议。 留下我， 也沉默在这孤单角色里。 4 一纸夙愿， 写进风里。 青骢双骑， 想和你。 5 借一曲寂寥旋律， 点缀这孤独的戏。 没有言语的默剧， 我用风雨吸引你。 6 说不出的千言万语， 丢在风里， 把这独角戏的结局， 寄在雨里。 淋着雨， 盼着你储存温度的消息。 7 寒风十里， 我在等雨。 风里雨里， 不见你。 8 借一道惊雷霹雳， 撕裂无言的默剧。 期待下一场大雨， 洗刷过往的回忆。 9 将那洗不掉的泪痕， 淹没心底， 你我没有句点的剧， 绝口不提。 留下你， 是我心口掩不住的秘密。 10 相逢似雨， 遥遥无期。 从此， 只爱清酒， 不爱你。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战焦作日常小练之PrimeGame]]></title>
    <url>%2F2018%2F11%2F21%2F2018-11-21%2F</url>
    <content type="text"><![CDATA[Given a suqence of nn integers a_iai. Let \text{mul}(l, r) = \prod_{i = l}^{r} a_imul(l,r)=∏i=lrai and \text{fac}(l, r)fac(l,r) be the number of distinct prime factors of \text{mul}(l, r)mul(l,r). Please calculate \sum_{i = 1}^{n}\sum_{j = i}^{n}\text{fac}(i, j)∑i=1n∑j=infac(i,j) InputThe first line contains one integer nn (1 \le n \le 10^61≤n≤106) \text{—}— the length of the sequence. The second line contains nn integers a_iai (1 \le i \le n, 1 \le a_i \le 10^61≤i≤n,1≤ai≤106) \text{—}— the sequence. OutputPrint the answer to the equation. 样例输入1复制121099 62 10 47 53 9 83 33 15 24 样例输出1复制1248 样例输入2复制12106 7 5 5 4 9 9 1 8 12 样例输出2复制1134 题目来源ACM-ICPC Nanjing Onsite 2018 题意 n个数，求所有[i,j]区间内每个数不重复的素数因素之和。 题解 将每个数分解成不同素数之积。例如例1，99分解成3和11，62分解成2和31，10分解成2和5，47分解成47，53为53，9为3，83为83，33为3和11，15为3和5，24为2和3。 第1个数出现次数为n次，第2个为(n-1) 2次，第3个为(n-3) 3次……则素数因数不重复的前提下和母数出现次数相同。但由于某些区间存在相同素数，所以我们规定假设某一位数的素数因数p所在位置为c,上一个这个素数p位置为b，则这次这个素数p出现次数为(n + 1 - c) * (c - b)。当然所以素数的初始位置为0，没出现一次就将该位置更新。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e6+7;struct NODE&#123; int size; ll prime[20];&#125;node[maxn];int n;int pos[maxn];bool isPrime[maxn];void init()&#123; for(ll i = 2; i &lt; maxn; i++)&#123; if(!isPrime[i])&#123; node[i].prime[node[i].size++] = i; for(ll j = i+i; j &lt; maxn; j+=i)&#123; isPrime[j] = true; node[j].prime[node[j].size++] = i; &#125; &#125; &#125;&#125;int main()&#123; init(); scanf(&quot;%d&quot;, &amp;n); ll ans = 0; for(int i = 1; i &lt;= n; i++)&#123; ll tmp; scanf(&quot;%lld&quot;, &amp;tmp); for(int j = 0; j &lt; node[tmp].size; j++)&#123; ans += (ll)(n + 1 - i)*(i - pos[node[tmp].prime[j]]); pos[node[tmp].prime[j]] = i; &#125; &#125; printf(&quot;%lld\n&quot;, ans); return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求最小的有2^(500500)个因子的数]]></title>
    <url>%2F2018%2F11%2F18%2F2018-11-18%2F</url>
    <content type="text"><![CDATA[我们知道，120有16个因子(不信自己数一数)。事实上120也是最小的有16个因子的数。 请你找出最小的有2的500500次方个因子的数。 因为数据过大，可以结果对500500507取模。 思路： 以120为例，120的质因数分解为2*2*2*3*5。那么和16有什么关系呢？很明显，从这5个数中随机选[0-5]个数共有多少种方法呢。刚好16种。及4*2*2种。2有4种选法，3有2种（选或不选），5也2种。所以组合方式为16种。 现在看这道题，2^500500个因子，与2相关，1个素数p有2^1种，3个p有2^2种，7个有1^3种…… 现在我们有500500个位置，那么1个p占1位，若p有多个，则剩下的2个占1位，然后剩下的4个1位，8个1位……而2^32已经超int范围了，所以次方最大为16。然后我们打表求出前500500个素数，对着500500个素数中分别插入2^2,2^4,2^8,2^16,3^2,3^4,3^8,5^2……插入的前提是p^n要小于500500个数中的最大数。最后求出这500500个数之后，只需相乘就是该数了。有了思路就可以写代码了。 答案取模500500507后为35407281 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 500500507;const ll mi = 500500+1;const ll maxn = 2e7;ll a[4] = &#123;2, 4, 8, 16&#125;;ll prime[mi+100];ll check[maxn], tot;void init()&#123; memset(check, 0, sizeof(check)); prime[tot++] = 1; for (ll i = 2; i &lt; maxn; ++i)&#123; if(!check[i])&#123; prime[tot++] = i; &#125; if(tot == mi)&#123; break; &#125; for (ll j = 1; j &lt; tot; ++j)&#123; if (i * prime[j] &gt; maxn)&#123; break; &#125; check[i*prime[j]] = 1; if (i % prime[j] == 0)&#123; break; &#125; &#125; &#125;&#125;ll Pow(ll a, ll b)&#123; ll ans = 1; for(ll i = 1; i &lt;= b; i++)&#123; ans *= a; if(ans &gt; prime[tot-1])&#123; ans = prime[tot-1]+1; break; &#125; &#125; return ans;&#125;int main()&#123; init(); priority_queue&lt;ll&gt;que; que.push(1); ll Size = 1; ll Top = 4; for(ll i = 1; i &lt; mi; i++)&#123; if(Size &gt;= mi)&#123; if(prime[i] &gt;= que.top())&#123; break; &#125; else&#123; que.pop(); que.push(prime[i]); for(ll j = 0; j &lt; Top; j++)&#123; if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123; Top = j; break; &#125; if(Pow(prime[i], a[j]) &gt;= que.top())&#123; Top = j; break; &#125; else&#123; que.pop(); que.push(Pow(prime[i], a[j])); &#125; &#125; &#125; &#125; else&#123; que.push(prime[i]); Size++; for(ll j = 0; j &lt; Top; j++)&#123; if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123; Top = j; break; &#125; if(Size &gt;= mi)&#123; if(Pow(prime[i], a[j]) &gt;= que.top())&#123; Top = j; break; &#125; else&#123; que.pop(); que.push(Pow(prime[i], a[j])); &#125; &#125; else&#123; if(Pow(prime[i], a[j]) &gt;= prime[tot-1])&#123; Top = j; break; &#125; que.push(Pow(prime[i], a[j])); Size++; &#125; &#125; &#125; &#125; ll ans = 1; int SI = 0; while(!que.empty())&#123; ans *= que.top(); que.pop(); ans%=mod; SI++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[昨世今生]]></title>
    <url>%2F2018%2F11%2F09%2F2018-11-09%2F</url>
    <content type="text"><![CDATA[author：浅悠悠 致亲人，致自己 5岁， 你的梦想是什么呢？ emm，环游世界！ 为什么呢？ 爷爷之前说的。 9岁，告别了童言无忌 然而玩耍依然是最大的乐趣。 那些年，是记忆里的伊甸园。 12岁，你开始了奋发学习 你并不理解知识改变命运， 但你却依旧坚持， 为了心中的荣誉。 那些年，你的理想是北大清华。 15岁，你读了高中 开始憧憬大人们的生活， 也开始尝试各种偶像剧。 你喜欢看好莱坞，听飞轮海。 你学明星留起了长发， 也在心里默默藏起了一个她。 17岁，快要高考了 你却接受了各式文化的洗礼， 渐渐喜欢弹琴写词， 喜欢吟诗作画， 喜欢古典音乐与欧美文学， 喜欢听《为你写诗》，看她笑靥如花 。 那些年，你眼里只有她。 18岁，你踏上了大学生活 昔日的她也断了联系。 你开始学李清照多愁善感， 也学苏轼一笑释然。 时而感时花溅泪， 时而欲与天公试比高。 那一年，你的理想是文学与艺术。 20岁，大二刚刚结束 你开始后悔两年的蹉跎， 也明白了人生几何。 身边有几个一直陪伴你的红颜， 但你每次都觉得和那个她比， 差了一点。 你封闭起自己奋发图强， 渐渐厌倦了与别人的交流， 却渴望着别人的理解。 那些年，你的理想是出人头地。 22岁，即将毕业 却发现很难找到一份令自己满意的工作， 你渐渐明白很多事情不是由自己决定。 你收起了曾经的轻狂， 也渐渐学着别人假装。 你开始喜欢看周星驰，听毛不易。 那一年，你的理想是找到一份稳定的工作。 24岁，忙碌的工作压得你喘不过气 看尽了天外有天有无常， 山外有山有他乡， 你已忘却了喜怒无常， 凡事都一笑而过。 你穿梭于各个城市之间， 有时也常常想起曾经环游世界的梦想， 但也只能感慨马路的纵横交错。 那些年，你只想轻松一点。 26岁，你依旧孑然一身 随着年纪增长的， 除了脱单的朋友们， 还有送去各种礼金。 过节回家，父母从带你串亲戚， 变成了催你找对象。 而你每次都是推辞说忙， 或者配不上别人家的姑娘。 28岁，你遇见了一个和你境遇类似的姑娘 初次见面，简单地交涉， 彼此没有脸红，也没有心跳，只剩下尴尬。 终于她喝了一口浓咖啡说，你还不错。 你愣了一下，说，你也不错。 29岁，你们结婚了 你并不确定她是否真的喜欢你， 就像你不确定是否真的喜欢她， 只是双方父母一直在催促。 攒了几年去实现理想的钱， 全部用在了这场婚宴上。 婚前的酒宴，朋友来的不多也不少。 你醉后对朋友说，不想结婚， 朋友说，你只是喝多了，想多了。 30岁，渐渐升职 独自负责几个项目， 管理几个刚毕业的入职者。 然而她怀孕了，辞掉了工作， 于是你又每日加班。 电话那边总是抱怨， 但你却不能争辩什么。 那些年，你的理想是简单安稳的生活。 31岁，有了孩子 大大小小的费用又花去了一笔钱， 不过都无所谓， 你看着你的孩子， 心中满是欣慰。 那一年，你的全部只为孩子。 32岁，人生最忙碌的一年， 孩子24小时的折腾， 第二天拖着疲惫的身体上班， 老板说你上班不干活， 回家媳妇说你不干活， 你想了半天也没明白，那谁干的活呢。 那些年，你不再提起理想。 35岁，你的身体越来越差， 加班越来越少， 晋升也越来越慢， 而孩子也要开始上幼儿园了， 各种培训机构与学费又花去了不少积蓄， 那一年，你本打算给自己过个生日，换个新电脑 40岁，曾经宣告世界的理想已不知去何方。 你常常希望将曾经未完成的心愿寄托给孩子， 但望着尚未还完的房贷，你笑笑摇摇头。 一天，他对你说，爸，我想学钢琴。 你没什么犹豫的，这些年你已经习惯了， 但那句“爸爸现在买不起”你始终说不出口。 孩子很懂事，说：爸爸没事，我学吉他也可以。 你看着这么懂事的孩子，却开心不起来。 那些年，你不再提起那些年。 50岁，孩子上了大学 他学的专业你有点不懂， 你知道工作不好找， 你和他深夜聊聊， 准备了四两白酒， 你说着那些曾经你最讨厌的话， 你们从交流变成了争吵， 你发现，你老了，老到可能都打不过这个18岁的孩子。 你说不过他，只能说一句：我是你爸！ 孩子看着你，知道再怎么争辩都没用， 这场确立你最后威严的酒局不欢而散， 在孩子回自己屋的路上叨叨了一句 “我不想活成你那样” 。 50岁的人了，怎么就哭了呢？ 一定是酒太烈了， 对，一定是酒太烈了 54岁，孩子也工作了 似乎有一点理解你了， 但你却反了过来， 告诉他说不要妥协 。 55岁，孩子结婚了 你问他，你喜欢他吗。 他愣了愣，喜欢吧。 60岁，有时间旅行了 你和老伴准备好了， 孩子却说：爸妈，我工作忙了。 帮我照顾一下孩子。 你们退了机票， 又回到了30年前 65岁，孩子的孩子也上学了 你下定决心说：一定要环游世界， 可是手边的拐杖， 只能支撑你走到楼下花园。 68岁，你已走到了人生的尽头。 你躺在医院的病床上， 望着窗外泛黄的枯叶不知何时落下来。 你迷迷糊糊的看见医生摇了摇头， 你明白了，你要死了。 你并没有感到害怕。 你这一生，无怨无悔。 只是，有好多遗憾啊。 听说，人死时是最清醒的。 因为那时你的大脑里会倒叙你的一生。 生命的倒叙走向了最后一秒， 忽然间，身边的人哭了，你却笑了。 原来画面又回到了18岁的离别季， 那一天离别前，你们端坐在操场的石凳上， 各自心中思绪万千，嘴上却沉默无言。 终于，你放下了腼腆， 攥紧了她的手， 笑着对她说， 往后余生， 愿你拥有全部的权力， 而我愿拥有全部的义务。]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割求解最大权闭合子图]]></title>
    <url>%2F2018%2F10%2F10%2F2018-10-10%2F</url>
    <content type="text"><![CDATA[定义有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 如下图： 能选的子图有Ø,{4},{3,4},{2,4},{1,2,3,4},它们的权值分别为0,-1,5,-6,4. 所以最大权闭合子图为{3,4}，权值为5. 解法这个问题可以转化为最小割问题，用网络流解决。 从源点s向每个正权点连一条容量为权值的边，每个负权点向汇点t连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和-最小割）。 如何理解割掉一条边的含义由于原图的边都是无穷大，那么割边一定是与源点s或汇点t相连的。 割掉s与i的边，表示不选择i点作为子图的点； 割掉i与t的边，表示选择i点为子图的点。 如果s与i有边，表示i存在子图中； 如果i与t有边，表示i不存在于子图中。 合法性只有s与t不连通时，才能得到闭合子图。 如果s与t连通，则存在点i,j，使得s到i有边，i到j连通，j到t有边，所以j一定是i的后继，但选择了i，没有选择j，不是闭合子图。 如果s与t不连通，选择了正权点i，一定选择了i后继中的所有负权点。设j是i的后继中的正权点，则割掉s到j的边是没有意义的，最小割不会割掉它，则j一点被选中，所以i的所有后继都被选中，符合闭合图的定义。 最优性最小割=(不选的正权之和+要选的负权绝对值之和） 最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割 因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。 例题POJ2987_Firing]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统三大经典同步问题]]></title>
    <url>%2F2018%2F10%2F09%2F2018-10-09%2F</url>
    <content type="text"><![CDATA[用专业术语来说, 进程是程序的一次动态执行.说简单点, 就是进程是系统中的某个任务.操作系统中有多个任务需要执行, 那么怎样执行才能使它们同步呢? 即如何让任务并发执行互不影响呢? 这就引出了进程同步中的经典问题: 生产者消费者问题, 哲学家进餐问题, 读写问题 生产者-消费者问题有一群生产者进程在生产产品, 并将这些产品提供给消费者进程取消费. 为使生产者进程与消费者进程能并发进行, 在两者间设置了一个具有n个缓冲区的缓冲池, 生产者进程将其所生产的产品翻入缓冲区中, 消费者进程可从一个缓冲区中取走产品取消费.生产者消费者进程都以异步方式进行, 但它们之间必须保持同步, 不允许消费者进程到空缓冲区去取产品, 也不允许生产者进程向已满的缓冲区投放产品. 一个缓冲池中有n个缓冲区, 只要缓冲池未满, 生产者便可以投放产品; 缓冲池为空, 消费者便可以消费产品 法一:记录型信号量1234567891011121314151617181920212223242526272829303132333435//生产者消费者问题//记录型信号量//缓冲池中有n个缓冲区, 互斥信号量mutex, //信号量empty表示空缓冲区数量, full表示满缓冲区的数量int in = out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; producer an item nextp; wait(empty); wait(mutex); buffer[in] = nextp; in = (in + 1) % n; signal(mutex); signal(full); &#125; while(true);&#125;void consumer() &#123; do &#123; wait(full); wait(mutex); nextc = buffer[out]; out = (out + 1) % n; signal(mutex); signal(empty); consumer the item in nextc; &#125; while(true);&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 注意: 对信号量的wait()和signal()操作必定是成对出现的. 法二:AND型信号量1234567891011121314151617181920212223242526272829303132//AND型信号量//Swait(empty, mutex)代替wait(empty)和wait(mutex)//Ssignal(mutex,full)代替signal(mutext)和signal(full)//Swait(full, mutex)代替wait(full)和wait(mutex)//Ssignal(mutex, empty)代替signal(mutex)和signal(empty)int in = out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; producer an item nextp; Swait(empty, mutex); buffer[in] = nextp; in = (in + 1) % n; Ssignal(mutex, full); &#125; while(true);&#125;void consumer() &#123; do &#123; Swait(full, mutex); nextc = buffer[out]; out = (out + 1) % n; Ssignal(mutex, empty); consumer the item in nextc; &#125; while(true);&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 法三: 管程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//管程//建立管程producerconsumer,PC/*put(x), 生产者利用该过程将自己生产的产品投放到缓冲池中, 并用整型变量count表示缓冲池中已有的产品数目,当count&gt;=N时, 表示缓冲池已满,生产者需等待.get(x), 消费者利用该过程从缓冲池中取出一个产品, 当count&lt;=0时, 表示缓冲池已无可用的产品, 消费者需等待condition 为notfull和notemptycwait(condition), 当管程被一个进程占用时, 其他进程调用该进程时阻塞, 并挂在条件condition的队列上csignal(condition), 唤醒在cwait执行后阻塞在条件condition队列上的进程, 如果这样的进程不止一个, 则选择其中一个实施唤醒操作, 如果队列为空, 则无操作而返回.*/Monitor producerconsumer &#123; item buffer[N]; int in, out; condition notfull, notempty; int count; public: void put(item x) &#123; if (count &gt;= N) cwait(notfull); buffer[in] = x; in = (in + 1) % N; count++; ssignal(notempty); &#125; void get(item x) &#123; if (count &lt;= 0) cwait(notempty); x = buffer[out]; out = (out + 1) % N; count--; csignal(notfull); &#125; &#123; in = 0; out = 0; count = 0; &#125;&#125;PC;void producer() &#123; item x; while (true) &#123; producer an item in nextp; PC.put(x); &#125;&#125;void consumer() &#123; item x; while (true) &#123; PC.get(x); consumer the item in nextc; &#125;&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 哲学家进餐问题五个哲学家公用一张圆桌, 分别坐在周围的五张桌子上, 在圆桌上有五个碗和五只筷子交叉排列, 它们的生活方式是交替的进行思考和进餐. 哲学家进行思考时不用筷子, 饥饿时取一只他两边的任意一只筷子(默认取左边的筷子, 没有时取右边的, 都没有时就取不了), 当他有两只筷子时就能进餐. 进餐后, 放下筷子继续思考.若只有一只筷子, 不放弃该筷子并等待拥有另一只筷子时再进餐. 用一个信号量表示一只筷子, 共五个信号量 semaphore chopsitck[5] = {1, 1, 1, 1, 1}; , 为 1 表示筷子未拿起, 为0表示筷子被拿起.那么第i为科学家的进餐活动就可以描述为 法一:记录型信号量12345678do &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); //eat signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); //think&#125; while (true); 假设五位哲学家都要拿筷子(都拿左手边), 那么将没有人可以 用餐, 就会陷入死锁状态.则哲学家进餐的解决方法: 1.至多允许四位哲学家拿同一边的筷子, 则可让至少一位哲学家先用餐, 用餐完后释放筷子进而让其他哲学家有机会用餐. 2.五位哲学家先竞争奇数(偶数)好筷子, 在竞争偶数(奇数)号筷子, 总会有一位哲学家能进餐. 法二: AND型信号量12345678//AND型信号量semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;do &#123; //think Swait(chopsitck[(i + 1) % 5], chopsitck[i]); //eat Ssignal(chopsitck[(i + 1) % 5], chopsitck[i]);&#125; while (true); 读者-写者问题一个数据文件或记录可被多个进程所共享, 则我们称这个文件或记录为共享对象.读文件的进程称为Reader进程, 写文件的进程称为Writer进程.共享对象可以被多个Reader进程, 因为读进程并不会破坏数据, 但是Writer进程在任何时刻只能有一个, 且须与其他对象互斥的访问共享对象, 否则多个写进程会造成冲突. 读写者问题即一个Writer进程必须与其他进程互斥的访问共享对象. 设置写互斥信号量wmutex 设置读互斥信号量rmutex 整型变量readcount表示正在读的进程数目(Reader) 当readcount!=0时, 表示有Reader进程,此时不能进行Writer进程. 法一: 123456789101112131415161718192021222324252627282930313233343536//记录型信号量semaphore rmutext = 1, wmutext = 1;int readcount = 0;void Reader() &#123; do &#123; wait(rmutex); if (readcount == 0) &#123; wait(wmutex); &#125; readcount++; signal(rmutex); perform read operation; wait(rmutex); readcount--; if (readcount == 0) &#123; signal(wmutext); &#125; signal(rmutex); &#125; while (true);&#125;void Writer() &#123; do &#123; wait(wmutex); perform write operation; signal(wmutex); &#125; while (true);&#125;void main() &#123; cobegin Reader(); Writer(); coend&#125; 法二: 引入RN, 表示最多允许RN个Reader进程同时读 信号量L初始为RN 123456789101112131415161718192021222324252627//信号量集int RN;semaphore L = RN, mx = 1;void Reader() &#123; do &#123; Swait(L, 1, 1); Swait(mx, 1, 0); perform read operation; Ssignal(L, 1); &#125; while (true);&#125;void Writer() &#123; do &#123; Swait(mx, 1, 1; L, RN, 0); perform write operation; Ssignal(mx, 1); &#125; while (true);&#125;void main() &#123; cobegin Reader(); Writer(); coend&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强连通图经典算法——Tarjan算法]]></title>
    <url>%2F2018%2F10%2F08%2F2018-10-08%2F</url>
    <content type="text"><![CDATA[Tarjan 算法 一.算法简介 Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。 我们定义： 如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 例如：在上图中，{1 , 2 , 3 , 4 } , { 5 } , { 6 } 三个区域可以相互连通，称为这个图的强连通分量。 Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。 再Tarjan算法中，有如下定义。 DFN[ i ] : 在DFS中该节点被搜索的次序(时间戳) LOW[ i ] : 为i或i的子树能够追溯到的最早的栈中节点的次序号 当DFN[ i ]==LOW[ i ]时，为i或i的子树可以构成一个强连通分量。 二.算法图示 以1为Tarjan 算法的起始点，如图 顺次DFS搜到节点6 回溯时发现LOW[ 5 ]==DFN[ 5 ] , LOW[ 6 ]==DFN[ 6 ] ,则{ 5 } , { 6 } 为两个强连通分量。回溯至3节点，拓展节点4. 拓展节点1 ， 发现1再栈中更新LOW[ 4 ]，LOW[ 3 ] 的值为1 回溯节点1，拓展节点2 自此，Tarjan Algorithm 结束，{1 , 2 , 3 , 4 } , { 5 } , { 6 } 为图中的三个强连通分量。 不难发现，Tarjan Algorithm 的时间复杂度为O(E+V). 1234567891011121314151617181920212223void Tarjan ( int x ) &#123; dfn[ x ] = ++dfs_num ; low[ x ] = dfs_num ; vis [ x ] = true ;//是否在栈中 stack [ ++top ] = x ; for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123; int temp = e[ i ].to ; if ( !dfn[ temp ] )&#123; Tarjan ( temp ) ; low[ x ] = gmin ( low[ x ] , low[ temp ] ) ; &#125; else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ; &#125; if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量 vis[ x ] = false ; color[ x ] = ++col_num ;//染色 while ( stack[ top ] != x ) &#123;//清空 color [stack[ top ]] = col_num ; vis [ stack[ top-- ] ] = false ; &#125; top -- ; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>Tarjan算法</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM算法专用模板(持续更新中)]]></title>
    <url>%2F2018%2F10%2F05%2F2018-10-05%2F</url>
    <content type="text"><![CDATA[标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，母函数，斯特林数，卡特兰数，莫比乌斯反演，SG函数与Nim博弈，奇异函数与Wythoff博弈，并查集，线段树，主席树，树状数组，ST表，LCA，BM算法，KMP，Trie树，AC自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim等等。 数据结构基础并查集12345678910111213141516int fa[maxn];void init()&#123; for(int i = 0; i &lt; maxn; i++)&#123; fa[i] = i; &#125;&#125;int root(int x)&#123; return x==fa[x] ? x : x=root(fa[x]);&#125;void Union(int px, int py)&#123; px = root(px); py = root(py); if(px != py)&#123; fa[py] = px; &#125;&#125; 并查集路径压缩按雉合并12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+7;int fa[maxn],r[maxn];int a[maxn];int n,m;void init()&#123; for(int i=0;i&lt;=n;i++)&#123; fa[i]=i; r[i]=1; &#125;&#125;int Find(int x)&#123; return x==fa[x]?x:Find(fa[x]);&#125;void Merge(int x,int y)&#123; int t1=Find(x),t2=Find(y); if(t1==t2) return ;//已合并返回 if(r[t1]&gt;r[t2]) fa[t2]=t1; //把y的祖先t2和并到x的祖先t1上。因以t1为根的树更高 else &#123; fa[t1]=t2; if(r[t1]==r[t2]) r[t2]++; //若两树一样高，那么合并后，高度加一。 &#125;&#125;int sum[maxn];int main()&#123; cin&gt;&gt;n; init(); memset(sum,0,sizeof(sum)); for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; cin&gt;&gt;m; while(m--)&#123; int flag,x,y,z; cin&gt;&gt;flag; if(flag==1)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; int cnt=0; for(int j=y+1;j&lt;=z;j++)&#123; Merge(j,j-1); cnt+=a[j]; &#125; Merge(x,y); cnt+=a[y]; sum[fa[x]]+=cnt; &#125; else&#123; cin&gt;&gt;x&gt;&gt;y; sum[fa[x]]=sum[fa[x]]-a[x]+y; &#125; &#125; int minn=0x3f3f3f3f; for(int i=1;i&lt;=n;i++)&#123; if(fa[i]==i)&#123; minn=min(minn,sum[fa[i]]); &#125; &#125; cout&lt;&lt;minn&lt;&lt;endl; return 0;&#125; 加权并查集12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 2e5+5;int n,m,s[N],p[N],ans;void init()&#123; ans=0; memset(s,0,sizeof(s)); for(int i=0;i&lt;N;i++) p[i]=i;&#125;int fd(int x) &#123; ///此时find不单有查找任务，还有更新距离任务 if(x==p[x]) return x; int t=p[x]; p[x]=fd(p[x]); s[x]+=s[t]; ///记录到根节点的距离，一定要有一个思想，根节点是一个区间的一个端点而不是一个区间，输入的区间被合并成了两个点 return p[x];&#125;void Union(int a,int b,int num) &#123; int x=fd(a),y=fd(b); if(x==y) &#123; if(s[b]!=s[a]+num) ans++; &#125;else &#123; p[y]=x; s[y]=s[a]+num-s[b]; ///y到x的距离等于a到x的距离+b到a的距离-b到y的距离 &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; init(); for(int i=0;i&lt;m;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; Union(a-1,b,c); ///等价于Union(a,b+1,c); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 单调队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn=1e6+7;int a[maxn];int maxq[maxn];int minq[maxn];int q[maxn];int n,k;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); while(cin&gt;&gt;n&gt;&gt;k)&#123; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int head,tail,t; memset(q,0,sizeof(q)); head=1,tail=1; q[tail]=1; minq[1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; while(head&lt;=tail&amp;&amp;a[i]&lt;a[q[tail]]) tail--; q[++tail]=i; if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1) head++; minq[i]=a[q[head]]; &#125; memset(q,0,sizeof(q)); head=1,tail=1; q[tail]=1; maxq[1]=a[1]; for(int i=2;i&lt;=n;i++)&#123; while(head&lt;=tail&amp;&amp;a[i]&gt;a[q[tail]]) tail--; q[++tail]=i; if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1) head++; maxq[i]=a[q[head]]; &#125; for(int i=k;i&lt;n;i++) cout&lt;&lt;minq[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;minq[n]&lt;&lt;endl; for(int i=k;i&lt;n;i++) cout&lt;&lt;maxq[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;maxq[n]&lt;&lt;endl; &#125; return 0;&#125; 链式前向星12345678910111213141516int head[maxn], cnt;struct EDGE&#123; int next, to, u, w;&#125;edge[maxm];void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].u = u; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; cnt = 0; memset(head, -1, sizeof(head)); //memset(edge, 0, sizeof(edge));&#125; 树结构树状数组123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;int n,m,i,num[100001],t[200001],l,r;//num:原数组；t：树状数组int lowbit(int x)&#123; return x&amp;(-x);&#125;void change(int x,int p)//将第x个数加p&#123; while(x&lt;=n) &#123; t[x]+=p; x+=lowbit(x); &#125; return;&#125;int sum(int k)//前k个数的和&#123; int ans=0; while(k&gt;0) &#123; ans+=t[k]; k-=lowbit(k); &#125; return ans;&#125;int ask(int l,int r)//求l-r区间和&#123; return sum(r)-sum(l-1);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num[i]; change(i,num[i]); &#125; for(i=1;i&lt;=m;i++) &#123; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;ask(l,r)&lt;&lt;endl; &#125; return 0;&#125; 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define MAXN 100010#define inf 0x3f3f3f3fusing namespace std;struct node&#123; int l,r;//区间[l,r] int add;//区间的延时标记 int sum;//区间和 int mx; //区间最大值 int mn; //区间最小值&#125;tree[MAXN&lt;&lt;2];//一定要开到4倍多的空间void pushup(int index)&#123; tree[index].sum = tree[index&lt;&lt;1].sum+tree[index&lt;&lt;1|1].sum; tree[index].mx = max(tree[index&lt;&lt;1].mx,tree[index&lt;&lt;1|1].mx); tree[index].mn = min(tree[index&lt;&lt;1].mn,tree[index&lt;&lt;1|1].mn);&#125;void pushdown(int index)&#123; //说明该区间之前更新过 //要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新 if(tree[index].add)&#123; //替换原来的值 /* tree[index&lt;&lt;1].sum = (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add; tree[index&lt;&lt;1|1].sum = (tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add; tree[index&lt;&lt;1].mx = tree[index].add; tree[index&lt;&lt;1|1].mx = tree[index].add; tree[index&lt;&lt;1].mn = tree[index].add; tree[index&lt;&lt;1|1].mn = tree[index].add; tree[index&lt;&lt;1].add = tree[index].add; tree[index&lt;&lt;1|1].add = tree[index].add; tree[index].add = 0;*/ //在原来的值的基础上加上val tree[index&lt;&lt;1].sum += (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add; tree[index&lt;&lt;1|1].sum +=(tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add; tree[index&lt;&lt;1].mx += tree[index].add; tree[index&lt;&lt;1|1].mx += tree[index].add; tree[index&lt;&lt;1].mn += tree[index].add; tree[index&lt;&lt;1|1].mn += tree[index].add; tree[index&lt;&lt;1].add += tree[index].add; tree[index&lt;&lt;1|1].add += tree[index].add; tree[index].add = 0; &#125;&#125;void build(int l,int r,int index)&#123; tree[index].l = l; tree[index].r = r; tree[index].add = 0;//刚开始一定要清0 if(l == r)&#123; scanf(&quot;%d&quot;,&amp;tree[index].sum); tree[index].mn = tree[index].mx = tree[index].sum; return ; &#125; int mid = (l+r)&gt;&gt;1; build(l,mid,index&lt;&lt;1); build(mid+1,r,index&lt;&lt;1|1); pushup(index);&#125;void updata(int l,int r,int index,int val)&#123; if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123; /*把原来的值替换成val,因为该区间有tree[index].r-tree[index].l+1 个数，所以区间和 以及 最值为： */ /*tree[index].sum = (tree[index].r-tree[index].l+1)*val; tree[index].mn = val; tree[index].mx = val; tree[index].add = val;//延时标记*/ //在原来的值的基础上加上val,因为该区间有tree[index].r-tree[index].l+1 //个数，所以区间和 以及 最值为： tree[index].sum += (tree[index].r-tree[index].l+1)*val; tree[index].mn += val; tree[index].mx += val; tree[index].add += val;//延时标记 return ; &#125; pushdown(index); int mid = (tree[index].l+tree[index].r)&gt;&gt;1; if(l &lt;= mid)&#123; updata(l,r,index&lt;&lt;1,val); &#125; if(r &gt; mid)&#123; updata(l,r,index&lt;&lt;1|1,val); &#125; pushup(index);&#125;int query(int l,int r,int index)&#123; if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123; //return tree[index].sum; return tree[index].mx; //return tree[index].mn; &#125; pushdown(index); int mid = (tree[index].l+tree[index].r)&gt;&gt;1; int ans = 0; int Max = 0; int Min = inf; if(l &lt;= mid)&#123; ans += query(l,r,index&lt;&lt;1); Max = max(query(l,r,index&lt;&lt;1),Max); Min = min(query(l,r,index&lt;&lt;1),Min); &#125; if(r &gt; mid)&#123; ans += query(l,r,index&lt;&lt;1|1); Max = max(query(l,r,index&lt;&lt;1|1),Max); Min = min(query(l,r,index&lt;&lt;1|1),Min); &#125; //return ans; return Max; //return Min;&#125;int main()&#123; int n,m,q,x,y,z; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; build(1,n,1); while(m--)&#123; scanf(&quot;%d&quot;,&amp;q); if(q == 1)&#123; cout&lt;&lt;&quot;查询:(x,y)&quot;&lt;&lt;endl; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); cout&lt;&lt;query(x,y,1)&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;更新(x,y)为z：&quot;&lt;&lt;endl; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); updata(x,y,1,z); for(int i = 1; i &lt;= n; ++i)&#123; printf(&quot;a[%d] = %d\n&quot;,i,query(i,i,1)); &#125; &#125; &#125; &#125; return 0;&#125; 主席树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// luogu-judger-enable-o2#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[100010],hash[101000],tot,root[201000],cnt,n,m,tt,qll[200100],qrr[20000];int q1,q2,id[201000],b[201000];struct TREE&#123; int ln,rn,zhi;&#125;t[10010000];struct NODE&#123; int l,r,k,flag;&#125;q[100100];int lowbit(int x) &#123;return (x)&amp;(-x);&#125;void gai(int &amp;node,int l,int r,int hs,int v)&#123; if(!node) node=++tot; t[node].zhi+=v; if(l==r) return; int mid=(l+r)/2; if(hs&lt;=mid) gai(t[node].ln,l,mid,hs,v); else gai(t[node].rn,mid+1,r,hs,v);&#125;void add(int p,int v)&#123; hash[p]=lower_bound(a+1,a+1+tt,hash[p])-a; //cout&lt;&lt;hash[p]&lt;&lt;endl; for(int i=p;i&lt;=n;i+=lowbit(i)) gai(root[i],1,tt,hash[p],v);&#125;char s[2];int SUM()&#123; int ans1=0,ans2=0; for(int i=1;i&lt;=q1;i++) ans1+=t[t[qrr[i]].ln].zhi; for(int i=1;i&lt;=q2;i++) ans2+=t[t[qll[i]].ln].zhi; return ans1-ans2;&#125;int cha(int qr,int ql,int l,int r,int k)&#123; q1=0,q2=0; for(int i=qr;i&gt;=1;i-=lowbit(i)) qrr[++q1]=root[i]; for(int i=ql;i&gt;=1;i-=lowbit(i)) qll[++q2]=root[i]; while(l&lt;r) &#123; int lsiz=SUM(),mid=(l+r)/2; if(k&lt;=lsiz) &#123; for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].ln; for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].ln; r=mid; &#125; else &#123; for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].rn; for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].rn; l=mid+1;k-=lsiz; &#125; &#125; return l;&#125;int main()&#123; int x,y,z; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]);b[i]=a[i]; hash[++cnt]=a[i]; &#125; for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%s&quot;,s); if(s[0]==&apos;Q&apos;) scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k),q[i].flag=1; else &#123; scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r); a[++cnt]=q[i].r;hash[cnt]=a[cnt]; &#125; &#125; sort(a+1,a+1+cnt); tt=unique(a+1,a+1+cnt)-a-1; for(int i=1;i&lt;=n;i++) add(i,1); for(int i=1;i&lt;=m;i++) &#123; if(q[i].flag==1) printf(&quot;%d\n&quot;,a[cha(q[i].r,q[i].l-1,1,tt,q[i].k)]); else &#123; hash[q[i].l]=b[q[i].l]; add(q[i].l,-1); hash[q[i].l]=q[i].r; b[q[i].l]=q[i].r; add(q[i].l,1); &#125; &#125;&#125; 划分树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** 划分树（查询区间第 k 大）*/const int MAXN = 100010;int tree[20][MAXN];//表示每层每个位置的值int sorted[MAXN];//已经排序好的数int toleft[20][MAXN];//toleft[p][i] 表示第 i 层从 1 到 i 有数分入左边void build(int l,int r,int dep)&#123; if(l == r) return; int mid = (l+r)&gt;&gt;1; int same = mid − l + 1;//表示等于中间值而且被分入左边的个数 for(int i = l; i &lt;= r; i++) //注意是 l, 不是 one if(tree[dep][i] &lt; sorted[mid]) same−−; int lpos = l; int rpos = mid+1; for(int i = l; i &lt;= r; i++) &#123; if(tree[dep][i] &lt; sorted[mid]) tree[dep+1][lpos++] = tree[dep][i]; else if(tree[dep][i] == sorted[mid] &amp;&amp; same &gt; 0) &#123; tree[dep+1][lpos++] = tree[dep][i]; same−−; &#125; elsetree[dep+1][rpos++] = tree[dep][i]; toleft[dep][i] = toleft[dep][l−1] + lpos − l &#125; build(l,mid,dep+1); build(mid+1,r,dep+1);&#125;//查询区间第 k 大的数,[L,R] 是大区间，[l,r] 是要查询的小区间int query(int L,int R,int l,int r,int dep,int k)&#123; if(l == r) return tree[dep][l]; int mid = (L+R)&gt;&gt;1; int cnt = toleft[dep][r] − toleft[dep][l−1]; if(cnt &gt;= k) &#123; int newl = L + toleft[dep][l−1] − toleft[dep][L−1]; int newr = newl + cnt − 1; return query(L,mid,newl,newr,dep+1,k); &#125; else &#123; int newr = r + toleft[dep][R] − toleft[dep][r]; int newl = newr − (r−l−cnt); return query(mid+1,R,newl,newr,dep+1,k−cnt) &#125;&#125;int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)==2) &#123; memset(tree,0,sizeof(tree)); for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;,&amp;tree[0][i]); sorted[i] = tree[0][i]; &#125; sort(sorted+1,sorted+n+1); build(1,n,0); int s,t,k; while(m−−) &#123; scanf(&quot;%d%d%d&quot;,&amp;s,&amp;t,&amp;k); printf(&quot;%d\n&quot;,query(1,n,s,t,0,k)); &#125; &#125; return 0&#125; Trie树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+7;char s[maxn];int n,m;bool p;struct node&#123; int count; node * next[26];&#125;*root;node * build()&#123; node * k=new(node); k-&gt;count=0; memset(k-&gt;next,0,sizeof(k-&gt;next)); return k;&#125;void insert()&#123; node * r=root; char * word=s; while(*word) &#123; int id=*word-&apos;a&apos;; if(r-&gt;next[id]==NULL) r-&gt;next[id]=build(); r=r-&gt;next[id]; r-&gt;count++; word++; &#125;&#125;int search()&#123; node * r=root; char * word=s; while(*word) &#123; int id=*word-&apos;a&apos;; r=r-&gt;next[id]; if(r==NULL) return 0; word++; &#125; return r-&gt;count;&#125;int main()&#123; char str[11]; int i,j; root=(struct dictree*)malloc(sizeof(struct dictree)); for(i=0;i&lt;26;i++) root-&gt;child[i]=0; root-&gt;n=2; while(gets(str),strcmp(str,&quot;&quot;)!=0)&#123; insert(str); &#125; while(scanf(&quot;%s&quot;,str)!=EOF)&#123; printf(&quot;%d\n&quot;,find(str)); &#125;&#125; 伸展树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231 /* An implementation of top-down splaying D. Sleator &lt;sleator@cs.cmu.edu&gt; March 1992 */ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int size; /* number of nodes in the tree */ /* Not actually needed for any of the operations */ typedef struct tree_node Tree; struct tree_node &#123; Tree * left, * right; int item; &#125;; Tree * splay (int i, Tree * t) &#123; /* Simple top down splay, not requiring i to be in the tree t. */ /* What it does is described above. */ Tree N, *l, *r, *y; if (t == NULL) return t; N.left = N.right = NULL; l = r = &amp;N; for (;;) &#123; if (i &lt; t-&gt;item) &#123; if (t-&gt;left == NULL) &#123; break; &#125; if (i &lt; t-&gt;left-&gt;item) &#123; y = t-&gt;left; /* rotate right */ t-&gt;left = y-&gt;right; y-&gt;right = t; t = y; if (t-&gt;left == NULL) &#123; break; &#125; &#125; r-&gt;left = t; /* link right */ r = t; t = t-&gt;left; &#125; else if (i &gt; t-&gt;item) &#123; if (t-&gt;right == NULL) &#123; break; &#125; if (i &gt; t-&gt;right-&gt;item) &#123; y = t-&gt;right; /* rotate left */ t-&gt;right = y-&gt;left; y-&gt;left = t; t = y; if (t-&gt;right == NULL) &#123; break; &#125; &#125; l-&gt;right = t; /* link left */ l = t; t = t-&gt;right; &#125; else &#123; break; &#125; &#125; l-&gt;right = t-&gt;left; /* assemble */ r-&gt;left = t-&gt;right; t-&gt;left = N.right; t-&gt;right = N.left; return t; &#125; /* Here is how sedgewick would have written this. */ /* It does the same thing. */ Tree * sedgewickized_splay (int i, Tree * t) &#123; Tree N, *l, *r, *y; if (t == NULL) &#123; return t; &#125; N.left = N.right = NULL; l = r = &amp;N; for (;;) &#123; if (i &lt; t-&gt;item) &#123; if (t-&gt;left != NULL &amp;&amp; i &lt; t-&gt;left-&gt;item) &#123; y = t-&gt;left; t-&gt;left = y-&gt;right; y-&gt;right = t; t = y; &#125; if (t-&gt;left == NULL) &#123; break; &#125; r-&gt;left = t; r = t; t = t-&gt;left; &#125; else if (i &gt; t-&gt;item) &#123; if (t-&gt;right != NULL &amp;&amp; i &gt; t-&gt;right-&gt;item) &#123; y = t-&gt;right; t-&gt;right = y-&gt;left; y-&gt;left = t; t = y; &#125; if (t-&gt;right == NULL) &#123; break; &#125; l-&gt;right = t; l = t; t = t-&gt;right; &#125; else &#123; break; &#125; &#125; l-&gt;right=t-&gt;left; r-&gt;left=t-&gt;right; t-&gt;left=N.right; t-&gt;right=N.left; return t; &#125; Tree * insert(int i, Tree * t) &#123; /* Insert i into the tree t, unless it&apos;s already there. */ /* Return a pointer to the resulting tree. */ Tree * new; new = (Tree *) malloc (sizeof (Tree)); if (new == NULL) &#123; printf(&quot;Ran out of space\n&quot;); exit(1); &#125; new-&gt;item = i; if (t == NULL) &#123; new-&gt;left = new-&gt;right = NULL; size = 1; return new; &#125; t = splay(i,t); if (i &lt; t-&gt;item) &#123; new-&gt;left = t-&gt;left; new-&gt;right = t; t-&gt;left = NULL; size ++; return new; &#125; else if (i &gt; t-&gt;item) &#123; new-&gt;right = t-&gt;right; new-&gt;left = t; t-&gt;right = NULL; size++; return new; &#125; else &#123; /* We get here if it&apos;s already in the tree */ /* Don&apos;t add it again */ free(new); return t; &#125;&#125;Tree * delete(int i, Tree * t)&#123;/* Deletes i from the tree if it&apos;s there. *//* Return a pointer to the resulting tree. */ Tree * x; if (t==NULL) &#123; return NULL; &#125; t = splay(i,t); if (i == t-&gt;item) &#123; /* found it */ if (t-&gt;left == NULL) &#123; x = t-&gt;right; &#125; else &#123; x = splay(i, t-&gt;left); x-&gt;right = t-&gt;right; &#125; size--; free(t); return x; &#125; return t; /* It wasn&apos;t there */&#125;int main(int argv, char *argc[])&#123;/* A sample use of these functions. Start with the empty tree, *//* insert some stuff into it, and then delete it */ Tree * root; int i; root = NULL; /* the empty tree */ size = 0; for (i = 0; i &lt; 1024; i++) &#123; root = insert((541*i) &amp; (1023), root); &#125; printf(&quot;size = %d\n&quot;, size); for (i = 0; i &lt; 1024; i++) &#123; root = delete((541*i) &amp; (1023), root); &#125; printf(&quot;size = %d\n&quot;, size);&#125; LCA(Tarjan)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e4 + 7;const int inf = 0x3f3f3f3f;int n, head[maxn], fa[maxn], head_2[maxn], cnt, cnt_2, sx;bool vis[maxn];struct EDGE&#123; int next, to, u;&#125;edge[maxn];struct QUERY&#123; int next, to, u, lca;&#125;query[maxn];void add_edge(int u, int v)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].u = u; head[u] = cnt++;&#125;void add_query(int u, int v)&#123; query[cnt_2].next = head_2[u]; query[cnt_2].to = v; query[cnt_2].u = u; head_2[u] = cnt_2++; query[cnt_2].next = head_2[v]; query[cnt_2].to = u; query[cnt_2].u = v; head_2[v] = cnt_2++;&#125;void init_edge()&#123; memset(head, -1, sizeof(head)); cnt = 0;&#125;void init_query()&#123; memset(head_2, -1, sizeof(head_2)); cnt_2 = 0;&#125;int root(int x)&#123; return x = x == fa[x] ? x : root(fa[x]);&#125;void tarjan(int x) &#123; fa[x] = x; for (int i = head[x]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; tarjan(v); fa[root(v)] = x; &#125; vis[x] = true; for (int i = head_2[x]; i != -1; i = query[i].next) &#123; int v = query[i].to; if (vis[v]) &#123; query[i].lca = query[i^1].lca = root(v); &#125; &#125;&#125;void read()&#123; int u, v; scanf(&quot;%d&quot;, &amp;n); memset(vis, false, sizeof(vis)); for(int i = 1; i &lt; n; i++)&#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v); vis[v] = true; &#125; for(int i = 1; i&lt;=n; i++)&#123; if(!vis[i])&#123; sx = i; break; &#125; &#125; memset(vis, false, sizeof(vis)); scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_query(u, v);&#125;void solve()&#123; tarjan(sx); for(int i = 0; i &lt; cnt_2; i+=2)&#123; printf(&quot;%d\n&quot;, query[i].lca); &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; init_edge(); init_query(); read(); solve(); &#125; return 0;&#125;/*2161 148 510 165 94 68 44 101 136 1510 116 710 216 38 116 1216 752 33 43 11 53 5*///4 3 RMQST表12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+7;int stmax[maxn][30];int stmin[maxn][30];int a[maxn];void rmq_st(int n)&#123; for(int i=1;i&lt;=n;i++) stmax[i][0]=stmin[i][0]=a[i]; int m=(int)(double(log(n))/log(2.0)); for(int j=1;j&lt;=m;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123; stmax[i][j]=max(stmax[i][j-1],stmax[i+(1&lt;&lt;j-1)][j-1]); stmin[i][j]=min(stmin[i][j-1],stmin[i+(1&lt;&lt;j-1)][j-1]); &#125;&#125;void rmq_query(int l,int r)&#123; int k=(int)((double)log(r-l+1)/log(2.0)); cout&lt;&lt;&quot;Max is : &quot;&lt;&lt;max(stmax[l][k],stmax[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl; cout&lt;&lt;&quot;Min is : &quot;&lt;&lt;min(stmin[l][k],stmin[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; rmq_st(n); int l,r; while(cin&gt;&gt;l&gt;&gt;r)&#123; rmq_query(l,r); &#125; return 0;&#125; 普通莫队1234567891011121314151617181920212223242526272829303132333435363738/* 解释： belong[x]x属于分块后的哪一块，Q[i]每个询问 modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析 注意： 最后也可以不对询问id排序，直接保存到一个数组里面输出即可*/int a[nmax], belong[nmax];ll ans = 0;struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];bool cmp(node a, node b) &#123; if (belong[a.l] != belong[b.l]) return a.l &lt; b.l; else return a.r &lt; b.r;&#125;bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;void modify(int pos, int tag) &#123; // ......... 增删操作&#125;int main() &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); int sz = sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= m; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; belong[i] = (i - 1) / sz + 1; &#125; sort(Q + 1, Q + 1 + m, cmp); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (l &lt; Q[i].l) modify(l++, -1); while (l &gt; Q[i].l) modify(--l, 1); while (r &gt; Q[i].r) modify(r--, -1); while (r &lt; Q[i].r) modify(++r, 1); Q[i].ans = ans; &#125; sort(Q + 1, Q + 1 + m, cmpid); for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans); return 0;&#125; 莫队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=3e5+5;//区间范围const int MAX=1e6+5;//最大数字int unit,cnt[MAX],arr[N],res[N],ans=0;struct node&#123; int l,r,id;&#125;q[N];bool cmp(node a,node b)&#123; return a.l/unit!=b.l/unit?a.l/unit&lt;b.l/unit:a.r&lt;b.r;&#125;void add(int pos)&#123; cnt[arr[pos]]++; if(cnt[arr[pos]]==1)&#123; ans++; &#125;&#125;void remove(int pos)&#123; cnt[arr[pos]]--; if(cnt[arr[pos]]==0)&#123; ans--; &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); unit=sqrt(n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; int m; scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r); q[i].id=i; &#125; sort(q+1,q+m+1,cmp); int L=q[1].l,R=L-1; for(int i=1;i&lt;=m;i++)&#123; while(L&gt;q[i].l) add(--L); while(L&lt;q[i].l) remove(L++); while(R&gt;q[i].r) remove(R--); while(R&lt;q[i].r) add(++R); res[q[i].id]=ans; &#125; for(int i=1;i&lt;=m;i++)&#123; printf(&quot;%d\n&quot;,res[i]); &#125;&#125; 动态规划背包1234567891011121314151617181920212223242526272829303132333435int nValue,nKind;//0-1 背包，代价为 cost, 获得的价值为 weightvoid ZeroOnePack(int cost,int weight)&#123; for(int i=nValue; i&gt;=cost; i−−) dp[i]=max(dp[i],dp[i−cost]+weight);&#125;//完全背包，代价为 cost, 获得的价值为 weightvoid CompletePack(int cost,int weight)&#123; for(int i=cost; i&lt;=nValue; i++) dp[i]=max(dp[i],dp[i−cost]+weight);&#125;//多重背包void MultiplePack(int cost,int weight,int amount)&#123; if(cost*amount&gt;=nValue) CompletePack(cost,weight); else &#123; int k=1; while(k&lt;amount) &#123; ZeroOnePack(k*cost,k*weight); amount−=k; k&lt;&lt;=1; &#125; ZeroOnePack(amount*cost,amount*weight);//这个不要忘记了，经常掉了 &#125;&#125;//分组背包：for k = 1 to Kfor v = V to 0for item i in group kF[v] = maxF[v],F[v-Ci]+Wi 最长上升子序列1234567891011121314151617181920212223242526272829303132333435const int MAXN=500010;int a[MAXN],b[MAXN]//用二分查找的方法找到一个位置，使得 num&gt;b[i-1] 并且 num&lt;b[i], 并用 num 代替b[i]int Search(int num,int low,int high)&#123; int mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(num&gt;=b[mid]) low=mid+1; else high=mid−1; &#125; return low;&#125;int DP(int n)&#123; int i,len,pos; b[1]=a[1]; len=1; for(i=2; i&lt;=n; i++) &#123; if(a[i]&gt;=b[len])//如果 a[i] 比 b[] 数组中最大还大直接插入到后面即可 &#123; len=len+1; b[len]=a[i]; &#125; else //用二分的方法在 b[] 数组中找出第一个比 a[i] 大的位置并且让a[i] 替代这个位置 &#123; pos=Search(a[i],1,len); b[pos]=a[i]; &#125; &#125; return len;&#125; 最长公共子序列1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; const int MAXN = 1005; int DP[MAXN][MAXN]; int main()&#123; string a; string b; while(cin &gt;&gt; a &gt;&gt; b) &#123; int l1 = a.size(); int l2 = b.size(); memset(DP, 0, sizeof(DP)); for(int i = 1; i &lt;= l1; i++) for(int j = 1; j &lt;= l2; j++) if(a[i - 1] == b[j - 1]) DP[i][j] = max(DP[i][j], DP[i - 1][j - 1] + 1); else DP[i][j] = max(DP[i][j - 1], DP[i - 1][j]); printf(&quot;%d\n&quot;, DP[l1][l2]); &#125; return 0;&#125; 概率dp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748POJ 2096/*POJ 2096概率DPdp求期望逆着递推求解题意：（题意看题目确实比较难道，n和s都要找半天才能找到） 一个软件有s个子系统，会产生n种bug 某人一天发现一个bug,这个bug属于一个子系统，属于一个分类 每个bug属于某个子系统的概率是1/s,属于某种分类的概率是1/n 问发现n种bug,每个子系统都发现bug的天数的期望。求解： dp[i][j]表示已经找到i种bug,j个系统的bug，达到目标状态的天数的期望 dp[n][s]=0;要求的答案是dp[0][0]; dp[i][j]可以转化成以下四种状态: dp[i][j],发现一个bug属于已经有的i个分类和j个系统。概率为(i/n)*(j/s); dp[i][j+1],发现一个bug属于已有的分类，不属于已有的系统.概率为 (i/n)*(1-j/s); dp[i+1][j],发现一个bug属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(j/s); dp[i+1][j+1],发现一个bug不属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(1-j/s); 整理便得到转移方程*/#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int MAXN=1010;double dp[MAXN][MAXN];int main()&#123; int n,s; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;s)!=EOF) &#123; dp[n][s]=0; for(int i=n;i&gt;=0;i--) for(int j=s;j&gt;=0;j--) &#123; if(i==n&amp;&amp;j==s)continue; dp[i][j]=(i*(s-j)*dp[i][j+1]+(n-i)*j*dp[i+1][j]+(n-i)*(s-j)*dp[i+1][j+1]+n*s)/(n*s-i*j); &#125; printf(&quot;%.4lf\n&quot;,dp[0][0]);//POJ上G++要改成%.4f &#125; return 0;&#125; 轮廓线dp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/*HDU 4285要形成刚好 K 条回路的方法数要避免环套环的情况。所以形成回路时，要保证两边的插头数是偶数G++ 11265ms 11820KC++ 10656ms 11764K*/const int MAXD=15;const int STATE=1000010;const int HASH=300007;//这个大一点可以防止 TLE, 但是容易 MLEconst int MOD=1000000007;int N,M,K;int maze[MAXD][MAXD];int code[MAXD];int ch[MAXD];int num;//圈的个数struct HASHMAP&#123; int head[HASH],next[STATE],size; long long state[STATE]; int f[STATE]; void init() &#123; size=0; memset(head,−1,sizeof(head)); &#125; void push(long long st,int ans) &#123; int i; int h=st%HASH; for(i=head[h]; i!=−1; i=next[i]) if(state[i]==st) &#123; f[i]+=ans; f[i]%=MOD; return; &#125; state[size]=st; f[size]=ans; next[size]=head[h]; head[h]=size++; &#125;&#125; hm[2];void decode(int *code,int m,long long st)&#123; num=st&amp;63; st&gt;&gt;=6; for(int i=m; i&gt;=0; i−−) &#123; code[i]=st&amp;7; st&gt;&gt;=3; &#125;&#125;long long encode(int *code,int m)//最小表示法&#123; int cnt=1; memset(ch,−1,sizeof(ch)); ch[0]=0; long long st=0; for(int i=0; i&lt;=m; i++) &#123; if(ch[code[i]]==−1) ch[code[i]]=cnt++; code[i]=ch[code[i]]; st&lt;&lt;=3; st|=code[i]; &#125; st&lt;&lt;=6; st|=num; return st;&#125;void shift(int *code,int m)&#123; for(int i=m; i&gt;0; i−−) code[i]=code[i−1]; code[0]=0;&#125;void dpblank(int i,int j,int cur)&#123; int k,left,up; for(k=0; k&lt;hm[cur].size; k++) &#123; decode(code,M,hm[cur].state[k]); left=code[j−1]; up=code[j]; if(left&amp;&amp;up) &#123; if(left==up) &#123; if(num&gt;=K) continue; int t=0;//要避免环套环的情况，需要两边插头数为偶数 for(int p=0; p&lt;j−1; p++) if(code[p]) t++; if(t&amp;1) continue; if(num&lt;K) &#123; num++; code[j−1]=code[j]=0; hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]); &#125; &#125; else &#123; code[j−1]=code[j]=0; for(int t=0; t&lt;=M; t++) if(code[t]==up) code[t]=left; hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]); &#125; &#125; else if(left||up) &#123; int t; if(left) t=left; else t=up; if(maze[i][j+1]) &#123; code[j−1]=0; code[j]=t; hm[cur^1].push(encode(code,M),hm[cur].f[k]); &#125; if(maze[i+1][j]) &#123; code[j]=0; code[j−1]=t; hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]); &#125; &#125; else &#123; if(maze[i][j+1]&amp;&amp;maze[i+1][j]) &#123; code[j−1]=code[j]=13; hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]); &#125; &#125; &#125;&#125;void dpblock(int i,int j,int cur)&#123; int k; for(k=0; k&lt;hm[cur].size; k++) &#123; decode(code,M,hm[cur].state[k]); code[j−1]=code[j]=0; hm[cur^1].push(encode(code,j==M?M−1:M),hm[cur].f[k]); &#125;&#125;char str[20];void init()&#123; scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K); memset(maze,0,sizeof(maze)); for(int i=1; i&lt;=N; i++) &#123; scanf(&quot;%s&quot;,&amp;str); for(int j=1; j&lt;=M; j++) if(str[j−1]==&apos;.&apos;) maze[i][j]=1; &#125;&#125;void solve()&#123; int i,j,cur=0; hm[cur].init(); hm[cur].push(0,1); for(i=1; i&lt;=N; i++) for(j=1; j&lt;=M; j++) &#123; hm[cur^1].init(); if(maze[i][j]) dpblank(i,j,cur); else dpblock(i,j,cur); cur^=1; &#125; int ans=0; for(i=0; i&lt;hm[cur].size; i++) if(hm[cur].state[i]==K) &#123; ans+=hm[cur].f[i]; ans%=MOD; &#125; printf(&quot;%d\n&quot;,ans);&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T−−) &#123; init(); solve(); &#125; return 0;&#125;/*Sample Input 4 4 1 **.. .... .... .... 4 1 .... .... .... ....Sample Output 6*/ 图论最短路Dijkstra(邻接矩阵)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 3007;const int inf = 0x3f3f3f3f;int road[maxn][maxn];int dis[maxn];bool vis[maxn];int n, m, sx, ex;void init()&#123; memset(road, inf, sizeof(road));&#125;int dijkstra(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); dis[sx] = 0; for(int u = 1; u&lt;=n; u++)&#123; int minD = inf, k = -1; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123; k = i; minD = dis[i]; &#125; &#125; //if(k == ex) // return dis[ex]; vis[k] = true; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123; dis[i] = dis[k] + road[k][i]; &#125; &#125; &#125; return dis[ex];&#125;void read()&#123; int u, v, w; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); road[u][v] = min(road[u][v], w); //road[v][u] = min(road[v][u], w); //双向边 &#125;&#125;void solve()&#123; printf(&quot;%d\n&quot;, dijkstra(sx, ex));&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123; init(); read(); solve(); &#125; return 0;&#125; Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 3007;const int inf = 0x3f3f3f3f;struct EDGE&#123; int next, to, w;&#125;edge[maxn&lt;&lt;4];int head[maxn], dis[maxn], cnt;bool vis[maxn];int n, m, sx, ex;void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;int dijkstra(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); dis[sx] = 0; for(int cas = 1; cas&lt;=n; cas++)&#123; int minD = inf, kk = -1; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123; kk = i; minD = dis[i]; &#125; &#125; //if(kk == ex) // return dis[ex]; vis[kk] = true; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123; dis[v] = dis[kk] + edge[i].w; &#125; &#125; &#125; return dis[ex];&#125;void read()&#123; int u, v, w; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); //add(v, u, w); //双向边 &#125;&#125;void solve()&#123; printf(&quot;%d\n&quot;, dijkstra(sx, ex));&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123; init(); read(); solve(); &#125; return 0;&#125; Dijkstra+heap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 3007;const int inf = 0x3f3f3f3f;struct EDGE&#123; int next, to, w;&#125;edge[maxn&lt;&lt;4];int head[maxn], dis[maxn], cnt;bool vis[maxn];int n, m, sx, ex;struct NODE&#123; int u; int dis; NODE()&#123;&#125; NODE(int x, int y) : u(x), dis(y)&#123;&#125; bool operator &lt;(const NODE &amp;a)const&#123; return dis&gt;a.dis; &#125;&#125;;void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;int dijkstra(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); dis[sx] = 0; priority_queue&lt;NODE&gt;que; que.push(NODE(sx, 0)); while(!que.empty())&#123; NODE tmp = que.top(); que.pop(); int kk = tmp.u; if(vis[kk])&#123; continue; &#125; vis[kk] = true; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123; dis[v] = dis[kk] + edge[i].w; que.push(NODE(v, dis[v])); &#125; &#125; &#125; return dis[ex];&#125;void read()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v, w; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); //双向边 &#125;&#125;void solve()&#123; printf(&quot;%d\n&quot;, dijkstra(sx, ex));&#125;int main()&#123; int T; while(T--)&#123; init(); read(); solve(); &#125; return 0;&#125; SPFA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1e3+7;int n, m, sx, ex;int head[maxn], dis[maxn], cnt;bool vis[maxn];struct EDGE&#123; int next, to, w, u;&#125;edge[maxn&lt;&lt;3];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].u = u; edge[cnt].w = w; head[u] = cnt++;&#125;int SPFA(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); queue&lt;int&gt;que; dis[sx] = 0; que.push(sx); while(!que.empty())&#123; int kk = que.front(); que.pop(); vis[kk] = false; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dis[v] &gt; dis[kk] + edge[i].w)&#123; dis[v] = dis[kk] + edge[i].w; if(!vis[v])&#123; vis[v] = true; que.push(v); &#125; &#125; &#125; &#125; return dis[ex];&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123; init(); sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); //add(v, u, w); //双向边 &#125; printf(&quot;%d\n&quot;, SPFA(sx, ex)); &#125;&#125; SPFA+SLF优化123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e2;int phi[MAXN],n,tot;int pri[MAXN];bool mark[MAXN];void getphi()&#123; phi[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(!mark[i])&#123; phi[i]=i-1; pri[++tot]=i; &#125; for(int j=1;j&lt;=tot;j++)&#123; int x=pri[j]; if(i*x&gt;n) break; mark[i*x]=1; if(i%x==0)&#123; phi[i*x]=phi[i]*x; break; &#125; else phi[i*x]=phi[i]*phi[x]; &#125; &#125;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; tot=0; getphi(); printf(&quot;%d\n&quot;,phi[n]); &#125; return 0;&#125; Floyd12345for(k=1; k&lt;=n; k++) for(i=1; i&lt;=n; i++) for(j=1; j&lt;=n; j++) if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j]; K短路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210/** * poj * Problem#2449 * Accepted * Time: 438ms * Memory: 15196k */#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;typedef bool boolean;#define pii pair&lt;int, int&gt;#define fi first#define sc secondtypedef class Node &#123; public: int val, ed; Node *l, *r; Node() &#123; &#125; Node(int val, int ed, Node *l, Node *r):val(val), ed(ed), l(l), r(r) &#123; &#125;&#125;Node;#define Limit 1000000Node pool[Limit];Node* top = pool;Node* newnode(int val, int ed) &#123; if(top &gt;= pool + Limit) return new Node(val, ed, NULL, NULL); top-&gt;val = val, top-&gt;ed = ed, top-&gt;l = top-&gt;r = NULL; return top++;&#125;Node* merge(Node* a, Node* b) &#123; if (!a) return b; if (!b) return a; if (a-&gt;val &gt; b-&gt;val) swap(a, b); Node* p = newnode(a-&gt;val, a-&gt;ed); p-&gt;l = a-&gt;l, p-&gt;r = a-&gt;r; p-&gt;r = merge(p-&gt;r, b); swap(p-&gt;l, p-&gt;r); return p;&#125;typedef class Status &#123; public: int dist; Node* p; Status(int dist = 0, Node* p = NULL):dist(dist), p(p) &#123; &#125; boolean operator &lt; (Status b) const &#123; return dist &gt; b.dist; &#125;&#125;Status;typedef class Edge &#123; public: int end, next, w; Edge(int end = 0, int next = 0, int w = 0):end(end), next(next), w(w) &#123; &#125;&#125;Edge;typedef class MapManager &#123; public: int ce; int* h; Edge* es; MapManager() &#123; &#125; MapManager(int n, int m):ce(0) &#123; h = new int[(n + 1)]; es = new Edge[(m + 5)]; memset(h, 0, sizeof(int) * (n + 1)); &#125; void addEdge(int u, int v, int w) &#123; es[++ce] = Edge(v, h[u], w); h[u] = ce; &#125; Edge&amp; operator [] (int pos) &#123; return es[pos]; &#125;&#125;MapManager;int n, m;int s, t, k;MapManager g;MapManager rg;boolean *vis;int* f, *lase;inline void init() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); g = MapManager(n, m); rg = MapManager(n, m); for (int i = 1, u, v, w; i &lt;= m; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); g.addEdge(u, v, w); rg.addEdge(v, u, w); &#125; scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;k);&#125;queue&lt;int&gt; que;void spfa(MapManager&amp; g, int s) &#123; vis = new boolean[(n + 1)]; f = new int[(n + 1)]; lase = new int[(n + 1)]; memset(f, 0x7f, sizeof(int) * (n + 1)); memset(vis, false, sizeof(boolean) * (n + 1)); que.push(s); f[s] = 0, lase[s] = 0; while (!que.empty()) &#123; int e = que.front(); que.pop(); vis[e] = false; for (int i = g.h[e]; i; i = g[i].next) &#123; int eu = g[i].end, w = g[i].w; if (f[e] + w &lt; f[eu]) &#123; f[eu] = f[e] + w, lase[eu] = i; if (!vis[eu]) &#123; vis[eu] = true; que.push(eu); &#125; &#125; &#125; &#125; &#125;Node** hs;inline void rebuild() &#123; for (int i = 1; i &lt;= n; i++) for (int j = g.h[i]; j; j = g[j].next) &#123; int e = g[j].end; if (lase[i] != j) g[j].w += f[e] - f[i]; &#125; hs = new Node*[(n + 1)]; que.push(t); hs[t] = NULL; while (!que.empty()) &#123; int e = que.front(); que.pop(); if (lase[e]) hs[e] = hs[g[lase[e]].end]; for (int i = g.h[e]; i; i = g[i].next) if (lase[e] != i &amp;&amp; f[g[i].end] != 0x7f7f7f7f) hs[e] = merge(hs[e], new Node(g[i].w, g[i].end, NULL, NULL)); for (int i = rg.h[e]; i; i = rg[i].next) &#123; int eu = rg[i].end; if (lase[eu] == i) que.push(eu); &#125; &#125;&#125;inline int kthpath(int k) &#123; if (s == t) k++; if (f[s] == 0x7f7f7f7f) return -1; if (k == 1) return f[s]; priority_queue&lt;Status&gt; q; if (!hs[s]) return -1; q.push(Status(hs[s]-&gt;val, hs[s])); while (--k &amp;&amp; !q.empty()) &#123; Status e = q.top(); q.pop(); if(k == 1) return e.dist + f[s]; int eu = e.p-&gt;ed; if (hs[eu]) q.push(Status(e.dist + hs[eu]-&gt;val, hs[eu])); if (e.p-&gt;l) q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;l-&gt;val, e.p-&gt;l)); if (e.p-&gt;r) q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;r-&gt;val, e.p-&gt;r)); &#125; return -1;&#125;inline void solve() &#123; printf(&quot;%d\n&quot;, kthpath(k));&#125;int main() &#123; init(); spfa(rg, t); rebuild(); solve(); return 0;&#125;//最短路算法+可持久化堆 生成树Kruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//并查集实现最小生成树vector&lt;int&gt; u, v, weights, w_r, father;int mycmp(int i, int j)&#123; return weights[i] &lt; weights[j];&#125;int find(int x)&#123; return father[x] == x ? x : father[x] = find(father[x]);&#125;void kruskal_test()&#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n)); for(int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; cin &gt;&gt; A[i][j]; &#125; &#125; int edges = 0; // 共计n*(n - 1)/2条边 for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; u.push_back(i); v.push_back(j); weights.push_back(A[i][j]); w_r.push_back(edges++); &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; father.push_back(i); // 记录n个节点的根节点，初始化为各自本身 &#125; sort(w_r.begin(), w_r.end(), mycmp); //以weight的大小来对索引值进行排序 int min_tree = 0, cnt = 0; for (int i = 0; i &lt; edges; ++i) &#123; int e = w_r[i]; //e代表排序后的权值的索引 int x = find(u[e]), y = find(v[e]); //x不等于y表示u[e]和v[e]两个节点没有公共根节点，可以合并 if (x != y) &#123; min_tree += weights[e]; father[x] = y; ++cnt; &#125; &#125; if (cnt &lt; n - 1) min_tree = 0; cout &lt;&lt; min_tree &lt;&lt; endl;&#125;int main(void)&#123; kruskal_test(); return 0;&#125; Prim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//Prim算法实现void prim_test()&#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n)); for(int i = 0; i &lt; n ; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; cin &gt;&gt; A[i][j]; &#125; &#125; int pos, minimum; int min_tree = 0; //lowcost数组记录每2个点间最小权值，visited数组标记某点是否已访问 vector&lt;int&gt; visited, lowcost; for (int i = 0; i &lt; n; ++i) &#123; visited.push_back(0); //初始化为0，表示都没加入 &#125; visited[0] = 1; //最小生成树从第一个顶点开始 for (int i = 0; i &lt; n; ++i) &#123; lowcost.push_back(A[0][i]); //权值初始化为0 &#125; for (int i = 0; i &lt; n; ++i) &#123; //枚举n个顶点 minimum = max_int; for (int j = 0; j &lt; n; ++j) &#123; //找到最小权边对应顶点 if(!visited[j] &amp;&amp; minimum &gt; lowcost[j]) &#123; minimum = lowcost[j]; pos = j; &#125; &#125; if (minimum == max_int) //如果min = max_int表示已经不再有点可以加入最小生成树中 break; min_tree += minimum; visited[pos] = 1; //加入最小生成树中 for (int j = 0; j &lt; n; ++j) &#123; if(!visited[j] &amp;&amp; lowcost[j] &gt; A[pos][j]) lowcost[j] = A[pos][j]; //更新可更新边的权值 &#125; &#125; cout &lt;&lt; min_tree &lt;&lt; endl;&#125;int main(void)&#123; prim_test(); return 0;&#125; 次小生成树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;typedef long long LL;const int MAXN = 500;const int MAXE = 500 * 500;const int INF = 0x3f3f3f3f;int pre[MAXN + 7];void initPre(int n)&#123; for(int i = 0; i &lt;= n; i++) pre[i] = i; &#125;//并查集int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]); &#125;void merge(int x, int y)&#123; int fx = Find(x), fy = Find(y); if(fx != fy) pre[fx] = fy; &#125;struct Edge&#123; //前向星存边 int u, v; //起点 终点 int w; bool select;&#125;edge[MAXE + 7];bool cmp(Edge a, Edge b)&#123; if(a.w != b.w) return a.w &lt; b.w; if(a.u != b.u) return a.u &lt; b.u; return a.v &lt; b.v;&#125;struct Node&#123;//链式前向星 用于存储每个集合里面的边 int to; int next;&#125;link[MAXN + 7];int head[MAXN + 7];//邻接表的头结点的位置int End[MAXN + 7];//邻接表的尾节点的位置int length[MAXN + 7][MAXN + 7];//最小生成树中任意两点路径上的最长边 int kruskal(int n, int m)&#123; //初始化邻接表,对于每一个顶点添加一个指向自身的边,表示以i为代表元的集合中只有点i for(int i = 1; i &lt;= n; i++)&#123; link[i].to = i, link[i].next = head[i]; End[i] = i, head[i] = i; &#125; sort(edge + 1, edge + 1 + m, cmp); int cnt = 0; for(int i = 1; i &lt;= m; i++)&#123; if(cnt == n - 1) break;//当找到的边数等于节点数-1,说明mst已经找到 int fx = Find(edge[i].u); int fy = Find(edge[i].v); if(fx != fy)&#123; for(int j = head[fx]; j != -1; j = link[j].next)//修改length数组 for(int k = head[fy]; k != -1; k = link[k].next) //每次合并两个等价类的之后,分别属于两个等价类的两个节点之间的最长边一定是当前加入的边 length[link[j].to][link[k].to] = length[link[k].to][link[j].to] = edge[i].w; //合并邻接表 link[End[fy]].next = head[fx]; End[fy] = End[fx]; merge(fx, fy); cnt++; edge[i].select = true; &#125; &#125; if(cnt &lt; n - 1) return -1; return 1;&#125;int main()&#123; //初始化建图后执行以下操作 int flag = kruskal(n, m); int mst = 0; for(int i = 1; i &lt;= m; i++) if(edge[i].select) mst += edge[i].w;//计算出最小生成树 int secmst = INF; //在 T/(u,v) + (x, y)中寻得次小生成树 for(int i = 1; i &lt;= m; i++) if(!edge[i].select) secmst = min(secmst, mst + edge[i].w - length[edge[i].u][edge[i].v]); return 0;&#125; 拓扑排序1234567891011121314151617181920212223242526272829303132333435363738394041424344/*hdu1285--采用二维数组记录两者之间的关系*/#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;int map[510][510];//前驱数量 int indegree[510];int queue[510];//保存拓扑序列 void topo(int n)&#123; int i,j,m,t=0; for(j=1;j&lt;=n;j++)&#123; for(i=1;i&lt;=n;i++)&#123; if(indegree[i]==0)&#123;//找出前驱数量为零的的点即每次找到第一名 m=i;break; &#125; &#125; queue[t++]=m;indegree[m]=-1;//将第一名的前驱数量设为-1 for(i=1;i&lt;=n;++i)&#123;//第二步将前驱中含有第一名的点前驱数量减1 if(map[m][i])indegree[i]--; &#125; &#125; printf(&quot;%d&quot;,queue[0]);//输出拓扑序列 for(i=1;i&lt;n;++i)&#123; printf(&quot; %d&quot;,queue[i]); &#125; printf(&quot;\n&quot;);&#125;int main()&#123; int n,m,i,j,a,b; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123; memset(indegree,0,sizeof(indegree));//初始化 memset(map,0,sizeof(map)); for(i=0;i&lt;m;++i)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(map[a][b]==0)&#123; //避免重复的数据输入 map[a][b]=1;indegree[b]++;//第一步记录关系和点的前驱数量 &#125; &#125; topo(n);//调用拓扑排序 &#125; return 0;&#125; 网络流FF12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;#define maxn 1200#define INF 2e9using namespace std;int i,j,k,n,m,h,t,tot,ans,st,en;struct node&#123; int c,f;&#125;edge[maxn][maxn];int flag[maxn],pre[maxn],alpha[maxn],q[maxn],v;int read()&#123; char c;int x;while(c=getchar(),c&lt;&apos;0&apos;||c&gt;&apos;9&apos;);x=c-&apos;0&apos;; while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) x=x*10+c-&apos;0&apos;;return x;&#125;void bfs()&#123; memset(flag,0xff,sizeof(flag));memset(pre,0xff,sizeof(pre));memset(alpha,0xff,sizeof(alpha)); flag[st]=0;pre[st]=0;alpha[st]=INF;h=0,t=1;q[t]=st; while(h&lt;t)&#123; h++;v=q[h]; for(int i=1;i&lt;=n;i++)&#123; if(flag[i]==-1)&#123; if(edge[v][i].c&lt;INF&amp;&amp;edge[v][i].f&lt;edge[v][i].c)&#123; flag[i]=0;pre[i]=v;alpha[i]=min(alpha[v],edge[v][i].c-edge[v][i].f);q[++t]=i; &#125; else if(edge[i][v].c&lt;INF&amp;&amp;edge[i][v].f&gt;0)&#123; flag[i]=0;pre[i]=-v;alpha[i]=min(alpha[v],edge[i][v].f);q[++t]=i; &#125; &#125; &#125; flag[v]=1; &#125;&#125;void Ford_Fulkerson()&#123; while(1)&#123; bfs(); if(alpha[en]==0||flag[en]==-1)&#123; break; &#125; int k1=en,k2=abs(pre[k1]);int a=alpha[en]; while(1)&#123; if(edge[k2][k1].c&lt;INF) edge[k2][k1].f+=a; else if(edge[k1][k2].c&lt;INF) edge[k1][k2].f-=a; if(k2==st) break; k1=k2;k2=abs(pre[k1]); &#125; alpha[en]=0; &#125;&#125;void flow()&#123; int maxflow=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(i==st&amp;&amp;edge[i][j].f&lt;INF) maxflow+=edge[i][j].f; &#125; printf(&quot;%d&quot;,maxflow);&#125;int main()&#123; int u,v,c,f; n=read();m=read();st=read();en=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) edge[i][j].c=INF,edge[i][j].f=0; for(int i=1;i&lt;=m;i++)&#123; u=read();v=read();c=read(); edge[u][v].c=c; &#125; Ford_Fulkerson(); flow(); return 0;&#125; EK12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt; using namespace std;#define INF 0x3f3f3f#define maxn 10005int n, m, st, en, flow[maxn][maxn], pre[maxn];int q[maxn], curr_pos, st_pos, end_pos;bool wh[maxn];int max_flow;void Init()//初始化&#123; int i, a, b, c; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;en); for(i = 0; i != m; ++i) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); flow[a][b] += c; &#125; return ;&#125;bool Bfs(int st, int en)//广搜找源点&#123; st_pos = -1, end_pos = 0; memset(wh, 0, sizeof wh); wh[st] = 1; q[0] = st; while(st_pos != end_pos) &#123; curr_pos = q[++st_pos]; for(int i = 1; i != n+1; ++i) &#123; if(!wh[i] &amp;&amp; flow[curr_pos][i] &gt; 0) &#123; wh[i] = 1; pre[i] = curr_pos; if(i == en) &#123; return true; &#125; q[++end_pos] = i; &#125; &#125; &#125; return false;&#125; int EK(int start_pos, int end_pos)&#123; int i, minn; while(Bfs(start_pos, end_pos))//回溯 &#123; minn = INF; for(i = end_pos; i != start_pos; i = pre[i]) &#123; minn = min(minn, flow[pre[i]][i]); &#125; for(i = end_pos; i != start_pos; i = pre[i]) &#123; flow[pre[i]][i] -= minn; flow[i][pre[i]] += minn;//反向弧加上该值（具体原因下文详解） &#125; max_flow += minn; &#125; return max_flow;&#125;int main()&#123; //freopen(&quot;test.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;test.out&quot;, &quot;w&quot;, stdout); Init(); printf(&quot;%d&quot;, EK(st, en)); //fclose(stdin); //fclose(stdout);&#125; DINIC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+7;const int inf = 0x3f3f3f3f;int n, m, sx, ex, cnt;int head[maxn], pre[maxn];struct EDGE&#123; int u, next, to, c;&#125;edge[maxn&lt;&lt;3];void add_edge(int u, int v, int c)&#123; edge[cnt].u = u; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].c = c&lt;=inf ? c : inf; head[u] = cnt++;&#125;void add(int u, int v, int c)&#123; add_edge(u, v, c); add_edge(v, u, 0);//双向边容量为c&#125;void init()&#123; //memset(edge, 0, sizeof(edge)); memset(head, -1, sizeof(head)); cnt = 0;&#125;void read()&#123; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;bool BFS(int sx, int ex)&#123; memset(pre, 0, sizeof(pre)); queue&lt;int&gt;que; que.push(sx); pre[sx] = 1; while(!que.empty())&#123; int kk = que.front(); que.pop(); for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!pre[v]&amp;&amp;edge[i].c)&#123; pre[v] = pre[kk] + 1; que.push(v); &#125; &#125; &#125; return pre[ex] != 0;&#125;int DFS(int pos, int flow)&#123; if(pos == ex || flow == 0) return flow; int f = flow; for(int i = head[pos]; i != -1; i = edge[i].next)&#123; int tmp, v = edge[i].to; if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123; edge[i].c -= tmp; edge[i^1].c += tmp; flow -= tmp; if(flow == 0)&#123; break; &#125; &#125; &#125; return f - flow;&#125;int Dinic(int sx, int ex)&#123; int flow = 0; while(BFS(sx, ex))&#123; flow += DFS(sx, inf); &#125; return flow;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123; init(); read(); printf(&quot;%d\n&quot;, Dinic(sx, ex)); &#125; return 0;&#125; DINIC优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+7;const int inf = 0x3f3f3f3f;int n, m, sx, ex, cnt;int head[maxn], pre[maxn], cur[maxn];struct EDGE&#123; int u, next, to, c;&#125;edge[maxn&lt;&lt;3];void add_edge(int u, int v, int c)&#123; edge[cnt].u = u; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].c = c&lt;=inf ? c : inf; head[u] = cnt++;&#125;void add(int u, int v, int c)&#123; add_edge(u, v, c); add_edge(v, u, 0);//双向边容量为c&#125;void init()&#123; //memset(edge, 0, sizeof(edge)); memset(head, -1, sizeof(head)); cnt = 0;&#125;void read()&#123; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;bool BFS(int sx, int ex)&#123; memset(pre, 0, sizeof(pre)); queue&lt;int&gt;que; que.push(sx); pre[sx] = 1; while(!que.empty())&#123; int kk = que.front(); que.pop(); for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!pre[v]&amp;&amp;edge[i].c)&#123; pre[v] = pre[kk] + 1; que.push(v); &#125; &#125; &#125; return pre[ex] != 0;&#125;int DFS(int pos, int flow)&#123; if(pos == ex || flow == 0) return flow; int f = flow; for(int i = head[pos]; i != -1; i = edge[i].next)&#123; int tmp, v = edge[i].to; if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123; edge[i].c -= tmp; edge[i^1].c += tmp; flow -= tmp; if(flow == 0)&#123; break; &#125; &#125; &#125; return f - flow;&#125;int Dinic(int sx, int ex)&#123; int flow = 0; while(BFS(sx, ex))&#123; memcpy(cur, head, sizeof(head)); flow += DFS(sx, inf); &#125; return flow;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123; init(); read(); printf(&quot;%d\n&quot;, Dinic(sx, ex)); &#125; return 0;&#125; DINIC(邻接矩阵)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 307;struct NODE&#123; int c; int f;&#125;;int sx,ex;int pre[maxn];NODE road[maxn][maxn];int n, m, N;bool BFS()&#123; memset(pre,0,sizeof(pre)); queue&lt;int&gt;q; q.push(sx); pre[sx] = 1; while(!q.empty())&#123; int d = q.front(); q.pop(); for(int i = 1;i&lt;=N;i++)&#123; if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123; pre[i] = pre[d] + 1; q.push(i); &#125; &#125; &#125; return pre[ex]!=0;&#125;int dfs(int pos, int flow)&#123; int f = flow; if(pos==ex) return flow; for(int i = 1; i &lt;= N; i++)&#123; if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123; int a = road[pos][i].c - road[pos][i].f; int t = dfs(i, min(a, flow)); road[pos][i].f += t; road[i][pos].f -= t; flow -= t; &#125; &#125; return f - flow;&#125;int dinic()&#123; int sum = 0; while(BFS())&#123; sum+=dfs(sx,inf); &#125; return sum;&#125;void init()&#123; N = n; sx = 0; ex = N; memset(road,0,sizeof(road));&#125;void read()&#123; int u,v,w; for(int i = 1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); road[u][v].c+=w; &#125;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123; init(); read(); printf(&quot;%d\n&quot;,dinic()); &#125; return 0;&#125; ISAP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int read() &#123; int x=0,f=1; char c=getchar(); for (;!isdigit(c);c=getchar()) if (c==&apos;-&apos;) f=-1; for (;isdigit(c);c=getchar()) x=x*10+c-&apos;0&apos;; return x*f;&#125;const int maxn=205;const int maxm=205;const int inf=2e9+7;struct edge &#123; int v,w,nxt;&#125; e[maxm&lt;&lt;1];int h[maxn],tot,n,m,gap[maxn],last[maxn],d[maxn],que[maxn],ql,qr;vector&lt;int&gt; inv[maxn];void add(int u,int v,int w) &#123; e[++tot]=(edge)&#123;v,w,h[u]&#125;; h[u]=tot; e[++tot]=(edge)&#123;u,0,h[v]&#125;; h[v]=tot;&#125;void init(int s,int t) &#123; memset(gap,0,sizeof gap),memset(d,0,sizeof d),++gap[d[t]=1]; for (int i=1;i&lt;=n;++i) last[i]=h[i]; que[ql=qr=1]=t; while (ql&lt;=qr) &#123; int x=que[ql++]; for (int i=h[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (!d[v]) ++gap[d[v]=d[x]+1],que[++qr]=v; &#125;&#125;int aug(int x,int s,int t,int mi) &#123; if (x==t) return mi; int flow=0; for (int &amp;i=last[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (d[x]==d[v]+1) &#123; int tmp=aug(v,s,t,min(mi,e[i].w)); flow+=tmp,mi-=tmp,e[i].w-=tmp,e[i^1].w+=tmp; if (!mi) return flow; &#125; if (!(--gap[d[x]])) d[s]=n+1; ++gap[++d[x]],last[x]=h[x]; return flow;&#125;int maxflow(int s,int t) &#123; init(s,t); int ret=aug(s,s,t,inf); while (d[s]&lt;=n) ret+=aug(s,s,t,inf); return ret;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);#endif while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)) &#123; tot=1,memset(h,0,sizeof h); for (int i=1;i&lt;=n;++i) inv[i].clear(); for (int i=1;i&lt;=m;++i) &#123; int u=read(),v=read(),w=read(); add(u,v,w); if (w) inv[v].push_back(u); &#125; int ans=maxflow(1,n); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; MCMF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxm = 1e5+7;const int maxn = 1e4+7;const int inf = 0x3f3f3f3f;int n, m, cnt, sx, ex;int head[maxn], pre[maxn], dis[maxn];bool vis[maxn];struct EDGE&#123; int next; int to; int w; int c;&#125;edge[maxm];void init()&#123; sx = 0; ex = 1; cnt = 0; memset(edge, 0, sizeof(edge)); memset(head, -1, sizeof(head));&#125;void add_edge(int u, int v, int c, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].c = c&lt;=inf ? c : inf; edge[cnt].w = w; head[u] = cnt++;&#125;void add(int u, int v, int c, int w)&#123; add_edge(u, v, c, w); add_edge(v, u, 0, -w);&#125;bool SPFA(int sx, int ex)&#123; memset(pre, -1, sizeof(pre)); memset(dis, inf, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[sx] = 0; queue&lt;int&gt;que; que.push(sx); while(!que.empty())&#123; int kk = que.front(); que.pop(); vis[kk] = false; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; EDGE tmp = edge[i]; if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123; dis[tmp.to] = dis[kk] + tmp.w; pre[tmp.to] = i; if(!vis[tmp.to])&#123; vis[tmp.to] = true; que.push(tmp.to); &#125; &#125; &#125; &#125; return pre[ex] != -1;&#125;int MCMF(int sx, int ex)&#123; int flow = 0, cost = 0; while(SPFA(sx, ex))&#123; int min_flow = inf; for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123; min_flow = min(min_flow, edge[i].c); &#125; for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123; edge[i].c -= min_flow; edge[i^1].c += min_flow; cost += min_flow * edge[i].w; &#125; flow += min_flow; &#125; return cost;&#125;void read()&#123; int u, v, c, w; ex = n+1; for(int i = 0;i&lt;m;i++)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w); add(u,v,c, w); &#125;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; if(n+m==0)&#123; break; &#125; init(); read(); printf(&quot;%d\n&quot;,MCMF(sx, ex)); &#125; return 0;&#125; 匹配匈牙利算法(邻接矩阵)123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 107;int N, K;int edge[maxn][maxn], head[maxn];bool vis[maxn];void init()&#123; memset(edge, 0, sizeof(edge)); memset(head, 0, sizeof(head));&#125;bool find_edge(int x) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (edge[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!head[i] || find_edge(head[i])) &#123; head[i] = x; return true; &#125; &#125; &#125; return false;&#125;int Magyar(int N)&#123; int ans = 0; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find_edge(i)) &#123; ans++; &#125; &#125; return ans;&#125;int main() &#123; while (cin &gt;&gt; N &gt;&gt; K) &#123; int x, y; for (int i = 1; i &lt;= K; i++)&#123; cin &gt;&gt; x &gt;&gt; y; edge[x][y] = 1; &#125; cout &lt;&lt; Magyar(N) &lt;&lt; endl; &#125; return 0;&#125; 匈牙利算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;int T, N, m;int head[maxn], link[maxn];bool vis[maxn];int cnt;struct EDGE&#123; int next, u, to, w;&#125;edge[maxn];void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].u = u; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; memset(edge, 0, sizeof(edge)); memset(link, 0, sizeof(link)); memset(head, -1, sizeof(head)); cnt = 0;&#125;bool find_edge(int x)&#123; for(int i = head[x]; i!= -1; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v])&#123; vis[v] = true; if (!link[v] || find_edge(link[v])) &#123; link[v] = x; return true; &#125; &#125; &#125; return false;&#125;int Magyar(int N)&#123; int ans = 0; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find_edge(i)) &#123; ans++; &#125; &#125; return ans;&#125;int solve()&#123; int ans = Magyar(N); return ans;&#125;void read()&#123; scanf(&quot;%d%d&quot;,&amp;N, &amp;m); while(m--)&#123; int x, y; scanf(&quot;%d%d&quot;,&amp;x, &amp;y); add(x, y, 1); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; init(); read(); printf(&quot;%d\n&quot;, solve()); &#125; return 0;&#125; KM算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 207;const int maxm = 30007;const int inf = 0x3f3f3f3f;int n, m;int minD, cntx, cnty, edge[maxn][maxn];bool visx[maxn], visy[maxn];int linkx[maxn], link[maxn], wx[maxn], wy[maxn];bool dfs(int x)&#123; //匈牙利算法找增广路径 visx[x] = true; for(int i = 1; i &lt;= cnty; i++)&#123; if(!visy[i])&#123; int t = wx[x] + wy[i] - edge[x][i]; if(t == 0) &#123; visy[i] = true; if(link[i] == 0 || dfs(link[i]))&#123; linkx[x] = i; link[i] = x; return true; &#125; &#125; else if(t &gt; 0)&#123; //找出边权与顶标和的最小的差值 if(t &lt; minD)&#123; minD = t; &#125; &#125; &#125; &#125; return false;&#125;int km()&#123; memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(link, 0, sizeof link); memset(wy, 0, sizeof(wy)); for(int i = 1; i &lt;= cntx; i++)&#123; wx[i] = -inf; for(int j = 1; j &lt;= cnty; j++)&#123; if(wx[i] &lt; edge[i][j])&#123; wx[i] = edge[i][j];//初始化为权值最大的边的权值 &#125; &#125; &#125; for(int i = 1; i &lt;= cntx; i++)&#123; while(1)&#123; minD = inf; memset(visx, false, sizeof visx); memset(visy, false, sizeof visy); if(dfs(i))&#123; break; &#125; for(int j = 1; j &lt;= cntx; j++)&#123; //将交错树中X部的点的顶标减去minz if(visx[j])&#123; wx[j] -= minD; &#125; &#125; for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz if(visy[j])&#123; wy[j] += minD; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnty; i ++)&#123; if(link[i]!=0)&#123; ans += edge[link[i]][i]; &#125; &#125; return ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cntx = cnty = n; memset(edge, 0, sizeof(edge)); for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); edge[u][v] = max(edge[u][v], w); &#125; printf(&quot;%d\n&quot;, km()); &#125; return 0;&#125; KM算法最小权匹配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 207;const int maxm = 30007;const int inf = 0x3f3f3f3f;int n, m;int minD, cntx, cnty, edge[maxn][maxn];bool visx[maxn], visy[maxn];int linkx[maxn], link[maxn], wx[maxn], wy[maxn];bool dfs(int x)&#123; //匈牙利算法找增广路径 visx[x] = true; for(int i = 1; i &lt;= cnty; i++)&#123; if(!visy[i])&#123; int t = wx[x] + wy[i] - edge[x][i]; if(t == 0) &#123; visy[i] = true; if(link[i] == 0 || dfs(link[i]))&#123; linkx[x] = i; link[i] = x; return true; &#125; &#125; else if(t &gt; 0)&#123; //找出边权与顶标和的最小的差值 if(t &lt; minD)&#123; minD = t; &#125; &#125; &#125; &#125; return false;&#125;int km()&#123; memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(link, 0, sizeof link); memset(wy, 0, sizeof(wy)); for(int i = 1; i &lt;= cntx; i++)&#123; wx[i] = -inf; for(int j = 1; j &lt;= cnty; j++)&#123; if(wx[i] &lt; edge[i][j])&#123; wx[i] = edge[i][j];//初始化为权值最大的边的权值 &#125; &#125; &#125; for(int i = 1; i &lt;= cntx; i++)&#123; while(1)&#123; minD = inf; memset(visx, false, sizeof visx); memset(visy, false, sizeof visy); if(dfs(i))&#123; break; &#125; for(int j = 1; j &lt;= cntx; j++)&#123; //将交错树中X部的点的顶标减去minz if(visx[j])&#123; wx[j] -= minD; &#125; &#125; for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz if(visy[j])&#123; wy[j] += minD; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnty; i ++)&#123; if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123; ans += edge[link[i]][i]; &#125; &#125; return -ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cntx = cnty = n; for(int i = 0; i &lt;= cntx; i++)&#123; for(int j = 0; j &lt;= cnty; j++)&#123; edge[i][j] = -inf; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); edge[u][v] = max(edge[u][v], -w); &#125; printf(&quot;%d\n&quot;, km()); &#125; return 0;&#125; KM算法最小权匹配优化版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 207;const int maxm = 30007;const int inf = 0x3f3f3f3f;int n, m;int minD, cntx, cnty, edge[maxn][maxn];bool visx[maxn], visy[maxn];int linkx[maxn], link[maxn], wx[maxn], wy[maxn];bool dfs(int x)&#123; //匈牙利算法找增广路径 visx[x] = true; for(int i = 1; i &lt;= cnty; i++)&#123; if(!visy[i])&#123; int t = wx[x] + wy[i] - edge[x][i]; if(t == 0) &#123; visy[i] = true; if(link[i] == 0 || dfs(link[i]))&#123; linkx[x] = i; link[i] = x; return true; &#125; &#125; else if(t &gt; 0)&#123; //找出边权与顶标和的最小的差值 if(t &lt; minD)&#123; minD = t; &#125; &#125; &#125; &#125; return false;&#125;int km()&#123; memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(link, 0, sizeof link); memset(wy, 0, sizeof(wy)); for(int i = 1; i &lt;= cntx; i++)&#123; wx[i] = -inf; for(int j = 1; j &lt;= cnty; j++)&#123; if(wx[i] &lt; edge[i][j])&#123; wx[i] = edge[i][j];//初始化为权值最大的边的权值 &#125; &#125; &#125; for(int i = 1; i &lt;= cntx; i++)&#123; while(1)&#123; minD = inf; memset(visx, false, sizeof visx); memset(visy, false, sizeof visy); if(dfs(i))&#123; break; &#125; for(int j = 1; j &lt;= cntx; j++)&#123; //将交错树中X部的点的顶标减去minz if(visx[j])&#123; wx[j] -= minD; &#125; &#125; for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz if(visy[j])&#123; wy[j] += minD; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnty; i ++)&#123; if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123; ans += edge[link[i]][i]; &#125; &#125; return -ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cntx = cnty = n; for(int i = 0; i &lt;= cntx; i++)&#123; for(int j = 0; j &lt;= cnty; j++)&#123; edge[i][j] = -inf; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); edge[u][v] = max(edge[u][v], -w); &#125; printf(&quot;%d\n&quot;, km()); &#125; return 0;&#125; 强连通Tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 7;const int inf = 0x3f3f3f3f;int n, m;int head[maxn], cnt, top, dfs_num, col_num;int dfn[maxn], low[maxn], Stack[maxn], color[maxn];bool vis[maxn];struct EDGE&#123; int next, to, u;&#125;edge[maxn&lt;&lt;3];void add(int u, int v)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].u = u; head[u] = cnt++;&#125;void Tarjan(int x)&#123; dfn[x] = ++dfs_num; low[x] = dfs_num; vis[x] = true; //是否在栈中 Stack[++top] = x; for(int i = head[x]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!dfn[v])&#123; Tarjan(v); low[x] = min(low[x], low[v]); &#125; else if(vis[v])&#123; low[x] = min(low[x], dfn[v]); &#125; &#125; if(dfn[x] == low[x])&#123; //构成强连通分量 vis[x] = false; color[x] = ++col_num; //染色 while(Stack[top] != x)&#123; //清空 color[Stack[top]] = col_num; vis [ Stack[ top-- ] ] = false ; &#125; top--; &#125;&#125;void init()&#123; top = dfs_num = col_num = cnt = 0; memset(head, -1, sizeof(head)); memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(color, 0, sizeof(color)); memset(vis, false, sizeof(vis));&#125;void read()&#123; int u, v; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= n; i++)&#123; if(!color[i])&#123; Tarjan(i); &#125; &#125; if(col_num != 1)&#123; printf(&quot;No\n&quot;); &#125; else&#123; printf(&quot;Yes\n&quot;); &#125;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m)&#123; init(); read(); solve(); &#125; return 0;&#125; Tarjan缩点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#define MAXN 10010#define MAXE 100010using namespace std;int head[MAXN],tot1,tot2;struct Edge&#123; int u,v,next;&#125;e1[MAXE],e2[MAXN];void addEdge(int u,int v,Edge* edge,int&amp; tol)&#123; edge[tol].u=u;edge[tol].v=v; edge[tol].next=head[u];head[u]=tol++;&#125;int n,m;int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];bool instack[MAXN];int scc,top,INDEX;void Tarjan(int u)&#123; int v; low[u]=dfn[u]=++INDEX; stack[top++]=u; instack[u]=true; for(int i=head[u];i!=-1;i=e1[i].next)&#123; v=e1[i].v; if(!dfn[v])&#123; Tarjan(v); if(low[u]&gt;low[v]) low[u]=low[v]; &#125; else if(instack[v]&amp;&amp;low[u]&gt;dfn[v]) low[u]=dfn[v]; &#125; if(low[u]==dfn[u])&#123; ++scc; do&#123; v=stack[--top]; instack[v]=false; belong[v]=scc; num[scc]++; &#125;while(u!=v); &#125;&#125;int inde[MAXN],outde[MAXN];void solve()&#123; memset(dfn,0,sizeof(dfn)); memset(instack,false,sizeof(instack)); memset(num,0,sizeof(num)); scc=top=INDEX=0; for(int i=1;i&lt;=n;++i) if(!dfn[i]) Tarjan(i); tot2=0;memset(head,-1,sizeof(head)); memset(inde,0,sizeof(inde)); memset(outde,0,sizeof(outde)); int u,v; for(int i=0;i&lt;m;++i)&#123; u=belong[e1[i].u]; v=belong[e1[i].v]; if(u!=v)&#123; addEdge(u,v,e2,tot2); inde[v]++; outde[u]++; &#125; &#125; int a=0,b=0; for(int i=1;i&lt;=scc;++i)&#123; if(!inde[i]) a++; if(!outde[i]) b++; &#125; if(scc==1)printf(&quot;0\n&quot;); else printf(&quot;%d\n&quot;,max(a,b));&#125;int main()&#123; int zushu; scanf(&quot;%d&quot;,&amp;zushu); while(zushu--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tot1=0;memset(head,-1,sizeof(head)); int u,v; for(int i=0;i&lt;m;++i)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addEdge(u,v,e1,tot1); &#125; solve(); &#125; return 0;&#125; 2-SAT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135HDU 3622/*HDU 3622题意:给n对炸弹可以放置的位置(每个位置为一个二维平面上的点),每次放置炸弹是时只能选择这一对中的其中一个点,每个炸弹爆炸的范围半径都一样,控制爆炸的半径使得所有的爆炸范围都不相交(可以相切),求解这个最大半径. 首先二分最大半径值,然后2-sat构图判断其可行性,对于每 两队位置(u,uu)和(v,vv),如果u和v之间的距离小于2*id,也就 是说位置u和位置v处不能同时防止炸弹(两范围相交),所以连边(u,vv) 和(v,uu),求解强连通分量判断可行性.注意精度问题*/#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;const int MAXN=210;const int MAXM=40005;//边的最大数const double eps=1e-5;struct Edge&#123; int to,next;&#125;edge1[MAXM],edge2[MAXM];int head1[MAXN];int head2[MAXN];int tol1,tol2;bool vis1[MAXN],vis2[MAXN];int Belong[MAXN];//连通分量标记int T[MAXN];//dfs结点结束时间int Bcnt,Tcnt;void add(int a,int b)//原图和逆图都要添加&#123; edge1[tol1].to=b; edge1[tol1].next=head1[a]; head1[a]=tol1++; edge2[tol2].to=a; edge2[tol2].next=head2[b]; head2[b]=tol2++;&#125;void init()//建图前初始化&#123; memset(head1,-1,sizeof(head1)); memset(head2,-1,sizeof(head2)); memset(vis1,false,sizeof(vis1)); memset(vis2,false,sizeof(vis2)); tol1=tol2=0; Bcnt=Tcnt=0;&#125;void dfs1(int x)//对原图进行dfs,算出每个结点的结束时间，哪个点开始无所谓&#123; vis1[x]=true; int j; for(int j=head1[x];j!=-1;j=edge1[j].next) if(!vis1[edge1[j].to]) dfs1(edge1[j].to); T[Tcnt++]=x;&#125;void dfs2(int x)&#123; vis2[x]=true; Belong[x]=Bcnt; int j; for(j=head2[x];j!=-1;j=edge2[j].next) if(!vis2[edge2[j].to]) dfs2(edge2[j].to);&#125;struct Point&#123; int x,y;&#125;s[MAXN];double dist(Point a,Point b)&#123; return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;bool ok(int n)//判断可行性&#123; for(int i=0;i&lt;2*n;i++) if(!vis1[i]) dfs1(i); for(int i=Tcnt-1;i&gt;=0;i--) if(!vis2[T[i]])//这个别写错，是vis2[T[i]] &#123; dfs2(T[i]); Bcnt++; &#125; for(int i=0;i&lt;=2*n-2;i+=2) if(Belong[i]==Belong[i+1]) return false; return true;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int n; double left,right,mid; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d%d%d%d&quot;,&amp;s[2*i].x,&amp;s[2*i].y,&amp;s[2*i+1].x,&amp;s[2*i+1].y); left=0; right=40000.0; while(right-left&gt;=eps) &#123; mid=(left+right)/2; init(); for(int i=0;i&lt;2*n-2;i++) &#123; int t; if(i%2==0)t=i+2; else t=i+1; for(int j=t;j&lt;2*n;j++) if(dist(s[i],s[j])&lt;2*mid)//冲突了 &#123; add(i,j^1); add(j,i^1);//注意顺序不能变的 &#125; &#125; if(ok(n))left=mid; else right=mid; &#125; printf(&quot;%.2lf\n&quot;,right); &#125; return 0;&#125; 数学数论gcd123int gcd(int a, int b)&#123; return !b ? a : gcd(b, a%b);&#125; exgcd123456789int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if (b==0)&#123; x=1,y=0; return a; &#125; int d=exgcd(b,a%b,y,x); y-=a/b*x; return d;&#125; 中国剩余定理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std; int Extended_Euclid(int a,int b,int &amp;x,int &amp;y) //扩展欧几里得算法&#123; int d; if(b==0) &#123; x=1;y=0; return a; &#125; d=Extended_Euclid(b,a%b,y,x); y-=a/b*x; return d;&#125; int Chinese_Remainder(int a[],int w[],int len) //中国剩余定理 a[]存放余数 w[]存放两两互质的数&#123; int i,d,x,y,m,n,ret; ret=0; n=1; for (i=0;i&lt;len;i++) n*=w[i]; for (i=0;i&lt;len;i++) &#123; m=n/w[i]; d=Extended_Euclid(w[i],m,x,y); ret=(ret+y*m*a[i])%n; &#125; return (n+ret%n)%n;&#125; int main()&#123; int n,i; int w[15],b[15]; while (scanf(&quot;%d&quot;,&amp;n),n) &#123; for (i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;w[i],&amp;b[i]); &#125; printf(&quot;%d/n&quot;,Chinese_Remainder(b,w,n)); &#125; return 0;&#125; 欧拉函数12345678910111213int oula(int n)&#123; int rea=n; for(int i=2; i&lt;=n; i++) if(n%i==0)//第一次找到的必为素因子 &#123; rea=rea-rea/i; do n/=i;//把该素因子全部约掉 while(n%i==0); &#125; return rea;&#125; 欧拉筛123456789101112131415161718int prime[maxn];int visit[maxn];void Prime()&#123; mem(visit,0); mem(prime, 0); for (int i = 2;i &lt;= maxn; i++) &#123; cout&lt;&lt;&quot; i = &quot;&lt;&lt;i&lt;&lt;endl; if (!visit[i]) &#123; prime[++prime[0]] = i; //纪录素数， 这个prime[0] 相当于 cnt，用来计数 &#125; for (int j = 1; j &lt;=prime[0] &amp;&amp; i*prime[j] &lt;= maxn; j++) &#123; visit[i*prime[j]] = 1; if (i % prime[j] == 0) &#123; break; &#125; &#125; &#125;&#125; 卡特兰数卡特兰数打表12345678910111213141516#include &lt;stdio.h&gt;unsigned long long ctl[34] = &#123;0,1&#125;;void calc()&#123; int i; for(i = 2; i &lt; 34; i ++) ctl[i] = ctl[i-1]*(4*i-2)/(i+1);&#125; int main()&#123; int i; calc(); for(i = 0; i &lt; 34; i ++) printf(&quot;%d: %llu\n&quot;,i, ctl[i]);&#125; 卡特兰数表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;string catalan[]=&#123; &quot;1&quot;, &quot;2&quot;, &quot;5&quot;, &quot;14&quot;, &quot;42&quot;, &quot;132&quot;, &quot;429&quot;, &quot;1430&quot;, &quot;4862&quot;, &quot;16796&quot;, &quot;58786&quot;, &quot;208012&quot;, &quot;742900&quot;, &quot;2674440&quot;, &quot;9694845&quot;, &quot;35357670&quot;, &quot;129644790&quot;, &quot;477638700&quot;, &quot;1767263190&quot;, &quot;6564120420&quot;, &quot;24466267020&quot;, &quot;91482563640&quot;, &quot;343059613650&quot;, &quot;1289904147324&quot;, &quot;4861946401452&quot;, &quot;18367353072152&quot;, &quot;69533550916004&quot;, &quot;263747951750360&quot;, &quot;1002242216651368&quot;, &quot;3814986502092304&quot;, &quot;14544636039226909&quot;, &quot;55534064877048198&quot;, &quot;212336130412243110&quot;, &quot;812944042149730764&quot;, &quot;3116285494907301262&quot;, &quot;11959798385860453492&quot;, &quot;45950804324621742364&quot;, &quot;176733862787006701400&quot;, &quot;680425371729975800390&quot;, &quot;2622127042276492108820&quot;, &quot;10113918591637898134020&quot;, &quot;39044429911904443959240&quot;, &quot;150853479205085351660700&quot;, &quot;583300119592996693088040&quot;, &quot;2257117854077248073253720&quot;, &quot;8740328711533173390046320&quot;, &quot;33868773757191046886429490&quot;, &quot;131327898242169365477991900&quot;, &quot;509552245179617138054608572&quot;, &quot;1978261657756160653623774456&quot;, &quot;7684785670514316385230816156&quot;, &quot;29869166945772625950142417512&quot;, &quot;116157871455782434250553845880&quot;, &quot;451959718027953471447609509424&quot;, &quot;1759414616608818870992479875972&quot;, &quot;6852456927844873497549658464312&quot;, &quot;26700952856774851904245220912664&quot;, &quot;104088460289122304033498318812080&quot;, &quot;405944995127576985730643443367112&quot;, &quot;1583850964596120042686772779038896&quot;, &quot;6182127958584855650487080847216336&quot;, &quot;24139737743045626825711458546273312&quot;, &quot;94295850558771979787935384946380125&quot;, &quot;368479169875816659479009042713546950&quot;, &quot;1440418573150919668872489894243865350&quot;, &quot;5632681584560312734993915705849145100&quot;, &quot;22033725021956517463358552614056949950&quot;, &quot;86218923998960285726185640663701108500&quot;, &quot;337485502510215975556783793455058624700&quot;, &quot;1321422108420282270489942177190229544600&quot;, &quot;5175569924646105559418940193995065716350&quot;, &quot;20276890389709399862928998568254641025700&quot;, &quot;79463489365077377841208237632349268884500&quot;, &quot;311496878311103321137536291518809134027240&quot;, &quot;1221395654430378811828760722007962130791020&quot;, &quot;4790408930363303911328386208394864461024520&quot;, &quot;18793142726809884575211361279087545193250040&quot;, &quot;73745243611532458459690151854647329239335600&quot;, &quot;289450081175264899454283846029490767264392230&quot;, &quot;1136359577947336271931632877004667456667613940&quot;, &quot;4462290049988320482463241297506133183499654740&quot;, &quot;17526585015616776834735140517915655636396234280&quot;, &quot;68854441132780194707888052034668647142985206100&quot;, &quot;270557451039395118028642463289168566420671280440&quot;, &quot;1063353702922273835973036658043476458723103404520&quot;, &quot;4180080073556524734514695828170907458428751314320&quot;, &quot;16435314834665426797069144960762886143367590394940&quot;, &quot;64633260585762914370496637486146181462681535261000&quot;, &quot;254224158304000796523953440778841647086547372026600&quot;, &quot;1000134600800354781929399250536541864362461089950800&quot;, &quot;3935312233584004685417853572763349509774031680023800&quot;, &quot;15487357822491889407128326963778343232013931127835600&quot;, &quot;60960876535340415751462563580829648891969728907438000&quot;, &quot;239993345518077005168915776623476723006280827488229600&quot;, &quot;944973797977428207852605870454939596837230758234904050&quot;, &quot;3721443204405954385563870541379246659709506697378694300&quot;, &quot;14657929356129575437016877846657032761712954950899755100&quot;, &quot;57743358069601357782187700608042856334020731624756611000&quot;, &quot;227508830794229349661819540395688853956041682601541047340&quot;, &quot;896519947090131496687170070074100632420837521538745909320&quot;&#125;;int main()&#123; int i; while(scanf(&quot;%d&quot;,&amp;i)!=EOF)&#123; cout&lt;&lt;catalan[i-1]&lt;&lt;endl; &#125;&#125; 斯特林数第一类斯特林数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define RI register intconst int N=200005,mod=998244353,G=3;int n,A,B,ans,a[18][N],rev[N];int ksm(int x,int y) &#123; int re=1; for(RI i=y;i;i&gt;&gt;=1,x=1LL*x*x%mod) if(i&amp;1) re=1LL*re*x%mod; return re;&#125;void NTT(int *a,int n,int x) &#123; for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]); for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123; int gn=ksm(G,(mod-1)/(i&lt;&lt;1)); for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123; int g=1,t1,t2; for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123; t1=a[j+k],t2=1LL*g*a[j+i+k]%mod; a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod; &#125; &#125; &#125; if(x==1) return; int inv=ksm(n,mod-2);reverse(a+1,a+n);//a+1!!! for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;&#125;void work(int s,int t,int d) &#123; if(s==t) &#123;a[d][0]=s,a[d][1]=1;return;&#125; int mid=(s+t)&gt;&gt;1,len=0,kn=1; work(s,mid,d+1); for(RI i=0;i&lt;=mid-s+1;++i) a[d][i]=a[d+1][i]; work(mid+1,t,d+1); while(kn&lt;=t-s+1) kn&lt;&lt;=1,++len; for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1)); for(RI i=mid-s+2;i&lt;kn;++i) a[d][i]=0; for(RI i=t-mid+1;i&lt;kn;++i) a[d+1][i]=0; NTT(a[d],kn,1),NTT(a[d+1],kn,1); for(RI i=0;i&lt;kn;++i) a[d][i]=1LL*a[d][i]*a[d+1][i]%mod; NTT(a[d],kn,-1);&#125;int C(int d,int u) &#123; int k1=1,k2=1; for(RI i=d-u+1;i&lt;=d;++i) k1=1LL*k1*i%mod; for(RI i=1;i&lt;=u;++i) k2=1LL*k2*i%mod; return 1LL*k1*ksm(k2,mod-2)%mod;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;A,&amp;B); if(!A||!B||A+B-2&gt;n-1) &#123;puts(&quot;0&quot;);return 0;&#125; if(n==1) &#123;puts(&quot;1&quot;);return 0;&#125; work(0,n-2,0); ans=1LL*a[0][A+B-2]*C(A+B-2,B-1)%mod; printf(&quot;%d\n&quot;,ans); return 0;&#125; 第二类斯特林数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define RI register intconst int mod=998244353,G=3,N=262150;int n,kn,len,ans;int a[N],b[N],fac[N],ni[N],rev[N];int ksm(int x,int y) &#123; int re=1; for(;y;y&gt;&gt;=1,x=1LL*x*x%mod) if(y&amp;1) re=1LL*re*x%mod; return re;&#125;void NTT(int *a,int n,int x) &#123; for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]); for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123; int gn=ksm(G,(mod-1)/(i&lt;&lt;1)); for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123; int g=1,t1,t2; for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123; t1=a[j+k],t2=1LL*g*a[j+i+k]%mod; a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod; &#125; &#125; &#125; if(x==1) return; int inv=ksm(n,mod-2);reverse(a+1,a+n); for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); fac[0]=1;for(RI i=1;i&lt;=n;++i) fac[i]=1LL*fac[i-1]*i%mod; ni[n]=ksm(fac[n],mod-2); for(RI i=n-1;i&gt;=0;--i) ni[i]=1LL*ni[i+1]*(i+1)%mod; for(RI i=0;i&lt;=n;++i) &#123; a[i]=1LL*(1-2*(i&amp;1)+mod)%mod*ni[i]%mod; if(i!=1) b[i]=1LL*(ksm(i,n+1)-1+mod)%mod*ni[i]%mod*ksm(i-1+mod,mod-2)%mod; else b[i]=n+1; &#125; kn=1;while(kn&lt;=n+n) kn&lt;&lt;=1,++len; for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1)); NTT(a,kn,1),NTT(b,kn,1); for(RI i=0;i&lt;kn;++i) a[i]=1LL*a[i]*b[i]%mod; NTT(a,kn,-1); for(RI i=0,j=1;i&lt;=n;++i,j=(j+j)%mod) ans=(ans+1LL*j*fac[i]%mod*a[i]%mod)%mod; printf(&quot;%d\n&quot;,ans); return 0;&#125; 逆元逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p 观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。 注意在下面所有的算法中，最好先把除数取个模再运算。 扩展欧几里得算法原理a∗b≡1(modp)a∗b≡1(modp)a∗b+k∗p=1a∗b+k∗p=1然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。 如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元 代码 1234567891011121314151617LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 &#123; if(b==0) &#123; x=1,y=0; return a; &#125; LL ret=exgcd(b,a%b,y,x); y-=a/b*x; return ret;&#125;LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 &#123; LL x,y; LL d=exgcd(a,mod,x,y); return d==1?(x%mod+mod)%mod:-1;&#125; 注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大. 性能分析: 时间复杂度:O(logn)（实际是斐波那契数列）适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。 费马小定理/欧拉定理原理费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp)ap−2∗a≡1(modp)ap−2∗a≡1(modp)ap−2ap−2就是a在mod p意义下的逆元啦。 欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式)aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp)aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。 代码 123456789101112131415LL qkpow(LL a,LL p,LL mod)&#123; LL t=1,tt=a%mod; while(p) &#123; if(p&amp;1)t=t*tt%mod; tt=tt*tt%mod; p&gt;&gt;=1; &#125; return t;&#125;LL getInv(LL a,LL mod)&#123; return qkpow(a,mod-2,mod);&#125; 性能分析： O(logmod)适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。但是如果是合数，相信一般没人无聊到去算个欧拉函数。 递推求逆元原理p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%ik∗i+r≡0(modp)k∗i+r≡0(modp)k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp)i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp)i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi]嗯。。好难看的公式说白了就是:inv[i]=-(mod/i)*inv[i%mod]然后边界是inv[1]=1这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法 代码线性求逆元 1234567LL inv[mod+5];void getInv(LL mod)&#123; inv[1]=1; for(int i=2;i&lt;mod;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;&#125; 注意： 调用前要先预处理调用的时候要先对除数取mod性能分析： 时间复杂度O(n)适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。递归求逆元 12345LL inv(LL i)&#123; if(i==1)return 1; return (mod-mod/i)*inv(mod%i)%mod;&#125; 性能分析 时间复杂度:O(logmod)好像找到了最简单的算法了！！ 适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。 miller-rabin，Pollard_rho算法大素数判断和素因子分解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//****************************************************************// Miller_Rabin 算法进行素数测试//速度快，而且可以判断 &lt;2^63的数//****************************************************************const int S=20;//随机算法判定次数，S越大，判错概率越小//计算 (a*b)%c. a,b都是long long的数，直接相乘可能溢出的// a,b,c &lt;2^63long long mult_mod(long long a,long long b,long long c)&#123; a%=c; b%=c; long long ret=0; while(b) &#123; if(b&amp;1)&#123;ret+=a;ret%=c;&#125; a&lt;&lt;=1; if(a&gt;=c)a%=c; b&gt;&gt;=1; &#125; return ret;&#125;//计算 x^n %clong long pow_mod(long long x,long long n,long long mod)//x^n%c&#123; if(n==1)return x%mod; x%=mod; long long tmp=x; long long ret=1; while(n) &#123; if(n&amp;1) ret=mult_mod(ret,tmp,mod); tmp=mult_mod(tmp,tmp,mod); n&gt;&gt;=1; &#125; return ret;&#125;//以a为基,n-1=x*2^t a^(n-1)=1(mod n) 验证n是不是合数//一定是合数返回true,不一定返回falsebool check(long long a,long long n,long long x,long long t)&#123; long long ret=pow_mod(a,x,n); long long last=ret; for(int i=1;i&lt;=t;i++) &#123; ret=mult_mod(ret,ret,n); if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数 last=ret; &#125; if(ret!=1) return true; return false;&#125;// Miller_Rabin()算法素数判定//是素数返回true.(可能是伪素数，但概率极小)//合数返回false;bool Miller_Rabin(long long n)&#123; if(n&lt;2)return false; if(n==2)return true; if((n&amp;1)==0) return false;//偶数 long long x=n-1; long long t=0; while((x&amp;1)==0)&#123;x&gt;&gt;=1;t++;&#125; for(int i=0;i&lt;S;i++) &#123; long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件 if(check(a,n,x,t)) return false;//合数 &#125; return true;&#125;//************************************************//pollard_rho 算法进行质因数分解//************************************************long long factor[100];//质因数分解结果（刚返回时是无序的）int tol;//质因数的个数。数组小标从0开始long long gcd(long long a,long long b)&#123; if(a==0)return 1;//??????? if(a&lt;0) return gcd(-a,b); while(b) &#123; long long t=a%b; a=b; b=t; &#125; return a;&#125;long long Pollard_rho(long long x,long long c)&#123; long long i=1,k=2; long long x0=rand()%x; long long y=x0; while(1) &#123; i++; x0=(mult_mod(x0,x0,x)+c)%x; long long d=gcd(y-x0,x); if(d!=1&amp;&amp;d!=x) return d; if(y==x0) return x; if(i==k)&#123;y=x0;k+=k;&#125; &#125;&#125;//对n进行素因子分解void findfac(long long n)&#123; if(Miller_Rabin(n))//素数 &#123; factor[tol++]=n; return; &#125; long long p=n; while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1); findfac(p); findfac(n/p);&#125;int main()&#123; //srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话 long long n; while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF) &#123; tol=0; findfac(n); for(int i=0;i&lt;tol;i++)printf(&quot;%I64d &quot;,factor[i]); printf(&quot;\n&quot;); if(Miller_Rabin(n))printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0;&#125; 组合数学Lucas定理费马小定理实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll mulit(ll a,ll b,ll m)&#123; ll ans=0; while(b)&#123; if(b&amp;1) ans=(ans+a)%m; a=(a&lt;&lt;1)%m; b&gt;&gt;=1; &#125; return ans;&#125;ll quick_mod(ll a,ll b,ll m)&#123; ll ans=1; while(b)&#123; if(b&amp;1)&#123; ans=mulit(ans,a,m); &#125; a=mulit(a,a,m); b&gt;&gt;=1; &#125; return ans;&#125;ll comp(ll a,ll b,ll m)&#123; if(a&lt;b) return 0; if(a==b) return 1; if(b&gt;a-b) b=a-b; ll ans=1,ca=1,cb=1; for(int i=0;i&lt;b;i++)&#123; ca=ca*(a-i)%m; cb=cb*(b-i)%m; &#125; ans=ca*quick_mod(cb,m-2,m)%m; return ans;&#125;ll lucas(ll a,ll b,ll m)&#123; ll ans=1; while(a&amp;&amp;b)&#123; ans=(ans*comp(a%m,b%m,m))%m; a/=m; b/=m; &#125; return ans;&#125;int main()&#123; ll a,b,m; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;m)&#123; cout&lt;&lt;lucas(a,b,m)&lt;&lt;endl; &#125; return 0;&#125; exgcd实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123; if(a%b==0)&#123; x=0,y=1; return b; &#125; ll r,tx,ty; r=exgcd(b,a%b,tx,ty); x=ty; y=tx-a/b*ty;&#125;ll comp(ll a,ll b,ll m)&#123; if(a&lt;b) return 0; if(a==b) return 1; if(b&gt;a-b) b=a-b; ll ans=1,ca=1,cb=1; for(int i=0;i&lt;b;i++)&#123; ca=ca*(a-i)%m; cb=cb*(b-i)%m; &#125; ll x,y; exgcd(cb,m,x,y); x=(x%m+m)%m; ans=ca*x%m; return ans;&#125;ll lucas(ll a,ll b,ll m)&#123; ll ans=1; while(a&amp;&amp;b)&#123; ans=(ans*comp(a%m,b%m,m))%m; a/=m; b/=m; &#125; return ans;&#125;int main()&#123; ll a,b,m; int n; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;m; cout&lt;&lt;lucas(a+b,b,m)&lt;&lt;endl; &#125; return 0;&#125; 全排列全组合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/**** **** **** **** **** ***** Function Name : 全排列,全组合**** **** **** **** **** ****/void createper(int n) //全排列&#123; int total,i,j,k,t,*a=new int[n],top; total=1; for(i=1; i&lt;=n; i++) &#123; a[i]=i; total*=i; &#125; for(i=1; i&lt;n; i++) printf(&quot;%d &quot;,a[i]); printf(&quot;%d\n&quot;,a[n]); for(i=1; i&lt;total; i++) &#123; j=n; while(a[j]&lt;a[j-1]) j--; k=n; while(a[j-1]&gt;a[k]) k--; t=a[j-1]; a[j-1]=a[k]; a[k]=t; top=(j+n-1)/2; for(k=j; k&lt;=top; k++) &#123; t=a[k]; a[k]=a[n-k+j]; a[n-k+j]=t; &#125; for(j=1; j&lt;n; j++) printf(&quot;%d &quot;,a[j]); printf(&quot;%d\n&quot;,a[n]); &#125;&#125;void createfab(int m,int n) //全组合&#123; int i,j,lcount,*a=new int[n+2]; for(i=1; i&lt;=n; i++) a[i]=i; a[n+1]=m+1; for(j=1; j&lt;n; j++) printf(&quot;%d &quot;,a[j]); printf(&quot;%d\n&quot;,a[n]); lcount=1; while(a[1]&lt;m-n+1) &#123; for(i=n; i&gt;0; i--) &#123; if(a[i]&lt;a[i+1]-1) &#123; a[i]++; for(j=i; j&lt;n; j++) a[j+1]=a[j]+1; for(j=1; j&lt;n; j++) printf(&quot;%d &quot;,a[j]); printf(&quot;%d\n&quot;,a[n]); lcount++; break; &#125; &#125; &#125;&#125; 母函数1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;// Author: Tanky Woo// www.wutianqi.comconst int _max = 10001; // c1是保存各项质量砝码可以组合的数目// c2是中间量，保存每一次的情况int c1[_max], c2[_max]; int main()&#123; //int n,i,j,k; int nNum; // int i, j, k; while(cin &gt;&gt; nNum) &#123; for(i=0; i&lt;=nNum; ++i) // ---- ① &#123; c1[i] = 1; c2[i] = 0; &#125; for(i=2; i&lt;=nNum; ++i) // ----- ② &#123; for(j=0; j&lt;=nNum; ++j) // ----- ③ for(k=0; k+j&lt;=nNum; k+=i) // ---- ④ &#123; c2[j+k] += c1[j]; &#125; for(j=0; j&lt;=nNum; ++j) // ---- ⑤ &#123; c1[j] = c2[j]; c2[j] = 0; &#125; &#125; cout &lt;&lt; c1[nNum] &lt;&lt; endl; &#125; return 0;&#125; 容斥原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int p[10]=&#123;0&#125;;int k;void getp(int n)&#123; k=0; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; p[k++]=i; &#125; while(n%i==0) n/=i; &#125; if(n&gt;1) p[k++]=n;&#125;int nop(int m)&#123; int que[1000]; int top=0; que[top++]=-1; for(int i=0;i&lt;k;i++) &#123; int t=top; for(int j=0;j&lt;t;j++) &#123; que[top++]=que[j]*p[i]*(-1); &#125; &#125; int sum=0; for(int i=1;i&lt;top;i++) &#123; sum+=m/que[i]; &#125; return sum;&#125;int main()&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); getp(n); printf(&quot;%d\n&quot;,m-nop(m)); return 0;&#125; 莫比乌斯反演12345678910111213141516171819202122232425262728293031const int MAXN = 1000000;bool check[MAXN+10];int prime[MAXN+10];int mu[MAXN+10];void Moblus()&#123; memset(check,false,sizeof(check)); mu[1] = 1; int tot = 0; for(int i = 2; i &lt;= MAXN; i++) &#123; if( !check[i] ) &#123; prime[tot++] = i; mu[i] = −1; &#125; for(int j = 0; j &lt; tot; j++) &#123; if(i * prime[j] &gt; MAXN) break; check[i * prime[j]] = true; if( i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; else &#123; mu[i * prime[j]] = −mu[i]; &#125; &#125; 莫比乌斯Euler打表123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e2;int phi[MAXN],n,tot;int pri[MAXN];bool mark[MAXN];void getphi()&#123; phi[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(!mark[i])&#123; phi[i]=i-1; pri[++tot]=i; &#125; for(int j=1;j&lt;=tot;j++)&#123; int x=pri[j]; if(i*x&gt;n) break; mark[i*x]=1; if(i%x==0)&#123; phi[i*x]=phi[i]*x; break; &#125; else phi[i*x]=phi[i]*phi[x]; &#125; &#125;&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; tot=0; getphi(); printf(&quot;%d\n&quot;,phi[n]); &#125; return 0;&#125; 离散对数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123; if (!b) &#123;x = 1; y = 0; return a;&#125; long long d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d;&#125;long long inv(long long a, long long n) &#123; long long x, y; exgcd(a, n, x, y); return (x + n) % n;&#125;long long pow_mod(long long x, long long k, long long n) &#123; if (k == 0) return 1; long long ans = pow_mod(x * x % n, k&gt;&gt;1, n); if (k&amp;1) ans = ans * x % n; return ans;&#125;long long log_mod(long long a, long long b, long long n) &#123; long long m = (long long)sqrt(n + 0.5), v, e = 1, i; v = inv(pow_mod(a, m, n), n); map&lt;long long, long long&gt; x; x[1] = 0; for (long long i = 1; i &lt; m; i++) &#123; e = e * a % n; if (!x.count(e)) x[e] = i; &#125; for (long long i = 0; i &lt; m; i++) &#123; if (x.count(b)) return i * m + x[b]; b = b * v % n; &#125; return -1;&#125;const long long MOD = 100000007;long long n, k, b, r, Max, x[505], y[505];typedef pair&lt;long long, long long&gt; pii;set&lt;pii&gt; beats;long long cal() &#123; long long ans = 0; for (long long i = 0; i &lt; b; i++) &#123; if (x[i] != Max &amp;&amp; !beats.count(make_pair(x[i] + 1, y[i]))) ans++; &#125; ans += n; for (long long i = 0; i &lt; b; i++) if (x[i] == 1) ans--; return pow_mod(k, ans, MOD) * pow_mod(k - 1, Max * n - b - ans, MOD) % MOD;&#125;long long solve() &#123; long long m = cal(); if (m == r) return Max; long long tmp = n; for (long long i = 0; i &lt; b; i++) if (x[i] == Max) tmp--; long long ans = pow_mod(k - 1, tmp, MOD) * pow_mod(k, n - tmp, MOD) % MOD; m = m * ans % MOD; if (m == r) return Max + 1; return log_mod(pow_mod(k - 1, n, MOD), r * inv(m, MOD) % MOD, MOD) + Max + 1;&#125;int main() &#123; while (~scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;k, &amp;b, &amp;r)) &#123; beats.clear(); Max = 1; for (long long i = 0; i &lt; b; i++) &#123; scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); beats.insert(make_pair(x[i], y[i])); Max = max(Max, x[i]); &#125; printf(&quot;%lld\n&quot;,solve()); &#125; return 0;&#125; 自适应 simpson 积分1234567891011121314double simpson(double a,double b)&#123; double c = a + (b−a)/2; return (F(a) + 4*F(c) + F(b))*(b−a)/6&#125;double asr(double a,double b,double eps,double A)&#123; double c = a + (b−a)/2; double L = simpson(a,c), R = simpson(c,b); if(fabs(L + R − A) &lt;= 15*eps) return L + R + (L + R − A)/15.0; return asr(a,c,eps/2,L) + asr(c,b,eps/2,R)&#125;double asr(double a,double b,double eps)return asr(a,b,eps,simpson(a,b)); 线性代数快速幂1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int pow_mod(int a, int n, int m)&#123; long long ans = 1; while(n)&#123; if(n&amp;1)&#123; ans = (ans * a) % m; &#125; a = (a * a) % m; n &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; int a, n, m; cin &gt;&gt; a &gt;&gt; n &gt;&gt; m; cout &lt;&lt; pow_mod(a, n, m);&#125; 矩阵快速幂1234567891011121314151617181920212223242526const int N=10; int tmp[N][N]; void multi(int a[][N],int b[][N],int n) &#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) tmp[i][j]+=a[i][k]*b[k][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) a[i][j]=tmp[i][j]; &#125; int res[N][N]; void Pow(int a[][N],int n) &#123; memset(res,0,sizeof res);//n是幂，N是矩阵大小 for(int i=0;i&lt;N;i++) res[i][i]=1; while(n) &#123; if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; &#125; &#125; 快速乘如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。 O(logn)快速乘123456789inline LL quick_mul(LL a,LL n,LL m)&#123; LL ans=0; while(n)&#123; if(n&amp;1) ans=(ans+a)%m; a=(a&lt;&lt;1)%m; n&gt;&gt;=1; &#125; return ans;&#125; O(1)快速乘12345678typedef long long ll;#define MOL 123456789012345LLinline ll mul_mod_ll(ll a,ll b)&#123; ll d=(ll)floor(a*(long double)b/MOL+0.5); ll ret=a*b-d*MOL; if(ret&lt;0) ret+=MOL; return ret;&#125; 首先，使用浮点数计算 ab/MOL 的值，关键在于第二句，显然 ab - d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。 考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。 模板123inline ll ksc(ll x,ll y,ll mod)&#123; return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125; 因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。 高斯消元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/**** **** **** **** **** ***** Function Name : 高斯消元法* Description : 求解线性方程组** void exchange_col(int p1,int p2,int n)* 交换 p1 行和 p2 行的所有数据** bool gauss(int n)* 求解系数矩阵为 n 的线性方程组，方程组无解返回 false，否则 true** x1 = x0 - f(x0)/f&apos;(x0) 牛顿迭代法**** **** **** **** **** ****/const int num = 100;double matrix[num][num + 1]; //系数矩阵，从 0 开始double ans[num]; //结果数组void exchange_col(int p1,int p2,int n) //交换 p1 行和 p2 行的所有数据&#123; double t; int i; for(i = 0 ; i &lt;= n ; i++) t = matrix[p1][i],matrix[p1][i] = matrix[p2][i],matrix[p2][i] = t;&#125;bool gauss(int n) //求解系数矩阵为 n 的线性方程组&#123; int i,j,k; int p; double r; for(i = 0 ; i &lt; n - 1 ; i++) &#123; p = i; for(j = i + 1 ; j &lt; n ; j++) //寻找 i 列绝对值最大值位置 &#123; if(abs(matrix[j][i]) &gt; abs(matrix[p][i])) p = j; &#125; if(p != i) exchange_col(i,p,n); if(matrix[i][i] == 0) return false; for(j = i + 1 ; j &lt; n ; j++) //剩余列进行消元 &#123; r = matrix[j][i] / matrix[i][i]; for(k = i ; k &lt;= n ; k++) matrix[j][k] -= r * matrix[i][k]; &#125; &#125; for(i = n - 1 ; i &gt;= 0 ; i--) //获得结果 &#123; ans[i] = matrix[i][n]; for(j = n - 1 ; j &gt; i ; j--) ans[i] -= matrix[i][j] * ans[j]; if(matrix[i][i] == 0) return false; ans[i] /= matrix[i][i]; &#125; return true;&#125; 字符串字符串hash1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int HASH = 10007;const int MAXN = 2010;struct HASHMAP&#123; int head[HASH],next[MAXN],size; unsigned long long state[MAXN]; int f[MAXN]; void init() &#123; size = 0; memset(head,−1,sizeof(head)); &#125; int insert(unsigned long long val,int _id) &#123; int h = val%HASH; for(int i = head[h]; i != −1; i = next[i]) if(val == state[i]) &#123; int tmp = f[i]; f[i] = _id; return tmp; &#125; f[size] = _id; state[size] = val; next[size] = head[h]; head[h] = size++; return 0; &#125;&#125; H;const int SEED = 13331;unsigned long long P[MAXN];unsigned long long S[MAXN];char str[MAXN];int ans[MAXN][MAXN];int main()&#123; P[0] = 1; for(int i = 1; i &lt; MAXN; i++) P[i] = P[i−1] * SEED; int T; scanf(&quot;%d&quot;,&amp;T); while(T−−) &#123; scanf(&quot;%s&quot;,str); int n = strlen(str); S[0] = 0; for(int i = 1; i &lt;= n; i++) S[i] = S[i−1]*SEED + str[i−1]; memset(ans,0,sizeof(ans)); for(int L = 1; L &lt;= n; L++) &#123; H.init(); for(int i = 1; i + L − 1 &lt;= n; i++) &#123; int l = H.insert(S[i+L−1] − S[i−1]*P[L],i); ans[i][i+L−1] ++; ans[l][i+L−1]−−; &#125; &#125; for(int i = n; i &gt;= 0; i−−) for(int j = i; j &lt;= n; j++) ans[i][j] += ans[i+1][j] + ans[i][j−1] − ans[i−1]; int m,u,v; scanf(&quot;%d&quot;,&amp;m); while(m−−) &#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); printf(&quot;%d\n&quot;,ans[u][v]); &#125; &#125; return 0&#125; 字符串和数值hash1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 整数hash// 104729, 224737, 350377, 479909, 611953, 882377// 1020379, 1299709, 1583539, 1870667, 2015177// 4256233,5800079,7368787, 10570841, 15485863const int MOD = 20023;bool bhash[MOD];int vhash[MOD];int cnt[MOD];bool find_hash(int &amp; pos)&#123; int val = pos; pos %= MOD; for (; bhash[pos]; pos=(pos+1)%MOD) &#123; if (vhash[pos] == val) return true; &#125; return false;&#125;int make_hash(int val)&#123; int pos = val; if (! find_hash(pos)) &#123; bhash[pos] = true; vhash[pos] = val; cnt[pos] = 0; &#125; cnt[pos] ++; return pos;&#125;//字符串hashconst int MOD = 20023;bool bhash[MOD];char vhash[MOD][45];char str[45];int cal_str()&#123; int i, j, pos; for (i=pos=0,j=1; str[i]; i++,j=(j*27)&amp;INT_MAX,pos&amp;=INT_MAX) &#123; int num = str[i] - &apos;a&apos;; if (str[i] == &apos; &apos;) num = 26; pos += j*num; &#125; return pos % MOD;&#125;bool find_hash(int &amp; pos)&#123; pos = cal_str(); for (; bhash[pos]; pos=(pos+1)%MOD) &#123; if (strcmp(vhash[pos], str) == 0) return true; &#125; return false;&#125;int make_hash()&#123; int pos; if (! find_hash(pos)) &#123; bhash[pos] = true; strcpy(vhash[pos], str); &#125; return pos;&#125; BM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127int* CreateBC(char* pattern, int len)&#123; int* bc = new int[256]; for(int i = 0; i &lt; 256; ++i) &#123; bc[i] = -1; &#125; for(int i = 0; i &lt; len; ++i) &#123; bc[pattern[i]] = i; &#125; for(int i = 0; i &lt; 256; ++i) &#123; if(bc[i] != -1) &#123; cout &lt;&lt; &quot;bc[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; bc[i] &lt;&lt; endl; &#125; &#125; return bc;&#125; int* CreateSuffix(char* pattern, int len)&#123; int* suffix = new int[len]; suffix[len - 1] = len; for(int i = len - 2; i &gt;= 0; --i) &#123; int j = i; for(; pattern[j] == pattern[len - 1 - i + j] &amp;&amp; j &gt;= 0; --j); suffix[i] = i - j; &#125; for(int i = 0; i &lt; len; ++i) &#123; cout &lt;&lt; &quot;suffix[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; suffix[i] &lt;&lt; endl; &#125; return suffix;&#125; int* CreateGS(char* pattern, int len)&#123; int* suffix = CreateSuffix(pattern, len); int* gs = new int[len]; /* 在计算gs数组时，从移动数最大的情况依次到移动数最少的情况赋值， 确保在合理的移动范围内，移动最少的距离，避免失配的情况。 */ //第三种情况 for(int i = 1; i &lt; len; ++i) &#123; gs[i] = len; &#125; //第二种情况 for(int i = len - 1; i &gt;= 0; --i) //从右往左扫描，确保模式串移动最少。 &#123; if(suffix[i] == i + 1) //是一个与好后缀匹配的最大前缀 &#123; for(int j = 0; j &lt; len - 1 - i; ++j) &#123; if(gs[j] == len) //gs[j]初始值为len, 这样确保gs[j]只被修改一次 &#123; gs[j] = len - 1 - i; &#125; &#125; &#125; &#125; //第一种情况 for(int i = 0; i &lt; len - 1; ++i) &#123; gs[len - 1 - suffix[i]] = len - 1 - i; &#125; return gs;&#125; int bm_search(char* text, int text_len, char* pattern, int pattern_len)&#123; int* bc = CreateBC(pattern, pattern_len); int* gs = CreateGS(pattern, pattern_len); for(int i = 0; i &lt;= text_len - pattern_len; ) &#123; int j = pattern_len - 1; for(; j &gt;= 0 &amp;&amp; pattern[j] == text[i+j]; --j); if(j &lt; 0) &#123; return i; &#125; int bad_char_index = j; char bad_char = text[i + j]; int bc_move = bad_char_index - bc[bad_char]; if(bc_move &lt; 0) &#123; bc_move = bad_char_index + 1; &#125; int gs_move = gs[bad_char_index]; int move = (bc_move &gt; gs_move ? bc_move : gs_move); i += move; &#125; if(bc != NULL) &#123; delete bc; bc = NULL; &#125; if(gs != NULL) &#123; delete bc; gs = NULL; &#125; return -1;&#125; KMP123456789101112131415161718192021222324252627282930313233343536373839/**** **** **** **** **** ***** Function Name : 字符串匹配(KMP 算法)* Description : O(N+M)**** **** **** **** **** ****/void get_nextval(const string &amp; s, int * p)&#123; int i = 0,j = -1; p[0] = -1; while(i &lt; s.size()) &#123; if(j == -1 || s[i] == s[j]) &#123; ++i,++j; if(s[i] != s[j]) p[i] = j; else p[i] = p[j]; &#125; else j = p[j]; &#125;&#125;int Index_KMP(const string &amp; s, const string &amp; s1, int pos)&#123; int i = pos - 1,j = 0; int * next = new int[s1.size()]; get_nextval(s1,next); while(i &lt;= s.size() &amp;&amp; j &lt;= s1.size()) &#123; if(j == -1 || s[i] == s1[j]) ++i,++j; else j = next[j]; &#125; if(j &gt; s1.size()) return i - s1.size(); else return -1;&#125; AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;using namespace std;const int maxm=500006; //maxm是总结点数：约为字母数+++char s[1000005],word[55];int nxt[maxm][26],tail[maxm],f[maxm],size; //nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数int newnode()&#123; //初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号 memset(nxt[size],0,sizeof(nxt[size])); f[size]=tail[size]=0; return size++;&#125;void insert(char s[])&#123; //构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作 int i,p=0; for(i=0;s[i];i++)&#123; int &amp;x=nxt[p][s[i]-&apos;a&apos;]; p=x?x:x=newnode(); &#125; tail[p]++; //此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成&#125;void makenxt()&#123; //利用bfs来构造失配指针 int i; queue&lt;int&gt;q; f[0]=0; //先将0结点挂的字母加入队列，失配指针指向0结点 for(i=0;i&lt;26;i++)&#123; int v=nxt[0][i]; if(v)&#123; f[v]=0; q.push(v); &#125; &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); for(i=0;i&lt;26;i++)&#123; int v=nxt[u][i]; if(!v)nxt[u][i]=nxt[f[u]][i]; //当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母 else&#123; q.push(v); //u结点存在指向i的结点，则将所指向的结点下标加入队列 f[v]=nxt[f[u]][i]; //失配指针指向上个结点失配指针指向结点所挂当前字母的结点 &#125; &#125; &#125;&#125;int query(char s[])&#123; //查询s串中模式串出现了多少种/次 int ans=0,v=0; for(int i=0;s[i];i++)&#123; while(v&amp;&amp;!nxt[v][s[i]-&apos;a&apos;])v=f[v]; //先匹配直到没有失配 v=nxt[v][s[i]-&apos;a&apos;]; int tmp=v; while(tmp)&#123; ans+=tail[tmp]; tail[tmp]=0; //这里加这句是为了仅计算出现多少种模式链，而若不加这句则可以计算累计出现多少次 tmp=f[tmp]; &#125; &#125; return ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; int n; scanf(&quot;%d&quot;,&amp;n); size=0,newnode(); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%s&quot;,word); insert(word); &#125; makenxt(); scanf(&quot;%s&quot;,s); printf(&quot;%d\n&quot;,query(s)); &#125; return 0;&#125; 后缀自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int CHAR = 26;const int MAXN = 250010;struct SAM_Node&#123; SAM_Node *fa,*next[CHAR]; int len; long long cnt; void clear() &#123; fa = 0; memset(next,0,sizeof(next)); cnt = 0; &#125;&#125; pool[MAXN*2];SAM_Node *root,*tail;SAM_Node* newnode(int len)&#123; SAM_Node* cur = tail++; cur−&gt;clear(); cur−&gt;len = len; return cur;&#125;void SAM_init()&#123; tail = pool; root = newnode(0);&#125;SAM_Node* extend(SAM_Node* last,int x)&#123; SAM_Node *p = last, *np = newnode(p−&gt;len+1); while(p &amp;&amp; !p−&gt;next[x]) p−&gt;next[x] = np, p = p−&gt;fa; if(!p) np−&gt;fa = root; else &#123; SAM_Node* q = p−&gt;next[x]; if(q−&gt;len == p−&gt;len+1) np−&gt;fa = q; else &#123; SAM_Node* nq = newnode(p−&gt;len+1); memcpy(nq−&gt;next,q−&gt;next,sizeof(q−&gt;nextnq−&gt;fa = q−&gt;fa; q−&gt;fa = np−&gt;fa = nq; while(p &amp;&amp; p−&gt;next[x] == q)p−&gt;next[x] = nq, p = p−&gt;fa; &#125;&#125;return np;&#125; 计算几何基础计算几何几何公式三角形1234567891011121314151617\1. 半周长 P=(a+b+c)/2\2. 面积 S=aHa/2=absin(C)/2=sqrt(P(P-a)(P-b)(P-c))\3. 中线 Ma=sqrt(2(b^2+c^2)-a^2)/2=sqrt(b^2+c^2+2bccos(A))/2\4. 角平分线 Ta=sqrt(bc((b+c)^2-a^2))/(b+c)=2bccos(A/2)/(b+c)\5. 高线 Ha=bsin(C)=csin(B)=sqrt(b^2-((a^2+b^2-c^2)/(2a))^2)\6. 内切圆半径 r=S/P=asin(B/2)sin(C/2)/sin((B+C)/2) =4Rsin(A/2)sin(B/2)sin(C/2)=sqrt((P-a)(P-b)(P-c)/P) =Ptan(A/2)tan(B/2)tan(C/2)\7. 外接圆半径 R=abc/(4S)=a/(2sin(A))=b/(2sin(B))=c/(2sin(C)) 四边形1234567891011D1,D2为对角线,M对角线中点连线,A为对角线夹角\1. a^2+b^2+c^2+d^2=D1^2+D2^2+4M^2\2. S=D1D2sin(A)/2(以下对圆的内接四边形)\3. ac+bd=D1D2\4. S=sqrt((P-a)(P-b)(P-c)(P-d)),P为半周长 正n边形123456789R为外接圆半径,r为内切圆半径\1. 中心角 A=2PI/n\2. 内角 C=(n-2)PI/n\3. 边长 a=2sqrt(R^2-r^2)=2Rsin(A/2)=2rtan(A/2)\4. 面积 S=nar/2=nr^2tan(A/2)=nR^2sin(A)/2=na^2/(4tan(A/2)) 圆123456789\1. 弧长 l=rA\2. 弦长 a=2sqrt(2hr-h^2)=2rsin(A/2)\3. 弓形高 h=r-sqrt(r^2-a^2/4)=r(1-cos(A/2))=atan(A/4)/2\4. 扇形面积 S1=rl/2=r^2A/2\5. 弓形面积 S2=(rl-a(r-h))/2=r^2(A-sin(A))/2 棱柱12345\1. 体积 V=Ah,A为底面积,h为高\2. 侧面积 S=lp,l为棱长,p为直截面周长\3. 全面积 T=S+2A 棱锥1234567\1. 体积 V=Ah/3,A为底面积,h为高(以下对正棱锥)\2. 侧面积 S=lp/2,l为斜高,p为底面周长\3. 全面积 T=S+A 棱台1234567\1. 体积 V=(A1+A2+sqrt(A1A2))h/3,A1.A2为上下底面积,h为高(以下为正棱台)\2. 侧面积 S=(p1+p2)l/2,p1.p2为上下底面周长,l为斜高\3. 全面积 T=S+A1+A2 圆柱12345\1. 侧面积 S=2PIrh\2. 全面积 T=2PIr(h+r)\3. 体积 V=PIr^2h 圆锥1234567\1. 母线 l=sqrt(h^2+r^2)\2. 侧面积 S=PIrl\3. 全面积 T=PIr(l+r)\4. 体积 V=PIr^2h/3 圆台1234567\1. 母线 l=sqrt(h^2+(r1-r2)^2)\2. 侧面积 S=PI(r1+r2)l\3. 全面积 T=PIr1(l+r1)+PIr2(l+r2)\4. 体积 V=PI(r1^2+r2^2+r1r2)h/3 球123\1. 全面积 T=4PIr^2\2. 体积 V=4PIr^3/3 球台12345\1. 侧面积 S=2PIrh\2. 全面积 T=PI(2rh+r1^2+r2^2)\3. 体积 V=PIh(3(r1^2+r2^2)+h^2)/6 球扇形123\1. 全面积 T=PIr(2h+r0),h为球冠高,r0为球冠底面半径\2. 体积 V=2PIr^2h/3 直线与线段预备函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889**//结构定义与宏定义**\#include&lt;stdio.h&gt;\#include&lt;string.h&gt;\#include&lt;stdlib.h&gt;\#include &lt;math.h&gt;\#define eps 1e-8\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point&#123;​ double x,y;&#125;;struct line&#123;​ point a,b;&#125;; **//计算cross product (P1-P0)x(P2-P0)**double xmult(point p1,point p2,point p0)&#123;​ return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double xmult(double x1,double y1,double x2,double y2,double x0,double y0)&#123;​ return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);&#125; **//计算dot product (P1-P0).(P2-P0)**double dmult(point p1,point p2,point p0)&#123;​ return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);&#125;double dmult(double x1,double y1,double x2,double y2,double x0,double y0)&#123;​ return (x1-x0)*(x2-x0)+(y1-y0)*(y2-y0);&#125; **//两点距离**double distance(point p1,point p2)&#123;​ return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;double distance(double x1,double y1,double x2,double y2)&#123;​ return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125; 判三点是否共线1234567int dots_inline(point p1,point p2,point p3)&#123; return zero(xmult(p1,p2,p3));&#125; 判点是否在线段上1234567891011121314151617181920212223242526272829**//判点是否在线段上,包括端点（下面为两种接口模式）**int dot_online_in(point p,line l)&#123; return zero(xmult(p,l.a,l.b))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp;(l.a.y-p.y)*(l.b.y-p.y)&lt;eps;&#125;int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;&#125;**//判点是否在线段上,不包括端点**int dot_online_ex(point p,line l)&#123; return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)) &amp;&amp;(!zero(p.x-l.b.x)||!zero(p.y-l.b.y));&#125; 判断两点在线段的同一侧1234567891011121314151617**//判两点在线段同侧,点在线段上返回0**int same_side(point p1,point p2,line l)&#123; return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&gt;eps;&#125;int same_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;&#125; 判断两点是否在线段的异侧1234567891011121314151617**//判两点在线段异侧,点在线段上返回0**int opposite_side(point p1,point p2,line l)&#123; return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b)&lt;-eps;&#125;int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125; 求点关于直线的对称点12345678910111213141516171819202122232425262728293031323334353637**// 点关于直线的对称点 // by lyt****// 缺点：用了斜率****// 也可以利用&quot;点到直线上的最近点&quot;来做，避免使用斜率。**point symmetric_point(point p1, point l1, point l2)&#123; point ret; if (l1.x &gt; l2.x - eps &amp;&amp; l1.x &lt; l2.x + eps) &#123; ret.x = (2 * l1.x - p1.x); ret.y = p1.y; &#125; else &#123; double k = (l1.y - l2.y ) / (l1.x - l2.x); ret.x = (2*k*k*l1.x + 2*k*p1.y - 2*k*l1.y - k*k*p1.x + p1.x) / (1 + k*k); ret.y = p1.y - (ret.x - p1.x ) / k; &#125; return ret;&#125; 判断两线段是否相交常用版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//定义点struct Point&#123; double x; double y;&#125;;typedef struct Point point; //叉积double multi(point p0, point p1, point p2)&#123; return ( p1.x - p0.x )*( p2.y - p0.y )-( p2.x - p0.x )*( p1.y - p0.y );&#125; //相交返回true,否则为false, 接口为两线段的端点bool isIntersected(point s1,point e1, point s2,point e2)&#123; return (max(s1.x,e1.x) &gt;= min(s2.x,e2.x)) &amp;&amp; (max(s2.x,e2.x) &gt;= min(s1.x,e1.x)) &amp;&amp; (max(s1.y,e1.y) &gt;= min(s2.y,e2.y)) &amp;&amp; (max(s2.y,e2.y) &gt;= min(s1.y,e1.y)) &amp;&amp; (multi(s1,s2,e1)*multi(s1,e1,e2)&gt;0) &amp;&amp; (multi(s2,s1,e2)*multi(s2,e2,e1)&gt;0);&#125; 不常用版123456789101112131415161718192021222324252627282930313233343536373839404142434445**//判两线段相交,包括端点和部分重合**int intersect_in(line u,line v)&#123; if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b)) return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u); return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);&#125;int intersect_in(point u1,point u2,point v1,point v2)&#123; if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2)) return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);&#125; **//判两线段相交,不包括端点和部分重合**int intersect_ex(line u,line v)&#123; return opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);&#125;int intersect_ex(point u1,point u2,point v1,point v2)&#123; return opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);&#125; 求两条直线的交点123456789101112131415161718192021**//计算两直线交点,注意事先判断直线是否平行!****//线段交点请另外判线段相交(同时还是要判断是否平行!)**point intersection(point u1,point u2,point v1,point v2)&#123; point ret=u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x+=(u2.x-u1.x)*t; ret.y+=(u2.y-u1.y)*t; return ret;&#125; 点到直线的最近距离1234567891011point ptoline(point p,point l1,point l2)&#123; point t=p; t.x+=l1.y-l2.y,t.y+=l2.x-l1.x; return intersection(p,t,l1,l2);&#125; 点到线段的最近距离123456789101112131415point ptoseg(point p,point l1,point l2)&#123; point t=p; t.x+=l1.y-l2.y,t.y+=l2.x-l1.x; if (xmult(l1,t,p)*xmult(l2,t,p)&gt;eps) return distance(p,l1)&lt;distance(p,l2)?l1:l2; return intersection(p,t,l1,l2);&#125; 多边形预备浮点函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465\#include &lt;stdlib.h&gt;\#include&lt;stdio.h&gt;\#include&lt;string.h&gt;\#include &lt;math.h&gt;\#define MAXN 1000 **//offset为多变形坐标的最大绝对值**\#define offset 10000\#define eps 1e-8 **//浮点数判0**\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps) **//浮点数判断符**\#define _sign(x) ((x)&gt;eps?1:((x)&lt;-eps?2:0)) **//定义点**struct point&#123; double x,y;&#125;pt[MAXN ]; **//定义线段**struct line&#123; point a,b;&#125;; **//叉积**double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125; 判定是否是凸多边形123456789101112131415161718192021222324252627282930313233**//判定凸多边形,顶点按顺时针或逆时针给出,允许相邻边共线,是凸多边形返回1，否则返回0**int is_convex(int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0; return s[1]|s[2];&#125; **//判凸行，顶点按顺时针或逆时针给出,不允许相邻边共线,是凸多边形返回1，否则返回0**int is_convex_v2(int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],p[(i+2)%n],p[i]))]=0; return s[0]&amp;&amp;s[1]|s[2];&#125; 判定点是否在多边形内12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879**//判点在凸多边形内或多边形边上时返回1，严格在凸多边形外返回0**int inside_convex(point q,int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0; return s[1]|s[2];&#125; **//判点严格在凸多边形内返回1,在边上或者严格在外返回0**int inside_convex_v2(point q,int n,point* p)&#123; int i,s[3]=&#123;1,1,1&#125;; for (i=0;i&lt;n&amp;&amp;s[0]&amp;&amp;s[1]|s[2];i++) s[_sign(xmult(p[(i+1)%n],q,p[i]))]=0; return s[0]&amp;&amp;s[1]|s[2];&#125; **//判点在任意多边形内,顶点按顺时针或逆时针给出****//on_edge表示点在多边形边上时的返回值, offset为多边形坐标上限,严格在内返回1，严格在外返回0**int inside_polygon(point q,int n,point* p,int on_edge=2)&#123; point q2; int i=0,count; while (i&lt;n) for (count=i=0,q2.x=rand()+offset,q2.y=rand()+offset;i&lt;n;i++) &#123; if (zero(xmult(q,p[i],p[(i+1)%n]))&amp;&amp;(p[i].x-q.x)*(p[(i+1)%n].x-q.x)&lt;eps &amp;&amp;(p[i].y-q.y)*(p[(i+1)%n].y-q.y)&lt;eps) return on_edge; else if (zero(xmult(q,q2,p[i]))) break; else if (xmult(q,p[i],q2)*xmult(q,p[(i+1)%n],q2)&lt;-eps&amp;&amp; xmult(p[i],q,p[(i+1)%n])*xmult(p[i],q2,p[(i+1)%n])&lt;-eps) count++; &#125; return count&amp;1;&#125; 判定一条线段是否在一个任意多边形内123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475**//预备函数**inline int opposite_side(point p1,point p2,point l1,point l2)&#123; return xmult(l1,p1,l2)*xmult(l1,p2,l2)&lt;-eps;&#125;inline int dot_online_in(point p,point l1,point l2)&#123; return zero(xmult(p,l1,l2))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp;(l1.y-p.y)*(l2.y-p.y)&lt;eps;&#125; **//判线段在任意多边形内,顶点按顺时针或逆时针给出,与边界相交返回1**int inside_polygon(point l1,point l2,int n,point* p)&#123; point t[MAXN],tt; int i,j,k=0; if (!inside_polygon(l1,n,p)||!inside_polygon(l2,n,p)) return 0; for (i=0;i&lt;n;i++) &#123; if (opposite_side(l1,l2,p[i],p[(i+1)%n])&amp;&amp;opposite_side(p[i],p[(i+1)%n],l1,l2)) return 0; else if (dot_online_in(l1,p[i],p[(i+1)%n])) t[k++]=l1; else if (dot_online_in(l2,p[i],p[(i+1)%n])) t[k++]=l2; else if (dot_online_in(p[i],l1,l2)) t[k++]=p[i]; &#125; for (i=0;i&lt;k;i++) for (j=i+1;j&lt;k;j++) &#123; tt.x=(t[i].x+t[j].x)/2; tt.y=(t[i].y+t[j].y)/2; if (!inside_polygon(tt,n,p)) return 0; &#125; return 1;&#125; 三角形预备函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263\#include &lt;math.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;\#include&lt;stdio.h&gt;**//定义点**struct point&#123; double x,y;&#125;;typedef struct point point; **//定义直线**struct line&#123; point a,b;&#125;;typedef struct line line;**//两点距离**double distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;**//两直线求交点**point intersection(line u,line v)&#123; point ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; return ret;&#125; 求三角形的外心12345678910111213141516171819202122232425point circumcenter(point a,point b,point c)&#123; line u,v; u.a.x=(a.x+b.x)/2; u.a.y=(a.y+b.y)/2; u.b.x=u.a.x-a.y+b.y; u.b.y=u.a.y+a.x-b.x; v.a.x=(a.x+c.x)/2; v.a.y=(a.y+c.y)/2; v.b.x=v.a.x-a.y+c.y; v.b.y=v.a.y+a.x-c.x; return intersection(u,v);&#125; 求三角形内心12345678910111213141516171819202122232425262728293031point incenter(point a,point b,point c)&#123; line u,v; double m,n; u.a=a; m=atan2(b.y-a.y,b.x-a.x); n=atan2(c.y-a.y,c.x-a.x); u.b.x=u.a.x+cos((m+n)/2); u.b.y=u.a.y+sin((m+n)/2); v.a=b; m=atan2(a.y-b.y,a.x-b.x); n=atan2(c.y-b.y,c.x-b.x); v.b.x=v.a.x+cos((m+n)/2); v.b.y=v.a.y+sin((m+n)/2); return intersection(u,v);&#125; 求三角形垂心123456789101112131415161718192021point perpencenter(point a,point b,point c)&#123; line u,v; u.a=c; u.b.x=u.a.x-a.y+b.y; u.b.y=u.a.y+a.x-b.x; v.a=b; v.b.x=v.a.x-a.y+c.y; v.b.y=v.a.y+a.x-c.x; return intersection(u,v);&#125; 圆预备函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465\#include &lt;math.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#define eps 1e-8struct point&#123; double x,y;&#125;;typedef struct point point;double xmult(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;double distance(point p1,point p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));&#125;**//点到直线的距离**double disptoline(point p,point l1,point l2)&#123; return fabs(xmult(p,l1,l2))/distance(l1,l2);&#125;**//求两直线交点**point intersection(point u1,point u2,point v1,point v2)&#123; point ret=u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x+=(u2.x-u1.x)*t; ret.y+=(u2.y-u1.y)*t; return ret;&#125; 判定直线是否与圆相交123456789//判直线和圆相交,包括相切int intersect_line_circle(point c,double r,point l1,point l2)&#123; return disptoline(c,l1,l2)&lt;r+eps;&#125; 判定线段与圆相交12345678910111213141516171819int intersect_seg_circle(point c,double r, point l1,point l2)&#123; double t1=distance(c,l1)-r,t2=distance(c,l2)-r; point t=c; if (t1&lt;eps||t2&lt;eps) return t1&gt;-eps||t2&gt;-eps; t.x+=l1.y-l2.y; t.y+=l2.x-l1.x; return xmult(l1,c,t)*xmult(l2,c,t)&lt;eps&amp;&amp;disptoline(c,l1,l2)-r&lt;eps;&#125; 判圆和圆相交1234567int intersect_circle_circle(point c1,double r1,point c2,double r2)&#123; return distance(c1,c2)&lt;r1+r2+eps&amp;&amp;distance(c1,c2)&gt;fabs(r1-r2)-eps;&#125; 计算圆上到点p最近点1234567891011121314151617181920212223**//当p为圆心时，返回圆心本身**point dot_to_circle(point c,double r,point p)&#123; point u,v; if (distance(p,c)&lt;eps) return p; u.x=c.x+r*fabs(c.x-p.x)/distance(c,p); u.y=c.y+r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1); v.x=c.x-r*fabs(c.x-p.x)/distance(c,p); v.y=c.y-r*fabs(c.y-p.y)/distance(c,p)*((c.x-p.x)*(c.y-p.y)&lt;0?-1:1); return distance(u,p)&lt;distance(v,p)?u:v;&#125; 计算直线与圆的交点1234567891011121314151617181920212223242526272829**//计算直线与圆的交点,保证直线与圆有交点****//计算线段与圆的交点可用这个函数后判点是否在线段上**void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)&#123; point p=c; double t; p.x+=l1.y-l2.y; p.y+=l2.x-l1.x; p=intersection(p,c,l1,l2); t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2); p1.x=p.x+(l2.x-l1.x)*t; p1.y=p.y+(l2.y-l1.y)*t; p2.x=p.x-(l2.x-l1.x)*t; p2.y=p.y-(l2.y-l1.y)*t;&#125; 计算两个圆的交点1234567891011121314151617181920212223**//计算圆与圆的交点,保证圆与圆有交点,圆心不重合**void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)&#123; point u,v; double t; t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2; u.x=c1.x+(c2.x-c1.x)*t; u.y=c1.y+(c2.y-c1.y)*t; v.x=u.x+c1.y-c2.y; v.y=u.y-c1.x+c2.x; intersection_line_circle(c1,r1,u,v,p1,p2);&#125; 球面给出地球经度纬度，计算圆心角1234567891011121314151617181920212223242526272829\#include &lt;math.h&gt;const double pi=acos(-1); **//计算圆心角lat表示纬度,-90&lt;=w&lt;=90,lng表示经度****//返回两点所在大圆劣弧对应圆心角,0&lt;=angle&lt;=pi**double angle(double lng1,double lat1,double lng2,double lat2)&#123; double dlng=fabs(lng1-lng2)*pi/180; while (dlng&gt;=pi+pi) dlng-=pi+pi; if (dlng&gt;pi) dlng=pi+pi-dlng; lat1*=pi/180,lat2*=pi/180; return acos(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2));&#125; 已知经纬度，计算地球上两点直线距离123456789101112131415161718192021**//计算距离,r为球半径**double line_dist(double r,double lng1,double lat1,double lng2,double lat2)&#123; double dlng=fabs(lng1-lng2)*pi/180; while (dlng&gt;=pi+pi) dlng-=pi+pi; if (dlng&gt;pi) dlng=pi+pi-dlng; lat1*=pi/180,lat2*=pi/180; return r*sqrt(2-2*(cos(lat1)*cos(lat2)*cos(dlng)+sin(lat1)*sin(lat2)));&#125; 已知经纬度，计算地球上两点球面距离123456789**//计算球面距离,r为球半径**inline double sphere_dist(double r,double lng1,double lat1,double lng2,double lat2)&#123; return r*angle(lng1,lat1,lng2,lat2);&#125; 三维几何的若干模板预备函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495**//三维几何函数库**\#include &lt;math.h&gt;\#define eps 1e-8\#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)struct point3&#123;double x,y,z;&#125;;struct line3&#123;point3 a,b;&#125;;struct plane3&#123;point3 a,b,c;&#125;; **//计算cross product U x V**point3 xmult(point3 u,point3 v)&#123; point3 ret; ret.x=u.y*v.z-v.y*u.z; ret.y=u.z*v.x-u.x*v.z; ret.z=u.x*v.y-u.y*v.x; return ret;&#125; **//计算dot product U . V**double dmult(point3 u,point3 v)&#123; return u.x*v.x+u.y*v.y+u.z*v.z;&#125; **//矢量差 U - V**point3 subt(point3 u,point3 v)&#123; point3 ret; ret.x=u.x-v.x; ret.y=u.y-v.y; ret.z=u.z-v.z; return ret;&#125; **//取平面法向量**point3 pvec(plane3 s)&#123; return xmult(subt(s.a,s.b),subt(s.b,s.c));&#125;point3 pvec(point3 s1,point3 s2,point3 s3)&#123; return xmult(subt(s1,s2),subt(s2,s3));&#125; **//两点距离,单参数取向量大小**double distance(point3 p1,point3 p2)&#123; return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)+(p1.z-p2.z)*(p1.z-p2.z));&#125; **//向量大小**double vlen(point3 p)&#123; return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);&#125; 判定三点是否共线//判三点共线 12345int dots_inline(point3 p1,point3 p2,point3 p3)&#123; return vlen(xmult(subt(p1,p2),subt(p2,p3)))&lt;eps;&#125; 判定四点是否共面1234567**//判四点共面**int dots_onplane(point3 a,point3 b,point3 c,point3 d)&#123; return zero(dmult(pvec(a,b,c),subt(d,a)));&#125; 判定点是否在线段上12345678910111213141516171819202122232425262728293031323334353637**//判点是否在线段上,包括端点和共线**int dot_online_in(point3 p,line3 l)&#123; return zero(vlen(xmult(subt(p,l.a),subt(p,l.b))))&amp;&amp;(l.a.x-p.x)*(l.b.x-p.x)&lt;eps&amp;&amp; (l.a.y-p.y)*(l.b.y-p.y)&lt;eps&amp;&amp;(l.a.z-p.z)*(l.b.z-p.z)&lt;eps;&#125;int dot_online_in(point3 p,point3 l1,point3 l2)&#123; return zero(vlen(xmult(subt(p,l1),subt(p,l2))))&amp;&amp;(l1.x-p.x)*(l2.x-p.x)&lt;eps&amp;&amp; (l1.y-p.y)*(l2.y-p.y)&lt;eps&amp;&amp;(l1.z-p.z)*(l2.z-p.z)&lt;eps;&#125; **//判点是否在线段上,不包括端点**int dot_online_ex(point3 p,line3 l)&#123; return dot_online_in(p,l)&amp;&amp;(!zero(p.x-l.a.x)||!zero(p.y-l.a.y)||!zero(p.z-l.a.z))&amp;&amp; (!zero(p.x-l.b.x)||!zero(p.y-l.b.y)||!zero(p.z-l.b.z));&#125;int dot_online_ex(point3 p,point3 l1,point3 l2)&#123; return dot_online_in(p,l1,l2)&amp;&amp;(!zero(p.x-l1.x)||!zero(p.y-l1.y)||!zero(p.z-l1.z))&amp;&amp; (!zero(p.x-l2.x)||!zero(p.y-l2.y)||!zero(p.z-l2.z));&#125; 判断点是否在空间三角形上123456789101112131415161718192021222324252627282930313233343536373839**//判点是否在空间三角形上,包括边界,三点共线无意义**int dot_inplane_in(point3 p,plane3 s)&#123; return zero(vlen(xmult(subt(s.a,s.b),subt(s.a,s.c)))-vlen(xmult(subt(p,s.a),subt(p,s.b)))- vlen(xmult(subt(p,s.b),subt(p,s.c)))-vlen(xmult(subt(p,s.c),subt(p,s.a))));&#125;int dot_inplane_in(point3 p,point3 s1,point3 s2,point3 s3)&#123; return zero(vlen(xmult(subt(s1,s2),subt(s1,s3)))-vlen(xmult(subt(p,s1),subt(p,s2)))- vlen(xmult(subt(p,s2),subt(p,s3)))-vlen(xmult(subt(p,s3),subt(p,s1))));&#125; **//判点是否在空间三角形上,不包括边界,三点共线无意义**int dot_inplane_ex(point3 p,plane3 s)&#123; return dot_inplane_in(p,s)&amp;&amp;vlen(xmult(subt(p,s.a),subt(p,s.b)))&gt;eps&amp;&amp; vlen(xmult(subt(p,s.b),subt(p,s.c)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s.c),subt(p,s.a)))&gt;eps;&#125;int dot_inplane_ex(point3 p,point3 s1,point3 s2,point3 s3)&#123; return dot_inplane_in(p,s1,s2,s3)&amp;&amp;vlen(xmult(subt(p,s1),subt(p,s2)))&gt;eps&amp;&amp; vlen(xmult(subt(p,s2),subt(p,s3)))&gt;eps&amp;&amp;vlen(xmult(subt(p,s3),subt(p,s1)))&gt;eps;&#125; 判断两点是否在线段同侧12345678910111213**//判两点在线段同侧,点在线段上返回0,不共面无意义**int same_side(point3 p1,point3 p2,line3 l)&#123; return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&gt;eps;&#125;int same_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123; return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&gt;eps;&#125; 判断两点是否在线段异侧12345678910111213**//判两点在线段异侧,点在线段上返回0,不共面无意义**int opposite_side(point3 p1,point3 p2,line3 l)&#123; return dmult(xmult(subt(l.a,l.b),subt(p1,l.b)),xmult(subt(l.a,l.b),subt(p2,l.b)))&lt;-eps;&#125;int opposite_side(point3 p1,point3 p2,point3 l1,point3 l2)&#123; return dmult(xmult(subt(l1,l2),subt(p1,l2)),xmult(subt(l1,l2),subt(p2,l2)))&lt;-eps;&#125; 判断两点是否在平面同侧12345678910111213**//判两点在平面同侧,点在平面上返回0**int same_side(point3 p1,point3 p2,plane3 s)&#123; return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&gt;eps;&#125;int same_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123; return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&gt;eps;&#125; 判断两点是否在平面异侧12345678910111213**//判两点在平面异侧,点在平面上返回0**int opposite_side(point3 p1,point3 p2,plane3 s)&#123; return dmult(pvec(s),subt(p1,s.a))*dmult(pvec(s),subt(p2,s.a))&lt;-eps;&#125;int opposite_side(point3 p1,point3 p2,point3 s1,point3 s2,point3 s3)&#123; return dmult(pvec(s1,s2,s3),subt(p1,s1))*dmult(pvec(s1,s2,s3),subt(p2,s1))&lt;-eps;&#125; 判断两空间直线是否平行12345678910111213**//判两直线平行**int parallel(line3 u,line3 v)&#123; return vlen(xmult(subt(u.a,u.b),subt(v.a,v.b)))&lt;eps;&#125;int parallel(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return vlen(xmult(subt(u1,u2),subt(v1,v2)))&lt;eps;&#125; 判断两平面是否平行12345678910111213**//判两平面平行**int parallel(plane3 u,plane3 v)&#123; return vlen(xmult(pvec(u),pvec(v)))&lt;eps;&#125;int parallel(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; return vlen(xmult(pvec(u1,u2,u3),pvec(v1,v2,v3)))&lt;eps;&#125; 判断直线是否与平面平行12345678910111213**//判直线与平面平行**int parallel(line3 l,plane3 s)&#123; return zero(dmult(subt(l.a,l.b),pvec(s)));&#125;int parallel(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return zero(dmult(subt(l1,l2),pvec(s1,s2,s3)));&#125; 判断两直线是否垂直12345678910111213**//判两直线垂直**int perpendicular(line3 u,line3 v)&#123; return zero(dmult(subt(u.a,u.b),subt(v.a,v.b)));&#125;int perpendicular(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return zero(dmult(subt(u1,u2),subt(v1,v2)));&#125; 判断两平面是否垂直12345678910111213//判两平面垂直int perpendicular(plane3 u,plane3 v)&#123; return zero(dmult(pvec(u),pvec(v)));&#125;int perpendicular(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; return zero(dmult(pvec(u1,u2,u3),pvec(v1,v2,v3)));&#125; 判断两条空间线段是否相交123456789101112131415161718192021222324252627282930313233343536373839404142434445**//判两线段相交,包括端点和部分重合**int intersect_in(line3 u,line3 v)&#123; if (!dots_onplane(u.a,u.b,v.a,v.b)) return 0; if (!dots_inline(u.a,u.b,v.a)||!dots_inline(u.a,u.b,v.b)) return !same_side(u.a,u.b,v)&amp;&amp;!same_side(v.a,v.b,u); return dot_online_in(u.a,v)||dot_online_in(u.b,v)||dot_online_in(v.a,u)||dot_online_in(v.b,u);&#125;int intersect_in(point3 u1,point3 u2,point3 v1,point3 v2)&#123; if (!dots_onplane(u1,u2,v1,v2)) return 0; if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2)) return !same_side(u1,u2,v1,v2)&amp;&amp;!same_side(v1,v2,u1,u2); return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);&#125; **//判两线段相交,不包括端点和部分重合**int intersect_ex(line3 u,line3 v)&#123; return dots_onplane(u.a,u.b,v.a,v.b)&amp;&amp;opposite_side(u.a,u.b,v)&amp;&amp;opposite_side(v.a,v.b,u);&#125;int intersect_ex(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return dots_onplane(u1,u2,v1,v2)&amp;&amp;opposite_side(u1,u2,v1,v2)&amp;&amp;opposite_side(v1,v2,u1,u2);&#125; 判断线段是否与空间三角形相交12345678910111213141516171819202122232425262728293031323334353637**//判线段与空间三角形相交,包括交于边界和(部分)包含**int intersect_in(line3 l,plane3 s)&#123; return !same_side(l.a,l.b,s)&amp;&amp;!same_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp; !same_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;!same_side(s.c,s.a,l.a,l.b,s.b);&#125;int intersect_in(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return !same_side(l1,l2,s1,s2,s3)&amp;&amp;!same_side(s1,s2,l1,l2,s3)&amp;&amp; !same_side(s2,s3,l1,l2,s1)&amp;&amp;!same_side(s3,s1,l1,l2,s2);&#125; **//判线段与空间三角形相交,不包括交于边界和(部分)包含**int intersect_ex(line3 l,plane3 s)&#123; return opposite_side(l.a,l.b,s)&amp;&amp;opposite_side(s.a,s.b,l.a,l.b,s.c)&amp;&amp; opposite_side(s.b,s.c,l.a,l.b,s.a)&amp;&amp;opposite_side(s.c,s.a,l.a,l.b,s.b);&#125;int intersect_ex(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return opposite_side(l1,l2,s1,s2,s3)&amp;&amp;opposite_side(s1,s2,l1,l2,s3)&amp;&amp; opposite_side(s2,s3,l1,l2,s1)&amp;&amp;opposite_side(s3,s1,l1,l2,s2);&#125; 计算两条直线的交点123456789101112131415161718192021222324252627282930313233343536373839**//计算两直线交点,注意事先判断直线是否共面和平行!****//线段交点请另外判线段相交(同时还是要判断是否平行!)**point3 intersection(line3 u,line3 v)&#123; point3 ret=u.a; double t=((u.a.x-v.a.x)*(v.a.y-v.b.y)-(u.a.y-v.a.y)*(v.a.x-v.b.x)) /((u.a.x-u.b.x)*(v.a.y-v.b.y)-(u.a.y-u.b.y)*(v.a.x-v.b.x)); ret.x+=(u.b.x-u.a.x)*t; ret.y+=(u.b.y-u.a.y)*t; ret.z+=(u.b.z-u.a.z)*t; return ret;&#125;point3 intersection(point3 u1,point3 u2,point3 v1,point3 v2)&#123; point3 ret=u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x+=(u2.x-u1.x)*t; ret.y+=(u2.y-u1.y)*t; ret.z+=(u2.z-u1.z)*t; return ret;&#125; 计算直线与平面的交点123456789101112131415161718192021222324252627282930313233343536373839**//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线!****//线段和空间三角形交点请另外判断**point3 intersection(line3 l,plane3 s)&#123; point3 ret=pvec(s); double t=(ret.x*(s.a.x-l.a.x)+ret.y*(s.a.y-l.a.y)+ret.z*(s.a.z-l.a.z))/ (ret.x*(l.b.x-l.a.x)+ret.y*(l.b.y-l.a.y)+ret.z*(l.b.z-l.a.z)); ret.x=l.a.x+(l.b.x-l.a.x)*t; ret.y=l.a.y+(l.b.y-l.a.y)*t; ret.z=l.a.z+(l.b.z-l.a.z)*t; return ret;&#125;point3 intersection(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; point3 ret=pvec(s1,s2,s3); double t=(ret.x*(s1.x-l1.x)+ret.y*(s1.y-l1.y)+ret.z*(s1.z-l1.z))/ (ret.x*(l2.x-l1.x)+ret.y*(l2.y-l1.y)+ret.z*(l2.z-l1.z)); ret.x=l1.x+(l2.x-l1.x)*t; ret.y=l1.y+(l2.y-l1.y)*t; ret.z=l1.z+(l2.z-l1.z)*t; return ret;&#125; 计算两平面的交线12345678910111213141516171819202122232425**//计算两平面交线,注意事先判断是否平行,并保证三点不共线!**line3 intersection(plane3 u,plane3 v)&#123; line3 ret; ret.a=parallel(v.a,v.b,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.a,v.b,u.a,u.b,u.c); ret.b=parallel(v.c,v.a,u.a,u.b,u.c)?intersection(v.b,v.c,u.a,u.b,u.c):intersection(v.c,v.a,u.a,u.b,u.c); return ret;&#125;line3 intersection(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; line3 ret; ret.a=parallel(v1,v2,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v1,v2,u1,u2,u3); ret.b=parallel(v3,v1,u1,u2,u3)?intersection(v2,v3,u1,u2,u3):intersection(v3,v1,u1,u2,u3); return ret;&#125; 点到直线的距离12345678910111213**//点到直线距离**double ptoline(point3 p,line3 l)&#123; return vlen(xmult(subt(p,l.a),subt(l.b,l.a)))/distance(l.a,l.b);&#125;double ptoline(point3 p,point3 l1,point3 l2)&#123; return vlen(xmult(subt(p,l1),subt(l2,l1)))/distance(l1,l2);&#125; 计算点到平面的距离12345678910111213**//点到平面距离**double ptoplane(point3 p,plane3 s)&#123; return fabs(dmult(pvec(s),subt(p,s.a)))/vlen(pvec(s));&#125;double ptoplane(point3 p,point3 s1,point3 s2,point3 s3)&#123; return fabs(dmult(pvec(s1,s2,s3),subt(p,s1)))/vlen(pvec(s1,s2,s3));&#125; 计算直线到直线的距离1234567891011121314151617**//直线到直线距离**double linetoline(line3 u,line3 v)&#123; point3 n=xmult(subt(u.a,u.b),subt(v.a,v.b)); return fabs(dmult(subt(u.a,v.a),n))/vlen(n);&#125;double linetoline(point3 u1,point3 u2,point3 v1,point3 v2)&#123; point3 n=xmult(subt(u1,u2),subt(v1,v2)); return fabs(dmult(subt(u1,v1),n))/vlen(n);&#125; 空间两直线夹角的cos值12345678910111213**//两直线夹角cos值**double angle_cos(line3 u,line3 v)&#123; return dmult(subt(u.a,u.b),subt(v.a,v.b))/vlen(subt(u.a,u.b))/vlen(subt(v.a,v.b));&#125;double angle_cos(point3 u1,point3 u2,point3 v1,point3 v2)&#123; return dmult(subt(u1,u2),subt(v1,v2))/vlen(subt(u1,u2))/vlen(subt(v1,v2));&#125; 两平面夹角的cos值12345678910111213**//两平面夹角cos值**double angle_cos(plane3 u,plane3 v)&#123; return dmult(pvec(u),pvec(v))/vlen(pvec(u))/vlen(pvec(v));&#125;double angle_cos(point3 u1,point3 u2,point3 u3,point3 v1,point3 v2,point3 v3)&#123; return dmult(pvec(u1,u2,u3),pvec(v1,v2,v3))/vlen(pvec(u1,u2,u3))/vlen(pvec(v1,v2,v3));&#125; 直线与平面夹角sin值12345678910111213//直线平面夹角sin值double angle_sin(line3 l,plane3 s)&#123; return dmult(subt(l.a,l.b),pvec(s))/vlen(subt(l.a,l.b))/vlen(pvec(s));&#125;double angle_sin(point3 l1,point3 l2,point3 s1,point3 s2,point3 s3)&#123; return dmult(subt(l1,l2),pvec(s1,s2,s3))/vlen(subt(l1,l2))/vlen(pvec(s1,s2,s3));&#125; 高级计算几何最远曼哈顿距离123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119\#include &lt;stdio.h&gt;\#define INF 9999999999999.0struct Point&#123; double x[5];&#125;pt[100005];double dis[32][100005], coe[5], minx[32], maxx[32];**//去掉绝对值后有2^D种可能**void GetD(int N, int D)&#123; int s, i, j, tot=(1&lt;&lt;D); for (s=0;s&lt;tot;s++) &#123; for (i=0;i&lt;D;i++) if (s&amp;(1&lt;&lt;i)) coe[i]=-1.0; else coe[i]=1.0; for (i=0;i&lt;N;i++) &#123; dis[s][i]=0.0; for (j=0;j&lt;D;j++) dis[s][i]=dis[s][i]+coe[j]*pt[i].x[j]; &#125; &#125;&#125;**//取每种可能中的最大差距**void Solve(int N, int D)&#123; int s, i, tot=(1&lt;&lt;D); double tmp, ans; for (s=0;s&lt;tot;s++) &#123; minx[s]=INF; maxx[s]=-INF; for (i=0; i&lt;N; i++) &#123; if (minx[s]&gt;dis[s][i]) minx[s]=dis[s][i]; if (maxx[s]&lt;dis[s][i]) maxx[s]=dis[s][i]; &#125; &#125; ans=0.0; for (s=0; s&lt;tot; s++) &#123; tmp=maxx[s]-minx[s]; if (tmp&gt;ans) ans=tmp; &#125; printf(&quot;%.2lf\n&quot;, ans);&#125;int main (void)&#123; int n, i; while (scanf(&quot;%d&quot;,&amp;n)==1) &#123; for (i=0;i&lt;n;i++) scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;pt[i].x[0],&amp;pt[i].x[1],&amp;pt[i].x[2],&amp;pt[i].x[3],&amp;pt[i].x[4]); GetD(n, 5); Solve(n, 5); &#125; return 0;&#125; 最近点对123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157\#include &lt;stdio.h&gt;\#include &lt;math.h&gt;\#include &lt;stdlib.h&gt;\#define Max(x,y) (x)&gt;(y)?(x):(y)struct Q&#123; double x, y;&#125;q[100001], sl[10], sr[10]; int cntl, cntr, lm, rm;double ans; int cmp(const void*p1, const void*p2)&#123; struct Q*a1=(struct Q*)p1; struct Q*a2=(struct Q*)p2; if (a1-&gt;x&lt;a2-&gt;x)return -1; else if (a1-&gt;x==a2-&gt;x)return 0; else return 1;&#125; double CalDis(double x1, double y1, double x2, double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125; void MinDis(int l, int r)&#123; if (l==r) return; double dis; if (l+1==r) &#123; dis=CalDis(q[l].x,q[l].y,q[r].x,q[r].y); if (ans&gt;dis) ans=dis; return; &#125; int mid=(l+r)&gt;&gt;1, i, j; MinDis(l,mid); MinDis(mid+1,r); lm=mid+1-5; if (lm&lt;l) lm=l; rm=mid+5; if (rm&gt;r) rm=r; cntl=cntr=0; for (i=mid;i&gt;=lm;i--) &#123; if (q[mid+1].x-q[i].x&gt;=ans)break; sl[++cntl]=q[i]; &#125; for (i=mid+1;i&lt;=rm;i++) &#123; if (q[i].x-q[mid].x&gt;=ans)break; sr[++cntr]=q[i]; &#125; for (i=1;i&lt;=cntl;i++) for (j=1;j&lt;=cntr;j++) &#123; dis=CalDis(sl[i].x,sl[i].y,sr[j].x,sr[j].y); if (dis&lt;ans) ans=dis; &#125;&#125; int main (void)&#123; int n, i; while (scanf(&quot;%d&quot;,&amp;n)==1&amp;&amp;n) &#123; for (i=1;i&lt;=n;i++) scanf(&quot;%lf %lf&quot;, &amp;q[i].x,&amp;q[i].y); qsort(q+1,n,sizeof(struct Q),cmp); ans=CalDis(q[1].x,q[1].y,q[2].x,q[2].y); MinDis(1,n); printf(&quot;%.2lf\n&quot;,ans/2.0); &#125; return 0;&#125; 最小包围圆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211\#include&lt;stdio.h&gt;\#include&lt;string.h&gt;\#include&lt;math.h&gt;struct Point&#123; double x; double y;&#125;pt[1005];struct Traingle&#123; struct Point p[3];&#125;;struct Circle&#123; struct Point center; double r;&#125;ans;**//计算两点距离**double Dis(struct Point p, struct Point q)&#123; double dx=p.x-q.x; double dy=p.y-q.y; return sqrt(dx*dx+dy*dy);&#125;**//计算三角形面积**double Area(struct Traingle ct)&#123; return fabs((ct.p[1].x-ct.p[0].x)*(ct.p[2].y-ct.p[0].y)-(ct.p[2].x-ct.p[0].x)*(ct.p[1].y-ct.p[0].y))/2.0;&#125;**//求三角形的外接圆，返回圆心和半径(存在结构体&quot;圆&quot;中)**struct Circle CircumCircle(struct Traingle t)&#123; struct Circle tmp; double a, b, c, c1, c2; double xA, yA, xB, yB, xC, yC; a = Dis(t.p[0], t.p[1]); b = Dis(t.p[1], t.p[2]); c = Dis(t.p[2], t.p[0]); //根据S = a * b * c / R / 4;求半径R tmp.r = (a*b*c)/(Area(t)*4.0); xA = t.p[0].x; yA = t.p[0].y; xB = t.p[1].x; yB = t.p[1].y; xC = t.p[2].x; yC = t.p[2].y; c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / 2; c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / 2; tmp.center.x = (c1*(yA - yC)-c2*(yA - yB)) / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB)); tmp.center.y = (c1*(xA - xC)-c2*(xA - xB)) / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB)); return tmp;&#125;**//确定最小包围圆**struct Circle MinCircle(int num, struct Traingle ct)&#123; struct Circle ret; if (num==0) ret.r = 0.0; else if (num==1) &#123; ret.center = ct.p[0]; ret.r = 0.0; &#125; else if (num==2) &#123; ret.center.x = (ct.p[0].x+ct.p[1].x)/2.0; ret.center.y = (ct.p[0].y+ct.p[1].y)/2.0; ret.r = Dis(ct.p[0], ct.p[1])/2.0; &#125; else if(num==3) ret = CircumCircle(ct); return ret;&#125;**//递归实现增量算法**void Dfs(int x, int num, struct Traingle ct)&#123; int i, j; struct Point tmp; ans = MinCircle(num, ct); if (num==3) return; for (i=1; i&lt;=x; i++) if (Dis(pt[i], ans.center)&gt;ans.r) &#123; ct.p[num]=pt[i]; Dfs(i-1, num+1, ct); tmp=pt[i]; for (j=i;j&gt;=2;j--) pt[j]=pt[j-1]; pt[1]=tmp; &#125;&#125;void Solve(int n)&#123; struct Traingle ct; Dfs(n, 0, ct);&#125;int main (void)&#123; int n, i; while (scanf(&quot;%d&quot;, &amp;n)!=EOF &amp;&amp; n) &#123; for (i=1;i&lt;=n;i++) scanf(&quot;%lf %lf&quot;, &amp;pt[i].x, &amp;pt[i].y); Solve(n); printf(&quot;%.2lf %.2lf %.2lf\n&quot;, ans.center.x, ans.center.y, ans.r); &#125; return 0;&#125; 求两个圆的交点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145\#include&lt;stdio.h&gt;\#include&lt;string.h&gt;\#include&lt;math.h&gt;\#include&lt;stdlib.h&gt;const double eps = 1e-8;const double PI = acos(-1.0); struct Point&#123; double x; double y;&#125;;typedef struct Point point; struct Line&#123; double s, t;&#125;;typedef struct Line Line; struct Circle&#123; Point center; double r; Line line[505]; int cnt; bool covered; &#125;circle[105]; double distance(point p1, point p2)&#123; double dx = p1.x-p2.x; double dy = p1.y-p2.y; return sqrt(dx*dx + dy*dy);&#125; point intersection(point u1,point u2, point v1,point v2)&#123; point ret = u1; double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x)) / ((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x)); ret.x += (u2.x-u1.x)*t; ret.y += (u2.y-u1.y)*t; return ret;&#125; void intersection_line_circle(point c,double r,point l1,point l2,point&amp; p1,point&amp; p2)&#123; point p=c; double t; p.x+=l1.y-l2.y; p.y+=l2.x-l1.x; p=intersection(p,c,l1,l2); t=sqrt(r*r-distance(p,c)*distance(p,c))/distance(l1,l2); p1.x=p.x+(l2.x-l1.x)*t; p1.y=p.y+(l2.y-l1.y)*t; p2.x=p.x-(l2.x-l1.x)*t; p2.y=p.y-(l2.y-l1.y)*t;&#125; **//计算圆与圆的交点,保证圆与圆有交点,圆心不重合**void intersection_circle_circle(point c1,double r1,point c2,double r2,point&amp; p1,point&amp; p2)&#123; point u,v; double t; t=(1+(r1*r1-r2*r2)/distance(c1,c2)/distance(c1,c2))/2; u.x=c1.x+(c2.x-c1.x)*t; u.y=c1.y+(c2.y-c1.y)*t; v.x=u.x+c1.y-c2.y; v.y=u.y-c1.x+c2.x; intersection_line_circle(c1,r1,u,v,p1,p2);&#125; 求三角形外接圆圆心12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697struct Point&#123; double x; double y;&#125;pt[1005];struct Traingle&#123; struct Point p[3];&#125;;struct Circle&#123; struct Point center; double r;**&#125;**ans;**//计算两点距离**double Dis(struct Point p, struct Point q)&#123; double dx=p.x-q.x; double dy=p.y-q.y; return sqrt(dx*dx+dy*dy);&#125;**//计算三角形面积**double Area(struct Traingle ct)&#123; return fabs((ct.p[1].x-ct.p[0].x)*(ct.p[2].y-ct.p[0].y)-(ct.p[2].x-ct.p[0].x)*(ct.p[1].y-ct.p[0].y))/2.0;&#125;**//求三角形的外接圆，返回圆心和半径(存在结构体&quot;圆&quot;中)**struct Circle CircumCircle(struct Traingle t)&#123; struct Circle tmp; double a, b, c, c1, c2; double xA, yA, xB, yB, xC, yC; a = Dis(t.p[0], t.p[1]); b = Dis(t.p[1], t.p[2]); c = Dis(t.p[2], t.p[0]); //根据S = a * b * c / R / 4;求半径R tmp.r = (a*b*c)/(Area(t)*4.0); xA = t.p[0].x; yA = t.p[0].y; xB = t.p[1].x; yB = t.p[1].y; xC = t.p[2].x; yC = t.p[2].y; c1 = (xA*xA+yA*yA - xB*xB-yB*yB) / 2; c2 = (xA*xA+yA*yA - xC*xC-yC*yC) / 2; tmp.center.x = (c1*(yA - yC)-c2*(yA - yB)) / ((xA - xB)*(yA - yC)-(xA - xC)*(yA - yB)); tmp.center.y = (c1*(xA - xC)-c2*(xA - xB)) / ((yA - yB)*(xA - xC)-(yA - yC)*(xA - xB)); return tmp;&#125; 求凸包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;math.h&gt;\#define INF 999999999.9\#define PI acos(-1.0)struct Point&#123; double x, y, dis;&#125;pt[1005], stack[1005], p0;int top, tot;**//计算几何距离**double Dis(double x1, double y1, double x2, double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;**//极角比较， 返回-1: p0p1在p0p2的右侧，返回0:p0,p1,p2共线**int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)&#123; double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y); if (delta&lt;0.0) return 1; else if (delta==0.0) return 0; else return -1;&#125;**// 判断向量p2p3是否对p1p2构成左旋**bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)&#123; int type=Cmp_PolarAngel(p3, p1, p2); if (type&lt;0) return true; return false;&#125;**//先按极角排，再按距离由小到大排**int Cmp(const void*p1, const void*p2)&#123; struct Point*a1=(struct Point*)p1; struct Point*a2=(struct Point*)p2; int type=Cmp_PolarAngel(*a1, *a2, p0); if (type&lt;0) return -1; else if (type==0) &#123; if (a1-&gt;dis&lt;a2-&gt;dis) return -1; else if (a1-&gt;dis==a2-&gt;dis) return 0; else return 1; &#125; else return 1;&#125;**//求凸包**void Solve(int n)&#123; int i, k; p0.x=p0.y=INF; for (i=0;i&lt;n;i++) &#123; scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y); if (pt[i].y &lt; p0.y) &#123; p0.y=pt[i].y; p0.x=pt[i].x; k=i; &#125; else if (pt[i].y==p0.y) &#123; if (pt[i].x&lt;p0.x) &#123; p0.x=pt[i].x; k=i; &#125; &#125; &#125; pt[k]=pt[0]; pt[0]=p0; for (i=1;i&lt;n;i++) pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y); qsort(pt+1, n-1, sizeof(struct Point), Cmp); **//去掉极角相同的点** tot=1; for (i=2;i&lt;n;i++) if (Cmp_PolarAngel(pt[i], pt[i-1], p0)) pt[tot++]=pt[i-1]; pt[tot++]=pt[n-1]; **//求凸包** top=1; stack[0]=pt[0]; stack[1]=pt[1]; for (i=2;i&lt;tot;i++) &#123; while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false) top--; stack[++top]=pt[i]; &#125;&#125;int main (void)&#123; int n; while (scanf(&quot;%d&quot;,&amp;n)==2) &#123; Solve(n); &#125; return 0;&#125; 凸包卡壳旋转求出所有对踵点、最远点对123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;math.h&gt;\#define INF 999999999.9\#define PI acos(-1.0)struct Point&#123; double x, y, dis;&#125;pt[6005], stack[6005], p0;int top, tot;**//计算几何距离**double Dis(double x1, double y1, double x2, double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;**//极角比较， 返回-1: p0p1在p0p2的右侧，返回0:p0,p1,p2共线**int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)&#123; double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y); if (delta&lt;0.0) return 1; else if (delta==0.0) return 0; else return -1;&#125;**// 判断向量p2p3是否对p1p2构成左旋**bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)&#123; int type=Cmp_PolarAngel(p3, p1, p2); if (type&lt;0) return true; return false;&#125;**//先按极角排，再按距离由小到大排**int Cmp(const void*p1, const void*p2)&#123; struct Point*a1=(struct Point*)p1; struct Point*a2=(struct Point*)p2; int type=Cmp_PolarAngel(*a1, *a2, p0); if (type&lt;0) return -1; else if (type==0) &#123; if (a1-&gt;dis&lt;a2-&gt;dis) return -1; else if (a1-&gt;dis==a2-&gt;dis) return 0; else return 1; &#125; else return 1;&#125;**//求凸包**void Hull(int n)&#123; int i, k; p0.x=p0.y=INF; for (i=0;i&lt;n;i++) &#123; scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y); if (pt[i].y &lt; p0.y) &#123; p0.y=pt[i].y; p0.x=pt[i].x; k=i; &#125; else if (pt[i].y==p0.y) &#123; if (pt[i].x&lt;p0.x) &#123; p0.x=pt[i].x; k=i; &#125; &#125; &#125; pt[k]=pt[0]; pt[0]=p0; for (i=1;i&lt;n;i++) pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y); qsort(pt+1, n-1, sizeof(struct Point), Cmp); **//去掉极角相同的点** tot=1; for (i=2;i&lt;n;i++) if (Cmp_PolarAngel(pt[i], pt[i-1], p0)) pt[tot++]=pt[i-1]; pt[tot++]=pt[n-1]; **//求凸包** top=1; stack[0]=pt[0]; stack[1]=pt[1]; for (i=2;i&lt;tot;i++) &#123; while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false) top--; stack[++top]=pt[i]; &#125;&#125;**//计算叉积**double CrossProduct(struct Point p1, struct Point p2, struct Point p3)&#123; return (p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y);**&#125;****//卡壳旋转，求出凸多边形所有对踵点**void Rotate(struct Point*ch, int n)&#123; int i, p=1; double t1, t2, ans=0.0, dif; ch[n]=ch[0]; for (i=0;i&lt;n;i++) &#123; **//如果下一个点与当前边构成的三角形的面积更大，则说明此时不构成对踵点** while (fabs(CrossProduct(ch[i],ch[i+1],ch[p+1])) &gt; fabs(CrossProduct(ch[i],ch[i+1],ch[p]))) p=(p+1)%n; dif=fabs(CrossProduct(ch[i],ch[i+1],ch[p+1])) - fabs(CrossProduct(ch[i],ch[i+1],ch[p])); **//如果当前点和下一个点分别构成的三角形面积相等，则说明两条边即为平行线，对角线两端都可能是对踵点** if (dif==0.0) &#123; t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y); t2=Dis(ch[p+1].x, ch[p+1].y, ch[i+1].x, ch[i+1].y); if (t1&gt;ans)ans=t1; if (t2&gt;ans)ans=t2; &#125; **//说明p，i是对踵点** else if (dif&lt;0.0) &#123; t1=Dis(ch[p].x, ch[p].y, ch[i].x, ch[i].y); if (t1&gt;ans)ans=t1; &#125; &#125; printf(&quot;%.2lf\n&quot;,ans);&#125;int main (void)&#123; int n; while (scanf(&quot;%d&quot;,&amp;n)==1) &#123; Hull(n); Rotate(stack, top+1); &#125; return 0;&#125; 凸包+旋转卡壳求平面面积最大三角123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;math.h&gt;\#define INF 99999999999.9\#define PI acos(-1.0)struct Point&#123; double x, y, dis;&#125;pt[50005], stack[50005], p0;int top, tot;double Dis(double x1, double y1, double x2, double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;int Cmp_PolarAngel(struct Point p1, struct Point p2, struct Point pb)&#123; double delta=(p1.x-pb.x)*(p2.y-pb.y)-(p2.x-pb.x)*(p1.y-pb.y); if (delta&lt;0.0) return 1; else if (delta==0.0) return 0; else return -1;&#125;bool Is_LeftTurn(struct Point p3, struct Point p2, struct Point p1)&#123; int type=Cmp_PolarAngel(p3, p1, p2); if (type&lt;0) return true; return false;&#125;int Cmp(const void*p1, const void*p2)&#123; struct Point*a1=(struct Point*)p1; struct Point*a2=(struct Point*)p2; int type=Cmp_PolarAngel(*a1, *a2, p0); if (type&lt;0) return -1; else if (type==0) &#123; if (a1-&gt;dis&lt;a2-&gt;dis) return -1; else if (a1-&gt;dis==a2-&gt;dis) return 0; else return 1; &#125; else return 1;&#125;void Hull(int n)&#123; int i, k; p0.x=p0.y=INF; for (i=0;i&lt;n;i++) &#123; scanf(&quot;%lf %lf&quot;,&amp;pt[i].x, &amp;pt[i].y); if (pt[i].y &lt; p0.y) &#123; p0.y=pt[i].y; p0.x=pt[i].x; k=i; &#125; else if (pt[i].y==p0.y) &#123; if (pt[i].x&lt;p0.x) &#123; p0.x=pt[i].x; k=i; &#125; &#125; &#125; pt[k]=pt[0]; pt[0]=p0; for (i=1;i&lt;n;i++) pt[i].dis=Dis(pt[i].x,pt[i].y, p0.x,p0.y); qsort(pt+1, n-1, sizeof(struct Point), Cmp); tot=1; for (i=2;i&lt;n;i++) if (Cmp_PolarAngel(pt[i], pt[i-1], p0)) pt[tot++]=pt[i-1]; pt[tot++]=pt[n-1]; top=1; stack[0]=pt[0]; stack[1]=pt[1]; for (i=2;i&lt;tot;i++) &#123; while (top&gt;=1 &amp;&amp; Is_LeftTurn(pt[i], stack[top], stack[top-1])==false) top--; stack[++top]=pt[i]; &#125;&#125;double TArea(struct Point p1, struct Point p2, struct Point p3)&#123; return fabs((p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y));&#125;void Rotate(struct Point*ch, int n)&#123; if (n&lt;3) &#123; printf(&quot;0.00\n&quot;); return; &#125; int i, j, k; double ans=0.0, tmp; ch[n]=ch[0]; for (i=0;i&lt;n;i++) &#123; j=(i+1)%n; k=(j+1)%n; while ((j!=k) &amp;&amp; (k!=i)) &#123; while (TArea(ch[i],ch[j],ch[k+1])&gt;TArea(ch[i],ch[j],ch[k])) k=(k+1)%n; tmp=TArea(ch[i],ch[j], ch[k]); if (tmp&gt;ans) ans=tmp; j=(j+1)%n; &#125; &#125; printf(&quot;%.2lf\n&quot;,ans/2.0);&#125;int main (void)&#123; int n; while (scanf(&quot;%d&quot;,&amp;n)==1) &#123; if (n==-1)break; Hull(n); Rotate(stack, top+1); &#125; return 0;&#125; Pick定理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687**// Pick定理求整点多边形内部整点数目****// (1) 给定顶点座标均是整点（或正方形格点）的简单多边形，皮克定理说明了其面积A和内部格点数目i、边上格点数目b的关系：A = i + b/2 - 1；****// (2) 在两点（x1，y1），（x2，y2）连线之间的整点个数（包含一个端点）为：gcd（|x1－x2|，|y1－y2|）；****// (3) 求三角形面积用叉乘** \#include&lt;stdio.h&gt;\#include&lt;stdlib.h&gt;\#include&lt;math.h&gt;\#include&lt;string.h&gt; long long x[3], y[3], area, b;long long My_Abs(long long t)&#123; if (t&lt;0) return -t; return t;&#125;long long Gcd(long long x, long long y)&#123; if (y==0) return x; long long mod=x%y; while (mod) &#123; x=y; y=mod; mod=x%y; &#125; return y;&#125;int main (void)&#123; int i; while (1) &#123; for (i = 0;i &lt; 3;i ++) scanf(&quot;%lld %lld&quot;, &amp;x[i], &amp;y[i]); if(x[0]==0&amp;&amp;y[0]==0&amp;&amp;x[1]==0&amp;&amp;y[1]==0&amp;&amp;x[2]==0&amp;&amp;y[2]==0) break; area = (x[1]-x[0])*(y[2]-y[0])-(x[2]-x[0])*(y[1]-y[0]); area = My_Abs(area); b=0; b=Gcd(My_Abs(x[1]-x[0]), My_Abs(y[1]-y[0])) + Gcd(My_Abs(x[2]-x[0]), My_Abs(y[2]-y[0])) + Gcd(My_Abs(x[1]-x[2]), My_Abs(y[1]-y[2])); printf(&quot;%lld\n&quot;, (area-b+2)/2); &#125; return 0;&#125; 求多边形面积和重心12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667\#include &lt;stdio.h&gt;\#include &lt;math.h&gt;int x[1000003], y[1000003];double A, tx, ty, tmp;int main (void)&#123; int cases, n, i; scanf (&quot;%d&quot;, &amp;cases); while (cases --) &#123; scanf (&quot;%d&quot;, &amp;n); A = 0.0; x[0] = y[0] = 0; for (i = 1; i &lt;= n; i ++) &#123; scanf (&quot;%d %d&quot;, &amp;x[i], &amp;y[i]); A += (x[i-1]*y[i] - x[i]*y[i-1]); &#125; A += x[n]*y[1] - x[1]*y[n]; A = A / 2.0; tx = ty = 0.0; for (i = 1; i &lt; n; i ++) &#123; tmp = x[i]*y[i+1] - x[i+1]*y[i]; tx += (x[i]+x[i+1]) * tmp; ty += (y[i]+y[i+1]) * tmp; &#125; tmp = x[n]*y[1] - x[1]*y[n]; tx += (x[n]+x[1])*tmp; ty += (y[n]+y[1])*tmp; printf (&quot;%.2lf %.2lf\n&quot;, tx/(6.0*A), ty/(6.0*A)); &#125; return 0;&#125; 判断一个简单多边形是否有核123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;const int INF = (1&lt;&lt;30);struct Point&#123; int x, y;&#125;pt[150];typedef struct Point Point;bool turn_right[150];int det(Point s1, Point t1, Point s2, Point t2)&#123; int d1x = t1.x-s1.x; int d1y = t1.y-s1.y; int d2x = t2.x-s2.x; int d2y = t2.y-s2.y; return d1x*d2y - d2x*d1y;&#125;void Swap(int &amp;a, int &amp;b)&#123; if (a&gt;b) &#123; int t=a; a=b; b=t; &#125;&#125;int main (void)&#123; int n, i, cross, maxx, minx, maxy, miny, maxn, minn, countn=0; while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) &#123; maxx=maxy=-INF; minx=miny=INF; **//点按顺时针给出** for (i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d&quot;, &amp;pt[i].x, &amp;pt[i].y); if (maxx&lt;pt[i].x) maxx=pt[i].x; if (maxy&lt;pt[i].y) maxy=pt[i].y; if (minx&gt;pt[i].x) minx=pt[i].x; if (miny&gt;pt[i].y) miny=pt[i].y; &#125; pt[n+1]=pt[1]; pt[n+2]=pt[2]; pt[n+3]=pt[3]; pt[n+4]=pt[4]; **//求每条线段的转向** for (i=1; i&lt;=n+1; i ++) &#123; cross = det(pt[i],pt[i+1], pt[i+1], pt[i+2]); if (cross&lt;0) turn_right[i+1]=true; else turn_right[i+1]=false; &#125; **//两条边连续右转的为凸处，只有此时才可影响“核”肯恩存在的范围** for (i=2; i&lt;= n+1; i++) if (turn_right[i] &amp;&amp; turn_right[i+1]) &#123; if (pt[i].x==pt[i+1].x) &#123; minn=pt[i].y; maxn=pt[i+1].y; Swap(minn, maxn); if (minn&gt;miny) miny=minn; if (maxn&lt;maxy) maxy=maxn; &#125; else &#123; minn=pt[i].x; maxn=pt[i+1].x; Swap(minn, maxn); if (minn&gt;minx) minx=minn; if (maxn&lt;maxx) maxx=maxn; &#125; &#125; if (minx&lt;=maxx &amp;&amp; miny&lt;=maxy) printf(&quot;Floor #%d\nSurveillance is possible.\n\n&quot;, ++countn); else printf(&quot;Floor #%d\nSurveillance is impossible.\n\n&quot;, ++countn); &#125; return 0;&#125; 模拟退火123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185\#include &lt;stdio.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;math.h&gt;\#define Lim 0.999999\#define EPS 1e-2\#define PI acos(-1.0)double Temp, maxx, minx, maxy, miny, lx, ly, dif;int nt, ns, nc;struct Target&#123; double x, y;&#125;T[105];struct Solution&#123; double x, y; double f;&#125;S[25], P, A;double Dis(double x1, double y1, double x2, double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;void Seed(void)&#123; int i, j; for (i=0;i&lt;ns;i++) &#123; S[i].x=minx+((double)(rand()%1000+1)/1000.0)*lx; S[i].y=miny+((double)(rand()%1000+1)/1000.0)*ly; S[i].f=0.0; for (j=0;j&lt;nt;j++) S[i].f=S[i].f+Dis(S[i].x,S[i].y, T[j].x, T[j].y); &#125;&#125;void Trans(void)&#123; int i, j, k; double theta; for (i=0;i&lt;ns;i++) &#123; P=S[i]; for (j=0;j&lt;nc;j++) &#123; theta=(((double)(rand()%1000+1))/1000.0)*2.0*PI; A.x=P.x+Temp*cos(theta); A.y=P.y+Temp*sin(theta); if (A.x&lt;minx||A.x&gt;maxx||A.y&lt;miny||A.y&gt;maxy) continue; A.f=0.0; for (k=0;k&lt;nt;k++) A.f=A.f+Dis(A.x,A.y,T[k].x,T[k].y); dif=A.f-S[i].f; if (dif&lt;0.0)S[i]=A; else &#123; dif=exp(-dif/Temp); if (dif&gt;Lim) S[i]=A; &#125; &#125; &#125;&#125;int main (void)&#123; int i, k; while (scanf(&quot;%d&quot;,&amp;nt)==1&amp;&amp;nt) &#123; maxx=maxy=0; minx=miny=(1&lt;&lt;20); for (i=0;i&lt;nt;i++) &#123; scanf(&quot;%lf %lf&quot;,&amp;T[i].x,&amp;T[i].y); if (maxx&lt;T[i].x)maxx=T[i].x; if (minx&gt;T[i].x)minx=T[i].x; if (maxy&lt;T[i].y)maxy=T[i].y; if (miny&gt;T[i].y)miny=T[i].y; &#125; lx=maxx-minx; ly=maxy-miny; Temp=sqrt(lx*lx+ly*ly)/3.0; ns=5, nc=10; Seed(); while (Temp&gt;EPS) &#123; Trans(); Temp=Temp*0.40; &#125; k=0; for (i=1;i&lt;ns;i++) if (S[k].f&gt;S[i].f) k=i; printf (&quot;%.0lf\n&quot;, S[k].f); &#125; return 0;&#125; 六边形坐标系123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283**//第一种六边形坐标系**\#include&lt;stdio.h&gt;\#include&lt;math.h&gt;\#include&lt;string.h&gt;\#include&lt;stdlib.h&gt;double Dis(double x1, double y1, double x2, double y2)&#123;​ double dx=x1-x2;​ double dy=y1-y2;​ return sqrt(dx*dx+dy*dy);&#125;void Get_KL(double L, double x, double y, int &amp;k, int &amp;l, double &amp;cd)&#123;​ k=floor((2.0*x)/(3.0*L));​ l=floor((2.0*y)/(sqrt(3.0)*L));​ double d1, d2, x1, y1, x2, y2;​ if ((k+l)&amp;1)​ &#123;​ x1=k*L*1.5;​ y1=(l+1.0)*L*sqrt(3.0)*0.5;​ x2=(k+1.0)*L*1.5;​ y2=l*L*sqrt(3.0)*0.5;​ d1=Dis(x1,y1, x,y);​ d2=Dis(x2,y2, x,y);​ if (d1&gt;d2)​ &#123;​ k++;​ cd=d2;​ &#125;​ else​ &#123;​ l++;​ cd=d1;​ &#125;​ &#125;​ else​ &#123;​ x1=k*L*1.5;​ y1=l*L*sqrt(3.0)*0.5;​ x2=(k+1.0)*L*1.5;​ y2=(l+1.0)*L*sqrt(3.0)*0.5;​ d1=Dis(x1,y1, x,y);​ d2=Dis(x2,y2, x,y);​ if (d1&gt;d2)​ &#123;​ k++,l++;​ cd=d2;​ &#125;​ else cd=d1;​ &#125;&#125;int My_Abs(int x)&#123;​ if (x&lt;0) return -x;​ return x;&#125;int main (void)&#123;​ double L, x1, y1, x2, y2, ans, cd1, cd2;​ int k1, l1, k2, l2;​ while (scanf(&quot;%lf %lf %lf %lf %lf&quot;,&amp;L,&amp;x1,&amp;y1,&amp;x2,&amp;y2)==5)​ &#123;​ if (L==0.0&amp;&amp;x1==0.0&amp;&amp;y1==0.0&amp;&amp;x2==0.0&amp;&amp;y2==0.0) break;​ Get_KL(L, x1, y1, k1, l1, cd1);​ Get_KL(L, x2, y2, k2, l2, cd2);​ if (k1==k2&amp;&amp;l1==l2) printf(&quot;%.3lf\n&quot;, Dis(x1,y1, x2,y2));​ else​ &#123;​ ans=cd1+cd2;​ if (My_Abs(k1-k2) &gt; My_Abs(l1-l2))​ ans=ans+sqrt(3.0)*L*My_Abs(k1-k2);​ else ans=ans+sqrt(3.0)*L*My_Abs(k1-k2)+sqrt(3.0)*L*(double)(My_Abs(l1-l2)-My_Abs(k1-k2))/2.0;​ printf(&quot;%.3lf\n&quot;, ans);​ &#125;​ &#125;​ return 0;&#125; **//第二种六边形坐标系**\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;math.h&gt;struct A&#123;​ int x, y, num;&#125;a[10001];const int dec[6][2] = &#123;&#123;-1,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;0,1&#125;&#125;;bool adj(int x1, int y1, int x2, int y2)&#123;​ if (x1 == x2 &amp;&amp; abs(y1-y2) == 1) return true;​ if (y1 == y2 &amp;&amp; abs(x1-x2) == 1) return true;​ if (x1 == x2 + 1 &amp;&amp; y1 == y2 -1) return true;​ if (x1 == x2 - 1 &amp;&amp; y1 == y2 +1) return true;​ return false;&#125;bool flag[10001];int main (void)&#123;​ int i, j, k, x, u, v, cut, minn, cnt[6];​ memset(cnt, 0, sizeof(cnt));​ a[1].num = 1, cnt[1] = 1;​ a[1].x = a[1].y = 0;​ for (i = 2; i &lt; 10001; i ++)​ &#123;​ k = (int)((3.0+sqrt(12.0*i - 3.0))/6.0+0.0000001);​ if (i == 3*(k-1)*(k-1)+3*(k-1)+1) k --;​ j = i - (3*(k-1)*(k-1)+3*(k-1)+1);​ **// 当前的六边形是第k层的第j个六边形**​ if (j == 1) a[i].x = a[i-1].x, a[i].y = a[i-1].y + 1;​ else​ &#123;​ x = (j-1) / k;​ a[i].x = a[i-1].x + dec[x][0], a[i].y = a[i-1].y + dec[x][1];​ &#125;​ memset(flag, false, sizeof(flag));​ x = 12*k-6, cut = 0;​ for (u = i-1, v = 0; u&gt;=1&amp;&amp;v&lt;x; u --, v ++)​ if (adj(a[u].x, a[u].y, a[i].x, a[i].y))​ &#123;​ cut ++;​ flag[a[u].num] = true;​ if (cut == 3) break;​ &#125;​ minn = 10001;​ for (u = 1; u &lt; 6; u ++)​ if ((!flag[u])&amp;&amp;minn &gt; cnt[u])​ &#123;​ minn = cnt[u];​ x = u;​ &#125;​ a[i].num = x;​ cnt[x] ++;​ &#125;​ scanf (&quot;%d&quot;, &amp;x);​ while (x --)​ &#123;​ scanf (&quot;%d&quot;, &amp;i);​ printf (&quot;%d\n&quot;, a[i].num);​ &#125;​ return 0;&#125; 用一个给定半径的圆覆盖最多的点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163**//同半径圆的圆弧表示**\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;math.h&gt;\#define PI acos(-1.0)struct Point&#123; double x, y;&#125;pt[2005];double dis[2005][2005];struct List&#123; double a; bool flag; int id;&#125;list[8005];int cnt;double Dis(int i, int j)&#123; double dx=pt[i].x-pt[j].x; double dy=pt[i].y-pt[j].y; return sqrt(dx*dx+dy*dy);&#125;int Cmp(const void*p1, const void*p2)&#123; struct List*a1=(struct List*)p1; struct List*a2=(struct List*)p2; if (a1-&gt;a&lt;a2-&gt;a)return -1; else if (a1-&gt;a==a2-&gt;a) return a1-&gt;id-a2-&gt;id; else return 1;&#125;int main (void)&#123; int n, i, j, ans, num; double r, theta, delta, a1, a2; while (scanf(&quot;%d %lf&quot;,&amp;n,&amp;r)==2) &#123; if (n==0&amp;&amp;r==0.0) break; r=r+0.001; r=r*2.0; for (i=1;i&lt;=n;i++) scanf(&quot;%lf %lf&quot;, &amp;pt[i].x, &amp;pt[i].y); for (i=1;i&lt;n;i++) for (j=i+1;j&lt;=n;j++) &#123; dis[i][j]=Dis(i, j); dis[j][i]=dis[i][j]; &#125; ans=0; for (i=1;i&lt;=n;i++) &#123; cnt=0; for (j=1;j&lt;=n;j++) if ((j!=i)&amp;&amp;(dis[i][j]&lt;=r)) &#123; theta=atan2(pt[j].y-pt[i].y, pt[j].x-pt[i].x); if (theta&lt;0.0) theta=theta+2.0*PI; delta=acos(dis[i][j]/r); a1=theta-delta; a2=theta+delta; list[++cnt].a=a1; list[cnt].flag=true; list[cnt].id=cnt; list[++cnt].a=a2; list[cnt].flag=false; list[cnt].id=cnt; &#125; qsort(list+1,cnt,sizeof(struct List),Cmp); num=0; for (j=1;j&lt;=cnt;j++) if (list[j].flag) &#123; num++; if (num&gt;ans) ans=num; &#125; else num--; &#125; printf(&quot;It is possible to cover %d points.\n&quot;, ans+1); &#125; return 0;&#125; 不等大的圆的圆弧表示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061intersection_circle_circle(circle[i].center, circle[i].r, circle[j].center, circle[j].r, p1, p2); a1= atan2(p1.y-circle[j].center.y, p1.x-circle[j].center.x); if (a1&lt;0.0) a1=a1+2.0*PI; a2= atan2(p2.y-circle[j].center.y, p2.x-circle[j].center.x); if (a2&lt;0.0) a2=a2+2.0*PI; if (a1&gt;a2) &#123; tmp=a1; a1=a2; a2=tmp; &#125; mid=(a1+a2)/2.0; xtest = circle[j].center.x +circle[j].r*cos(mid); ytest = circle[j].center.y +circle[j].r*sin(mid); if (!point_in_circle(xtest, ytest, i)) &#123; circle[j].cnt++; circle[j].line[circle[j].cnt].s=0; circle[j].line[circle[j].cnt].t=a1; circle[j].cnt++; circle[j].line[circle[j].cnt].s=a2; circle[j].line[circle[j].cnt].t=2.0*PI; &#125; else &#123; circle[j].cnt++; circle[j].line[circle[j].cnt].s=a1; circle[j].line[circle[j].cnt].t=a2; &#125; 矩形面积并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311\#include&lt;stdio.h&gt;\#include&lt;string.h&gt;\#include&lt;stdlib.h&gt;\#include&lt;math.h&gt;struct Node&#123; int l, r, cnt; double cover;&#125;node[80005];struct Point&#123; double x; double y1, y2; int id_y1, id_y2, id_x; bool flag;&#125;pt[20005];double y[20005];int total, cnty;int cmp1(const void*p1, const void*p2)&#123; double*a1=(double*)p1; double*a2=(double*)p2; if (*a1&lt;*a2) return -1; else if (*a1==*a2) return 0; else return 1;&#125;int cmp2(const void*p1, const void*p2)&#123; struct Point*a1=(struct Point*)p1; struct Point*a2=(struct Point*)p2; if (a1-&gt;x&lt;a2-&gt;x) return -1; else if (a1-&gt;x==a2-&gt;x) &#123; if (a1-&gt;id_x&lt;a2-&gt;id_x) return -1; else if (a1-&gt;id_x==a2-&gt;id_x) return 0; else return 1; &#125; else return 1;&#125;int find(double target)&#123; int head=1, tail=cnty, mid; while (head&lt;=tail) &#123; mid=(head+tail)&gt;&gt;1; if (y[mid]==target) return mid; else if (y[mid]&lt;target) head=mid+1; else tail=mid-1; &#125; return 0;&#125;void Build(int l, int r, int s)&#123; node[s].l=l; node[s].r=r; node[s].cnt=0; node[s].cover=0.0; if (l+1&lt;r) &#123; int mid=(l+r)&gt;&gt;1; Build(l,mid,s&lt;&lt;1); Build(mid,r,(s&lt;&lt;1)+1); &#125;&#125;void Update(int s)&#123; if (node[s].cnt&gt;0) node[s].cover=y[node[s].r]-y[node[s].l]; else if(node[s].l+1==node[s].r) node[s].cover=0.0; else node[s].cover=node[s&lt;&lt;1].cover+node[(s&lt;&lt;1)+1].cover;&#125;void Insert(int l, int r, int s)&#123; if (l&lt;=node[s].l&amp;&amp;node[s].r&lt;=r) &#123; node[s].cnt++; Update(s); return; &#125; if (node[s].l+1&lt;node[s].r) &#123; int mid=(node[s].l+node[s].r)&gt;&gt;1; if (l&lt;mid) Insert(l,r,s&lt;&lt;1); if (r&gt;mid) Insert(l,r,(s&lt;&lt;1)+1); Update(s); &#125;&#125;void Delete(int l, int r, int s)&#123; if (l&lt;=node[s].l&amp;&amp;node[s].r&lt;=r) &#123; if (node[s].cnt&gt;0) node[s].cnt--; Update(s); return; &#125; if (node[s].l+1&lt;node[s].r) &#123; int mid=(node[s].l+node[s].r)&gt;&gt;1; if (l&lt;mid) Delete(l,r,s&lt;&lt;1); if (r&gt;mid) Delete(l,r,(s&lt;&lt;1)+1); Update(s); &#125;&#125;int main (void)&#123; int n, i, j, countn=0; double ans; while (scanf(&quot;%d&quot;, &amp;n)==1 &amp;&amp; n) &#123; cnty=total=0; for (i=1;i&lt;=n;i++) &#123; total++; scanf(&quot;%lf %lf&quot;, &amp;pt[total].x, &amp;pt[total].y1); pt[total].flag=true; pt[total].id_x=total; y[++cnty]=pt[total].y1; total++; scanf(&quot;%lf %lf&quot;, &amp;pt[total].x, &amp;pt[total].y2); pt[total].flag=false; pt[total].id_x=total; y[++cnty]=pt[total].y2; pt[total].y1=pt[total-1].y1; pt[total-1].y2=pt[total].y2; &#125; qsort(y+1, cnty, sizeof(double), cmp1); j=cnty; cnty=1; for (i=2;i&lt;=j;i++) if (y[i]!=y[i-1]) y[++cnty]=y[i]; for (i=1;i&lt;=total;i++) &#123; pt[i].id_y1=find(pt[i].y1); pt[i].id_y2=find(pt[i].y2); &#125; qsort(pt+1, total, sizeof(struct Point), cmp2); ans=0.0; Build(1,cnty,1); Insert(pt[1].id_y1, pt[1].id_y2, 1); for (i=2;i&lt;=total;i++) &#123; ans=ans+(pt[i].x-pt[i-1].x)*node[1].cover; if (pt[i].flag) Insert(pt[i].id_y1, pt[i].id_y2, 1); else Delete(pt[i].id_y1, pt[i].id_y2, 1); &#125; printf(&quot;%.0lf\n&quot;, ans+1e-10); &#125; return 0;&#125; 矩形的周长并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341\#include &lt;stdio.h&gt;\#include &lt;string.h&gt;\#include &lt;stdlib.h&gt;struct Point&#123; int x, y;&#125;plist[10001];struct Line&#123; int x, b, e, flag;&#125;llist[10001];struct Item&#123; int y, id, idx;&#125;ilist[10001];struct Node&#123; int l, r, c, m, line; bool lf, rf;&#125;node[40005];int ys[10001];int cmp1(const void*p1, const void*p2)&#123; struct Item *a1 = (struct Item*)p1; struct Item *a2 = (struct Item*)p2; return a1-&gt;y - a2-&gt;y;&#125;int cmp2(const void*p1, const void*p2)&#123; struct Item *a1 = (struct Item*)p1; struct Item *a2 = (struct Item*)p2; return a1-&gt;id - a2-&gt;id;&#125;int cmp3(const void*p1, const void*p2)&#123; struct Line *a1 = (struct Line*)p1; struct Line *a2 = (struct Line*)p2; return a1-&gt;x - a2-&gt;x;&#125;void getm(int s)&#123; if (node[s].c &gt; 0) &#123; node[s].m = ys[node[s].r-1] - ys[node[s].l-1]; node[s].line = 1; node[s].rf = node[s].lf = true; &#125; else if (node[s].r - node[s].l &lt;= 1) &#123; node[s].m = node[s].line = 0; node[s].rf = node[s].lf = false; &#125; else &#123; node[s].m = node[s&lt;&lt;1].m + node[(s&lt;&lt;1)+1].m; node[s].line = node[s&lt;&lt;1].line + node[(s&lt;&lt;1)+1].line; if (node[s&lt;&lt;1].rf &amp;&amp; node[(s&lt;&lt;1)+1].lf) node[s].line --; node[s].lf = node[s&lt;&lt;1].lf; node[s].rf = node[(s&lt;&lt;1)+1].rf; &#125;&#125;void build(int l, int r, int s)&#123; node[s].l = l; node[s].r = r; node[s].c = node[s].m = node[s].line; if (node[s].r - node[s].l &gt; 1) &#123; int mid = (node[s].l + node[s].r)&gt;&gt;1; build(l,mid,s&lt;&lt;1); build(mid,r,(s&lt;&lt;1)+1); &#125;&#125;void insert(int l, int r, int s)&#123; if (l &lt;= node[s].l &amp;&amp; node[s].r &lt;= r) &#123; node[s].c ++; getm(s); &#125; if (node[s].r - node[s].l &gt; 1) &#123; int mid = (node[s].l + node[s].r)&gt;&gt;1; if (l &lt; mid) insert(l, r, s&lt;&lt;1); if (mid &lt; r) insert(l, r, (s&lt;&lt;1)+1); getm(s); &#125;&#125;void delet(int l, int r, int s)&#123; if (l &lt;= node[s].l &amp;&amp; node[s].r &lt;= r) &#123; node[s].c --; getm(s); &#125; if (node[s].r - node[s].l &gt; 1) &#123; int mid = (node[s].l + node[s].r)&gt;&gt;1; if (l &lt; mid) delet(l, r, s&lt;&lt;1); if (mid &lt; r) delet(l, r, (s&lt;&lt;1)+1); getm(s); &#125;&#125;int main (void)&#123; int n, i, j, l, r, x1, y1, x2, y2, tot, p, ans; while (scanf (&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) &#123; for (i = 0; i &lt; n; i ++) &#123; scanf (&quot;%d %d %d %d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); l = 2*i; r = l + 1; plist[l].x = x1; plist[l].y = y1; plist[r].x = x2; plist[r].y = y2; ilist[l].y = y1; ilist[l].id = l; ilist[r].y = y2; ilist[r].id = r; &#125; tot = 2*n; qsort(ilist, tot, sizeof(struct Item), cmp1); ys[0] = ilist[0].y; ilist[0].idx = 0; j = 0; for (i = 1; i &lt; tot; i ++) &#123; if (ilist[i].y != ilist[i-1].y) &#123; j ++; ys[j] = ilist[i].y; &#125; ilist[i].idx = j; &#125; p = j + 1; qsort(ilist, tot, sizeof(struct Item), cmp2); for (i = 0; i &lt; n; i ++) &#123; l = 2*i; r = l + 1; llist[l].x = plist[l].x; llist[l].b = ilist[l].idx; llist[l].e = ilist[r].idx; llist[l].flag = 1; llist[r].x = plist[r].x; llist[r].b = ilist[l].idx; llist[r].e = ilist[r].idx; llist[r].flag = 0; &#125; qsort(llist, tot, sizeof(struct Line), cmp3); build(1,p,1); insert(llist[0].b+1, llist[0].e+1,1); int now_m = node[1].m, now_line = node[1].line; ans = now_m; for (i = 1; i &lt; tot; i ++) &#123; if (llist[i].flag) insert(llist[i].b+1, llist[i].e+1, 1); else delet(llist[i].b+1, llist[i].e+1, 1); ans += (abs(node[1].m - now_m) + 2*(llist[i].x - llist[i-1].x)*now_line); now_m = node[1].m; now_line = node[1].line; &#125; printf (&quot;%d\n&quot;, ans); &#125; return 0;&#125; 最近圆对123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301\#include&lt;iostream&gt;\#include&lt;stdlib.h&gt;\#include&lt;string.h&gt;\#include&lt;set&gt;\#include &lt;math.h&gt;using namespace std;set &lt;int&gt;tree;set &lt;int&gt;::iterator iter;struct Point&#123; double x; int id, flag;&#125;p1[100001], p2[100001];int tot1, tot2;struct Q&#123; double x,y, r;&#125;q[50001];int cmp(const void*p1, const void*p2)&#123; struct Point*a1=(struct Point*)p1; struct Point*a2=(struct Point*)p2; if (a1-&gt;x&lt;a2-&gt;x) return -1; else if (a1-&gt;x==a2-&gt;x) return a2-&gt;flag-a1-&gt;flag; else return 1;&#125;int cmp1(const void*p1, const void*p2)&#123; struct Q*a1=(struct Q*)p1; struct Q*a2=(struct Q*)p2; if (a1-&gt;y&lt;a2-&gt;y)return -1; else if (a1-&gt;y==a2-&gt;y)return 0; else return 1;&#125;double dis(double x1, double y1, double x2, double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;bool judge(int i, int j, double d)&#123; if (dis(q[i].x, q[i].y, q[j].x, q[j].y)&lt;=q[i].r+q[j].r+2.0*d) return true; return false;&#125;bool insert(int v,double d)&#123; iter = tree.insert(v).first; if (iter != tree.begin()) &#123; if (judge(v, *--iter,d)) &#123; return true; &#125; ++iter; &#125; if (++iter != tree.end()) &#123; if (judge(v, *iter,d)) &#123; return true; &#125; &#125; return false;&#125;bool remove(int v,double d)&#123; iter = tree.find(v); if (iter != tree.begin() &amp;&amp; iter != --tree.end()) &#123; int a = *--iter; ++iter; int b = *++iter; if (judge(a, b,d)) &#123; return true; &#125; &#125; tree.erase(v); return false;&#125;bool check(double d)&#123; int i=1, j=1; while (i&lt;=tot1&amp;&amp;j&lt;=tot2) &#123; if (p1[i].x-d&lt;=p2[j].x+d) &#123; if (insert(p1[i++].id, d)) return true; &#125; else &#123; if (remove(p2[j++].id, d)) return true; &#125; &#125; while (i&lt;=tot1) &#123; if (insert(p1[i++].id, d)) return true; &#125; while (j&lt;=tot2) &#123; if (remove(p2[j++].id, d)) return true; &#125; return false;&#125;int main (void)&#123; int cases, n, i; scanf(&quot;%d&quot;,&amp;cases); while (cases--) &#123; scanf(&quot;%d&quot;,&amp;n); tot1=tot2=0; for (i=1;i&lt;=n;i++) scanf(&quot;%lf %lf %lf&quot;,&amp;q[i].x,&amp;q[i].y, &amp;q[i].r); qsort(q+1,n,sizeof(struct Q),cmp1); for (i=1;i&lt;=n;i++) &#123; tot1++; p1[tot1].x=q[i].x-q[i].r; p1[tot1].id=i; p1[tot1].flag=1; tot2++; p2[tot2].x=q[i].x+q[i].r; p2[tot2].id=i; p2[tot2].flag=-1; &#125; qsort(p1+1,tot1,sizeof(struct Point),cmp); qsort(p2+1,tot2,sizeof(struct Point),cmp); double head=0.0, tail=dis(q[1].x,q[1].y,q[2].x,q[2].y)+1.0, mid; while (tail-head&gt;1e-8) &#123; tree.clear(); mid=(head+tail)/2.0; if (check(mid)) &#123; tail=mid; &#125; else head=mid; &#125; printf (&quot;%.6lf\n&quot;,2.0*head); &#125; return 0;&#125; 求两个圆的面积交1234567891011121314151617double area_of_overlap(point c1, double r1, point c2, double r2)&#123; double a = distance(c1, c2), b = r1, c = r2;double cta1 = acos((a * a + b * b - c * c) / 2 / (a * b)), cta2 = acos((a * a + c * c - b * b) / 2 / (a * c)); double s1 = r1*r1*cta1 - r1*r1*sin(cta1)*(a * a + b * b - c * c) / 2 / (a * b); double s2 = r2*r2*cta2 - r2*r2*sin(cta2)*(a * a + c * c - b * b) / 2 / (a * c); return s1 + s2;&#125; 博弈论Nim博弈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #define LL long long #define mod 1000000007 #define sz 100005 using namespace std; int sg[sz]; bool vis[sz]; int main() &#123; //´ò±í³ÌÐò /*int tmp; sg[0]=0; for(int i=1;i&lt;=50;i++) &#123; memset(vis,0,sizeof(vis)); for(int j=0;j&lt;i;j++) vis[sg[j]]=1; for(int k=1;k&lt;i;k++) &#123; for(int m=1;m&lt;i;m++) &#123; int u=i-k-m; if(u&gt;0) &#123; tmp=sg[k]^sg[m]^sg[u]; vis[tmp]=1; &#125; else break; &#125; &#125; for(int x=0;;x++) if(!vis[x]) &#123; sg[i]=x; printf(&quot;sg[%d]: %d\n&quot;,i,x); break; &#125; &#125;*/ int t,n,tmp,s; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; s=0; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d&quot;,&amp;tmp); if(tmp%8==7) s^=(tmp+1); else if(tmp%8==0) s^=(tmp-1); else s^=tmp; &#125; if(s) printf(&quot;First player wins.\n&quot;); else printf(&quot;Second player wins.\n&quot;); &#125; return 0; &#125; 威佐夫博弈12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int wzf(int a,int b)&#123; if(a&lt;b)&#123; a^=b; b^=a; a^=b; &#125; int k=a-b; a=(int)(k*(1+sqrt(5))/2.0); if(a==b) return 1; else return 0; &#125;int main()&#123; for(int i=1;i&lt;100;i++) for(int j=1;j&lt;100;j++) if(wzf(i,j)) printf(&quot;(%d,%d) %d\n&quot;,i,j,i-j);&#125; 其他整数划分123456789101112131415161718192021222324252627282930#include&lt;iostream&gt; using namespace std; int d[1000][10], n, k; int main() &#123; cin &gt;&gt; n &gt;&gt; k; d[0][0] = 1; for (int i = 1; i &lt;= n; i++) d[i][1] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= k; j++) if (i &gt;= j) d[i][j] = d[i - j][j] + d[i - 1][j - 1]; cout &lt;&lt; d[n][k]&lt;&lt;endl; return 0; &#125; 区间K大数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#define MAXN 10010#define MAXE 100010using namespace std;int head[MAXN],tot1,tot2;struct Edge&#123; int u,v,next;&#125; e1[MAXE],e2[MAXN];void addEdge(int u,int v,Edge* edge,int&amp; tol)&#123; edge[tol].u=u; edge[tol].v=v; edge[tol].next=head[u]; head[u]=tol++;&#125;int n,m;int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];bool instack[MAXN];int scc,top,INDEX;void Tarjan(int u)&#123; int v; low[u]=dfn[u]=++INDEX; stack[top++]=u; instack[u]=true; for(int i=head[u]; i!=-1; i=e1[i].next) &#123; v=e1[i].v; if(!dfn[v]) &#123; Tarjan(v); if(low[u]&gt;low[v]) low[u]=low[v]; &#125; else if(instack[v]&amp;&amp;low[u]&gt;dfn[v]) low[u]=dfn[v]; &#125; if(low[u]==dfn[u]) &#123; ++scc; do &#123; v=stack[--top]; instack[v]=false; belong[v]=scc; num[scc]++; &#125; while(u!=v); &#125;&#125;int inde[MAXN],outde[MAXN];void solve()&#123; memset(dfn,0,sizeof(dfn)); memset(instack,false,sizeof(instack)); memset(num,0,sizeof(num)); scc=top=INDEX=0; for(int i=1; i&lt;=n; ++i) if(!dfn[i]) Tarjan(i); tot2=0; memset(head,-1,sizeof(head)); memset(inde,0,sizeof(inde)); memset(outde,0,sizeof(outde)); int u,v; for(int i=0; i&lt;m; ++i) &#123; u=belong[e1[i].u]; v=belong[e1[i].v]; if(u!=v) &#123; addEdge(u,v,e2,tot2); inde[v]++; outde[u]++; &#125; &#125; int a=0,b=0; for(int i=1; i&lt;=scc; ++i) &#123; if(!inde[i]) a++; if(!outde[i]) b++; &#125; if(scc==1) printf(&quot;0\n&quot;); else printf(&quot;%d\n&quot;,max(a,b));&#125;int main()&#123; int zushu; scanf(&quot;%d&quot;,&amp;zushu); while(zushu--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tot1=0; memset(head,-1,sizeof(head)); int u,v; for(int i=0; i&lt;m; ++i) &#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); addEdge(u,v,e1,tot1); &#125; solve(); &#125; return 0;&#125;22. 22. 22. 22. 区间 KKKK 大数//POJ 2104#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int NMAX = 100000;const int LOGNMAX = 17 +1;int sortseq[LOGNMAX][NMAX];int num[NMAX];struct node&#123; int l,r,d; node * pl,* pr;&#125; mem[(NMAX&lt;&lt;1)+100];int mempos,n,m;node * root;node * make_tree(int l,int r,int d)&#123; node * rt = mem+(mempos ++); rt-&gt;l = l; rt-&gt;r = r; rt-&gt;d = d; if (l == r) &#123; sortseq[d][l] = num[l]; return rt; &#125; int mid = (l+r) &gt;&gt; 1; rt-&gt;pl = make_tree(l,mid,d+1); rt-&gt;pr = make_tree(mid+1,r,d+1); int i=l,j=mid+1,k=l; while (i&lt;=mid &amp;&amp; j&lt;=r) &#123; if (sortseq[d+1][i] &lt; sortseq[d+1][j]) sortseq[d][k++] = sortseq[d+1][i++]; else sortseq[d][k++] = sortseq[d+1][j++]; &#125; while (i&lt;=mid) sortseq[d][k++] = sortseq[d+1][i++]; while (j&lt;=r) sortseq[d][k++] = sortseq[d+1][j++]; return rt;&#125;int s,t,rank;int query(node * rt,int val)&#123; int i,mid,ret; if (s &lt;= rt-&gt;l &amp;&amp; rt-&gt;r &lt;= t) &#123; if (val &lt;= sortseq[rt-&gt;d][rt-&gt;l]) return 0; else if (sortseq[rt-&gt;d][rt-&gt;r] &lt; val) return rt-&gt;r - rt-&gt;l +1; else if (sortseq[rt-&gt;d][rt-&gt;r] == val) return rt-&gt;r - rt-&gt;l; int l = rt-&gt;l, r = rt-&gt;r, mid; while (l &lt;= r) &#123; mid = (l+r) &gt;&gt; 1; if (val &lt;= sortseq[rt-&gt;d][mid]) r = mid-1; else l = mid+1; &#125; return l - rt-&gt;l; &#125; else &#123; ret = 0; mid = (rt-&gt;l+rt-&gt;r) &gt;&gt; 1; if (s &lt;= mid) ret += query(rt-&gt;pl,val); if (mid+1 &lt;= t) ret += query(rt-&gt;pr,val); return ret; &#125;&#125;// 二分查找时遇到相同值的处理非常重要int main()&#123; int i,j,l,r; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for (i=0; i&lt;n; i++) scanf(&quot;%d&quot;,num+i); mempos = 0; root = make_tree(0,n-1,0); while (m --) &#123; s = get_val()-1; t = get_val()-1; rank = get_val()-1; l = 0, r = n-1; while (l &lt;= r) &#123; int mid = (l+r) &gt;&gt; 1;// 二分查找sortseq[0][mid]在区间[s,t]中的排名 int pos = query(root,sortseq[0][mid]); if (rank &lt; pos) r = mid-1; else l = mid+1; &#125; printf(&quot;%d\n&quot;,sortseq[0][r]); &#125;&#125; 离散化12345678int getid(int x)&#123; return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;&#125; for(int i = 1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); &#125; sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end()); 位运算统计1的个数12345678int NumberOfOne(int n) &#123; int count = 0; while(n) &#123; n &amp;= (n-1); count++; &#125; return count;&#125; strtok 和 sscanf 结合输入空格作为分隔输入，读取一行的整数： 12345678gets(buf);int v;char *p = strtok(buf,&quot; &quot;);while(p)&#123; sscanf(p,&quot;%d&quot;,&amp;v); p = strtok(NULL,&quot; &quot;);&#125; 输入输出挂12345678910111213141516171819202122//适用于正负整数template &lt;class T&gt;inline bool scan_d(T &amp;ret)&#123; char c; int sgn; if(c=getchar(),c==EOF) return 0; //EOF while(c!=&apos;−&apos;&amp;&amp;(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)) c=getchar(); sgn=(c==&apos;−&apos;)?−1:1; ret=(c==&apos;−&apos;)?0:(c−&apos;0&apos;); while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) ret=ret*10+(c−&apos;0&apos;); ret*=sgn; return 1;&#125;inline void out(int x)&#123; if(x&gt;9) out(x/10); putchar(x%10+&apos;0&apos;)&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>动态规划</tag>
        <tag>博弈论</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC2016-F.Mountain Scenes]]></title>
    <url>%2F2018%2F10%2F02%2F2018-10-02%2F</url>
    <content type="text"><![CDATA[1000ms 262144K An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various integral lengths, then aligns them with the bottom of a frame, rising vertically in columns, to form a mountain scene. A mountain scene must be uneven; if all columns are the same height, it’s a plain scene, not a mountain scene! It is possible that she may not use all of the ribbon. If our artist has 44 inches of ribbon and a 2 \times 22×2 inch frame, she could form these scenes: She would not form these scenes, because they’re plains, not mountains! Given the length of the ribbon and the width and height of the frame, all in inches, how many different mountain scenes can she create? Two scenes are different if the regions covered by ribbon are different. There’s no point in putting more than one piece of ribbon in any column. InputEach input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input will consist of a single line with three space-separated integers nn, ww and hh, where nn (0 \le n \le 10,000)(0≤n≤10,000) is the length of the ribbon in inches, w (1 \le w \le 100)w(1≤w≤100) is the width and hh (1 \le h \le 100)(1≤h≤100)is the height of the frame, both in inches. OutputOutput a single integer, indicating the total number of mountain scenes our artist could possibly make, modulo 10^9 + 7109+7. 样例输入1复制125 5 5 样例输出1复制17770 样例输入2复制115 5 5 样例输出2复制16050 样例输入3复制110 10 1 样例输出3复制11022 题解问题可以转化为有n个物品，现有w个盘子，每个盘子的容量为[0,h]，所有盘子放的物品不能全部相同，n个物品选[0,n]个物品放进盘中，共有多少种方法。 首先，利用dp，第一层i为第i个盘子，第2层j为前i个盘子共放置j个物品共有多少种方法。这样dp[i][j]+=dp[i-1][j-k]，其中k[0,h] 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 1e4+7;const ll mod = 1e9+7;ll dp[107][maxn];ll n,w,h;ll solve()&#123; memset(dp,0,sizeof(dp)); ll ans = 0; if(n &gt; w * h)&#123; n = w*h; &#125; for(int i = 0;i&lt;=n;i++)&#123; dp[0][i] = 1; &#125; for(int i = 1; i&lt;=w; i++)&#123; for(int j = 0;j&lt;=n; j++)&#123; for(int k = 0; k&lt;=h&amp;&amp;k&lt;=j; k++)&#123; dp[i][j]+=dp[i-1][j-k]; dp[i][j]%=mod; &#125; &#125; &#125; ans = (dp[w][n] - 1 - n/w + mod)%mod; return ans;&#125;int main()&#123; while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;w,&amp;h))&#123; printf(&quot;%lld\n&quot;,solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分时最短路+次小生成树+最小费用最大流题解]]></title>
    <url>%2F2018%2F09%2F29%2F2018-09-29%2F</url>
    <content type="text"><![CDATA[问题 A: 高速时间限制: 1 Sec 内存限制: 128 MB提交: 15 解决: 4[提交][状态][讨论版][命题人:qianyouyou] 题目描述教练开车去东北，因为比赛地点在东北。共有 n 座城，已知教练在 s 城，比赛地点在 t 城，n 座城之间共有 m 条高速，每条高速连接两座城市，每两座城市之间最多两条高速。每条高速都有权值 v，表示两个城市之间最快可以 v 小时到达。 然而高速不是永久开放的，每条高速都会有一段开放时间 [ a，b ]，表示该高速在 a ~ b 小时范围之间开放，其余时间处于关闭状态，不能通过任何车辆。例如 [ 24，27 ]表示该路在第 24 小时到 27 小时之间开放。 已知教练在 0 时刻出发，他最快多少小时可以到达 t 城。 （PS：由于刹车坏掉了，因此车一旦启动就不能停下来，也就是说车不能停于某点或某边，不过车可以来回无限次在两地之间穿梭） 输入多组测试样例，首行输入 t，表示 t 组样例。 图为无向图，s 城固定为 1 点，t 城固定为 n 点。 每组样例第 1 行，输入n，m（1 &lt; n ≤ 100，0 &lt; m ≤ 1000）。 接下来 m 行，每行 5 个数值x，y，v，l，f。表示 x 与 y 有一条高速，耗时为 v。该路开放时间为[ l，f ]。 数据保证教练可以到达终点，只不过是时间问题。 输出输出一个数值，即最少耗时。 样例输入12345615 42 3 1 5 112 5 1 3 184 3 1 7 141 4 1 0 15 样例输出110 tag：图论、分时最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//最短路#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxx = 0x3f3f3f3f;const int maxn = 1e5+7;int t,n,m,cnt;int dis[maxn]; //当前该点到原点最短距离bool vis[maxn]; //是否访问过int head[maxn]; //点集struct EDGE&#123; int next,to,w,l,r; //上一条边，下一个点，权值，左值，右值&#125;edge[2*maxn]; //边集struct NODE&#123; int u,dis; NODE()&#123;&#125; NODE(int u,ll w):u(u),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const&#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn]; //点集加最短距离void add(int u, int v, int w, int l,int r)&#123; //构建边集 edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].l = l; edge[cnt].r = r; head[u] = cnt; cnt++;&#125;void init()&#123; //初始化 cnt = 0; memset(head,-1,sizeof(head)); memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis));&#125;void read()&#123; //读入数据 int u,v,w,l,r; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 0;i &lt; m; i++)&#123; scanf(&quot;%d%d%d%d%d&quot;,&amp;u,&amp;v,&amp;w,&amp;l,&amp;r); add(u,v,w,l,r); add(v,u,w,l,r); &#125;&#125;void init_data(int kk)&#123; //初始化数据 vis[kk] = false; dis[kk] = maxx;&#125;int solve(int s)&#123; priority_queue&lt;NODE&gt;q; //储存最短距离 q.push(NODE(s,0)); //读入原点 while(!q.empty())&#123; //队列为空则无法到达 int kk = q.top().u; //储存当前最短距离下标 int minD = q.top().dis; //储存当前最短距离 q.pop(); if(kk==n) //若下标为目标值，return return minD; vis[kk] = true; //该点是否访问 for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; //松弛边 if(!vis[edge[l].to]&amp;&amp;minD&lt;=edge[l].r&amp;&amp;minD&gt;=edge[l].l&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123; dis[edge[l].to] = minD + edge[l].w; q.push(NODE(edge[l].to,dis[edge[l].to])); //将松弛后的边压入队列 &#125; &#125; init_data(kk); //初始化数据 &#125; return 0;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; init(); //初始化 read(); //读入 printf(&quot;%d\n&quot;,solve(1)); //解决方案 &#125; return 0;&#125; 问题 C: 千年老二时间限制: 1 Sec 内存限制: 128 MB提交: 24 解决: 12[提交][状态][讨论版][命题人:qianyouyou] 题目描述雷婷与万钧是青梅竹马，无论是考试还是玩游戏，雷婷总是第一，而万钧总是第二，尽管万钧有做第一的实力，但他每次都会把第一让给雷婷，仅因为每次读榜单时雷霆万钧听起来是那么顺耳。这天，雷婷参加了 acm 选拔，万钧也跟着雷婷参加。题目是这样的： 有 n 个节点，编号为 1~n，有 m 条边，每条边都有一个距离。两点之间最多只有 1 条边。现在你需要选取 n-1 条边，使得所有点都连接起来都有通路。n-1 条边距离之和越小分数越高。 万钧立马意识到这道题是求最小生成树的，并且每个人的答案不能相同，万钧根据瞪眼法立马瞪出了答案，然而他还是等待雷婷先做完。现在雷婷已经找到了距离最短的1种方案，不过他俩太心有灵犀了，答案一模一样，万钧想获得第 2 名，请你帮万钧想一种方案，距离之和越短越好，但不能和雷婷的结果相同。一条边不同即可认为不同。如果找不到输出 -1。当然存在一种情况，如果雷婷的方案是没有方案求出最短距离，即表示该图没有最小生成树，即输出 -1。总之雷婷的方案是最优解的一种。 输入存在多组数据，第一行一个正整数 t，表示有 t 组数据。 每组数据第一行有两个整数 n 和 m（2 ≤ n ≤ 100，1 ≤ m ≤ 1000)，之后 m 行，每行三个正整数 s，e，w，表示 s 到 e 的双向路的权值为 w。 输出输出次小生成树的值（如果存在多个最小生成树或仅有一个树，则次小生成树就是最小生成树，输出-1），如果不存在输出 -1。 样例输入1234513 33 1 31 2 12 3 2 样例输出14 tag：图论、次小生成树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//次小生成树#include&lt;bits/stdc++.h&gt;using namespace std;const int L=1e5+7;const int inf=0x3f3f3f3f;const int maxn=1000+7;int father[maxn],n,m,num[maxn],nPos; //父节点（并查集），点数，边数，最小生成树点集，当前访问方位struct node&#123; int s,y,w;&#125;edge[L]; //边集，左端点，右端点，权值void init()&#123; //初始化并查集 for(int i=0;i&lt;=n;i++) father[i]=i;&#125;int root(int x)&#123; //并查集，构造父节点 return father[x]==x?x:father[x]=root(father[x]);&#125;void unite(int x,int y)&#123; //并查集，合并两个联通图 x=root(x); y=root(y); if(x!=y) father[y]=x;&#125;int alike(int x,int y)&#123; //并查集，判断是否为同一连通图 return root(x)==root(y);&#125;int cmp(node a,node b)&#123; //sort结构体排序 return a.w&lt;b.w;&#125;int secondTree(int pos) //次小生成树&#123; init(); //初始化 int sum=0,cnt=0; for(int i=0;i&lt;m;i++) //对于删去边后的图进行最小生成树运算 &#123; if(cnt==n-1) break; if(i==pos) continue; if(!alike(edge[i].s,edge[i].y))&#123; unite(edge[i].s,edge[i].y); sum+=edge[i].w; cnt++; &#125; &#125; return cnt!=n-1?-1:sum; //判断删除边后是否能构成最小生成树&#125;int kruskal()&#123; //最小生成树 init(); sort(edge,edge+m,cmp); //对边进行权值排序 int sum=0,cnt=0; for(int i=0;i&lt;m;i++) //每次选择最小且未访问过的一条边 &#123; if(cnt==n-1) break; if(!alike(edge[i].s,edge[i].y))&#123; unite(edge[i].s,edge[i].y); sum+=edge[i].w; cnt++; num[++nPos]=i; &#125; &#125; return cnt!=n-1?-1:sum; //判断边是否大于等于n-1，否则输出-1&#125;void read()&#123; //读入数据 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf(&quot;%d%d%d&quot;,&amp;edge[i].s,&amp;edge[i].y,&amp;edge[i].w);&#125;void solve()&#123; //解决方案 int Min=inf; nPos=0; int mst=kruskal(); //最小生成树值 if(mst==-1) &#123; //没有最小生成树即输出-1 printf(&quot;-1\n&quot;); return; &#125; for(int i=1;i&lt;=nPos;i++)&#123; //对最小生成树的每条边进行遍历，选择删边后的最小值 int secmst=secondTree(num[i]); if(secmst!=-1) //若没有次小生成树输出-1 Min=min(Min,secmst); &#125; if(Min!=inf&amp;&amp;Min!=mst) printf(&quot;%d\n&quot;,Min); //输出结果 else printf(&quot;-1\n&quot;);&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; read(); //读入数据 solve(); //解决方案 &#125; return 0;&#125; 问题 F: 给力台球厅时间限制: 1 Sec 内存限制: 128 MB提交: 10 解决: 3[提交][状态][讨论版][命题人:qianyouyou] 题目描述教练爱打台球。这天偶遇一家台球厅，便进去看看。然而这家台球厅貌似和平常的台球厅不太一样，它的每张桌面上的洞都是随机分布在桌面上的，球也是随机摆放的。 教练立即意识到，此台球厅的桌面不符合正态分布之概率密度函数，而是呈离散分布，顿时患有强迫症的教练心里就不舒服了。为了平缓一下翻腾的内心，教练随机选取了一张球和洞数量一样的球桌，望着奇怪的桌面与奇怪的球，教练脑袋上不禁长出了大把大把的草：如果能求出所有球入洞的最短距离之和该有多好啊。 现有一个桌面面积为 n×m 的台球桌，将台球桌分成 n×m 个小格，台球桌上有许多的洞和许多的球，均匀分布在小格里，且每个小格只有三种状态，有球，有洞，空白。球用 @ 表示，洞用 # 表示，空白的地方用 * 表示。每个洞只能容纳一个球，球每次只能按照上下左右的方向移动，且每移动一格视为移动 1 个单位长度。当一个球被另一个球挡住时，它可以跳球，所以每一个球都可以完全无视其他球或洞的存在而继续前行，直到进自己心仪的洞。现求所有球进洞的距离之和最小是多少。如果你能帮教练解决这道题，恭喜你就是 ACM 队员了（每个球只能进一个洞，每个洞内有球的话就变成空白状态） 输入多组测试样例，首行输入 m，n，即矩形台球桌面的边长。(2 ≤ m，n ≤ 20，球最多100个，洞最多100个，保证洞和球数量相等) 输出输出一个整数，即所有球入洞的距离最短是多少。 样例输入12345678910112 2*#@*7 8****#*******#*******#***@@@@#@@@****#*******#*******#*** 样例输出12228 tag：图论、最小费用最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//网络流#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f; //无穷大const int maxn = 60007;const int maxm = 1000007;int vis[maxn],d[maxn],pre[maxn],a[maxn],m,n; //是否访问，最短路，前置节点，流量，边集，点集char mp[107][107]; //台球地图struct Edge&#123; int u, v, c, cost, next;&#125;edge[maxm]; //网络流边集int s[maxn], cnt; //每个点流量void init()&#123; //初始化 cnt = 0; memset(s, -1, sizeof(s));&#125;void add(int u, int v, int c, int cost)&#123; //对两点之间进行单向边建立 edge[cnt].u = u; edge[cnt].v = v; edge[cnt].cost = cost; edge[cnt].c = c; edge[cnt].next = s[u]; s[u] = cnt++; //建立单向边 edge[cnt].u = v; edge[cnt].v = u; edge[cnt].cost = -cost; edge[cnt].c = 0; edge[cnt].next = s[v]; s[v] = cnt++; //建立双向边&#125;bool spfa(int ss, int ee,int &amp;flow,int &amp;cost)&#123; //以距离为费用寻找最短路，以最短路为当前增广路 queue&lt;int&gt; q; memset(d, INF, sizeof d); memset(vis, 0, sizeof vis); //初始化 d[ss] = 0, vis[ss] = 1, pre[ss] = 0, a[ss] = INF; q.push(ss); while (!q.empty())&#123; //spfa以费用为距离寻找最短路 int u = q.front();q.pop(); vis[u] = 0; for (int i = s[u]; ~i; i = edge[i].next)&#123; //和当前点相连所有边松弛过程 int v = edge[i].v; if (edge[i].c&gt;0&amp;&amp; d[v]&gt;d[u] + edge[i].cost)&#123; //松弛过程 d[v] = d[u] + edge[i].cost; pre[v] = i; a[v] = min(a[u], edge[i].c); //取最小值 if (!vis[v])&#123; vis[v] = 1; q.push(v); //压入待松弛队列 &#125; &#125; &#125; &#125; if (d[ee] == INF) return 0; //判断是否有最短路，无说明最大流完成 flow += a[ee]; cost += d[ee]*a[ee]; int u = ee; while (u != ss)&#123; //求当前最短路下的流量和 edge[pre[u]].c -= a[ee]; edge[pre[u] ^ 1].c += a[ee]; u = edge[pre[u]].u; &#125; return 1;&#125;int MCMF(int ss, int ee)&#123; //最小费用最大流 int cost = 0, flow=0; //初始化 while (spfa(ss, ee, flow, cost)); //寻找增广路径，直到没有增广路径为止 return cost; //返回最大流费用&#125;struct point&#123; int x,y; //球坐标，洞坐标&#125;;void solve()&#123; point H[107],P[107]; //建立球集与洞集 int h=0,p=0; for(int i=0;i&lt;n;i++)&#123; //输入地图 scanf(&quot;%s&quot;,&amp;mp[i]); for(int j=0;j&lt;m;j++)&#123; if(mp[i][j]==&apos;#&apos;)&#123; //若为洞则坐标加入洞集 H[h].x=i; H[h].y=j; h++; &#125; else if(mp[i][j]==&apos;@&apos;)&#123; //若为球则坐标加入球集 P[p].x=i; P[p].y=j; p++; &#125; &#125; &#125; init(); //初始化 for(int i=0;i&lt;h;i++) for(int j=0;j&lt;p;j++)&#123; int c=fabs(H[i].x-P[j].x)+fabs(H[i].y-P[j].y); add(i+1,h+j+1,1,c); &#125; //建立球与洞之间的路径 for(int i=0;i&lt;h;i++) //建立超级源点 add(0,i+1,1,0); for(int i=0;i&lt;p;i++) //建立超级汇点 add(h+1+i,h+p+1,1,0); printf(&quot;%d\n&quot;,MCMF(0,h+p+1)); //最小费用最大流&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; if(!(m||n)) break; solve(); //解决方案 &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小费用最大流</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用容斥原理求解范围内互素数对数例题]]></title>
    <url>%2F2018%2F09%2F26%2F2018-09-26%2F</url>
    <content type="text"><![CDATA[GCDGiven 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs.Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.Yoiu can assume that a = c = 1 in all test cases. Input The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.Each case contains five integers: a, b, c, d, k, 0 &lt; a &lt;= b &lt;= 100,000, 0 &lt; c &lt;= d &lt;= 100,000, 0 &lt;= k &lt;= 100,000, as described above. Output For each test case, print the number of choices. Use the format in the example. Sample Input 12321 3 1 5 11 11014 1 14409 9 Sample Output 12Case 1: 9Case 2: 736427 Hint 1For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5). 题意： 求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数 题解： gcd(a,b)=k，我们可以写成gcd(a/k,b/k)=1。因此我们只需求[1,b/k]和[1,d/k]范围内互素数的对数。首先利用欧拉函数很容易求解[1,min(a,b)]范围内互素数的对数，将φ(1~min(a,b))全部加起来，就求出1~min(a,b)所有互素对数，假设d永远＞=b,那么接下来我们只需求[1,b]范围内和[b+1,d]范围内互素的数，此时需用容斥原理。对于[1,b]范围内和x互素的数，最多为b个，而在这b个数中我们只需减去不互素的对数即可。我们需先求出x的所有质因数，然后这些质因数的倍数在[1,b]范围内的个数为b/g，因此只需减去这些对数即可，然而由于会有重复的情况出现，因此需用容斥原理处理一下。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;typedef long long ll;ll oula[maxn];int a,b,c,d,k;struct Number&#123; int cnt; int prime[20];&#125; fac[maxn];void getLa( int n)&#123; memset(fac,0,sizeof(fac)); for(int i = 0; i &lt; n; ++i) oula[i] = i; for(int i = 2; i &lt; n; ++i) if( oula[i] == i ) for(int j = 1; j*i &lt; n; ++j)&#123; oula[j*i] -= oula[j*i]/i; fac[j*i].prime[fac[j*i].cnt++]=i; &#125;&#125;ll inc(int index,int b,int m)&#123; ll r=0,t; for(int i=index; i&lt;fac[m].cnt; ++i) &#123; t=b/fac[m].prime[i];//b范围内有多少个数和m的因数为prime[i] r+=t-inc(i+1,t,m);//减去这些数就是b范围内和m互质的数的个数。 &#125; return r;&#125;ll solve()&#123; b/=k; d/=k; if(b&gt;d) swap(b,d); ll ans = 0; for(int i = 1; i &lt;= b; ++i) ans+=oula[i]; for(int i=b+1; i&lt;=d; ++i) ans+=b-inc(0,b,i); return ans;&#125;int main()&#123; getLa(maxn); int t; scanf(&quot;%d&quot;,&amp;t); for(int cas = 1; cas&lt;=t; ++cas)&#123; scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0)&#123; printf(&quot;Case %d: 0\n&quot;,cas); continue; &#125; printf(&quot;Case %d: %lld\n&quot;,cas,solve()); &#125; return 0;&#125; 下面那道和上面这道类似，稍微改一下就好。 Visible TreesThere are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see.If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him. Input The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000) Output For each test case output one line represents the number of trees Farmer Sherlock can see. Sample Input 12321 12 3 Sample Output 1215 题意 求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数。当然和上面不同之处在于对数左右数不同也认为不同。(2,3)和(3,2)为不同的对数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;typedef long long ll;ll oula[maxn];int m,n;struct Number&#123; int cnt; int prime[20];&#125; fac[maxn];void getLa( int n)&#123; memset(fac,0,sizeof(fac)); for(int i = 0; i &lt; n; ++i) oula[i] = i; for(int i = 2; i &lt; n; ++i) if( oula[i] == i ) for(int j = 1; j*i &lt; n; ++j)&#123; oula[j*i] -= oula[j*i]/i; fac[j*i].prime[fac[j*i].cnt++]=i; &#125;&#125;ll inc(int index,int b,int m)&#123; ll r=0,t; for(int i=index; i&lt;fac[m].cnt; ++i) &#123; t=b/fac[m].prime[i]; r+=t-inc(i+1,t,m); &#125; return r;&#125;ll solve()&#123; if(m&gt;n) swap(m,n); ll ans = 0; for(int i = 1; i &lt;= m; ++i) ans+=oula[i]; ans=ans*2-1; for(int i=m+1; i&lt;=n; ++i) ans+=m-inc(0,m,i); return ans;&#125;int main()&#123; getLa(maxn); int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); printf(&quot;%lld\n&quot;,solve()); &#125; return 0;&#125; 跳蚤Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 Input 两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。 Output 可以完成任务的卡片数。 Sample Input 12 4 Sample Output 112 Hint 这12张卡片分别是：(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4),(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long long intusing namespace std;const int maxn = 1005,maxm = 100005,INF = 1000000000;LL N,M;int fac[maxn],faci = 0;void Sp()&#123; LL e = M; for (LL i = 2; i * i &lt;= e; i++)&#123; if (e % i == 0)&#123; fac[++faci] = i; while (e % i == 0) e /= i; &#125; &#125; if (e - 1) fac[++faci] = e;&#125;LL qpow(LL a,LL b)&#123; LL ans = 1; for (; b; b &gt;&gt;= 1, a *= a) if (b &amp; 1) ans *= a; return ans;&#125;LL cal(int s)&#123; LL mult = 1,pos = 1; for (int i = 1; s; i++,s &gt;&gt;= 1)&#123; if (s &amp; 1)&#123; mult *= fac[i]; pos *= -1; &#125; &#125; return qpow(M/mult,N) * pos;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
        <tag>gcd</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]容斥原理的三种运用方式]]></title>
    <url>%2F2018%2F09%2F25%2F2018-09-25-1%2F</url>
    <content type="text"><![CDATA[在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 集合相交通常情况为奇加偶减，即加上重叠为奇次的，减去重叠为偶次的。 容斥原理是属于一种模板题目，一般简单的都是之间打模板，稍难的题目运用到了数学分析和数论的其他知识。 容斥原理分为三种实现： 1.位运算与二进制枚举（容易理解） 2.队列数组（耗时最短） 3.递归（代码最短但不容易理解） http://blog.csdn.net/deepseazbw/article/details/76187211 HDU的一道题目用的三种方法实现，一般都是找出一个数字的素因子，然后用cnt（计算器）记录下来，然后分别三种方法实现. 实现容斥原理的时候 1.先计算出容斥部分，然后再用总数减去 http://blog.csdn.net/deepseazbw/article/details/76187211 2.在容斥部分的时候，就将总数带入进去 http://blog.csdn.net/deepseazbw/article/details/76660935 模板题目： HDU 4135 1695]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]求解逆元的3种方法]]></title>
    <url>%2F2018%2F09%2F25%2F2018-09-25%2F</url>
    <content type="text"><![CDATA[简述逆元逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。 比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p 观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。 注意在下面所有的算法中，最好先把除数取个模再运算。 方法一：扩展欧几里得算法原理a∗b≡1(modp)a∗b≡1(modp) a∗b+k∗p=1a∗b+k∗p=1 然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。 如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元 代码1234567891011121314151617LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 &#123; if(b==0) &#123; x=1,y=0; return a; &#125; LL ret=exgcd(b,a%b,y,x); y-=a/b*x; return ret;&#125;LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 &#123; LL x,y; LL d=exgcd(a,mod,x,y); return d==1?(x%mod+mod)%mod:-1;&#125;1234567891011121314151617 注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大. 性能分析: 时间复杂度:O(logn)（实际是斐波那契数列） 适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。 方法二:费马小定理/欧拉定理原理费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp) ap−2∗a≡1(modp)ap−2∗a≡1(modp) ap−2ap−2就是a在mod p意义下的逆元啦。 欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式) aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp) aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。 代码123456789101112131415LL qkpow(LL a,LL p,LL mod)&#123; LL t=1,tt=a%mod; while(p) &#123; if(p&amp;1)t=t*tt%mod; tt=tt*tt%mod; p&gt;&gt;=1; &#125; return t;&#125;LL getInv(LL a,LL mod)&#123; return qkpow(a,mod-2,mod);&#125;123456789101112131415 性能分析： O(logmod) 适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。 但是如果是合数，相信一般没人无聊到去算个欧拉函数。 方法三：递推求逆元原理p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值 p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i k∗i+r≡0(modp)k∗i+r≡0(modp) k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp) i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp) i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi] 嗯。。好难看的公式 说白了就是:inv[i]=-(mod/i)*inv[i%mod] 然后边界是inv[1]=1 这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法 代码线性求逆元1234567LL inv[mod+5];void getInv(LL mod)&#123; inv[1]=1; for(int i=2;i&lt;mod;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;&#125;1234567 注意： 调用前要先预处理 调用的时候要先对除数取mod 性能分析： 时间复杂度O(n) 适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。 递归求逆元12345LL inv(LL i)&#123; if(i==1)return 1; return (mod-mod/i)*inv(mod%i)%mod;&#125;12345 性能分析 时间复杂度:O(logmod) 好像找到了最简单的算法了！！ 适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
        <tag>exgcd</tag>
        <tag>费马小定理</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]生成函数小结]]></title>
    <url>%2F2018%2F09%2F24%2F2018-09-24%2F</url>
    <content type="text"><![CDATA[母函数母函数是用于解决组合问题计数的一种方法。 在了解它之前我们先看看熟悉的杨辉三角。 杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)n(1+x)n的展开式从低项到高项的各项系数，也可以表示为组合数的形式CinCni。如果将两者联系起来我们会发现，(1+x)(1+x)可以看成对于一件取舍，1=x01=x0就是不取，x就是取。这样在(1+x)n(1+x)n的展开式中xixi项的系数就是从n件物品选取i件的方案数。 定义给定数列a0,a1,a2…ana0,a1,a2…an，构造函数G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x),其中G(x)G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)f0(x),f1(x),f2(x)…fn(x)为标志函数。 母函数主要有两种形式：普通型母函数和指数型母函数。 普通型母函数先看一个例题：HDU 1085 普通型母函数的标志函数一般为x0，x1,x2…xnx0，x1,x2…xn 因为每个硬币有个数限制，但是也不难构造出 G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5)G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5) xixi 指数型母函数再看一个例题：HDU 1521 指数型母函数的标志函数一般为x00!,x11!,x22!…xnn!x00!,x11!,x22!…xnn!，对于xii!xii!表示在一个方案中某个元素出现了ii次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！i！。 对于这道题就不难构造出母函数为 G(x)=(1/ 0!+X / 1!+X2 / 2!+…+Xa1 / a1!)(1 / 0!+X / 1!+X2 / 2!+…+Xa2 / a2!)( / 0!+X / 1!+X2 / 2!+…+Xan / an!)]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM/ICPC北京网络赛D题 80 Days（非暴力0(n)解法）]]></title>
    <url>%2F2018%2F09%2F22%2F2018-09-22-1%2F</url>
    <content type="text"><![CDATA[描述80 Days is an interesting game based on Jules Verne’s science fiction “Around the World in Eighty Days”. In this game, you have to manage the limited money and time. Now we simplified the game as below: There are n cities on a circle around the world which are numbered from 1 to n by their order on the circle. When you reach the city i at the first time, you will get ai dollars (ai can even be negative), and if you want to go to the next city on the circle, you should pay bi dollars. At the beginning you have c dollars. The goal of this game is to choose a city as start point, then go along the circle and visit all the city once, and finally return to the start point. During the trip, the money you have must be no less than zero. Here comes a question: to complete the trip, which city will you choose to be the start city? If there are multiple answers, please output the one with the smallest number. 输入The first line of the input is an integer T (T ≤ 100), the number of test cases. For each test case, the first line contains two integers n and c (1 ≤ n ≤ 10^6, 0 ≤ c ≤ 10^9). The second line contains n integers a1, …, an (-10^9 ≤ ai ≤ 10^9), and the third line contains n integers b1, …, bn (0 ≤ bi ≤ 10^9). It’s guaranteed that the sum of n of all test cases is less than 106 输出For each test case, output the start city you should choose. 提示For test case 1, both city 2 and 3 could be chosen as start point, 2 has smaller number. But if you start at city 1, you can’t go anywhere. For test case 2, start from which city seems doesn’t matter, you just don’t have enough money to complete a trip. 利用前缀和与后缀和优化dp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst LL maxn = 1e6+7;LL a[maxn],b[maxn],cha[maxn],qian[maxn],qian2[maxn], hou[maxn], hou2[maxn];void init(LL n,LL c)&#123; hou[n+1] = qian[0] = 0; hou2[n] = hou[n] = cha[n]; qian2[1] = qian[1] = cha[1]; for(int i = 2;i&lt;=n;i++)&#123; qian[i] = cha[i]+qian[i-1]; qian2[i] = min(qian[i],qian2[i-1]); &#125; LL sum = 0; for(int i = n-1;i&gt;0;i--)&#123; hou[i] = cha[i]+hou[i+1]; hou2[i] = min(hou[i]-sum,cha[i]); if(hou2[i]&gt;=0)&#123; sum=hou[i]; hou2[i]=0; &#125; &#125;&#125;int fun(LL n,LL c)&#123; if(qian[n]+c&lt;0) return -1; for(int i = 1;i&lt;=n;i++)&#123; if(cha[i]+c&gt;=0&amp;&amp;cha[i]+c+hou2[i+1]&gt;=0)&#123; if(hou[i]+c+qian2[i-1]&gt;=0)&#123; return i; &#125; &#125; &#125; return -1;&#125;int main()&#123; int t; LL n,c; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;c); for(int i = 1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; for(int i = 1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;b[i]); cha[i] = a[i] - b[i]; &#125; init(n,c); int tmp = fun(n,c); printf(&quot;%d\n&quot;,tmp); &#125; return 0;&#125; 尺取法 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#define MAX 1000005 int p[MAX&lt;&lt;1],a[MAX],b[MAX]; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n; long long c; scanf(&quot;%d%lld&quot;,&amp;n,&amp;c); for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; for(int i = 1;i &lt;= n;i++) &#123; p[i] = p[i + n] = a[i] - b[i]; &#125; int l = 1,r = 1; while(l &lt;= n &amp;&amp; r - l + 1 &lt;= n) &#123; c = c + p[r]; r ++; while(c &lt; 0) &#123; c = c - p[l]; l ++; &#125; &#125; if(l &gt; n) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;,l); &#125;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>动态规划</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[组合数学]动态规划解决整数划分问题]]></title>
    <url>%2F2018%2F09%2F22%2F2018-09-22%2F</url>
    <content type="text"><![CDATA[整数划分问题是将一个正整数n拆成一组数连加并等于n的形式，且这组数中的最大加数不大于n。 如6的整数划分为： 6 6 5 5 + 1 4 4 + 2, 4 + 1 + 1 3 3 + 3, 3 + 2 + 1, 3 + 1 + 1 + 1 2 2 + 2 + 2, 2 + 2 + 1 + 1, 2 + 1 + 1 + 1 + 1 1 1 + 1 + 1 + 1 + 1 + 1 设n为要划分的正整数，m是划分中的最大加数(当m &gt; n时，最大加数为n)， 1 当n = 1或m = 1时，split的值为1，可根据上例看出，只有一个划分1 或 1 + 1 + 1 + 1 + 1 + 1 可用程序表示为if(n == 1 || m == 1) return 1; 2 下面看一看m 和 n的关系。它们有三种关系 (1) m &gt; n 在整数划分中实际上最大加数不能大于n，因此在这种情况可以等价为split(n, n); 可用程序表示为if(m &gt; n) return split(n, n); (2) m = n 这种情况可用递归表示为split(n, m - 1) + 1，从以上例子中可以看出，就是最大加 数为6和小于6的划分之和 用程序表示为if(m == n) return (split(n, m - 1) + 1); (3) m &lt; n 这是最一般的情况，在划分的大多数时都是这种情况。 从上例可以看出，设m = 4，那split(6, 4)的值是最大加数小于4划分数和整数2的划分数的和。 因此，split(n, m)可表示为split(n, m - 1) + split(n - m, m) hdu1028 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 121;int n, dp[maxn][maxn];void init()&#123; memset(dp,0,sizeof(dp)); dp[0][0] = dp[1][0] = 1; for(int i = 1;i&lt;maxn;i++) dp[i][1] = 1; for(int i = 2;i&lt;maxn;i++) for(int j = 1;j&lt;=i;j++) dp[i][j] = dp[i][j-1] + dp[i-j][min(i-j,j)];&#125;int main()&#123; init(); while(~scanf(&quot;%d&quot;,&amp;n))&#123; printf(&quot;%d\n&quot;,dp[n][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>动态规划</tag>
        <tag>划分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[容斥原理]Hard to prepare]]></title>
    <url>%2F2018%2F09%2F20%2F2018-09-20%2F</url>
    <content type="text"><![CDATA[After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enjoy the show, every audience has to wear a Nogaku mask, and seat around as a circle. There are N guests Reimu serves. Kokoro has 2^k2k masks numbered from 0,1,\cdots,0,1,⋯, 2^k - 12k−1, and every guest wears one of the masks. The masks have dark power of Dark Nogaku, and to prevent guests from being hurt by the power, two guests seating aside must ensure that if their masks are numbered ii and jj , then ii XNOR jj must be positive. (two guests can wear the same mask). XNOR means ~(ii^jj) and every number has kk bits. (11 XNOR 1 = 11=1, 00XNOR 0 = 10=1, 11 XNOR 0 = 00=0) You may have seen 《A Summer Day’s dream》, a doujin Animation of Touhou Project. Things go like the anime, Suika activated her ability, and the feast will loop for infinite times. This really troubles Reimu: to not make her customers feel bored, she must prepare enough numbers of different Nogaku scenes. Reimu find that each time the same guest will seat on the same seat, and She just have to prepare a new scene for a specific mask distribution. Two distribution plans are considered different, if any guest wears different masks. In order to save faiths for Shrine, Reimu have to calculate that to make guests not bored, how many different Nogaku scenes does Reimu and Kokoro have to prepare. Due to the number may be too large, Reimu only want to get the answer modules 1e9+71e9+7 . Reimu did never attend Terakoya, so she doesn’t know how to calculate in module. So Reimu wishes you to help her figure out the answer, and she promises that after you succeed she will give you a balloon as a gift. InputFirst line one number TT , the number of testcases; (T \le 20)(T≤20) . Next TT lines each contains two numbers, NNand k(0&lt;N, k \le 1e6)k(0&lt;N,k≤1e6) . OutputFor each testcase output one line with a single number of scenes Reimu and Kokoro have to prepare, the answer modules 1e9+71e9+7 . 样例输入复制12323 14 2 样例输出复制12284 题目来源ACM-ICPC 2018 徐州赛区网络预赛 题目描述 有n个位置围成一个圈，2^k个数，每个位置随便放置一个数，要求范围在1到2^k之间，然而每个数都有一个互斥的数，且互斥的两个数不会和其他的重复，要求相邻位置不能有互斥的数。 题解 首先用快速幂求出2^k然后赋给k，即k = 2^k。然后假设这n个数依次排开，那么每一个数不能是上一个元素的互斥数，那么第1个元素共k种，那么之后每一种为k-1种。即k*(k-1)^(n-1)，然而这样的话最后一个元素可以为第一个元素的互斥数，因此要减去相应的数，根据容斥原理最终列出实在为k*(k-1)^(n-1)-k*(k-1)^(n-2)+k*(k-1)^(n-3)-k*(k-1)^(n-4)……然而这样做会超时，因此我们可以合并，即加一次减一次合并到一起重新得到公式。 当然我们也可以换一种思考方式，很容易想到，第1个数有种选择，第2个数到第n-1个数都有种选择，第n个数有种选择。 所以答案就是 但是这样会出现漏算：在第1个数和第n-1个数相同的情况下，第n个数有种选择， 而并非种 然后仔细分析可以发现，漏算的情况你可以把第1个数和第n-1个数当成同一个数，这样序列长度就变成n-2了，问题规模变小 递归或递推即可 代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9+7;ll quick_pow(ll ans, ll res, ll n)&#123; while(n)&#123; if(n&amp;1) ans = ans * res % mod; res = res * res % mod; n&gt;&gt;=1; &#125; return ans;&#125;ll solve(ll n, ll k)&#123; ll ans = 0; ll i = (n&amp;1)+2; ll res = pow(k-1,i-2); for(;i&lt;=n;i+=2)&#123; ans = (ans + res) % mod; res = res * (k - 1) % mod * (k - 1) % mod; &#125; ans = ans * k % mod * (k - 2) % mod; ans = (ans + k) % mod; return ans;&#125;int main()&#123; ll t,n,k; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); k = quick_pow(1,2,k); printf(&quot;%lld\n&quot;,solve(n,k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 ACM-ICPC Asia Regional Contest Shanghai Site - Onsite Contest]]></title>
    <url>%2F2018%2F09%2F18%2F2018-09-18-2%2F</url>
    <content type="text"><![CDATA[F - Friendship of Frog NN frogs from different countries are standing in a line. Each country is represented by a lowercase letter. The distance between adjacent frogs (e.g. the 1st1stand the 2nd2nd frog, the N−1thN−1th and the NthNth frog, etc) are exactly 11. Two frogs are friends if they come from the same country.The closest friends are a pair of friends with the minimum distance. Help us find that distance. Input First line contains an integer TT, which indicates the number of test cases.Every test case only contains a string with length NN, and the ithith character of the string indicates the country of ithith frogs.⋅⋅ 1≤T≤501≤T≤50.⋅⋅ for 80% data, 1≤N≤1001≤N≤100.⋅⋅ for 100% data, 1≤N≤10001≤N≤1000.⋅⋅ the string only contains lowercase letters. Output For every test case, you should output “ Case #x: y“, where xx indicates the case number and counts from 11 and yy is the result. If there are no frogs in same country, output −1−1 instead. Sample Input 1232abcecbaabc Sample Output 12Case #1: 2Case #2: -1 题解 超级水题，一次性遍历，顺便设置一个字母表，记录上一个字母位置，初始值为0，每遇到一个字母，对该字母表进行更新。如果上一个该字母表不为0，则先用当前位置减去表中上一个位置，然后记录下最小值，然后再更新。最终如果最小值为初始值，则输出-1，否则输出该最小值。 代码 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxx = 1e9+7;char str[1007];int a[26];int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); for(int cc = 1;cc&lt;=t;cc++)&#123; scanf(&quot;%s&quot;,&amp;str); int minD = maxx; memset(a,0,sizeof(a)); int len = strlen(str); for(int i = 0;i&lt;len;i++)&#123; int num = str[i]-&apos;a&apos;; if(a[num]) minD = min(minD,i - a[num] + 1); a[num] = i + 1; &#125; if(minD == maxx) printf(&quot;Case #%d: -1\n&quot;,cc); else printf(&quot;Case #%d: %d\n&quot;,cc,minD); &#125; return 0;&#125; K - Kingdom of Black and WhiteIn the Kingdom of Black and White (KBW), there are two kinds of frogs: black frog and white frog.Now NN frogs are standing in a line, some of them are black, the others are white. The total strength of those frogs are calculated by dividing the line into minimum parts, each part should still be continuous, and can only contain one kind of frog. Then the strength is the sum of the squared length for each part.However, an old, evil witch comes, and tells the frogs that she will change the color of at most one frog and thus the strength of those frogs might change.The frogs wonder the maximum possible strength after the witch finishes her job. Input First line contains an integer TT, which indicates the number of test cases.Every test case only contains a string with length NN, including only 00(representinga black frog) and 11 (representing a white frog).⋅⋅ 1≤T≤501≤T≤50.⋅⋅ for 60% data, 1≤N≤10001≤N≤1000.⋅⋅ for 100% data, 1≤N≤1051≤N≤105.⋅⋅ the string only contains 0 and 1. Output For every test case, you should output “ Case #x: y“,where xx indicates the case number and counts from 11 and yy is the answer. Sample Input 12320000110101 Sample Output 12Case #1: 26Case #2: 10 题解 解法有点偏暴力，首先将01分成m个联通块，一次性遍历，将m个联通块的长度储存起来，算出总值ans。然后对这m个联通块分别判断加1情况下是否变大，当然该值的计算要先用ans减去该联通块以及相邻左边或右边联通块的值，然后再加上更新的值。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); for(int cas=1;cas&lt;=t;cas++) &#123; cin&gt;&gt;s; int flag = -1; vector&lt;long long&gt; Q; int len = 0; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]-&apos;0&apos;!=flag) &#123; Q.push_back(len); len = 1; flag = s[i]-&apos;0&apos;; &#125; else len++; &#125; Q.push_back(len); Q.push_back(0); long long res = 0; for(int i=1;i&lt;Q.size()-1;i++) res += Q[i]*Q[i]; long long ans = res; for(int i=1;i&lt;Q.size()-1;i++) &#123; long long tmp = 0; if(Q[i]==1) ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]-Q[i+1]*Q[i+1]+(Q[i-1]+Q[i+1]+1)*(Q[i-1]+Q[i+1]+1)); else &#123; ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]+(Q[i-1]+1)*(Q[i-1]+1)+(Q[i]-1)*(Q[i]-1)); ans = max(ans,res-Q[i+1]*Q[i+1]-Q[i]*Q[i]+(Q[i+1]+1)*(Q[i+1]+1)+(Q[i]-1)*(Q[i]-1)); &#125; &#125; printf(&quot;Case #%d: %lld\n&quot;,cas,ans); &#125;&#125; L - LCM Walk A frog has just learned some number theory, and can’t wait to show his ability to his girlfriend.Now the frog is sitting on a grid map of infinite rows and columns. Rows are numbered 1,2,⋯1,2,⋯ from the bottom, so are the columns. At first the frog is sitting at grid (sx,sy)(sx,sy), and begins his journey.To show his girlfriend his talents in math, he uses a special way of jump. If currently the frog is at the grid (x,y)(x,y), first of all, he will find the minimum zzthat can be divided by both xx and yy, and jump exactly zz steps to the up, or to the right. So the next possible grid will be (x+z,y)(x+z,y), or (x,y+z)(x,y+z).After a finite number of steps (perhaps zero), he finally finishes at grid (ex,ey)(ex,ey). However, he is too tired and he forgets the position of his starting grid!It will be too stupid to check each grid one by one, so please tell the frog the number of possible starting grids that can reach (ex,ey)(ex,ey)! Input First line contains an integer TT, which indicates the number of test cases.Every test case contains two integers exex and eyey, which is the destination grid.⋅⋅ 1≤T≤10001≤T≤1000.⋅⋅ 1≤ex,ey≤1091≤ex,ey≤109. Output For every test case, you should output “ Case #x: y“, where xx indicates the case number and counts from 11 and yy is the number of possible starting grids. Sample Input 123436 106 82 8 Sample Output 123Case #1: 1Case #2: 2Case #3: 3 题解 设当前位置为(x,y)，gcd(x,y) = g。则可设x = m1g，y=m2g，LCM（x,y） = m1m2g，则目标值为（m1g+m1m2g，m2g）或（m1g，m2g+m1m2g）。已知目标值，求x，y。我们设目标值为x2，y2，则可推出m1 = x2/(g+y2)或m2 = y2/(g+x2)。递归过程，直到m1或m2不为0则返回值，否则次数加1，再继续递归。 最终得到结果。 代码 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll gcd(ll a,ll b)&#123; return a%b==0?b:gcd(b,a%b);&#125;ll dfs(ll g,ll x,ll y)&#123; ll ans = 0; if(!(x%(g+y)))&#123; ans++; ll tmp = x*g/(g+y); ans+=dfs(gcd(max(tmp,y),min(tmp,y)),tmp,y); &#125; if(!(y%(g+x)))&#123; ans++; ll tmp = y*g/(g+x); ans+=dfs(gcd(max(tmp,x),min(tmp,x)),x,tmp); &#125; return ans;&#125;int main()&#123; ll t,x,y; scanf(&quot;%lld&quot;,&amp;t); for(ll c = 1;c&lt;=t;c++)&#123; scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); ll tmp = gcd(max(x,y),min(x,y)); ll ans = dfs(tmp,x,y); printf(&quot;Case #%lld: %lld\n&quot;,c,++ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI手拉手问题]]></title>
    <url>%2F2018%2F09%2F18%2F2018-09-18-1%2F</url>
    <content type="text"><![CDATA[问题描述：n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成环的个数的期望。PS：一个人的左手和右手也可以拉起来构成一个环。 例如：n为2时，期望为4/3，假设从第一个人的左手开始，他的左手和右手和第2个人的左手和右手拉起来的概率都为1/3，其中自己的左手和右手拉起来构成环数为2，其他为1，则期望为1/3*2+1/3*1+1/3*1 题解：1+1/3+1/5+……1/(2n-1) 如果直接看公式很容易理解，每多一个人，就多了两只手，假设除了这个人以外其他人的期望都算出来了，假设期望为F(n)，那么对于这个人来说无非两种情况，要么和自己拉，要么和别人拉，和自己拉的概率为1/(2n-1)，和别人拉的概率为(2n-2)/(2n-1)。和自己拉的话很好理解，在之前的期望上加1就好了，和别人拉的话就可以把这两个人绑定起来当成一个人就好了，期望就是之前的期望。所以用公式的话就是F(n+1)=F(n)*(2n-2)/(2n-1)+(F(n)+1)*1/(2n-1),化简就得F(n+1)=F(n)+1/(2n-1)，递归得F(n)=1+1/3+1/5+……1/(2n-1) 根据调和级数推到公式： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ld long doubleconst int maxn = 1e7+7;ld a[maxn];void init()&#123; a[0] = 0; a[1]=1; for(int i = 2;i&lt;maxn;i++)&#123; a[i]=a[i-1]+1.0/(2*i-1); &#125;&#125;int main()&#123; //freopen(&quot;head.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;head.out&quot;,&quot;w&quot;,stdout); long long tmp; init(); cin&gt;&gt;tmp; if(tmp*1.0&gt;=maxn) cout&lt;&lt;log(2*tmp-1) - log(((2*tmp-1)-1)/2)/ 2 + 0.57721566490153286060651209 / 2&lt;&lt;endl; else cout&lt;&lt;a[tmp]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找距离最小点对]]></title>
    <url>%2F2018%2F09%2F18%2F2018-09-18%2F</url>
    <content type="text"><![CDATA[在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一。下面我们着重考虑平面上的最接近点对问题。 ​ 最接近点对问题的提法是:给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。 ​ 严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。 参考解答 ​ 这个问题很容易理解，似乎也不难解决。我们只要将每一点与其他n-1个点的距离算出，找出达到最小距离的两个点即可。然而，这样做效率太低，需要O(n2)的计算时间。在问题的计算复杂性中我们可以看到，该问题的计算时间下界为Ω(nlogn)。这个下界引导我们去找问题的一个θ(nlogn)算法。 这个问题显然满足分治法的第一个和第二个适用条件，我们考虑将所给的平面上n个点的集合S分成2个子集S1和S2，每个子集中约有n/2个点，·然后在每个子集中递归地求其最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对，因为S1和S2的最接近点对未必就是S的最接近点对。如果组成S的最接近点对的2个点都在S1中或都在S2中，则问题很容易解决。但是，如果这2个点分别在S1和S2中，则对于S1中任一点p，S2中最多只有n/2个点与它构成最接近点对的候选者，仍需做n2/4次计算和比较才能确定S的最接近点对。因此，依此思路，合并步骤耗时为O(n2)。整个算法所需计算时间T(n)应满足: T(n)=2T(n/2)+O(n2) ​ 它的解为T(n)=O(n2)，即与合并步骤的耗时同阶，显示不出比用穷举的方法好。从解递归方程的套用公式法，我们看到问题出在合并步骤耗时太多。这启发我们把注意力放在合并步骤上。 ​ 为了使问题易于理解和分析，我们先来考虑一维的情形。此时S中的n个点退化为x轴上的n个实数x1,x2,..,xn。最接近点对即为这n个实数中相差最小的2个实数。我们显然可以先将x1,x2,..,xn排好序，然后，用一次线性扫描就可以找出最接近点对。这种方法主要计算时间花在排序上，因此如在排序算法中所证明的，耗时为O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对这种一维的简单情形，我们还是尝试用分治法来求解，并希望能推广到二维的情形。 ​ 假设我们用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}。这样一来，对于所有p∈S1和q∈S2有p ​ 递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设δ=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如图1所示。 图1 一维情形的分治法 我们注意到，如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;δ，则p3和q3两者与m的距离不超过δ，即|p3-m|&lt;δ，|q3-m|&lt;δ，也就是说，p3∈(m-δ,m]，q3∈(m,m+δ]。由于在S1中，每个长度为δ的半闭区间至多包含一个点（否则必有两点距离小于δ），并且m是S1和S2的分割点，因此(m-δ,m]中至多包含S中的一个点。同理，(m,m+δ]中也至多包含S中的一个点。由图1可以看出，如果(m-δ,m]中有S中的点，则此点就是S1中最大点。同理，如果(m,m+δ]中有S中的点，则此点就是S2中最小点。因此，我们用线性时间就能找到区间(m-δ,m]和(m,m+δ]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。也就是说，按这种分治策略，合并步可在O(n)时间内完成。这样是否就可以得到一个有效的算法了呢？还有一个问题需要认真考虑，即分割点m的选取，及S1和S2的划分。选取分割点m的一个基本要求是由此导出集合S的一个线性分割，即S=S1∪S2 ，S1∩S2=Φ，且S1{x|x≤m}；S2{x|x&gt;m}。容易看出，如果选取m=[max(S)+min(S)]/2，可以满足线性分割的要求。选取分割点后，再用O(n)时间即可将S划分成S1={x∈S|x≤m}和S2={x∈S|x&gt;m}。然而，这样选取分割点m，有可能造成划分出的子集S1和S2的不平衡。例如在最坏情况下，|S1|=1，|S2|=n-1，由此产生的分治法在最坏情况下所需的计算时间T(n)应满足递归方程: T(n)=T(n-1)+O(n) ​ 它的解是T(n)=O(n2)。这种效率降低的现象可以通过分治法中”平衡子问题”的方法加以解决。也就是说，我们可以通过适当选择分割点m，使S1和S2中有大致相等个数的点。自然地，我们会想到用S的n个点的坐标的中位数来作分割点。在选择算法中介绍的选取中位数的线性时间算法使我们可以在O(n)时间内确定一个平衡的分割点m。 ​ 至此，我们可以设计出一个求一维点集S中最接近点对的距离的算法CPAIR1如下。 function CPAIR1(S); begin if |S|=2 then δ=|x[2]-x[1]| // x[1..n]存放的是S中n个点的坐标 else if (|S|=1) then δ:=∞ else begin m:=S中各点的坐标值的中位数; 构造S1和S2,使S1={x∈S|x≤m}，S2={x∈S|x&gt;m}; δ1:=CPAIRI(S1); δ2:=CPAIRI(S2); p:=max(S1); q:=min(S2); δ:=min(δ1,δ2,q-p); end; return(δ); end; 由以上的分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程： ​ 解此递归方程可得T(n)=O(nlogn)。 ​ 这个算法看上去比用排序加扫描的算法复杂，然而这个算法可以向二维推广。 ​ 下面我们来考虑二维的情形。此时S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。 ​ 递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min(δ1,δ1)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈P1，q∈P2，如图2所示。 图2 距直线l的距离小于δ的所有点 在一维的情形，距分割点距离为δ的2个区间(m-δ,m](m,m+δ]中最多各有S中一个点。因而这2点成为唯一的末检查过的最接近点对候选者。二维的情形则要复杂些，此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，如图3所示。 图3 包含点q的δ×2δ的矩形R ​ 由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。如图4(a)所示。 图4 矩形R中点的稀疏性 ​ 若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个δ×2δ的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则 ​ 因此d(u,v)≤5δ/6&lt;δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。图4(b)是矩形R中含有S中的6个点的极端情形。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n2/4对候选者。这是否就意味着我们可以在O(n)时间内完成分治法的合并步骤呢？现在还不能作出这个结论，因为我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。 ​ 至此，我们可以给出用分治法求二维最接近点对的算法CPAIR2如下: function CPAIR2(S); begin if |S|=2 then δ:=S中这2点的距离 else if |S|=0 then δ:=∞ else begin \1. m:=S中各点x坐标值的中位数; 构造S1和S2，使S1={p∈S|px≤m}和S2={p∈S|px&gt;m} \2. δ1:=CPAIR2(S1);δ2:=CPAIR2(S2); \3. δm:=min(δ1,δ2); \4. 设P1是S1中距垂直分割线l的距离在δm之内的所有点组成的集合， P2是S2中距分割线l的距离在δm之内所有点组成的集合。将P1和P2中的点依其y坐标值从小到大排序，并设P1和P2是相应的已排好序的点列; 通过扫描P1以及对于P1中每个点检查P2中与其距离在δm之内的所有点(最多6个)可以完成合并。当P1中的扫描指针逐次向上移动 时，P2*中的扫描指针可在宽为2δm的一个区间内移动。设δl是按 这种扫描方式找到的点对间的最小距离; \6. δ=min(δm,δl); end; return(δ); end; 下面我们来分析一下算法CPAIR2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间，第3步和第6步用了常数时间，第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合我们的要求。因此，在这里我们要作一个技术上的处理。我们采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列为P。在执行分治法的第4步时，只要对P作一次线性扫描，即可抽取出我们所需要的排好序的点列P1和P2。然后，在第5步中再对P1*作一次线性扫描，即可求得δl。因此，第4步和第5步的两遍扫描合在一起只要用O(n)时间。这样一来，经过预排序处理后的算法CPAIR2所需的计算时间T(n)满足递归方程： ​ 显而易见T(n)=O(nlogn)，预排序所需的计算时间为O(n1ogn)。因此，整个算法所需的计算时间为O(nlogn)。在渐近的意义下，此算法已是最优的了。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重装系统后，如何快速搭建之前基于github的博客]]></title>
    <url>%2F2018%2F09%2F17%2F2018-09-17%2F</url>
    <content type="text"><![CDATA[声明：此文是针对于windows环境前提：我需要说几个条件; 1.当初搭建博客时的ssh没有删除，如果删除那就再重新配置一个，配置方法参照我上一篇博客； 2.当初搭建博客的仓库没有删除，如果删除，那就再重新搭一个吧，剩下的教程几乎没有关系了 3.如果，当时搭建博客时，如果按照我的教程，或者说按照网上大多数教程，有建了一个文件夹（例如：git pages或者hexo），这个文件夹在重装系统后还有保留下来，那最好不过。 先说第一种情况：如果那个文件夹在的情况下：不知道你们有没有按照其他的教程去配置静态页面，我按照那个方法有在github上新建了一个branch 那个gh-pages是我新建的branch，如果建了没关系 我们只需用点击master就好，回到原来的地方 然后再你原来的那个文件夹里打开git bash here 输入npm install hexo –save 然后可以试着输入hexo g 和hexo d 提示你需要重新配置邮箱和用户名，那么按照原来的邮箱和原来的用户名输入就好； 再次输入hexo g，如果有提示 就说明已经重新配置好了； 如果没有保留当初在桌面配置的文件夹首先先看看自己电脑上有没有ssh 在自己的一个盘里建一个文件夹，里面分别有三个文件夹（git，node，git pages） 分别在git和node里配置好git和node 然后再git pages里打开git bash here检查有没有ssh cd ~/. ssh 如果有 No such file or directory 说明是第一次使用，那么按照上一篇博客配置， 如果提示有，那么你可以先试试这个ssh能用不，先别急着删； 按照刚刚的步骤再输入 npm install hexo –save 然后按照刚刚的步骤再来一次； 如果最后hexo d后，文章没有推上去，那么就说明没有成功，需要重新配置ssh 先删除原来的sshssh-add -Drm -r ~/.ssh 最好查看一下上一篇博客里，Deployment的config.yml文件里面的deploy值有没有改好（参照上一篇） 配置好了之后再按照刚刚的步骤再来一次（记得配置邮箱和用户名） 如果git bash在这儿没有起作用的话， 那么win+r打开cmd，安装一个类似刚刚操作的扩展 输入 npm install hexo-deployer-git –save 然后再输入 hexo ghexo d 然后再进入自己的博客页面查看。]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论小问题]]></title>
    <url>%2F2018%2F09%2F16%2F2018-09-16%2F</url>
    <content type="text"><![CDATA[输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？ 答案：n = min( n*(n+1)/2&gt;=x+y ) 当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状的管子，往里面灌水，x代表一定容量的水，y代表一定容量的水，然后管子每升高1个高度就会多1个容量，最终刚好为n(n+1)/2或n(n+1)/2+1，n(n+1)/2即x+y=n(n+1)/2，否则为n*(n+1)/2+1。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质因数分解原创算法]]></title>
    <url>%2F2018%2F09%2F13%2F2018-09-13%2F</url>
    <content type="text"><![CDATA[由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。 12345678910111213void Prime()&#123; memset(tag,0,sizeof(tag)); int cnt=0; for(int i = 2; i&lt;N; i++)&#123; if(tag[i]) prime[cnt++]=i; for(int j=0;j&lt;cnt &amp;&amp; prime[j]*i&lt;N; j++)&#123; tag[i*prime[j]] = i; if(i % prime[j]==0) break; &#125; &#125;&#125; 打表时表中储存为该数最小质数，这样给一个数只需除以对应表中数，直到除到最后为1为止]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]路径规划总结之A*搜索]]></title>
    <url>%2F2018%2F09%2F10%2F2018-09-10%2F</url>
    <content type="text"><![CDATA[路径规划路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。机器人的路径规划应用场景极丰富，最常见如游戏中NPC及控制角色的位置移动，百度地图等导航问题，小到家庭扫地机器人、无人机大到各公司正争相开拓的无人驾驶汽车等。 目前路径规划算法分为： A*算法首先，我们来看看A*算法的定义：A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。 采用广度优先搜索策略，在搜索过程中使用启发函数，即有大致方向的向前进虽然目标有时候不是很明确。 在计算机科学中，A*算法作为Dijkstra算法的扩展，因其高效性而被广泛应用于寻路及图的遍历，如星际争霸等游戏中就大量使用。在理解算法前，我们需要知道几个概念： 搜索区域（The Search Area）：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。 开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。 父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针。 路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销。 启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和。 可能看定义不是很好理解，那么我们根据例子具体看看什么是A*算法吧。 详细讲解参考： 启发式算法 A*算法]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 2018 徐州赛区网络预赛]]></title>
    <url>%2F2018%2F09%2F09%2F2018-09-09%2F</url>
    <content type="text"><![CDATA[Characters with Hash问答 26.45% 1000ms 262144K Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”. It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. InputFirst line a integer TT , the number of test cases (T \le 10)(T≤10). For each test case: First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000). Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters. OutputA single number which gives the answer. 样例输入复制1234523 zoMl6 YYJSNPI 样例输出复制12610 题目来源ACM-ICPC 2018 徐州赛区网络预赛 代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;char str[1000007],ch[2];int main()&#123; int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%s%s&quot;,&amp;n,ch,str); int ans = 2*n; for(int i = 0; i&lt;n; i++)&#123; if(str[i]==ch[0]) ans-=2; else&#123; if(abs(str[i]-ch[0])&lt;10) ans-=1; break; &#125; &#125; if(ans==0) ans++; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC沈阳网络预赛K题-Supreme Number]]></title>
    <url>%2F2018%2F09%2F08%2F2018-09-08-1%2F</url>
    <content type="text"><![CDATA[Supreme Number问答 26.7% 1000ms 131072K A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers. Now lets define a number NN as the supreme number if and only if each number made up of an non-empty subsequence of all the numeric digits of NN must be either a prime number or 11. For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number. Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal supreme number that does not exceed NN? InputIn the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases. In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100). OutputFor each test case print &quot;Case #x: y&quot;, in which xx is the order number of the test case and yy is the answer. 样例输入复制12326100 样例输出复制12Case #1: 5Case #2: 73 题目来源ACM-ICPC 2018 沈阳赛区网络预赛 题解非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;int read()&#123; char ch=&apos; &apos;; int ans=0; while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;) ch=getchar(); while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;) &#123; if(ans&lt;100000) ans=ans*10+ch-&apos;0&apos;; ch=getchar(); &#125; return ans;&#125;int main()&#123; int t; cin&gt;&gt;t; for(int aaa=1;aaa&lt;=t;aaa++)&#123; int ans = read(); int i; for(i = 0;i&lt;19;i++)&#123; if(pri[i]&gt;ans)&#123; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl; break; &#125; &#125; if(i==19) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl; &#125; return 0;&#125; 打表代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;using namespace std;#define N 10000000int h=0;bool p[N];int prime[N];bool dfs(int x)&#123; if(p[x]==false) return false; int c = 1; while(c&lt;x)&#123; c*=10; if(p[x%c]==false) return false; if(c&gt;x) break; int tmp = x; while(tmp)&#123; if(p[tmp]==false) return false; if(p[tmp%c]==false) return false; tmp/=c; if(!tmp) break; if(dfs(tmp)==false) return false; &#125; &#125; return true;&#125;void db()&#123; memset(p,true,sizeof(p)); p[0] = false; for(int i=2;i&lt;N;i++) &#123; if(p[i]==false) continue; for(int j=2;i*j&lt;N;j++) &#123; p[i*j]=false; &#125; if(!dfs(i)) p[i] = false; if(p[i]==true) &#123; prime[h++]=i; &#125; &#125;&#125;int main()&#123; db(); int n; //打印前n个质数 for(int i=0;i&lt;=h;i++) cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;; return 0;&#125;//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC沈阳网络预赛D题-A*模板题]]></title>
    <url>%2F2018%2F09%2F08%2F2018-09-08%2F</url>
    <content type="text"><![CDATA[Made In Heaven问答 14.67% 1000ms 131072K One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry. JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time. InputThere are at most 5050 test cases. The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN. The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ). Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW. It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist. All the test cases are generated randomly. OutputOne line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output &quot;yareyaredawa&quot; (without quote), else output &quot;Whitesnake!&quot; (without quote). 样例输入复制12342 21 2 2 141 2 52 1 4 样例输出复制1yareyaredawa 题目来源ACM-ICPC 2018 沈阳赛区网络预赛 题意N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“Whitesnake!”，否则输出“yareyaredawa” 类似POJ2449 题解A*+SPFA A*算法：1234A*，启发式搜索，是一种较为有效的搜索方法。我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。 估价函数：12345678为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。估价函数需要满足： 设当前状态state到目标函数所需代价的估计值为f(state) 设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state) 对于任意的state，应该有f(state)&lt;=g(state)也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。 第K短路：12345678根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。实现过程：1.预处理f(x)，在反向图上以T为起点求到每个点的最短路2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路因为估价函数的作用，图中很多节点访问次数远小于K 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define ll long longconst ll maxn=100010;ll n,m,dis[maxn];ll tot,head1[maxn],head2[maxn];bool flag[maxn];struct edge&#123; ll to; ll w; ll next;&#125;e[maxn*2],e2[maxn*2];struct node&#123; ll f; ll g; ll from; bool operator &lt; (node a)const &#123; if(a.f==f) return g&gt;a.g; return f&gt;a.f; &#125;&#125;;void add_edge(ll u,ll v,ll w)&#123; tot++; e[tot].to=v; e[tot].w=w; e[tot].next=head1[u]; head1[u]=tot; e2[tot].to=u; e2[tot].w=w; e2[tot].next=head2[v]; head2[v]=tot;&#125;void prepare()&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn;tot=0; memset(head1,0,sizeof(head1)); memset(head2,0,sizeof(head2));&#125;void spfa(ll t)&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn; dis[t]=0; queue&lt;ll&gt; q; q.push(t); flag[t]=1; while(!q.empty()) &#123; ll v=q.front(); q.pop();flag[v]=0; for(ll i=head2[v];i;i=e2[i].next) if(dis[e2[i].to]&gt;dis[v]+e2[i].w) &#123; dis[e2[i].to]=dis[v]+e2[i].w; if(!flag[e2[i].to]) &#123; q.push(e2[i].to); flag[e2[i].to]=1; &#125; &#125; &#125;&#125;ll a_star(ll s,ll t,ll k)&#123; if(s==t) k++; if(dis[s]==maxn) return -1; priority_queue&lt;node&gt; q; ll cnt=0; node tmp,to; tmp.from=s; tmp.g=0; tmp.f=tmp.g+dis[tmp.from]; q.push(tmp); while(!q.empty()) &#123; tmp=q.top(); q.pop(); if(tmp.from==t) cnt++; if(cnt==k) return tmp.g; for(ll i=head1[tmp.from];i;i=e[i].next) &#123; to.from=e[i].to; to.g=tmp.g+e[i].w; to.f=to.g+dis[to.from]; q.push(to); &#125; &#125; return -1;&#125;int main()&#123; ll x,y,z,s,t,k; ll T; while(cin&gt;&gt;n&gt;&gt;m) &#123; cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T; prepare(); for(ll i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; add_edge(x,y,z); &#125; spfa(t); ll ans=a_star(s,t,k); if(ans&lt;=T&amp;&amp;ans!=-1) cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl; &#125; return 0;&#125; k短路模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const ll maxn=100010;ll n,m,dis[maxn];ll tot,head1[maxn],head2[maxn];bool flag[maxn];struct edge&#123; ll to; ll w; ll next;&#125;e[maxn*2],e2[maxn*2];struct node&#123; ll f; ll g; ll from; bool operator &lt; (node a)const &#123; if(a.f==f) return g&gt;a.g; return f&gt;a.f; &#125;&#125;;void add_edge(ll u,ll v,ll w)&#123; tot++; e[tot].to=v; e[tot].w=w; e[tot].next=head1[u]; head1[u]=tot; e2[tot].to=u; e2[tot].w=w; e2[tot].next=head2[v]; head2[v]=tot;&#125;void prepare()&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn;tot=0; memset(head1,0,sizeof(head1)); memset(head2,0,sizeof(head2));&#125;void spfa(ll t)&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn; dis[t]=0; queue&lt;ll&gt; q; q.push(t); flag[t]=1; while(!q.empty()) &#123; ll v=q.front(); q.pop();flag[v]=0; for(ll i=head2[v];i;i=e2[i].next) if(dis[e2[i].to]&gt;dis[v]+e2[i].w) &#123; dis[e2[i].to]=dis[v]+e2[i].w; if(!flag[e2[i].to]) &#123; q.push(e2[i].to); flag[e2[i].to]=1; &#125; &#125; &#125;&#125;ll a_star(ll s,ll t,ll k)&#123; if(s==t) k++; if(dis[s]==maxn) return -1; priority_queue&lt;node&gt; q; ll cnt=0; node tmp,to; tmp.from=s; tmp.g=0; tmp.f=tmp.g+dis[tmp.from]; q.push(tmp); while(!q.empty()) &#123; tmp=q.top(); q.pop(); if(tmp.from==t) cnt++; if(cnt==k) return tmp.g; for(ll i=head1[tmp.from];i;i=e[i].next) &#123; to.from=e[i].to; to.g=tmp.g+e[i].w; to.f=to.g+dis[to.from]; q.push(to); &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>最短路</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[最短路]SPFA的SLF与LLL优化]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05-2%2F</url>
    <content type="text"><![CDATA[SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。 SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;deque&gt;const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11 ; using namespace std ;//1061109567int n , m , head[maxn] , dis[maxn] , cnt , sum , tot ;bool mark[maxn] ; struct id&#123; int nxt ,to , val ;&#125; edge[M] ;deque &lt; int &gt; Q ;inline void Init ( )&#123; freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin ) ; freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;&#125;int read( )&#123; char ch = getchar( ) ; int k = 1 , ret = 0 ; while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125; while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ; return k * ret ;&#125;void add( int u , int v , int va )&#123; edge[++cnt].nxt = head[u] , edge[cnt].to = v ; edge[cnt].val = va , head[u] = cnt ;&#125;void input( )&#123; n = read() , m = read( ) ; int u ,v , c ; memset( head , -1 , sizeof(head)) ; for( int x = 1 ; x &lt;= m ; ++x ) &#123; u = read( ) , v = read( ) , c = read( ) ; add( u ,v , c ) ; &#125;&#125;void spfa( )&#123; memset( dis , 127/2 , sizeof(dis) ) ; dis[1] = 0 , mark[1] = true ; Q.push_back( 1 ) ; while( !Q.empty( ) ) &#123; int u = Q.front( ) ; Q.pop_front( ) ; mark[u] = false ; for( int i = head[u] ; ~i ; i = edge[i].nxt ) &#123; int v = edge[i].to ; if( dis[v] &gt; dis[u] + edge[i].val ) &#123; dis[v] = dis[u] + edge[i].val ; if( !mark[v] ) &#123; mark[v] = true ; if( Q.empty( ) || dis[v] &gt; dis[Q.front( )] ) Q.push_back( v ) ; else Q.push_front( v ) ; &#125; &#125; &#125; &#125; if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ; else printf( &quot;%d\n&quot; , dis[n] ) ;&#125;int main( )&#123;// Init( ) ; input( ) ; spfa( ) ;// fclose( stdin ) ;// fclose( stdout ) ; return 0 ;&#125; LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，每次出队时，若 d[i]&gt;平均值，把 i 移到队列末尾，如此反复，直到找到某一i使得dist(i)&lt;=x，则将i出队进行松弛操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;deque&gt;const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11 ; using namespace std ;//1061109567int n , m , head[maxn] , dis[maxn] , cnt , sum , tot ;bool mark[maxn] ; struct id&#123; int nxt ,to , val ;&#125; edge[M] ;deque &lt; int &gt; Q ;inline void Init ( )&#123; freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin ) ; freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;&#125;int read( )&#123; char ch = getchar( ) ; int k = 1 , ret = 0 ; while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125; while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ; return k * ret ;&#125;void add( int u , int v , int va )&#123; edge[++cnt].nxt = head[u] , edge[cnt].to = v ; edge[cnt].val = va , head[u] = cnt ;&#125;void input( )&#123; n = read() , m = read( ) ; int u ,v , c ; memset( head , -1 , sizeof(head)) ; for( int x = 1 ; x &lt;= m ; ++x ) &#123; u = read( ) , v = read( ) , c = read( ) ; add( u ,v , c ) ; &#125;&#125;void spfa( )&#123; memset( dis , 127/2 , sizeof(dis) ) ; dis[1] = 0 , mark[1] = true ; Q.push_back( 1 ) ; tot = 0 ; while( !Q.empty( ) ) &#123; int u = Q.front( ) ; Q.pop_front( ) ; if( dis[u] * tot &gt; sum ) &#123; Q.push_back( u ) ; continue; &#125; mark[u] = false ; tot-- ; sum -= dis[u] ; for( int i = head[u] ; ~i ; i = edge[i].nxt ) &#123; int v = edge[i].to ; if( dis[v] &gt; dis[u] + edge[i].val ) &#123; dis[v] = dis[u] + edge[i].val ; if( !mark[v] ) &#123; mark[v] = true ; if( Q.empty( ) || dis[v] * tot &gt; sum ) Q.push_back( v ) ; else Q.push_front( v ) ; tot++ ; sum += dis[v] ; &#125; &#125; &#125; &#125; if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ; else printf( &quot;%d\n&quot; , dis[n] ) ;&#125;int main( )&#123;// Init( ) ; input( ) ; spfa( ) ;// fclose( stdin ) ;// fclose( stdout ) ; return 0 ;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++] pair和make_pair]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05-1%2F</url>
    <content type="text"><![CDATA[偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：pair与make_pair std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair&lt;int,float&gt; 或者 std::pair&lt;double,double&gt;等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：template pair make_pair(T1 a, T2 b) { return pair(a, b); } 一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题： 例如有如下两个定义： std::pair&lt;int, float&gt;(1, 1.1); std::make_pair(1, 1.1);其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。这个问题在编程是需要引起注意。下面是一段pair与make_pair的例子程序： 123456789101112131415include &lt;iostream&gt;using namespace std;int main(int argc, char** argv)&#123; pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25); pair &lt;string,double&gt; product2; pair &lt;string,double&gt; product3; product2.first =&quot;lightbulbs&quot;; // type of first is string product2.second =0.99; // type of second is double product3 = make_pair (&quot;shoes&quot;,20.0); cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product1.first &lt;&lt;&quot; is $&quot;&lt;&lt; product1.second &lt;&lt;&quot;\n&quot;; cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product2.first &lt;&lt;&quot; is $&quot;&lt;&lt; product2.second &lt;&lt;&quot;\n&quot;; cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product3.first &lt;&lt;&quot; is $&quot;&lt;&lt; product3.second &lt;&lt;&quot;\n&quot;; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[单源最短路]两大优化算法争锋之SPFA与堆优化版Dijkstra]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05%2F</url>
    <content type="text"><![CDATA[单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。 这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 基础算法Dijkstra时间复杂度：O(V2+E) n-1次循环 –&gt;找到未标记的d最小的点 –&gt;标记，松弛它的边 123456789101112131415161718192021void dijkstra(int s)&#123; memset(vis, false, sizeof(vis)); vis[s] = true; for(int i = 1; i &lt;= n; i++) dis[i] = road[s][i]; for(int u = 1; u&lt;n; u++)&#123; int minD = inf,k = -1; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i]&amp;&amp;dis[i]&lt;minD)&#123; k = i; minD = dis[i]; &#125; &#125; vis[k] = true; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])&#123; dis[i]=dis[k]+road[k][i]; &#125; &#125; &#125;&#125; Bellman-Ford时间复杂度：O(VE) n-1次循环 –&gt;对所有边松弛 还能再松弛则有负环 12345678910int dis[10010];int u[10010],v[10010],w[10010];int n,m;void Bellman_ford(int a)&#123; memset(dis,inf,sizeof(dis));//赋初始值 dis[a]=0; for(int i=1;i&lt;=n-1;i++)//更新n-1次 for(int j=1;j&lt;=m;j++)//更新每一条边 dis[v[j]]=min(dis[v[j]],dis[u[j]]+w[j]);//判断是否更新 &#125; 两大基础算法对比 Dijkstra是每次确定了到一个点的最短距离，再用该点更新到其它点的距离。不能处理有负边的图。 Bellman-Ford是每次对所有边松弛。可以计算出有负边无负环的最短路，可以判断是否存在负环。 优化算法Dijkstra+heap优化时间复杂度：O((V+E)lgV) 用STL中的优先队列实现堆： while(优先队列非空) –&gt;队头出队，松弛它的边 –&gt;松弛了的&lt;新距离,点&gt;入队 12345678910111213141516typedef pair&lt;int,int&gt; PII;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;...while(!q.empty())&#123; // O(V) 加上count&lt;n可以优化一点点 int w=q.top().first, u=q.top().second; q.pop(); // O(lgV) if(b[u])continue; b[u]=true; //++count; for(int i=head[u];i;i=e[i].next)&#123; // Sum -&gt; O(E) int v=e[i].to; if(d[u]+e[i].w&lt;d[v])&#123; d[v]=d[u]+e[i].w; q.push(PII(d[v],v)); // O(lgV) &#125; &#125;&#125; SPFA时间复杂度：O(kE) or O(VE) while(队非空) –&gt;队头出队，松弛它的边 –&gt;松弛了且不在队内的点入队 1234567891011while(!q.empty())&#123; int u=q.front(); q.pop(); b[u]=false; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(d[u]+e[i].w&lt;d[v])&#123; d[v]=d[u]+e[i].w; if(!b[v])b[v]=true,q.push(v); &#125; &#125;&#125; 算法思路对比 Dijkstra+heap是用小根堆，每次取出d最小的点，来更新距离，那么这个点来说，最小距离就是当前的d。 SPFA是用双端队列，每次取出队头，来更新距离，它之后可能还会入队。它是一种动态逼近法，因为每次松弛距离都会减小，所以松弛一定会有结束的。如果一个点入队超过n次就是存在负环。 复杂度分析对比Dijkstra+heap 因为是堆，取队头需要O(lgV)。 松弛边时，因为点的d改变了，所以点v需要以新距离重新入堆，O(lgV)，总共O(ElgV)。 因此总的是O((V+E)lgV) SPFA 论文证明也不严格。复杂度不太好分析。 总的是O(kE)。k大概为2。 复杂度应该是 O(VE)。 适用场景如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。 另外，Dijkstra和Prim也很相似，它们的区别主要是d的含义，前者是到s的临时最短距离，后者是到树的临时最短距离，相同点是，每次找d最小的更新其它点的距离。 Dijkstra堆优化版代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxx = 0x3f3f3f3f3f3f3f3f;const int maxn = 1e5+7;int t,n,m,cnt;ll dis[maxn];bool vis[maxn];int head[maxn];struct EDGE&#123; int next; int to; ll w;&#125;edge[2*maxn];struct NODE&#123; int u; ll dis; NODE()&#123;&#125; NODE(int u,ll w):u(u),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const &#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn];void add(int u, int v, ll w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt; cnt++;&#125;void dijkstra(int s)&#123; memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis)); priority_queue&lt;NODE&gt;q; q.push(NODE(s,0)); while(!q.empty())&#123; int kk = q.top().u; ll minD = q.top().dis; q.pop(); if(vis[kk]) continue; vis[kk] = true; for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; if(!vis[edge[l].to]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123; dis[edge[l].to] = minD + edge[l].w; q.push(NODE(edge[l].to,dis[edge[l].to][j])); &#125; &#125; &#125;&#125;int main()&#123; ll u,v,w; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(head,-1,sizeof(head)); cnt = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 0;i &lt; m; i++)&#123; scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; dijkstra(1); if(dis[n]!=maxx) printf(&quot;%lld\n&quot;,dis[n]); else printf(&quot;0\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
        <tag>SPFA算法</tag>
        <tag>Bellman-Ford算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[分层最短路]Magical Girl Haze]]></title>
    <url>%2F2018%2F09%2F04%2F2018-09-04%2F</url>
    <content type="text"><![CDATA[问题描述一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。 思路去掉的k条路肯定全部在从1到n的某一条路径上，这样走这一条路径才有可能最短。我们可以对最短路分层，即分别求k为0，k为1，k为2……k为k的情况下最短路程。定义最短路时使用二维数组dis[n][k],n为结点数，k为分层数。设i为每次求得的最短路结点，kk为所在层，dis为最短路，原点到原点的距离为0，则： 最短路状态转移方程：dis[j][kk]=min(dis[i][kk]+road[i][j],dis[j][kk]) 分层状态转移方程：dis[j][kk+1]=min(dis[i][kk],dis[j][kk+1]) Magical Girl HazeThere are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance. InputThe first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases. For each test case, the first line has three integers N, MN,M and KK. Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv. It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN. OutputFor each test case, print the minimum distance. 样例输入复制1234567815 6 11 2 21 3 42 4 33 4 13 5 64 5 2 样例输出复制13 题目来源ACM-ICPC 2018 南京赛区网络预赛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxx = 0x3f3f3f3f3f3f3f3f;const int maxn = 1e5+7;int t,n,m,k,cnt;ll dis[maxn][12];bool vis[maxn][12];int head[maxn];struct EDGE&#123; int next; int to; ll w;&#125;edge[2*maxn];struct NODE&#123; int u, j; ll dis; NODE()&#123;&#125; NODE(int u,int j,ll w):u(u),j(j),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const &#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn];void add(int u, int v, ll w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt; cnt++;&#125;void dijkstra(int s)&#123; memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis)); priority_queue&lt;NODE&gt;q; q.push(NODE(s,0,0)); while(!q.empty())&#123; int kk = q.top().u; int j = q.top().j; ll minD = q.top().dis; q.pop(); if(vis[kk][j]) continue; vis[kk][j] = true; for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; if(j&lt;k&amp;&amp;!vis[edge[l].to][j+1]&amp;&amp;dis[edge[l].to][j+1] &gt; minD)&#123; dis[edge[l].to][j+1] = minD; q.push(NODE(edge[l].to,j+1,dis[edge[l].to][j+1])); &#125; if(!vis[edge[l].to][j]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to][j])&#123; dis[edge[l].to][j] = minD + edge[l].w; q.push(NODE(edge[l].to,j,dis[edge[l].to][j])); &#125; &#125; &#125;&#125;int main()&#123; ll u,v,w; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(head,-1,sizeof(head)); cnt = 0; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i = 0;i &lt; m; i++)&#123; scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; dijkstra(1); if(dis[n][k]!=maxx) printf(&quot;%lld\n&quot;,dis[n][k]); else printf(&quot;0\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>分层最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]辗转相除法求gcd的数学证明]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03-2%2F</url>
    <content type="text"><![CDATA[在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。 gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a,b)。这里就不证明了。 我们接着看gcd，如何高效求gcd呢？目前最快的方法算是欧几里得算法了。 欧几里得算法其实很简单，已知a，b，其中a&gt;b，求gcd(a,b)。 解：用b整除a，得到余数c，再用c整除b，得到余数d，再用d整除c，得到余数e……不断这样操作，最后直到没有余数为止。假设e再整除d，余数为0，则e为最大公因数。 列式子即为： a = x1 * b + r1; b = x2 * r1 + r2; r1 = x3 * r2 + r3; …… rn-1= xn+1 * rn + rn+1; rn = xn+2 * rn+1 + 0; 若设a为r-1，b为r0，则通项公式即为rn-1 / rn = xn+1 rn + rn+1，最后一项为rn / rn+1 = xn+2 rn+1。 很容易理解，若某一步余数为0，则上一步的余数即为最大公约数。很容易证明该循环一定会终止，因为最坏的情况下a和b的最大公因数是1，那么任何一个数都是1的倍数，所以任何数取余1都为0，所以循环必会结束。 该算法历经千年，直到现在依然为求解gcd最高效的算法，gcd(a,b)最坏的情况下运算次数最多才是b位数的7位，这里就不详细介绍了。 那么为什么最后的结果就是最大公因数呢，接下来我们来证明一下。 假设g为gcd(a,b)，即g为g，b的最大公因数，则带到上式记为rn = xn+2 * g，这个式子g必然为rn的因数。 那再带到上一个式子，rn-1 = xn+1 * rn + g，由于g既是rn的因数，又是g的因数，则g是rn-1的因数。 再带到上一个式子，rn-2 = xn * rn-1 + rn，由于g是rn-1，rn的因数，所以g必然是rn-2的因数。 …… 最终带到第一组式子中，即g既是a的因数，也是b的因数。 那如何证明它是最大公因数呢？ 我们假设h为a，b的任意因数，则h整除a，且h整除b，带到第一个式子，则h整除r1，再带到第2个式子，h整除r2，再带到第3个式子，h整除r3……直到倒数第二个式子，h整除rn+1，即h整除g由于最后一个式子余数为0，那么既然g为a，b的因数，h为g的因数，则h&lt;=g，故g为gcd(a,b)。 证毕。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An Olympian Math Problem]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03-1%2F</url>
    <content type="text"><![CDATA[问题描述： 求解(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1。 PS：n! = 1 * 2 * …… * n。 证明过程： Alice, a student of grade 66, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is: We denote k!k!: k! = 1 \times 2 \times \cdots \times (k - 1) \times kk!=1×2×⋯×(k−1)×k We denote SS: S = 1 \times 1! + 2 \times 2! + \cdots +S=1×1!+2×2!+⋯+(n - 1) \times (n-1)!(n−1)×(n−1)! Then SS module nn is ____ You are given an integer nn. You have to calculate SS modulo nn. InputThe first line contains an integer T(T \le 1000)T(T≤1000), denoting the number of test cases. For each test case, there is a line which has an integer nn. It is guaranteed that 2 \le n\le 10^{18}2≤n≤1018. OutputFor each test case, print an integer SS modulo nn. HintThe first test is: S = 1\times 1!= 1S=1×1!=1, and 11modulo 22 is 11. The second test is: S = 1\times 1!+2 \times 2!= 5S=1×1!+2×2!=5, and 55 modulo 33 is 22. 样例输入复制123223 样例输出复制1212 题目来源ACM-ICPC 2018 南京赛区网络预赛 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll t,n;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,n-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介于邻接矩阵与邻接表之间的存图方式————链式前向星]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03%2F</url>
    <content type="text"><![CDATA[链式前向星 图的存储一般有三种：邻接矩阵、邻接表、前向星。 若图是稀疏图，边很少，开二维数组很浪费; 若点很多(如10000个点)a[10000][10000]又会爆.只能用前向星做. 前向星的效率不是很高，优化后为链式前向星，直接介绍链式前向星。 （一）链式前向星1. 结构这里用两个东西： 1 结构体数组edge存边，edge[i]表示第i条边, 2 head[i]存以i为起点的第一条边(在edge中的下标) 123456struct EDGE&#123; int next; //下一条边的存储下标(默认0) int to; //这条边的终点 int w; //权值 &#125;; EDGE edge[500010]; 2.增边若以点i为起点的边新增了一条，在edge中的下标为j. 那么edge[j].next=head[i];然后head[i]=j. 即每次新加的边作为第一条边，最后倒序遍历 1234567void Add(int u, int v, int w) &#123; //起点u, 终点v, 权值w //cnt为边的计数，从1开始计 edge[++cnt].next = head[u]; edge[cnt].w = w; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 &#125; 3. 遍历遍历以st为起点的边 1for(int i=head[st]; i!=0; i=edge[i].next) i开始为第一条边，每次指向下一条(以0为结束标志) （若下标从0开始，next应初始化-1） 一个简单的输出有向图熟悉链式前向星： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#define MAXM 500010#define MAXN 10010struct EDGE&#123; int next; //下一条边的存储下标 int to; //这条边的终点 int w; //权值 &#125;; EDGE edge[MAXM];int n, m, cnt;int head[MAXN]; //head[i]表示以i为起点的第一条边 void Add(int u, int v, int w) &#123; //起点u, 终点v, 权值w edge[++cnt].next = head[u]; edge[cnt].w = w; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 &#125; void Print() &#123; int st; cout &lt;&lt; &quot;Begin with[Please Input]: \n&quot;; cin &gt;&gt; st; for(int i=head[st]; i!=0; i=edge[i].next) &#123;//i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 cout &lt;&lt; &quot;Start: &quot; &lt;&lt; st &lt;&lt; endl; cout &lt;&lt; &quot;End: &quot; &lt;&lt; edge[i].to &lt;&lt; endl; cout &lt;&lt; &quot;W: &quot; &lt;&lt; edge[i].w &lt;&lt; endl &lt;&lt; endl; &#125;&#125;int main() &#123; int s, t, w; cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=m; i++) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; w; Add(s, t, w); &#125; Print(); return 0;&#125; （二）链式前向星实现SPFA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define MAXM 500010#define MAXN 10010#define ANS_MAX 2147483647struct EDGE &#123; int next; int to; int w;&#125;;EDGE edge[MAXM];int n, m, st, cnt;int head[MAXN];int d[MAXN];bool inq[MAXN];inline int Read() &#123; char c; int ans = 0; bool Sign = false; while(!isdigit(c=getchar()) &amp;&amp; c != &apos;-&apos;); if(c == &apos;-&apos;) &#123; Sign = true; c = getchar(); &#125; do &#123; ans = (ans&lt;&lt;3) + (ans&lt;&lt;1) + (c ^ &apos;0&apos;); &#125; while(isdigit(c=getchar())); return Sign ? -ans : ans;&#125;void Add(int u, int v, int w) &#123; edge[++cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt;&#125;void read() &#123; int x, y, w; n = Read(); m = Read(); st = Read(); for(int i=1; i&lt;=m; i++) &#123; x = Read(); y = Read(); w = Read(); Add(x, y, w); &#125;&#125;void SPFA(int x) &#123; d[x] = 0; for(int i=1; i&lt;=n; i++) d[i] = ANS_MAX; queue&lt;int&gt; Q; Q.push(x); inq[x] = true; while(!Q.empty()) &#123; int k = Q.front(); Q.pop(); inq[k] = false; for(int i=head[k]; i!=0; i=edge[i].next) &#123; int j = edge[i].to; if(d[j] &gt; d[k] + edge[i].w) &#123; d[j] = d[k] + edge[i].w; if(!inq[j]) &#123; Q.push(j); inq[j] = true; &#125; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, d[i]); printf(&quot;\n&quot;);&#125;int main() &#123; read(); SPFA(st); return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>链式前向星</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018中国大学生程序设计竞赛 - 网络选拔赛 1001 Buy and Resell]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25-2%2F</url>
    <content type="text"><![CDATA[Buy and ResellTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:\1. spend ai dollars to buy a Power Cube\2. resell a Power Cube and get ai dollars if he has at least one Power Cube\3. do nothingObviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:The first line has an integer n. (1≤n≤105)The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)It is guaranteed that the sum of all n is no more than 5×105. Output For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1 Sample Output Hint profit = - 1 - 2 + 10 + 9 = 16 profit = - 5 + 10 = 5 profit = 0 题解： n天，每天商品有个价格，或买或卖或不买不卖。 贪心策略：分为两个堆（或优先队列），一个堆v为储存买的价格，一个堆s储存卖的价格。第i天的商品和之前买与卖两个堆中的最小值进行比较。共分为四种情况：1.如果第i天的价格比买的堆v里最小值大，且买的堆v里最小值比卖的堆s里最小值小，则买掉买的堆v里最小的，再卖出去，交易次数加2，即v.pop(),s.push(),cnt+2。2.如果第i天的价格比卖的堆s里最小值大，且买的堆v里最小值比卖的堆s里最小值大，则买掉卖的堆s里最小的，再卖出去，意思为现在卖比之前卖的那次更划算，我们把它买回来就等于之前那次没有卖，再卖出去等于现在才卖，即s.pop(),v.push(),s.push()。3.如果当天的价格即小于s中最小又小于v中最小，则把他放到买的堆v里，即v.push()。 这样下来，最后买的堆里剩下的就是没买没卖的。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; ll t; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; ll n, tmp, cnt = 0,sum = 0; scanf(&quot;%lld&quot;,&amp;n); priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;v,s; for(ll i = 0;i&lt;n;i++)&#123; scanf(&quot;%lld&quot;,&amp;tmp); if(!v.empty())&#123; if(!s.empty()&amp;&amp;tmp&gt;s.top()&amp;&amp;s.top()&lt;=v.top())&#123; sum+=tmp-(s.top()); v.push(s.top()); s.pop(); s.push(tmp); &#125; else if(tmp&gt;v.top()&amp;&amp;(s.empty()||s.top()&gt;v.top()))&#123; s.push(tmp); sum+=tmp-(v.top()); v.pop(); cnt++; &#125; else if(tmp&lt;=v.top())&#123; v.push(tmp); &#125; &#125; else&#123; if(!s.empty()&amp;&amp;tmp&gt;s.top())&#123; v.push(s.top()); sum+=tmp-s.top(); s.pop(); s.push(tmp); &#125; else v.push(tmp); &#125; &#125; printf(&quot;%lld %lld\n&quot;,sum,2*cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018中国大学生程序设计竞赛 - 网络选拔赛 1009 Tree and Permutation]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25-1%2F</url>
    <content type="text"><![CDATA[Tree and PermutationTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0 Problem Description There are N vertices connected by N?1 edges, each edge has its own length.The set { 1,2,3,…,N } contains a total of N! unique permutations, let’s say the i-th permutation is Pi and Pi,j is its j-th number.For the i-th permutation, it can be a traverse sequence of the tree with N vertices, which means we can go from the Pi,1-th vertex to the Pi,2-th vertex by the shortest path, then go to the Pi,3-th vertex ( also by the shortest path ) , and so on. Finally we’ll reach the Pi,N-th vertex, let’s define the total distance of this route as D(Pi) , so please calculate the sum of D(Pi) for all N! permutations. Input There are 10 test cases at most.The first line of each test case contains one integer N ( 1≤N≤105 ) .For the next N?1 lines, each line contains three integer X, Y and L, which means there is an edge between X-th vertex and Y-th of length L ( 1≤X,Y≤N,1≤L≤109 ) . Output For each test case, print the answer module 109+7 in one line. Sample Input 3 1 2 1 2 3 1 3 1 2 1 1 3 2 Sample Output 16 24 题意： 首先给出一个含有n个节点的树，边权为距离。 对于1-n的某一种排列p1,p2,p3……pn，贡献为dis(p1,p2)+dis(p2,p3)+dis(p3,p4)+……+dis(pn-1,pn) 求所有排列的贡献和 题解： 一棵树n个结点n-1条边，所以任意两点之间都有最短距离。由于所有遍历方式可以看做n个结点的排列，而每次有直接关系的只有两点之间的距离，因此只需求出两点之间的距离在所有排列中一共出现多少次即可。 比如n=2时，两个点1,2，共有两种排列方式，即1,2,和2,1 n=3时，三个点1,2,3,其中1,2共有4种方法得到，即1,2,3,和2,1,3,和3,1,2,和3,2,1 n=4时，三个点1,2,3,4,其中1,2共有12种方法得到，即1,2,3,4,和1,2,4,3,和2,1,3,4,和2,1,4,3,和3,1,2,4,和3,2,1,4和4,1,2,3,和4,2,1,3,和3,4,1,2,和4,3,1,2,和3,4,2,1,和4,3,2,1, n=jie[n-1]*（n-1）。 先用树状dp求出所有两两结点之间的距离之和，再乘以每条边在所有结点排列的n！方式中一共用到的次数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+7;const ll mod = 1e9+7;ll sum[maxn], n;ll dp[maxn];ll jie[maxn];ll jie2[maxn];struct Edge&#123; ll v, w;&#125;;vector&lt;Edge&gt; tree[maxn];void init()&#123; jie[2] = 2; for(ll i = 3;i&lt;maxn;i++)&#123; jie[i] = jie[i-1]*(i-1)%mod; &#125;&#125;void dfs(ll cur, ll father)&#123; sum[cur] = 1; for(ll i = 0; i &lt; tree[cur].size(); i++) &#123; ll son = tree[cur][i].v; ll len = tree[cur][i].w; if(father == son) continue; dfs(son, cur); sum[cur] += sum[son]%mod; sum[cur]%=mod; dp[cur] += (dp[son]%mod + (n-sum[son])%mod*sum[son]%mod * len%mod)%mod; dp[cur]%=mod; &#125;&#125;int main()&#123; init(); ll u, v, w; while(scanf(&quot;%lld&quot;, &amp;n)!=EOF) &#123; if(n&lt;=2)&#123; if(n==1)&#123; printf(&quot;0\n&quot;); continue; &#125; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w); printf(&quot;%lld\n&quot;, 2*w%mod); continue; &#125; for(ll i = 0; i &lt; n; i++) tree[i].clear(); memset(sum, 0, sizeof(sum)); memset(dp, 0, sizeof(dp)); for(ll i = 0; i &lt; n-1; i++) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w); u--,v--; Edge t1, t2; t1.v = v; t1.w = w; t2.v = u; t2.w = w; tree[u].push_back(t1); tree[v].push_back(t2); &#125; dfs(0, -1); printf(&quot;%lld\n&quot;, (dp[0]%mod)*jie[n]%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018中国大学生程序设计竞赛 - 网络选拔赛 1004 Find Integer]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25%2F</url>
    <content type="text"><![CDATA[Find IntegerTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description people in USSS love math very much, and there is a famous math problem .give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn. Input one line contains one integer T;(1≤T≤1000000)next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000) Output print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);else print two integers -1 -1 instead. Sample Input 1 2 3 Sample Output 4 5 题解：本题首先用到了费马大定理，即a^n+b^n≠c^n。(a,b,c∈Z，n&gt;2) 所以当n大于2或者n为0时直接输出-1,-1，当n=1时直接输出1,a+1。 当n=2时，输出勾股数。 首先a²+b²=c²，a²=c²-b²，a²=(c+b)(c-b)。 设x=c+b，y=c-b，则a²=xy。 c=(x+y)/2，b=(x-y)/2。 当然我的方法是通过打表求得勾股数，方法有点偏暴力，即枚举x，y，然后用公式看c，b是否在范围内且为整数，当然在枚举的时候少不了剪枝，不然肯定tle。 不过后来听说根据费马大定理奇偶数列法则可。直接推出式子。 打表代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct node&#123; ll b,c;&#125;aa[40007];void init()&#123; memset(aa,0,sizeof(aa)); for(ll i = 3;i&lt;=40000;i++)&#123; for(ll j = 1;j&lt;i;j++)&#123; if(i*i%j==0)&#123; ll x = j; ll y = i*i/j; if((x+y)%2==0)&#123; aa[i].c=(x+y)/2; aa[i].b=(y-x)/2; break; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; ll a,b,c,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a); if(n&gt;2||n==0)&#123; printf(&quot;-1 -1\n&quot;); continue; &#125; else if(n==1)&#123; printf(&quot;1 %lld\n&quot;,a+1); continue; &#125; else&#123; if(aa[a].b)&#123; printf(&quot;%lld %lld\n&quot;,aa[a].b,aa[a].c); &#125; else printf(&quot;-1 -1\n&quot;); &#125; &#125; return 0;&#125; 0(1)代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll a,b,c,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a); if(n&gt;2||n==0) &#123; printf(&quot;-1 -1\n&quot;); continue; &#125; else if(n==1) &#123; printf(&quot;1 %lld\n&quot;,a+1); continue; &#125; else &#123; if(a%2==1&amp;&amp;a&gt;1) &#123; ll cc=(a-1)/2; b=2*cc*(cc+1); c=2*cc*(cc+1)+1; printf(&quot;%lld %lld\n&quot;,b,c); &#125; else if(a%2==0&amp;&amp;a&gt;2) &#123; ll cc=a/2; b=cc*cc-1; c=cc*cc+1; printf(&quot;%lld %lld\n&quot;,b,c); &#125; else&#123; printf(&quot;-1 -1\n&quot;); &#125; &#125; &#125; return 0;&#125; 推导过程：a为任意情况 a² = c² - b² a² = (c+b)(c-b) a² = a² * 1 c + b = a² c - b = 1 c = (a² + 1) / 2 b = (a² - 1) / 2 a为偶数情况： if(a² % 2 == 0) a² = a²/2 * 2 c + b = a²/2 c - b = 2 c = a²/4 + 1 b =a²/4 - 1 证毕]]></content>
      <categories>
        <category>训练之路</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>数论</tag>
        <tag>CCPC</tag>
        <tag>费马大定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.23网络流专项训练题解]]></title>
    <url>%2F2018%2F08%2F23%2F2018-08-23%2F</url>
    <content type="text"><![CDATA[问题 A: 赛马时间限制: 1 Sec 内存限制: 128 MB提交: 32 解决: 5[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述古有田忌赛马戏齐王，今有悠悠赛马虐渣渣。悠悠和他的小老弟渣渣每人有n匹马，每匹马都有一个评分，分数越高速度越快。现在渣渣不甘于当小老弟，随着赛马曲的想起，渣渣决定挑战悠悠，规则同田忌赛马。每胜一局得1分，每负一局减一分，赵神做裁判，悠悠为了捍卫自己的王者地位，决定出老千，问了赵神关于渣渣的赛马顺序，请问悠悠最高能得多少分。 输入文件有多组测试样例，遇0为止。 首行一个整数n，n&lt;=1000; 第2行n个整数表示悠悠每匹马的分数。 第3行n个整数表示渣渣每匹马的分数。0&lt;=分数&lt;500; 输出输出悠悠最高分。 样例输入123456789103192 173 71195 177 74210 1010 102220 219222 2180 样例输出123100 提示水题，可以用网络流或者匹配，也可以用更简单的方法。 [提交][状态][Edit][TestData)] 题解本题贪心可解。贪心策略即田忌赛马的策略。第1步我们将我们最慢的马和对方最快的马进行比较，如果最慢的马比对方最慢的马快，那么我们就胜一局，然后返回第1步。反之我们进行第2步，继续拿我们最快的马和对方最快的马进行比较，如果获胜就胜一局，然后返回第1步。反之我们进行第3步，继续拿我们最慢的马和对方最快的马进行比较，这种情况下分为两种情况，一种是得分相等，另外一种是我方必败，必败得分减一，否则不变，然后我们再返回第1步。直到所有的马都结束为止，此时我们就得到了最高得分。 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int a[1007],b[1007];int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; while(cin&gt;&gt;n)&#123; if(n==0) break; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; sort(a,a+n); sort(b,b+n); int s=0; for(int i=0,j=0,k=n-1,l=n-1; i&lt;=k;)&#123; if(a[i]&gt;b[j]) s++,i++,j++; else if(a[k]&gt;b[l]) s++,k--,l--; else&#123; if(a[i]&lt;b[l]) s--; i++,l--; &#125; &#125; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; 问题 B: 海上钢琴师时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述宁愿一生孤独，不愿随波逐流。海上钢琴师毅然留在了船上，与大海为伴，此生再不上岸。 然而，他的音乐却已名扬四海。为了将他的钢琴声可以传播到陆地以便欣赏，人们决定在陆地与钢琴师所在的船之间的n-2座岛屿上建立声音保留设备。每当声音传到该设备处时，以该设备为起点可以将声音信号发送到其他与该设备有信号连接的设备那里。信号传播是单向的，且是有限的。当该设备将一部分信号传给其他设备时，该设备所拥有的总信号要减去相应传出去的信号，所保留的信号可以继续传给其他的设备。船上也有该设备，由于岛屿与船的位置不同，所以钢琴声传到设备的声音有限。设备与设备之间的传播分贝也有限。陆地的总接收设备与某些岛屿上的设备有信号连接，请问陆地最多能收到多少分贝的钢琴声。 输入第一行输入两个数m，n。m代表共有m对设备建立了单向连接。n代表包括船和陆地在内共有n个设备。编号1为船，编号n为陆地，其他为岛屿（n&lt;=100，m&lt;=1000） 接下来m行，每行三个数a，b，c，代表a-&gt;b，即a的信号可以传到b信号，最大可以通过该信号传送c分贝。c&lt;=2000 输出输出陆地上最大可以收到多少分贝声音。（海上钢琴声不超过10000分贝） 样例输入1234565 41 2 1001 3 502 3 23 4 602 4 99 样例输出1150 提示样例解释：（容量，流量） 方案1： 方案2： [提交][状态][Edit][TestData)] 题解网络流最大流模板题。题面转化过来就是一个网络流模型，船为s，陆地为t，设备之间的连接就是弧。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+7;const int inf=0x3f3f3f3f;int r[maxn][maxn]; //残留网络，初始化为原图bool visit[maxn];int pre[maxn];int m,n;bool bfs(int s,int t) //寻找一条从s到t的增广路，若找到返回true&#123; int p; queue&lt;int &gt; q; memset(pre,-1,sizeof(pre)); memset(visit,false,sizeof(visit)); pre[s]=s; visit[s]=true; q.push(s); while(!q.empty()) &#123; p=q.front(); q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(r[p][i]&gt;0&amp;&amp;!visit[i]) &#123; pre[i]=p; visit[i]=true; if(i==t) return true; q.push(i); &#125; &#125; &#125; return false;&#125;int EdmondsKarp(int s,int t)&#123; int flow=0,d,i; while(bfs(s,t)) &#123; d=inf; for(i=t;i!=s;i=pre[i]) d=d&lt;r[pre[i]][i]? d:r[pre[i]][i]; for(i=t;i!=s;i=pre[i]) &#123; r[pre[i]][i]-=d; r[i][pre[i]]+=d; &#125; flow+=d; &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;m&gt;&gt;n) &#123; int u,v,w; memset(r,0,sizeof(r)); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r[u][v]+=w; &#125; cout&lt;&lt;EdmondsKarp(1,n)&lt;&lt;endl; &#125; return 0;&#125; 问题 C: 进击的巨人时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述那一年，巨人发起了第一轮进击，s城破，埃尔文团长带领众居民计划逃往较安全的t城。从s城到t城之间共有m坐城市，某些城市之间构成单向通路。由s城到t城恰构成一个有向无环图。然而每条路上都有限定的最大人流量。埃尔文团长想知道每一次最多有多少居民能到达t城。 输入首行输入两个数n，m（n，m&lt;=100），n0为s城，nn为t城。s城到t城之间的城用n1——nn表示。m表示单项通道数。 接下来m行，每行三个数a，b，c，代表a到b的最大人流量是c。c&lt;1000。 输出输出最多有多少人到t 样例输入1234567891011121314156 140 2 50 1 101 2 60 3 53 1 21 5 35 2 35 4 33 5 33 4 43 6 52 6 64 6 102 4 4 样例输出118 [提交][状态][Edit][TestData)] 题解网络流最大流模板题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+7;const int inf=0x3f3f3f3f;int r[maxn][maxn]; //残留网络，初始化为原图bool visit[maxn];int pre[maxn];int m,n;bool bfs(int s,int t) //寻找一条从s到t的增广路，若找到返回true&#123; int p; queue&lt;int &gt; q; memset(pre,-1,sizeof(pre)); memset(visit,false,sizeof(visit)); pre[s]=s; visit[s]=true; q.push(s); while(!q.empty()) &#123; p=q.front(); q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(r[p][i]&gt;0&amp;&amp;!visit[i]) &#123; pre[i]=p; visit[i]=true; if(i==t) return true; q.push(i); &#125; &#125; &#125; return false;&#125;int EdmondsKarp(int s,int t)&#123; int flow=0,d,i; while(bfs(s,t)) &#123; d=inf; for(i=t;i!=s;i=pre[i]) d=d&lt;r[pre[i]][i]? d:r[pre[i]][i]; for(i=t;i!=s;i=pre[i]) &#123; r[pre[i]][i]-=d; r[i][pre[i]]+=d; &#125; flow+=d; &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m) &#123; int u,v,w; memset(r,0,sizeof(r)); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r[u][v]+=w; &#125; cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl; &#125; return 0;&#125; 问题 D: X档案时间限制: 1 Sec 内存限制: 128 MB提交: 5 解决: 3[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述据X档案记载，倘若外星文明即将攻击地球，会在战争之前发动病毒袭击，最合理的对象是鸟或狗，因为鸟在空中传播病毒的范围2较广，而狗相较于其他动物来说和人类接触最频繁。X城作为全球反外星文明的重要基地，对外星文明来说威胁最大而作为外星文明首先攻击的目标。因此，X长官下令捕杀了全城的鸟，而狗由于受到爱狗人士们的保护免于此劫。然而灾难还是降临了，外星文明悄无声息地将病毒注入到一些狗体内。据全球卫星显示，X城的地形是一个nm的矩阵，划分成了nm个11的小矩阵。矩阵的四周被城墙所围。而在某些单位11的小矩阵中有居民，或者有被感染的狗。我们已经知道了狗的全部坐标，为了安全起见，X长官启动了X计划，将这些狗在未发作之前用围栏隔离起来以防止狗攻击人类，每个1*1的小矩阵四周均可建立围栏。该计划收录到了X档案中。围栏使得狗和人类均无法通过。由于计划的机密性，长官不想动用太多的财力，现求最少需要多长围栏才能将所有狗隔离。 输入输入包含多组样例，读到文件结束。 第一行为n，m，代表n*m的矩阵。（0&lt;n，m&lt;=150） 接下来n行，每行m个由0，1，2组成的数。 0代表此处没有任何东西，1代表此处有人，2代表此处有被感染的狗。 输出输出格式为：Case i: k i为第i组样例，k为所需最短的围栏长度。 样例输入12345678910115 60 0 0 1 0 02 0 0 0 0 10 0 1 0 0 00 0 2 0 0 10 0 0 1 0 04 60 0 1 0 0 10 0 0 1 1 00 0 0 0 2 20 1 1 0 2 0 样例输出12Case 1: 6Case 2: 4 提示第1组样例解释： 第2组样例解释： [提交][状态][Edit][TestData)] 题解题目描述那么多，其实就是最小割问题。只不过我们要建立一个超级源点指向所有狼（羊），再建立一个超级汇点指向所有羊（狼）。羊和狼为结点，两个节点直接一条边，权值为1。最终求解最大流即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define maxn 100100#define inf 0x3f3f3f3fusing namespace std;int to[maxn],c[maxn],first[maxn],Next[maxn],N;int d[maxn];int Q[maxn],bot,top,tag[maxn],can[maxn];int s,t,n,m,tmp,ans,cas=0;int TAG=5201314;void _init()&#123; ans=s=0,t=n*m+1,N=-1; for (int i=s; i&lt;=t; i++) first[i]=-1;&#125;void edge(int U,int V,int W)&#123; N++; to[N]=V,c[N]=W; Next[N]=first[U],first[U]=N;&#125;void _input()&#123; int cur=0; for (int i=1; i&lt;=n; i++) for (int j=1; j&lt;=m; j++) &#123; scanf(&quot;%d&quot;,&amp;tmp); cur++; if (i&lt;n) edge(cur,cur+m,1),edge(cur+m,cur,1); if (j&lt;m) edge(cur,cur+1,1),edge(cur+1,cur,1); if (tmp==2) edge(s,cur,inf),edge(cur,s,inf); else if (tmp==1) edge(cur,t,inf),edge(t,cur,inf); &#125;&#125;bool bfs()&#123; TAG++; Q[bot=top=1]=t,d[t]=0,tag[t]=TAG; while (bot&lt;=top) &#123; int cur=Q[bot++]; for (int i=first[cur]; i!=-1; i=Next[i]) &#123; if (c[i^1]&lt;=0 || tag[to[i]]==TAG) continue; tag[to[i]]=TAG,d[to[i]]=d[cur]+1,Q[++top]=to[i]; if (to[i]==s) return true; &#125; &#125; return false;&#125;int dfs(int cur,int num)&#123; if (cur==t) return num; int tmp=num,k; for (int i=first[cur]; i!=-1; i=Next[i]) &#123; if (d[cur]!=d[to[i]]+1 || c[i]&lt;=0 || tag[to[i]]!=TAG || can[to[i]]==TAG) continue; k=dfs(to[i],min(num,c[i])); if (k) c[i]-=k,c[i^1]+=k,num-=k; if (num==0) break; &#125; if (num) can[cur]=TAG; return tmp-num;&#125;void dinic()&#123; while (bfs()) ans+=dfs(s,inf);&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; _init(); _input(); dinic(); printf(&quot;Case %d: %d\n&quot;,++cas,ans); &#125; return 0;&#125; 问题 E: 同桌的你时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述据yoyo统计，青春期的情侣80%都是曾经的同桌。因此，选择好的同桌对你日后的感情发展有很大的帮助。高一7班共有n个男生，m个女生，男生们听过分析后纷纷要求重新排座位，以期待和心仪的女生做同桌。每个男生都有自己的暗恋对象，0&lt;=暗恋对象的个数&lt;=m，也就是说某个男生最多暗恋全班女生，最少一个都不暗恋。汪老师知道这件事后很是重视，于是开始调座位，优先考虑男生和他的暗恋女生坐在一起。男生用a表示，女生用n表示。请问最多有多少男生能和自己心仪的对象坐在一起。 输入首行输入n，m，e（0&lt;n，m&lt;=1000，0&lt;=e&lt;=10000）n男m女e为所有男生暗恋女生的个数之和。 接下来e行，每行两个数i，j，代表ai男生暗恋bj女生。 输出一个整数，最优分配下最多有多少男生能和自己心仪的对象坐在一起。 样例输入1232 1 22 11 1 样例输出11 提示样例解释： 全班两个男生暗恋班里唯一一个女生，无论怎么分配只能凑成一对。 [提交][状态][Edit][TestData)] 题解二分图最大匹配问题。男生和女生构成二分图，每个男生和暗恋的女生之间建立一条边。由于不涉及到权值，因此可用匈牙利算法求解，当然也可用网络流求解。网络流的话就是在二分图的两部分分别建立超级源点s和超级汇点t，每条边的容量固定是1，然后此题就转化成了网络流问题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int cnt=2;int alist[6000001];struct data&#123; int v;int next;int value;&#125;edge[6000001];void add(int u,int v,int value)&#123; edge[cnt].v=v; edge[cnt].value=value; edge[cnt].next=alist[u]; alist[u]=cnt++; return ;&#125;int h[1000001];int q[1000001];bool bfs()&#123; int x,next; memset(h,-1,sizeof(h)); int head=0,tail=1; q[head]=1; h[1]=0; while(head&lt;tail) &#123; x=q[head++]; next=alist[x]; while(next) &#123; int v=edge[next].v; int value=edge[next].value; if(value&amp;&amp;h[v]&lt;0) &#123; q[tail++]=v; h[v]=h[x]+1; &#125; next=edge[next].next; &#125; &#125; if(h[n]==-1) return false; return true;&#125;int ans;int dfs(int x,int y)&#123; if(x==n) return y; int next=alist[x]; int w,used=0; while(next) &#123; int v=edge[next].v; int value=edge[next].value; if(value&amp;&amp;h[v]==h[x]+1) &#123; w=y-used; w=dfs(v,min(w,value)); edge[next].value-=w; edge[next^1].value+=w; used+=w; if(used==y) return y; &#125; next=edge[next].next; &#125; if(!used) h[x]=-1; return used;&#125;void dinic()&#123; while(bfs()) ans+=dfs(1,0x7fffffff);&#125;int n1,m1,e1;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;m1,&amp;e1); n=n1+m1+2; for(int i=1;i&lt;=n1;i++) &#123; add(1,i+1,1); add(i+1,1,1); &#125; for(int i=1;i&lt;=e1;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(u&lt;=n1&amp;&amp;v&lt;=m1) add(u+1,v+n1+1,1), add(v+n1+1,u+1,1); &#125; for(int i=1;i&lt;=m1;i++) &#123; add(i+n1+1,n,1); add(n,i+n1+1,1); &#125; dinic();//暴力跑最大流 printf(&quot;%d&quot;,ans); return 0;&#125; 问题 F: 奇迹暖暖时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述梅拉抢走了绫罗的设计图，暖暖决定帮绫罗抢过来。于是梅拉和暖暖开始了搭配比赛。梅拉和暖暖各有n套衣服。由于暖暖是天才服装搭配师，且自带主角光环，又怎会输呢，（废话，输了你怎么通关啊）只不过暖暖为了让梅拉输的心服口服，决定狠狠虐梅拉一把。针对梅拉的n套衣服，暖暖的每套衣服i得分都比梅拉的任意一套衣服j得分高出score(ij)，0&lt;=score(ij)&lt;100000。然而每比完一场，他们之后的比赛都不能再用这套的衣服了。所以对于n场比赛，求出暖暖最高能比梅拉高多少分？（至少为0） 输入首行输入n(n&lt;=300) 接下来n行，第i行表示暖暖的第i套衣服，每行n个数，第j个数表示暖暖第i套衣服比梅拉第j套衣服的分高多少分。 0&lt;=score(ij)&lt;100000 输出输出一个整数，即最高高出多少分 样例输入1232100 520 23 样例输出1123 [提交][状态][Edit][TestData)] 题解最大权二分图匹配。暖暖和梅拉构成二分图。每条边均有权值，最终求解二分匹配下的最大权值。二分图匹配除了网络流以外还有两道专门解二分图的算法，即匈牙利算法和KM算法。匈牙利算法一般解决二分图最大匹配问题，即边没有权值。而km算法一般解决有权值的二分图。本题为KM算法模板题。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int N=300+7;const int INF=0x3f3f3f3f;int n,nx,ny;int linker[N],lx[N],ly[N],slack[N];int visx[N],visy[N],w[N][N];int DFS(int x)&#123; visx[x]=1; for(int y=1;y&lt;=ny;y++)&#123; if(visy[y]) continue; int tmp=lx[x]+ly[y]-w[x][y]; if(tmp==0)&#123; visy[y]=1; if(linker[y]==-1 || DFS(linker[y]))&#123; linker[y]=x; return 1; &#125; &#125;else if(slack[y]&gt;tmp)&#123; slack[y]=tmp; &#125; &#125; return 0;&#125;int KM()&#123; int i,j; memset(linker,-1,sizeof(linker)); memset(ly,0,sizeof(ly)); for(i=1;i&lt;=nx;i++) //lx初始化为与它关联边中最大的 for(j=1,lx[i]=-INF;j&lt;=ny;j++) if(w[i][j]&gt;lx[i]) lx[i]=w[i][j]; for(int x=1;x&lt;=nx;x++)&#123; for(i=1;i&lt;=ny;i++) slack[i]=INF; while(1)&#123; memset(visx,0,sizeof(visx)); memset(visy,0,sizeof(visy)); if(DFS(x)) //若成功（找到了增广轨），则该点增广完成，进入下一个点的增广 break; //若失败（没有找到增广轨），则需要改变一些点的标号，使得图中可行边的数量增加。 //方法为：将所有在增广轨中（就是在增广过程中遍历到）的X方点的标号全部减去一个常数d， //所有在增广轨中的Y方点的标号全部加上一个常数d int d=INF; for(i=1;i&lt;=ny;i++) if(!visy[i] &amp;&amp; d&gt;slack[i]) d=slack[i]; for(i=1;i&lt;=nx;i++) if(visx[i]) lx[i]-=d; for(i=1;i&lt;=ny;i++) //修改顶标后，要把所有不在交错树中的Y顶点的slack值都减去d if(visy[i]) ly[i]+=d; else slack[i]-=d; &#125; &#125; int res=0; for(i=1;i&lt;=ny;i++) if(linker[i]!=-1) res+=w[linker[i]][i]; return res;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(~scanf(&quot;%d&quot;,&amp;n))&#123; nx=ny=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;w[i][j]); int ans=KM(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 问题 G: 巨人也疯狂时间限制: 1 Sec 内存限制: 128 MB提交: 2 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述人类发现巨人控制吃人的神经是由一些神经元和一些神经通道组成的，每个神经通道两端各有一个神经元，且这个通道是单向的。吃人信号从脑部神经元S发出到控制吃人的神经元T，S、T之间是一个有向无环图。人类想把某些神经通道切断达到S的信号无法传到T（由于神经元太小不容易砍掉，所以考虑神经元），每个神经通道由于位置不同也有砍断所需的力量。人类想知道如何花最小的力气而使S的信号传不到T。 输入首行输入两个数，n，m，（n，m&lt;1000）。n代表包括s，t在内共有n个节点，1为s，n为t。 接下来m行，每行3个数，a，b，c，表示a到b的神经通路需要花费c力气。 输出输出最小的力气。 样例输入1234567897 81 2 21 3 22 4 22 5 23 5 24 6 26 7 25 7 2 样例输出14 [提交][状态][Edit][TestData)] 题解网络流最小割模板题。根据最小割最大流定理，求最小割问题即求最大流问题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+7;const int inf=0x3f3f3f3f;int r[maxn][maxn]; //残留网络，初始化为原图bool visit[maxn];int pre[maxn];int m,n;bool bfs(int s,int t) //寻找一条从s到t的增广路，若找到返回true&#123; int p; queue&lt;int &gt; q; memset(pre,-1,sizeof(pre)); memset(visit,false,sizeof(visit)); pre[s]=s; visit[s]=true; q.push(s); while(!q.empty()) &#123; p=q.front(); q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(r[p][i]&gt;0&amp;&amp;!visit[i]) &#123; pre[i]=p; visit[i]=true; if(i==t) return true; q.push(i); &#125; &#125; &#125; return false;&#125;int EdmondsKarp(int s,int t)&#123; int flow=0,d,i; while(bfs(s,t)) &#123; d=inf; for(i=t;i!=s;i=pre[i]) d=d&lt;r[pre[i]][i]? d:r[pre[i]][i]; for(i=t;i!=s;i=pre[i]) &#123; r[pre[i]][i]-=d; r[i][pre[i]]+=d; &#125; flow+=d; &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m) &#123; int u,v,w; memset(r,0,sizeof(r)); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r[u][v]+=w; &#125; cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl; &#125; return 0;&#125; 问题 H: 过河拆桥时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述猴子是一种自私的动物。动物世界由河流分成了n个岛屿。这天，猴子在a1岛屿上望见an岛屿上有一片桃林。a1到an之间有n-2个岛屿，分别是a2——an-1。岛屿之间共有m坐桥，每座桥都有一定的距离。现在猴子通过这些桥从a1走到了an，然而由于猴子怕其他动物也过去享受那片桃林，于是每走一座桥都会拆一座桥。终于到了an，吃完桃子后，正直涨潮，于是他必须马上回到a1，由于之前走过的桥被拆了，所以只能寻找一条新的路回到a1。请问猴子从a1到an，再从an回到a1的最短路径是多少。 输入首行输入nm（n&lt;=1000m&lt;=10000） 接下来m行，每行三个数x，y，z，代表ax岛与ay岛之间有桥，距离是z。（z&lt;=35000） 输出输出一个整数，为最短距离。 样例输入1234564 52 3 12 4 21 2 13 4 11 3 2 样例输出16 [提交][状态][Edit][TestData)] 题解最小费用最大流问题。本题可以转化为从1到n找两条不重边的路，使得这两条路的距离之和加起来相对于其他方案来说最小。转化成功之后就是建模过程。首先以1为源点，n为汇点。边的长度就是每条边的费用，每条边的容量为1。由于我们要找两条路到达t，那么我们s点的流量就必须是2，这样流到t点的最大流最大为2，为1证明无解，为2即有解。然而由于源点流量一般无限大，那么我们只需再建立一个超级源点sss，和源点s相连，且容量为2，当然sss到s的费用为0。建完模之后我们就可以用最小费用最大流模板代码求解了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+7;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,cost ,rev;&#125;;int V;vector&lt;edge&gt;G[maxn];int dist[maxn];int prevv[maxn],preve[maxn];void add(int from,int to,int cap,int cost)&#123; edge e,w; e.to=to; e.cap=cap; e.cost=cost; e.rev=G[to].size(); G[from].push_back(e); w.to=from; w.cap=0; w.cost=-cost; w.rev=G[from].size()-1; G[to].push_back(w);&#125;int min_ans(int s,int t,int f)&#123; int res=0; while(f&gt;0) &#123; for(int i=0; i&lt;V; i++) &#123; dist[i]=inf; &#125; dist[s]=0; bool update=true; while(update) &#123; update=false; for(int v=0; v&lt;V; v++) &#123; if(dist[v]==inf) &#123; continue; &#125; for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;dist[e.to]&gt;dist[v]+e.cost) &#123; dist[e.to]=dist[v]+e.cost; prevv[e.to]=v; preve[e.to]=i; update=true; &#125; &#125; &#125; &#125; if(dist[t]==inf) return -1; int d=f; for(int v=t; v!=s; v=prevv[v]) &#123; d=min(d,G[prevv[v]][preve[v]].cap); &#125; f-=d; res+=d*dist[t]; for(int v=t; v!=s; v=prevv[v]) &#123; edge &amp;e =G[prevv[v]][preve[v]]; e.cap-=d; G[v][e.rev].cap+=d; &#125; &#125; return res;&#125;int N,M;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int a,b,c; while(cin&gt;&gt;N&gt;&gt;M) &#123; V=N; for(int i=0; i&lt;=N; i++) G[i].clear(); for(int i=0; i&lt;M; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a--; b--; add(a,b,1,c); add(b,a,1,c); &#125; printf(&quot;%d\n&quot;,min_ans(0,N-1,2)); &#125; return 0;&#125; 问题 I: 植物大战僵尸时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和Zombies（僵尸）是游戏的主角，其中Plants防守，而Zombies进攻。该款游戏包含多种不同的挑战系列，比如Protect Your Brain、Bowling等等。其中最为经典的，莫过于玩家通过控制Plants来防守Zombies的进攻，或者相反地由玩家通过控制Zombies对Plants发起进攻。 现在，我们将要考虑的问题是游戏中Zombies对Plants的进攻，请注意，本题中规则与实际游戏有所不同。游戏中有两种角色，Plants和Zombies，每个Plant有一个攻击位置集合，它可以对这些位置进行保护；而Zombie进攻植物的方式是走到植物所在的位置上并将其吃掉。 游戏的地图可以抽象为一个N行M列的矩阵，行从上到下用0到N–1编号，列从左到右用0到M–1编号；在地图的每个位置上都放有一个Plant，为简单起见，我们把位于第r行第c列的植物记为Pr c。 Plants分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个Plant，定义Score和Attack如下： Score[Pr c] Zombie击溃植物Pr c可获得的能源。若Score[Pr c]为非负整数，则表示击溃植物Pr c可获得能源Score[Pr c]，若为负数表示击溃Pr c需要付出能源 -Score[Pr c]。 Attack[Pr c] 植物Pr c能够对Zombie进行攻击的位置集合。 Zombies必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此Zombies的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻，Zombies必须首先攻击Pr M-1；若需要对Pr c（0≤c&lt;M-1）攻击，必须将PrM-1 Pr M-2 … Pr c+1先击溃，并移动到位置(r c)才可进行攻击。 在本题的设定中，Plants的攻击力是无穷大的，一旦Zombie进入某个Plant的攻击位置，该Zombie会被瞬间消灭，而该Zombie没有时间进行任何攻击操作。因此，即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。 Zombies的目标是对Plants的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套Zombies的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。 输入输入的第一行包含两个整数N M，分别表示地图的行数和列数。 接下来N×M行描述每个位置上植物的信息。第r×M + c + 1行按照如下格式给出植物Pr c的信息：第一个整数为Score[Pr c] 第二个整数为集合Attack[Pr c]中的位置个数w，接下来w个位置信息（r’ c’），表示Pr c可以攻击位置第r’ 行第c’ 列。 输出输出仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为0。 样例输入12345673 210 020 0-10 0-5 1 0 0100 1 2 1100 0 样例输出125 [提交][状态][Edit][TestData)] 题解最大权闭合图问题。最大权闭合图转化为最小割问题，再由最小割转化成最大流问题。课件上有详解。 （本题作为NOI的考试题，同时也是今天十道题中最难的一道题，是不是顿时感觉到了自己与高中生们的差距(ó﹏ò｡)ε=(´ο｀*)))唉） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define M 1000using namespace std;int now,tot,s,t,va[M],du[M],H[M],h[M],ok[M],d[M],v[M],cur[M];int n,m;queue&lt;int&gt; q;struct edge1&#123; int x,y,ne;&#125;e[500000];struct edge&#123; int from,to,cap,flow,ne;&#125;E[500000];int C(int x,int y)&#123; return (x-1)*m+y;&#125;void Add(int x,int y)&#123; e[++tot].y=y; e[tot].x=x; e[tot].ne=H[x]; H[x]=tot; du[y]++;&#125;void Addedge(int from,int to,int cap)&#123; E[++tot]=(edge)&#123;from,to,cap,0,h[from]&#125;; h[from]=tot; E[++tot]=(edge)&#123;to,from,0,0,h[to]&#125;; h[to]=tot;&#125;bool bfs()&#123; for (int i=s;i&lt;=t;i++) v[i]=0; v[s]=1; d[s]=0; q.push(s); while (!q.empty()) &#123; int x=q.front(); q.pop(); for (int i=h[x];i;i=E[i].ne) &#123; edge e=E[i]; if (!v[e.to]&amp;&amp;e.cap&gt;e.flow) &#123; v[e.to]=1; d[e.to]=d[x]+1; q.push(e.to); &#125; &#125; &#125; return v[t];&#125;int dfs(int x,int a)&#123; if (x==t||!a) return a; int flow=0; for (int &amp;i=cur[x];i;i=E[i].ne) &#123; edge &amp;e=E[i]; if (d[e.to]!=d[x]+1) continue; int f=dfs(e.to,min(a,e.cap-e.flow)); if (f) &#123; flow+=f; a-=f; e.flow+=f; E[i^1].flow-=f; if (!a) break; &#125; &#125; return flow;&#125;int dinic()&#123; int flow=0; while (bfs()) &#123; for (int i=s;i&lt;=t;i++) cur[i]=h[i]; flow+=dfs(s,inf); &#125; return flow;&#125;void Topsort()&#123; queue&lt;int&gt; q; for (int i=1;i&lt;=now;i++) if (!du[i]) ok[i]=1,q.push(i); while (!q.empty()) &#123; int x=q.front(); q.pop(); for (int i=H[x];i;i=e[i].ne) &#123; int y=e[i].y; du[y]--; if (!du[y]) &#123; ok[y]=1; q.push(y); &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) &#123; now++; int w; scanf(&quot;%d%d&quot;,&amp;va[now],&amp;w); for (int k=1;k&lt;=w;k++) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x++,y++; Add(now,C(x,y)); &#125; if (j!=m) Add(now+1,now); &#125; Topsort(); s=0,t=now+1; int ans=0; tot=1; for (int x=1;x&lt;=now;x++) if (ok[x]) &#123; if (va[x]&gt;0) ans+=va[x],Addedge(s,x,va[x]); else Addedge(x,t,-va[x]); for (int i=H[x];i;i=e[i].ne) &#123; int y=e[i].y; if (ok[y]) Addedge(y,x,inf); &#125; &#125; cout&lt;&lt;ans-dinic()&lt;&lt;endl; return 0;&#125; 问题 J: Pigs时间限制: 1 Sec 内存限制: 128 MB提交: 2 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述Mirko works on a pig farm that consists of M locked pig-houses and Mirko can’t unlock any pighouse because he doesn’t have the keys. Customers come to the farm one after another. Each of them has keys to some pig-houses and wants to buy a certain number of pigs.All data concerning customers planning to visit the farm on that particular day are available to Mirko early in the morning so that he can make a sales-plan in order to maximize the number of pigs sold.More precisely the procedure is as following: the customer arrives opens all pig-houses to which he has the key Mirko sells a certain number of pigs from all the unlocked pig-houses to him and if Mirko wants he can redistribute the remaining pigs across the unlocked pig-houses.An unlimited number of pigs can be placed in every pig-house.Write a program that will find the maximum number of pigs that he can sell on that day. 输入The first line of input contains two integers M and N 1 &lt;= M &lt;= 1000 1 &lt;= N &lt;= 100 number of pighouses and number of customers. Pig houses are numbered from 1 to M and customers are numbered from 1 to N.The next line contains M integeres for each pig-house initial number of pigs. The number of pigs in each pig-house is greater or equal to 0 and less or equal to 1000.The next N lines contains records about the customers in the following form ( record about the i-th customer is written in the (i+2)-th line):A K1 K2 … KA B It means that this customer has key to the pig-houses marked with the numbers K1 K2 … KA (sorted nondecreasingly ) and that he wants to buy B pigs. Numbers A and B can be equal to 0. 输出The first and only line of the output should contain the number of sold pigs. 样例输入123453 33 1 102 1 2 22 1 3 31 2 6 样例输出17 [提交][状态][Edit][TestData)] 题解课件上有建模讲解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int N=107,M=1007,INF=0x3f3f3f3f;inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-1; c=getchar();&#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;; c=getchar();&#125; return x*f;&#125;int m,n,s,t;int pig[M],now[M];struct edge&#123; int v,c,f,ne;&#125;e[N*M&lt;&lt;1];int cnt,h[N];inline void ins(int u,int v,int c)&#123; cnt++; e[cnt].v=v;e[cnt].c=c;e[cnt].f=0;e[cnt].ne=h[u];h[u]=cnt; cnt++; e[cnt].v=u;e[cnt].c=0;e[cnt].f=0;e[cnt].ne=h[v];h[v]=cnt;&#125;int q[N],head,tail,vis[N],d[N];bool bfs()&#123; memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); head=tail=1; d[s]=0;vis[s]=1; q[tail++]=s; while(head!=tail)&#123; int u=q[head++]; for(int i=h[u];i;i=e[i].ne)&#123; int v=e[i].v; if(!vis[v]&amp;&amp;e[i].c&gt;e[i].f)&#123; vis[v]=1; d[v]=d[u]+1; q[tail++]=v; if(v==t) return true; &#125; &#125; &#125; return false;&#125;int cur[N];int dfs(int u,int a)&#123; if(u==t||a==0) return a; int flow=0,f; for(int &amp;i=cur[u];i;i=e[i].ne)&#123; int v=e[i].v; if(d[v]==d[u]+1&amp;&amp;(f=dfs(v,min(a,e[i].c-e[i].f)))&gt;0)&#123; flow+=f; e[i].f+=f; e[((i-1)^1)+1].f-=f; a-=f; if(a==0) break; &#125; &#125; return flow;&#125;int dinic()&#123; int flow=0; while(bfs())&#123; for(int i=s;i&lt;=t;i++) cur[i]=h[i]; flow+=dfs(s,INF); &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); m=read(); n=read(); s=0; t=n+1; for(int i=1;i&lt;=m;i++) pig[i]=read(); for(int i=1;i&lt;=n;i++)&#123; int A=read(),B,x; while(A--)&#123; x=read(); if(!now[x]) ins(s,i,pig[x]),now[x]=i; else ins(now[x],i,INF),now[x]=i; &#125; B=read(); ins(i,t,B); &#125; printf(&quot;%d&quot;,dinic());&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>匹配</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的网络流]]></title>
    <url>%2F2018%2F08%2F22%2F2018-08-22%2F</url>
    <content type="text"><![CDATA[内容：网络流 网络流：2018-8-23 课件：by.浅悠悠 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>预流推进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论3(网络流 + 二分图 + 匹配)]]></title>
    <url>%2F2018%2F08%2F19%2F2018-08-19%2F</url>
    <content type="text"><![CDATA[网络流基础最大流问题的解决一般基于两种方法，即增广路算法与预流推进算法。 网络一个连通的赋权有向图D=（V、E、C），其中V是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。 流网络上的流就是由起点流向终点的可行流 正方向设P为容量网络中源点到汇点的一条链，由源点s到汇点t的方向就为正方向。 残量网络在一个图中，残留网络指在既有的容量和已具备的流量条件下，网络中仍然可以继续增大流量的边所组成的网络。 增广路经在残留网络中的一条从源点s流向汇点t的路径叫做一条增广路。 割图的割可以用来表示对图的一个划分，将原图 G=(V,E)的顶点集 V 分为 S、T 两部分，让源点 s 在 S 中，汇点 t 在 T 中，能够通过 S、T 间的最大净流量为割(S,T)的容量，最小割为图中具有最小容量的割。 最大流增广路算法利用不断寻找增广路并在其上对流量进行更新的方法寻找网络的最大流。 每次用BFS找一条最短的增广路径，然后沿着这条路径修改流量值（实际修改的是残量网络的边权）。当没有增广路时，算法停止，此时的流就是最大流。 最大流最小割定理：在网络的一个流量状态下，通过图的任意一个割的流量都与该流量相同，所以具有最小容量的割的的容量就是该图的流量的最大值即最大流。 最小费用最大流有上下界的最大流二分图网络流匹配]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>匹配</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
        <tag>KM算法</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们一起学过的线性代数]]></title>
    <url>%2F2018%2F08%2F17%2F2018-08-17%2F</url>
    <content type="text"></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵论</tag>
        <tag>快速幂</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学1（排列组合 + 鸽巢原理 + 容斥原理）]]></title>
    <url>%2F2018%2F08%2F16%2F2018-08-16%2F</url>
    <content type="text"><![CDATA[排列组合加法/乘法法则加法法则相互独立的事件 A、B 分别有 k 和 l 种方法产生，则产生 A 或 B 的方法数为 k+l 种。 集合论定义若|A|=k，|B|=l ，且A∩B=Φ ，则|A∪B| = k+l 。 S = S1 ∪ S2 ∪ · · · ∪ Sm, Si ∩ Sj = ∅ (i ≠ j) ⇒ |S| = |S1| + |S2| + · · · + |Sm|。 例1a食堂有3种汉堡，b食堂有4种小吃，c食堂有2种包子，你的早餐只想吃一种，共有多少种选择方法？ 解： 设S是所有食物的集合，Si是第i类食物的集合(i=1,2,3)，显然，Si∩Sj=Φ (i≠j) ，根据加法法则有： |S| = |S1| + |S2| + |S3| = 3 + 4 + 2 = 9。 例2大于0小于10的奇偶数有多少个？ 解： 设S是符合条件数的集合，S1、S2分别是符合条件的奇数、偶数集合，显然，S1∩S2=Φ ，根据加法法则有： |S| = |S1| + |S2| = 5 + 4 = 9。 乘法法则相互独立的事件 A、B 分别有 k 和 l 种方法产生，则选取A以后再选取B 的方法数为 k×l 种。 集合论定义若|A|=k，|B|=l ，A×B={(a,b)|a∈A，b∈B}，则|A×B| = k×l 。 S = P × Q ⇒ |S| = |P | × |Q|。 例从A 地到B地有二条不同的道路，从B地到C地有四条不同的道路，而从C地到D地有三条不同的道路。求从A地经B、C两地到达D地的道路数。 解： 设S是所求的道路数集合，S1、S2、S3分别是从A到B、从B到C、从C到D的道路集合，根据乘法法则有 |S| = |S1 | × |S2| × |S3| = 2 × 4 × 3 = 24。 计数问题的分类有序安排或有序选择 ​ ——允许重复/不允许重复 无序安排或无序选择 ​ ——允许重复/不允许重复 重集的概念标准集的特性：确定、无序、相异等。 重集：B={k1 b1, k2 b2, …, kn * bn}，其中：bi为n个互不相同的元素，称 ki为bi的重数， i = 1, 2, …, n，n=1,2,…, ∞，ki = 1, 2, …, ∞。 排列线排列从n个不同元素中，取r个(0≤r≤n)按一定顺序排列起来，其排列数P(n,r)。 集合论定义设A={an} ，从A中选择r个(0≤r≤n)元素排列起来，A的r−有序子集，A的r−排列。 定理若n, r∈Z且n≥r≥0, P(n,r)=n!/(n-r)!。 若n=r，称全排列P(n,n)= n!； 若n＜r, P(n,r)=0； 若r=0, P(n,r)=1。 证明构造集合A的r−排列时，可以从A的n各元素中任选一个作为排列的第一项，有n种选法；第一项选定后从剩下的n-1个元素中选排列的第二项有n-1种选法；…由此类推，第r项有n-r+1种选法。根据乘法原理有： P(n,r) = n(n-1)……(n-r+1) = n!/(n-r)! 。 推论1若n, r∈N且n≥r≥2，则P(n,r)=n×P(n-1,r-1) 。 证明在集合A的n个元素中，任一个元素都可以排在它的r−排列首位，故首位有n种取法；首位取定后，其他位置的元素正好是从A的另n-1个元素中取r-1个的排列，因此有P(n-1,r-1)种取法。由乘法法则有： P(n,r)=n×P(n-1,r-1) 推论2若n, r∈N且n≥r≥2，则P(n,r)= r×P(n-1,r-1)+P(n-1,r) 。 证明当r≥2时，把集合A的r−排列分为两大类：一类包含A中的某个固定元素，不妨设为a1，另一类不包含a1 。第一类排列相当于先从A-{a1}中取r-1个元素进行排列，有P(n-1,r-1)种取法，再将a1放入每一个上述排列中，对任一排列，a1都有r种放法。由乘法法则，第一类排列共有r×P(n-1,r-1)个。第二类排列实质上是A-{a1}的r−排列，共有P(n-1,r)个。再由加法法则有： P(n,r)= r×P(n-1,r-1)+P(n-1,r) 例1由数字1,2,3,4,5可以构成多少个所有数字互不相同的四位数？ 解： 由于所有的四位数字互不相同，故每一个四位数就是集合{1,2,3,4,5}的一个4−排列，因而所求的四位数个数为 P(5,4)=5!/(5-4)!=120。 例2将具有9个字母的单词FRAGMENTS进行排列，要求字母A总是紧跟在字母R的右边，问有多少种这样的排法？如果再要求字母M和N必须相邻呢？ 解： 由于A总是R的右边，故这样的排列相当于是8个元素的集合{F,RA,G,M,E,N,T,S}的一个全排列，个数为 P(8,8) = 8! = 40320。 如果再要求M和N必须相邻，可先把M和N看成一个整体={M,N}，进行7个元素的集合{F,RA,G,E,T,S,}的全排列，在每一个排列中再进行 {M,N}的全排列，由乘法法则，排列个数为 P(7,7) P(2,2) = 7! 2! = 10080。 例3有多少个5位数，每位数字都不相同，不能取0，且数字7和9不能相邻？ 解： 由于所有的5位数字互不相同，且不能取0，故每一个5位数就是集合{1,2,…,9}的一个5-排列，其排列数为P(9,5)，其中7和9相邻的排列数为[c(7,3)4!2]4×2×P(7,3)，满足题目要求的5位数个数为 P(9,5) - 4 2 P(7,3) = 15120 -1680 = 13440 圆排列设A={an} ，从A中取r个(0≤r≤n)元素按某种顺序（如逆时针）排成一个圆圈，称为圆排列（循环排列）。 定理设A={an}，A的r圆排列个数为P(n,r)/r。 证明由于把一个圆排列旋转所得到另一个圆排列视为相同的圆排列，因此线排列a1a2…ar，a2a3…ara1，… ara1a2…ar-1在圆排列中是一个，即一个圆排列可产生r个不同的线排列；同理， r个不同的线排列对应一个圆排列。而总共有P(n,r)个线排列，故圆排列的个数为 ​ P(n,r)/r= n!/(r×(n-r)!) 例1有8人围圆桌就餐，问有多少种就座方式？如果有两人不愿坐在一起，又有多少种就座方式？ 解： 由上述定理知8人围圆桌就餐，有8!/8=7!=5040种就座方式。 又有两人不愿坐在一起，不妨设此二人为A、B，当A、B坐在一起时，相当于7人围圆桌就餐，有7!/7=6!种就座方式。 而A、B坐在一起时，又有两种情况，或者A在B的左面，或者A在B的右面，因此A、B坐在一起时，共有2×6!种就座方式，因此如果有两人不愿坐在一起，就座方式为 7!-2×6!= 5×6!=3600 例24男4女围圆桌交替就座有多少种就座方式？ 解： 显然，这是一个圆排列问题。首先让4个男的围圆桌就座，有4!/4=3!种就座方式。 因为要求男女围圆桌交替就座，在男的坐定后，两两之间均需留有一个空位，女的就座相当于一个4元素集合的全排列，就座方式数为4!。由乘法法则知，就座方式数为 3!×4!=144 重排列从n个不同元素中，可重复选取r个按一定顺序排列起来，称为重排列。 集合论定义从重集B={k1 b1, k2 b2, … , kn * bn}中选取r个按一定顺序排列起来。 定理1重集B={∞ b1, ∞ b2, … , ∞ * bn} 的r−排列的个数为nr。 证明：构造B的r−排列如下：选择第一项时可从n个元素中任选一个，有n种选法，选择第二项时由于可以重复选取，仍有n种选法，…，同理，选择第r项时仍有n种选法，根据乘法法则，可得出r−排列的个数为nr。 例1由数字1,2,3,4,5,6这六个数字能组成多少个五位数？又可组成多少大于34500的五位数？ 解： 一个五位数的各位数字可重复出现，是一个典型的重排列问题，相当于重集B={∞ 1,∞ 2,…,∞*6}的5−排列，所求的五位数个数为6^5=7776。 大于34500的五位数可由下面三种情况组成： 万位选4,5,6中的一个，其余4位相当于重集B的4−排列，由乘法法则知，共有3×6^4个五位数； 万位是3，千位5,6中的一个，其余3位相当于重集B的3−排列，由乘法法则知，共有2×6^3个五位数； 万位是3，千位4中的一个，百位选5,6中的一个，其余2位相当于重集B的2−排列，由乘法法则知，共有2×6^2个五位数； 由加法法则知，大于34500的五位数个数为3×6^4 + 2×6^3 + 2×6^2=4392 定理2重集B={n1 b1,n2 b2,…,nk bk}的全排列个数为n! / ( n1! n2! …… nk! )，其中，n = n1 + n2 +…… +nk。 证明：将B中的ni个bi看作不同的ni个元素，赋予上标1,2,…, ni，即b(1,i),b(2,i)……,b(ni,i), i=1, 2,…… k，如此，重集B就变成具有n1+n2+…+nk=n个不同的元素集合A = {b(1,1),b(2,1)……,b(n1,1),b(1,2),b(2,2)……,b(n2,2),……b(1,k),b(2,k)……,b(nk,k,} 显然，集合A的全排列个数为n!。又由于ni个bi赋予上标的方法有ni!种，于是对重集B的任一个全排列，都可以产生集合A的n1!×n2!×…×nk!个排列（由乘法法则），故重集B的全排列个数为n! / ( n1! n2! …… * nk! )。 注：利用组合数的计数方法同样可以得出证明。 例2有四面红旗，三面蓝旗，二面黄旗，五面绿旗可以组成多少种由14面旗子组成的一排彩旗？ 解： 这是一个重排列问题，是求重集{4红旗,3蓝旗,2黄旗,5绿旗}的全排列个数，根据定理，一排彩旗的种数为 14! / ( 4! 3! 2! * 5! ) = 2522520。 例3用字母A、B、C组成五个字母的符号，要求在每个符号里，A至多出现2次，B至多出现1次，C至多出现3次，求此类符号的个数。 解： 这也是一个重排列问题。根据分析，符合题意的符号个数相当于求重集M={2A,1B,3*C}的5−排列个数，可分为三种情况：需要分别求M-{A}、M-{B}和M-{C}的全排列个数。根据加法法则，此类符号个数为 5! / (1! 1! 3!) + 5! / (2! 0! 3!) + 5! / (2! 1! 2!) = 60 项链排列对圆排列，通过转动、平移、翻转、可重合的，即可看作项链排列。 若n个不同元素的r−项链排列个数为P(n,r)/(2×r)，具体参照Pólya定理。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论1(辗转相除法 + 欧拉筛 + 杜教筛 + 模运算 + 快速幂)]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%2F</url>
    <content type="text"></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论2（强连通 + 2-SAT + 欧拉图 + 着色问题）]]></title>
    <url>%2F2018%2F08%2F14%2F2018-08-14%2F</url>
    <content type="text"><![CDATA[图的连通性连通图所谓连通性，直观的讲，就是“连成一片”。 我们发现，按照上面的划分方法，我们可以把G1分为三部分，因此，G1是不连通的，但是，这三个部分，我们把它们叫做图G1的三个连通分量。 定义无向图G中，如果任意两顶点u和v，都能找到从一条u到v的路径。称无向图G是连通的。 当G为有向图时，若G中存在一条以 u为起点 v为终点的有向路P，则称从 u到 v是可达的。 如果G的任何两个顶点都是相互可达的 ，则称图G是强连通的；如果G的有向边被看作无向边时是连通的，则称有向图G是弱连通的 。 连通分量所谓连通分量，指的是图中的极大连通子图。 有了连通分量的概念，我们可以对图的连通性换言之为：如果图G中只有唯一一个连通分量，那么G是连通的，我们称G为连通图。 强连通无向图连通性在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先遍历或广度优先遍历，便可访问到图中所有顶点；对于非连通图，则需从多个顶点出发进行遍历，而每次从一个新的起点出发进行遍历得到的顶点访问序列恰好是一个连通分量中的顶点集。 方法对无向图的连通性判定，一般我们采用搜索的方法，这里我们首先要提到应用非常广泛的深度优先搜索算法DFS，DFS在图论算法中有非常重要的地位。 例子对下图( a ) 所示无向图进行深度优先遍历，需分别从顶点 v 1 和 v 5 出发调用两次 DFS（或 BFS），得到的顶点序列分别为： v 1 v 2 v 3 v 4 和 v 5 v 6 。这两个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图 G 的两个连通分量，如下图 ( b ) 所示。 代码因此，要想判定一个无向图是否为连通图，或有几个连通分量，可以设置一个计数器 count ，初始时取值为 0 ，每调用一次遍历算法，就给 count 增 1 。这样，当整个遍历算法结束时，依据 count 的值，就可确定图的连通性了。算法用伪代码描述如下： 12345678910111213141516171819无向图连通分支//无向图连通分支，dfs邻接阵形式，o（n^2）//返回分支数，id返回1..分支数的值//传入图的大小n和邻接阵mat，不相邻点边权0#define MAXN 100 void floodfill(int n,int mat[][MAXN],int* id,int now,int tag)&#123;int i; for (id[now]=tag,i=0;i&lt;n;i++) if (!id[i]&amp;&amp;mat[now][i]) floodfill(n,mat,id,i,tag); &#125;int find_components(int n,int mat[][MAXN],int* id)&#123; int count,i; for (i=0;i&lt;n;id[i++]=0); for (count=i=0;i&lt;n;i++) if (!id[i]) floodfill(n,mat,id,i,++count); return count; &#125; 有向图连通性假设，我们把一张有向图的所有边看做无向的，然后对转化后的无向图进行一次DFS，是不是就可以判断无向图的连通性呢？显然可以。 对于采用邻接矩阵表示的有向图G=&lt;E，V&gt;，如果存在一条边e(u,v),那么在矩阵中e(u,v)&gt;0，我们令e(v,u)=e(u,v)，这样就可以将一条有向边变成无向边。 之后，对于这个转化后的矩阵进行一次DFS，这样既可以判断有向图是否连通。 需要注意的是，一般情况下，我们在题目中应用到得不是简单的有向图是否连通，而是：求有向图的强连通分量。 有向图的强连通分量有向图G的极大强连通子图称为G的强连通分量(SCC)。 下图中，子图{1,2,3,4}为一个强连通分量，因为顶点 1,2,3,4 两两可达。{5},{6}也分别是两个强连通分量。 直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为 O(N^2+M)。更好的方法是 Kosaraju 算法或 和Tarjan 算法，两者的时间复杂度都是 O(N+M)。还有Gabow算法不介绍。 Kosaraju 算法Kosaraju算法的解释和实现都比较简单，为了找到强连通分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域。具体流程如图(1~4)。 上面我们提及原图G的逆图GT，其定义为GT=(V, ET)，ET={(u, v):(v, u)∈E}}。也就是说GT是由G中的边反向所组成的，通常也称之为图G的转置。在这里值得一提的是，逆图GT和原图G有着完全相同的连通分支，也就说，如果顶点s和t在G中是互达的，当且仅当s和t在GT中也是互达的。 在这里顺便提一下在调用dfs的过程中，几种添加顶点到集合的顺序。一共有四种顺序： Pre-Order，在递归调用dfs之前将当前顶点添加到queue中 Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中 Post-Order，在递归调用dfs之后将当前顶点添加到queue中 Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中 最后一种的用途最广，至少目前看来是这样，比如步骤2-a以及拓扑排序中，都是利用的Reverse Post-Order来获取顶点集合。 步骤 (1)对G执行深度优先搜索，求出每个顶点的后序遍历顺序号postOrder。 (2)反转有向图G中的边，构造一个新的有向图G*。 (3)由最高的postOrder编号开始，对G*执行深度优先搜索。如果深度优先搜索未达到所有顶点，由未访问的最高postOrder编号的顶点开始，继续深度优先搜索。 (4)步骤三所产生的森林中的每一棵树，对应于一个强连通分支。 代码12345678910111213141516171819202122232425#define maxN 1024int marked[maxN];//用于记录某个点是否被访问过，0为没有被临幸过，1为被临幸过int id[maxN];//记录每个点所属的连通分量int count;//记录连通分量总数目void kosaraju(graph *g)&#123; int i; memset(marked,0,sizeof(marked)); memset(id,0,sizeof(id)); count=0; for(i=0;i&lt;g-&gt;V;i++)&#123;//之所以这里用循环就是因为g指向的无向图可能不是一个连通图，而是由多个连同分量组成 if(!marked[i])&#123;dfs(g,i); count++;&#125; &#125;&#125; void dfs(graph *g,int v)&#123; graphNode *t; marked[v]=1; id[v]=count; t=g-&gt;adjlist[v].next;//t指向v的邻接点 while(t)&#123; if(!marked[t-&gt;key])&#123;dfs(g,t-&gt;key);&#125;//这里是重点，就是你发现v到t-&gt;key有路径就把它算到跟自己在一个连通分量里了，这里有一个隐性前提，就是你提前知道t-&gt;key一定可以到v，所以你发现v可以到t-&gt;key的时候，你毫不犹豫把它算为跟自己一伙儿的了。Korasaju算法不同书上有不同的表述，区别是先遍历图g还是先遍历图g的逆向图，这只是顺序的区别。我把我看得版本完整说一下：（1）先DFS遍历图g的逆向图，记录遍历的逆后序。（什么叫逆后序？逆后序就是DFS时后序的逆序，注意逆后序不一定为DFS的前序。DFS前序为，访问某个顶点前，把它push进队列。DFS后序为访问完某个顶点后才把它push进队列。而DFS逆后序为访问完某个顶点后把它push进一个栈中。当DFS遍历完整个图后，后序队列的输出与逆后序栈的输出正好相反。）（2）然后按着图g逆向图的DFS遍历的逆后序序列遍历图g求所有的强连通分量，这一步的过程跟无向图求所有连通分量的算法一模一样！按着这里说的遍历顺序重复无向图求所有连通分量的步骤求出来的就是有向图的所有强连通分量，为什么呢？因为我们完成第一步后，按着第一步得到的逆后序要对有向图g进行DFS遍历的前一刻，前面这段过程就相当于我们完成了对这幅有向图g一个加工，把它加工成了一个无向图！也就是说，这个加工实现了我注释开头提到的那个隐性前提。所以后面按着无向图求所有连通分量的步骤求出来的就是有向图g的所有强连通分量。举个例子，比如有向图3-&gt;5-&gt;4-&gt;3，它的逆向图为3-&gt;4-&gt;5-&gt;3（你最好在纸上画下，就是个三角循环图），从逆向图的顶点3开始DFS，得到的逆后续为3，4,5 。按着这个顺序对原图进行DFS，DFS(3)时遇到5，则5肯定跟3在一个强连通分量中（为什么？因为我们逆向图DFS(5)时肯定能到达3，这就是隐形前提。所以正向图DFS(3)遇到5时，我们毫不犹豫把它算到自己一个强连通分量中。） t=t-&gt;next; &#125;&#125; Tarjan 算法Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。定义 DFN(u)为节点 u 搜索的次序编号(时间戳)，Low(u)为 u 或 u 的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出 123456Low(u)=Min &#123; DFN(u), Low(v),(u,v)为树枝边，u为v的父节点 DFN(v),(u,v)为指向栈中节点的后向边(非横叉边) &#125; 当 DFN(u)=Low(u)时，以 u 为根的搜索子树上所有节点是一个强连通分量。算法伪代码如下： 12345678910111213141516tarjan(u) &#123; DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值 Stack.push(u) // 将节点u压入栈中 for each (u, v) in E // 枚举每一条边 if (v is not visted) // 如果节点v未被访问过 tarjan(v) // 继续向下找 Low[u] = min(Low[u], Low[v]) else if (v in S) // 如果节点v还在栈内 Low[u] = min(Low[u], DFN[v]) if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根 repeat v = S.pop // 将v退栈，为该强连通分量中一个顶点 print v until (u== v) &#125; 流程从节点 1 开 始 DFS ，把遍历到的节点加入栈中。搜索到节点 u=6 时 ，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到 u=v 为止，{6}为一个强连通分量。 返回节点 5，发现 DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。 返回节点 3，继续搜索到节点 4，把 4 加入堆栈。发现节点 4 向节点 1 有后向边，节点 1 还在栈中，所以 LOW[4]=1。节点 6 已经出栈，(4,6)是横叉边，返回 3，(3,4)为树枝边，所以 LOW[3]=LOW[4]=1。 继续回到节点 1 ，最后访问节点 2 。访问边 (2,4) ， 4 还在栈中，所以LOW[2]=DFN[4]=5。返回 1 后，发现 DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。 至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。可以发现，运行 Tarjan 算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为 O(N+M)。 代码12345678910111213141516171819202122232425262728293031323334353637383940void tarjan(int i)&#123; int j; DFN[i]=LOW[i]=++Dindex; instack[i]=true; Stap[++Stop]==i; for (edge *e=V[i]; e; e=e-&gt;next) &#123; j=e-&gt;t; if (!DFN[j]) &#123; tarjan(j); if (LOW[j]&lt;LOW[i]) LOW[i]=LOW[j]; &#125; else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i] ) LOW[i]=DFN[j]; &#125; if (DFN[i]==LOW[i]) &#123; Bcnt++; do &#123; j=Stap[Stop--]; instack[j]=false; Belong[j]=Bcnt; &#125; while (j!=i); &#125;&#125;void solve()&#123; int i; Stop=Bcnt=Dindex=0; memset(DFN,0,sizeof(DFN)); for (i=1; i&lt;=N; i++) if (!DFN[i]) tarjan(i);&#125; Gabow算法这个算法其实就是Tarjan算法的变异体，我们观察一下，只是它用第二个堆栈来辅助求出强连通分量的根，而不是Tarjan算法里面的dfn[]和backn[]数组。那么，我们说一下如何使用第二个堆栈来辅助求出强连通分量的根。 我们使用类比方法，在Tarjan算法中，每次backn[i]的修改都是由于环的出现(不然，backn[i]的值不可能变小)，每次出现环，在这个环里面只剩下一个backnk[i]没有被改变(深度最低的那个)，或者全部被改变，因为那个深度最低的节点在另一个环内。那么Gabow算法中的第二堆栈变化就是删除构成环的节点，只剩深度最低的节点，或者全部删除，这个过程是通过出栈来实现，因为深度最低的那个顶点一定比前面的先访问，那么只要出栈一直到栈顶那个顶点的访问时间不大于深度最低的那个顶点。其中每个被弹出的节点属于同一个强连通分量。那有人会问：为什么弹出的都是同一个强连通分量？因为在这个节点访问之前，能够构成强连通分量的那些节点已经被弹出了，这个对Tarjan算法有了解的都应该清楚，那么Tarjan算法中的判断根我们用什么来代替呢？想想，其实就是看看第二个堆栈的顶元素是不是当前顶点就可以了。 现在，你应该明白其实Tarjan算法和Gabow算法其实是同一个思想的不同实现，但是，Gabow算法更精妙，时间更少(不用频繁更新backn[])。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stack&gt;using namespace std;bool map[100][100];//记录图形bool visited[100];//记录点是不是已经被访问过了bool del[100];//记录点是不是已经删除了int dfn[100];//记录点访问的次序stack&lt;int&gt;s1,s2;int dotn;void init()&#123; int line; cin&gt;&gt;dotn&gt;&gt;line; for(int i=1;i&lt;=line;i++) &#123; int u,v; cin&gt;&gt;u&gt;&gt;v; map[u][v]=1; &#125; memset(visited,0,sizeof(visited)); memset(del,0,sizeof(del));&#125;void dfs(int u,int &amp;time)&#123; visited[u]=1; dfn[u]=++time; s1.push(u); s2.push(u); for(int i=1;i&lt;=dotn;i++) &#123; if(map[u][i]) &#123; if(!visited[i]) &#123; dfs(i,time); &#125; else &#123; if(!del[i]) &#123; while(dfn[s2.top()]&gt;dfn[i])s2.pop();//注意这个地方 &#125; &#125; &#125; &#125; if(u==s2.top()) &#123; while(u!=s1.top()) &#123; cout&lt;&lt;s1.top()&lt;&lt;&quot; &quot;; del[s1.top()]=1; s1.pop(); &#125; cout&lt;&lt;u&lt;&lt;endl; del[s1.top()]=1; s1.pop(); s2.pop(); &#125;&#125;void Gadow()&#123; init(); int time=0; for(int i=1;i&lt;=dotn;i++) &#123; if(!visited[i]) &#123; dfs(i,time); &#125; &#125;&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); Gadow(); return 0;&#125; 应用强连通分支问题的最大应用就在于两个字：缩点！ 所谓缩点，就是把图中属于同一个强连通分支中的点缩为一个点，这样，我们就得到了一个新的有向图，而且图中不存在回路。 POJ 1236 - Network of Schools（最小点基） 2-SAT有向图缩点一个很大的应用，就是2-SAT问题(2判定性问题 )。 POJ 3678 - Katu Puzzle POJ 3683 - Priest John’s Busiest Day 2-SAT定义 1:布尔变量 x，假如逻辑运算“或”和“与”分别用“∨”和“∧ ”来表示，﹁x表示 x 的非，布尔表达式是用算术运算符号连接起来的变量所构成的代数表达式。给定每个变量 x 的一个值 p(x)，可以像计算代数表达式一样计算布表达式的值。如果存在一个真值分配，使得布尔表达式的取值为真，则这个布尔表达式称为可适定性的，简称 SAT。 例如（x1∨x2）∧(﹁x1∨﹁x2) 这个布尔表达式，如果 p(x1)=真，p(x2)=假，则表达式的值为真，则这个表达式是适定性的。不是所有的布尔表达式都是可适定的。 例如x1∧﹁x2∧(﹁x1∨x2)，则不管 p(x1),p(x2)取何值，表达式都不可能为真，因此这个布尔表达式是不可适定的。 适定性问题的一般形式 X=｛x1,x2..,xn｝为一个有限的布尔变量集，包含 x1,x2，..,xn的“或”和“与”，运算的 m 个句子 C1,C2,..,Cm,布尔表达式 C1∧C2∧,..,∧Cm 是否可适定。 布尔表达式由用“与”连接起来的一些句子构成，则称这个表达式为“合取范式”。 定义 2:对于给定的句子 C1,C2,..,Cm,如果 max{|Ci|}=k(1≦i≦m),则称此适定性问题为 k 适定性问题，简称 k-SAT。 当 k&gt;2 时，k-SAT 是 NP 完全的，所以我们一般讨论2-SAT问题。 解题思路下面我们从一道例题来认识 2-SAT 问题，并提出对一类 2-SAT 问题通用的解法。Poi 0106 Peaceful Commission [和平委员会] 某国有 n 个党派，每个党派在议会中恰有 2 个代表。现在要成立和平委员会 ，该会满足： 每个党派在和平委员会中有且只有一个代表如果某两个代表不和，则他们不能都属于委员会代表的编号从 1 到 2n，编号为 2a-1、2a 的代表属于第 a 个党派 输入 n（党派数），m（不友好对数）及 m 对两两不和的代表编号其中 1≤n≤8000，0≤m ≤20000求和平委员会是否能创立。若能，求一种构成方式。 例： 输入： 3 2 1 3 2 4 输出： 1 4 5 分析原题可描述为： 有 n 个组，第 i 个组里有两个节点 Ai, Ai’ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的 n 个点都能两两相容。（在这里把 Ai,Ai’ 的定义稍稍放宽一些，它们同时表示属于同一个组的两个节点。也就是说，如果我们描述 Ai，那么描述这个组的另一个节点就可以用 Ai’） 初步构图 如果 Ai 与 Aj 不相容，那么如果选择了 Ai，必须选择 Aj ‘ ；同样，如果选择了 Aj，就必须选择 Ai ’ 。 Ai → AjAj → Ai 这样的两条边对称 我们从一个例子来看： 假设 4 个组，不和的代表为：1 和 4，2 和 3，7 和 3，那么构图： 假设： 首先选 13 必须选，2 不可选5、6 可以任选一个8 必须选，4、7 不可选 矛盾的情况为：存在 Ai，使得 Ai 既必须被选又不可选。得到算法 1：枚举每一对尚未确定的 Ai, Ai‘ ，任选 1 个，推导出相关的组，若不矛盾，则可选择；否则选选另 1 个，同样推导。若矛盾，问题必定无解。 此算法正确性简要说明： 由于 Ai,Ai’ 都是尚未确定的，它们不与之前的组相关联，前面的选择不会影响 Ai,Ai’ 。算法的时间复杂度在最坏的情况下为 O(nm)。 在这个算法中，并没有很好的利用图中边的对称性观察图（1）可以发现，1 和 3 构成一个环，这样 1 和 3 要么都被选中，要么都不选。2和 4 也同样如此。 在每个一个环里，任意一个点的选择代表将要选择此环里的每一个点。不妨把环收缩成一个子节点。新节点的选择表示选择这个节点所对应的环中的每一个节点。 对于原图中的每条边 Ai → Aj（设 Ai 属于环 Si，Aj 属于环 Sj）如果 Si≠Sj，则在新图中连边： Si → Sj 这样构造的有向无环图和原图是等价的，这样我们就可以用之前介绍过的强连通分量的算法把图转化成有向无环图，在这个基础上，如果存在一对 Ai, Ai’属于同一个环，则判无解，否则将采用拓扑排序，以自底向上的顺序进行推导，一定能找到可行解。 下面给出 2-SAT 问题中常用的建边方式： 2-SAT 中元素关系常见有以下 11 种 A[x] NOT A[x] A[x] AND A[y] A[x] AND NOT A[y] A[x] OR A[y] A[x] OR NOT A[y] NOT (A[x] AND A[y]) NOT (A[x] OR A[y]) A[x] XOR A[y] NOT (A[x] XOR A[y]) A[x] XOR NOT A[y] And 结果为 1：建边 ~x-&gt;y, ~y-&gt;x (两个数都为 1)And 结果为 0：建边 y-&gt;~x , x-&gt;~y(两个数至少有一个为 0)OR 结果为 1：建边 ~x-&gt;y , ~y-&gt;x(两个数至少有一个为 1)OR 结果为 0：建边 x-&gt;~x , y-&gt;~y(两个数都为 0)XOR 结果为 1：建边 x-&gt;~y , ~x-&gt;y , ~y-&gt;x , y -&gt; ~x (两个数一个为 0，一个为 1)XOR 结果为 0：建边 x-&gt;y , ~x-&gt;~y , y-&gt;x ~y-&gt;~x(两个数同为 1 或者同为 0) 对于一般判定是不是有解的情况，我们可以直接采用 tarjan 算法求强联通，然后缩点，如果 x 与~x 染色相同，说明无解，否则有解。有的时候，可能需要用二分++tarjan 算法 欧拉图每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。 答案是肯定的。 math 版上的 OmnipotentEntity 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。 熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。 欧拉图（E问题）起源：欧拉回路问题是图论中最古老的问题之一。它诞生于十八世纪的欧洲古城哥尼斯堡。普瑞格尔河流经这座城市，人们在两岸以及河中间的两个小岛之间建了七座桥（如图1）。 于是产生了这样一个问题：是否可以找到一种方案，使得人们从自己家里出发，不重复地走遍每一座桥，然后回到家中？这个问题如果用数学语言来描述，就是在图2中找出一条回路，使得它不重复地经过每一条边。这便是著名的“哥尼斯堡七桥问题”。 定义：​ 欧拉回路：图G=(V,E) (无向图or有向图) 的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。 ​ 欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。 ​ 欧拉图与半欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉通路而无欧拉回路的图称为半欧拉图。 ​ 桥：设无向图G=&lt;V,E&gt;，若存在边集E的一个非空子集E1，使得p(G-E1)&gt;p(G)，而对于E1的任意真子集E2，均有p(G-E2)=p(G)，则称E1是G的边割集，或简称割集；若E1是单元集，即E1={e}，则称e为割边或桥。[p(G)表示图G的连通分支数.] 图中，图（4）为欧拉图，图（3）为半欧拉图，图（1）（2）不是欧拉图。 性质： 欧拉回路：一个欧拉回路，删掉一个点，仍然是一个欧拉回路。从一个欧拉回路拖走一个小欧拉回路，结果也是一个欧拉回路。 判定（充要）： 欧拉回路：1: 图G是连通的，不能有孤立点存在。 2: 对于无向图来说度数为奇数的点个数为0;对于有向图来说每个点的入度必须等于出度。 欧拉通路：1: 图G是连通的，无孤立点存在。 2: 对于无向图来说，度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点。对于有向图来说，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。 算法（求欧拉回路）：Fleury算法:设图G是一个无向欧拉图，则按照下面算法求欧拉回路: 1:任取G中一个顶点v0,令P0 = v0. 2:假设沿Pi = v0e1v1e2v2……eivi 走到了顶点 vi,按照下面方法从E(i) = E(G) - {e1, e2, e3,…,ei} 中选e(i ＋ 1),选择后删除e(i +１)这条边. a):e(i+1)余vi关联 b):除非无别的边可选，否则e(i+1)不应是Gi = G – {e1,e2,…,ei} 中的桥.假若迫不得已选的是桥,除删除这条边之外,还应该再把孤立点从Gi中移除(选择桥边必然会形成孤立的点). 3:当步骤 2 无法继续执行时停止算法. 当算法停止时，所得到的简单回路 Pm = = v0e1v1e2v2e3v3……emvm (vm = v0) 为图G的一条欧拉回路. 下面用图来描述： 随便选择一个起点 v1。当前处在 v1 点，有两种走法 v1 – v9,v1 – v10，这俩条边都不是桥边，那么随便选择一个，&lt;v1, v10&gt;这条边吧。那么图就会成为这样.Eu = (走过的边集){&lt;v1, v10&gt;} 当前到了 V10 点，有&lt;v10,v4&gt;,&lt;v10,v3&gt;,&lt;v10, v8&gt;，先看&lt;v10,v8&gt;这条边吧，如果选择了这条边那么图就会成为这样： 很显然形成了两个图，上下两个图不连通，即&lt;v10, v8&gt;这条边就是所谓的桥边，算法中说除非别无他选，否则不应该选择桥边，那么这条边就不能选择。回到上面，由于&lt;v10,v4&gt;,&lt;v10,v3&gt;都不是桥边，所以随便选择&lt;v10,v4&gt;吧. Eu={&lt;v1, v10&gt;,&lt;v10,v4&gt;} 到了 v4 这个点，&lt;v4, v2&gt;这条边是桥边,但是别无选择，只好选择这条边.选择完这条边这时不仅要从原图中删除这条边，由于点4成为了孤点，所以这个点也该从原图删除。Eu={&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;}. 同理到达 v2 只好选择&lt;v2,v3&gt;，删除孤点 v2和边. Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;}. 别无他选，&lt;v3,v10&gt;。Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;}. 同样,选择&lt;v10, v8&gt;，Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;}. 此时到了 v8 同第一次到达v10时的情况，不能选择&lt;v8,v9&gt;这条桥边,选择&lt;v8,v6&gt;,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;}. 到达v6，选择&lt;v6,v7&gt;,删点删边,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;}.以下就不给图了(逃; 然后接下来的选择都是别无他选,依次选择&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;，最后得到的欧拉边集Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;,&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;},于是我们就得到了一条欧拉回路. 算法实现：这个算法在实现时也有很巧妙的方法。因为DFS本身就是一个入栈出栈的过程，所以我们直接利用DFS的性质来实现栈，其伪代码如下： 1234567DFS(u): While (u存在未被删除的边e(u,v)) 删除边e(u,v) DFS(v) End PathSize ← PathSize + 1 Path[ PathSize ] ← u 模板：1234567891011121314151617181920212223242526272829303132333435363738394041void DFS(Graph &amp;G,SqStack &amp;S,int x,int t)&#123; k=0;//一个标志,来标记当前访问的节点是否还有邻接边可供访问 Push(S,x); //将本次遍历边所经由的点入栈 for(i=t;i&lt;v;i++) //v是顶点数,e是边数 if(G[i][x]&gt;0) &#123; k=1; G[i][x]=0; G[x][i]=0; //此边已访问,删除此边 DFS(G,S,i,0);//寻找下一条关联的边,本次找到的是与x关联的i,在 //下一层中将寻找与i关联的边 break; &#125;//if,for if(k==0) //如果k=0,说明与当前顶点关联的边已穷尽 &#123; Pop(S); GetTop(S,m); G[x][m]=1;G[m][x]=1;//恢复在上一层中被删除的边 a=x+1;//如果可能的话,从当前节点的下一条关联边开始搜寻 if(StackLength(S)!=e)//继续搜寻,边还没有全部遍历完 &#123; Pop(S); //还原到上一步去 DFS(G,S,m,a);// &#125;//if else //搜寻完毕,将最后节点也入栈 Push(S,x); &#125;//if&#125;//DFSvoid Euler(Graph &amp;G,int x)&#123;//G是存储图的邻接矩阵,都处理成无向图形式,值为1代表有边,0代表无边,不包括自回路,x是出发点InitStack(S);//用来存放遍历边时依次走过的顶点DFS(G,S,x,0);//深度优先遍历查找,0是指查询的起点//输出 while(!StackEmpty(S)) &#123; GetTop(S,m); printf(&quot;-&gt;v%d&quot;,m); Pop(S); &#125;//while&#125;//Euler 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N = 1005;int n, m, flag, top, sum, du[N], ans[5005], map[N][N];void dfs(int x)&#123; ans[++top] = x; for(int i = 1; i &lt;= n; i++) &#123; if(map[x][i] &gt;= 1) &#123; map[x][i]--; map[i][x]--; dfs(i); break; &#125; &#125;&#125;void fleury(int x)&#123; top = 1; ans[top] = x; while(top &gt; 0) &#123; int k = 0; for(int i = 1; i &lt;= n; i++)//判断是否可扩展 &#123; if(map[ans[top]][i] &gt;= 1)//若存在一条从ans[top]出发的边 那么就是可扩展 &#123;k = 1; break;&#125; &#125; if(k == 0)//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它 &#123; printf(&quot;%d &quot;, ans[top]); top--; &#125; else if(k == 1)//如可扩展， 则dfs可扩展的哪条路线 &#123; top--;//这需要注意 dfs(ans[top+1]); &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) &#123; memset(du, 0, sizeof(du)); memset(map, 0, sizeof(map)); for(int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); map[x][y]++; //记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边 map[y][x]++; du[x]++; du[y]++; &#125; flag = 1; // flag标记开始点。 如果所有点度数全为偶数那就从1开始搜 sum = 0; for(int i = 1; i &lt;= n; i++) &#123; if(du[i] % 2 == 1) &#123; sum++; flag = i;// 若有奇数边， 从奇数边开始搜 &#125; &#125; if(sum == 0 || sum == 2) fleury(flag); &#125; return 0;&#125; 基本(套圈)法1.在图中任意找一个回路C； 2.将图中属于C的边删除； 3.在残留图的各个极大连通分量中求欧拉回路； 4.将各极大连通分量中的欧拉回路合并到C上。 详细过程 首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，所停止的点必然也是起点(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，然后停止时，走过的路径形成了一个圈，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。 总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。 下面用图描述一遍： 假设我们选择从v1开始走,由于随便走，所以可能出现以下走法 第一步：v1 – v9 第二步：v9 – v8 第三步：v8 – v10 第四步：v10 – v1 此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么 第五步: v10 – v3 第六步: v3 – v2 第七步: v2 – v4 第八步: v4 – v10 发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么 第九步：v8 – v6 第十步：v6 –v7 第十一步：v7– v8 又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。 具体实现与分析: 使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;const int MAXV = 100 + 7;const int MAXE = 100 * 100 + 7;int head[MAXV];int V, E;typedef struct EdgeNode&#123; int to; int w; int next; &#125;edgeNode;edgeNode Edges[MAXE];bool visit[2 * MAXE];stack&lt;int&gt; stv;queue&lt;int&gt; quv;//点集queue&lt;int&gt; que;//边集void EulerDFS(int now)&#123; st.push(now);//每访问一个点，就把该点压入栈 for(int k = head[now]; k != -1; k = Edges[k].next) &#123; if(!visit[k]) &#123; visit[k] = true; //有向图每条边保存了两次，也要标记两次 if(k &amp; 1) visit[k + 1] = true; else visit[k - 1] = true; EulerDFS(Edges[k].to); que.push(k);//回溯时记录边 &#125; &#125; quv.push(stv.top());//记录点 stv.pop();&#125;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;V, &amp;E); memset(head, -1, sizeof(head)); for(int i = 1; i &lt;= E; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); Edges[2 * i - 1].to = v; //双向储存边 Edges[2 * i - 1].w = w; Edges[2 * i - 1].next = head[u]; head[u] = 2 * i - 1; Edges[2 * i].to = u; Edges[2 * i].w = w; Edges[2 * i].next = head[v]; head[v] = 2 * i; &#125; memset(visit, false, sizeof(visit)); EulerDFS(1); return 0;&#125; 例题例1 有N个盘子，每个盘子上写着一个仅由小写字母组成的英文单词。你需要给这些盘子按照合适的顺序排成一行，使得相邻两个盘子中，前一个盘子上面单词的末字母等于后一个盘子上面单词的首字母。请你编写一个程序，判断是否能达到这一要求。如果能，请给出一个合适的顺序。 分析以26个英文字母作为顶点。对于每一个单词，在图中从它的首字母向末字母连一条有向边。 问题转化为在图中寻找一条不重复地经过所有边的路径，即欧拉路径。这个问题能够在O(|E|)时间内解决。 例2PKU 2337 问题描述 给出一些字符串，让你首尾串起来串成一串，并且输出一个字典序最小的方案。如果不能，输出“**”。否则输出字典序最小的回路。 输入 2 6 aloha arachnid dog gopher rat tiger 3 oak maple elm 输出 aloha.arachnid.dog.gopher.rat.tiger ** 分析 在没有特殊要求的情况下，DFS遍历图的结点顺序是可以任选的。但是这里由于加上了字典序最小的要求，所以DFS遍历时需要按照以下的优先顺序： 如果有不是桥的边，遍历这些边中字典序最小的边。 否则，遍历这些这些桥中字典序最小的边。 比如一个单词，abcde，那么就连接一条a到e的有向边。如此构成的图一共最多有26个节点。每条边都代表一个单词，那么就转化成了：找一条路，遍历所有的边。就是欧拉通路问题。 遍历欧拉通路的方法： 确定一个起点（出度-入度=1，或者等于0（如果存在欧拉回路的话）） 从起点开始深搜（首先要保证图中存在欧拉回路或者通路） dfs(vid, eid) 其中vid表示当前搜到的点。eid表示当前搜到的边（一个点可能会有很多边） 对于每条边，都是等它搜索完了后，把它代表的内容（这里是单词）压入一个栈中。 最后深搜结束后，依次弹栈就是答案。 例3DOOR MAN 大意：给定N(&lt;=20)个房间,房间之间有门相隔，门的数目不超过100道，当前人在第M个房门，当前人每经过一道门的时候就把经过的门锁上，问有没有一条路可以使得我们走到第0个房门的时候所有的门都锁上了。 思路：我们可以把门看成是两个房间之间的边，那么问题可以转化成找一条欧拉路径。PS：判断的时候只要判断所有的边在一起就行了，所有的点不一定连通，当0点和M点不连通的时候，无解。注意这组数据。 中国邮递员问题(CPP)定义一个邮递员从邮局出发，要走完他所管辖范围内的每一条街道，至少一次再返回邮局，如何选择一条尽可能短的路线？这就是中国邮递员问题（CPP），其命名是因为中国数学家管梅谷在1962年首先提出了这个问题。如果用顶点表示交叉路口，用边表示街道，那么邮递员所管辖的范围可用一个赋权图来表示，其中边的权重表示对应街道的长度。 图论语言中国邮递员问题可用图论语言叙述为：在一个具有非负权的赋权连通图G中，找出一条权最小的环游。这种环游称为最优环游。若G是欧拉图，则G的任意欧拉环游都是最优环游，从而可利用弗勒里算法求解。若G不是欧拉图，则G的任意一个环游必定通过某些边不止一次。将边e的两个端点再用一条权为w(e)的新边连接时，称边e为重复的。此时CPP与下述问题等价，若G是给定的有非赋权的赋权连通图， （1）用添加重复边的方法求G的一个欧拉赋权母图 ，使得 尽可能小； （2）求 的欧拉环游。 此图图论中和中国邮递员问题类似的是旅行商问题，区别于中国邮递员问题，旅行商问题是说在边赋权的完全图中找一个权和最小的哈密尔顿圈。 埃德蒙兹（J.Edmonds）和约翰逊（E.L.Johnson)在1973年给出了求解（1）的多项式时间算法。 如果邮递员所通过的街道都是单向道，则对应的图应为有向图。1973年，埃德蒙兹和约翰逊证明此时CPP也有多项式时间算法。帕帕季米特里屋（C.H.Papadimitrious）在1976年证明，如果既有双向道，又有单向道，则CPP是NP困难的。 分析由于每边至少遍历一次，所以最短路的瓶颈就在于重复遍历。由于图一直保持连通性，所以两两奇点之间都存在欧拉路；又两两奇点之间的最短路可求；奇点个数为偶数。所以问题就等价于找一个奇点构成的完全图G’(V,E)的最小权匹配(Perfect Matching in General Graph)。V(G’)为原图G中的奇点，每条边为两奇点对应原图的最短路长度。 奇偶点图作业法 确定G中的奇点，构成G’。 确定G’两两结点在G中的最短路作为它们在G’中的边权。 对G’进行最小权匹配。 最小权匹配里的各匹配边所对应的路径在G中被重复遍历一次,得到欧拉图G’’。 对G’’找一条欧拉路即可。 有向的中国邮路问题，比较复杂。 哈密顿图（H问题） 1857年，英国数学家汉密尔顿(Hamilton)提出了著名的汉密尔顿回路问题，其后，该问题进一步被发展成为所谓的“货郎担问题”，即赋权汉密尔顿回路最小化问题：这两个问题成为数学史上著名的难题。 性质汉密尔顿路：给定图G，若存在一条路，经过图中每个结点恰好一次，这条路称作汉密尔顿路。 汉密尔顿回路：给定图G，若存在一条回路，经过图中每个结点恰好一次，这条回路称作汉密尔顿回路。 汉密尔顿图：具有汉密尔顿回路的图，称作汉密尔顿图。 解法必须说明，汉密尔顿回路问题是一个NP完全问题(NP-Complete)，也就是说，至今没有一个行之有效的多项式时间的算法能够找到这类问题的最优解，只有一些近似算法。关于NPC问题，我们这里不做讨论。我们一般情况下，直接用DFS进行搜索，当然，如果图的点比较多的时候(一般n&gt;10)，这个算法是不现实的。 旅行商问题(TSP) Traveling Salesman Problem，即旅行商问题， 旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值，这是一个NP难问题。 TSP的历史很久，最早的描述是1759年欧拉研究的骑士周游问题，即对于国际象棋棋盘中的64个方格，走访64个方格一次且仅一次，并且最终返回到起始点。 TSP由美国RAND公司于1948年引入，该公司的声誉以及线形规划]这一新方法的出现使得TSP成为一个知名且流行的问题。 解法状压DP 着色问题图的着色问题是由地图的着色问题引申而来的：用m种颜色为地图着色，使得地图上的每一个区域着一种颜色，且相邻区域颜色不同。问题处理：如果把每一个区域收缩为一个顶点，把相邻两个区域用一条边相连接，就可以把一个区域图抽象为一个平面图。 通常所说的着色问题是指下述两类问题： 1．给定无环图G=(V,E)，用m种颜色为图中的每条边着色，要求每条边着一种颜色，并使相邻两条边有着不同的颜色，这个问题称为图的边着色问题。 2．给定无向图G=(V,E)，用m种颜色为图中的每个顶点着色，要求每个顶点着一种颜色，并使相邻两顶点之间有着不同的颜色，这个问题称为图的顶着色问题。 边着色问题定义：给图G的边着色，使得有共同顶点的边异色的最少颜色数，称为边色数。 妖怪图（snark graph）妖怪图每个点都关联着3条边，用4种颜色可以把每条边涂上颜色，使得有公共端点的边异色，而用3种颜色办不到，切断任意3条边不会使它断裂成2个有边的图。 单星妖怪和双星妖怪： 时间表问题；设x1,x2,…,xm为m个工作人员，y1,y2,…,yn表为n种设备，工作人员对设备提出要求，使用时间均假定以单位时间计算，自然每一个工作人员在同一个时间只能使用一种设备，某一种设备在同一时间里只能为一个工作人员使用，问应如何合理安排，使得尽可能短时间里满足工作人员的要求？ 问题转换为X={x1,x2,…,xm}，Y={y1,y2,…,yn}的二分图G，工作人员xi要求使用设备yj，每单位时间对应一条从xi到yj的边，这样所得的二分图过xi ，yj的边可能不止一条。问题变为对所得二分图G的边着色问题。有相同颜色的边可以安排在同一时间里。 定理：二分图G的边色数＝图中顶点的最大度。 定理(Vizing 1964)：若图G为简单图，图中顶点最大度为d，则G的边色数为d或d+1。 目前仍无有效区分(判别)任给定图属第几类图的有效方法。 引申边的着色问题可以转化为顶点的着色问题。 点着色问题定义：给图G的顶点着色，使得相邻的顶点异色的最少颜色数，称为图G顶色数，简称色数；记作χ(G)。 四色猜想：平面图的色数不大于5。 色数的性质：（1）图G只有孤立点时，χ(G)=1； （2）n个顶点的完全图G有χ(G)=n； （3）若图G是n个顶点的回路，则χ(G)=2， n为偶数。χ(G) =3， n为奇数； （4）图G是顶点数超过1的树时，χ(G)=2； （5）若图G是二分图，则χ(G)=2。 定理：图G=(V,E)的色数χ(G)=2的充要条件是：(1)|E|≥1；(2)G不存在边数为奇数的回路。 若图G=(V,E)，d=max{d(vi)},vi∈V，则χ(G)≤d+1。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>欧拉图</tag>
        <tag>哈密顿图</tag>
        <tag>连通图</tag>
        <tag>着色问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ccpc-wannafly秦皇岛站集训部分题解]]></title>
    <url>%2F2018%2F08%2F13%2F2018-08-12%2F</url>
    <content type="text"><![CDATA[WANNAFLY_DAY1Problem A. Birthday恬恬的生日临近了。宇扬给她准备了一个大蛋糕。 正如往常一样，宇扬在蛋糕上插了n支蜡烛，并把蛋糕分为m个区域。因为某种原因，他必须把第i根蜡烛插在第ai个区域或第bi个区域。区域之间是不相交的。宇扬在一个区域内同时摆放x支蜡烛就要花费x2的时间。宇扬布置蛋糕所用的总时间是他在每个区域花的时间的和。 宇扬想快些见到恬恬，你能告诉他布置蛋糕最少需要多少时间吗？ Input第一行包含两个整数n，m（1 ≤ n ≤ 50， 2 ≤ m ≤ 50）。接下来n行，每行两个整数ai, bi（1 ≤ ai, bi ≤ m）。 Output一个整数表示答案 Examplesstandard input3 31 21 21 2 standard output 5 standard input 3 31 22 31 3 standard output 3 思路：考虑费用流时把每个part拆成n个点，选择第i个点的代表为放置i块蛋糕和(i - 1)块蛋糕的时间差，这个时间差是增的，因此在费用流的过程中必定会从小到大选择具体建图：左边n个点代表n个蛋糕，右边m * n个点代表m个part,每个part拆成n个点。源点向每个左边的点连一条流量1费用0的边，每个右边的点向汇点连一条流量1费用0的编。每个蛋糕向可以放的两个part的所有点连边，连向第i个点的费用为i^2 - (i - 1)^2，流量为1。这样求最小费用流既为答案。 Problem B. Board恬恬有一个n × n的数组。她在用这个数组玩游戏： 开始时，数组中每一个元素都是0。 恬恬会做某些操作。在一次操作中，她可以将某一行的所有元素同时加上一个值，也可以将某一列的所有元素同时加上一个值。 在几次操作后，一个元素被隐藏了。你能帮助她回忆隐藏的数是几吗？ Input第一行一个整数n（1 ≤ n ≤ 1000）。接下来n行每行n个整数表示数组a。第(i + 1)行的第j个元素表示aij（aij = −1或0 ≤ aij ≤ 100000）。−1表示隐藏的元素 Output仅一个整数表示答案 Examplestandard input31 2 10 -1 00 1 0 standard output 1 思路把格子N染色，第i行第j列格子的颜色为(i + j) % N。那么每次操作时，必定是N种不同的颜色都有一格被操作到，因此最后任何颜色格子的和必定是相等的。因此只需要记录每种颜色格子的和，并算出缺失格子的颜色C，用其余颜色的和减去颜色C的和即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1005;int map[maxn][maxn];int main()&#123; int n; int x,y; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]==-1) &#123; x=i; y=j; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==x) continue; int minn=0x3f3f3f; for(int j=0;j&lt;n;j++) &#123; minn=min(minn,map[i][j]); &#125; for(int j=0;j&lt;n;j++) &#123; map[i][j]-=minn; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==y) continue; int minn=0x3f3f3f; for(int j=0;j&lt;n;j++) &#123; minn=min(minn,map[j][i]); &#125; for(int j=0;j&lt;n;j++) &#123; map[j][i]-=minn; &#125; &#125; int ans1=0,ans2=0; for(int i=0;i&lt;n;i++) &#123; if(map[i][y]!=0 &amp;&amp; map[i][y]!=-1) ans1=map[i][y]; &#125; for(int i=0;i&lt;n;i++) &#123; if(map[x][i]!=0 &amp;&amp; map[x][i]!=-1) ans2=map[x][i]; &#125; cout&lt;&lt;ans1+ans2&lt;&lt;endl; &#125; return 0;&#125; Problem C. Circle现在我们要把1 . . . n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多。请输出最大对数。 Input一行一个整数n(1 ≤ n ≤ 1000)。 Output一行一个整数表示答案。 Examplestandard input 4 standard output4 Note样例的一种构造方法为1 4 3 2。 思路因为(i,i+1)=1且(1,n)=1，所以把1…n依次放进一个环，就可以啦。答案为n。 代码12345678910#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+7;int main()&#123; int t; while(cin&gt;&gt;t)&#123; cout&lt;&lt;t&lt;&lt;endl; &#125; return 0;&#125; Problem D. 土龙弟弟Problem E. Growth弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。 为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a ≥ xi且b ≥ yi，则弱弱在接下来的每一天都可以得到zi的分数。 问m天以后弱弱最多能得到多少分数。 Input第一行一个两个整数n和m（1 ≤ n ≤ 1000，1 ≤ m ≤ 2000000000）。接下来n行，每行三个整数xi，yi，zi（1 ≤ xi, yi ≤ 1000000000，1 ≤ zi ≤ 1000000）。 Output一行一个整数表示答案。 Examplestandard input2 42 1 101 2 20 standard output 50 Note在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。共获得0 + 0 + 20 + 30 = 50分 思路把奖励的x拿出来从小到大排序，得到x1,x2,…,xn。把奖励的y拿出来从小到大排序，得到y1,y2,…,yn。用v[i][j]表示a值到达xi，b值达到yi时接下来每天可以得到的奖励。v[i][j] = v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1] + t[i][j]其中t[i][j]为满足x=i，y=j的奖励的总和。用f[i][j]表示a值达到xi，b值达到yj时已经拿到的奖励的最大值。f[i][j] + (x[i + 1] - x[i] - 1) t[i][j] + t[i + 1][j] -&gt; f[i + 1][j]f[i][j] + (y[j + 1] - y[j] - 1) t[i][j] + t[i][j + 1] -&gt; f[i][j + 1]最后统计一下答案就可以了。 Problem F. KingdomX王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个官员是这个上司的下属。上司的编号总比下属小。 我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力是1。国王的影响力总是n。 任何一位有下属的官员总是选择他的下属中影响力最高的作为他的心腹（有若干下属影响力相同的话则会选择编号最小的）。 一位官员得到一条消息后，他就要把消息传达给国王。我们定义一位官员的花费为他将消息传达给国王的花费。国王自己的花费为0。如果一位官员是他上司的心腹，则他的花费等于他上司的花费，否则他的花费为他上司的花费加1。 由于时代和平，消息并不需要传递的太快。我们希望你决定每位官员（除了国王）的上司，使得所有官员的花费之和和尽量小。 Input一个整数n（1 ≤ n ≤ 8000）表示包括国王在内的官员的总数。 Output一个整数表示最大的花费之和。 Examplestandard input4 standard output 2 思路f[i]代表i个点时的答案，g[i][j]代表若干颗树加起来，size和为i，每棵树size&lt;=j时，这些树的代价和最大是多少从1到n枚举i，在i固定时枚举心腹的影响力大小更新f[i]，然后用类似背包的思路更新g[i][1]~g[i][i]复杂度O(N^2) Problem G. Matrix弱弱有一个n × m的矩阵，第i行第j列位置上的值为aij。弱弱定义以(x, y)为顶点，大小为k的三角形为： 第x行y位置，第x + 1行y − 1，y，y + 1位置，. . .，第x + k − 1行y − k + 1，. . .，y + k − 1位置组成的区域。 比如说，以(1, 3)为顶点，大小为3的三角形为 OOXOOOOOXXXOOOXXXXXOOOOOOOOO中打叉的位置。 现在弱弱想要知道所有大小为k的三角形中，重心位置离顶点最近的是哪个？重心是三角形中每个位置按照它们的值加权平均所得的点。请输出这个最小距离（欧几里得距离）。 Input第一行一个三个整数n，m，k（1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，1 ≤ k ≤ min n,(m + 1)/2 接下来n行，每行m个整数aij（1 ≤ aij ≤ 1000）表示每个位置的重量。 Output一行一个数表示答案。相对误差或绝对误差在10−5（1e-5）之内均会被判断为正确。 Examplestandard input2 3 21 1 11 1 1 standard output 0.7500000000 Note只有一个大小为2的三角形。 思路w个格子的重心的坐标为（∑xiwi / ∑wi, ∑yiwi / ∑wi)。那么其实我们只要维护∑xiwi，∑yiwi，∑wi就可以了。假设我们现在有一个顶点为(x, y)的三角形，我们想要推到顶点为(x, y+1)的三角形，观察两者之间的差异，会发现在推过去的过程中，其实就是删去了一个斜条，又加入了一个斜条。同理，从(x, y)到(x+1, y)其实只是删去了两个斜条，加上了底上的横条，而这些关键的值都是可以通过前缀和的方法维护。 Problem H. Mountain平面上有n座山，每座山都有左右两面，第i座山的高度为ai，现在弱弱在第一座山的左边山脚下（高度为0），他想要依此爬过这些山，到达第n座山的右边山脚下。 除了简单的爬上爬下，还有一种特殊操作。 如果弱弱目前在第i座山右面的海拔x的位置，且第j(i &lt; j)座山的海拔大于等于x，且第i + 1, . . . , j − 1座山中没有一座山的海拔高于x，那么他可以使用绳索滑到第j座山左面海拔x的位置。 弱弱想找到一种方式，使得他在行程中海拔变化的幅度最小。请输出最小幅度。 Input第一行一个整数n（1 ≤ n ≤ 1000）。接下来一行n个整数ai（1 ≤ ai ≤ 1000）表示每座山的高度。 Output一行一个整数表示答案。 Examplestandard input51 3 5 4 2 standard output 10 思路考虑山中最高的一座，最优操作一定是从第一座山的左下角开始不停地往上爬，然后从最高的山不停地往下爬爬到最后一座山的右下角。所以答案为最高山的高度*2。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int a[1007], n;int main()&#123; while(cin&gt;&gt;n)&#123; int cnt = 0; a[0] = 0; int cur = 0; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i] &gt;= a[cur])&#123; cnt += abs(a[i] - a[cur]); cur = i; &#125; &#125; while(cur&lt;n)&#123; int cur2 = cur+1; for(int i = cur2;i&lt;=n;i++)&#123; if(a[i] &gt;= a[cur2])&#123; cur2 = i; &#125; &#125; cnt+=abs(a[cur2]-a[cur]); cur = cur2; &#125; cnt+=a[n]; cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125; Problem I. 清明梦超能力者黄黄YY是一个清明梦超能力者，同时也是一个记忆大师。他能够轻松控制自己在梦中的一切，在醒来之后还能清晰的记得梦中所有的细节，这让他的朋友们都十分羡慕。 又是一个晚上，黄YY又到了自己的梦中，并且随手造出了一棵有n个点的树，树上每个点有一个初始颜色0。为了让这棵树不那么单调，黄YY拿起了画笔在上面尽情上色。每一次上色可以用u, v, c来描述，代表黄YY把u, v这条路径上的点都染色成了c。 正当黄YY开心的完成了m次染色，准备在早上醒来之时向朋友们炫耀。但现实中的黄YY由于过于兴奋滚到了床下，撞到了脑袋，在剧痛中醒来。由于脑部受到了严重创伤，黄YY对刚才梦境中发生的一切发生了严重的信息丢失。 但英俊潇洒的黄YY当然不希望自己的窘态被朋友们发现。为了证明自己还是那个清明梦超能力者，他希望告诉朋友们自己上色后每个节点的颜色。同时为了更进一步证明他还是个记忆大师，他希望干脆直接说出每个点在倒数第k次染色时的颜色。 当然，现在的黄YY已经成了弱智了，作为黄YY最亲密的朋友，你快来帮帮黄YY吧！ Input第一行三个整数n, m, k，代表树的点数，黄YY染色的次数，以及最后求颜色时，倒数的次数（1 ≤ n, m, k ≤ 100000）。 接下来n − 1行，每行u, v代表u, v两点之间有一条边。这里保证1 ≤ u, v ≤ n，且无重边与自环，是一棵标准的树。 接下来m行，每一行三个数字u, v, c代表黄YY在第这次用c颜色的画笔从u涂到了v。 Output一行n个数字，输出每个点倒数第k次染色时的颜色。如果本身不足k次，输出0。 Examplestandard input 3 3 2 1 2 2 3 1 2 1 2 3 2 1 3 3 standard output 1 2 2 Note对于点1在第一次和第三次染色的时候分别被染色为1, 3，倒数第二次的颜色就是1。 对于点2在第一、二、三次染色的时候分别被染色为1, 2, 3，倒数第二次的颜色就是2。 对于点3在第二次和第三次染色的时候分别被染色为2, 3，倒数第二次的颜色就是2。 思路首先每条路径从LCA处分开可以拆成两条链假设链A-&gt;B执行了第i次染色操作，假设A是B的祖先，那么我们在B点加入一个”插入i”的事件，在A的父亲点加入一个”删除i”的事件然后dfs整颗树求解，每个点维护一个线段树。处理一个点时先合并所有儿子的线段树，然后再处理这个点上的事件，得到线段树之后询问第K大值既可得到答案。复杂度分析：Node merge(Node a, Node* b) { if (a == NULL) return b; if (b == NULL) return a; a-&gt;sum += b-&gt;sum; a-&gt;child[0] = merge(a-&gt;child[0], b-&gt;child[0]); a-&gt;child[1] = merge(a-&gt;child[1], b-&gt;child[1]); return a;}考虑以上的线段树合并，每次合并会减少一个区间。而在事件点插入、删除的时候会产生至多log个区间，因此复杂度为O(NLogN) Problem J. 最短路给一个连通图，每次询问两点间最短路。每条边的长度都是1。 Input第一行两个整数n和m，表示图的点数和边数（1 ≤ n ≤ 100000, 1 ≤ m ≤ n + 100）。 接下来m行每行两个整数a和b，表示一条边（1 ≤ a, b ≤ n）。保证没有自环和重边。保证图连通。 接下来一个整数q表示询问的个数（1 ≤ q ≤ 100000）。 接下来q行每行两个整数a和b表示询问a和b之间的最短路。 Output每个询问输出一行表示答案 Exampleinput 4 51 22 31 44 32 441 41 22 41 3 output 1112 思路本题十分直接。我们不断地把度数为1的点删掉，把度数为2的点收缩，最后会得到一个图，和原图的点数与边数之差相同，且新图中每个点的度数都至少是3。这就是说我们会得到一个200个点300条边以内的图。新图可以用Floyd算法预处理所有点对之间最短路。询问时，将询问转化到新图上即可。转化时需要注意细节。 WANNAFLY_DAY2Problem A. Tobaku Mokushiroku Kaiji开司正在与另外一人玩石头剪刀布。双方各有一些代表石头、剪刀、布的卡牌，每局两人各出一张卡牌，根据卡牌的内容决定这一局的胜负。胜负规则为：石头赢剪刀、剪刀赢布、布赢石头、相同为平局。每张卡牌至多被使用一次。已知双方的卡牌数量，问开司最多赢几局？ Input一行六个数字a, b, c, d, e, f(0 ≤ a, b, c, d, e, f ≤ 50)，a, b, c分别表示开司的石头、剪刀、布的牌的数量，d, e, f分别表示此时另一人的石头、剪刀、布的牌的数量。 Output一个整数表示开司最多赢几局 Examplein 29 7 41 14 12 42 out 33 代码123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[6]; for(int i = 0;i&lt;6;i++) cin&gt;&gt;a[i]; cout&lt;&lt;min(a[0],a[4])+min(a[1],a[5])+min(a[2],a[3])&lt;&lt;endl; return 0;&#125; Problem E. Eustia of the Tarnished WingsNovus Aither是一个潜藏着多个势力的城市。每个势力都有一个唯一的领导人，每个领导人有一个属性值。如果两个势力的领导人的属性值分别为a, b，且|a − b| ≤ m，说明这两个领导人的思想有一定的相似之处，这两个势力可以合并，新的领导人可以指定为原来的两个领导人中的任意一个。新产生的势力可以依照相同的的规则，继续与其他势力合并。问在所有可能的合并情况中，最少会剩下几个势力。 Input第一行两个空格隔开的整数n(1 ≤ n ≤ 106), m(0 ≤ m109)。n代表当前势力的个数。m的含义如题目描述。第二行n个空格隔开的整数di(0 ≤ di ≤ 109)，代表第i个势力的领导人的属性值。 Output输出一个数表示势力的最少数量。 Examplestandard input4 12 1 3 10 standard output 2 代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1e6+7;ll a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); int cnt = 1; for(int i = 1;i&lt;n;i++)&#123; if(a[i]-a[i-1]&gt;m) cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; WANNAFLY_DAY3Problem D. Shopping你要买n件物品，其中有一些是凳子。商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个物品。你有m辆购物车，请最小小化你的花费。 Input第一行一个整数t表示数据组数(1 ≤ t ≤ 100)。 每组数据第一行两个整数n, m (1 ≤ n, m ≤ 1000)，接下来n行每行两个整数ai, bi，分别表示第i件物品的价格以及它是否是凳子(1 ≤ ai ≤ 105, 0 ≤ bi ≤ 1)。 Output每组数据输出一行一个实数表示最小花费，保留一位小数。 Examplestdin25 11 02 13 14 05 05 101 02 13 14 05 0 stdout 12.510.5 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 1007;struct node&#123; double cost; int flag;&#125;a[maxn];int cmp(node a,node b)&#123; return a.cost&gt;b.cost;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m; int cnt = 0; double all = 0; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i].cost; cin&gt;&gt;a[i].flag; if(a[i].flag==1) cnt++; all+=a[i].cost; &#125; if(cnt&gt;m) cnt = m; sort(a,a+n,cmp); for(int i = 0;i&lt;cnt;i++)&#123; all-=(a[i].cost/2.0); &#125; printf(&quot;%.1lf\n&quot;,all); &#125; return 0; &#125; WANNAFLY_DAY47 贵族用户终于活成了自己讨厌的样子。充钱能让你变得更强。 在暖婊这个游戏里面，如果你充了 x 元钱，那么你能获得 10x 个钻石。同时暖婊也有 m 档VIP，如果你往暖婊里面充了 ai 个钻石，那么你能成为第 i 档贵族用户。当你成为为第 i 档贵族用户。当你成为第 i 档贵族用户之后，那么你可以获得 pi% 的优惠。 你需要 k 件材料合成衣服，其中第 i 件材料原价为 di 个钻石，你一共需要 ci 件这种材料。当你获得 p 的优惠时，这个材料的真实价格为 ⌈di(1 − p)⌉。请问栗子米最少需要氪多少钱，这里我们规定只能氪整数的钱。 7.2 输入格式第一行一个整数 T(T ≤ 1000)，表示数据组数。每组数据第一行两个整数 m, k(1 ≤ m, k ≤ 15)。 接下来 m 行每行两个正整数 1 ≤ ai ≤ 105, 1 ≤ pi ≤ 100，保证 ai &lt; ai+1, pi ≤ pi+1。接下来 k 行每行两个正整数 1 ≤ ci, di ≤ 1000。 7.3 输出格式对于每组数据，输出一个整数，表示至少要氪多少钱。 7.4 样例输入11 1100 100100 100 7.5 样例输出10 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int m,k;struct node&#123; int a; int p;&#125;vip[20];struct cost&#123; int cc; int dd;&#125;dim[20];int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;m&gt;&gt;k; for(int i = 0;i&lt;m;i++)&#123; cin&gt;&gt;vip[i].a&gt;&gt;vip[i].p; if(vip[i].a%10) vip[i].a+=10-(vip[i].a%10); &#125; int ans = 0; for(int i = 0;i&lt;k;i++)&#123; cin&gt;&gt;dim[i].cc&gt;&gt;dim[i].dd; ans+=dim[i].cc*dim[i].dd; &#125; if(ans%10) ans+=10-(ans%10); int minx = ans; for(int u = 0;u&lt;m;u++)&#123; int ans2 = 0; for(int i = 0;i&lt;k;i++)&#123; ans2 += dim[i].cc*(ceil((1-((double)vip[u].p/100.0))*dim[i].dd)); &#125; if(ans2%10)&#123; ans2+=10-(ans2%10); &#125; if(ans2&lt;=vip[u].a)&#123; ans2 = vip[u].a; &#125; minx = min(minx,ans2); &#125; cout&lt;&lt;minx/10&lt;&lt;endl; &#125; return 0;&#125; WANNAFLY_DAY6F平衡二叉树 代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 70;ll n,d;ll a,b;ll c[maxn];int main()&#123; cin&gt;&gt;n&gt;&gt;d; a = 1; b = 0; memset(c,0,sizeof(c)); for(int i = 0;i&lt;n-1;i++) a*=2; a-=1; for(int i = 0;i&lt;=d;i++)&#123; c[i] = 1; &#125; c[d+1] = 2; for(int i = d+2;i&lt;n-1-d;i++)&#123; c[i] = c[i-1]+c[i-d-1]; &#125; for(int i = 0;i&lt;n-1-d;i++) b+=c[i]; cout&lt;&lt;a-b&lt;&lt;endl; return 0;&#125; H卡牌游戏 代码123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; for(int u = 1;u&lt;=t;u++)&#123; long double x,y; int z; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;z; printf(&quot;Case #%d: &quot;,u); long double ans = 0; for(int i = 0;i&lt;z;i++)&#123; ans += x/y; x--; y--; &#125; printf(&quot;%Lf\n&quot;,ans); &#125; return 0;&#125; WANNAFLY_DAY7A.机器学习 代码12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double n; cin&gt;&gt;n; printf(&quot;%.2lf\n&quot;,n); return 0;&#125; D最小生成树 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 1e5+7;ll a[maxn];int main()&#123; int n; cin&gt;&gt;n; ll minx = 0x3fffffff; ll sum = 0; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; minx = min(minx,a[i]); sum+=a[i]; &#125; sum += minx*(n-1); sum-=minx; cout&lt;&lt;sum&lt;&lt;endl;; return 0;&#125; G区间权值 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxx = 1e7+7;const int maxn = 300007;const int mod = 1e9+7;ll a[maxn] = &#123;0&#125;;ll w[maxn] = &#123;0&#125;;ll dpa[maxn] = &#123;0&#125;;ll dpb[maxn] = &#123;0&#125;;ll dpl[maxn] = &#123;0&#125;;ll dpr[maxn] = &#123;0&#125;;int n;void init()&#123; for(int i = 1;i&lt;=n;i++)&#123; int tmp = min(i,n-i+1); dpb[i] = tmp*dpa[n]%mod; dpb[i] -= dpl[tmp-1]; dpb[i] -= dpr[n-tmp+2]; dpb[i]%=mod; dpb[i] *= w[i]; dpb[i]%=mod; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; dpa[i] = a[i]; dpa[i]+=dpa[i-1]; dpa[i]%=mod; dpl[i] = dpl[i-1]; dpl[i]+=dpa[i]; dpl[i]%=mod; &#125; dpr[n+1] = 0; for(int i = n;i&gt;=1;i--)&#123; dpr[i] = dpr[i+1]; dpr[i]+=dpa[n]-dpa[i-1]; dpr[i]%=mod; &#125; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;w[i]; &#125; ll ans = 0; init(); for(int i = 1;i&lt;=n;i++)&#123; ans+=dpb[i]; ans%=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; I联通块计数 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxx = 1e7+7;const int maxn = 1e5+7;const ll mod = 998244353;int n;ll a[maxn];ll dp[maxn];void init()&#123; for(int i = 0;i&lt;n;i++)&#123; dp[i] = a[i]; dp[i]%=mod; if(i&gt;0)&#123; dp[i]*=dp[i-1]; dp[i]%=mod; dp[i]+=a[i]; dp[i]%=mod; dp[i]+=dp[i-1]; dp[i]%=mod; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; ll ans = 1; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; ans+=(a[i]*(a[i]+1)/2)%mod; ans%=mod; &#125; init(); if(n&gt;0)&#123; ans+=dp[n-1]; ans%=mod; &#125; cout&lt;&lt;ans%mod&lt;&lt;endl; return 0;&#125; J寻找复读机 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+7;int n,m;int vis[maxn];int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof(vis)); string str1, tmp; int d; while(m--)&#123; cin&gt;&gt;d; cin&gt;&gt;tmp; if(str1==tmp)&#123; if(vis[d]!=-1) vis[d]++; &#125; else&#123; vis[d]=-1; &#125; str1 = tmp; &#125; int flag = 0; for(int i = 1;i&lt;=n;i++)&#123; if(vis[i]!=-1)&#123; if(flag==0)&#123; cout&lt;&lt;i; flag = 1; &#125; else cout&lt;&lt;&apos; &apos;&lt;&lt;i; &#125; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM/ICPC</tag>
        <tag>wannafly</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sg函数与nim博弈]]></title>
    <url>%2F2018%2F07%2F28%2F2018-07-28%2F</url>
    <content type="text"><![CDATA[内容：sg函数 时间：2018-7-28 课件by.浅悠悠 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>sg函数</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.26图论基础专项训练题解]]></title>
    <url>%2F2018%2F07%2F26%2F2018-07-26%2F</url>
    <content type="text"><![CDATA[问题 A: 签到题之青蛙爬楼梯时间限制: 1 Sec 内存限制: 128 MB提交: 117 解决: 37[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述楼梯有n阶台阶，青蛙每次可以跳1~n阶台阶，问青蛙共有多少种上楼梯的方法。 输入输入仅一行，一个整数n（n&lt;=50） 输出输出n阶台阶对应上楼梯的方法。 样例输入13 样例输出14 提示本题作为水题，不作为图论题。样例提示（1，1，1），（1，2），（2，1），（3）共4种方法 题解第n阶台阶，我们可以从n-1跳到n，可以从n-2跳到n……可以从1跳到n，也可以从0跳到n。那么要求第n阶的数量，只需求前n-1阶，前n-2阶……前1阶的方法，所以我们列出关系式为F(n)=F(n-1)+F(n-2)+……+F(1)+1。同理，第n-1阶的关系式为F(n-2)+F(n-3)+……+F(1)+1。两个式子合并得F(n)=2*F(n-1)。由于F(1)=1,所以F(n)=2^(n-1)。 代码参考12345678910#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main()&#123; int n; cin&gt;&gt;n; ll a = pow(2,n-1); cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 问题 B: 排名时间限制: 1 Sec 内存限制: 128 MB提交: 60 解决: 24[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述有 N 个比赛队（1&lt;=N&lt;=500），编号依次为 1，2，3……N 进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即 P1 赢 P2，用 P1，P2 表示，排名时 P1 在 P2之前。现在请你编程序确定排名。 符合条件的排名可能不是唯一的。此时要求输出时编号小的队伍在前。输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。 输入输入有若干组。每组中的第一行为二个数N（1&lt;=N&lt;=500）。M；当中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中。每行也有两个整数P1。P2表示即P1队赢了P2队。 输出给出一个符合要求的排名。输出时队伍号之间有空格。最后一名后面没有空格。 样例输入12344 31 44 32 3 样例输出11 2 4 3 题解拓扑排序模板题，唯一可能出现问题的地方就是题目要求同样拓扑序的两个编号小的要在前面，这点可以通过将普通拓扑排序中的队列改为使用优先队列或者堆来实现。 代码参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;const int maxn=510;int graph[maxn][maxn];//保存图int degree[maxn];//保存入度int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; memset(graph,0,sizeof(graph)); memset(degree,0,sizeof(degree)); for(int i=0;i&lt;m;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(!graph[u][v]) &#123; graph[u][v]=1; degree[v]++;//的入度++ &#125; &#125; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=1;i&lt;=n;i++) if(degree[i]==0) q.push(i); bool first=1; while(!q.empty()) &#123; int cur=q.top(); q.pop(); if(first) &#123; cout&lt;&lt;cur; first=0; &#125; else cout&lt;&lt;&quot; &quot;&lt;&lt;cur; for(int i=1;i&lt;=n;i++) &#123; if(graph[cur][i]==1) &#123; degree[i]--;//相连的点的入度减1 if(degree[i]==0)//假设入度为0，增加队列 q.push(i); &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 问题 C: 系兄弟就来砍我时间限制: 1 Sec 内存限制: 128 MB提交: 34 解决: 10[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述渣渣灰因为一句“大家好，我系渣渣辉，系兄弟就来砍我”引得众粉丝纷纷拿两米长的大刀寻找。现有n个据点，编号（1~n），有m条单向路使据点相连。每个据点仅有一个人。这n个人中有k个粉丝。其中渣渣灰在s据点处。请问这k个粉丝到渣渣灰的最短距离是多少 输入首行输入nmks。(k&lt;=n&lt;=100m&lt;=500)s为渣渣灰所在位置 接下来m行，每行输入xyz，表示从x到y的距离是z，由于是单向边，则y到x的距离不一定是z。 接下来k个数字，表示粉丝所在据点。 输出对于每一个粉丝，输出对应的最短距离。 样例输入123453 3 2 11 2 12 3 13 1 12 3 样例输出12 1 提示数据保证k个粉丝均能到达渣渣灰的据点 题解首先，既然要求k个点到s点的最短路，我们可以反过来求s到这k个点的最短路。这样就变成了单源最短路问题，dijkstra算法和spfa算法都可以做。由于图为有向图，我们在存图时反向存图即可，原本a[i][j]表示i-&gt;j，我们可以将它重新定义为j-&gt;i，或者存图时直接写成a[j][i]即可。 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷infint n,m,k,s;int dis[maxn]; //储存各个点到源点的最短距离,dis[s]为0int road[maxn][maxn]; //两点之间直接距离关系bool vis[maxn]; //判断源点到该点的距离是否为最短距离int fans[maxn];void dijkstra(int s)&#123; memset(vis, false, sizeof(vis)); vis[s] = true; for(int i = 1; i &lt;= n; i++) dis[i] = road[s][i]; for(int u = 1; u&lt;n; u++) &#123; int minD = inf,k = -1; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[i]&lt;minD) &#123; k = i; minD = dis[i]; &#125; &#125; vis[k] = true; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i]) &#123; dis[i]=dis[k]+road[k][i]; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s; memset(road,inf,sizeof(road)); for(int i = 1; i&lt;=m; i++) &#123; int tmp; int x,y; cin&gt;&gt;x&gt;&gt;y&gt;&gt;tmp; road[y][x]=tmp; &#125; dijkstra(s); for(int i = 0; i&lt;k; i++) &#123; cin&gt;&gt;fans[i]; &#125; for(int i = 0; i&lt;k-1; i++) cout&lt;&lt;dis[fans[i]]&lt;&lt;&apos; &apos;; cout&lt;&lt;dis[fans[k-1]]&lt;&lt;endl; return 0;&#125; 问题 D: 躁动的小Z时间限制: 1 Sec 内存限制: 128 MB提交: 7 解决: 2[提交][状态][讨论版][命题人:外部导入][Edit] [TestData)] 题目描述你猜怎么样？小Z追到Gakki了！Gakki邀请小Z去她家共进晚餐，小Z喜出望外。小Z的家和Gakki的家隔着几个街区，所以他决定乘坐公交车前往 Gakki家赴约。小Z的家在公交站台的起始站（编号为1），而Gakki家正好在末站（编号为n）。城市中有许多公交站台，有些站台之间可以通过公交 线路互相到达。现在给你n个公交站台和m条不同的公交线路的时间花费，请你帮助小Z分析一下最短的可以从家里来到Gakki身边的路径？ 输入有多组测试样例。 第一行两个正整数n,m(2≤n≤10^5,0≤m≤10^5)，代表站台数与公交线路数量。 接下来m行每行三个正整数a[i],b[i],w[i],代表从公交站a[i]到b[i]需要花费的时间为w[i]。(1≤a[i],b[i]≤n,1≤w[i]≤10^6) 注意：公交线路可能会产生环，并且两个站台之间可能有多条公交线路。 输出单独一行，输出花费时间最小时小Z经过的公交站台编号，以空格隔开；如果小Z无法到达Gakki的家，则输出-1. 样例输入12345675 61 2 22 5 52 3 41 4 14 3 33 5 1 样例输出11 4 3 5 题解半年前写的代码。其实原理很简单，在dijkstra算法模板的基础上加上一个pre数组，用于记录该节点的上一个节点，即该点是经过哪一点才到达该点的。pre数组具体在边松弛的过程中进行重新赋值，松弛成功就将pre值记录k点，及该点是由起点经过k点后所得到的。最后把pre数组中的值递归输出一遍即可。 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;string.h&gt; #include&lt;stdlib.h&gt;#define max 900000typedef struct &#123; int d; int pre;&#125;path;path to[1000 + 2];int g[1000 + 2][1000 + 2], vis[1000 + 2]; void fun(int ddd) &#123; if (ddd == 1) &#123; printf(&quot;%d&quot;, ddd); return; &#125; int j= to[ddd].pre; fun(j); printf(&quot; %d&quot;, ddd);&#125;int main() &#123; int n, m, a, b, v, i, j, min, k, from; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; memset(vis, 0, sizeof(vis)); for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; g[i][j] = max; &#125; to[i].d = max; &#125; for (i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v); g[a][b] = v; g[b][a] = v; &#125; for (i = 2; i &lt;= n; i++) &#123; to[i].d = g[1][i]; if (g[1][i] != max) &#123; to[i].pre = 1; &#125; &#125; vis[1] = 1; for (i = 2; i &lt;= n; i++) &#123; min = max; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123; min = to[j].d; k = j; &#125; &#125; vis[k] = 1; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123; to[j].d = to[k].d + g[k][j]; to[j].pre = k; &#125; &#125; &#125; fun(n); printf(&quot;\n&quot;); &#125; return 0;&#125; 问题 E: 逛街时间限制: 1 Sec 内存限制: 128 MB提交: 8 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述假设渣渣灰有一个女朋友，他的女朋友要他陪着一起去公园。由于渣渣灰不喜欢运动，所以他想找一条最短的路到达公园。由于途中会有许多消费点，而每到一个消费点女朋友就要购物，而渣渣灰比较抠，所以假如有多条最短路，则他会选择途中消费点最便宜的。给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 输入输入nm，点的编号是1~n然后是m行，每行4个数 abdp，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 st;起点s，终点。n和m为0时输入结束。(1&lt;n&lt;=1000 0&lt;m&lt;100000 s != t) 输出输出 一行有两个数， 最短距离及其花费。 样例输入1234563 21 2 5 62 3 4 51 30 0 样例输出19 11 提示输入样例的空行只是为了让大家分辨数据，输入有没有空行都没关系。输出样例没有空行。 题解同上一道题的方法，我们再创建一个value数组储存花费情况。在松弛时对value进行改变。松弛成功则value（s-&gt;i）=value(s-&gt;k-&gt;i)。若最短路相等则对value值进行比较，即value（s-&gt;i）=min(value(s-&gt;k-&gt;i),value（s-&gt;i))。s为源点，i为当前终点，k为中间点。最终输出最短路及对应value值即可。 代码参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define INF 0x3f3f3f3f#define Min(a,b) a&gt;b?b:astruct Node&#123; int adj,val;&#125;g[1005][1005];int dist[1005];//距离int value[1005];//费用int used[1005];//标记int n,m,i,j;void Dijkstra(int s)&#123; memset(dist,0x3f,sizeof(dist)); memset(value,0x3f,sizeof(value)); memset(used,0,sizeof(used)); dist[s]=0;//从起点开始 value[s]=0; while(1) &#123; int k,u=-1,d[1005]; int min=INF; memset(d,0,sizeof(d)); for(i=1;i&lt;=n;i++) if(used[i]==0&amp;&amp;dist[i]&lt;min)//找出从起点到下一个最小距离的顶点 &#123; min=dist[i]; u=i;//记录下标 &#125; if(u==-1)//判断所有顶点是否都到达过 return ; for(i=1,k=0;i&lt;=n;i++) if(dist[u]==dist[i]&amp;&amp;used[i]==0) d[k++]=i;//从起点到下一个要访问的顶点的最小距离可能有多个 for(i=0;i&lt;k;i++) used[d[i]]=1; for(i=0;i&lt;k;i++)//多个满足的点分别进行迪杰斯特拉最短路查找 for(j=1;j&lt;=n;j++) if(g[d[i]][j].adj!=INF &amp;&amp; (dist[d[i]]+g[d[i]][j].adj)&lt;=dist[j]) &#123;//原理与 main()函数中建立邻接矩阵一样 if((dist[d[i]]+g[d[i]][j].adj)&lt;dist[j]) value[j]=value[d[i]]+g[d[i]][j].val; else value[j]=Min(value[j],value[d[i]]+g[d[i]][j].val); dist[j]=dist[d[i]]+g[d[i]][j].adj; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (n||m)) &#123; int a,b,d,p; memset(g,0x3f,sizeof(g)); for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;d,&amp;p); if(d&lt;=g[a][b].adj)//处理路径距离问题 &#123; if(d==g[a][b].adj)//如果距离相等，则存放最少的费用 g[a][b].val=g[b][a].val=Min(p,g[a][b].val); else//否则，存放新路径距离的费用 g[a][b].val=g[b][a].val=p; g[a][b].adj=g[b][a].adj=d;//填充路径距离 &#125; &#125; int s,t; scanf(&quot;%d%d&quot;,&amp;s,&amp;t); Dijkstra(s); printf(&quot;%d %d\n&quot;,dist[t],value[t]); &#125; return 0;&#125; 问题 F: 足球时间限制: 1 Sec 内存限制: 128 MB提交: 3 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述yoyo得到了一个足球，这个足球与其他的足球一样，表面有 12 个正五边形和 20 个正六边形组成，足球的每个面初始的时候都为白色。现在yoyo把这个足球拆解开来，32个面编号为1~32。爱画画的yoyo希望将足球的某些面涂为黑色（可能是 0 个），在每次涂色操作中，慢慢只可以将某一些相邻或者联通的面一起涂为黑色（两个面相邻当且仅当他们共用一条边）。例如，yoyo可以在一次涂色操作中将面 1、2、3、4、5 涂为黑色，但是他不可以将面11 和 24 涂为白色，因为面 11 和 24 是不相邻也不联通的。求yoyo所需要的最少的涂色次数。 输入第一行包含一个整数 t，表示有t组测试数据，对于每组测试数据： 输入包含一行，该行包含 32 个整数，每个数的值等于 0 时表示白色，等于 1 时表示黑色。 输出对于每组测试数据，输出Case c: ans，其中 c 为测试数据编号，ans 为最少的操作次数。 样例输入123431 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 样例输出123Case 1: 1Case 2: 0Case 3: 2 提示除了相邻的数面也相邻外，面 1 和面 13 是相邻的，面 13 和面 17 是相邻的，面 17 和面 32 是相邻的，面 15 和面 32 是相邻的，面 19 和面 32 是相邻的。 PS:1和32不相邻。 题解先把所有相邻的点赋值为1，再用Floyd算法把所有点之间的最短距离打表求出来。之后每输入一组样例，则对样例中的1dfs深搜，然后深搜把所有相邻为1且值为1的点重新赋值为0。最后记录下主循环中dfs的次数即可。 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 32 + 1;int dis[maxn][maxn];int vis[maxn];void init()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); dis[32][32] = 0; for(int i = 1; i &lt; maxn - 1; i++)&#123; dis[i][i] = 0; dis[i][i + 1] = 1; dis[i + 1][i] = 1; &#125; dis[1][13] = dis[13][1] = 1; dis[17][13] = dis[13][17] = 1; dis[17][32] = dis[32][17] = 1; dis[15][32] = dis[32][15] = 1; dis[19][32] = dis[32][19] = 1; for(int k = 1; k &lt; maxn; k++)&#123; for(int i = 1; i &lt; maxn; i++) for(int j = 1; j &lt; maxn; j++) if(dis[i][j] &gt; dis[i][k]+dis[k][j]) dis[i][j] = dis[i][k]+dis[k][j]; &#125;&#125;void dfs(int x)&#123; vis[x] = 0; for(int i = 1; i &lt; maxn; i++)&#123; if(vis[i]&amp;&amp;dis[x][i]==1) dfs(i); &#125;&#125;int main()&#123; init(); int t; cin&gt;&gt;t; for(int u = 1;u &lt;= t;u++)&#123; for(int i = 1;i &lt; maxn; i++) cin&gt;&gt;vis[i]; int ans = 0; for(int i = 1; i &lt; maxn; i++)&#123; if(vis[i])&#123; ans++; dfs(i); &#125; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 问题 G: 牌时间限制: 1 Sec 内存限制: 128 MB提交: 2 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌i，j，得到一个ai bj + bi aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。 输入首行输入n，代表n个点 接下来n行，每一行两个属性ab第i行代表第i张牌，属性为ai，bi。数据范围保持在200以内。 输出输出最大分数 样例输入12345652 43 31 72 54 4 样例输出1108 题解主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;string.h&gt; #include&lt;stdlib.h&gt;#define max 900000typedef struct &#123; int d; int pre;&#125;path;path to[1000 + 2];int g[1000 + 2][1000 + 2], vis[1000 + 2]; void fun(int ddd) &#123; if (ddd == 1) &#123; printf(&quot;%d&quot;, ddd); return; &#125; int j= to[ddd].pre; fun(j); printf(&quot; %d&quot;, ddd);&#125;int main() &#123; int n, m, a, b, v, i, j, min, k, from; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; memset(vis, 0, sizeof(vis)); for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; g[i][j] = max; &#125; to[i].d = max; &#125; for (i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v); g[a][b] = v; g[b][a] = v; &#125; for (i = 2; i &lt;= n; i++) &#123; to[i].d = g[1][i]; if (g[1][i] != max) &#123; to[i].pre = 1; &#125; &#125; vis[1] = 1; for (i = 2; i &lt;= n; i++) &#123; min = max; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123; min = to[j].d; k = j; &#125; &#125; vis[k] = 1; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123; to[j].d = to[k].d + g[k][j]; to[j].pre = k; &#125; &#125; &#125; fun(n); printf(&quot;\n&quot;); &#125; return 0;&#125; 常用模板代码拓扑排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=510;int graph[maxn][maxn];//保存图int degree[maxn];//保存入度int TOP[maxn];//保存已删除点int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; int now = 0；//指针作用记录TOP中可插入的位置 memset(graph,0,sizeof(graph)); memset(degree,0,sizeof(degree)); for(int i=0;i&lt;m;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(!graph[u][v]) &#123; graph[u][v]=1; degree[v]++;//v的入度++ &#125; &#125; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++) if(degree[i]==0) q.push(i); while(!q.empty()) &#123; int cur=q.front(); q.pop(); TOP[now++]=cur; for(int i=1;i&lt;=n;i++) &#123; if(graph[cur][i]==1) &#123; degree[i]--;//相连的点的入度减1 if(degree[i]==0)//假设入度为0，增加队列 q.push(i); &#125; &#125; &#125; //这里可以添加输出，排序已保存在TOP数组中 &#125; return 0;&#125; dijkstra（单元最短路径）1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷infint n,m,k,s;int dis[maxn]; //储存各个点到源点的最短距离,dis[s]为0int road[maxn][maxn]; //两点之间直接距离关系bool vis[maxn]; //判断源点到该点的距离是否为最短距离void dijkstra(int s)&#123; memset(vis, false, sizeof(vis)); vis[s] = true; for(int i = 1; i &lt;= n; i++) dis[i] = road[s][i]; for(int u = 1; u&lt;n; u++) &#123; int minD = inf,k = -1; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[i]&lt;minD) &#123; k = i; minD = dis[i]; &#125; &#125; vis[k] = true; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i]) &#123; dis[i]=dis[k]+road[k][i]; &#125; &#125; &#125;&#125;int main()&#123; memset(road,inf,sizeof(road)); //主函数添加程序与数据以及调用dijkstra return 0;&#125; SPFA（单元最短路径，可带负环）1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define N 105int res[N];//存储源点到每个顶点的最短距离值int g[N][N];int cnt[N];//每个点入队次数，判断是否出现负环int que[N*N];//队列bool in_que[N];//标记一个点是否已在队列中int front;//队首位置int rear;//队尾位置void spfa(int n,int src)&#123; rear=front=0; que[++rear]=src; memset(res,0x3f3f3f3f,sizeof(res)); memset(in_que,0,sizeof(in_que)); res[src]=0; while(front&lt;rear) &#123; int cur=que[++front]; in_que[cur]=0; int i; for(i=1; i&lt;=n; i++) &#123; if(res[cur]+g[cur][i]&lt;res[i]) &#123; res[i]=res[cur]+g[cur][i]; if(!in_que[i]) &#123; que[++rear]=i; in_que=1; &#125; &#125; &#125; &#125;&#125; Floyed（全源最短路径）123456789for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) /* 实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j] 都不是Inf ，只要一个是Inf，那么就肯定不必更新。 */ if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j]; Prim最小生成树1234567891011121314151617181920void Prim()&#123; int i,j,k,tmp,ans; for(i=1;i&lt;=n;i++) dis[i]=inf;//初始化 dis[1]=0; for(i=1;i&lt;=n;i++)&#123; tmp=inf; for(j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123; tmp=dis[j]; k=j; &#125;//找出最小距离的节点 &#125; vis[k]=1;//把访问的节点做标记 for(j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;dis[j]&gt;map[k][j]) dis[j]=map[k][j];//更新最短距离 &#125; &#125;&#125; kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1007;int n,m;struct Edge&#123; int x; int y; int l;&#125; edge[maxn];int fa[maxn];int init()&#123; for(int i = 0; i&lt;maxn; i++) fa[i] = i;&#125;int findfa(int x)&#123; return fa[x] == x ? x : (fa[x] = findfa(fa[x]));&#125;int merge_1(int x,int y)&#123; fa[findfa(x)] = findfa(y);&#125;int kruskal()&#123; int cnt = 0; int sum = 0; for(int i = 0; i&lt;= m; i++) &#123; int fx = findfa(edge[i].x); int fy = findfa(edge[i].y); if(fx!=fy) &#123; merge_1(fx,fy); cnt++; sum+=edge[i].l; if(cnt&gt;=n-1) break; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;int main()&#123; init(); //此处填写边以及点等待输入数据，填写完成后须对边的权值进行排序 kruskal(); return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论1（拓扑排序 + 最短路 + 最小生成树）]]></title>
    <url>%2F2018%2F07%2F26%2F2018-07-26-1%2F</url>
    <content type="text"><![CDATA[内容：图论基础 时间：2018-7-26 课件by.浅悠悠 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA算法</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.20-C++标本模板库stl]]></title>
    <url>%2F2018%2F07%2F20%2F2018-07-20-1%2F</url>
    <content type="text"><![CDATA[内容：stl 时间：2018-7-20 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.20-stl专项训练题解]]></title>
    <url>%2F2018%2F07%2F20%2F2018-07-20%2F</url>
    <content type="text"><![CDATA[问题A问题A同问题B，具体方法在问题B中介绍，此处仅贴代码 输入首行输入t，代表t组测试样例 对于每一行，输入四个整数a，b，c，d 输出对于每组样例，输出一个整数表示答案 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int maxn = 9;ll a[4], sum[4] = &#123; 0 &#125;;ll dp[maxn * 4][maxn * 4];//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; &#125; dp[i][i] = 1; &#125;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--)&#123; init();//打表 ll ans = 1; //这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里 for (int i = 0; i &lt; 4; i++) &#123; !i ? sum[i] = 0 : sum[i] = sum[i - 1]; cin &gt;&gt; a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i]; &#125; //将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d) for (int i = 1; i &lt; 4; i++) &#123; ans *= dp[sum[i]][a[i]]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; return 0;&#125; 问题 B: yoyo思维题(困难)问题A同问题B 提交: 4 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述小琳，小花，小薇，yoyo，他们每个人手上有一堆牌，牌的张数分别为x1，x2，x3，x4，每张牌都不一样。现有n名同学，n=x1+x2+x3+x4。每名同学均需要一张牌，于是他们按顺序每人随机到四个人那里拿取牌顶的一张牌，最后一个人刚好拿到剩下的最后一张牌。排队拿牌的同学的顺序是固定的，选择拿谁的牌是不确定的。假如发牌的人手上的牌发完了，则要拿牌的同学会选择其他发牌的人。请问有多少种取法取走所有的牌。 输入首行输入t，代表t组测试样例 对于每一行，输入四个整数a，b，c，d，输入为均不超过500的正整数 输出对于每组样例，输出一个整数表示答案，答案对10^9+7取模 样例输入1215 4 2 3 样例输出12522520 提示本题作为思维题，并未用到stl，仅锻炼一下大家解决问题的能力。用到的数学知识相对多一点。 题解题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是C(b,a+b);那么三堆的话我们可以把前两堆看成一堆，那么表达式就是C(c,a+b+c)，这是我们需要与前两堆的组成方法相乘，就是C(b,a+b)C(c,a+b+c)。4堆的话就是C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。所以答案就是C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。此外，有一公式C(a,b) = C(a,b-1)+C(a-1,b-1)，所以我们用数组来代替C(m,n)操作 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int maxn = 501;const ll mod = 1000000007;ll a[4], sum[4] = &#123; 0 &#125;;ll dp[maxn * 4][maxn * 4];//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; dp[i][j] %= mod; &#125; dp[i][i] = 1; &#125;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--)&#123; init();//打表 ll ans = 1; //这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里 for (int i = 0; i &lt; 4; i++) &#123; !i ? sum[i] = 0 : sum[i] = sum[i - 1]; cin &gt;&gt; a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i]; &#125; //将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d) for (int i = 1; i &lt; 4; i++) &#123; ans *= dp[sum[i]][a[i]]; ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; return 0;&#125; 问题 C: 悠派计算器提交: 4 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit][TestData)] 题目描述yoyo的小老弟小渣渣灰特别懒，兴趣爱好并不多，就睡觉一个。为了多睡会儿懒觉，他把数学老师布置的作业全部推给yoyo计算。yoyo很头疼，于是请你帮他写一个计算器帮忙计算。现有多个数学表达式，请你写一个计算器算出结果，表达式只包含’+’’-‘’*’’/‘’%’’(‘’)’操作，其中表达式中’-‘作为减运算符，不会作为负号出现，此外’/‘为整除运算符，’%’为取余运算符。表达式保证合法。 输入输入第一行t，表示共有t行测试用例，接下来t行每一行均为一个合法的数学表达式。保证每个数在[09999]范围内，保证计算过程中不会出现超范围情况。（注：没有空格） 输出输出计算结果 样例输入1234567870*15%61-2*(3+4*5%6)+7/8-9*10%11*12(1+2*3)1-(100%5)(3+2*5)/(5)(11-11)+(33)*64-11 样例输出123456705-1357122101 提示数据很水，不用考虑long long或取余等情况。 题解逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)(c+d)转换为ab+cd+ 如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。 例如(a+b)(c+d)转换为ab+cd+ 计算机在计算普通表达式时，要对运算优先级用递归进行判断，对于更为复杂的表达式会使计算机运算效率变低甚至崩溃。而逆波兰表达式只需要进行简单的入栈出栈操作就可以完成任何普通表达式的运算。 普通表达式——&gt;逆波兰表达式 (1)a+b——&gt;a b + (2)a+(b-c)——&gt;a b c - + (3)a+(b-c)d——&gt;a b c - d + 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100007;map&lt;char,int&gt;Pri;//其实可以不必用map，只是为了方便大家理解map而多添加的一步stack&lt;int&gt;num;stack&lt;char&gt;Ope;char str[maxn];//初始化void init()&#123; Pri[&apos;+&apos;] = Pri[&apos;-&apos;] = 1; Pri[&apos;*&apos;] = Pri[&apos;/&apos;] = Pri[&apos;%&apos;] = Pri[&apos;(&apos;] = Pri[&apos;)&apos;] = 2; while(!num.empty()) num.pop(); while(!Ope.empty()) Ope.pop();&#125;//基本运算操作void operation_1(int &amp;a,int &amp;b, char c)&#123; if(c == &apos;+&apos;) a += b; else if(c == &apos;-&apos;) a = b-a; else if(c == &apos;*&apos;) a *= b; else if(c == &apos;/&apos;) a = b/a; else if(c == &apos;%&apos;) a = b%a;&#125;//遇到+或者)时执行的操作void operation_2()&#123; char ch = Ope.top(); while(ch != &apos;(&apos;&amp;&amp;!Ope.empty())&#123; Ope.pop(); int a = num.top(); num.pop(); int b = num.top(); num.pop(); operation_1(a,b,ch); num.push(a); if(!Ope.empty()) ch = Ope.top(); &#125; if(!Ope.empty()&amp;&amp;Ope.top() == &apos;(&apos;) Ope.pop();&#125;int main()&#123; int t; cin&gt;&gt;t;getchar(); while(t--)&#123; cin.getline(str,maxn); stringstream s(str); init(); char tmp; while(s &gt;&gt; tmp)&#123; //遇到数字字符时，需要判断下一位是否依旧是数字，是的话需要合并 if(tmp &gt;= &apos;0&apos; &amp;&amp; tmp &lt;= &apos;9&apos;)&#123; int t = 0; do&#123; if(Pri[tmp])&#123; break; &#125; t *= 10; t += tmp - &apos;0&apos;; &#125;while(s &gt;&gt; tmp); num.push(t); &#125; //遇到&apos;)&apos;时 if(tmp == &apos;)&apos;)&#123; operation_2(); &#125; //遇到&apos;+&apos; ‘-’时 else if(Pri[tmp]==1)&#123; if(!Ope.empty()&amp;&amp;Ope.top()!=&apos;(&apos;)&#123; operation_2(); &#125; Ope.push(tmp); &#125; else if(Pri[tmp])&#123; Ope.push(tmp); &#125; &#125; int ans = num.top(); num.pop(); while(!num.empty()&amp;&amp;!Ope.empty())&#123; operation_1(ans,num.top(),Ope.top()); Ope.pop(); num.pop(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 问题 D: 留胡子提交: 53 解决: 6[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述众所周知，刘虎子同学爱留胡子，人送外号刘胡子。为了留一抹性感又忧郁的小胡子，刘虎子专门与yoyo合作研发了一套算法，俗称油胡子算法。油胡子算法原理很简单，要想获得油胡子，首先将胡子从左到右分为n撮胡子，第i撮胡子的平均长度为xi。现每次从n中选出最左边的相邻胡子长度之差的绝对值为1的两撮胡子，减掉较长的1撮胡子，减掉的那撮胡子可以认为从n撮胡子中删除，剩下n-1撮胡子待修剪，再将剩下的n-1撮胡子从左到右重新排列成相邻的数继续如此操作，直到没有两撮相邻差的绝对值为1的胡子为止。此时的胡子称为完美油胡子。请问刘虎子同学最多需要剪多少次才能得到自己心仪的性感小胡子。 输入输入第一行为n，接下来一行n个数x1x2…xi…xn。 输出输出最多执行次数。 样例输入1263 2 3 1 0 1 样例输出15 题解用栈来维护每次合并完的数，每入栈一个数以后栈顶和次栈顶比较，如果可以合并就合并为新的栈顶，并且再次与次栈顶比较直至无法合并，在合并过程中统计次数即可。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int n,x;int ans=0; //最大操作次数stack&lt;int&gt; st;int main()&#123; int i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; //将x与当前栈顶元素st.top()比较，若栈不空且st.top()比x大1，则合并一次(此时即当前栈顶元素出栈) //然后x与次栈顶比较，以此类推，直到不满足栈不空且st.top()比x大1 while(!st.empty() &amp;&amp; st.top()-x==1) &#123; st.pop(); ans++; &#125; //若栈不空且x比st.top()大1，则合并一次 //(此时即x&quot;出栈&quot;，也就是忽略此x继续看下一个输入的x 但栈不发生任何变化) if(!st.empty() &amp;&amp; x-st.top()==1) ans++; //其他情况(x为第一个元素或不满足上述两种情况)：将x入栈 else st.push(x); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 问题 E: 卜卦提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述赵神是一个特别特别闷骚的人。别看他平日表现很高冷，其实他一直暗恋着自己的小迷妹小花花，一日不见兮，思之如狂。马上快七夕了，赵神想卜一卦算一下他的爱情幸运数，于是他找到了yoyo半仙替他卜卦。yoyo半仙需要赵神的3个幸运数字以及小花花的3个幸运数字方可进行卜卦。已知赵神的3个幸运数字是’5’’2’’0’而小花花的幸运数字是abc，(保证由5，2，0，a，b，c，这6个数各不相同，且abc均为30以内的素数)。卜卦规则如下：由{520abc}组成的6个各不相同数中选取最小的3个数作为加数，其余最大的3个数作为基数。每一个数若加上加数仅能被基数整除，其他素数均不能整除，则该数称为幸运数。其中第1314个幸运数为爱情幸运数。现在你刚好知道小花花的幸运数，请你帮yoyo完成卜卦吧。PS：顺利完成任务后则会收获赵神珍藏版kiss一枚。 输入首行输入t，代表t组测试样例 接下来t行输入三个数abc。 输出输出第1314个幸运值 样例输入12327 3 117 11 13 样例输出12295410156221775105893556 来源题解待写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int fort = 1314;ll coeff[6];int cmp(ll a,ll b)&#123; return a &gt; b;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;coeff[0]&gt;&gt;coeff[1]&gt;&gt;coeff[2]; coeff[3] = 5; coeff[4] = 2; coeff[5] = 0; sort(coeff, coeff + 6, cmp); priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; set&lt;ll&gt;ans; pq.push(1); s.insert(1); for(int i = 0;;i++)&#123; ll x = pq.top(); pq.pop(); if(i)&#123; for(int k = 3;k &lt; 6;k++)&#123; ans.insert(x - coeff[k]); if(ans.size()==fort) break; &#125; if(ans.size()==fort)&#123; /*int ttt = 1; for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++) cout&lt;&lt;ttt++&lt;&lt;&apos; &apos;&lt;&lt;*it&lt;&lt;endl;*/ set&lt;ll&gt;::reverse_iterator it = ans.rbegin(); cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; for(int j = 0;j&lt;3;j++)&#123; ll x2=x*coeff[j]; if(!s.count(x2))&#123; s.insert(x2); pq.push(x2); &#125; &#125; &#125; &#125; return 0;&#125; 问题 F: 成绩互评提交: 117 解决: 40[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述学生互评作业的简单规则是这样定的：每个人的作业会被k个同学评审，得到k个成绩。系统需要去掉一个最高分和一个最低分，将剩下的分数取平均，就得到这个学生的最后成绩。本题就要求你编写这个互评系统的算分模块。 输入输入第一行给出3个正整数N（3&lt; N &lt;= 104，学生总数）、k（3&lt;= k &lt;= 10，每份作业的评审数）、M（&lt;= 20，需要输出的学生数）。随后N行，每行给出一份作业得到的k个评审成绩（在区间[0 100]内），其间以空格分隔。 输出按非递减顺序输出最后得分最高的M个成绩，保留小数点后3位。分数间有1个空格，行首尾不得有多余空格。 样例输入12345676 5 388 90 85 99 6067 60 80 76 7090 93 96 99 9978 65 77 70 7288 88 88 88 8855 55 55 55 55 样例输出187.667 88.000 96.000 题解total数组保存各个同学的平均分，v数组保存每次接收得到的分数，排序后取前m名，按递增输出 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int cmp(double a, double b) &#123; return a &gt; b;&#125;int main() &#123; int N, K, M; while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; M) &#123; vector&lt;double&gt;v(K); vector&lt;double&gt;v2(N); for (int i = 0; i &lt; N; i++) &#123; double sum = 0; for (int j = 0; j &lt; K; j++) &#123; cin &gt;&gt; v[j]; sum += v[j]; &#125; sort(v.begin(), v.end(), cmp); sum -= v[0] + v[K - 1]; sum /= K - 2; v2[i] = sum; &#125; sort(v2.begin(), v2.end(), cmp); for (int i = M - 1; i &gt; 0; i--) printf(&quot;%.3lf &quot;, v2[i]); printf(&quot;%.3lf\n&quot;, v2[0]); &#125; return 0;&#125; 问题 G: 列车提交: 18 解决: 10[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述火车站的列车调度铁轨的结构如下图所示。tle=”” align=”” /&gt; 两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？ 输入输入第一行给出一个整数N (2 &lt;= N &lt;= 105)，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。 输出在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。 样例输入1298 4 2 5 3 9 1 6 7 样例输出14 题解必须要车号大的先出，小的后出。所以列车排队的每一队必须是从大到小排列（从右往左看），才能保证开出去的车也是从大到小的。 对于每一个想要进入并列铁轨的车，如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨 否则，选择一个最接近它车号的尾部车号的队伍进入 其实无需保存每一个并行队列的所有值，只需要保存当前队伍的车尾（就是每一列最左边 即 每一列的最小值）即可 因为每一次都是需要排序比较大小的，所以用set自动排序 首先把set里面放入一个0值。每一次set的最后一个值s.rbegin()都是当前所有队列队尾的最大值. 如果当前想要进入排队队伍的t值比集合里面最大值小，就移除第一个比他大的值，然后把t插入集合中。表示的是将t值插入了最接近它车号的队伍的队尾 否则就直接插入进去t值。作为新的队伍。s.upper_bound(t)返回的是第一个大于t的迭代器的位置 在前面加星号表示取这个位置的值 所以s.erase(*(s.upper_bound(t)));表示删除当前这个刚好大于t的位置处的值 因为一开始插入了一个没有的0，所以最后输出是s.size()-1。** 123456789101112131415161718#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n, t; cin &gt;&gt; n; set&lt;int&gt; s; s.insert(0); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; t; if(t &lt; *s.rbegin()) &#123; s.erase(*(s.upper_bound(t))); &#125; s.insert(t); &#125; cout &lt;&lt; s.size() - 1; return 0;&#125; 问题 H: 新浪关注提交: 24 解决: 14[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。 输入输入首先在第一行给出某用户的关注列表，格式如下： 人数N 用户1 用户2 …… 用户N 其中N是不超过5000的正整数，每个“用户i”（i=1 … N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。 之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。 输出我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。 样例输入1234567891010 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao8Magi 50Pota 30LLao 3Ammy 48Dave 15GAO3 31Zoro 1Cath 60 样例输出123AmmyCathPota 题解将关注的人存储在集合set里，将点赞的人和点赞的次数存储在map中，并统计点赞的平均次数sum / M，遍历map，如果map的值大于平均次数，且在set中找不到该用户名，就输出当前用户名（因为map中的键是已经按照字典序排序过的，所以直接输出就可以），并用flag标记是否有过输出，如果从始至终没有输出，说明没有悄悄关注的人，就输出Bing Mei You 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; int m, n; while (cin &gt;&gt; n) &#123; set&lt;string&gt;id; while (n--) &#123; string name; cin &gt;&gt; name; id.insert(name); &#125; cin &gt;&gt; m; map&lt;string, int&gt;mm; int sum = 0; for (int i = 0; i &lt; m; i++) &#123; int cnt; string str; cin &gt;&gt; str &gt;&gt; cnt; mm[str] = cnt; sum += cnt; &#125; sum /= m; int flag = 0; for (auto it : mm) &#123; if (it.second &gt; sum&amp;&amp;id.find(it.first) == id.end()) &#123; cout &lt;&lt; it.first &lt;&lt; endl; flag = 1; &#125; &#125; if (!flag) cout &lt;&lt; &quot;Bing Mei You&quot; &lt;&lt; endl; &#125; return 0;&#125; 问题 I: 礼物提交: 94 解决: 44[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述四月一日快到了，Vayko想了个愚人的好办法——送礼物。嘿嘿，不要想的太好，这礼物可没那么简单，Vayko为了愚人，准备了一堆盒子，其中有一个盒子里面装了礼物。盒子里面可以再放零个或者多个盒子。假设放礼物的盒子里不再放其他盒子。用()表示一个盒子，B表示礼物，Vayko想让你帮她算出愚人指数，即最少需要拆多少个盒子才能拿到礼物。 输入本题目包含多组测试，请处理到文件结束。每组测试包含一个长度不大于1000只包含’(‘’)’和’B’三种字符的字符串，代表Vayko设计的礼物透视图。你可以假设，每个透视图画的都是合法的。 输出对于每组测试，请在一行里面输出愚人指数。 样例输入12((((B)()))())(B) 样例输出1241 题解看上去像是编译原理的文法识别，要用到栈，其实不是，只要看准备上面红色的字，就知道，只有三种字符()B，且待处理的串为合法的文法，所以要知道包装盒的个数，只要知道B前面有多少(字符，但可能有(()B)这种情况，B前面有)，但因为合法，所以可以在B之前的找到(与)相匹配，就剔除掉了，所以盒子的个数就是B之前的串中(的个数减去)的个数。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123; string str; while (cin &gt;&gt; str) &#123; int sco = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str[i] == &apos;(&apos;) sco++; else if (str[i] == &apos;)&apos;) sco--; else if (str[i] == &apos;B&apos;) break; &#125; cout &lt;&lt; sco &lt;&lt; endl; &#125; return 0;&#125; 问题 J: Sunscreen题意：有C头奶牛要去沐光浴，太阳光太强烈会晒坏皮肤，太弱又会没效果。每头牛都有一个太阳光适宜的范围经行沐光浴，分别给出minspf_i和maxspf_i。 有L种防晒霜，每种防晒霜可以把所受阳光固定于一个值spf_i，每种有cover_i瓶。 问最多会有几头牛得到合适的光晒强度？ 题解：贪心策略，在满足minspf的条件下，尽量将spf的防晒霜涂到maxspf小的奶牛身上，因为maxspf大的奶牛有更多的选择。这里就需要一个优先队列来储存满足minspf的奶牛的maxspf的值。 具体解题步骤如下： 1.将奶牛按照minspf升序排列，将防晒霜按照spf升序排列。 2.枚举防晒霜，将minspf&lt;=spf的奶牛的maxspf存到优先队列中，然后值小的先出队列，看是否满足maxspf&gt;=spf，更新记录值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXN = 12505;struct spf &#123; int max; int min; friend bool operator &lt; (spf a, spf b) &#123; return a.min &lt; b.min; &#125;&#125;cow[MAXN], bot[MAXN];struct cmp &#123; bool operator()(const int a, const int b)const &#123; return a &gt; b; &#125;&#125;;int main() &#123; int C, L, i; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;pq; while (cin &gt;&gt; C &gt;&gt; L) &#123; for (i = 0; i &lt; C; i++) cin &gt;&gt; cow[i].min &gt;&gt; cow[i].max; for (i = 0; i &lt; L;i++) cin &gt;&gt; bot[i].min &gt;&gt; bot[i].max; sort(cow, cow + C); sort(bot, bot + L); int cur = 0, ans = 0; for(int i=0;i&lt;L;i++)&#123; while(cur &lt; C&amp;&amp;cow[cur].min &lt;= bot[i].min) &#123; pq.push(cow[cur].max); cur++; &#125; while(!pq.empty()&amp;&amp;bot[i].max) &#123; int maxSPF = pq.top(); pq.pop(); if(maxSPF &gt;= bot[i].min)&#123; ans++; bot[i].max--; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[少年班]天分与平凡，青春与坚守]]></title>
    <url>%2F2018%2F07%2F14%2F2018-07-14%2F</url>
    <content type="text"><![CDATA[好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初心呢；或许是经历过许许多多次起起伏伏，遇见过形形色色想遇或不想遇的人或事，又怀念起那段那段青涩的高中岁月；或许只是单纯的想再看看这部电影吧。不管为何，总之现在思绪万千。就让我将这万千的思绪草草记录一下吧。 这部电影剧情很简单，讲述的是几个天才少年与一个平凡少年被发掘功课数学难题却因青春的叛逆与时代的变迁而成长的故事。故事以主人公以吴未的少年班回忆而展开，主人公吴未就是那个平凡的少年。 少年班，顾名思义就是大学里专为年纪轻轻却智商非凡的天才们开设的精英班，某知名大学老师周知庸曾经就是少年班的成员，他的梦想是攻克IMC的题目，但曾经的他未能实现，于是将希望寄托在新时代的少年身上。在他的坚持下从全国各地找到了几名心仪的人选，其中包括了吴未。 然而，像其他天才系列电影一样，天才们拥有着平凡人所羡慕的才能之外，往往却拥有着平凡人所不能理解的烦恼。天才少年方厚政年纪最小，却智商超群，可谓前途无量，只是他IQ高。EQ却低，因此没有什么朋友。天才少年麦克因家庭原因而性格叛逆，打架斗殴无所不为。天才少年王大法无拘无束，自由散漫，因此总让别人捉摸不透，不想与之有交集。天才少女周兰品学兼优，是典型的别人家的子，但也是因为优秀而让所有人都敬而远之。但是和其他电影不同的是，这些天才们不可思议的烦恼其实我们都能理解。毕竟曾经或现在处于青春期的我们哪一个人曾经没有过类似的烦恼呢？他们的性格不过是我们所有人青春期各种性格的集合并放大罢了。 当然，我们的主人公也有着自己的烦恼，身为平凡人的代表，当他进入少年班后从之前的全校第二摇身一变变成班上的倒数第一，这种落差估计每个处于青春期的孩子都受不了吧。于是他一边仰望着天才们过人的天赋，一边忍受着天才们怪异的性格，一边照顾着正处于青春期幼稚的天才们，一边独自默默努力着，为了自己心中的荣誉。然而，努力在这满是天才的地方却显得那么多余。就在他一筹莫展，开始疑惑为何老师选中他的时候，周知庸老师出现，解开了她的心结。“运送金枪鱼的时候，要在里面混进几条鲶鱼，否则金枪鱼就会因懒惰而死，到不了岸。”老师鼓励他做好自己鲶鱼的身份，因为天才们离开了它的照顾就会堕入深渊。尽管是鲶鱼，但吴未却似乎找到了自己的归宿，并以此为荣，从此，吴未以天才们的快乐为快乐，以天才们的梦想为梦想，就在自己喜欢的人面前，也只能呼喊着天才们所喜欢的校花名字。 IMC马上开始了，老师想进各种办法激励着天才们去努力钻研，但是恃才傲物并且正处于青春期的天才们又怎会把新鲜的大学生活浪费在学习上呢？趁着大学生活的新鲜感犹在，天才们渐渐被校花江依琳所吸引，从此各种各样的新奇表白开始了。只有吴未从一开始就暗恋着同班的天才少女周兰。尽管周兰从来都看不起吴未，并且单恋这少年班的迈克。 比赛前一天，几名少年班朝夕相处的小伙伴们在酒后发泄着各种各样青春期的passion，来到女生宿舍楼下，大声表白校花，那一刻，漫天飞舞的纸花，洋洋洒洒，似乎整个世界都在期待着几个天才少年去改变。 比赛的一个月里，天才们尽管出现各种各样的矛盾，但在吴未的调节下，无伤大雅。但一次偶遇，校花与富家公子哥之间的隐曲之事深深刺激到了天才们。他们落荒而逃，逃得那么彻底。 老师闻讯，拿起了酒杯，向舞台赶去。天才们旧气难言，拿起了自制的化学炸药，向富二代的车赶去。老师将酒水泼向校花，门外传来雷鸣般的爆炸。这一刻，老师的梦想毁了，天才们的前途毁了，然而，世界依然有活力地在转，一如既往。 然而，老师仍心怀希望，尽力将此事最小化解决。这边，王大法作为被开除的学生被家人拖走，那边，吴未望向楼上的橱窗，老师站在橱窗望着吴未。这一刻，吴未明白，自己的价值将要发挥了。就这样，吴未顶替其他天才们而被学校开除。 奔驰的归家车上，吴未哭的撕心裂肺，将自己仅有的一枚荣誉勋章扔向窗外，像扔去回忆一样。身后周兰，方厚政，迈克，追的精疲力尽，他们将过去的笔记本扔向追不上的公交车，像追随友谊一样。 最终，天才们并没有解出题，也没有改变世界，但他们最终都找到了自己的方向。周知庸老师最后没能实现自己的天才梦，也丢掉了工作，像人间蒸发一样，随旧时代而去，但他却找到了自己的人生伴侣。吴未，平淡无味，但又快乐的漂浮着。 这部影片最大的亮点就在于其真实性。首先，少年班的故事从1978年起一直延续着。然而，随着时代的发展，如今的少年班已不复存在了。旧时代里，时代的推进是由天才们推进的，这就是为何周知庸老师为何执着于天才的原因之一。就像他说的，“高斯十七岁就发现了第二相反定理，这些天才当时他们不敢发表，因为怕人们不信。”因为这种理念的支撑，让他对所有平凡人带上了有色眼镜，以至于四十多岁依旧单身。然而，过去毕竟是过去，世界上有很多天才，但只有一个高斯，只有一个牛顿，只有一个爱因斯坦。牛顿他们所带表的这类基础科学并不是一个人所完成的，它需要所处时代的支持以及现有技术的支撑，就像牛顿自己也说过，自己是站在巨人肩膀上的，况且牛顿从未说过自己是天才，自己只是热爱探索而已，因此，想要天才改变世界的周知庸老师从一开始就错了，因为他不懂平凡人的价值，所以，他没有牛顿的成就，与牛顿唯一的共同点就是一直单身。世界是一个多元化的世界，不只是理论的世界，如果说基础科学是时代质的飞跃，那应用科学就是时代量的积累、倘若基础科学离开了应用科学，那么世界依旧停滞不前，基础科学反而成为了最没用的东西。故事的结尾，天才们并没有从事科研工作，而是选择了自己所喜欢的岗位，他们没有改变世界，只是生活的比平凡人更潇洒。平凡与天赋，其实离开谁都不行，正是因为天才们的研发，广大平凡的劳动者的坚持工作与制作，才使得这个世界不断推进向前。 然而，少年班不适宜于当下最主要的原因还是心智的为题。尽管天才们智商超群，但是年纪与经历更重要。十几岁就步入大学校门，尽管他们智商达标了，但心智并未达标。电影中表现的淋淋尽致。他们从未接触过社会，也并不懂得什么是责任，当然，那个时代的我们都一样，在心智上，人人都是平等的。我们就来分析一下各个主人公吧。 首先是主人公方厚政。作为年纪最小的天才，他的心情，性格，全都写在了脸上。目测智商150，心理年龄只有9岁。遇到委屈就哭，遇到自己看不上的事就挖苦，总之这个世界上只有自己是最厉害的，当面对丰富多彩的大学生活，他又怎会抵挡住各种各样的新鲜事物而去专心钻研呢。主人公迈克，看似成熟，其实心智同样幼稚，面对所有事第一个想到的就是用拳头来解决，从不会考虑后果。主人公王大法自由散漫，每天吃着馒头，听着经文，一副玩世不恭的样子。主人公周兰，可以说是所有优秀的女孩的代表，可以说是比较正常的一个，但正处于花季年纪的她并不适合大学生活，成绩优异不懂打扮的她让人只能敬而远之。尽管是天才，但是如今的大学并不只是学习知识的地方，如果说初中是每个人最会做梦的年纪，高中洋溢着每个人最具浓厚的青春，走向社会是一个人成长为打人的标志，那么大学时代则是每一个人从孩子长成大人的过度期，因此嚷处于做梦年纪的孩子直接去面向社会的残酷未免太过残忍。 校花江依琳可谓是剧中较完美的一个人，他承载着天才们对女性最完美的幻想。她可以说是剧中EQ最高的一位。尽管他是天才们放弃比赛的导火线，但是天才们又有几个真正懂得感情呢。她对方厚政的感情其实就是姐姐对弟弟的照顾，而对于心智只有9岁的方厚政来说，又怎会冬的何谓男女之情呢。方厚政对待像话的感觉也不过是弟弟对大姐姐的仰慕之情。王大法测试时便已说过他所期望的爱情是门当户对，显然校花并不是他所期待的人，因此他对校花的感情量自己都不会说清楚。至于迈克，校花也许的确对迈克有点好感，但迈克显然给不了校花幸福，首先，迈克并不知道什么是责任，测试时便已清楚他的情绪宣泄是暴力，倘若青春期那股passion磨灭了，后果自行脑补。其次迈克给不了校花真正需要的。之所以前期近似完美的校花最后会有那么一出戏，其实很容易看出的。江依琳需要一场舞蹈独秀以支撑日后的发展，身为天才的少年们有谁能给呢，因此江依琳选择了富家公子哥，这都是情理之中。而此时的天才们只顾自己的感受，仗着长久以来老师的庇护去炸车。所以，当看到周知庸老师泼江依琳水时，我倒有点替校花感到冤枉，自己争取来的前途就因为接近了天才们而被老师给毁了。而周老师之所以泼水，也许是曾经旧时代里被戏弄过，旧火新火全发泄在了江依琳身上。 周知庸老师，典型旧时代的人，因为自己未能拿奖的遗憾，而把希望寄托在新时代的少年天才们身上。也许努力学习没有错，但他忽略了当今世界已不是简简单单努力学习就能改变的了。当一个人不愿接受新时代时，他已经被这个时代所遗弃，成为旧时代的古董。当他最后不在从事教育事业，专心于交际时，此刻的他应该是幸福的。 不过，周老师错了吗，没人能说他错了。至少20多年来，他一直秉持着初心，坚守着梦想，对于现代人来说，这一点是多么的可贵呢。社会这个大染缸将每一个青春期怀穿着梦想的少年少女染成形形色色为生活而忙碌的机器，又有几个人能站出来说我要改变这个世界呢。我感觉说这话的人并不丢人，反而是那些早已面目全非的人让人可悲。 不知不觉，恭喜我又成功把我给绕进去了。我竟然有分不清自己的立场了，呵呵。不过不论什么样的人，坚持做好自己就好。正处于大学生活的我们，无论何时都要坚持自己的梦想，不必在意那些圆滑的人说你不够圆滑，不必在意那些所谓成熟的人说你不够成熟，不要照原样接受别人的生活。选择坚守，选择理想，选择倾听自己内心深处的呼唤。因为在这个充满怀疑的世界，我们依旧需要梦想。]]></content>
      <categories>
        <category>心路历程</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回忆若一指流沙，散落了谁的风华]]></title>
    <url>%2F2018%2F06%2F11%2F2018-06-11%2F</url>
    <content type="text"><![CDATA[宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。 后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有一种壮志凌云。 在宁夏，没有高楼大厦，但远处的山峰鳞次栉比。没有车水马龙，但广阔的天空一碧如洗。一切都安顿好之后，我们便奔向当地特色小吃而去。宁夏理工学院，坐落在湖心的一座岛屿之上，可以说，一座岛屿即一座城。很快我们便摸不清方向了。此时，一个小姐姐跑过来跟我们搭讪。由于比赛都发的队服，很是显眼，显然，她是被我们的队服吸引而来的。就这样莫名其妙的，我们渐渐熟悉。在她的带领下，我们逛了校园，逛了小吃摊…… 宁夏昼长夜短，即使到了晚上八九点，天依然为褪色。就这样逛着逛着，吃着吃着，天就黑了，当我们看时间时，已是十点多了。我们留下了联系方式，各自归宿。 第2天，宁夏理工学院组织我们所有参赛者一起去旅游，地点是沙湖，即沙漠中的一片绿洲。我们队和昨天的小姐姐约好今天一起游玩，而我们队刚好缺了一个教练，就这样理所当然的，她以我们教练的身份一起踏上了沙漠的旅程。 一路上，我们划过了湖泊，翻过了沙漠，跨过了沙丘，因为她的出现，在她的陪伴下，我们的旅程不再显得单调乏味。在沙漠中，偶然发现某片沙地里满是荆棘，当跨过荆棘之后，望到了一片花海。尽管花在强烈的阳光下已奄奄一息，然而它们仿佛在用生命证明自己存在的意义。同伴们纷纷前往亭下避暑，只有我守着安静的沙漠，等待着花开。 第3天，终于要比赛了。经过了上一次失败的经验，这次尽管最后一次提交因为时间到了没有提交成功，不过好在前两个半小时成功A了3道题，我们队最终斩获一枚铜奖，也算是这么多月的训练也算有了一个回报。 临别时，小姐姐教练来为我们送行，并带来当地的特产。因为赶飞机，我们草草照相留念之后，便踏上了返程的飞机。 戴上耳机，梳理着三天的回忆。其实我们每个人来到这个世界上，就只能义无反顾的前进。在人生的道路上，除了自己，其他人都只能伴我们走过一程。这一程，或长或短，也许转瞬已尽，也许直通彼岸，但永远不会是永远。当走完这一程，余下的路需由自己来走完。然而不必逗留着，因为每时每刻，都会有新的过客伴你走过新的一程。尽管离别之后，我们可能会永远不见，但彼此走过的那份欢乐，永远藏在心里。 谢谢你伴我们走过这三天，也许今后永远不会再见，但我们走过的那段旅程以及旅程中的你我永远不会失散。]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API函数配置读写文件]]></title>
    <url>%2F2018%2F06%2F03%2F2018-06-03%2F</url>
    <content type="text"><![CDATA[cfg_op.h 1234567891011#pragma once#ifdef __cplusplusextern &quot;C&quot; &#123;#endif //获取配置项 int GetCfgItem(char *pFileName/*in*/, char*pKey/*in*/, char *pValue/*in out*/, int *pValueLen/*out*/); //写配置项 int WriteCfgItem(char*pFileName/*in*/, char *pKey/*in*/, char *pValue/*in*/, int *ValueLen/*in*/);#ifdef __cplusplus&#125;#endif cfg_op.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#define Maxline 2048extern &quot;C&quot; &#123; int GetCfgItem(char *pFileName, char*pKey, char *pValue, int *pValueLen) &#123; int ret = 0; FILE *fp = NULL; char lineBuf[Maxline]; char *pTmp = NULL, *pEnd = NULL, *pBegin = NULL; fp = fopen(pFileName, &quot;r&quot;); if (fp == NULL) &#123; ret = -1; return ret; &#125; while (!feof(fp)) &#123; memset(lineBuf, 0, sizeof(lineBuf)); fgets(lineBuf, Maxline, fp); printf(&quot;lineBuf:%s &quot;, lineBuf); pTmp = strchr(lineBuf, &apos;=&apos;); if (pTmp == NULL) &#123; //没有=号 continue; &#125; pTmp = strstr(lineBuf, pKey); if (pTmp == NULL) &#123; //判断key是不是在//所在行 是不是有key continue; &#125; pTmp = pTmp + strlen(pKey); // mykey1 = myvalue11111111==&gt;&quot;myvalue11111111&quot; pTmp = strchr(pTmp, &apos;=&apos;); if (pTmp == NULL) &#123; //判断所在行是不是有key continue; &#125; pTmp++; printf(&quot;pTmp:%s &quot;, pTmp); //获取value起点 while (1) &#123; if (*pTmp == &apos; &apos;) &#123; pTmp++; &#125; else &#123; pBegin = pTmp; if (*pBegin == &apos;\n&apos;) &#123; //没有配置value printf(&quot;配置项:%s 没有配置value \n&quot;, pKey); goto End; &#125; break; &#125; &#125; //获取value结束点 while (1) &#123; if (*pTmp == &apos; &apos; || *pTmp == &apos;\n&apos;) &#123; break; &#125; else &#123; pTmp++; &#125; &#125; pEnd = pTmp; //赋值 *pValueLen = pEnd - pBegin; memcpy(pValue, pBegin, pEnd - pBegin); &#125; End: if (fp == NULL) fclose(fp); return ret; &#125; int WriteCfgItem(char*pFileName, char *pKey, char *pValue, int *ValueLen) &#123; int rv = 0, iTag = 0, length = 0; FILE *fp = NULL; char lineBuf[Maxline]; char *pTmp = NULL, *pBegin = NULL, *pEnd = NULL; char filebuf[1024 * 8] = &#123; 0 &#125;; if (pFileName == NULL || pKey == NULL || pValue == NULL) &#123; rv = -1; printf(&quot;SetCfgItem() err. param err \n&quot;); goto End; &#125; fp = fopen(pFileName, &quot;r+&quot;); if (fp == NULL) &#123; rv = -2; printf(&quot;fopen() err.\n&quot;); &#125; if (fp == NULL) &#123; fp = fopen(pFileName, &quot;w+t&quot;); if (fp == NULL) &#123; rv = -3; printf(&quot;fopen() err.\n&quot;); goto End; &#125; &#125; fseek(fp, 0L, SEEK_END);//把文件指针从0位置开始，移动到文件末尾 //获取文件长度 length = ftell(fp); fseek(fp, 0L, SEEK_SET); if (length &gt; 1024 * 8) &#123; rv = -3; printf(&quot;文件超过1024*8,nunsupport&quot;); goto End; &#125; while (!feof(fp)) &#123; //读每一行 memset(lineBuf, 0, sizeof(lineBuf)); pTmp = fgets(lineBuf, Maxline, fp); if (pTmp == NULL) &#123; break; &#125; //key关键字是否在本行 pTmp = strstr(lineBuf, pKey); if (pTmp == NULL)//key关键字不在本行，copy到filebuf中 &#123; strcat(filebuf, lineBuf); continue; &#125; else//key关键字在本行中，替换旧的行，再copy到filebuf中 &#123; sprintf(lineBuf, &quot;%s = %s\n&quot;, pKey, pValue); strcat(filebuf, lineBuf); //若存在key iTag = 1; &#125; &#125; //若key关键字，不存在 追加 if (iTag == 0) &#123; fprintf(fp, &quot;%s = %s\n&quot;, pKey, pValue); &#125; else &#123;//若key关键字，存在，则重新创建文件 if (fp != NULL) &#123; fclose(fp); fp = NULL;//避免野指针 &#125; fp = fopen(pFileName, &quot;w+t&quot;); if (fp == NULL) &#123; rv = -4; printf(&quot;fopen() err.\n&quot;); goto End; &#125; fputs(filebuf, fp); &#125; End: if (fp != NULL) &#123; fclose(fp); &#125; return rv; &#125;&#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define _CRT_SECURE_NO_WARNINGS#include&quot;cfg_op.h&quot;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define CFGNAME &quot;d:/mycfg.ini&quot;//读配置项int GetCfg() &#123; int ret = 0; char name[1024] = &#123; 0 &#125;; char value[1024] = &#123; 0 &#125;; int vlen = 0; printf(&quot;\n请输入Key:&quot;); scanf(&quot;%s&quot;, name); ret = GetCfgItem(CFGNAME, name, value, &amp;vlen); if (ret != 0) &#123; printf(&quot;func GetCfgItem err:%d \n&quot;, ret); return ret; &#125; printf(&quot;value:%s \n&quot;); return ret;&#125;//写配置项int TWriteCfg() &#123; int ret = 0; char name[1024] = &#123; 0 &#125;; char value[1024] = &#123; 0 &#125;; int vlen = 0; printf(&quot;\n请输入Key:&quot;); scanf(&quot;%s&quot;, name); printf(&quot;\n请输入Value:&quot;); scanf(&quot;%s&quot;, value); WriteCfgItem(CFGNAME, name, value, &amp;vlen); if (ret != 0) &#123; printf(&quot;func WriteCfgItem err:%d \n&quot;, ret); return ret; &#125; printf(&quot;您的输入是：%s = %s \n&quot;, name, value); return ret;&#125;void show_menu() &#123; printf(&quot;==========================\n&quot;); printf(&quot;1.测试写配置文件\n&quot;); printf(&quot;2.测试读配置文件\n&quot;); printf(&quot;0.退出\n&quot;); printf(&quot;==========================\n&quot;);&#125;int main() &#123; int choice; show_menu(); while (~scanf(&quot;%d&quot;, &amp;choice)) &#123; //显示一个菜单 switch (choice) &#123; case 1: TWriteCfg(); break; case 2: GetCfg(); break; default: exit(0); &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); show_menu(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>API</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客训练赛19之托米专场]]></title>
    <url>%2F2018%2F06%2F01%2F2018-06-01%2F</url>
    <content type="text"><![CDATA[托米的简单表示法题目描述 作为故事主角的托米是一名老师。 一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: 几何表示的定义： 1. 对于一个括号序列A，我们定义g(A)是A的几何表示形式,则 “()”的表示是一个1*1的方块，高度为1; 2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1; 3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。 其中+指的是字符串的连接符。 ​ 在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： 输入描述:123输入的第一行包含一个整数T，表示指定测试用例的数量。每个测试用例前面都有一个空白行。每个测试用例由一个合法括号序列组成。 每行只包含字符&apos;(&apos;和&apos;)&apos;。 输出描述:1对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。 示例1 输入复制 123452((()))(())(()(())) 输出复制 121020 说明1第二个测试案例是上图中显示的案例。 备注:121≤T≤10一个合法括号序列长度≤4 x 105 题解这道题提交了好多次，一直WA。后来改成long long就过了。原理很简单，就是遇见左括号入栈，遇见右括号出栈。在入栈出栈时执行操作。先入栈的高度比后入栈的最高高度要高1，初始宽度为1，每执行一次出栈操作，出栈元素前一个元素的宽度等于他自身宽度加上出栈元素宽度再加1。而出栈元素的面积等于宽乘高减去包含元素的面积。就这样，每次出栈时，前一个元素宽度加上该元素宽度加1，前元素将要减去的面积area等于出栈元素的面积minu。而出栈元素的面积area等于高乘宽减去将要减去的面积minu。最终由于0位置没有面积，就是全域，那他的minu即将要减去的面积就是总面积。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 200010;char str[maxn*2];ll high[maxn],wed[maxn],area[maxn],minu[maxn],mystack[maxn];ll fun()&#123; int cnt = 1,head = 1,tail = 1,len = strlen(str); memset(high,0,sizeof(high)); memset(wed,0,sizeof(wed)); memset(minu,0,sizeof(minu)); memset(mystack,0,sizeof(mystack)); for(int i = 0;i &lt; len;i++)&#123; if(str[i] == &apos;(&apos;)&#123; mystack[tail++]=cnt++; high[mystack[tail - 1]]++; wed[mystack[tail - 1]] = 1; if(high[mystack[tail - 2]] &lt;= high[mystack[tail - 1]]) high[mystack[tail - 2]] = high[mystack[tail - 1]] + 1; &#125; else if(str[i] == &apos;)&apos;)&#123; if(tail &gt; 1)&#123; if(high[mystack[tail-2]] &lt;= high[mystack[tail-1]]) high[mystack[tail-2]] = high[mystack[tail-1]] + 1; tail--; wed[mystack[tail - 1]] += wed[mystack[tail]] + 1; area[mystack[tail]] = wed[mystack[tail]] * high[mystack[tail]] - minu[mystack[tail]]; minu[mystack[tail - 1]] += area[mystack[tail]]; &#125; &#125; &#125; return minu[0];&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; scanf(&quot;%s&quot;,str); cout &lt;&lt; fun() &lt;&lt; endl; &#125; return 0;&#125; 托米的饮料题目描述 好了，现在是小托米的故事啦~~~ 可爱的小托米得到了n瓶饮料. 但他不小心把开盖的工具弄丢了,所以他只能利用饮料瓶来开盖. 已知第i个瓶子的品牌为a i ,且其能打开b i 品牌的瓶子. 问有几瓶饮料托米无法喝到. 被用于打开饮料瓶的瓶子不一定需要被打开. 一个瓶子不能打开其本身. 输入描述:12第一行一个整数n,表示饮料的瓶数.接下来n行,每行两个整数ai,bi. 输出描述:1输出一行一个整数,表示小托米无法喝到的饮料瓶数. 示例1 输入复制 1234541 12 23 34 4 输出复制 14 示例2 输入复制 1234541 22 33 44 1 输出复制 10 备注:121≤n≤1001≤ ai,bi≤ 1000 题解本题坑人之处在于理解题意。因为没理解题意导致提交了好多次才提交成功。本题实质很简单，就是每个瓶子对应有一个编号b，可以开这个编号b除了自己以外的所有的瓶子。但仅限于该瓶子，其他瓶子也只能执行自己的编号b。首先输入完成时记录下所有编号的瓶子个数，把n赋给瓶子个数cnt，因为一开始n个瓶子都没打开。接着对b按顺序进行遍历，如果对应编号的瓶子不存在，则不执行操作，否则接着判断，如果a和b不同，则cnt减去该瓶子的数量，然后数量置零，因为该类瓶子已经打开完了，之后不需要再打开，否则执行完操作后再加1，因为不能打开自己。最后cnt就是剩下没打开的数量。 代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int vis[1010]=&#123;0&#125;,a[1010],b[1010];int main()&#123; int n; cin&gt;&gt;n; int cnt = n; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; vis[a[i]]++; &#125; for(int i = 1;i&lt;=n;i++)&#123; if(vis[b[i]])&#123; cnt-=vis[b[i]]; vis[b[i]]=0; if(a[i]==b[i])&#123; cnt++; vis[b[i]]=1; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 托米搭积木题目描述 小托米真的很可爱呀(&gt;_&lt;) 这天,可爱的小托米得到了n堆积木,且第i堆积木初始时有ai块积木. 输入描述:1234567第一行两个整数n,m.第二行n个整数,第i个整数代表ai的值.接下来m行,每行代表一个操作:第一个整数t代表操作的类型若t=1,则接下来两个整数v,x,代表操作1.若t=2,则接下来一个整数y,代表操作2.若t=3,则接下来一个整数q,代表操作3. 输出描述:1对于每个操作3,输出其对应的答案. 示例1 输入复制 1234567891011121310 111 2 3 4 5 6 7 8 9 103 23 92 103 13 101 1 102 102 103 13 103 9 输出复制 1234567291120304039 备注:1234561≤n,m≤ 1051≤ai≤1091≤t≤31≤v≤ n,1≤ x≤1091≤y≤1041≤q≤n 题解很简单的一道题，3种操作，第1操作是把第i位置的数该为另一个数x，第2个操作是所有数加v，第3个操作是查询某一位置的数。首先分析，第1种操作和第3种操作时间复杂度都是O(1),第2中操作如果每位加v的话时间复杂度O(n)。所以优化在于第2操作。不过对于此操作我们可以降维优化，因为是所有数都加v，那么我们只需把v记录下来，每次查询时对查询的数直接加v就行了。这样就又遇到了一个问题，就是假如所有的数现在的状态是加v，而i位置元素现在变成了x，这样就会造成所有元素相加不一致。解决也很简单，只需每次变成x后，给x减去v就行了，这样查询时再加上v结果并没变。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int m,n;int a[100010], cnt;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int t,x,y; cnt=0; while(m--)&#123; cin&gt;&gt;t; if(t==3)&#123; cin&gt;&gt;x; cout&lt;&lt;a[x]+cnt&lt;&lt;endl; &#125; else if(t==2)&#123; cin&gt;&gt;x; cnt+=x; &#125; else if(t==1)&#123; cin&gt;&gt;x&gt;&gt;y; a[x]=y; a[x]-=cnt; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[心路历程]心境决定处境，心界决定眼界]]></title>
    <url>%2F2018%2F05%2F31%2F2018-05-31%2F</url>
    <content type="text"><![CDATA[有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸，但此刻的你并没有精力寻找彼岸的方向，因为你的心思全放在了如何不被突如其来的大水淹没，于是你拼命的寻找救命稻草，以阻止自己下沉。就这样，在慌乱的过程中，阻止了你上岸的步伐。 假如一开始你没有目标，那么此时这种状态并非坏事。因为当你在水里抓住救命稻草之后，会寻找彼岸的方向。如果你足够冷静，此刻你会总结你和他的差距在哪里，从而为自己确立目标，并参考他的经历为自己制定计划。如果你不够冷静，那此时你也许会照搬别人的做法，以别人的目标为自己的目标。这样也许会走很多弯路，做许多无用功，但至少比之前毫无目标浑浑噩噩要好得多，同时这段经历也会成为你如何成长道路上的一比财富。 倘若你一开始就有自己的目标，有属于自己的彼岸，而当你看到有人已经走到人生的彼岸时，你会怀疑自己走过的路，即使彼岸就在前方，你也会动摇，因为你还没有到达彼岸，没有见过彼岸的风景。假如此时的你停下脚步眺望对方的彼岸，那无疑是致命的。它就像突如其来的潮水，可能会拖延了你前行的道路，更有可能会动摇你前行路上的决心，甚至改变你前进的方向。 我有一个计算机系的舍友，他的目标是考研。自大一以来一直成绩优异，大二时便已轻松通过四六级，而且交际甚广，可谓前程平坦，身边阳光明媚。但此时，某人给他发了一个自己做的贺卡程序，看起来挺酷，此时他开始动摇了。因为自进校以来同学们一直都是面对黑窗口敲代码，敲出来的也是黑窗口，从来没有想过有人能够编出应用来。他说，当他收到那份礼物时，心中交错的并不是喜悦，而是迷惘。就好像春天的果树看着繁花满庭，而自己却总是开不出花，便开始抱怨自己的价值，而忘记了自己的果实要等到秋天才能品尝。于是当他看到别人已经拥有了强大的实力并且取得相应的成果，而自己还停留在课本中的C语言基础知识，不会应用，顿时思绪万千，怀疑自己走的道路，怀疑学校的课程安排。那种感觉，就像走着走着掉进水里一样。 此时，他拼命的寻找救命稻草。终于，他抓到了第一根救命稻草。他开始跟着别人做项目，一起写程序，别人打比赛，他便开始模拟比赛。在这段时间，他感到生活变得充实，做事也有动力，因为他也想拥有像那个人一样的实力，像那个人一样去打比赛。但正当他感觉找到目标时，选拔结果出来了，正式比赛的名额没有他，他落选了。此时的他顿时感觉自己又失去了方向。于是他又开始寻找救命稻草。他抓到的第二根救命稻草是校外的编程培训班。于是他果断交了大笔费用去报了培训班。在培训班里，他又燃起了希望，因为在这里，老师讲的一些东西都是课本上所没有的，老师还经常在课堂上带他们写一些小应用，这些都是他们以前不曾经历过的。由于这种模式以前没有接触过，所以便对学的东西燃起了兴趣，即使一切都是从头开始学习，即使许多东西以前都学过。就这样过了两个月，当他冷静下来，重新审视自己时，才发现自己真正要走的路的还是考研，而这段时间所学的技术只是就业路上的一个工具。而培训班中的许多东西其实学校的课程里都有，只是他从未重视过，没接触过的东西未来也会学习。就这样，他又开始了最初的考研复习之路。 那么，当我们在前行的路上看到别人已经到达人生的彼岸或者接近人生的彼岸时该怎么办呢。 其实，一个人的心境决定了这个人的处境。假如心中拥抱黑暗，那么眼之所见也会变得暗淡。即使前程平坦，阳光盎然，你也望不见人生的彼岸。假如心中充满光明，那么黑夜也会为你亮起星光。即使道路坎坷，前程黑暗，你也会收获自信坚定向前。 以我为例，记得之前比赛失利，没有获奖，而朋友却在其他项目中表现优异，此时的我就像《三体》中经历水滴之战惨败而侥幸逃跑的舰队队长一样，当看到章北海率领的舰队未雨绸缪时，眼前是一片黑暗，不由自主地感叹:”好黑，真tm的黑啊”。此刻的我早已迷失了方向，整日思绪想的是同样是付出，朋友们一个个却硕果累累，而我却像墙角的蘑菇怎么也沐浴不到阳光。为了这场比赛，准备了一个多月，那段时间翘了许多节课，一心研究算法，而最后连个证明自己这段时间的成果都没有。眼前面临的是各种各样的考试，以及英语四级考试，顿时怀疑自己之前的付出是否值得。其实在不久之后又有一次比赛，而此时的我却整日处于悲观之中，害怕下次比赛同样拿不到成绩，害怕考试失利，害怕英语四级。此刻的我，感到人人都各有所长，就只有自己一直处于失败当中，人人都比我成功。于是我把自己包裹起来，不喜欢与人交流，感觉每个人都很虚伪，从此变得越来越冷漠。就这样，我一边准备比赛，一边疯狂复习，一边孤独，一边迷惘。由于同时选择多种方向，最终也一事无成。马上就要比赛了，此刻的我偶然间望见教室的窗外阳光依旧明媚，回忆起之前努力奋斗的日子里也是同样的阳光，望着这从未消逝的阳光，我重新总结了一下这段时间的经历，终于明白，其实阳光很好，世界很好，所有人都很好，只是我的心态变得暗淡了。当我重新投入到阳光灿烂的日子里，此时发现，其实许多人都在羡慕我。尽管我没有拿到奖，但这段时间我的实力已经突飞猛进。虽然我没有收获奖杯，但我却收获了成长，坚定了方向。 所以，心界决定了眼界。当你凝视黑暗的时候，黑暗也在呼唤着你。倘若一个人心中见不到光，那么对他而言，整个世界都是黑暗的。当看到别人取得的成就时，只会是羡慕嫉妒恨，自怨自艾。也许有人会说，悲观，是一种远见。但当一个人始终以悲观的态度看待世界，那么所看到的整个世界只剩下冷漠，背叛，黑暗，而你收获的也只有孤独，失望，迷茫。 不妨敞开心扉，让阳光渗透到我们的心中。此时你会发现，当你看到别人的成就时，更多的是送去祝福，而不是怀疑自己。这样，就不会迷失方向，同时别人的经历中总结经验，化作自己前行的垫脚石。 阳光很好，我亦很好，整个世界更好。]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++结构体中的深copy和浅copy&&结构体偏移量的两种求法]]></title>
    <url>%2F2018%2F05%2F30%2F2018-05-30%2F</url>
    <content type="text"><![CDATA[浅copy：编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，拷贝之后释放内存就不会出现问题。但是如果结构体中含有指针变量的时候，编译器只会copy指针变量，而对应的内存空间却不会缺不再多分配。 代码： 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECUFE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct note &#123; char a[64]; int b; char*c;&#125;note;void my_copy(note*from, note*to) &#123; *to = *from; //memcpy(to,from,sizeof(note));//和上述操作等效&#125;int main() &#123; note d, e; strcpy(d.a, &quot;123&quot;); d.b = 456; while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL) exit(1); strcpy(d.c, &quot;789&quot;); printf(&quot;d的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c); my_copy(&amp;d, &amp;e); printf(&quot;e的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c); if (d.c != NULL) &#123; free(d.c); d.c = NULL; &#125; if (e.c != NULL) &#123; free(e.c); e.c = NULL; &#125; return 0;&#125; 以此样例为例，输出结果为： 12345678d的值为：123456789e的值为：123456789 然后接着某些编译器如vs的编译器就会报错。出错位置为 1234if (e.c != NULL) &#123; free(e.c); e.c = NULL; &#125; 这是由于将结构体d内存元素直接赋给结构体e时，即进行 e= d操作时，由于结构体中含有指针元素，d结构体中的指针已经动态分配内存，而操作完成之后e中指针的值也会写上d动态分配内存的地址，因此d和e指向同一内存空间。这样当d中指针d.c释放内存之后，由于e.c仍然指向该部分内存，而不指向空，此时会强制释放掉e.c所指向内存，由于此处内存已经释放过了，处于不能被访问状态，而e.c又强制释放该内存，就会造成vs编译器报错。这就是前copy的弊端。 深copy：编译器会为拷贝的对象分配一定的内存空间。 以上述代码为例，只需在进行 e= d操作之后再为e.c重新分配内存，然后执行strcpy(e,d)即可。这样e.c和d.c分别指向两块不同的内存，这样就不会出现上面那种错误。 代码: 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECUFE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct note &#123; char a[64]; int b; char*c;&#125;note;void my_copy(note*from, note*to) &#123; *to = *from; //memcpy(to,from,sizeof(note));//和上述操作等效 while ((to-&gt;c = (char*)malloc(64 * sizeof(char))) == NULL) exit(1); strcpy(to-&gt;c, from-&gt;c);&#125;int main() &#123; note d, e; strcpy(d.a, &quot;123&quot;); d.b = 456; while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL) exit(1); strcpy(d.c, &quot;789&quot;); printf(&quot;d的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c); my_copy(&amp;d, &amp;e); printf(&quot;e的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c); if (d.c != NULL) &#123; free(d.c); d.c = NULL; &#125; if (e.c != NULL) &#123; free(e.c); e.c = NULL; &#125; return 0;&#125; 偏移量的求法123456struct note&#123; char name[64]; int age; int sex;&#125;a,*p;p=&amp;a; 以p为例求p-&gt;age偏移量 直接法1int offsize = (int)&amp;(p-&gt;age)-(int)p; 间接法1int offsize = (int)&amp;(((*note)0)-&gt;age);]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于模拟或暴力类型题的时间复杂度降维优化举例]]></title>
    <url>%2F2018%2F05%2F29%2F2018-05-29%2F</url>
    <content type="text"><![CDATA[首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即实现由0(…)0(N)-&gt;0(…)0(1)的降维过程。但推导公式往往是一件很麻烦的事情，因此推导公式是模拟类题的关键。以下两道题原本是用模拟或暴力来解决，但其实它们都是可以优化的，例如第一题只需要求周期内的数与周期即可，不用遍历全部数，第2题只需对该数n进行分析即可，时间复杂度0(1)，不用从1遍历到n一个个进行统计。 斐波那契数列百度熊对数学一直都非常感兴趣。最近在学习斐波那契数列的它，向你展示了一个数字串，它称之为“斐波那契”串： 1 111235813471123581347112358… 聪明的你当然一眼就看出了这个串是这么构造的： 先写下两位在0~9范围内的数字a, b，构成串ab； 取串最后的两位数字相加，将和写在串的最后面。 上面百度熊向你展示的串就是取a = b = 1构造出来的串。 显然，步骤1之后不停地进行步骤2，数字串可以无限扩展。现在，百度熊希望知道串的第n位是什么数字。 输入数据的第一行为一个整数T（1 ≤ T ≤1000）, 表示有T组测试数据；每组测试数据为三个正整数a, b, n（0 ≤ a, b &lt; 10, 0 &lt; n ≤109）。 对于每组测试数据，输出一行“Case #c: ans”（不包含引号） c是测试数据的组数，从1开始。 提示： 对于第一、二组数据，串为112358134711235… 对于第三组数据，串为14591459145914… 样例输入123431 1 21 1 81 4 8 样例输出123Case #1: 1Case #2: 3Case #3: 9 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500;int t, c, d, n, cyc, cnt;int a[maxn], vis[maxn];int init()&#123; memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis)); a[1] = c; a[2] = d; cnt = 2; while(!vis[a[cnt-1]*10+a[cnt-0]])&#123; vis[a[cnt-1]*10+a[cnt]] = cnt; int tmp = a[cnt-1] + a[cnt]; if(tmp&lt;10) a[++cnt]=tmp; else&#123; a[++cnt]=tmp/10; a[++cnt]=tmp%10; &#125; &#125; return vis[a[cnt-1]*10+a[cnt]];&#125;int main()&#123; cin&gt;&gt;t; for(int i = 1;i&lt;=t;i++)&#123; cin &gt;&gt; c &gt;&gt; d &gt;&gt; n; int res = init(); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;; if(cnt&gt;=n) cout&lt;&lt;a[n]&lt;&lt;endl; else cout&lt;&lt;a[res+(n-res)%(cnt-res)]&lt;&lt;endl; &#125; return 0;&#125; 计数问题试计算在区间 11 到 nn 的所有整数中，数字 xx（0 \leq x \leq 90≤x≤9）共出现了多少次？例如，在 11 到 1111 中，即在 11、22、33、44、55、66、77、88、99、1010、1111 中，数字 11 出现了 4 次。 输入格式输入共 1 行，包含 2 个整数 nn、xx，之间用一个空格隔开。 输出格式输出共 1 行，包含一个整数，表示 xx 出现的次数。 数据规模与约定对于 100% 的数据，1 \leq n \leq 1,000,0001≤n≤1,000,000，0 \leq x \leq 90≤x≤9。 忽略每行输出的末尾多余空格 样例输入111 1 样例输出14 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n, x;int main()&#123; cin&gt;&gt;n&gt;&gt;x; int cnt = 0, res = 1, re = 1; int tmp = n; if(x)&#123; while(tmp)&#123; int mod = tmp%10; cnt+=(res-re)/10*mod; if(mod&gt;x) cnt+=re; else if(mod==x) cnt+=n%re+1; re*=10; res*=10; res+=re; tmp/=10; &#125; &#125; else&#123; for(int i = 1;i&lt;=n;i++) for(int j=i;j;j/=10) if(j%10==x)cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C结构体]结构体的内存对齐]]></title>
    <url>%2F2018%2F05%2F28%2F2018-05-28%2F</url>
    <content type="text"><![CDATA[结构体内存对齐规则：第一个成员在与结构体变量偏移量为0的地址处。其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数 = min（编译器默认的一个对齐数 ，该成员大小）VS 中默认的值为 8Linux 中默认的值为 4 结构体总大小为最大对齐数（每个成员变量除了第一个成员，都有一个对齐数）的整数倍。 如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。结构体的对齐数为结构体当中所有对齐数中的最大对齐数。 为什么存在内存对齐？平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需一次访问。 总的来讲：结构体的内存对齐是拿空间来换取时间的做法。 手动设置对齐模数12345678//显示当前packing alignment的字节数，以warning message的形式显示#pragma pack(show)//将当前指定的packing alignment数组进行压栈操作，这里的栈是the internal compiler stack，同时设置当前的packing alignment为n，如果n没有指定，则将当前的packing alignment数组压栈。#pragma pack(push)//从internal compiler stack中删除最顶端的reaord；如果没有指定n，则当前栈顶record即为新的packing alignment数值；如果指定了n，则n成为新的packing alignment值。#pragma pack(pop)//制定packing的数值，以字节为单位，缺省数值是8，合法的数值分别是1，2，4，8，16#pragma pack(n)]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C指针进阶]二级指针做输入的3种内存模型]]></title>
    <url>%2F2018%2F05%2F26%2F2018-05-26%2F</url>
    <content type="text"><![CDATA[对于指针，我们只需要从两个角度进行分析即可。 第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） 第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一维的还是二维的。 今天分析的二维指针三种内存模型都是指针做输入的情况，在主调函数中分配内存。 在分析指针之前，先回顾一下内存四区的知识。首先我们知道内存分为5大区，我们暂把BSS段与数据段合称为全局区或者常量区，构成内存四区。以下是内存5大区具体概况。 内存5大区 BSS段( bss segment ) 通常是指用来存放程序中未初始化的全局变量和静态变量 （这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。既然都是0那么就没必要把每个0都存储起来,从而节省磁盘空间,这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。 数据段(data segment) 通常是指用来存放程序中已经初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,但一般都是放在只读数据段中。 代码段(code segment/text segment) 通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。 堆(heap) 堆是用于存放进程运行中被动态分配的内存段,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减) 栈 (stack) 栈又称堆栈, 是用户存放程序临时创建的局部变量,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在数据段中存放变 量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的先进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。 二阶指针做输入的3种内存模型接下来我们来讨论二阶指针做输入的3种内存模型。 第1种首先第一种就是指针数组，以字符型指针数组为例定义方式为： 1char*p1[10]; 指针数组的实质是表示存放指针的数组。 第2种第二种为二维数组，以字符型二维数组为例定义方式为： 1char p2[3][4]; 第3种第三种为二维指针，以字符型二维指针为例定义方式为： 1char **p3; 二维指针是一个存放指针的指针，因此使用前需先开辟一段空间。 区别指针数组与二维指针的区别：由于二维指针储存的是指针，因此二维指针首先需要开辟空间，然后再在子元素上继续开辟空间，因此需要两步完成。 而指针数组由于本质上是数组，因此省略了第1步，只需在子元素上继续开辟空间。因此只需要1步完成。 以动态分配内存为例： 第1步 1ptr =malloc(3 *sizeof(char *));//等价于 *ptr [3]; 第2步 123ptr =malloc(3 *sizeof (char *));等价于 *ptr [3];for(i =0;i&lt;3;i++) ptr[i] =malloc(sizeof(char)*10);//表示可以存放长度为10 的字符串。 指针数组只需第2步，二维指针则需要1,2步。 而除此之外，基本再没有什么区别。他们的步长都是4，即一个指针的内存大小。 指针数组与数组指针的区别：首先，我们知道，二维数组ptr[2].[2]，ptr的实质是一个数组指针。我们知道，对于一维指针数组a[2]，a本质是指针，只不过a是一个常量指针，即a的值不能被修改。那么对于二维数组ptr[2].[2],ptr是一个常量数组指针，即ptr的值不可修改。 那么，他们本质的区别是什么呢。首先，对于char p[3]，他的步长是4。即一个指针的内存大小。 (p+1)=p[1],(int)(p+1)-(int)p=4。对于char( p )[3],他的步长是3，即一个数组内存大小。 (p+1) = p[1].[3],(int)(p+1)-(int)p=3。所以这就是为什么指针数组和数组指针不能相互赋值的原因。 内存模型示意图 代码以下是针对二维指针的3种内存模型进行排序的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;/*排序并输出第1种内存模型:指针数组*/void sort_myArray1(char **myArray, int len) &#123; printf(&quot;排序前：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;******************\n&quot;); for (int i = 0; i &lt; len; i++) /*改变指针的指向*/ for (int j = len - 1; j &gt; i; j--) &#123; if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123; char *tmp = myArray[j]; myArray[j] = myArray[j - 1]; myArray[j - 1] = tmp; &#125; &#125; printf(&quot;排序后：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;\n&quot;);&#125;/*排序并输出第2种内存模型：二维数组（数组指针）*/void sort_myArray2(char(*myArray)[4], int len) &#123; printf(&quot;排序前：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;******************\n&quot;); for (int i = 0; i &lt; len; i++) /*改变指针所指向内存的值*/ for (int j = len - 1; j &gt; i; j--) &#123; if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123; char tmp[4]; strcpy(tmp, myArray[j]); strcpy(myArray[j], myArray[j - 1]); strcpy(myArray[j - 1], tmp); &#125; &#125; printf(&quot;排序后：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;\n&quot;);&#125;/*排序并输出第3种内存模型：二维指针*/void sort_myArray3(char **myArray, int len) &#123; printf(&quot;排序前：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;******************\n&quot;); for (int i = 0; i &lt; len; i++) /*改变指针所指向内存的值，也可以改写成改变指针的指向*/ for (int j = len - 1; j &gt; i; j--) &#123; if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123; char tmp[4]; strcpy(tmp, myArray[j]); strcpy(myArray[j], myArray[j - 1]); strcpy(myArray[j - 1], tmp); &#125; &#125; printf(&quot;排序后：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;\n&quot;);&#125;/*为二级指针分配动态内存并赋值*/char**get_myArray3(int len) &#123; char**myArray = NULL; while ((myArray = (char**)malloc(3 * sizeof(char*))) == NULL) &#123; printf(&quot;Error.\n&quot;); exit(1); &#125; for (int i = 0; i &lt; 3; i++) &#123; while ((myArray[i] = (char*)calloc(100, sizeof(char))) == NULL) &#123; printf(&quot;Error.\n&quot;); exit(1); &#125; sprintf(myArray[i], &quot;%d%d%d&quot;, i + 1, i + 2, i + 3); &#125; return myArray;&#125;/*将动态分配的内存空间释放掉*/void init_myArray3(char**myArray, int len) &#123; for (int i = 0; i &lt; len; i++) if (myArray[i] != NULL) &#123; free(myArray[i]); myArray[i] = NULL; &#125;&#125;int main() &#123; char*p1[] = &#123; &quot;123&quot;,&quot;456&quot;,&quot;789&quot; &#125;; /*第1种内存模型：指针数组*/ char p2[3][4] = &#123; &quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot; &#125;; /*第2种内存模型：多维数组*/ char**p3 = get_myArray3(3); /*第3种内存模型：二维指针*/ sort_myArray1(p1, sizeof(p1) / sizeof(p1[0])); /*数组的指针个数*/ sort_myArray2(p2, sizeof(p2) / sizeof(p2[0])); /*数组的行数*/ sort_myArray3(p3, 3); /*由于sizeof(p3)为4，即一个指针的大小，故不能用sizeof(p3) / sizeof(p2[3])*/ init_myArray3(p3, 3); if (p3 != NULL) free(p3); /*释放掉二维指针分配的内存*/ p3 = NULL; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C常量]C语言中的伪装大佬——伪常量const]]></title>
    <url>%2F2018%2F05%2F25%2F2018-05-25-1%2F</url>
    <content type="text"><![CDATA[为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的const列出来，以免之后犯错。 用法首先以int为例定义整形常量a的两种方法： 12const int a;int const a; 当然，这两种方法其实是一样的，都代表的是整形常量。对于其他类型也是同样的方法。 不过对于指针，就有点特别了。首先强调，const和 的优先级是 优先级高于const。以下是以字符串为例的 3种定义方法。 123const char *p; //char const *p;char * const p;const char * const p; //char const * const p; 第一种指的是p是指向常量字符型数的指针，所指向的内存数据不可以被修改，但是本身可修改。 第2种指的是p是指向字符型数的常指针，所指向的内存数据可以被修改，但是本身不可被修改。 第3种是指向常量字符型数的常指针，所指向的内存数据补可被修改，本身也不可被修改。 伪常量用法介绍完了，但为什么说C的const是伪常量呢？因为常量是不可被更改的，但const可以通过简介赋值所改变。我们首先说一下C中的const使用时需要注意的一些细节。 const是伪常量，无法用于数组的初始化和全局变量的初始化,本质就是限定一个变量不能直接赋值。 如以下代码： 123456781 #define A 102 int arr[A];3 4 //const本质，伪常量 ,无法用于数组初始化和全局变量初始化5 /*6 const int B = 10;7 int arr[B];8 */ 但是如果局部变量是能够初始化编译并运行的 123451 void main()2 &#123;3 const int B = 10;4 int arr[B];5 &#125; const是伪常量，都知道常量是不能改变值的。例如这样是根本无法编译的。 1234561 void main() &#123;2 //num在栈区，只有栈区会自动回收释放3 //局部const常量在栈区，而不在静态区(静态区会一直存在)4 const int num = 10;//num就是一个常量5 //num = 11; //const本质，限定一个变量不能直接赋值6 &#125; 前面一直强调const是伪常量，因为可以间接的去改变它的值。利用指针变量 1234567891011121314 1 void main() &#123; 2 //num在栈区，只有栈区会自动回收释放 3 //局部const常量在栈区，而不在静态区(静态区会一直存在) 4 const int num = 10;//num就是一个常量 5 //num = 11; //error const本质，限定一个变量不能直接赋值 6 7 //间接改变常量值 8 const int *p = &amp;num;//定义一个指针指向一个常量，存储num的地址 9 int *pv = (int *)p;//对指向常量的指针进行强制转换10 *pv = 8;//对指针指向内容赋值11 12 printf(&quot;%d&quot;,num); //813 14 &#125; 结论c语言的const是冒牌货。C语言const的含义是被称为一个不能被改变的普通变量 ，它会分配内存。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>const</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[组合数学]取石子]]></title>
    <url>%2F2018%2F05%2F25%2F2018-05-25%2F</url>
    <content type="text"><![CDATA[为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。 取石子题目描述给出四堆石子，石子数分别为a,b,c,d。规定每次只能从堆顶取走石子，问取走所有石子的方案数。 输入描述:1在一行内读入四个由空格分隔的整数a,b,c,d， 输入均为不超过500的正整数 输出描述:1输出一个整数表示答案，答案对109+7取模 输入13 5 4 2 输出12522520 备注:输入均为不超过500的正整数 题解：我们一堆一堆的考虑。第一堆a，第2堆b，第3堆c，第4堆d。假如只有一堆，则只有1种情况，即C(a,a)。假如有两堆，我们可以当做这两堆石子的排列组合。可以算出两堆石子的方案数。即C(b,a+b)。第三堆我们可以把前两堆看成一堆，然后继续排列组合，即C(c,a+b+c)。第4队即C(d,a+b+c+d)。最后全部相乘即可，即C(a,a) C(b,a+b) C(c,a+b+c)*C(d,a+b+c+d)。 暴力枚举首先想到暴力枚举，虽然一定超时。以下是代码。只需要把所有情况列一遍即可。 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define ll long longll a[4];ll cnt = 0;void dfs(ll a, ll b, ll c, ll d) &#123; if (!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!d) &#123; cnt++; cnt %= 1000000000 + 7; return; &#125; if (a) dfs(a - 1, b, c, d); if (b) dfs(a, b - 1, c, d); if (c) dfs(a, b, c - 1, d); if (d) dfs(a, b, c, d - 1);&#125;int main() &#123; for (int i = 0; i &lt; 4; i++) scanf(&quot;%lld&quot;, &amp;a[i]); dfs(a[0], a[1], a[2], a[3]); printf(&quot;%lld\n&quot;, cnt); return 0;&#125; python由于数据过大，c++没有大数类，所以用python首先A了一下。 123456789101112f = input().split()ans = 1sum = [int(f[0]),0,0,0]for i in range(1,4): sum[i]=sum[i-1]+int(f[i]) for j in range(sum[i]-int(f[i])+1,sum[i]+1): ans*=jfor i in range(1,4): for j in range(1,int(f[i])+1): ans//=jans%=1000000007print(ans) c++由于acm不能用python，所以只能再考虑c++。首先由于涉及到除法，所以不能直接取余。 我没知道公式：C(M,N)=C(M-1,N)+C(M-1，N-1)，这样把除法转化成加法，就可以模运算了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int maxn = 501;const ll mod = 1000000007;ll a[4], sum[4] = &#123; 0 &#125;;ll dp[maxn * 4][maxn * 4];void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; dp[i][j] %= mod; &#125; dp[i][i] = 1; &#125;&#125;int main() &#123; init(); ll ans = 1; for (int i = 0; i &lt; 4; i++) &#123; !i ? sum[i] = 0 : sum[i] = sum[i - 1]; cin &gt;&gt; a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i]; &#125; for (int i = 1; i &lt; 4; i++) &#123; ans *= dp[sum[i]][a[i]]; ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; C(M,N)模板1234567891011void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; dp[i][j] %= mod; &#125; dp[i][i] = 1; &#125;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>Python</tag>
        <tag>组合数学</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据库]关系数据库标准语言sql]]></title>
    <url>%2F2018%2F05%2F22%2F2018-05-22%2F</url>
    <content type="text"><![CDATA[有些人生而成功，像你。有些人生而失败，像我。——随笔 概述SQL（Structured Query Language） 结构化查询语言，是关系数据库的标准语言。 SQL是一个通用的、功能极强的关系数据库语言。 特点综合统一集数据查询，数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。 可以独立完成数据库生命周期中的全部活动： 定义关系模式，插入数据，建立数据库； 对数据库中的数据进行查询和更新； 数据库重构和维护 数据库安全性、完整性控制等 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。 数据操作符统一 高度非过程化非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径。 SQL只要提出“做什么”，无须了解存取路径。 存取路径的选择以及SQL的操作过程由系统自动完成。 面向集合的操作方式非关系数据模型采用面向记录的操作方式，操作对象是一条记录。 SQL采用集合操作方式 操作对象、查找结果可以是元组的集合 一次插入、删除、更新操作的对象可以是元组的集合 以同一种语法结构提供多种使用方式SQL是独立的语言，能够独立地用于联机交互的使用方式。 SQL又是嵌入式语言，SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用。 语言简洁，易学易用SQL功能极强，完成核心功能只用了9个动词。 SQL功能 动词 数据查询 SELECT 数据定义 CREATE, DROP, ALTER 数据操纵 INSERT, UPDATE, DELETE 数据控制 GRANT, REVOKE SQL基本概念SQL支持关系数据库三级模式结构 基本表本身独立存在的表 SQL中一个关系就对应一个基本表 一个(或多个)基本表对应一个存储文件 一个表可以带若干索引 存储文件逻辑结构组成了关系数据库的内模式 物理结构是任意的，对用户透明 视图从一个或几个基本表 导出的表数据库中只存放视图的定义而不存放视图对应的数据 视图是一个虚表 用户可以在视图上再定义视图 学生-课程数据库学生-课程模式 S-T :学生表：Student(Sno,Sname,Ssex,Sage,Sdept) 课程表：Course(Cno,Cname,Cpno,Ccredit) 学生选课表：SC(Sno,Cno,Grade) Student表 学 号 Sno 姓 名 Sname 性 别 Ssex 年 龄 Sage 所 在 系 Sdept 200215121 李勇 男 20 CS 200215122 刘晨 女 19 CS 200215123 王敏 女 18 MA 200515125 张立 男 19 IS Course表 课程号 Cno 课程名 Cname 先行课 Cpno 学分 Ccredit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 PASCAL语言 6 4 SC表 学 号 Sno 课程号 Cno 成绩 Grade 200215121 1 92 200215121 2 85 200215121 3 88 200215122 2 90 200215122 3 80 数据定义SQL的数据定义功能: 模式定义、表定义、视图和索引的定义 模式的定义与删除[例1]定义一个学生-课程模式S-T CREATE SCHEMA “S-T” AUTHORIZATION WANG; 为用户WANG定义了一个模式S-T [例2]CREATE SCHEMA AUTHORIZATION WANG； &lt;模式名&gt;隐含为用户名WANG 如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt; 定义模式定义模式实际上定义了一个命名空间 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。 CREATE SCHEMA [&lt;模式名&gt;] AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;] [例3] CREATE SCHEMA TEST AUTHORIZATION ZHANG ​ CREATE TABLE TAB1(COL1 SMALLINT， ​ COL2 INT， ​ COL3 CHAR(20)， ​ COL4 NUMERIC(10，3)， ​ COL5 DECIMAL(5，2) ​ )； ​ 为用户ZHANG创建了一个模式TEST，并在其中定义了一个表TAB1。 删除模式DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE(级联) 删除模式的同时把该模式中所有的数据库对象全部删除RESTRICT(限制) 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。 当该模式中没有任何下属的对象时才能执行。 [例4] DROP SCHEMA TEST CASCADE； ​ 删除模式ZHANG ​ 同时该模式中定义的表TAB1也被删除 基本表的定义、删除与修改定义基本表CREATE TABLE &lt;表名&gt; ​ （&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] ​ [，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] … ​ [，&lt;表级完整性约束条件&gt; ] ）； 如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。 [例5] 建立“学生”表Student，学号是主码，姓名取值唯一。 CREATE TABLE Student ​ (Sno CHAR(9) PRIMARY KEY， / 列级完整性约束条件 / ​ Sname CHAR(20) UNIQUE， / Sname取唯一值/ ​ Ssex CHAR(2)， ​ Sage SMALLINT， ​ Sdept CHAR(20) ​ )； ​ [，PRIMARY KEY （Sno）] [例6] 建立一个“课程”表Course CREATE TABLE Course ​ ( Cno CHAR(4) PRIMARY KEY， ​ Cname CHAR(40)， ​ Cpno CHAR(4) ， / 先行课 / ​ Ccredit SMALLINT， ​ FOREIGN KEY (Cpno) REFERENCES Course(Cno) / Cpno是外码，被参照表是Course，被参照列是Cno / ​ ); [例7] 建立一个“学生选课”表SC CREATE TABLE SC ​ (Sno CHAR(9)， ​ Cno CHAR(4)， ​ Grade SMALLINT， ​ PRIMARY KEY (Sno，Cno)，/ 主码由两个属性构成，必须作为表级完整性进行定义/ ​ FOREIGN KEY (Sno) REFERENCES Student(Sno)， / 表级完整性约束条件，Sno是外码，被参照表是Student / ​ FOREIGN KEY (Cno) REFERENCES Course(Cno) / 表级完整性约束条件， Cno是外码，被参照表是Course/ ); 数据类型SQL中域的概念用数据类型来实现 定义表的属性时 需要指明其数据类型及长度 选用哪种数据类型 取值范围 要做哪些运算 数据类型 含义 CHAR(n) 长度为n的定长字符串 VARCHAR(n) 最大长度为n的变长字符串 INT 长整数（也可以写作INTEGER） SMALLINT 短整数 NUMERIC(p，d) 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 REAL 取决于机器精度的浮点数 Double Precision 取决于机器精度的双精度浮点数 FLOAT(n) 浮点数，精度至少为n位数字 DATE 日期，包含年、月、日，格式为YYYY-MM-DD TIME 时间，包含一日的时、分、秒，格式为HH:MM:SS 模式与表每一个基本表都属于某一个模式 一个模式包含多个基本表 定义基本表所属模式方法一：在表名中明显地给出模式名 Create table “S-T”.Student（……）; /模式名为 S-T/ Create table “S-T”.Cource（……）; Create table “S-T”.SC（……）; 方法二：在创建模式语句中同时创建表 方法三：设置所属的模式 创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式。 RDBMS会使用模式列表中第一个存在的模式作为数据库对象的模式名 。 若搜索路径中的模式名都不存在，系统将给出错误 显示当前的搜索路径： SHOW search_path; 搜索路径的当前默认值是：$user， PUBLIC 先搜索与用户名相同的模式，若不存在，则使用PUBLIC 模式与表DBA用户可以设置搜索路径，然后定义基本表 ​ SET search_path TO “S-T”，PUBLIC； ​ Create table Student（……）; 结果建立了S-T.Student基本表。 RDBMS发现搜索路径中第一个模式名S-T存在，就把该模式作为基本表Student所属的模式。 修改基本表ALTER TABLE &lt;表名&gt; [ ADD [&lt;新列名&gt; &lt;数据类型&gt;].[完整性约束 ]] [ DROP &lt;完整性约束名&gt; ] [ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]； MODIFY 约束（属性名）]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据库]数据库概论基础整理]]></title>
    <url>%2F2018%2F05%2F21%2F2018-05-21%2F</url>
    <content type="text"><![CDATA[努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔 数据库系统概述四个基本概念数据（Data）数据(Data)：数据库中存储的基本对象。 定义：描述事物的符号记录 种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等 特点：数据与其语义是不可分的。 eg： 54是一个数据 语义1：学生某门课的成绩 语义2：某人的体重 语义3：计算机系2011级学生人数 eg: 学生档案中的学生记录 （张三，男，19941014，陕西西安市，计算机系，2011） 语义：学生姓名、性别、出生年月、籍贯、所在院系、入学时间 解释：张三是个大学生，1994年10月14日出生，陕西省西安市人，2011年考入计算机系 数据库（DB）数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。 特征数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统（DBMS）定义位于用户与操作系统之间的一层数据管理软件。 是基础软件，是一个大型复杂的软件系统 用途科学地组织和存储数据、高效地获取和维护数据。 数据库在计算机系统中的位置 功能 数据定义功能 提供数据定义语言(DDL) 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据操纵功能 提供数据操纵语言(DML) 实现对数据库的基本操作 (增删改查) 数据库的事务管理和运行管理 数据库在建立、运行和维护时由DBMS统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复 数据库的建立和维护功能(实用程序和管理工具) 数据库初始数据装载转换 数据库转储 介质故障恢复 数据库的重组织 性能监视分析等 其它功能 DBMS与网络中其它软件系统的通信 两个DBMS系统的数据转换 异构数据库之间的互访和互操作 数据库系统（DBS)Database System，在计算机系统中引入数据库后的系统。 构成数据库 数据库管理系统（及其开发工具） 应用系统 数据库管理员 数据管理技术的产生和发展什么是数据管理对数据进行分类、组织、编码、存储、检索和维护 是数据处理的中心问题 数据处理：对各种数据进行收集、存储、加工和传播。 数据管理技术的发展过程人工管理阶段(20世纪40年代中–50年代中) 文件系统阶段(20世纪50年代末–60年代中) 数据库系统阶段(20世纪60年代末–现在) 数据管理技术的发展动力应用需求的推动 计算机硬件的发展 计算机软件的发展 数据库系统的特点数据结构化整体数据的结构化是数据库的主要特征之一。 整体结构化不再仅仅针对某一个应用，而是面向全组织 不仅数据内部结构化，整体是结构化的，数据之间具有联系 数据库中实现的是数据的真正结构化数据的结构用数据模型描述，无需程序定义和解释 数据可以变长 数据的最小存取单位是数据项 数据的共享性高，冗余度低，易扩充数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。 数据共享的好处减少数据冗余，节约存储空间 避免数据之间的不相容性与不一致性 使系统易于扩充 数据独立性高数据独立性是由DBMS的二级映像功能来保证的。 物理独立性指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。 逻辑独立性指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。 数据由DBMS统一管理和控制DBMS提供的数据控制功能(1)数据的安全性（Security） 保护保护数据，以防止不合法的使用造成的数据的泄密和破坏。 (2)数据的完整性（Integrity） 检查将数据控制在有效的范围内，或保证数据之间满足一定的关系。 (3)并发（Concurrency） 控制对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。 (4)数据库恢复（Recovery） 将数据库从错误状态恢复到某一已知的正确状态。 应用程序与数据的对应关系(数据库系统) 数据模型两大类数据模型数据模型分为两类（分属两个不同的层次） (1) 概念模型 也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。 (2) 逻辑模型和物理模型 逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。 物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。 设计人员了解和选择物理模型。 客观对象的抽象过程—两步抽象 现实世界中的客观对象抽象为概念模型； 把概念模型转换为某一DBMS支持的数据模型。 数据模型组成元素数据结构，数据操作，完整性约束条件 数据结构描述数据库的组成对象，以及对象之间的联系 数据结构是对系统静态特性的描述（描述对象类型的集合） 描述的内容与数据类型、内容、性质有关的对象（域、属性、关系） 与数据之间联系有关的对象 数据操作对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则 数据操作的类型查询 更新(包括插入、删除、修改) 数据模型对操作的定义操作的确切含义 操作符号 操作规则（如优先级） 实现操作的语言 数据操作是对系统动态特性的描述 数据的完整性约束条件一组完整性规则的集合。 完整性规则：给定的数据模型中数据及其联系所具有的制约和储存规则 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。 定义反映和规定本数据模型必须遵守的基本的通用的完整性约束条件。例如在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。如：退休 概念模型用途概念模型用于信息世界的建模 是现实世界到机器世界的一个中间层次 是数据库设计的有力工具 数据库设计人员和用户之间进行交流的语言 对概念模型的基本要求较强的语义表达能力 能够方便、直接地表达应用中的各种语义知识 简单、清晰、易于用户理解 信息世界中的基本概念实体（Entity）客观存在并可相互区别的事物称为实体。 可以是具体的人、事、物或抽象的概念。如：选课 属性（Attribute）实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画。 码（Key） 唯一标识实体的属性集称为码。如：Snum 域（Domain）属性的取值范围称为该属性的域。 如：Grade 实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 如：Student(Snum,Sname,Grade ) 实体集（Entity Set）同一类型实体的集合称为实体集 联系（Relationship）现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。 实体内部的联系通常是指组成实体的各属性之间的联系 实体之间的联系通常是指不同实体集之间的联系 两个实体型之间的联系用图形来表示两个实体型之间的这三类联系 一对一联系（1:1） 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1 实例 一个班级只有一个正班长，一个班长只在一个班中任职 一对多联系（1：n）如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n 实例 一个班级中有若干名学生，每个学生只在一个班级中学习 多对多联系（m:n）如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n 实例 课程与学生之间的联系：一门课程同时有若干个学生选修，一个学生可以同时选修多门课程 两个以上实体型之间的联系两个以上实体型之间一对多联系若实体集E1，E2，…，En存在联系，对于实体集Ej（j=1，2，…，i-1，i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的 实例 课程、教师与参考书三个实体型一门课程可以有若干个教师讲授，使用若干本参考书，每一个教师只讲授一门课程，每一本参考书只供一门课程使用课程与教师、参考书之间1：n 两个以上实体型间的多对多联系两个以上实体型间的多对多联系 实例 供应商、项目、零件三个实体型,一个供应商可以供给多个项目多种零件,每个项目可以使用多个供应商供应的零件,每种零件可由不同供应商供给 单个实体型内的联系一对一联系一对多联系实例 职工实体型内部具有领导与被领导的联系,某一职工（干部）“领导”若干名职工,一个职工仅被另外一个职工直接领导,这是一对多的联系 多对多联系 概念模型的一种表示方法实体－联系方法(E-R方法)用E-R图来描述现实世界的概念模型 E-R方法也称为E-R模型 E-R图实体型 用矩形表示，矩形框内写明实体名。 属性 用椭圆形表示，并用无向边将其与相应的实体连接起来 联系 联系本身： 用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n） 联系的属性： 联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 最常用的数据模型非关系模型（格式化模型）层次模型(Hierarchical Model) 实体-&gt;记录 网状模型(Network Model) 属性-&gt;字段（数据项） 非关系模型中数据结构基本单位基本层次联系：两个记录以及它们之间的一对多（包括一对一）的联系。 关系模型(Relational Model)面向对象模型(Object Oriented Model）对象关系模型(Object Relational Model)层次模型(最早的模型)层次模型用树形结构来表示各类实体以及实体间的联系 满足下面两个条件的基本层次联系的集合为层次模型 有且只有一个结点没有双亲结点，这个结点称为根结点 根以外的其它结点有且只有一个双亲结点 层次模型中的几个术语 根结点，双亲结点，兄弟结点（同一双亲的节点），叶结点（没有子女的节点） 网状模型网状数据库系统采用网状模型作为数据的组织方式 满足下面两个条件的基本层次联系的集合： 允许一个以上的结点无双亲； 一个结点可以有多于一个的双亲。 表示方法(与层次数据模型相同) 实体型：用记录类型描述每个结点表示一个记录类型（实体） 属性：用字段描述每个记录类型可包含若干个字段 联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系 关系模型关系数据库系统采用关系模型作为数据的组织方式。 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。 关系（Relation）一个关系对应通常说的一张表 元组（Tuple）表中的一行即为一个元组 属性（Attribute）表中的一列即为一个属性，给每一个属性起一个名称即属性名 主码（Key）表中的某个属性或属性组，它可以唯一确定一个元组。 域（Domain）属性的取值范围。 分量元组中的一个属性值。 关系模式对关系的描述 关系名（属性1，属性2，…，属性n） 学生（学号，姓名，年龄，性别，系，年级） 术语对比 关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中有表（大表中嵌有小表） 关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。 数据操作查询 插入 删除 更新 数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合 存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干” 关系的完整性约束条件实体完整性 参照完整性 用户定义的完整性 数据库系统结构从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。 从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为: 单用户结构 主从式结构分布式结构 客户／服务器 浏览器／应用服务器／数据库服务器多层结构等 数据库系统模式的概念“型” 和“值” 的概念型(Type)对某一类数据的结构和属性的说明 值(Value)是型的一个具体赋值例如学生记录 型： （学号，姓名，性别，系别，年龄，籍贯）一个记录 值： （900201，李明，男，计算机，22，江苏） 模式（Schema）数据库逻辑结构和特征的描述 是型的描述 反映的是数据的结构及其联系 模式是相对稳定的 实例（Instance）模式的一个具体值 反映数据库某一时刻的状态 同一个模式可以有很多实例实例 随数据库中的数据的更新而变动 例如：在学生选课数据库模式中，包含学生记录、课程记录和学生选课记录 2013年的一个学生数据库实例，包含： 2013年学校中所有学生的记录 学校开设的所有课程的记录 所有学生选课的记录 2012年度学生数据库模式对应的实例与2013年度学生数据库模式对应的实例是不同的 数据库系统的三级模式结构 模式（Schema也称逻辑模式）数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图，综合了所有用户的需求 一个数据库只有一个模式 模式的地位：是数据库系统模式结构的中间层与数据的物理存储细节和硬件环境无关 与具体的应用程序、开发工具及高级程序设计语言无关 模式的定义数据的逻辑结构（数据项的名字、类型、取值范围等） 数据之间的联系 数据有关的安全性、完整性要求 外模式（External Schema也称子模式或用户模式）数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 模式与外模式的关系：一对多外模式通常是模式的子集 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求 对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同 外模式与应用的关系：一对多同一外模式也可以为某一用户的多个应用系统所使用 但一个应用程序只能使用一个外模式 外模式的用途保证数据库安全性的一个有力措施 每个用户只能看见和访问所对应的外模式中的数据 内模式（Internal Schema也称存储模式）一个数据库只有一个内模式 是数据物理结构和存储方式的描述是数据在数据库内部的表示方式记录的存储方式（堆存储，顺序存储，聚簇存储） 索引的组织方式（B+树索引，按hash索引存储） 数据是否压缩存储 数据是否加密 数据存储记录结构的规定 数据库的二级映像功能与数据独立性 数据库的二级映像功能与数据独立性三级模式是对数据的三个抽象级别 二级映象在DBMS内部实现这三个抽象层次的联系和转换 外模式／模式映象模式：描述的是数据的全局逻辑结构 外模式：描述的是数据的局部逻辑结构 同一个模式可以有任意多个外模式 每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系 映象定义通常包含在各自外模式的描述中 保证数据的逻辑独立性当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 模式／内模式映像模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的 数据库中模式／内模式映象是唯一的 该映象定义通常包含在模式描述中 保证数据的物理独立性当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变 应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。 数据库模式即全局逻辑结构是数据库的中心与关键 独立于数据库的其他层次 设计数据库模式结构时应首先确定数据库的逻辑模式 数据库的内模式依赖于它的全局逻辑结构 独立于数据库的用户视图，即外模式 独立于具体的存储设备 将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 数据库的外模式面向具体的应用程序 定义在逻辑模式之上 独立于存储模式和存储设备 当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 设计外模式时应充分考虑到应用的扩充性 特定的应用程序在外模式描述的数据结构上编制的 依赖于特定的外模式 与数据库的模式和存储结构独立 不同的应用程序有时可以共用同一个外模式 数据库的二级映像保证了数据库外模式的稳定性 从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去 数据的存取由DBMS管理用户不必考虑存取路径等细节 简化了应用程序的编制 大大减少了应用程序的维护和修改 数据库系统的组成数据库 数据库管理系统（及其开发工具） 应用系统 数据库管理员]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM全国邀请赛热身赛题2并查集]]></title>
    <url>%2F2018%2F05%2F19%2F2018-05-19%2F</url>
    <content type="text"><![CDATA[真是糟糕的一天，愿不要影响到明天邀请赛发挥。 题意： 有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可能叛徒数，否则输出-1，遇到第几条时判断是谎言。 例： 输入 3 3 1 2 2 3 3 1 输出 -1 3 输入 5 4 1 2 2 3 3 4 4 1 输出 1 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int MAXX = 100010;int fa[MAXX], r[MAXX];int vis[MAXX];int find(int x)&#123; if (fa[x] == x) return fa[x]; int tmp = fa[x]; fa[x] = find(fa[x]); r[x] = (r[tmp] + r[x]) % 2; return fa[x];&#125;void fun(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx == fy) return; fa[fy] = fx; r[fy] = (r[x] + 1 - r[y]) % 2;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int N, M, x, y, flag = 0, cnt = 0; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt;= N; i++) fa[i] = i, r[i] = 0; for (int i = 1; i &lt;= M; i++) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (!vis[x]) cnt++; if (!vis[y]) cnt++; vis[x] = vis[y] = 1; if (flag) continue; if (find(x) == find(y)) &#123; if (r[x] == r[y]) flag = i; &#125; else fun(x, y); &#125; if (flag) printf(&quot;-1 %d\n&quot;, flag); else &#123; int cnt2 = 0; for (int i = 1; i &lt;= N; i++) &#123; find(i); if (r[i] == 1 || !vis[i]) cnt2++; &#125; printf(&quot;1 %d\n&quot;, cnt - cnt2 &gt; cnt2 ? cnt - cnt2 : cnt2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛&&艾教习题总结]]></title>
    <url>%2F2018%2F05%2F16%2F2018-05-16%2F</url>
    <content type="text"><![CDATA[管道取珠 输入 第一行包含两个整数n, m，分别表示上下两个管道中球的数目。 第二行为一个AB字符串，长度为n，表示上管道中从左到右球的类型。其中A表示浅色球，B表示深色球。 第三行为一个AB字符串，长度为m，表示下管道中的情形。 输出 仅包含一行，即为 Sigma(Ai^2) i从1到k 除以1024523的余数。 输入示例 1232 1ABB 输出示例 15 数据规模及约定 约30%的数据满足 n, m ≤ 12；约100%的数据满足n, m ≤ 500。 题解 这题思路比较妙，我们需要先想想 ∑ai2 有什么意义。如果我们构造出这样一个游戏场景，即两个人同时玩两份同样的如题目所述的管道取珠的游戏，那么这两个人游戏结束后取到的珠子颜色序列一模一样的方案数就是题目里要求的答案。 令这两个人分别是 p1 和 p2。于是设 f[i][j][k] 表示 p1 取了第二个管道中的前 i 个珠子，第一个管道中的前 j 个珠子；p2 取了第一个管道的前 k 个珠子，这个状态下颜色序列相同的方案数，转移显然。 注：n为12以内一般是阶乘的题，n为30以内可以考虑状态压缩，莫队，线段树等各种情况，50左右选择二分，100以上需要另想方法。 问号猜数有一堆数按照递增的顺序排列，然而这些数的某些位我们并不知道，我们知道的只是这些数是从小到大排列的，现在依次给出这些数，不知道的位用？表示。我们需要猜这个数能满足递增条件的最小数。例如： ?? 1? ?1 ??? ?99 ?9? ?4?5 第一个数是10，第2个11，第3个21，第4个100，第5个199，第6个290，第7个1405。 题解 用贪心虽然比较快，但代码不容易写，须考虑情况挺多。因此我们分析一下。首先n&lt;=6，代表最大位数是6，也就是说最大的数也就是百万位。因此直接从1枚举，另设指针指向第1个数，每枚举到某个数满足该指针指向的数，则将指针指向下一个数，然后继续枚举，因此扫描一遍之后就得到所有的答案了。 接下来，假如n&lt;=15，由于数是递增的，则将枚举用二分来完成。假如n&gt;=100，这时再考虑贪心。 取牌去牌有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌ii.j，得到一个ai bj + bi aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。 题解 主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。 铁索连环有n个数，现在有m次查询，每次查询[l,r]范围所有不同的数。假设n很大 题解 我的思路是打表记录上一个相同元素的位置，比如a[1-10]=1,2,4,3,2,4,5,6,3,4,那么b[1-10]=0,0,0,0,2,3,0,0,4,6。这样l，r的范围内只需扫描1遍即可，扫到0结果加1，扫到非0的数看该下标是否 &lt; l，是则加1，否则不处理。时间复杂度是0mn。 艾教的方法不是很懂，不过举了一个例子，假如(3(3(3(3(3)))))，查询范围为括号所示，那么只需将第5个3赋为1，其他3赋为0即可。看起来最后就像一条链子捆绑着相同的元素。 狭路相逢有一个图，每条路上都有强盗，每个节点都有驴友，假如到某条路上，该路上的强盗抢劫你的条件是强盗人数大于等于你们人数。你们每经过一个节点可以拉驴友入伍结伴而行，问（忘记问什么了，尴尬~QAQ~） 题解 并查集 区间gcd给定l，r，问多少种gcd(l,r)==gcd(l2.r2) 题解 1、两个条件，从1到n，最大公约数呈递减阶梯式。 2、gcd(gcd（a,b）,gcd(c,d))==gcd(a,d) 根据性质2可以用st表列出范围内l，r的最大公约数，即1，n最大公约数 根据性质1，二分求解 信号误差艾教给女朋友传情发信号，信号是01串（16位）组成的字母，但是有情敌的干扰，途中可能至多会有两位进制会发生改变。问如何设置01串才能无视干扰准确将信号传给女盆友。例如1111111111111111，那么该2个1也是比0多，所以无视干扰。但每次只能处理一个字母，效率太慢。 题解 图论。将距离2以内的所有结点全部连起来。贪心选取结点，可以直接选择第一个结点开始。 牛客小白月赛音标题目描述 我们规定元音字母有a、e、i、o、u，并且规定半元音字母y也是元音字母。 Cwbc在学习英语，XHRlyb为了让Cwbc的记忆更加深刻，于是她让Cwbc把每个字符串的所有字母都变成一个恰好**不大于它本身的小写元音字母**。 输入描述:1输入数据有多行，每行有一个仅包含小写字母的字符串。 输出描述:1输出数据应有多行，每行有一个变化后的字符串。 示例1 输入1aeiou 输出1aeiou 说明1元音字母变为一个恰好不大于它本身的字母，也就是元音字母本身 示例2 输入1bfjpv 输出1aeiou 说明1输入样例是由元音字母a、e、i、o、u的后一个字母组成，每个字母变为一个恰好不大于它本身的字母，也就是a、e、i、o、u。 备注:1每行字符串长度不超过2×105，字符串总长度不超过106。 代码upper_bound的应用 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[210000];char a[]=&quot;aeiouy&quot;;int main()&#123; while(cin&gt;&gt;s) &#123; for(int i=0;s[i];i++) &#123; s[i]=a[upper_bound(a,a+6,s[i])-a-1]; &#125; puts(s); &#125;&#125; 躲藏题目描述XHRlyb和她的小伙伴Cwbc在玩捉迷藏游戏。 Cwbc藏在多个不区分大小写的字符串中。 好奇的XHRlyb想知道，在每个字符串中Cwbc作为子序列分别出现了多少次。 由于Cwbc可能出现的次数过多，你只需要输出每个答案对2000120420010122取模后的结果。 聪明的你在仔细阅读题目后，一定可以顺利的解决这个问题！ 输入描述:1输入数据有多行，每行有一个字符串。 输出描述:1输出数据应有多行，每行表示一个答案取模后的结果。 示例1 输入1Cwbc 输出11 说明1Cwbc作为子序列仅出现了1次。 示例2 输入1acdcecfwgwhwibjbkblcmcnco 输出181 说明1Cwbc作为子序列出现了34=81次。 备注:1每行字符串长度不超过2×105，字符串总长度不超过106。 代码一个memset导致超时，也是够无语。时间复杂度4 On，加上memset是5 On，就差1个On就超时。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;char str[200010];long long dp[5][200010];int main() &#123; int i; while (scanf(&quot;%s&quot;, str + 2) != EOF) &#123; dp[1][0] = &apos;c&apos;, dp[2][0] = &apos;w&apos;, dp[3][0] = &apos;b&apos;,dp[4][0] = &apos;c&apos;; for (i = 2; str[i]; i++) &#123; dp[0][i] = 1; str[i] = tolower(str[i]); for (int k = 1; k &lt; 5; k++) &#123; dp[k][i] = dp[k][i - 1]; if (str[i] == dp[k][0]) &#123; dp[k][i] += dp[k - 1][i]; dp[k][i] %= 2000120420010122; &#125; &#125; &#125; printf(&quot;%lld\n&quot;, dp[4][i - 1]); &#125; return 0;&#125; 博弈 博弈双方都是绝顶聪明的，并且XHRlyb先手，请你来帮XHRlyb预测这一局游戏谁会获胜。 如果博弈双方谁也无法取胜，那么判定为平局。 输入描述:1输入数据有多行，每行有三个正整数，l，r，k。 输出描述:1输出数据应有多行，如果这一局XHRlyb获胜，那么请输出XHRlyb；如果Cwbc获胜，请输出Cwbc；如果两人平局，请输出Draw。 示例1 输入11 3 2 输出1XHRlyb 示例2 输入11 4 2 输出1Cwbc 备注:1231 ≤ l ≤ r ≤ 105。1 ≤ k ≤ 100。1 ≤ T ≤ 1000。 代码水dp，l，r写反了，一直报错 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int dp[100005];int sum[100005];int main() &#123; int l, r, k; while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; k) &#123; memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum)); if (k == 1) &#123; cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; continue; &#125; for (int i = 1; i &lt; k; i++) &#123; dp[i] = 1; sum[i] = (sum[i - 1] + 1); &#125; for (int i = k; i &lt;= r; i++) &#123; dp[i] = (dp[i / k] * k + 1); sum[i] = (sum[i - 1] + dp[i]); &#125; if (abs(sum[r] - sum[l - 1]) % 2 == 1) cout &lt;&lt; &quot;XHRlyb&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Cwbc&quot; &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>动态规划</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陕西师范大学第七届程序设计竞赛题解]]></title>
    <url>%2F2018%2F05%2F14%2F2018-05-14%2F</url>
    <content type="text"><![CDATA[WWX的520题目描述520，因为谐音为我爱你，所以也被称之为表白日。 这一天，人们借机把藏在心底的洪荒之力通过表白、撒娇、传情、送礼、结婚等形式释放出来，商家也会趁势开展各类优惠促销活动，掀起一波或浪漫或虐狗的节日热浪。 这一天，也是送男朋友礼物、送女朋友礼物、送自己礼物、送亲朋好友礼物的好时机。 在520即将到来之际，wwx准备为她的女朋友购买一批礼物。于是他列出了一份礼物清单，但由于预算有限，必须删掉一种礼物。经过深思熟虑，他决定删掉价格第k高的礼物，你能帮帮他，找出是哪一种礼物吗? 输入描述:1234第一行是一个整数T（1&lt;=T&lt;=80），表示有T组数据.对于每一组数据，首先一行输入N(3&lt;=N&lt;=1000)，接下来的N行每行输入一个字符串和一个整数，以空格间隔，分别作为每种礼物的名字和价格。接下来一行输入k，表示要删去第k(1&lt;=&lt;=N)高的礼物礼物的名字的长度不超过30，礼物的价格不超过1000，且均为整数。 输出描述:12对于每组输入数据，依次输出它的组号和要删去的礼物的名字和价格,以空格间隔。若两种商品的价格相同，则比较礼物名字的字典序大小。即:两种礼物的价格相同时，字典序大者若为第k高，字典序小者则为第k+1高。 示例1 输入12345678910111223Apple 18Book 30Milk 800034Apple 300Bananas 200Bracelet 200Candy 2003 输出12#1: Apple 18#2: Bracelet 200 备注:123451.可用strcmp(s1,s2)函数进行字符串的比较。2.对于样例一中第二组数据:Apple 300是价格第一大，Candy 200是价格第二高，Bracelet200是价格第三大。 题解直接按照价格从大到小排序，如果价格相同按照字母序从大到小排序。排完序之后直接输出第k位的礼物名称与价格即可。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node &#123; string str; int v;&#125;a[1005];int cmp(node a, node b) &#123; if (a.v == b.v) &#123; return a.str&gt;b.str; &#125; return a.v&gt;b.v;&#125;int main() &#123; int t; cin &gt;&gt; t; for (int z = 1; z &lt;= t; z++) &#123; int n, k; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].str; cin &gt;&gt; a[i].v; &#125; sort(a, a + n, cmp); cin &gt;&gt; k; cout &lt;&lt; &quot;#&quot; &lt;&lt; z &lt;&lt; &quot;: &quot; &lt;&lt; a[k - 1].str &lt;&lt; &quot; &quot; &lt;&lt; a[k - 1].v &lt;&lt; endl; &#125; return 0;&#125; 配环境题目描述​ 黑猫在给校赛配环境，结果被服务器的各种入站规则出站规则搞得头疼，想到自己要上传GVIM、EMACS、VSCODE、Jetbrain全家桶、Visual Studio、Gedit、Microsoft Office Word、Eclipse等等，完全不知道要要花费多少时间才能上传完校赛需要的环境。 ​ 黑猫跑去问ddjing，谁知道ddjing说：“我要去实习了，没功夫解决这个问题，你去问问其他人吧。“ ​ 于是黑猫想请你帮他解决这个问题。 ​ 服务器总传输速度为每秒M个单位（本题出现的所有单位都统一），黑猫现在需要上传总共n个软件（按优先级顺序从高到低给出），每个软件的大小分别为v1、v2….vn，每个软件为保持稳定连接，上传需要一个最小的传输速度为m1、m2…mn。 ​ 服务器带宽分配的策略是：按优先级满足每一个软件要求的传输速度。如果服务器剩余的带宽不能满足某个软件最小传输速度的话，服务器将继续寻找下去，直到找到能满足最小传输速度的软件。 ​ 如果目前服务器的总传输速度不能满足所有还需要上传的软件的话，服务器将把传输速度全部给予当前优先级最高的（即使不能满足其最小传输速度）。 ​ 如果目前对所有软件都满足了其最小传输速度的话，服务器将把剩余所有传输速度全部给予当前优先级最高的软件。 输入描述:12345第一行给出一个正整数，表示服务器总带宽M第二行给出整数n，表示需要上传的n个软件。第三行为n个正整数，第i个数表示vi。第四行为n个正整数，第i个数表示mi。( 1 &lt;= M &lt;= 1000, 1 &lt;= n &lt;= 100 , 1 &lt;= vi &lt;= 1000 , 1 &lt;= mi &lt;= 1000 ) 输出描述:1输出一行，为上传完毕所有软件所需要的时间，保留两位小数。 示例1 输入12341061 1 4 5 1 4 10 9 8 7 6 5 输出11.60 示例2 输入123410610 9 8 7 6 51 1 4 5 1 4 输出14.50 题解原本是一道水题，结果成功被题面绕进去了。其实只需要把所有软件的大小V加起来除以宽带大小M即可。所谓最小速度都是迷惑人的。 代码12345678910111213141516#include&lt;stdio.h&gt;int main() &#123; int M, n; scanf(&quot;%d%d&quot;, &amp;M, &amp;n); double tmp, ans = 0; for (int i = 0; i &lt; n;i++) &#123; scanf(&quot;%lf&quot;, &amp;tmp); ans += tmp; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lf&quot;, &amp;tmp); &#125; ans /= M; printf(&quot;%.2lf\n&quot;, ans); return 0;&#125; 下面是一段超时代码，成功将题面的过程给模拟了出来，当时没仔细看数据是怎么得到的，一直超时很不可思议。因此总结出了经验，以后做题一定得分析出数据是怎么得到的，有时候就很容易找到规律或者发现玄机。另外下面的代码总结出了一个新的方法，就是利用滚动数组实现删除元素，虽然vector有删除功能，但删除效率低。以下的方法是利用滚动数组，将未删除的元素重新压入数组，删除的元素不进行操作，然后清空数组，这样循环操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;#define inf 0x3f3f3f3fint M, n;struct node&#123; double v; int m;&#125;a[1005];int vis[1005];vector&lt;int&gt;vv[2];int main() &#123; cin &gt;&gt; M &gt;&gt; n; double ans = 0, wei; int ff[2] = &#123; 0,1 &#125;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].v; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].m; vv[ff[0]].push_back(i); &#125; int flag = 1; while (flag &gt;= 0) &#123; flag = -1; wei = M; double mint = inf; vv[ff[1]].clear(); vector&lt;int&gt;::iterator it; for (it = vv[ff[0]].begin(); it != vv[ff[0]].end(); it++) &#123; if (a[*it].v &lt;= 0) &#123; continue; &#125; vis[*it] = 0; vv[ff[1]].push_back(*it); if (flag &lt; 0) flag = *it; if (a[*it].v &lt;= wei) &#123; vis[*it] = 1; wei -= a[*it].m; if (*it != flag) mint = min(mint, a[*it].v / a[*it].m); &#125; &#125; if (flag &lt; 0) break; mint = min(mint, a[flag].v / (vis[flag] ? a[flag].m + wei : wei)); for (it = vv[ff[1]].begin(); it != vv[ff[1]].end(); it++) &#123; if (a[*it].v &lt;= 0 || !vis[*it] || flag == *it) continue; a[*it].v -= a[*it].m*mint; &#125; a[flag].v -= (vis[flag] ? a[flag].m + wei : wei)*mint; ans += mint; ff[0] = ff[0] ^ ff[1]; ff[1] = ff[0] ^ ff[1]; ff[0] = ff[0] ^ ff[1]; //cout &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; mint &lt;&lt; endl; &#125; printf(&quot;%.2lf\n&quot;, ans); return 0;&#125; iko和她的糖题目描述​ iko超级超级喜欢吃糖，有一天iko想出去玩，她计划从1点走到N点（按1,2,3，…，n的顺序走），每个点都有一个补给站，第i点的补给站有a[i]颗糖，从i点走到i+1点会消耗掉b[i]颗糖，iko在出游的途中可以选择三个补给站，iko想知道她走完全程到达N点时口袋里最多还能剩下几颗糖（初始时iko的口袋里一颗糖都没有）。 输入描述:123第一行输入N（3&lt;=N&lt;=1000）第二行输入N个数代表a[1].......a[N] (0&lt;=a[i]&lt;=1000 )第三行输入N-1个数代表b[1]......b[N-1] ( 1&lt;=b[i]&lt;=1000 ) 输出描述:12输出一个数字表示iko到达n点时口袋里最多剩下的糖，若不能到达N点输出-1。 示例1 输入12331 3 43 4 输出1-1 示例2 输入12353 4 5 2 43 2 2 2 输出13 题解首先，3个补给站必须得选择第1个，因为一开始没有糖，而每条路都需要消耗糖，所以必须拿起点的糖。之后就很好理解了，每走一条路记录当前走过的补给站最大的两个，如果哪一条路糖果不够了，就把最大的补给站加上，如果还不够就把次大的也加上。每次记录走到这条路经过的最大补给站记录下来，然后现有糖果减去消耗的糖果，如果为负就把之前的最大补给站的糖果加上。例如第2组数据，初始是3，走到第1条路剩余糖果为0，此时记录的最大补给站是4，然后走到下一条路糖果变成了-2，那就把最大补给站的加上，现在剩余糖果是2。此时最大补给站记录5，再往下走是2，剩余糖果是0，继续走，消耗2个为-2，则加上最大补给站的糖5。最终就是3。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1005;int N, cur, MAX1, MAX2, flag, a[maxn];void check(int &amp;cnt) &#123; while (cnt&amp;&amp;cur &lt; 0) &#123; cur += MAX1; MAX1 = MAX2; cnt--; &#125;&#125;void fun(int i) &#123; if (MAX1 &lt;= a[i]) &#123; MAX2 = MAX1; MAX1 = a[i]; &#125; else if (MAX2 &lt; a[i]) &#123; MAX2 = a[i]; &#125;&#125;int main() &#123; while (cin &gt;&gt; N) &#123; memset(a, 0, sizeof(a)); MAX1 = -1, MAX2 = -1, flag = 0; int tmp, cnt = 3; cur = 0; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; N - 1; i++) &#123; fun(i); cin &gt;&gt; tmp; cur -= tmp; if (cur &lt; 0) &#123; check(cnt); &#125; if (cur &lt; 0) flag = 1; &#125; fun(N - 1); if (flag) printf(&quot;-1\n&quot;); else &#123; if (cnt == 2) cur += MAX1 + MAX2; else if (cnt == 1) cur += MAX1; printf(&quot;%d\n&quot;, cur); &#125; &#125; return 0;&#125; ZQ的睡前故事题目描述​ ZQ是一个拥有n女朋友的万人迷，她的每一个女朋友每天晚上都会挨个给他打电话，要他讲了睡前故事才能睡觉。可是，每次他的女朋友都会挑他在吃鸡的时候打电话，ZQ总是因为挂机被舍友赶出宿舍，于是，ZQ告诉他的女朋友们，别打电话了，他会主动打过去给他们讲故事，再打电话就分手！ ​ 于是，ZQ把他的女朋友名字写在纸上，画成一圈，顺时针编号为1~n，然后从1开始顺时针数。在每一次数数中，ZQ数k个就停下来，然后给选中的女朋友打电话讲故事。 输入描述:1先输入一个t，然后t组数据，每行包含两个数字n,k，n&lt;20,k&gt;0 输出描述:1按顺序输出每轮被选中的女朋友的编号。 示例1 输入1234310 35 211 4 输出1233 6 9 2 7 1 8 5 10 42 4 1 5 34 8 1 6 11 7 3 2 5 10 9 题解约瑟夫环。由于数据比较水，所以多种方法求解，这里不介绍了。 代码12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main() &#123; int n, k, t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); int i = 0; int cnt = n; int vis[20] = &#123; 0 &#125;; while (cnt) &#123; int kk = k; while (vis[i%n]) i++; for (int j = 1; j &lt; kk; j++) &#123; i++; while (vis[i%n]) i++; &#125; vis[i%n] = 1; cnt--; cnt ? printf(&quot;%d &quot;, i%n + 1) : printf(&quot;%d\n&quot;, i%n + 1); &#125; &#125; return 0;&#125; 附加：hdu5135 Little Zu Chongzhi’s Triangles题意： 有n条边组三角形，每个三角形必须由3条边组成，三角形边不可以重复利用，不可以共线，只能是分开的三角形。问这n条边组成的所有三角形的面积和最大为多少。 题解原本状压dp求解，但数据比较水，因此递归还没有记忆化搜索直接就过了。每次从n条边里面选择3条边组成三角形，方程maxx[i],[j] = max(maxx[i-1],[j],[1~n] );由于状态是集合，因此需要状压以下。这里主要说的是一个常犯的错误。我没找到vis是当前状态是否已经选过，尤其是搜索时vis的作用非常重要。但本题用深搜时犯了一个错误，就是在vis=1,与vis=0之间多了一个continue，即vis=1，continue，dfs，vis=0，导致状态更改，数据一直错误。正确顺序应该是continue，vis=1，dfs，vis=0。因此之后比赛时一定要注意此细节。在vis=1与vis=0之间一定要注意是否有其他条件导致循环结束而状态还未还原。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n;int vis[15];double a[15];double dfs(int x) &#123; double ans = 0, maxx = 0; for (int i = x; i&lt;n; i++) &#123; if (vis[i]) continue; vis[i] = 1; for (int j = i + 1; j&lt; n; j++) &#123; if (vis[j]) continue; vis[j] = 1; for (int k = j + 1; k&lt;n; k++) &#123; if (vis[k]) continue; if (a[k] &gt;= a[i] + a[j] || a[j] &gt;= a[i] + a[k] || a[i] &gt;= a[j] + a[k]) continue; vis[k] = 1; double c = (a[i] + a[k] + a[j]) / 2.0; ans = sqrt(c*(c - a[i])*(c - a[j])*(c - a[k])); ans += dfs(i + 1); maxx = max(maxx, ans); vis[k] = 0; &#125; vis[j] = 0; &#125; vis[i] = 0; &#125; return maxx;&#125;int main() &#123; while (cin &gt;&gt; n) &#123; if (!n) break; memset(a, 0, sizeof(a)); for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; a[i]; &#125; memset(vis, 0, sizeof(vis)); double ans = dfs(0); printf(&quot;%.2lf\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018计蒜之道初赛第一场A题百度无人车]]></title>
    <url>%2F2018%2F05%2F12%2F2018-05-12%2F</url>
    <content type="text"><![CDATA[百度无人车百度一共制造了 n 辆无人车，其中第 ii 辆车的重量为 a_i\ \mathrm{kg}ai kg。 由于车辆过重会增大轮胎的磨损程度，现在要给这 n 辆车减轻重量。每将一辆车减轻 1\ \mathrm{kg}1 kg需要消耗 p 万百度币，总预算为 s 万百度币。 现在希望你设计一种最优的减重方案，使得最重的车辆的重量是所有减重方案中最小的。任何时候，每辆车的重量必须大于等于 1\ \mathrm{kg}1 kg。并且减重方案只能减轻整数 \mathrm{kg}kg。 输入格式第一行输入一个整数 n，表示百度无人车的数量。 接下来一行输入 n 个整数，其中第 ii 个整数 a_iai表示第 ii 辆车的重量。 接着一行输入两个整数 p,s，分别表示把一辆车减重 1\ \mathrm{kg}1 kg 需要花费 p 万百度币，总的预算是 s 万百度币。 保证 1 \le n \le 200001≤n≤20000，1 \le a_i \le 200001≤ai≤20000，1 \le p \le 200001≤p≤20000，1 \le s \le 10^{18}1≤s≤1018。 输出格式输出一个整数，表示经过你设计的最优减重方案后，最重的车辆的重量是多少 \mathrm{kg}kg。 样例输入112346 7 8 91 3 样例输出117 样例输入2123511 14 6 13 114 68 样例输出218 题解每1kg消耗p元，一共s元，因此一共可以减s/p（kg），直接s=s/p就行了。先对整个数组进行排序，然后再进行操作。一开始用二分，时间复杂度Onlogn，通不过，因此换了一种线性的方法，时间复杂度On。首先建一个差分数组，储存该元素和前一个元素的差值。以1， 2， 4， 6， 9为例，差分数组为1,1,2,2,3。然后从后往前操作。假设s=s/p之后s为10，首先s与第n个元素差分数组比较，如果大，则s-3=7。再和第n-1比较，由于该位置后面还有一个元素，因此若要改变该元素使最大值变小，需同时改变这两个数，后面以此类推三个四个数等等。s和b[n-1]2即2 2比较，大，则s=7-22=3。再和b[n-2] 3比较。比它小，则证明最大部分再该部分。b[n-2]=b[n-2]-s/3即1，结束循环。现在的差分数组为1,1,1,0,0，现在依次从从b[1]加到b[n就好了，即3。另外由于最小值为1，因此需要对第一个元素特判一下，如果小于1需改为1。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 200007;typedef long long ll;int a[maxn], b[maxn];ll p, s, n;int main() &#123; cin &gt;&gt; n; a[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) &#123; b[i] = a[i] - a[i - 1]; &#125; cin &gt;&gt; p &gt;&gt; s; s /= p; ll ans = 0; for (int i = n; i&gt;0; i--) &#123; if (s &gt;= b[i] * (n - i + 1)) &#123; s -= b[i] * (n - i + 1); b[i] = 0; &#125; else &#123; b[i] -= s / (n - i + 1); for (int j = 2; j &lt;= i; j++) ans += b[j]; break; &#125; if (i == 1 &amp;&amp; b[i] &lt;= 1) break; &#125; if (b[1] &lt;= 1) b[1] = 1; ans += b[1]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛15]]></title>
    <url>%2F2018%2F05%2F11%2F2018-05-11%2F</url>
    <content type="text"><![CDATA[最小化价格题目描述 要求一种方式，使得每组人都到一个各不相同的地点，最小化选择的价格 每个队伍的人都要在同一个地方每个地方只能有一个队伍 输入描述:123第一行n,m第二行n个数，表示每组的人数接下来m行，每行两个数，表示可容纳的最大人数和选择的价格 输出描述:1输出最小化选择的价格，无解输出-1 示例1 输入1234563 42 3 41 22 33 44 5 输出112 备注:1所有数据小于1e5 题解首先对地点以价格从小到大排序，如果相同按容量从小到大排序。由于集合每次插入自动排序，而且可以执行删除操作，因此我们可以用集合储存队伍。然后将队伍放入集合中。对排完序的地点进行遍历，每个地点对容量进行判断，直接对集合up_bound-1操作，就是能被该地点容纳的人数最多的队伍。若存在该队伍，将该队伍从集合中删除，意为该队伍匹配到该地点。然后将总价格加上该地点所需的价格。否则不执行操作，意为当前没有队伍能和该地点匹配。最后对集合判断是否为空，若为空，则证明队伍已经匹配完毕，输出总价格即可，否则意为不是所有队伍都能被容纳，输出-1。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;int const maxn = 100020;struct node &#123; int pri; int num;&#125;loc[maxn];int cmp(node a, node b) &#123; if (a.pri == b.pri) return a.num &lt; b.num; else return a.pri &lt; b.pri;&#125;int main()&#123; int n, m, tmp, ans = 0; cin &gt;&gt; n &gt;&gt; m; multiset&lt;int&gt;a; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; a.insert(tmp); &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; loc[i].num &gt;&gt; loc[i].pri; &#125; sort(loc, loc + m, cmp); multiset&lt;int&gt;::iterator it; for (int i = 0; i &lt; m; i++) &#123; if (a.empty()) break; it = a.upper_bound(loc[i].num); if (it == a.begin()) continue; it--; ans += loc[i].pri; a.erase(it); &#125; if (a.empty()) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; return 0;&#125; 车辆安排题目描述有n个队伍，每个队伍的人数小于等于5，每辆车最多坐5个人，要求一个队伍的人都在一辆车上，求最少的车数 输入描述:12第一行n第二行n个数，表示每个队伍的人数 输出描述:1输出最少车数 示例1 输入1233 4 5 输出13 备注:12n≤1e5每个数小于等于5 题解设置一个数组，分别储存1,2,3,4,5人队伍的个数。总车数=人数为5的队伍数+（人数为4+1或4的队伍数）+（人数为3+2或3+1+1或3的队伍数）+（人数为2+2+1或2+1+1+1或2的队伍数）+（人数为1*5或1的队伍数），（组合方式按优先级排列）。时间复杂度O(1)。 代码123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main() &#123; int n, tmp; scanf(&quot;%d&quot;, &amp;n); int a[6] = &#123; 0 &#125;, sum = 0; while (n--) &#123; scanf(&quot;%d&quot;, &amp;tmp); a[tmp]++; &#125; sum += a[5] + a[4] + a[3]; a[1] = a[1] - a[4]; if (a[3] - a[2] &gt; 0) a[1] -= 2 * (a[3] - a[2]); a[2] -= a[3]; if (a[2] &lt; 0) a[2] = 0; a[1] -= a[2] / 2; if (a[2] % 2 == 0) &#123; sum += a[2] / 2; &#125; else &#123; sum += a[2] / 2 + 1; a[1] -= 3; &#125; if (a[1] &lt; 0) a[1] = 0; a[1] % 5 == 0 ? sum += a[1] / 5 : sum += a[1] / 5 + 1; printf(&quot;%d\n&quot;, sum); return 0;&#125; 出队题目描述约瑟夫问题(约瑟夫问题)，n个人，1 2报数 1出队( 就是体育课的时候1 2报数 1出队，2留下)，q次询问，每次求第x个人是第几个出队的 输入描述:12第一行两个数n,q接下来q行，每行一个数x，表示询问 输出描述:1一行输出一个询问的答案 示例1 输入12344 3234 输出123324 说明11 2 3 4围成一圈，第一轮：1 2报数，1出队，2留下，3出队，4留下，第二轮，2出队，4留下 备注:12q≤500000n和x≤1e18 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;#define ll unsigned long long intmap&lt;ll, ll&gt;ma;vector&lt;ll&gt;v;int main()&#123; int n, q , cnt; cin &gt;&gt; n &gt;&gt; q; ma[1] = 1; cnt = 1; for (int i = 2; i &lt;= n; i++) &#123; if (i % 2 == 0) v.push_back(i); else &#123; ma[i] = ++cnt; &#125; &#125; ll it = 0; if (n % 2) it++; while (!v.empty()) &#123; if (it == v.size()) it = 0; ma[*(v.begin() + it)] = ++cnt; v.erase(v.begin() + it); if (v.empty()) break; if (it == v.size()) it = 0; it++; &#125; while (q--) &#123; int x; cin &gt;&gt; x; cout &lt;&lt; ma[x] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>wannafly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[计算几何]二维计算几何基础]]></title>
    <url>%2F2018%2F05%2F09%2F2018-05-09%2F</url>
    <content type="text"><![CDATA[三寸青笺，写不尽对你的思念。——随笔 用解析几何借助计算机处理几何问题存在着两大缺陷： 1）方程解的情况复杂，例如Ax+By+C=0； 2）存在着浮点误差积累。 计算几何采用了介于代数与几何之间的方式解决几何问题。它利用几何特性辅助简单的代数运算解决几何问题，既能精确求解，有提高了算法效率，并且不失几何的优美特性。 向量向量向量：既有大小又有方向的量。 向量的比较在平面坐标系下，某点的坐标用（x，y）表示，向量和点一样，也可以用x,y表示。 12345struct Point&#123; //点 double x,y; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; //构造函数方便代码编写&#125;;typedef Point Vector; //向量。从程序实现上，Vector只是Point的别名 向量的加减乘除12345678910111213141516//向量+向量=向量，点+向量=点Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y);&#125;//点-点=向量Vector operator - (Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y);&#125;//向量*数=向量Vector operator * (Vector A, double p) &#123; return Vector(A.x * p, A.y * p);&#125;//向量/数=向量Vector operator / (Vector A, double p) &#123; return Vector(A.x / p, A.y / p);&#125; 向量的比较123456789101112131415bool operator &lt; (const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x&amp;&amp;a.y &lt; b.y);&#125;//减下误差的必要比较const double eps=1e-8;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; if(x&gt;0) return 1; return -1;&#125;bool operator ==(const point&amp; a,const point&amp; b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125; 注意上面的“相等”函数用到“三态函数”dcmp,减少了精度问题。另外，向量有一个所谓的“极角”，即从x轴正半轴旋转到该向量方向所需要的角度。C标注库里的atan2函数就是用来求极角的。如向量（x,y）的极角就是atan2（y，x）（单位：弧度） 向量內积（点积）点积，向量α和β的点积等于二者长度的乘积再乘上它们夹角的余弦。当夹角大于90°时点积为负。两向量的点积为一个标量 α·β，它的大小为α·β=|α||β|cosθ，其中θ是&lt;α,β&gt; 余弦为偶函数，因此点积满足交换率。如果两向量垂直，点积为0。 几何意义α在β的投影α’与β的长度乘积 由定义易知当两向量夹角为锐角时点积值为正，夹角钝角为负，垂直为0 123456789double dot(Vector A,Vector B)&#123; //向量点积 return A.x*B.x+A.y*B.y;&#125;double Length(Vector A)&#123; //向量A长度 return sqrt(dot(A,A));&#125;double angle(Vector A,Vector B)&#123; //向量A和B夹角 return acos(dot(A,B)/Length(A)/Length(B));&#125; 向量外积（叉积）简单地说，两个向量u和w得叉积等于u和w组成的三角形的有向面积的两倍。 叉积的二维意义—-有向面积：外积大小为由u，w这两个向量围成的平行四边形有向面积。 两向量的叉积为一个矢量 a×b，设向量 P(x1,y1),Q(x2,y2)，向量 a 和向量 b 的叉积还是一个向量，长度为|PQ|=x1y2-x2y1;即为向量 P,Q 围成的四边形的面积。它的方向与向量PQ 垂直，并且使(P,Q,P×Q)成右手系。 几何意义 不难发现，叉积不满足交换率，cross（u，w）=-corss（w，u）。 12345678double cross(Vector A,Vector B) //叉积&#123; return A.x*B.y-A.y*B.x;&#125;double area(point A,point B,point C) //已知三个点 p0,p1,p2 的叉积函数&#123; return cross(B-A,C-A);&#125; 叉积的一个重要性质，判断两向量互相之间的顺逆时针关系。若 P×Q&gt;0，则P在Q 的顺时针方向；若 P×Q&lt;0，则P在Q 的逆时针方向；若 P×Q=0，则P和Q 共线，但可能同向也可能反向； 利用这一性质，可以将一个多边形的顶点按照顺时针或者逆时针方向排序，这就是极角排序。利用 sort 或者 qsort 函数，自己定义 cmp 函数即可。 12345678910//逆时针极角排序比较函数(double) bool cmp(const point &amp;a, const point &amp;b) &#123; double x = atan2(a.y, a.x), y = atan2(b.y, b.x); return x &lt; y; &#125; //象限极角排序比较函数(int)，不失精度 int cross(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y); &#125; sort(p+1,p+n,cmp); 两向量的位置关系把叉积和点积组合在一起，很容易判断两向量的位置关系。如图所示，括号第一个数是点积的符号，第二个是叉积的符号。第一个向量u总是向右，另一个向量w的各种情况都包含在了图中。比如当w的中点在下图左上方的第二象限时点积为负担叉积均为正，用（-，+）表示。 点和直线点到直线的距离点到直线的距离是一个常用函数，可以用叉积求出，即用平行四边形的面积除以底。代码如下： 12345double DistoLine(point P,point A,point B) //点p到直线AB距离&#123; Vector v1=B-A,v2=P-A; return fabs(cross(v1,v2))/Length(v1); //如果不取绝对值，得到的是有向距离&#125; 点到线段的距离点到线段有两种可能： 简单地说，设投影点为Q，如果Q在线段AB上，则所求距离就是P点直线AB的距离（右）。如果Q在射线BA上，则所求为PA距离；否则为PB距离。判断Q的位置可以用点积进行。 1234567double DistoSegment(point P,point A,point B)&#123; if(A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if(dcmp(dot(v1,v2))&lt;0) return Length(v2); if(dcmp(dot(v1,v3))&gt;0) return Length(v3); return fabs(cross(v1,v2))/Length(v1);&#125; 判断点是否在线段上判断点 Q 在线段 P1P2 上的两条依据：①(Q-P1)*(P2-P1)=0;②Q 在以 P1,P2 为对角顶点的矩形内。 12345bool onSegment(point p1,point p2,point Q)&#123;if( (Q.x-p1.x)*(p2.y-p1.y)==(p2.x-p1.x)*(Q.y-p1.y)&amp;&amp;min(p1.x,p2.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(p1.x,p2.x)&amp;&amp;min(p1.y,p2.y)&lt;=Q.y&amp;&amp;Q.y&lt;= max(p1.y,p2.y) )return 1;else return 0;&#125; 线段相交最为直观的想法：解析几何法 弊端：运算误差大，运算次数多 误差来源：浮点运算 另外，编程难度事实上也很大（区域判断） 计算几何做法：运用叉积点积和位置关系 线段规范相交定义线段规范相交为两线段相交恰好有一个公共点且不是任一线段的端点 充要条件：每条线段的两个端点都在另一条线段的两侧 只有（1）是规范相交，其它是非规范相交。非规范相交的情况还有很多。 跨立实验 规范相交123456bool SegmentItersection(point a1, point a2, point b1, point b2)&#123; double c1 = cross(a2-a1, b1-a1), c2 = cross(a2-a1, b2-a1), c3 = cross(b2-b1, a1-b1), c4 = cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125; 线段相交如果允许在端点处相交怎么办？ 首先可能共线重叠 其次就是交点是端点 如果交点是端点 就判断几次点是否在线段上 12345//判断点p是否在线段a1 a2上bool OnSegment(point p,point a1,point a2)&#123; return dcmp(cross(a1-p,a2-p))==0&amp;&amp;dcmp(dot(a1-p,a2-p))&lt;0; //线段包含端点时改成&lt;=&#125; 多边形问题多边形面积两向量的叉积的几何意义是以这两个向量为邻边的平行四边形的有向面积，我们可以利用这一点来求简单多边形的面积。所谓简单多边形就是任何不相邻的两条边都没有交点，包括凸多边形和凹多边形。 求下面多边形的面积，已知个顶点的坐标。 注意：在引入叉积后，面积就可以为负值，就有了“负面积”的概念。“负面积”方便了我们的运算。 可以取p[0]点为划分顶点，一方面可以少算两个叉积（0和任何向量的叉积都等于0），另一方面也减少乘法溢出的可能性，还不用特殊处理（i=n-1时，下一个顶点p[0]而不是p[n]，因为p[n]不存在） 12345678//取p[0]为划分顶点double PolygonArea(vector&lt;Point&gt; p) &#123; int n = p.size(); double area = 0; for(int i = 1; i &lt; n-1; i++) area += Cross(p[i]-p[0], p[i+1]-p[0]); return area/2;&#125; 也可以取坐标原点为划分点，乘法次数减少。 点在多边形内外判断判断点是否在三角形内点 P 在三角形 ABC 内部常用的又两种方法，面积法和叉积法，面积法即为 S△PAB+S△PAC+S△PBC=S△ABC 其中三角形面积计算公式为 S=1/2×|cross(a,b)| 叉积法 利用叉积的正负号判断，如图所示，AP 在向量 AC 的顺时针方向，CP 在向量 BC 的顺时针方向，BP 在向量 BC 的顺时针方向，利用这一性质推广，那么可以利用叉积的正负号来判断一个点是否在一个凸多边形内部。 判断点是否在多边形内一般而言，该问题有射线法和转角法两种处理手段 射线法：从这个点出发引向无穷远点一条直线，根据交点情况确定点的位置 转角法：计算多边形每条边的转角，若最后相消为0则在外部，否则在内部 射线法：特殊情况不易处理 转角法：三角运算时间开销大 射线法以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。 若有偶数个交点则在形外，否则在形内。 若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。 转角法把多边形每条边的转角加起来，如果是360度，就在多边形内，如果是0度就在外面，180度则是在边界上 直接最要求角度用到反三角函数精度差且费时 改进假设有一条向右的射线，统计多边形穿过这条射线正反多少次，把这个数记为绕数wn，逆时针穿过时，wn加1，顺时针穿过时，wn减1。 注意在程序实现时，判断是否穿过，以及穿过方向时，需要用叉积判断输入点在左边还是右边。 实现代码12345678910111213141516int isPointinPolygon(point p,vector&lt;point&gt;poly)&#123; int wn=0; int n=poly.size(); for (int i=0;i&lt;n;i++) &#123; if (OnSegment(p,poly[i],poly[(i+1)%n])) return -1; //边界 int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i])); int d1=dcmp(poly[i].y-p.y); int d2=dcmp(poly[(i+1)%n].y - p.y); if (k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++; if (k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--; &#125; if (wn!=0) return 1; //内部 return 0; //外部&#125; 点在凸多边形内的判定更简单，只需判断是否在所有边的左边（假设各个顶点按照逆时针顺序排列） 多边形重心三角形重心 多边形重心将多边形拆分为N个三角形，分别求其重心和面积，可以想象，原来的质量均匀分布在内部的区域上，而现在质量仅分布在这N个重心点上（等价变换），这时就可以利用刚才猜想的公式了。 12345678910111213point PolyGravity(point *p,int n)&#123; point ans=point(0,0); double sumArea=0,area; for(int i=2;i&lt;n;i++) &#123; area=cross(p[i-1]-p[0],p[i]-p[0]); sumArea+=area; ans.x+=(p[0].x+p[i-1].x+p[i].x)*area; ans.y+=(p[0].y+p[i-1].y+p[i].y)*area; &#125; return ans/(sumArea*3);&#125; 解析几何交点的计算：求两线段，两直线，线段和直线的交点①判断两线段是否相交：我们分两步确定两条线段是否相交：(1)快速排斥试验设以线段 P1P2 为对角线的矩形为 R， 设以线段 Q1Q2 为对角线的矩形为 T，如果R和T不相交，显然两线段不会相交。(2)跨立试验如果两线段相交，则两线段必然相互跨立对方。若 P1P2 跨立 Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，即 ( P1 - Q1 ) × ( Q2 - Q1 ) ( P2 - Q1 ) × ( Q2 - Q1 ) &lt; 0。上式可改写成 ( P1 - Q1 ) × ( Q2 - Q1 ) ( Q2 - Q1 ) × ( P2 - Q1 ) &gt; 0。当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2 上；同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2 上。所以判断 P1P2 跨立 Q1Q2 的依据是： ( P1 - Q1 ) × ( Q2 - Q1 ) ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。同理判断 Q1Q2 跨立 P1P2 的依据是：( Q1 - P1 ) × ( P2 - P1 ) ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。 另外，“规范相交”指的是两条线段恰有唯一一个不是端点的公共点；而如果一条线段的一个端点在另一条线段上，或者两条线段部分重合，则视为“非规范相交”，以下代码是“非规范相交”。 结合 poj2653 练习，代码可参考： 12345678910111213141516const double eps = 1e-10;struct point &#123; double x, y; &#125;;struct Line &#123; point begin, end; &#125;line[100001];double min(double a, double b) &#123; return a&lt;b ? a : b; &#125;double max(double a, double b) &#123; return a&gt;b ? a : b; &#125;bool inter(const Line &amp; M, const Line &amp; N) &#123; point a = M.begin; point b = M.end; point c = N.begin; point d = N.end; if (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y)&gt;max(c.y, d.y) || min(c.x, d.x)&gt;max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y)) return 0; double h, i, j, k; h = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x); i = (b.x - a.x)*(d.y - a.y) - (b.y - a.y)*(d.x - a.x); j = (d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x); k = (d.x - c.x)*(b.y - c.y) - (d.y - c.y)*(b.x - c.x); return h*i &lt;= eps&amp;&amp;j*k &lt;= eps;&#125; ②判断两直线是否相交：首先判断两条直线是否在一条直线上，或者两条直线平行，否则一定相交，不平行且不在一条直线上则相交并且求出交点。可结合 hrbustoj1104 练习，代码可参考： 123456789101112131415161718192021222324#include&lt;stdio.h&gt; int main() &#123; int t; double x1, x2, x3, x4, y1, y2, y3, y4, x, y; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x3, &amp;y3, &amp;x4, &amp;y4); if ((x2 - x1)*(y4 - y3) == (x4 - x3)*(y2 - y1)) &#123; if ((x3 - x1)*(y4 - y2) == (x4 - x2)*(y3 - y1) &amp;&amp; (y4 - y3) != 0) puts(&quot;LINE&quot;);//在一条直线的情况 else puts(&quot;NONE&quot;);//平行的情况 &#125; else &#123; x = ((y1*(x2 - x1) - x1*(y2 - y1))*(x4 - x3) - (y3*(x4 - x3) - x3*(y4 - y3))*(x2 - x1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3)); y = ((y1*(x2 - x1) - x1*(y2 - y1))*(y4 - y3) - (y3*(x4 - x3) - x3*(y4 - y3))*(y2 - y1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3)); printf(&quot;POINT %.2f %.2f\n&quot;, x, y); &#125; &#125; return 0;&#125; ③判断线段和直线的交点：poj1039 判断直线和线段是否相交并求出交点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define eps 1.0e-8 struct Point &#123; double x, y;&#125; point[25];int n;double ans;bool ok;double intersect(Point a1, Point b1, Point a2, Point b2) &#123; double x1 = a1.x, x2 = b1.x, x3 = a2.x, x4 = b2.x; double y1 = a1.y, y2 = b1.y, y3 = a2.y, y4 = b2.y; double x = (y3 - y1 + x1*(y2 - y1) / (x2 - x1) - x3*(y4 - y3) / (x4 - x3)) / ((y2 - y1) / (x2 - x1) - (y4 - y3) / (x4 - x3)); return x;&#125;void work(Point a, Point b) &#123; b.y -= 1; for (int i = 0; i&lt;n; i++) &#123; Point p, q1, q2; p.x = point[i].x; p.y = a.y - (b.y - a.y) / (b.x - a.x)*(a.x - p.x); if ((p.y + eps&lt;point[i].y&amp;&amp;p.y - eps&gt;point[i].y - 1) || abs(p.y - point[i].y)&lt;eps || abs(p.y - point[i].y + 1)&lt;eps) continue; if (i == 0) return; if (p.y - eps&gt;point[i].y) ans = max(ans, intersect(a, b, point[i - 1], point[i])); else &#123; q1 = point[i - 1]; q1.y -= 1; q2 = point[i]; q2.y -= 1; ans = max(ans, intersect(a, b, q1, q2)); &#125; return; &#125; ok = true;&#125;int main() &#123; while (scanf(&quot;%d&quot;, &amp;n), n) &#123; for (int i = 0; i&lt;n; i++) scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y); ans = point[0].x; ok = false; for (int i = 0; i&lt;n; i++) for (int j = 0; j&lt;n; j++) if (i != j&amp;&amp;!ok) work(point[i], point[j]); if (ok) printf(&quot;Through all the pipe.\n&quot;); else printf(&quot;%.2f\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>点积/叉积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[博弈论]博弈论基本题型及5大常见博弈论原理]]></title>
    <url>%2F2018%2F05%2F08%2F2018-05-08%2F</url>
    <content type="text"><![CDATA[取石子游戏根据题目的意思，看它属于哪种博弈，属于哪种博弈的变形。 然后根据对应的博弈模型的解题策略来求解， 有时候并不一定能够直接看出它属于哪种模型，那这个时候就可以通过判断自己每步可选的策略，对于自己每步走的，对当前局势的影响。然后推断出与之相对应的博弈模型。 巴什博奕（Bash Game）有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。 假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。 胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 12345678910111213#include &lt;iostream&gt; using namespace std;int main() &#123; int iCase; cin &gt;&gt; iCase; while (iCase--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl; &#125; return 0;&#125; 威佐夫博奕（Wythoff Game）有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 2。任意操作都可将奇异局势变为非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。 如何判定是否是奇异局势呢？ 有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 其中（1+√5）/2 = 1.618…,即为黄金分割数。因此,由 ak，bk 组成的矩形近似为黄金矩形，由于 2/（1+√5）=（√5-1）/2，可以先求出 j=[a（√5-1）/2]，若a=[ j（1+√5）/2]，那么 a = aj，bj = aj + j，若不等于，那么 a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 1234567891011121314151617181920#include &lt;stdio.h&gt; #include &lt;math.h&gt; const double ep1 = (sqrt(5.0) - 1.0) / 2.0;const double ep2 = (sqrt(5.0) + 1.0) / 2.0;int main() &#123; int m, n; while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123; if (m &gt; n) &#123; int tmp; tmp = m, m = n, n = tmp; &#125; int id = m * ep1; int tmp1 = ep2 * id, tmp2 = id + tmp1; int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3; if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;); else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;); else printf(&quot;1\n&quot;); &#125; return 0;&#125; 斐波那契博弈（Fibonacci Nim）有一堆个数为 n 的石子，游戏双方轮流取石子，满足 1)先手不能在第一次把所有的石子取完； 2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。 约定取走最后一个石子的人为赢家，求必败态。 这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 证明： 这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 FIB 数列的必败证明： 1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std;long long int f[50];int main() &#123; int n, i; f[0] = f[1] = 1; for (i = 2; i &lt; 50; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; while (cin &gt;&gt; n) &#123; if (n == 0) break; for (i = 0; i &lt; 50; i++) &#123; if (f[i] == n) break; &#125; if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl; &#125; return 0;&#125; K倍博弈共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。 当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1，然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。 当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。 设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; using namespace std;const int maxn = 2000000;int a[maxn], b[maxn];int main()&#123; int n, k; int cas = 0, cass; for (scanf(&quot;%d&quot;, &amp;cass); cass--;) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ++cas; printf(&quot;Case %d: &quot;, cas); int i = 0, j = 0; a[0] = b[0] = 1; while (a[i]&lt;n) &#123; i++; a[i] = b[i - 1] + 1; while (a[j + 1] * k&lt;a[i]) j++; if (a[j] * k&lt;a[i]) b[i] = a[i] + b[j]; else b[i] = a[i]; &#125; if (a[i] == n) puts(&quot;lose&quot;); else puts(&quot;win&quot;); &#125; return 0;&#125; ＳＧ函数的求解(SG博弈）给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。 这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。 下 面我们就在有向无环图的顶点上定义 Sprague-Garundy 函数。首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的 Sprague-Grundy 函数 g如下：g(x)=mex{ g(y) | y 是 x 的后继 }。 SG 函数的性质： 1.首先，所有的 terminal position 所对应的顶点，也就是没有出边的顶点，其 SG 值为 0，因为它的后继集合是空集。 2.然后对于一个 g(x)=0 的顶点 x，它的所有后继 y 都满足 g(y)!=0。 3.对于一个 g(x)!=0 的顶点，必定存在一个后继 y 满足 g(y)=0。 以上这三句话表明，顶点 x 所代表的 postion 是 P-position 当且仅当 g(x)=0。我们通过计算有向无环图的每个顶点的 SG 值，就可以对每种局面找到必胜策略了。 Nim 游戏的规则：每次选择 一堆数量为 k 的石子，可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k不变。 变形假设不是一枚棋子，而是n枚棋子，如何获胜？ 让我们再来考虑一下顶点的 SG 值的意义。当 g(x)=k 时，表明对于任意一个0&lt;=i&lt;k，都存在 x 的一个后继 y 满足 g(y)=i。也 就是说，当某枚棋子的 SG 值是 k 时，我们可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k 不变。 这表明，如果将 n 枚棋子所在的顶 点的 SG 值看作 n 堆相应数量的石子，那么这个 Nim 游戏的每个必胜策略都对应于原来这 n 枚棋子的必胜策略！ 对于 n 个棋子，设它们对应的顶点的 SG 值分别为(a1,a2,…,an)，再设局面(a1,a2,…,an)时的 Nim 游戏的一种必胜策略是把 ai 变成 k，那么原游戏的一种必胜策略就是把第 i 枚棋子移动到一个 SG 值为 k 的顶点。 其实我们还是只要证明这种多棋子的有向图游戏的局面是 P-position 当且仅当所有棋子所在的位置的 SG 函数的异或为 0。这个证明与上节的 Bouton’s Theorem 几乎是完全相同的，只需要适当的改几个名词就行了。 刚才，我为了使问题看上去更容易一些，认为 n 枚棋子是在一个有向图上移动，但如果不是在一个有向图上，而是每个棋子在一个有向图上，每次可 以任选一个棋子（也就是任选一个有向图）进行移动，这样也不会给结论带来任何变化。 所以我们可以定义有向图游戏的和(Sum of Graph Games)：设 G1、G2、……、Gn是 n 个有向图游戏，定义游戏 G 是 G1、G2、……、Gn 的和(Sum)，游戏 G的移动规则是：任选一个子游戏 Gi 并移动上面的棋子。Sprague-Grundy Theorem 就是：g(G)=g(G1)^g(G2)^…^g(Gn)。也就是说，游戏的和的 SG 函数值是它的所有子游戏的 SG 函数值的异或。 再考虑在本文一开头的一句话：任何一个 ICG 都可以抽象成一个有向图游戏。所以“SG 函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每 个 ICG 的每个 position 定义 SG 值，也可以定义 n 个 ICG 的和。所以说当我们面对由 n 个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个 局面的 SG 值的方法，就可以把这些 SG 值全部看成 Nim 的石子堆，然后依照找 Nim 的必胜策略的方法来找这个游戏的必胜策略了！ NIM游戏有 n 堆石子，每次可以从第 1 堆石子里取 1 颗、2 颗或 3颗，可以从第 2 堆石子里取奇数颗，可以从第 3 堆及以后石子里取任意颗… … 我们可以把它看作 3 个子游戏，第 1 个子游戏只有一堆石子，每次可以取 1、2、3颗，很容易看出 x 颗石子的局面的 SG 值是 x%4。第 2 个子游戏也是只有一 堆 石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有 x 颗石子时的 SG值是 x%2。第 3 个游戏有 n-2 堆石子，就是一个 Nim 游戏。对于原游戏的每 个局面，把三个子游戏的 SG 值异或一下就得到了整个游戏的 SG 值，然后就可以根据这个 SG 值判断是否有必胜策略以及做出决策了。其实看作 3 个子游戏还是保守了些，干脆看作 n 个子游戏，其中第 1、2 个子游戏如上所述，第 3 个及以后的子游戏都是“1 堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简 单的游戏有 x 颗石子的 SG 值显然就是 x。其实，n 堆石子的 Nim 游戏本身不就是 n 个“任取石子游戏”的和吗？ 总结SG 函数与“游戏的和”的概念不是让我们去组合、制造稀奇古怪的游戏，而是把遇到的看上去有些复杂的游戏试图分成若干个子游戏，对于每个比原游戏简化很多的子游戏找出它的 SG 函数，然后全部异或起来就得到了原游戏的 SG 函数，就可以解决原游戏了。 HDU 3032 Nim or not NimLasker’s Nim 游戏：每一轮允许两会中操作之一：①、从一堆石子中取走任意多个，②、将一堆数量不少于 2 的石子分成都不为空的两堆。 很明显：sg(0) = 0，sg(1) = 1。 状态 2 的后继有：0，1 和（1，1），他们的 SG 值分别为 0，1，0，所以 sg(2)=2。 状态 3 的后继有：0、1、2、（1，2），他们的 SG 值分别为 0、1、2、3，所以sg(3) = 4。 状态 4 的后继有：0、1、2、3、（1，3）和（2，2），他们的 SG 值分别为 0，1，2，4，5，0，所以 sg(4) = 3. 由数学归纳法可以得出 sg(4k)=4k-1;sg(4k+1)=4k+1;sg(4k+2)=4k+2;sg(4k+3)=4k+4; 12345678910111213141516171819#include &lt;iostream&gt; using namespace std;int main() &#123; int iCase; cin &gt;&gt; iCase; while (iCase--) &#123; int n, cnt = 0, num; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; num; if (num % 4 == 0) num--; else if (num % 4 == 3) num++; cnt ^= num; &#125; if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; &#125; return 0;&#125; 寻找必败态必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。 必败态和胜态有着如下性质： 1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。 解题思路分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
        <tag>NIM游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]数论与与组合数学与线性代数中的常用算法总结]]></title>
    <url>%2F2018%2F05%2F07%2F2018-05-07%2F</url>
    <content type="text"><![CDATA[数论欧几里得算法（gcd）欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b) 证明设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b) 应用如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。 代码123456789101112131415//递归版int gcd(int a, int b) &#123; return b ? a : gcd(b, a%b);&#125;//非递归版int gcd(int a, int b) &#123; if (!a) return b; while (b) &#123; int temp = b; b = a%b; a = temp; &#125; return a;&#125; 扩展欧几里得算法（exgcd）若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1a+0b,因为 gcd(a,b)=gcd(b,a%b)则有 xa+yb=x1b+y1(a%b) 。将等式右边变形，bx1+(a%b)y1=bx1+(a-(a/b)b)y1=ay1+b(x1-(a/b)y1)则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y 应用对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)t,y-y0-a/gcd(a,b)t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。 代码1234567891011121314int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a%b, x, y); int t = x; x = y; y = t - a / b*y; return d;&#125; 筛法求素数筛素数的基本方法是用来筛选出一定范围内的素数 原理利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。 123456789101112131415161718bool isprime[N];//N 表示范围int prime[N], cnt;void f()&#123; int i, j; cnt = 0; memset(isprime, true, sizeof(isprime)); isprime[1] = false; for (i = 2; i &lt;= N; i++) &#123; if (isprime[i]) &#123; prime[cnt++] = i;//记录素数 for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了 isprime[j] = false; &#125; &#125;&#125; 快速幂快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。 原理 假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0a2^1a2^3，也就是a1 a2 a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。 12345678910int poww(int a, int b) &#123; int ans = 1, base = a; while (b != 0) &#123; if (b &amp; 1 != 0) ans *= base; base *= base; b &gt;&gt;= 1; &#125; return ans;&#125; 以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)a^(2^1)a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。 其中要理解base =base这一步：因为 base base==base2，下一步再乘，就是base2 base2==base4，然后同理 base4 base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1a2a8，这三项就可以完美解决了 矩阵快速幂矩阵乘法 简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C 其中c[i][j]为A的第i行与B的第j列对应乘积的和，即: 12345678910const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N &#123; memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; &#125; 方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。 1234567891011121314151617181920212223242526const int N=10; int tmp[N][N]; void multi(int a[][N],int b[][N],int n) &#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) tmp[i][j]+=a[i][k]*b[k][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) a[i][j]=tmp[i][j]; &#125; int res[N][N]; void Pow(int a[][N],int n) &#123; memset(res,0,sizeof res);//n是幂，N是矩阵大小 for(int i=0;i&lt;N;i++) res[i][i]=1; while(n) &#123; if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; &#125; &#125; 下面放一个求斐波那契数列的矩阵快速幂模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int mod = 10000;const int maxn = 35;int N;struct Matrix &#123; int mat[maxn][maxn]; int x, y; Matrix() &#123; memset(mat, 0, sizeof(mat)); for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1; &#125;&#125;;inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123; memset(c.mat, 0, sizeof(c.mat)); c.x = a.x; c.y = b.y; for (int i = 1; i &lt;= c.x; i++) &#123; for (int j = 1; j &lt;= c.y; j++) &#123; for (int k = 1; k &lt;= a.y; k++) &#123; c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod; c.mat[i][j] %= mod; &#125; &#125; &#125; return ;&#125;inline void mat_pow(Matrix &amp;a, int z) &#123; Matrix ans, base = a; ans.x = a.x; ans.y = a.y; while (z) &#123; if (z &amp; 1 == 1) mat_mul(ans, base, ans); mat_mul(base, base, base); z &gt;&gt;= 1; &#125; a = ans;&#125;int main() &#123; while (cin &gt;&gt; N) &#123; switch (N) &#123; case -1: return 0; case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; &#125; Matrix A, B; A.x = 2; A.y = 2; A.mat[1][1] = 1; A.mat[1][2] = 1; A.mat[2][1] = 1; A.mat[2][2] = 0; B.x = 2; B.y = 1; B.mat[1][1] = 1; B.mat[2][1] = 1; mat_pow(A, N - 1); mat_mul(A, B, B); cout &lt;&lt; B.mat[1][1] &lt;&lt; endl; &#125; return 0;&#125; 欧拉函数φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。 设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n sum(1-1/pi)/pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。 模运算基本的模运算(a + b)mod n=((a mod n) + (b mod n))mod n; (a - b)mod n=((a mod n) - (b mod n))mod n; (a b)mod n=((a mod n) (b mod n))mod n; 数论4大定理威尔逊定理若p为质数，则p可整除(p-1)!+1。 欧拉定理若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n) 证明设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。 于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n）， 所以a^φ(n) ≡ 1 (mod n)。 费马小定理假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。 若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 证明因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。 孙子定理（中国剩余定理） 高斯消元高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。 要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。 组合数学排列组合加法原理加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。 分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏） 乘法原理乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。 合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。 公式排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) 其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。 容斥原理设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|这个定理，常称作包含排斥原理，也就是容斥原理。 对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]最短路三大算法——Dijkstra算法，Bellman-ford，floyed]]></title>
    <url>%2F2018%2F05%2F06%2F2018-05-06-1%2F</url>
    <content type="text"><![CDATA[Dijkstra算法（单源最短路径）步骤 初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。 从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。 重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。 12345678910111213141516171819202122232425262728293031323334const int INF=0x3f3f3f3f;const int maxn=1200;int dist[maxn],g[maxn][maxn],N;bool vis[maxn];void dijkstra()&#123; for(int i=1;i&lt;=N;i++) dist[i]=(i==1)?0:INF; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=N;i++) &#123; int mark=-1,mindis=INF; for(int j=1;j&lt;=N;j++) &#123; if(!vis[j]&amp;&amp;dist[j]&lt;mindis) &#123; mindis=dist[j]; mark=j; &#125; &#125; vis[mark]=1; for(int j=1;j&lt;=N;j++) &#123; if(!vis[j]) &#123; dist[j]=min(dist[j],dist[mark]+g[mark][j]); &#125; &#125; &#125;&#125; Bellman-ford（单元最短路径，可带负环）为了能够求解边上带有负值的单源最短路径问题，Bellman(贝尔曼，动态规划提出者)和Ford(福特)提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度的方法。Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellman-ford算法有一个小优化：每次松弛先设一个flag，初值为FALSE，若有边更新则赋值为TRUE，最终如果还是FALSE则直接成功退出。Bellman-ford算法浪费了许多时间做无必要的松弛，所以SPFA算法用队列进行了优化，效果十分显著，高效难以想象。SPFA还有SLF，LLL，滚动数组等优化。 递推公式(求顶点u到源点v的最短路径)：$$dist 1 [u] = Edge[v][u]$$ $$dist k [u] = min{ dist k-1 [u], min{ dist k-1 [j] + Edge[j][u] } }, j=0,1,…,n-1,j≠u$$ Dijkstra算法和Bellman算法思想有很大的区别：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改 的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。 使用条件 单源最短路径(从源点s到其它所有顶点v) 有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图) 边权可正可负(如有负权回路输出错误提示) 差分约束系统(至今貌似只看过一道题) 描述 初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次，看下面的描述性证明(当做树)） 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在d[v]中 Bellman-Ford算法是否一定要循环n-1次么？未必！其实只要在某次循环过程中，考虑每条边后，都没能改变当前源点到所有顶点的最短路径长度，那么Bellman-Ford算法就可以提前结束了(开篇提出的小优化就是这个)。 123456789101112131415161718192021222324252627282930313233343536373839bool Bellman_Ford()&#123; for(int i = 1; i &lt;= nodenum; ++i) //初始化 dis[i] = (i == original ? 0 : MAX); for(int i = 1; i &lt;= nodenum - 1; ++i) for(int j = 1; j &lt;= edgenum; ++j) if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost) //松弛（顺序一定不能反~） &#123; dis[edge[j].v] = dis[edge[j].u] + edge[j].cost; pre[edge[j].v] = edge[j].u; &#125; bool flag = 1; //判断是否含有负权回路 for(int i = 1; i &lt;= edgenum; ++i) if(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost) &#123; flag = 0; break; &#125; return flag;&#125; SPFA1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define N 105int res[N];//存储源点到每个顶点的最短距离值int g[N][N];int cnt[N];//每个点入队次数，判断是否出现负环int que[N*N];//队列bool in_que[N];//标记一个点是否已在队列中int front;//队首位置int rear;//队尾位置void spfa(int n,int src)&#123; rear=front=0; que[++rear]=src; memset(res,0x3f3f3f3f,sizeof(res)); memset(in_que,0,sizeof(in_que)); res[src]=0; while(front&lt;rear) &#123; int cur=que[++front]; in_que[cur]=0; int i; for(i=1; i&lt;=n; i++) &#123; if(res[cur]+g[cur][i]&lt;res[i]) &#123; res[i]=res[cur]+g[cur][i]; if(!in_que[i]) &#123; que[++rear]=i; in_que=1; &#125; &#125; &#125; &#125;&#125; floyed（全源最短路径）Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 123456789for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) /* 实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j] 都不是Inf ，只要一个是Inf，那么就肯定不必更新。 */ if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j]; Floyd算法另一种理解DP，为理论爱好者准备的，上面这个形式的算法其实是Floyd算法的精简版，而真正的Floyd算法是一种基于DP(Dynamic Programming)的最短路径算法。设图G中n 个顶点的编号为1到n。令c [i, j, k]表示从i 到j 的最短路径的长度，其中k 表示该路径中的最大顶点，也就是说c[i,j,k]这条最短路径所通过的中间顶点最大不超过k。因此，如果G中包含边&lt;i, j&gt;，则c[i, j, 0] =边&lt;i, j&gt; 的长度；若i= j ，则c[i,j,0]=0；如果G中不包含边&lt;i, j&gt;，则c (i, j, 0)= +∞。c[i, j, n] 则是从i 到j 的最短路径的长度。对于任意的k&gt;0，通过分析可以得到：中间顶点不超过k 的i 到j 的最短路径有两种可能：该路径含或不含中间顶点k。若不含，则该路径长度应为c[i, j, k-1]，否则长度为 c[i, k, k-1] +c [k, j, k-1]。c[i, j, k]可取两者中的最小值。状态转移方程：c[i, j, k]=min{c[i, j, k-1], c [i, k, k-1]+c [k, j, k-1]}，k＞0。这样，问题便具有了最优子结构性质，可以用动态规划方法来求解。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
        <tag>Floyd算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]二分图匹配基本算法之KM算法解析]]></title>
    <url>%2F2018%2F05%2F06%2F2018-05-06%2F</url>
    <content type="text"><![CDATA[最佳匹配如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。 如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，或者Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。 带权二分图的权值最大的完备匹配称为最佳匹配。二分图的最佳匹配不一定是二分图的最大权匹配。 可以添加一些权值为0的边，使得最佳匹配和最大权匹配统一起来。 如图所示： KM算法求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。 1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。 2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。 3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。 相等子图因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。 相等子图性质 在任意时刻，相等子图上的最大权匹配一定小于等于相等子图的顶标和。 在任意时刻，相等子图的顶标和即为所有顶点的顶标和。 扩充相等子图后，相等子图的顶标和将会减小。 当相等子图的最大匹配为原图的完备匹配时，匹配边的权值和等于所有顶点的顶标和，此匹配即为最佳匹配。 演示过程1.如图所示，1与a匹配权值为3，与c为4。2与a权值为2，与b权值为1，与c权值为3。3与c权值为5。 2.首先对每个顶点赋值，将左边的顶点赋值为最大权重，右边的顶点赋值为0。 3.进行匹配，我们匹配的原则是：只与权重相同的边匹配，若是找不到边匹配，对此条路径的所有左边顶点-1，右边顶点+1，再进行匹配，若还是匹配不到，重复+1和-1操作。对1进行匹配，符合匹配条件的边只有1-c边。 4.接着对2匹配，顶点2值为3，2-c边权重为3，但是，1已经匹配c了，发生了冲突，我们这时候第一时间应该想到的是，让2换个工作，但根据匹配原则，只有2-c边 3+0=0 满足要求，于是2不能换边了，那1能不能换边呢？对1来说，也是只有1-c边满足4+0=4的要求，于是1也不能换边，走投无路了，怎么办？ 5.从常识的角度思考：其实我们寻找最优匹配的过程，也就是帮每个X顶点找到他们权值最高的Y顶点，但是，有些顶点会冲突，比如现在，1，2和c的权值都是最高，这时我们应该让1或者3换顶点，但是这时候换的话我们只能换到降低权值的Y顶点，也就是说，如果令R=左边顶点所有值相加，若发生了冲突，则最终权值一定小于R，但是，我们现在只要求最优匹配，所以，如果1换顶点降低的权值比较少的话，我们是能接受的（对2同样如此）。 在KM算法中如何体现呢？ 现在参与到这个冲突的顶点是1,2和c，令所有左边顶点值-1，右边顶点值+1，即 1-1,2-1. c+1。 我们进行了上述操作后会发现，若是左边有n个顶点参与运算，则右边就有n-1个顶点参与运算，整体效率值下降了1*（n-（n-1））=1，而对于1来说，1-c本来为可匹配的边，现在仍为可匹配边（3+1=4），对于2来说，2-c本来为可匹配的边，现在仍为可匹配的边（2+1=4），我们通过上述操作，为1增加了一条可匹配的边1-a，为B增加了一条可匹配的边2-a。 现在我们再来匹配，对2来说，2-a边 2+0=2，满足条件，所以2换边，a现在为未匹配状态，2-a匹配！ 6.我们现在匹配最后一条边3，3-c 5+1！=5，3边无边能匹配，所以3-1。现在3-c边 4+1=5，可以匹配，但是c已匹配了，发生冲突，3此时不能换边，于是便去找1，对于1来说，1-a此时也为可匹配边，但是a已匹配，1又去找2。 7.2现在无边可以匹配了，2+0！=1 ，现在的路径是3→c→1→a→2，所以1-1,2-1,3-1,a+1，c+1。如下图所示。 8.对于2来说，现在2-b 1+0=1 可匹配！使用匈牙利算法，对此条路径上的边取反。 实现代码：12345678910111213141516171819202122232425262728293031323334353637bool dfs(int s) //匈牙利算法找增广路径&#123; visx[s]=1; for(int i=1;i&lt;=cnty;i++) if(!visy[i])&#123; int t=wx[s]+wy[i]-dis[s][i]; if(t==0) &#123; visy[i]=1; if(linky[i]==0||dfs(linky[i]))&#123; linkx[s]=i,linky[i]=s; return true; &#125; &#125; else if(t&gt;0) //找出边权与顶标和的最小的差值 &#123; if(t&lt;minz)minz=t; &#125; &#125; return false;&#125;void km()&#123; memset(linkx,0,sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(linky,0,sizeof linky); for(int i=1;i&lt;=cntx;i++)&#123; while(1)&#123; minz=INF; memset(visx,0,sizeof visx); memset(visy,0,sizeof visy); if(dfs(i))break; for(int j=1;j&lt;=cntx;j++) //将交错树中X部的点的顶标减去minz if(visx[j])wx[j]-=minz; for(int j=1;j&lt;=cnty;j++) //将交错树中Y部的点的顶标加上minz if(visy[j])wy[j]+=minz; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>匹配</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>KM算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]二分图匹配基本算法之匈牙利算法解析]]></title>
    <url>%2F2018%2F05%2F05%2F2018-05-05%2F</url>
    <content type="text"><![CDATA[二分图概念二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（ i，j ）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 简而言之，一个图所有的顶点被分成两部分，同一部分的顶点之间没有边。如图所示： 二分图匹配给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。 增广路经增广路径的定义：设M为二分图G已匹配边的集合，若P是图G中一条连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行,显然P有奇数条边 由增广路的定义可以推出下述三个结论： P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 P经过取反操作可以得到一个更大的匹配M’。 M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。 匈牙利算法基本模式： 初始时最大匹配为空 ​ while 找到增广路经 ​ do 把增广路径加入到最大匹配中去 具体过程如图所示： 1.如图所示，1可以与a，c匹配，2可以与a，b匹配，3可以与c匹配 2.首先将对1进行搜索，1可以与a匹配，则将1与a相连 3.再对2进行搜索，2可以与a匹配 4.但是a已经与1匹配了，那么顺着a-&gt;1这条路找到1，再对1进行搜索，发现1还可以与c进行匹配，并且当前c还未与任何X区顶点匹配，则将1与c相连 5.现在对3进行匹配，发现3可以与c匹配 6.这时发现c已经匹配了，则顺着c-&gt;1这条路找到1，再对1进行搜索，发现1还可以与a匹配 7.但a也已经匹配了，则顺着a-&gt;2这条路找到2，这时发现2还可以与b匹配，并且b当前还未与任何X顶点匹配，则将2与b匹配，之后得到的结果即为最大匹配 以下是实现代码 123456789101112bool find(int x) &#123; //寻找增广路 for (int i = 1; i &lt;= N; i++) &#123; //遍历Y部分顶点 if (road[x][i] &amp;&amp; !vis[i]) &#123; //Y某顶点与X有路且未标记 vis[i] = true; if (!link[i] || find(link[i])) &#123; //如果Y顶点当前未与其他X匹配则直接与该点匹配，否则寻找增广路，然后将Y顶点与该顶点匹配 link[i] = x; return true; &#125; &#125; &#125; return false;&#125; 主程序调用： 123456for(int i = 1; i &lt;= N; i++)&#123; //对每一个X部分顶点进行遍历 memset(vis,false,sizeof(vis)); if(find(i))&#123; //寻找增光路 ans++; //最大匹配数量加1 &#125;&#125; 例题：POJ3041 给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍， 最少要几次。这里将每行x看成一个X结点，每列Y看成一个Y结点，障碍的坐标x,y看成X到Y的 一条边，构建出图后，就变成了找最少的点，使得这些点与所有的边相邻，即最小点覆盖问题。 又继续敲了一遍匈牙利算法 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int N, K, ans;int road[520][520], head[520];bool vis[520];bool find(int x) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (road[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!head[i] || find(head[i])) &#123; head[i] = x; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; while (cin &gt;&gt; N &gt;&gt; K) &#123; ans = 0; int x, y; memset(road, 0, sizeof(road)); memset(head, 0, sizeof(head)); for (int i = 1; i &lt;= K; i++) &#123; cin &gt;&gt; x &gt;&gt; y; road[x][y] = 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find(i)) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>匹配</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++实战qqHelper]C++打造qq消息一键群发工具]]></title>
    <url>%2F2018%2F05%2F03%2F2018-05-03%2F</url>
    <content type="text"><![CDATA[物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此次借此小程序练习C++，用C++打造qq聊天一键群发功能。该小程序还在完善中。目前只能作用于电脑Windows操作系统，并且电脑聊天界面发送按钮需切换到按Enter直接发送，不要选择Ctrl+Enter。当前仅有发送功能，因此消息的对象是所有好友。之后有时间会陆续添加暂停，继续等操作。 具体代码以及实现过程在代码中逐条说明。这里就不具体说明了。 QQmessage.h 12345678910111213141516171819202122232425262728293031323334353637383940#pragma onceclass QQmessage&#123;public: QQmessage(); ~QQmessage(); //类的入口 static QQmessage *Instance() &#123; static QQmessage object; return &amp;object; &#125; //入口函数 void Start(const wchar_t *msg);private: //开始线程 static unsigned int WINAPI RunThreadproc(void* param); //发送主函数 void SendAll(); //找到QQ窗口 HWND FindQQWindow(); //模拟按键 void PressKey(BYTE vkey); //发送消息 void SendMsg(); //添加文本到剪贴板 void AddTextToClipboard();private: CString m_msg;&#125;; QQmessage.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &quot;stdafx.h&quot;#include &quot;QQmessage.h&quot;QQmessage::QQmessage()&#123;&#125;QQmessage::~QQmessage()&#123;&#125;//入口函数void QQmessage::Start(const wchar_t *msg)&#123; m_msg = CString(msg); //输入的文本 _beginthreadex(NULL, 0, QQmessage::RunThreadproc, NULL, 0, NULL);&#125;//开始线程unsigned int QQmessage::RunThreadproc(void* param)&#123; QQmessage::Instance()-&gt;SendAll(); return 0;&#125;//发送主函数void QQmessage::SendAll()&#123; int errorTimes = 0; //打开对话框错误的次数! //把text复制到剪贴板 AddTextToClipboard(); //技术到家. 做项目能力. while (errorTimes&lt;= 4) &#123; HWND hQQWnd = FindQQWindow(); HWND hFrontWnd = GetForegroundWindow(); if (hQQWnd != hFrontWnd) &#123; if (!SetForegroundWindow(hQQWnd)) &#123; MessageBox(NULL, L&quot;没有找到QQ窗口&quot;, NULL, NULL); break; &#125; &#125; if (errorTimes == 0) &#123; PressKey(VK_TAB); PressKey(VK_TAB); &#125; PressKey(VK_DOWN); PressKey(VK_RETURN); HWND hCurFrontWnd = GetForegroundWindow(); if (hCurFrontWnd == hQQWnd) // &#123; ++errorTimes; continue; &#125; errorTimes = 0; SendMsg(); &#125;&#125;//找到QQ窗口HWND QQmessage::FindQQWindow()&#123; HWND hWnd = FindWindow(L&quot;TXGuiFoundation&quot;,L&quot;QQ&quot;); //Find Window //获取QQ的窗口!!! //辅助工具就是这么做的 return hWnd;&#125;//模拟按键void QQmessage::PressKey(BYTE vkey)&#123; keybd_event(vkey, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(vkey, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100);&#125;//发送消息 16GU盘void QQmessage::SendMsg()&#123; //粘贴 + 发送 keybd_event(VK_CONTROL, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(0x56, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(0x56, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100); keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100); //你好 鲜花刷起来! //发送 PressKey(VK_RETURN); PressKey(VK_ESCAPE);&#125;//添加文本到剪贴板void QQmessage::AddTextToClipboard()&#123; //1.把文本拷贝到全局变量! int memLen = m_msg.GetLength() * sizeof(wchar_t) + 2; HANDLE hGloBal = GlobalAlloc(GHND,memLen); //malloc calloc relloc void* memAddr = GlobalLock(hGloBal); ZeroMemory(memAddr, memLen); memcpy(memAddr, (const void*)m_msg.GetBuffer(), memLen); GlobalUnlock(hGloBal); //操作剪贴板! 怎么把大象装进冰箱! OpenClipboard(NULL); EmptyClipboard(); SetClipboardData(CF_UNICODETEXT, hGloBal); CloseClipboard();&#125; QQHelperDlg.h 12345678910111213141516171819202122232425262728293031323334353637// QQHelperDlg.h : 头文件//#pragma once// CQQHelperDlg 对话框class CQQHelperDlg : public CDialogEx&#123;// 构造public: CQQHelperDlg(CWnd* pParent = NULL); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_QQHELPER_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: CString m_Msg; afx_msg void OnBnClickedButton1();&#125;; QQHelperDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// QQHelperDlg.cpp : 实现文件//#include &quot;stdafx.h&quot;#include &quot;QQHelper.h&quot;#include &quot;QQHelperDlg.h&quot;#include &quot;afxdialogex.h&quot;#include &quot;QQmessage.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CQQHelperDlg 对话框CQQHelperDlg::CQQHelperDlg(CWnd* pParent /*=NULL*/) : CDialogEx(IDD_QQHELPER_DIALOG, pParent) , m_Msg(_T(&quot;&quot;))&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CQQHelperDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Text(pDX, IDC_EDIT1, m_Msg);&#125;BEGIN_MESSAGE_MAP(CQQHelperDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON1, &amp;CQQHelperDlg::OnBnClickedButton1)END_MESSAGE_MAP()// CQQHelperDlg 消息处理程序BOOL CQQHelperDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CQQHelperDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CQQHelperDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CQQHelperDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;//发送void CQQHelperDlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); QQmessage::Instance()-&gt;Start(m_Msg.GetBuffer());//m_Msg实例编辑框的变量 文字&#125; QQHelper.h 1234567891011121314151617181920212223242526272829303132// QQHelper.h : PROJECT_NAME 应用程序的主头文件//#pragma once#ifndef __AFXWIN_H__ #error &quot;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&quot;#endif#include &quot;resource.h&quot; // 主符号// CQQHelperApp: // 有关此类的实现，请参阅 QQHelper.cpp//class CQQHelperApp : public CWinApp&#123;public: CQQHelperApp();// 重写public: virtual BOOL InitInstance();// 实现 DECLARE_MESSAGE_MAP()&#125;;extern CQQHelperApp theApp; QQHelper.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// QQHelper.cpp : 定义应用程序的类行为。//#include &quot;stdafx.h&quot;#include &quot;QQHelper.h&quot;#include &quot;QQHelperDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CQQHelperAppBEGIN_MESSAGE_MAP(CQQHelperApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CQQHelperApp 构造CQQHelperApp::CQQHelperApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的一个 CQQHelperApp 对象CQQHelperApp theApp;// CQQHelperApp 初始化BOOL CQQHelperApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CQQHelperDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != NULL) &#123; delete pShellManager; &#125;#ifndef _AFXDLL ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; stdafx.h 12345678910111213141516171819202122232425262728293031323334353637383940414243// stdafx.h : 标准系统包含文件的包含文件，// 或是经常使用但不常更改的// 特定于项目的包含文件#pragma once#ifndef VC_EXTRALEAN#define VC_EXTRALEAN // 从 Windows 头中排除极少使用的资料#endif#include &quot;targetver.h&quot;#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS // 某些 CString 构造函数将是显式的// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏#define _AFX_ALL_WARNINGS#include &lt;afxwin.h&gt; // MFC 核心组件和标准组件#include &lt;afxext.h&gt; // MFC 扩展#include &lt;afxdisp.h&gt; // MFC 自动化类#ifndef _AFX_NO_OLE_SUPPORT#include &lt;afxdtctl.h&gt; // MFC 对 Internet Explorer 4 公共控件的支持#endif#ifndef _AFX_NO_AFXCMN_SUPPORT#include &lt;afxcmn.h&gt; // MFC 对 Windows 公共控件的支持#endif // _AFX_NO_AFXCMN_SUPPORT#include &lt;afxcontrolbars.h&gt; // 功能区和控件条的 MFC 支持#ifdef _UNICODE#if defined _M_IX86#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;x86&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#elif defined _M_X64#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;amd64&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#else#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;*&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#endif#endif stdafx.cpp 123456// stdafx.cpp : 只包括标准包含文件的源文件// QQHelper.pch 将作为预编译头// stdafx.obj 将包含预编译类型信息#include &quot;stdafx.h&quot; Resource.h 12345678910111213141516171819202122//&#123;&#123;NO_DEPENDENCIES&#125;&#125;// Microsoft Visual C++ 生成的包含文件。// 供 QQHelper.rc 使用//#define IDM_ABOUTBOX 0x0010#define IDD_ABOUTBOX 100#define IDS_ABOUTBOX 101#define IDD_QQHELPER_DIALOG 102#define IDR_MAINFRAME 128#define IDC_EDIT1 1000#define IDC_BUTTON1 1001// Next default values for new objects// #ifdef APSTUDIO_INVOKED#ifndef APSTUDIO_READONLY_SYMBOLS#define _APS_NEXT_RESOURCE_VALUE 130#define _APS_NEXT_COMMAND_VALUE 32771#define _APS_NEXT_CONTROL_VALUE 1002#define _APS_NEXT_SYMED_VALUE 101#endif#endif targetver.h 12345678#pragma once// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。#include &lt;SDKDDKVer.h&gt; 资源文件]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）]]></title>
    <url>%2F2018%2F05%2F01%2F2018-05-01%2F</url>
    <content type="text"><![CDATA[今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。 Walking in the Forest （最大值最小化例题）题目描述 It’s universally acknowledged that there’re innumerable trees in the campus of HUST. Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step. 输入描述:12The first line contains two integer N and K as described above.Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone. 输出描述:1An integer, the minimum distance of the largest step. 示例1 输入126 31 3 2 2 5 输出15 题意： 有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。 题解： 典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;long long a[100010];int n, k;bool check(long long ld,long long rd,long long mind) &#123; long long cnt = 0; int stemp = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (cnt + a[i] &lt;= mind) &#123; cnt += a[i]; &#125; else &#123; cnt = a[i]; stemp++; &#125; if (stemp &gt; k) return false; &#125; if (stemp &lt;= k) return true; return false;&#125;int main() &#123; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123; long long maxn = 0, sumn = 0; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); sumn += a[i]; if (maxn &lt; a[i]) maxn = a[i]; &#125; long long ld = maxn; long long rd = sumn; long long mind = (ld + rd) / 2; while (ld &lt;= rd) &#123; bool flag = check(ld, rd, mind); if (!flag) &#123; ld = mind + 1; mind = (ld + rd) / 2; &#125; else &#123; rd = mind - 1; mind = (ld + rd) / 2; &#125; &#125; printf(&quot;%lld\n&quot;, ld); &#125; return 0;&#125; POJ2456疯牛 （最小值最大化例题）时间限制：1000 ms | 内存限制：65535 KB 难度：4 描述 农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入5 312849样例输出3 题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。 题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int v[100005]; int n, c; int check(int d) &#123; int tmp = v[0], cnt = 1; for (int i = 1; i &lt; n; i++) &#123; if (v[i] - tmp &gt;= d) &#123; cnt++; tmp = v[i]; &#125; &#125; if (cnt &gt;= c) return 1; return 0; &#125; int main() &#123; while (cin &gt;&gt; n &gt;&gt; c) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i]; sort(v, v + n); int l = 0, r = v[n - 1], mid; while (l &lt;= r) &#123; mid = (l + r) / 2; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; printf(&quot;%d\n&quot;, r); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解]]></title>
    <url>%2F2018%2F04%2F29%2F2018-04-29%2F</url>
    <content type="text"><![CDATA[4月29日，13:30-18:30，浙江大学程序设计校赛 A-Peak题意： 有一串数字，问这串数字是否符合以下情况： 存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。 题解： 水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。 B - King of Karaoke题意： 两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k 题解： 只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。 D - Sequence Swapping Time Limit: 1 Second Memory Limit: 65536 KB BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element in the pair is an integer. As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if , ‘(‘ and ‘)’. BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get? InputThere are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains an integer (), indicating the length of the sequence. The second line contains a string () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above. The third line contains integers (). Their meanings are described above. It’s guaranteed that the sum of of all test cases will not exceed . OutputFor each test case output one line containing one integer, indicating the maximum possible score BaoBao can get. Sample Input1234567891011121346)())()1 3 5 -1 3 26)())()1 3 5 -100 3 23())1 -1 -13())-1 -1 -1 Sample Output1234242102 HintFor the first sample test case, the optimal strategy is to select in order. For the second sample test case, the optimal strategy is to select in order. 题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。 题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即curweight[i]。否则将cur和curweight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;stack&gt;using namespace std;struct node &#123; int cur; int cnt;&#125;;char str[1010];int wei[1010];int main() &#123; int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%s&quot;, &amp;n, str); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;wei[i]); &#125; stack&lt;node&gt;st; int sum = 0; int cur = 0; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (str[i] == &apos;(&apos;) &#123; if (cur == 0) &#123; cur = wei[i]; &#125; else if (abs(cur) &lt; abs(cur + wei[i])) &#123; cur = cur + wei[i]; &#125; else &#123; cur = wei[i]; &#125; &#125; else if (str[i] == &apos;)&apos;) &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123; cnt = 0; do &#123; cur += st.top().cur; cnt += st.top().cnt; st.pop(); &#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]); sum += cur*wei[i] + cnt; &#125; else if (cur*wei[i] &gt; 0) &#123; sum += wei[i] * cur; &#125; else &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123; cur += st.top().cur; sum += cur*wei[i] + st.top().cnt; st.pop(); &#125; else &#123; if (!cur&amp;&amp;!st.empty()) &#123; st.top().cnt += st.top().cur*wei[i]; &#125; else &#123; node tmp; tmp.cnt = cur*wei[i]; tmp.cur = cur; st.push(tmp); cur = 0; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125; J - CONTINUE…? Time Limit: 1 Second Memory Limit: 65536 KB Special Judge DreamGrid has classmates numbered from to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has gems. DreamGrid would like to divide the classmates into four groups , , and such that: Each classmate belongs to exactly one group. Both and consist only of girls. Both and consist only of boys. The total number of gems in and is equal to the total number of gems in and . Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty. InputThere are multiple test cases. The first line of input is an integer indicating the number of test cases. For each test case: The first line contains an integer () – the number of classmates. The second line contains a string () consisting of 0 and 1. Let be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl. It is guaranteed that the sum of all does not exceed . OutputFor each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead. Sample Input123456789101151121031014000071101001 Sample Output12345-1-131412213413214 题意： 有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可） 题解： 看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;int a[100010], vis[100010];using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); long long int sum = 0, half = 0; while (t--) &#123; int n; sum = 0; scanf(&quot;%d&quot;, &amp;n); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%1d&quot;, &amp;a[i]); sum += i + 1; &#125; if (sum % 2 != 0) &#123; printf(&quot;-1\n&quot;); continue; &#125; else half = sum / 2; sum = 0; for (int i = n; i &gt; 0; i--) &#123; if (sum + i &lt;= half) &#123; sum += i; vis[i - 1] = 1; if (sum == half) break; else if (half - sum &lt; i) &#123; vis[half - sum - 1] = 1; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i]) &#123; if (vis[i]) printf(&quot;3&quot;); else printf(&quot;4&quot;); &#125; else if (!a[i]) &#123; if (vis[i]) printf(&quot;1&quot;); else printf(&quot;2&quot;); &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; L - Doki Doki Literature Club Time Limit: 1 Second Memory Limit: 65536 KB Doki Doki Literature Club! is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story! A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words. The poem writing mini-game (from wikipedia) BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of words is nothing more than a sequence of strings, and the happiness of Sayori after reading the poem is calculated by the formula Given a list of words and Sayori’s preference to each word, please help BaoBao select words from the list and finish the poem with these words to maximize the happiness of Sayori. Please note that each word can be used at most once! InputThere are multiple test cases. The first line of input contains an integer (about 100), indicating the number of test cases. For each test case: The first line contains two integers and (), indicating the number of words and the length of the poem. For the following lines, the -th line contains a string consisting of lowercased English letters () and an integer (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that for all . OutputFor each test case output one line containing an integer and strings separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one. Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect! A sequence of strings is lexicographically smaller than another sequence of strings , if there exists a () such that for all and is lexicographically smaller than . A string is lexicographically smaller than another string , if there exists a () such that for all and , or for all and . Sample Input1234567891011121314151617181920212223242526410 8hello 0world 0behind 0far 1be 2spring 10can 15comes 20winter 25if 2005 5collegiate 0programming -5zhejiang 10provincial 5contest -453 2bcda 1bcd 1bbbbb 13 2a 1aa 1aaa 1 Sample Output12342018 if winter comes can spring be far behind15 zhejiang provincial collegiate programming contest3 bbbbb bcd3 a aa 题意： 有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。 题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node&#123; string str; long long int weight;&#125;;node level[110];bool cmp(node a,node b) &#123; if (a.weight != b.weight) return a.weight &gt; b.weight; else &#123; return a.str &lt; b.str; &#125;&#125;int main() &#123; int t, n, m; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; long long int h = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; level[i].str &gt;&gt; level[i].weight; &#125; sort(level, level + n, cmp); for (int i = m; i &gt; 0; i--) h += level[m - i].weight*i; printf(&quot;%lld &quot;, h); for (int i = 0; i &lt; m - 1; i++) cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;; cout &lt;&lt; level[m - 1].str &lt;&lt; endl; &#125; return 0;&#125; K - Lucky 7给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。 题解： 每输入一个数直接进行判断即可。]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(高级篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-3%2F</url>
    <content type="text"><![CDATA[由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(进阶篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-2%2F</url>
    <content type="text"><![CDATA[本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。 基本流程1.安装主题 2.启用主题 3.验证主题 4.设置语言 5.设置菜单 6.侧栏设置 7.尾栏设置 8.附页 安装主题在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 即可获取最新版主题，后续更新只需输入指令： 1git pull 启用主题在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next 1theme: next 注意中间有空格。到此，NexT 主题安装完成。 验证主题在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 1hexo clean 首先启动 Hexo 本地站点，并开启调试模式，整个命令是 1hexo s 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000/。 如果端口号被占用还是得先修改端口号，然后启动服务。即先输入 1hexo server -p 5000 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:5000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:5000/。 完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是： Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 双栏Scheme，简约淡雅的风尚 注释 # 即可。 以Pisce为例，选择 Pisce Scheme 设置语言在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文） 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定实例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id 设置菜单菜单栏设置菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。 12345678menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 添加标签，分类添加标签页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面 1hexo new page tags 在新建的index.md文件中添加type: “tags” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 添加分类页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面 1hexo new page categories 在新建的index.md文件中添加type: “categories” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。 添加关于我页面，步骤和以上差不多 在新建的index.md文件中添加内容 侧栏设置设置侧栏位置，修改主题目录下sidebar的position值 设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 尾栏设置修改底部的官方logo，找到 \themes\next\layout\_partials\下面的footer.swig文件，打开会发现，如下的语句： 第一个框 是下面侧栏的“日期❤ XXX” 如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可） 看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 附页站点配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 浅悠悠的个人博客 #网站标题subtitle: 。。。 #网站副标题description: 。。。 #网站描述author: 王骏 #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有)# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/imwillxue/imwillxue.github.com.git branch: master 主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat: #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客（基础篇）]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-1%2F</url>
    <content type="text"><![CDATA[以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程： 基本流程：1.搭建前的准备（包括node.js，git，github账户的配置） 2.安装hexo 3.配置hexo 4.连接hexo与github page 5.发布文章 搭建前的准备1.安装node.js 2.安装git 3.github账户管理 配置Node.js下载node.js。根据自己电脑的配置自行安装。 安装完成后打开终端输入： 12node -vnpm -v 进行是否安装成功测试。如不正确，回头检查哪一步错误。 配置Gitgit官网。自行安装。 安装完成后打开终端输入： 1git --version 以上步骤进行是否安装成功。如果安装失败自行面壁。 github管理已拥有账号可跳过注册此步 打开github进行注册。 登录后点击右上角加号，选择New repository新建代码库。 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。 注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io 建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 安装hexo在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹 在命令行输入 1npm install hexo -g //进行安装 输入 1hexo -v //检验是否安装成功。 配置hexo输入 1hexo init //初始化该文件夹 看到后面的“Start blogging with Hexo！”证明正在执行。 输入 1npm install //安装所需要的组件 输入 1hexo g //生成 输入 1hexo s 开启服务器，访问该网址，正式体验Hexo 连接hexo与github page设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容 输入ssh-keygen -t rsa -C “xxxxxx@xx.com”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 发布文章新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 当然你也可以执行下面的命令，相当于上面两条命令的效果 1hexo g -d //在部署前先生成 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。 到此为止，最基本的也是最全面的hexo+github搭建博客完结。]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>GitHub</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F24%2F2018-04-24%2F</url>
    <content type="text"><![CDATA[Welcome to My Blog! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server11$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>程序人生</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]堆的基本操作]]></title>
    <url>%2F2018%2F04%2F23%2F2018-04-23%2F</url>
    <content type="text"><![CDATA[堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 1.堆总是一棵完全二叉树。 2.堆中某个节点的值总是不大于或不小于其父节点的值。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 本次操作具体以小根堆为例进行演示。 堆的存储一般采用树组存储，i结点的父结点下标为( i - 1 ) / 2。左子树的下标为2 i + 1,右子树的下标为2 i + 2。 堆的操作堆的插入每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。 1234567891011121314151617// 新加入i结点 其父结点为(i - 1) / 2 void MinHeapFixup(int a[], int i) &#123; int j, temp; temp = a[i]; j = (i - 1) / 2; //父结点 while (j &gt;= 0 &amp;&amp; i != 0) &#123; if (a[j] &lt;= temp) break; a[i] = a[j]; //把较大的子结点往下移动,替换它的子结点 i = j; j = (i - 1) / 2; &#125; a[i] = temp; 插入时 12345void MinHeapAddNumber(int a[], int n, int nNum) &#123; a[n] = nNum; MinHeapFixup(a, n); &#125; 堆的删除堆中每次都只能删除根结点，即第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。 123456789101112131415161718192021222324252627// 从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2 void MinHeapFixdown(int a[], int i, int n) &#123; int j, temp; temp = a[i]; j = 2 * i + 1; while (j &lt; n) &#123; if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的 j++; if (a[j] &gt;= temp) break; a[i] = a[j]; //把较小的子结点往上移动,替换它的父结点 i = j; j = 2 * i + 1; &#125; a[i] = temp; &#125; //在最小堆中删除数 void MinHeapDeleteNumber(int a[], int n) &#123; Swap(a[0], a[n - 1]); MinHeapFixdown(a, 0, n - 1); &#125; 构建堆有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。 123456//建立最小堆 void MakeMinHeap(int a[], int n) &#123; for (int i = n / 2 - 1; i &gt;= 0; i--) MinHeapFixdown(a, i, n); &#125; 堆排序首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。 由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。 12345678void MinheapsortTodescendarray(int a[], int n) &#123; for (int i = n - 1; i &gt;= 1; i--) &#123; Swap(a[i], a[0]); MinHeapFixdown(a, 0, i); &#125; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[爬虫]python自动调用浏览器访问网页增加访问量]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-1%2F</url>
    <content type="text"><![CDATA[该程序主要是为了增长访问量而写的，主要针对一些访问量与用户信息无关的网页，比如CSDN。当然前提是python安装相应的库。原理很简单，没有用到什么高端的爬虫技术，没有用到正则表达式什么的。其实就是调用你的浏览器，然后程序自动帮你打开你的博客网页，隔一段时间自动关闭，以此循环，刷访问量。不多说了，直接贴代码吧。 123456789101112131415161718192021import webbrowser as web import time import os import random count = random.randint(1, 2) j = 0 aa = [80042845,80025162,80035076,80025133,80025068,80024813,79986200,79935658,79933992,79783339,79747976,79747322,79734593,79734363,79706272,79700188,79725018,79724244] while j &lt; count: i = 0 while i &lt;= 8: k = random.randint(0,17) web.open_new_tab(&apos;https://blog.csdn.net/qian_youyou/article/details/&apos;+str(aa[k])) i = i + 1 time.sleep(3) else: time.sleep(20) os.system(&apos;taskkill /F /IM chrome.exe&apos;) # print &apos;time webbrower closed&apos; j = j + 1]]></content>
      <categories>
        <category>程序人生</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言打造智能AI小游戏——三子棋]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22%2F</url>
    <content type="text"><![CDATA[三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3]，[3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。例如没有走时，9个格的权值为： [] [] [] 3 2 3 [] [] [] 2 4 2 [] [] [] 3 2 3 角落有横竖斜三种获胜方法，边有横竖两种方法，中心有横竖两斜4种方法。假如某格有X阻挡，那么权值会相应变化，例如 [] [] [] 2 1 2 [] X [] 1 0 1 [] [] [] 2 1 2 由于有中心阻挡，那么角只有横竖两种方法赢，因此权值为2。但该AI还需继续优化。例如以下： [] X [] 1 0 1 [] 0 [] 1 0 2 X X 0 0 0 0 AI面对这种情况，本来下在第一个格子就赢了，但他会选择权值为2的格子。因此我们可以在现有权值条件的情况下，在附加个权值。假如某一格子的路线上已经有AI的子了，那么该条路线上未落子的所有格子权值再加1，如果有两个已落子的AI格子权值就加2。例如以下情况： 原权值 优化 [] X [] 2 0 2 5 0 3 [] 0 [] 2 0 2 3 0 4 [] X 0 2 0 0 3 0 0 第一个格子5是由于斜路线上有两个子，那在原有的基础2上先加1，再加2，所以权值为2+1+2。第2行第3列权值为4，因为横竖两条路线均有1个子，因此权值为2+1+1，其余格子路线上均有1个子，因此权值为2+1。这样落在权值5那个格子上AI就赢了。 但是仅仅这些判断是不够的。例如： 原权值 优化 X [] X 0 1 0 0 2 0 [] 0 [] 1 0 1 2 0 2 [] [] 0 1 2 0 2 4 0 AI会选择权值为4的格子。那此时AI选择权值为2的格子时，你只需要走一步就赢了，AI就输了，因此该AI算法还得继续。 那么AI可以逆向思考一番，AI可以考虑一下当前情况在计算AI权值的同时再计算一次我们的权值。例如上面例子： AI 你 X [] X 0 1 0 0 1 0 [] 0 [] 1 0 1 1 0 0 [] [] 0 1 2 0 1 0 0 优化AI 优化你 0 2 0 0 4 0 2 0 2 2 0 0 2 4 0 2 0 0 我们把两个权值相加（另外把AI的权值应该再加1，因为AI判断赢要优先于输或平，假如AI方有权值大的，代表一步能赢的，我方也有这种情况，那相加权值相同，AI既可以选择赢棋那一格，也可以选择堵你将要赢的那一格。但AI判断赢要优先于堵对方赢。例子就不举了）： 相加权 加1权 X [] X 0 6 0 0 7 0 [] 0 [] 4 0 2 5 0 3 [] [] 0 4 4 0 5 4 0 因此AI判断到这里就会堵你了。 AI算法就介绍到这里，至于三子棋程序，由于过于简单，就不过多介绍了。主要介绍AI思想，Windows系统编译的程序。如果是Linux需要把以下代码改下。接下来我就贴上代码，供参考，如有不懂欢迎留言。 project.h 12345678910111213141516#pragma once #define COLUMN 3 #define ROW 3 #define GOON 0 #define WIN -1 #define DEFEAT 1 void init(char(*MAP)[COLUMN]); int victory(char(*MAP)[COLUMN]); bool check(char(*MAP)[COLUMN]); void show(char(*MAP)[COLUMN]); void check_stemp(char(*MAP)[COLUMN], int *x, int *y); void ai_auto(char(*MAP)[COLUMN]); int menu(); int first_hand(char(*MAP)[COLUMN]); int ai_hand(char(*MAP)[COLUMN]); void play(char(*MAP)[COLUMN]); project.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&quot;project.h&quot; int vis[ROW][COLUMN]; int weight[ROW][COLUMN]; int x, y; void init(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) &#123; MAP[i][j] = &apos; &apos;; vis[i][j] = 0; &#125; &#125; int victory(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] == &apos;X&apos;&amp;&amp;MAP[i][1] == &apos;X&apos;&amp;&amp;MAP[i][2] == &apos;X&apos;) return WIN; else if (MAP[i][0] == &apos;O&apos;&amp;&amp;MAP[i][1] == &apos;O&apos;&amp;&amp;MAP[i][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][i] == &apos;X&apos;&amp;&amp;MAP[1][i] == &apos;X&apos;&amp;&amp;MAP[2][i] == &apos;X&apos;) return WIN; else if (MAP[0][i] == &apos;O&apos;&amp;&amp;MAP[1][i] == &apos;O&apos;&amp;&amp;MAP[2][i] == &apos;O&apos;) return DEFEAT; &#125; if (MAP[0][0] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][2] == &apos;X&apos;) return WIN; else if (MAP[0][0] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][2] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][0] == &apos;X&apos;) return WIN; else if (MAP[0][2] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][0] == &apos;O&apos;) return DEFEAT; return GOON; &#125; bool check(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) if (!vis[i][j]) return false; return true; &#125; void show(char(*MAP)[COLUMN]) &#123; printf(&quot;-------------\n&quot;); for (int i = 0; i &lt; ROW; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt; COLUMN; j++) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; printf(&quot;\n&quot;); printf(&quot;-------------\n&quot;); &#125; &#125; void check_stemp(char(*MAP)[COLUMN], int *x, int *y) &#123; while (*x &gt; 3 || *x &lt;= 0 || *y&gt;3 || *y &lt;= 0 || MAP[*y - 1][*x - 1] != &apos; &apos;) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Input error, please reenter!\n&quot;); scanf(&quot;%d%d&quot;, x, y); &#125; MAP[*y - 1][*x - 1] = &apos;X&apos;; vis[*y - 1][*x - 1] = 1; &#125; void Empowerment(char(*MAP)[COLUMN], int(*weight)[COLUMN], char ai_X, char ai_0, int flag) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] != ai_X&amp;&amp;MAP[i][1] != ai_X&amp;&amp;MAP[i][2] != ai_X) &#123; weight[i][0]++; weight[i][1]++; weight[i][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[i][j] == ai_0) &#123; weight[i][0] += tmp+flag; weight[i][1] += tmp+flag; weight[i][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][i] != ai_X&amp;&amp;MAP[1][i] != ai_X&amp;&amp;MAP[2][i] != ai_X) &#123; weight[0][i]++; weight[1][i]++; weight[2][i]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][i] == ai_0) &#123; weight[0][i] += tmp+flag; weight[1][i] += tmp+flag; weight[2][i] += tmp+flag; tmp += 10; &#125; &#125; &#125; if (MAP[0][0] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][2] != ai_X) &#123; weight[0][0]++; weight[1][1]++; weight[2][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][j] == ai_0) &#123; weight[0][0] += tmp+flag; weight[1][1] += tmp+flag; weight[2][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][2] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][0] != ai_X) &#123; weight[0][2]++; weight[1][1]++; weight[2][0]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][2 - j] == ai_0) &#123; weight[0][2] += tmp+flag; weight[1][1] += tmp+flag; weight[2][0] += tmp+flag; tmp += 10; &#125; &#125; &#125; void ai_auto(char(*MAP)[COLUMN]) &#123; int weight[3][3] = &#123; 0 &#125;; Empowerment(MAP, weight, &apos;X&apos;, &apos;O&apos;, 1); Empowerment(MAP, weight, &apos;O&apos;, &apos;X&apos;, 0); int maxn = -1; int maxm = -1; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) &#123; if (vis[i][j]) weight[i][j] = -1; if (maxn &lt; weight[i][j]) &#123; maxn = weight[i][j]; maxm = i * 3 + j; &#125; &#125; MAP[maxm / 3][maxm % 3] = &apos;O&apos;; vis[maxm / 3][maxm % 3] = 1; &#125; int menu() &#123; int tmp; printf(&quot;*************************************************************\n&quot;); printf(&quot;* Please enter: * 1:First hand * 2.Back hand * Others:Close *\n&quot;); printf(&quot;*************************************************************\n&quot;); scanf(&quot;%d&quot;, &amp;tmp); return tmp; &#125; int first_hand(char(*MAP)[COLUMN]) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Please enter:x y\n&quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); check_stemp(MAP, &amp;x, &amp;y); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == WIN) &#123; printf(&quot;Congratulations on your victory, you are as smart as Qianyouyou.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; system(&quot;pause&quot;); return 0; &#125; int ai_hand(char(*MAP)[COLUMN]) &#123; ai_auto(MAP); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == DEFEAT) &#123; printf(&quot;You lose, you&apos;re as stupid as a pig.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; return 0; &#125; void play(char(*MAP)[COLUMN]) &#123; while (!check(MAP) || victory(MAP) == GOON) &#123; if (first_hand(MAP)) break; if (ai_hand(MAP)) break; &#125; system(&quot;pause&quot;); &#125; main.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&quot;project.h&quot; char MAP[ROW][COLUMN]; int main() &#123; char str[2]; do &#123; init(MAP); switch (menu()) &#123; case 1: first_hand(MAP); case 2: &#123; ai_hand(MAP); play(MAP); &#125; default: &#123; printf(&quot;Do you need to start again?(Y/N)&quot;); scanf(&quot;%s&quot;, str); &#125;break; &#125; &#125; while (str[0] == &apos;Y&apos; || str[0] == &apos;y&apos;); printf(&quot;Thank you for using!\n&quot;); system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>项目</tag>
        <tag>博弈论</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[排序]求解第k大分值]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21%2F</url>
    <content type="text"><![CDATA[描述： Arch0n老师is a rich man, 他靠自己的才华和智商年纪轻轻就赚了不少钱。为了训练自己的智商，他经常玩一些interesting的游戏来训练自己的智商，比如什么RGB游戏，还有和妹子一块玩Don’t Starve。 言归正传，今天他又发明了一个新的interesting game。Ar老师手上有一堆卡牌，然后卡牌上写了一个数字Ai(正整数)，当前他有n张牌，然后他总是随机取出两张来，然后他一眼就能看出这两牌中哪一张小（相同就取相同的，这操作好像对于Ar老师来说太简单了），作为这两张牌的有效分值，然后呢他陷入了沉思，对于n张牌取两张牌显然有确定的组合可能性，有n(n-1)/2对组合，然后他想知道所有这些组合中第k大的分值是多少。输入描述:输入一个t表示数据组数；(0&lt;t&lt;=10)接下来一行是n,k,表示n张牌和最后第k大的分值；（1&lt;n&lt;2500,保证0&lt;k&lt;=n(n-1)/2）接下来一行是n个值ai，表示第i张牌上的数字(0 &lt; ai &lt;= 10000000)。输出描述:每组数据输出一行，即第k大的分值为多少。 示例 输入 2 3 2 1 2 3 3 1 4 2 1 输出 1 2 题解： 首先将这n个数进行从大到小排序，a[0]储存第1大，a[1]储存第2大……第2个和第1个比较最小的是第2个，第3个和前两个比较较小的均是第3个，第4个和前3个比较均是第4个，以此递推，第n个数和n前n-1个比较均是n较小。将所有情况全排列很容易超时，因此我们可以从第k大这个k下手。由于a[0]最大，因此a[0]和任意比较都不会输出a[0]。那么首先k为1输出a[1],1&lt;k&lt;=1+2输出a[2],1+2&lt;k&lt;=1+2+3输出a[3]……现在应该很清楚了吧。可以设置一个变量cnt，和i,从1开始，cnt每次加1，i每次加cnt，直到i加到比k大或者等于时，那么此时的a[cnt]就是第k大的数。 1234567891011121314151617181920212223#include&lt;iostream&gt; #include&lt;algorithm&gt; int cmp(int a, int b) &#123; return a &gt; b; &#125; int T, N, k, a[100010]; using namespace std; int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; k; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + N, cmp); int cnt = 1, i = 1; for (int i = 1; i &lt; k; i += cnt) &#123; cnt++; &#125; cout &lt;&lt; a[cnt] &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言实现小游戏——控制台扫雷]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-2%2F</url>
    <content type="text"><![CDATA[程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌。此处用到了dfs。仅供参考。 项目版： mine.h 1234567#pragma once #define BOOM 10 #define SIZE 10 void init(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b);//初始化扫雷页面void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j);//如果展开面为0，通过深搜将周围所以为0的区域展开 int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//判断胜利条件 void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//展示扫雷页面 mine.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; int stemp[8][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123; 1,1 &#125;,&#123; -1,-1 &#125;,&#123; 1,-1 &#125;,&#123; -1,1 &#125; &#125;;//深搜时上下左右四个方向搜索 void init(char (*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(MAP, visit, i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(MAP, visit, x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y;//坐标 int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(MAP, visit, x, y); scanf(&quot;%d%d&quot;, &amp;y, &amp;x); init(MAP,visit, x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;y, &amp;x); int res = check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125; 另附原始版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #define BOOM 10 #define SIZE 10 char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y; int stemp[8][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;, &#123;-1,1&#125; &#125;; void init(int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check() &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show() &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); init(x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(); system(&quot;cls&quot;); show(); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int res = check(); system(&quot;cls&quot;); show(); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现随机生成数独九宫格]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-1%2F</url>
    <content type="text"><![CDATA[一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; void main() &#123; int a[9][9] = &#123; 0 &#125;; int *p[3][3], *m[3][6], *n[3][6], *r[9][4], *aa[9][9]; int **q[9]; int i, j, k, l, h, t, s = 0; void rank(int *x, int *y); bool check(int a[9][9], int n); srand((int)time(0)); for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 3; j++) p[i][j] = &amp;a[i * 3 + 1][j * 3 + 1]; for (k = 0; k &lt; 9; k++) q[k] = &amp;p[k / 3][k % 3]; for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; m[i][j] = &amp;a[i * 3 + 1][2 * j - j / 2]; n[i][j] = &amp;a[2 * j - j / 2][i * 3 + 1]; &#125; for (k = 0; k &lt; 9; k++) for (l = 0; l &lt; 4; l++) r[k][l] = &amp;a[(k / 3) * 3 + (l / 2) * 2][(k % 3) * 3 + (l % 2) * 2]; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) aa[i][j] = &amp;a[i][j]; step1: for (i = 0; i &lt; 9; i++) &#123; next1: **q[i] = rand() % 10; if (**q[i] == 0) goto next1; for (j = 0; j &lt; i; j++) if (**q[j] == **q[i]) goto next1; &#125; step2: for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; next2: *m[i][j] = rand() % 10; if (*m[i][j] == 0) goto next2; for (k = 0; k &lt; 3; k++) if (*m[i][j] == *p[i][k]) goto next2; for (k = 0; k &lt; j; k++) if (*m[i][j] == *m[i][k]) goto next2; for (k = 0; k &lt; i; k++) if (*m[i][j] == *m[k][j]) goto step2; &#125; step3: for (i = 0; i &lt; 3; i++) &#123; next4: for (j = 0; j &lt; 6; j++) &#123; next3: *n[i][j] = rand() % 10; if (*n[i][j] == 0) goto next3; for (k = 0; k &lt; 3; k++) if (*n[i][j] == *p[k][i]) goto next3; for (k = 0; k &lt; j; k++) if (*n[i][j] == *n[i][k]) goto next3; for (l = 0; l &lt; 2; l++) &#123; if (*n[i][j] == *m[j / 2][i * 2 + l]) goto next4; &#125; for (k = 0; k &lt; i; k++) if (*n[i][j] == *n[k][j]) goto step3; &#125; &#125; step4: for (i = 0; i &lt; 3; i++) &#123; for (h = 0; h &lt; 2; h++) &#123; next6: for (l = 0; l &lt; 3; l++) for (j = 0; j &lt; 2; j++) &#123; next5: *r[i * 3 + l][h * 2 + j] = rand() % 10; if (*r[i * 3 + l][h * 2 + j] == 0) goto next5; if (*r[i * 3 + l][h * 2 + j] == **q[i * 3 + l]) goto next5; for (k = 0; k &lt; h * 2 + j; k++) if (*r[i * 3 + l][h * 2 + j] == *r[i * 3 + l][k]) goto next5; for (k = 0; k &lt; 2; k++) &#123; if (*r[i * 3 + l][h * 2 + j] == *m[i][l * 2 + k]) goto next5; if (*r[i * 3 + l][h * 2 + j] == *n[l][i * 2 + k]) goto next5; &#125; for (k = 0; k &lt;= l * 3 + j * 2; k++) for (t = 0; t &lt; k; t++) if (a[i * 3 + h * 2][k] == a[i * 3 + h * 2][t]) goto next6; &#125; &#125; &#125; step5: for (i = 0; i &lt; 3; i++) &#123; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); if (check(a, i) == false) rank(aa[j][i * 3], aa[j][i * 3 + 2]); else if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 9; l++) &#123; for (j = l + 1; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 6; l++) &#123; for (h = l + 1; h &lt; 7; h++) &#123; for (j = h + 1; j &lt; 8; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) goto step4; &#125; printf(&quot;+---------------+---------------+---------------+\n&quot;); printf(&quot;| | | |\n&quot;); for (i = 0; i &lt; 9; i++) &#123; printf(&quot;| &quot;); for (j = 0; j &lt; 9; j++) &#123; printf(&quot;%-4d&quot;, a[i][j]); if ((j + 1) % 3 == 0) printf(&quot;| &quot;); &#125; printf(&quot;\n&quot;); printf(&quot;| | | |\n&quot;); if ((i + 1) % 3 == 0) &#123; printf(&quot;+---------------+---------------+---------------+\n&quot;); if (i &lt; 8) printf(&quot;| | | |\n&quot;); &#125; &#125; system(&quot;pause&quot;); &#125; void rank(int *x, int *y) &#123; int t; t = *x; *x = *y; *y = t; &#125; bool check(int a[9][9], int n) &#123; int i, j; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; i; j++) if (a[i][n * 3] == a[j][n * 3]) return false; return true; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现控制台小游戏——数字拼图]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20%2F</url>
    <content type="text"><![CDATA[一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;math.h&gt; #include &lt;time.h&gt; #define max 10 int x, y, step, label = 0; typedef struct score &#123; int steps, steps2; double times; char name[18]; &#125;score; score sco[max + 1]; char ch, buff[3]; bool flag, flag1 = false; clock_t start, finish; bool over()&#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t\t\t您共用了 %d 步 ,耗时 %.3f 分钟\n&quot;, step, (double)(finish - start) / 40000); system(&quot;pause&quot;); system(&quot;cls&quot;); printf(&quot;\n\n\n\n\n\n\n\n\t******************* 您是否重新开始游戏 (Y/N) ? *******************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch != &apos;n&apos;&amp;&amp;ch != &apos;N&apos;) &#123; return false; &#125; else &#123; printf(&quot;\n\n\n\n\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n&quot;); printf(&quot;\t+++++++++++++++++++++++++ 感谢您的使用 +++++++++++++++++++++++++\n&quot;, step); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); system(&quot;pause&quot;); exit(0); &#125; return true; &#125; void rank(score sco[],int n) &#123; int i, j; sco[0] = sco[n]; for (i = 0; i &lt; n; i++) if (sco[n].steps2&gt;sco[i].steps2) &#123; for (j = n; j &gt; i; j--) sco[j] = sco[j - 1]; sco[i] = sco[0]; break; &#125; for (j = i - 1; j &gt; 0; j--) if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps &lt; sco[j].steps) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; else if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps == sco[j].steps) if (sco[i].times &lt; sco[j].times) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; &#125; int check2(int *p, int n) &#123; int i, j, flag2 = 0; for (i = 1; i &lt; n*n - 1; i++) for (j = 0; j &lt; i; j++) if (p[j] &gt; p[i]) flag2++; if (!flag2) return 0; else if (flag2 % 2 == 0) return 2; else return 1; &#125; bool check(int *p,int n) &#123; int i; flag = true; for (i = 0; i&lt;n*n - 1; i++) if (p[i] != i + 1) flag = false; if (flag) &#123; flag1 = false; return false; &#125; return true; &#125; int operation(int *p,int n) &#123; scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch &gt;= &apos;a&apos;&amp;&amp;ch &lt;= &apos;z&apos;) ch -= 32; switch (ch) &#123; case &apos;A&apos;: if (y == n - 1) return 1; p[x*n + y] = p[x*n + y + 1]; p[x*n + y + 1] = 0; y++; step++; return 1; case &apos;W&apos;: if (x == n - 1) return 1; p[x*n + y] = p[(x + 1)*n + y]; p[(x + 1)*n + y] = 0; x++; step++; return 1; case &apos;D&apos;: if (y == 0) return 1; p[x*n + y] = p[x*n + y - 1]; p[x*n + y - 1] = 0; y--; step++; return 1; case &apos;S&apos;: if (x == 0) return 1; p[x*n + y] = p[(x - 1)*n + y]; p[(x - 1)*n + y] = 0; x--; step++; return 1; case &apos;R&apos;: return 2; case &apos;M&apos;: return 3; case &apos;Q&apos;: printf(&quot;\n\n\t********************* 您是否要离开游戏 (Y/N) ? *********************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch == &apos;y&apos; || ch == &apos;Y&apos;) return 4; else return 1; default: return 1; &#125; return 0; &#125; void map(int *p, int n) &#123; int i, j; system(&quot;cls&quot;); printf(&quot;\n\n\n&quot;); for (i = 0; i &lt; n; i++) &#123; printf(&quot;\t&quot;); for (j = 0; j &lt; n; j++) &#123; if (p[n*i + j] != 0) printf(&quot;%-4d&quot;, p[n*i + j]); else printf(&quot; &quot;); &#125; printf(&quot;\n\n&quot;); &#125; printf(&quot;\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); finish = clock(); printf(&quot;\n\t\t\t\t步数: %d\t 使用时间: %.3f 分钟 \n\n&quot;, step, (double)(finish - start) / 40000); &#125; void reset(int *p, int n) &#123; int i, j, flag2; system(&quot;cls&quot;); do &#123; for (i = 0; i &lt; n*n - 1; i++) &#123; do &#123; flag2 = 1; p[i] = rand() % (n*n - 1) + 1; for (j = 0; j &lt; i; j++) if (p[i] == p[j]) flag2 = 0; &#125; while (!flag2); &#125; flag2 = check2(p, n); if (flag2 == 1) &#123; flag2 = p[n*n - 2]; p[n*n - 2] = p[n*n - 3]; p[n*n - 3] = flag2; &#125; &#125; while (!flag2); p[n*n - 1] = 0; for (i = 0; i&lt;n; i++) for (j = 0; j&lt;n; j++) if (p[i*n + j] == 0)&#123; x = i; y = j; &#125; &#125; void help() &#123; int i = 0; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t--------------------------------+ 基本操作 +--------------------------------\n\n&quot;); printf(&quot;\n\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); printf(&quot;\n\n\t---------------------------+ 浅悠悠（王骏）制作 +---------------------------\n\n&quot;); if (label == 0) printf(&quot;\n\n\t--------------------------+ 暂时没有任何游戏记录 +--------------------------\n\n&quot;); else for (i = 1; i &lt;= label; i++) printf(&quot;\n\n\t 第%02d名：%-18s 步数：%-5d 阶数：%-5d 时间：%-6.3lf分钟\n\n&quot;, i, sco[i].name, sco[i].steps, sco[i].steps2, sco[i].times); printf(&quot;\n\n\t----------------------------+ 按任意键返回菜单 +----------------------------\n\n&quot;); system(&quot;pause&quot;); &#125; void game() &#123; int n, *p; int mark; do &#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t------------------+ 请输入阶数（推荐3——20阶） +------------------\n\n&quot;); scanf(&quot;%d&quot;, &amp;n); if (n &gt; 1) p = (int*)calloc(n*n, sizeof(int)); else printf(&quot;\t********************** 您输入有误，请重新输入 **********************\n\n&quot;), system(&quot;pause&quot;); &#125; while (n &lt;= 1); next1: step = 0; start = clock(); reset(p, n); next2: map(p, n); if (check(p, n) == false) &#123; printf(&quot;\n\n\t=================+ 恭喜您完成游戏，请输入您的姓名 +=================\n\n&quot;); scanf(&quot;%s&quot;, sco[++label].name); sco[label].steps = step; sco[label].steps2 = n; sco[label].times = (double)(finish - start) / 40000; rank(sco, label); if (over() == false) return; &#125; mark = operation(p, n); if (mark == 1) goto next2; else if (mark == 2) goto next1; else if (mark == 3) return; else if (mark == 4) if (over() == false) return; free(p); &#125; int main()&#123; srand((int)time(0)); do &#123; system(&quot;cls&quot;); printf(&quot;\t-------------+ 欢迎来到浅悠悠数字拼图，请选择您的操作 +-------------\n\n&quot;); printf(&quot;\t-----+ 1.开始游戏 +-----+ 2.帮助 +-----+ 0(或其他).退出 +-----\n\n&quot;); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; switch (ch)&#123; case&apos;1&apos;: game(); break; case&apos;2&apos;: help(); break; case&apos;0&apos;: exit(0); default: exit(0); &#125; &#125; while (ch != &apos;0&apos;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]正向BFS+hash解决八码问题]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18%2F</url>
    <content type="text"><![CDATA[八数码问题，可以用单向广搜、双向广搜、A*、IDA等多种方法求解。具体可以参考：八数码的八境界 Description 1234567 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 x 123456789 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 12 13 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x r-&gt; d-&gt; r-&gt; Input 123451 2 3 x 4 6 7 5 8 11 2 3 x 4 6 7 5 8 Output You will print to standard output either the word unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Sample Input 12 3 4 1 5 x 7 6 8 Sample Output 1ullddrurdllurdruldr 题解： 本题一共仅有9！种结果，因此求解方法很多。一开始采用stl进行存储，但一直超时，后来改用hash轻轻松松就过了。判重时9！个排列如果用数组直接保存，每一位保存一个维度，数组开不了那么大。因此可以根据康托展开进行判重，每一种排列对应成一个整形数字，9！种排列一共9！个数字，提高了hash效率。此外，对于x我们暂且当做9处理，而123456789的康托展开是1，因此bfs的终止条件就设为当前状态的康拓展开是否为1。此外，由于本次采用正向bfs，而输出结果时需要输出之前的状态，string储存太慢，queue队列会丢失之前的状态，因此用数组充当队列，用pre追溯上一个状态在队列中的下标。解决代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; using namespace std; const int MAXN = 400000; int fac[9] = &#123; 1, 1, 2, 6, 24, 120, 720, 5040, 40320&#125;; int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;; int opp[4] = &#123; &apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos; &#125;; bool vis[MAXN]; struct node &#123; int stadus; int cur[9]; int loc; char path; int pre; &#125;; node qu[MAXN]; int cantor(int s[]) &#123; int sum = 0; for (int i = 0; i&lt;9; i++) &#123; int num = 0; for (int j = i + 1; j&lt;9; j++) if (s[j]&lt;s[i]) num++; sum += num*fac[8 - i]; &#125; return sum + 1; &#125; int bfs(node now) &#123; memset(vis, false, sizeof(vis)); int x, y; int front = 0, end = 0; node no = now; qu[end++] = no; vis[now.stadus] = true; while (front &lt; end) &#123; no = qu[front++]; x = no.loc / 3; y = no.loc % 3; if (no.stadus == 1) return front - 1; for (int i = 0; i &lt; 4; i++) &#123; node cc = no; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 3 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; 3 &amp;&amp; yy &gt;= 0) &#123; cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.cur[xx * 3 + yy] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.stadus = cantor(cc.cur); if (!vis[cc.stadus]) &#123; vis[cc.stadus] = true; cc.loc = xx * 3 + yy; cc.path = opp[i]; cc.pre = front - 1; qu[end++] = cc; &#125; &#125; &#125; &#125; return -1; &#125; void show(int a) &#123; if (qu[a].pre) &#123; show(qu[a].pre); &#125; printf(&quot;%c&quot;, qu[a].path); &#125; int main() &#123; string tmp; while (getline(cin, tmp)) &#123; int i = 0, cnt = 0; node temp; while (tmp[i]) &#123; if (tmp[i] == &apos; &apos;) &#123; i++; continue; &#125; else if (tmp[i] == &apos;x&apos;) &#123; temp.loc = cnt; temp.cur[cnt] = 9; cnt++; i++; &#125; else &#123; temp.cur[cnt] = tmp[i] - &apos;0&apos;; cnt++; i++; &#125; &#125; temp.stadus = cantor(temp.cur); int ans = bfs(temp); ans != -1 ? show(ans) : printf(&quot;-1&quot;); cout &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>八数码</tag>
        <tag>康托展开</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[位运算]dfs+位运算解决N皇后问题]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13%2F</url>
    <content type="text"><![CDATA[在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的N，求出有多少种合法的放置方法。共有若干行，表示棋盘和皇后的数量；如果N=0，表示结束。 分析： 本篇文章重点介绍位运算解决N皇后的思想，并不是解决特定的问题。和普通算法一样，这是一个递归过程，程序一行一行地寻找可以放皇后的地方。过程带三个参数，row、ld和rd，分别表示在纵列和两个对角线方向的限制条件下这一行的哪些地方不能放。我们以6×6的棋盘为例，看看程序是怎么工作的。假设现在已经递归到第四层，前三层放的子已经标在左图上了。红色、蓝色和绿色的线分别表示三个方向上有冲突的位置，位于该行上的冲突位置就用row、ld和rd中的1来表示。把它们三个并起来，得到该行所有的禁位，取反后就得到所有可以放的位置。注意递归调用时三个参数的变化，每个参数都加上了一个禁位，但两个对角线方向的禁位对下一行的影响需要平移一位。最后，如果递归到某个时候发现row=111111了，说明六个皇后全放进去了，此时程序从第1行跳到第11行，找到的解的个数加一。 123456789101112131415161718192021#include&lt;stdio.h&gt; #include&lt;math.h&gt; int N, Count, res; void dfs(int row, int ld, int rd) &#123; if (row == res) &#123; Count++; return; &#125; for (int j = 1; j &lt;= res; j &lt;&lt;= 1) if (row != (row | j) &amp;&amp; ld != (ld | j) &amp;&amp; rd != (rd | j)) dfs(row | j, (ld | j) &lt;&lt; 1 &amp; res, (rd | j) &gt;&gt; 1); &#125; int main() &#123; while (~scanf(&quot;%d&quot;, &amp;N), N) &#123; Count = 0; res = pow(2, N) - 1; dfs(0, 0, 0); printf(&quot;%d\n&quot;, Count); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DFS</tag>
        <tag>ACM/ICPC</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[位运算]位运算的4个简单应用]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13-1%2F</url>
    <content type="text"><![CDATA[\1. 不用任何比较判断两个数中大的那个数 我们将两个数做差，得到另一个数，判断这个数的符号位就可以了。当然，不能直接使用判断语句，所以我们使用位运算来操作。 \2. 两个相同的数异或结果等于0。 就这道题而言，在运算过程中会产生一个中间值，即a与b的异或结果，a异或b再异或b就会等于a，如果第二次异或a就会等于b。 所以直接三个异或就可以搞定 \3. 整数的二进制中有多少个1 每次循环采用n&amp;=(n-1)，这样可以跳过二进制位是0的数。 \4. 数组中只有一个数出现了奇数次，其他数都出现偶数次，找出这个数 这道题还是使用了异或的性质，两个相同的数异或等于0，遍历一遍数组就可以得到出现奇数次的那个数。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言允许初始化列表中末尾出现多余的逗号]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01%2F</url>
    <content type="text"><![CDATA[C语言允许初始化列表中出现多余的逗号，例如： 1int days[] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, &#125;; 为什么这种特性是有用的？ 123456789101112#include &lt;stdio.h&gt; int main(int argc,char** argv)&#123; enum qs&#123; Va = 5, Vb, Vc, &#125; s; printf(&quot;a=%d,b=%d,c=%d&quot;,Va,Vb,Vc); return 0; &#125; 像enum枚举中的条目有可能是根据其它资源来的，而程序员会制作代码生成工具来生成它，所以就允许enum中的多余逗号。像int i = 9,j = 0;这种用法完全可以拆成int i=9;int j=0;因此不会增加代码生成器的负担，所以不支持int i=9,j=0,; 像这种代码，如果用代码生成器去读资源然后写进去，那么每生成一行都需要在末尾加一个逗号来分隔。C允许最后一行有多余的逗号，那就可以不用单独去处理最后一行了，减轻了代码生成器的制作负担，同时因为不用自行删除最后一个逗号，代码生成器的编写也就更不容易出错了。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历（根据后序遍历中序遍历推出层序遍历）]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%2F</url>
    <content type="text"><![CDATA[对于二叉树的遍历，分为深度优先遍历与广度优先遍历，广度优先遍历有时又称作层序遍历。而深度优先遍历又分为前序遍历，中序遍历和后序遍历。三者之间的区别主要在于根结点的遍历顺序。前序遍历的顺序是根结点-&gt;左子树-&gt;右子树，中序遍历顺序是左子树-&gt;根结点-&gt;右子树，后序遍历顺序是左子树-&gt;右子树-&gt;根结点。现在给出树的后序遍历与中序遍历，要求写出该树的层序遍历。以下是pat上的例题： 给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。 输入格式： 输入第一行给出一个正整数N（&lt;=30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。 输出格式： 在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例： 12372 3 1 5 7 6 41 2 3 4 5 6 7 输出样例： 14 1 6 3 5 7 2 分析： 树的后序遍历特点是最后一个遍历的永远是根结点，由样例很容易看到4即为该树的根结点。而中序遍历的特点是根结点的左边永远是根结点的左子树部分，右边永远是根结点的右子树部分。而树的每一个子树都可以作为新的根。因此二者结合起来很容易将整个树构建出来。以样例为例，首先可以从后序遍历确定4为根结点，然后对照着中序遍历找到4的中序位置为第4位，然后以4为界将树分为以左子树为根的树和以右子树为根的树。现在可以确定根的左子树与右子树的个数分别为m，n，而后序遍历先遍历左子树部分，因此可以确定左子树部分为第1~m位，右子树部分为m+1~m+n位，最后一位为根结点。而左子树部分最后一位即第n位为左子树部分的根即左子树，同理右子树也一样。由此我们只需建立一个树遍历的函数ergodic(int root, int start, int end, int index)即可。其中root为根结点，start与end为由该根结点所衍生出的所有子树的范围，index记录该树的位置。由后序遍历可知end即为根结点的位置，有start开始遍历中序，直到找到根结点在中序遍历中的位置i，在以i为界划分为（start，i-1）与（i+1，end）两部分，而root则为后序遍历中（start，end）中的end位置，即为root-end+i-1的位置。我们初始树的所有结点为-1，意味空值，因此最终搭建的树只需按顺序遍历所有有值部分即可。以下是代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;post, in, level(100000, -1); int N; void ergodic(int root, int start, int end, int index) &#123; int i = start; if (start &gt; end) return; while (i &lt; end&amp;&amp;in[i] != post[root]) i++; level[index] = post[root]; //cout &lt;&lt; root &lt;&lt; start &lt;&lt; end &lt;&lt; i &lt;&lt; endl; ergodic(root - 1 - end + i, start, i - 1, 2 * index + 1); ergodic(root - 1, i + 1, end, 2 * index + 2); &#125; int main() &#123; cin &gt;&gt; N; post.resize(N); in.resize(N); for (int i = 0; i &lt; N; i++) cin &gt;&gt; post[i]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; in[i]; ergodic(N - 1, 0, N - 1, 0); for (int i = 0, cnt = 0; i &lt; level.size(); i++) &#123; if (level[i] != -1) &#123; cout &lt;&lt; level[i]; cnt != N - 1 ? cout &lt;&lt; &apos; &apos; : cout &lt;&lt; endl; cnt++; &#125; &#125; return 0; &#125; 对于前序遍历也一样，因为前序遍历的特点和后序遍历的特点刚好相反，前序遍历第第一位总是根结点。根据两种遍历即可推出整棵树的结构，搭建完树的结构，任何遍历都会很方便。]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++八进制赋值与输入常见陷阱]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29-1%2F</url>
    <content type="text"><![CDATA[在C语言及C++中，一个整形数值前如果有一个数字0，则代表该整形数值为八进制数。例如int a，a = 010，则a的十进制数值为8，八进制数值为10。但是在输入a的时候，输入010，如果用scanf（“%d”，&amp;a），则将会被当做十进制10识别。而在c++中使用cout&lt;&lt;a时，也将会被默认为十进制输入。以下是测试用例。 12345678910#include&lt;iostream&gt; using namespace std; int main() &#123; int a = 010; cout &lt;&lt;&quot;将010赋给a时：a = &quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;请输入a:&quot;; cin &gt;&gt; a; cout &lt;&lt; &quot;将010输入给a时：a = &quot; &lt;&lt; a; return 0; &#125; 由此可知，cout默认是以十进制进行输入的。因此，我们在赋值与输入时，得格外注意进制之间的转换。例如： 12345678struct temp&#123; int a; int b; int c; &#125;temp_1 = &#123; 001, 010, 222 &#125;; 我们经常会在赋值时为了将数值对齐显得美观而在数值之前添加0，这样往往会导致得到的结果错误，因为系统将之默认为八进制赋值。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>进制</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据结构]L2-022. 重排链表]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-3%2F</url>
    <content type="text"><![CDATA[L2-022. 重排链表给定一个单链表 L1→L2→…→Ln-1→Ln，请编写程序将链表重新排列为 Ln→L1→Ln-1→L2→…。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。 输入格式： 每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (&lt;= 105)。结点的地址是5位非负整数，NULL地址用-1表示。 接下来有N行，每行格式为： Address Data Next 其中Address是结点地址；Data是该结点保存的数据，为不超过105的正整数；Next是下一结点的地址。题目保证给出的链表上至少有两个结点。 输出格式： 对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 输入样例： 123456700100 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 输出样例： 12345668237 6 0010000100 1 9999999999 5 1230912309 2 0000000000 4 3321833218 3 -1 分析： 一道数据结构链表题。由于每一次输出链表两边的元素，因此可以构建一个双向链表。即结构体中储存上一个元素pre，数据data，下一个元素next。然后设置一个根结点root和尾结点tail，分别指向第一个结点地址和最后一个结点地址。先输出tail，tail指向对应上一个元素pre。再输出root，root指向对应下一个元素next，以此循环。直到tail与root相遇时输出tail，终止循环。输出tail对应数据时，可以输出tail，data，root，输出root对应数据时，可以输出root，data，tail。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt; #define Maxn 100000 using namespace std; struct Lists &#123; int pre; int data; int next; Lists() &#123; pre = -1; data = 0; next = -1; &#125; &#125;List[Maxn]; int main() &#123; int root, N, tail; scanf(&quot;%d%d&quot;, &amp;root, &amp;N); for (int i = 0; i &lt; N; i++) &#123; int temp; scanf(&quot;%d&quot;, &amp;temp); scanf(&quot;%d%d&quot;, &amp;List[temp].data, &amp;List[temp].next); if (List[temp].next != -1) List[List[temp].next].pre = temp; else tail = temp; &#125; int flag = 0; while (root != tail) &#123; printf(&quot;%05d %d %05d\n&quot;, tail, List[tail].data, root); tail = List[tail].pre; if (root == tail) break; printf(&quot;%05d %d %05d\n&quot;, root, List[root].data, tail); root = List[root].next; &#125; printf(&quot;%05d %d -1\n&quot;, root, List[root].data); return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[并查集]L2-024. 部落]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-2%2F</url>
    <content type="text"><![CDATA[L2-024. 部落时间限制 120 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。 输入格式： 输入在第一行给出一个正整数N（&lt;= 104），是已知小圈子的个数。随后N行，每行按下列格式给出一个小圈子里的人： K P[1] P[2] … P[K] 其中K是小圈子里的人数，P[i]（i=1, .., K）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。 之后一行给出一个非负整数Q（&lt;= 104），是查询次数。随后Q行，每行给出一对被查询的人的编号。 输出格式： 首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出“Y”，否则输出“N”。 输入样例： 1234567843 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 输出样例： 12310 2YN 分析： 本题又是一道并查集。我的做法是用映射，将所有人映射到对应的圈子中。例如第i个圈子共有k个人，分别为k1…kj…kk。则map[kj]=i。倘若kj已经有对应的圈子，那将两个圈子联系起来。即Union（map[kj]，i）。此外设置计数器sum，每一次执行完map[kj]=i之后sum++，即未重复的人加一。最后计算每一个圈子i是否等于pre[i]，计算独立圈子的个数。判断两个人是否是一个部落，只需查询他们映射的圈子是否相同，即root(map[a])是否等于root(map[b])。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt; #include&lt;cstdio&gt; #define MAXN 10005 using namespace std; int N, k; int pre[MAXN]; int maps[MAXN]; int root(int x) &#123; while (x != pre[x]) &#123; pre[x] = pre[pre[x]]; x = pre[x]; &#125; return x; &#125; void Union(int px,int py) &#123; px = root(px); py = root(py); if (px != py) pre[py] = px; &#125; int main() &#123; cin &gt;&gt; N; int sum = 0; for (int i = 0; i &lt; MAXN; i++) &#123; pre[i] = i; maps[i] = 0; &#125; for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; k; while (k--) &#123; int temp; cin &gt;&gt; temp; if (!maps[temp]) &#123; maps[temp] = i; sum++; &#125; else Union(maps[temp], i); &#125; &#125; int count = 0; for (int i = 1; i &lt;= N; i++) if (pre[i] == i) count++; printf(&quot;%d %d\n&quot;, sum, count); cin &gt;&gt; k; while (k--) &#123; int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; if (root(maps[xx]) == root(maps[yy])) printf(&quot;Y\n&quot;); else printf(&quot;N\n&quot;); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++结构体内部初始化]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-1%2F</url>
    <content type="text"><![CDATA[我都知道，c语言中结构体内部是不支持初始化的。如果要初始化结构体，可以在声明变量时进行初始化。例如： 123456struct Test&#123; int a; char b; double c; &#125;; Test test_1 = &#123; 1, &apos;a&apos;, 0 &#125;; 然而c++中结构体内部在声明变量的同时可以声明函数，这为结构体内部初始化提供了很大的便利。 因此上面用例可以写成： 12345678910struct Test&#123; int a; char b; double c; Test()&#123; a = 1; b = &apos;a&apos;; c = 0; &#125; &#125;; 这为定义结构体时关于初始化问题提供了很大的便利。 以下是代码及运行结果： 12345678910111213141516#include&lt;iostream&gt; using namespace std; struct Test &#123; int a; char b; double c; Test() &#123; a = 1; b = &apos;a&apos;; c = 0; &#125; &#125;Text_1; int main() &#123; cout &lt;&lt; Text_1.a &lt;&lt; endl &lt;&lt; Text_1.b &lt;&lt; endl &lt;&lt; Text_1.c; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模拟]来一瓶82年拉菲（酒杯问题）]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28%2F</url>
    <content type="text"><![CDATA[问题描述： 悠神最近过生日，朋友纷纷来贺。现有一瓶82年拉菲与若干酒杯。酒杯呈三角形酒塔摆放，即每一个酒杯摆放在下一层两个酒杯中间，最下面一层酒杯摆放在桌面上。共有N(1&lt;=N&lt;=20)层酒杯，第k层共有k个酒杯。悠神将拉菲倒进第一层的酒杯中，速度为1杯/s，倒满后酒会向左右两个方向溢出，假设会全部溢出到这个酒杯下面相邻的两个酒杯中。然而悠神有洁癖，他不喜欢浪费，更不喜欢浸湿他心爱的桌布，所以请你计算一下第几秒之后桌布会被浸湿。 eg：如图所示为3层时的情况。第一层倒满需要1s，第二次倒满需要2s，第三层首次倒满需要2s。所以共需1+2+2=5s。 输入： 输入N(1&lt;=N&lt;=20)。 输出： 桌布浸湿时至少所需时间（取整数）。 输入样例： 2 输出样例： 3 分析： 桌布浸湿只与最下层最中间位置何时倒满有关，因此只需计算最下层中间位置酒杯的状态。由于时间取整，所以只需模拟出第一杯共倒了多少杯酒，即为多少s。而每一个酒杯共倒了多少酒与上一层相邻两个酒杯相关，及第i层第j个酒杯的酒只与第i-1层第j-1个和第j个酒杯的酒相关。及wine[i][j]=wine[i-1][j-1]+wine[i-1][j];由于酒杯有两种状态，及未满状态和倒满状态，所以要判断wine[i-1]层的酒是否&gt;1。 12345678910111213141516171819202122#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define MAXN 20 int main() &#123; int N; while (~scanf(&quot;%d&quot;, &amp;N)) &#123; double wine[MAXN + 1][MAXN + 1] = &#123; 0 &#125;; double temp = 0; while (wine[N][N / 2 + 1] &lt; 1) &#123; memset(wine, 0, sizeof(wine)); temp++; wine[1][1] = temp; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; wine[i][j] += (wine[i - 1][j - 1] &gt; 1 ? (wine[i - 1][j - 1] - 1) / 2.0 : 0) + (wine[i - 1][j] &gt; 1 ? (wine[i - 1][j] - 1) / 2.0 : 0); &#125; &#125; &#125; printf(&quot;%g\n&quot;, wine[1][1]); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]愿天下有情人都是失散多年的兄妹]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-1%2F</url>
    <content type="text"><![CDATA[题目概述：L2-016. 愿天下有情人都是失散多年的兄妹时间限制 200 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？ 输入格式： 输入第一行给出一个正整数N（2 &lt;= N &lt;= 104），随后N行，每行按以下格式给出一个人的信息： 本人ID 性别 父亲ID 母亲ID 其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。 接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。 注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。 输出格式： 对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出“Never Mind”；如果是异性并且关系出了五服，输出“Yes”；如果异性关系未出五服，输出“No”。 输入样例： 12345678910111213141516171819202122232425262728293031323334352400001 M 01111 -100002 F 02222 0333300003 M 02222 0333300004 F 04444 0333300005 M 04444 0555500006 F 04444 0555500007 F 06666 0777700008 M 06666 0777700009 M 00001 0000200010 M 00003 0000600011 F 00005 0000700012 F 00008 0888800013 F 00009 0001100014 M 00010 0999900015 M 00010 0999900016 M 10000 0001200017 F -1 0001200018 F 11000 0001300019 F 11100 0001800020 F 00015 1111000021 M 11100 0002000022 M 00016 -100023 M 10012 0001700024 M 00022 10013900021 0002400019 0002400011 0001200022 0001800001 0000400013 0001600017 0001500019 0002100010 00011 输出样例： 123456789Never MindYesNever MindNoYesNoYesNoNo 1分析： 利用广度优先搜索，将每个人及双亲放入集合mab中，假如集合长度为改变，则说明mab中已存在这个人，则证明双方是近亲。visit用来记录层数。五层时结束搜索。 AC代码BFS： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define MAXN 100005 using namespace std; struct inf &#123; int fa; int ma; char sex; &#125;; inf node[MAXN]; int visit[MAXN]; bool flag[MAXN]; int N; bool BFS(int x1,int x2) &#123; memset(visit, 0, sizeof(visit)); queue&lt;int&gt;family; set&lt;int&gt;mab; family.push(x1); family.push(x2); visit[x1] = 1; visit[x2] = 1; while (!family.empty()) &#123; int top = family.front(); family.pop(); int size = mab.size(); mab.insert(top); if (mab.size() == size) &#123; return true; break; &#125; if (visit[top] &lt;= 4) &#123; if (node[top].fa) &#123; family.push(node[top].fa); visit[node[top].fa] += visit[top] + 1; &#125; if (node[top].ma) &#123; family.push(node[top].ma); visit[node[top].ma] += visit[top] + 1; &#125; &#125; &#125; return false; &#125; int main() &#123; cin &gt;&gt; N; memset(node, 0, sizeof(node)); memset(flag, 0, sizeof(flag)); while (N--) &#123; int id, fa, ma; char ch[2]; scanf(&quot;%d%s%d%d&quot;, &amp;id, ch, &amp;fa, &amp;ma); node[id].sex = ch[0]; flag[id] = true; if (fa != -1) &#123; node[id].fa = fa; node[fa].sex = &apos;M&apos;; flag[fa] = true; &#125; if (ma != -1) &#123; node[id].ma = ma; node[ma].sex = &apos;F&apos;; flag[ma] = true; &#125; &#125; cin &gt;&gt; N; while (N--) &#123; int per1, per2; cin &gt;&gt; per1 &gt;&gt; per2; if (node[per1].sex == node[per2].sex) printf(&quot;Never Mind\n&quot;); else &#123; if (BFS(per1, per2)) printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>pat天梯赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector的嵌套实现二维数组，解决矩阵相乘问题]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26%2F</url>
    <content type="text"><![CDATA[定义vector的元素可以是一个vector。比如， vector&lt;vector&gt; 即表示一个二维int数组，里层的vector表示第一维， 外层的vector表示第二维。 例题描述：L1-048. 矩阵A乘以B时间限制 400 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。 输入格式： 输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。 输出格式： 若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出“Error: Ca != Rb”，其中Ca是A的列数，Rb是B的行数。 输入样例1： 12345672 31 2 34 5 63 47 8 9 0-1 -2 -3 -45 6 7 8 输出样例1： 1232 420 22 24 1653 58 63 28 输入样例2： 123456783 238 2643 -50 173 2-11 5799 6881 72 输出样例2： 1Error: 2 != 3 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int M1, N1, M2, N2; int main() &#123; cin &gt;&gt; M1 &gt;&gt; N1; vector&lt;int&gt;alie(N1); vector&lt;vector&lt;int&gt;&gt;ahang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N1; j++) &#123; scanf(&quot;%d&quot;, &amp;alie[j]); &#125; ahang[i] = alie; &#125; cin &gt;&gt; M2 &gt;&gt; N2; vector&lt;int&gt;blie(N2); vector&lt;vector&lt;int&gt;&gt;bhang(M2); for (int i = 0; i &lt; M2; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; scanf(&quot;%d&quot;, &amp;blie[j]); &#125; bhang[i] = blie; &#125; if (N1 != M2) printf(&quot;Error: %d != %d\n&quot;, N1, M2); else &#123; vector&lt;int&gt;anslie(N2); vector&lt;vector&lt;int&gt;&gt;anshang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; anslie[j] = 0; for (int k = 0; k &lt; N1; k++) anslie[j] += ahang[i][k] * bhang[k][j]; &#125; anshang[i] = anslie; &#125; printf(&quot;%d %d\n&quot;, M1, N2); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2 - 1; j++) printf(&quot;%d &quot;, anshang[i][j]); printf(&quot;%d\n&quot;, anshang[i][N2 - 1]); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F02%2F03%2F2018-02-03%2F</url>
    <content type="text"><![CDATA[韶光浅， 岁月转轴调弦 悠悠流曲耳边， 依依情记心间 又是一季似水流年 愿你跨过千山， 归来一如从前 ——浅悠悠]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS的用途与选择]]></title>
    <url>%2F2018%2F02%2F01%2F2018-02-01%2F</url>
    <content type="text"><![CDATA[1.BFS是用来搜索最短径路的解是比较合适的，比如求最少步数的解，最少交换次数的解，因为BFS搜索过程中遇到的解一定是离根最近的，所以遇到一个解，一定就是最优解，此时搜索算法可以终止。这个时候不适宜使用DFS，因为DFS搜索到的解不一定是离根最近的，只有全局搜索完毕，才能从所有解中找出离根的最近的解。（当然这个DFS的不足，可以使用迭代加深搜索ID-DFS去弥补）2.空间优劣上，DFS是有优势的，DFS不需要保存搜索过程中的状态，而BFS在搜索过程中需要保存搜索过的状态，而且一般情况需要一个队列来记录。3.DFS适合搜索全部的解，因为要搜索全部的解，那么BFS搜索过程中，遇到离根最近的解，并没有什么用，也必须遍历完整棵搜索树，DFS搜索也会搜索全部，但是相比DFS不用记录过多信息，所以搜素全部解的问题，DFS显然更加合适。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类的3种继承方式]]></title>
    <url>%2F2018%2F01%2F24%2F2018-01-24%2F</url>
    <content type="text"><![CDATA[简单地说下C++类的3种继承方式，分别是public继承，protected继承，private继承。 最常用的还是public继承。class默认的是private继承，它的member如果没写权限也是默认 private。struct则相反，默认的是public继承。结合下面的图示和代码，对C++的继承就有了 比较清晰的认识了。 继承之后，derived class 继承过后的member的属性就是图中所示。 代码主要从： 1.基类成员对其对象的可见性： 基类成员对派生类的可见性： 基类成员对派生类对象的可见性： 这3个方面谈的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt; class base&#123; public: base()&#123; a = 0; b = 1; c = 2; &#125; int a; protected: int b; private: int c; &#125;; class derived1 : public base&#123;//public继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived2 : protected base&#123;//protected继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived3 : private base&#123;//private继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived4 : public derived3&#123;//base的member不能被private继承的派生类的子类访问 public: void fun()&#123; // std::cout&lt;&lt;a; &#125; &#125;; class derived5 : base&#123;//默认private继承 void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; int main(void) &#123; base b1; derived1 d1; derived2 d2; derived3 d3; d1.fun(); d2.fun(); d3.fun(); std::cout&lt;&lt;b1.a;//base class Object只能访问public member std::cout&lt;&lt;d1.a;//public继承时 derived class Object只能访问base class的public member //std::cout&lt;&lt;d1.b&lt;&lt;d1.c;//不能访问 //std::cout&lt;&lt;d2.a&lt;&lt;d2.b;//protected继承时 derived class Object不能问访base class的member //std::cout&lt;&lt;d3.a;//private继承时 derived class Object不能问访base class的member return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sstream和strstream的用法]]></title>
    <url>%2F2018%2F01%2F24%2F2018-01-24-1%2F</url>
    <content type="text"><![CDATA[在C++有两种字符串流,也称为数组I/O流，一种在 strstream 中定义，另一种在 sstream 中定义。它们实现的东西基本一样。strstream里包含： 1234class strstreambuf;class istrstream;class ostrstream;class strstream; 它们是基于C类型字符串char*编写的 sstream中包含： 1234class stringbuf;class istringstream;class ostringstream;class stringstream; 它们是基于std::string编写的 因此ostrstream::str()返回的是char*类型的字符串而ostringstream::str()返回的是std::string类型的字符串在使用的时候要注意到二者的区别，一般情况下推荐使用std::string类型的字符串当然如果为了保持和C的兼容，使用strstream也是不错的选择。但要记住一点,strstream虽仍然是C++语言标准的一部分,但已被C++标准宣称为“deprecated”，也就是不再提倡使用了，也说不定以后干粹就没了。 先介绍一下sstream 123456789//strigstream流以空格为边界符,使用其须包含sstream头文件//istringstream 用法istringstream istring;string ss(&quot;ss 8346520&quot;);istring.str(ss);int i=0;string s;istring&gt;&gt;s&gt;&gt;i;cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; 或者 12345istringstream istring(&quot;ss 8346520&quot;);int i=0;string s;istring&gt;&gt;s&gt;&gt;i;cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; 都将打印：s内容是ss,i内容是8346520的结果; 1234567891011//ostringstream 用法string s=&quot;test&quot;;int i=8346520;int j=0;string s1;ostringstream ostring; //不能写成ostringstream ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;cout&lt;&lt;ostring.str()&lt;&lt;endl; //ostring流内保存内容是test 8346520istringstream istring(ostring.str());istring&gt;&gt;s1&gt;&gt;j;//要注意此处的顺序;cout&lt;&lt;s1&lt;&lt;&quot;――――&quot;&lt;&lt;j&lt;&lt;endl; 简单说说strstream:基于数组的类有istrstream、ostrstream和strstream。它们分别用来创建输入、输出和输入／输出流。这些类的基类之一是strstreambuf，它定义了派生类使用的几个底层的具体属性。除了strstreambuf以外，istream也是istrstream的基类。类ostrstream包括了类ostream。strstream也包括了类iostream。所以，所有基于数组的类和“普通”I／O类一样存取相同的成员函数。创建基于数组的输出流要将一个输出流和一个数组关联起来，可使用下列ostream的构造函数：ostrstream ostr（char＊buf，int size，int mode＝ios：：out）；其中，buf是指向数组的指针，该数组接收写入流的字符。数组的长度由参数size确定。缺省时，流以输出方式打开，但也可以将几项或在一起复合为所需的方式（例如，可以包含ios：：app使输出添加在数组中已存在的信息的尾部）。mode的缺省值可以满足大多数的要求。一旦打开了一个基于数组的输出流，所有对这个流的输出就放在数组中。但是，任何输出都不能写到数组的限界之外，任何这种企图都会导致错误。 下面是一个介绍基于数组的输出流的简单程序。 12345678910111213141516#include &lt;iostream&gt;#include &lt;strstream&gt;using namespace std;int main()&#123;int arraysize=50;char *pbuffer=new char[arraysize];ostrstream ostr(pbuffer,arraysize,ios::out);ostr&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot; &quot;;ostr&lt;&lt;99-14&lt;&lt;hex&lt;&lt;&quot; &quot;;ostr.setf(ios::showbase);ostr&lt;&lt;100&lt;&lt;ends; //使用ostrstream输出到流对象的时候,要用ends结束字符串cout&lt;&lt;pbuffer;delete[] pbuffer;return 0;&#125; 使用数组作输入:要将输入流和数组关联起来，可使用下列istrstream的构造函数： 1istrstream istr（char*buf）； 其中，buf是指向数组的指针，该数组作为每次向流输入的字符源。buf所指的数组必须以空结束。空结束符从不从数组中读取。 下面是一个用字符串输入的例子: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;strstream&gt;using namespace std;int main()&#123;const char s[]=&quot;10 Hello 15 12.23 done&quot;;istrstream ins(s);int i;char str[80];float f;//reading： 10 Helloins &gt;&gt;i;ins &gt;&gt;str;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;str&lt;&lt;endl;// reading：f 12.23 done.ins&gt;&gt;i;ins&gt;&gt;f;ins&gt;&gt;str;cout&lt;&lt;hex&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;str;return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>C/C++</tag>
        <tag>STL</tag>
        <tag>字符串流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式练习题集(附答案)]]></title>
    <url>%2F2018%2F01%2F21%2F2018-01-21%2F</url>
    <content type="text"><![CDATA[前言​ 好久到没有去写关于正则表达式的总结了，虽然自己写了一些关于正则表达式的东西。但是 ​ 感觉上对正则表达式还停留在网上查找的阶段，对于大部分的人来说，很难写自己的正则表达式 ​ 对于正则表达式笔者也做过相关的总结。呃，过了一段时间还是模糊了。因此找一些练习题来找 ​ 回自己的记忆。 ​ 需要说明的是这些练习题有的是网上的！ 初级练习​ 1、求非负整数 : ^\d+$ ​ Tips:需要注意的是这个匹配模式为多行模式下进行的 ​ ​ 2、匹配正整数： ^[1-9][1-9][0-9]$ 在网上也有这种写法的 ^[0-9][1-9][0-9]$ ​ 这里截图我也不贴了，前者指能匹配123012这种整数，而后者可以匹配001230。 ​ 取舍就看实际的需要了 ​ 3、非正整数：^(-\d+|(0+))$ ​ 4、负整数：^-[0-9][1-9][0-9]$ ​ 5、整数 ：^-?\d+$ ​ 6、非负浮点数 ：^\d+(.\d+)?$ ​ 7、正浮点数 ：^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ ​ 8、非正浮点数 ：^((-\d+(.\d+)?)|(0+(.0+)?))$ ​ 9、负浮点数：^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ ​ 10、浮点数：^(-?\d+)(.\d+)?$ ​ 11、有数字、26个英文字母组成的字符串：^[A-Za-z0-9]+$ 中级练习​ 1、长度为8-10的用户密码（以字母开头、数字、下划线） ​ ^[a-zA-Z]\w{7,10}$ ​ 2、验证输入只能是汉字 ： ^[\u4e00-\u9fa5]{0,}$ ​ 3、电子邮箱验证：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ ​ 4、URL地址验证：^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ​ 5、电话号码的验证：请参考：http://blog.csdn.net/kiritor/article/details/8733469 ​ 6、简单的身份证号验证：\d{15}|\d{18}$ ​ ………………………… 高级练习​ 1、提取并捕获html标签内容： ​ &lt;a(?: [^&gt;])+href=([^ &gt;])(?: [^&gt;])&gt; ​ ​ &lt;OPTION\s.*?&gt; ​]]></content>
      <categories>
        <category>程序人生</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程]]></title>
    <url>%2F2018%2F01%2F20%2F2018-01-20%2F</url>
    <content type="text"><![CDATA[1.Git简介Git是目前世界上最先进的分布式版本控制系统，在处理各种项目时都十分高效，而且非常的高大上。 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。而且集中式版本控制系统是必须联网才能工作。 Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。 2.Git安装（仅列出在Windows系统下的安装过程）打开Git官网下载安装程序，然后按照默认选项安装即可。 安装完成后，打开Git bash软件，弹出一个类似cmd的命令行窗口，证明安装成功。 安装完成后，需要进行设置，在命令行输入以下代码： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 顾名思义，这是设置你的名字和Email地址。 我们可以查看一下用户名和密码： 12$ git config user.name$ git config user.email 假如我们这时候报错，证明Git的用户名和密码没有配置成功，我们还可以这样做： 在用户主目录下找到 .git 文件夹： 然后打开 config 文件，这是专门用来配置和读取相应的工作环境变量的，在里面加上如图所示内容： 这样也就完成了对Git用户名和邮箱的配置。 3.创建版本库版本库(repository)也叫仓库，可以看做一个目录，这个目录里的所以文件都由Git进行管理，每个文件的修改、删除，Git都能跟踪。 1.选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit //创建一个名叫learngit的空目录$ cd learngit //把learngit设置为当前目录$ pwd //查看当前目录/c/Users/Administrator/learngit 如果使用Windows系统，要保证目录名不包含中文。 2.通过如下命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/Administrator/learngit/.git/ 这样Git就把仓库建好啦，我们可以看到在当前目录下多了一个 .git的目录，这个目录是Git来跟踪管理版本库的。 3.把文件添加到版本库 我们在 learngit 目录下编写一个 readme.txt 文件，内容如下： 12Git is a version control system.Git is free software. (1) 用 git add 命令，把文件添加到仓库： 1$ git add readme.txt 执行以上命令，没有任何显示。 (2) 用 git commit 命令，把文件提交到仓库： 1234$ git commit -m &quot;wrote a readme file&quot; //-m后面输入的是本次提交的说明，可以输入任意内容。[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) //1 file changed：1个文件被改动（新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt内有两行内容） create mode 100644 readme.txt 4.修改文件我们已经成功添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容： 12Git is a distributed version control system.Git is free software. 运行 git status 命令： 1234567$ git status //查看仓库当前的状态On branch masterChanges not staged for commit: //没有文件将要被提交 (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 上面的命令告诉我们，readme.txt 文件被修改过了，但还没有准备提交的修改。 如果我们想知道上次是怎么修改readme.txt 文件的，需要用 git diff 命令： 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system. //这一句是被删掉的+Git is a distributed version control system. //这一句是新添加的 Git is free software. 接下来还是那两步： (1) git add 1$ git add readme.txt 没有任何输出，这时候可以用 git status 查看一下当前仓库状态： 12345$ git statusOn branch masterChanges to be committed: //将要被提交的文件包括 readme.txt (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt (2) git commit 123$ git commit -m &quot;add distributed&quot;[master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 再用 git status 查看一下当前仓库状态： 123$ git statusOn branch masternothing to commit, working tree clean //当前没有需要提交的修改，而且，工作目录是干净的。 5.版本回退如果我们继续对 readme.txt 文件进行修改，改成如下内容： 12Git is a distributed version control system.Git is free software distributed under the GPL. 然后添加并提交： 1234$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 到目前为止，readme.txt 文件一共有三个版本被提交到了 Git 仓库里，我们可以用 git log 命令进行查看： 12345678910111213141516$ git log //查看历史记录commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 我们还可以加上 –pretty=oneline 参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file //一大串数字是 commit id ，而且每个人的都不一样。 好了，现在如果我们想把 readme.txt 文件退回到上一个版本，就可以使用 git reset 命令： 12$ git reset --hard HEAD^ //HEAD表示当前版本，则HEAD^表示上一个版本，那么上上版本就是HEAD^^HEAD is now at e475afc add distributed 这时候用 cat 命令查看一下 readme.txt 的内容： 123$ cat readme.txt //查看 readme.txt 文件的内容Git is a distributed version control system.Git is free software. 果然 readme.txt 文件返回到了上一个版本。 我们现在想要回到最新的版本，还是使用 git reset 命令： 12$ git reset --hard 1094a //这里不能用HEAD而必须使用 commit id ，因为最新版本在之前返回时已经被删除了，1094a就是最新版本的 commit id，可以在之前的代码中查到HEAD is now at 83b0afe append GPL 这时再查看一下 readme.txt 文件内容： 123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，又回到了最新的版本。 6.工作区和暂存区工作区（Working Directory） learngit 文件夹就是一个工作区。 版本库（Repository） 工作区有个隐藏目录 .git ，这个不算工作区，而是 Git 的版本库。 版本库里面的 index(stage) 文件叫暂存区，还有Git为我们自动创建的第一个分支 master ，以及指向 master 的一个指针叫做 HEAD。 前面我们提到过，如果我们想把文件添加到Git里面时，需要分两步： 第一步是用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区。 第二步是用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支。（我们现在只有唯一一个分支 master，所以现在就是往 master 分支上提交更改） 我们可以实践一下： 在 readme.txt 文件中加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后在工作区新建一个 LICENSE 文本文档（任意内容） 使用两次 git add 命令分别把 readme.txt 和 LICENSE 都添加后，可以用 git status 命令查看一下： 1234567$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： 再使用 git commit 命令把暂存区的所有修改提交到分支： 1234$ git commit -m &quot;understand how stage works&quot;[master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 这时候的工作区就是干净的： 123$ git statusOn branch masternothing to commit, working tree clean 这时候版本库就变成了这样： 7.管理修改Git 如此的优秀是因为，Git 跟踪并管理的不是文件，而是修改。 我们对 readme.txt 文件进行修改： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加： 12345678$ git add readme.txt$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# 然后再修改 readme.txt 文件： 12345$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交： 123$ git commit -m &quot;git tracks changes&quot;[master 519219b] git tracks changes 1 file changed, 1 insertion(+) 这时候我们查看一下状态： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以发现，第二次修改并没有被提交。 因为在工作区的第一次修改被放入暂存区，准备提交；而在工作区的第二次修改并没有被放入暂存区，所以， git commit命令只负责把暂存区的修改提交了。 提交后，我们可以用 git diff HEAD – readme.txt 命令去查看工作区和版本库里面最新版本的区别： 1234567891011$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 8.撤销修改假如说你在 readme.txt 文件中添加了一行内容如下： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 最后一行是万万不能让BOSS看到的，应该怎么撤销呢？ (1) 没有 git add 之前 可以手动删除最后一行，手动把文件恢复到上一个版本的状态。然后再用 git checkout – file 命令丢弃工作区的修改： 1$ git checkout -- readme.txt //把readme.txt文件在工作区的修改全部撤销。 现在看一下 readme.txt 文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 果然复原了。 (2) git add了，但没有git commit 这时候的修改添加到了暂存区，但没有提交到分支，用 git status 查看一下： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt 这时候我们可以使用 git reset HEAD file 命令把把暂存区的修改撤销掉，重新放回工作区： 123$ git reset HEAD readme.txt //git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区，HEAD表示最新版本。Unstaged changes after reset:M readme.txt 现在再用 git status 查看一下： 1234567$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt //暂存区是干净的，工作区有修改。 这时候再丢弃工作区的修改就OK了： 12345$ git checkout -- readme.txt //丢弃工作区的修改。$ git statusOn branch masternothing to commit, working tree clean 终于大功告成了。 (3) 既 git add 了，也 git commit 了 可以回退到上一个版本，见回退版本内容。 9.删除文件在工作区即 learngit 文件夹下新建一个 test.txt 文件，并添加和提交到Git： 123456$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 这时候可用 rm 命令删除： 1$ rm test.txt 这时工作区和版本库就不一样了。 现在又分两种情况： (1) 确实要从版本库中删除该文件，那就用 git rm 命令删除，并且 git commit： 1234567$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 这时候文件就从版本库被删除了。 (2) 文件被删错了。因为版本库里有，所以很好恢复： 1$ git checkout -- test.txt //用版本库里的版本替换工作区的版本。 10.远程仓库准备工作在开始这部分之前，我们需要自行注册GitHub账号。而且，因为你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要设置： (1) 创建SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有的话，看此目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有，直接跳到下一步。如果没有，打开Git Bash，创建SSH (2) 登陆GitHub，打开”Account settings” 然后点击”Add SSH and GPG Keys”，再点击”New SSH Key”进行SSH Key 的创建，填上任意 Title ，把 id_rsa.pub 中的内容复制到Key文本框内： 11.添加远程库现在我们已经在本地创建了一个Git仓库了，又想在GitHub上创建一个Git仓库，然后让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那么我们应该怎么做呢？ 首先，登陆GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入 test（因为我已经创建完成了，所以提示此用户名存在）其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 如上图所示我已经把本地仓库的内容推送到了GitHub上了，大家创建完以后应该是一个空的仓库。这时候我们可以在本地tset仓库下运行命令： 1$ git remote add origin git@github.com:qian-youyou/test.git //“qian-youyou”是我的GitHub的账户名，你需要填写你自己的账户名 添加后，远程库的名字就是 origin ，这是Git默认的叫法。 然后，我们就可以把本地库的所有内容推送到远程库上： 12345678910$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:RFHzhj/learngit.git * [new branch] master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 使用 git push 命令，就是把当前分支 master 推送到远程。 因为远程库是空的，所以我们在第一次推送 master 分支时，要加上 -u 参数，Git不但会把本地的master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地 master 分支的最新修改推送至GitHub。现在，我们拥有了真正的分布式版本库。 12.从远程库克隆我们的学习过程是先有了本地库，后有了远程库，然后再对远程库进行关联。 其实，我们大部分时候是先创建远程库，然后再从远程库克隆。]]></content>
      <categories>
        <category>程序人生</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦的索引]]></title>
    <url>%2F2017%2F05%2F20%2F2017-05-20%2F</url>
    <content type="text"><![CDATA[梦的索引 浅悠悠 5.20 to.** (从此，某人不理我) 一 风，轻拢着寒衣， 愁云，悄然漫入天际。 夜，显得如此孤寂。 寂静，淹没了每一个字节， 而我，沉浸在如梦般的程序。 不妨覆盖这寂寞的夜色， 将整个世界虚拟。 二 调用一个time函数， 永不熄灭的星空由我来设计。 早晨迎接春的花香， 午后拥抱夏的暖阳， 黄昏品尝秋的硕果， 静夜寻觅冬的足迹。 四季以奇幻的循环交替。 三 调用一个process函数， 柏拉图的理想国由我来开辟。 辽阔的天空一碧如洗， 雄鹰与黄鹂整齐地共鸣， 城市以和谐的进程刷新， 物竞天择已被仁爱更替。 世界如蒲公英般无忧无虑。 四 再定义一个爱你的函数， 永恒是爱的生命周期。 星空因你而努力闪耀， 四季因你而相伴朝夕， 花儿酿香渲染着你的气息， 阳光拂晓映射着你的甜蜜。 在这个世界里， 你是唯一的主题。 五 我将自己作为参数， 向爱你的函数传递， 却意外发现你并不在我的域。 我开始不断重载爱的定义， 将你我的变量封存在同一结构体。 但很快系统出现了bug。 当进程陷入死循环时， 才发现此算法不可逆。 六 也许你已在我的世界 永远赋上了静态的属性。 系统不断将思念返回压入我的堆栈， 而我的内存此刻已满满是你。 我向系统申请最后一点内存， 打开心的端口监听你的信息， 返回却总是操作失败的消息。 七 我想重写爱的模板， 再一次将爱传递， 却无法返回你也爱我的信息。 我试图虚拟出最后一点内存， 将“你爱我吗”的字符串压入栈尾， 打开最后的端口传递给你。 八 倘若返回值为真， 我愿释放掉整个世界的内存， 从此只储存关于你的回忆。 否则我愿析构自己， 将所有的喜怒哀乐封进内域。 从此不需要让你知道， 我一直爱你。 九 此端，彼岸， 谁在孤独地将二叉树上的结点遍历？ 谁苦苦寻找连接着爱的网络服务器？ 虚拟，现实， 我是茫茫内存中哪一个孤独的进程？ 又是匆匆人海里哪一个寻梦的躯体？ 十 我能编译出整个世界， 却无法虚拟真实的你。 爱的程序， 也解不开你我的局。 也许程序注定是梦， 而你， 永远是我梦的索引。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丽日芳馨]]></title>
    <url>%2F2017%2F05%2F11%2F2017-05-11%2F</url>
    <content type="text"><![CDATA[映日清风浴春蕾，萋萋谁解芳草馨。 蝶羽蹁跹花儿醉，野韵泊然守天浔。 春风化雨蝶双去，冷月袭风蕊浸淋。 愁霖散尽曙光见，一片清新护花魂。 （本来是写给方大仙的，然后就误会了，方大仙再也没理过我。唉，从此江郎才尽。不过至少曾经我一直在像她学习）]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绛影流风]]></title>
    <url>%2F2016%2F12%2F09%2F2016-12-09%2F</url>
    <content type="text"><![CDATA[红尘滚滚浸离情，泪眼朦胧残月明。 乍见羲和乘风耀，一笑淡然气自雄。 流飞翰墨升丹气，朗润丹青贯玉虹。 愿效流风倾岁月，何人与我竞峥嵘。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雪韵]]></title>
    <url>%2F2016%2F11%2F23%2F2016-11-23%2F</url>
    <content type="text"><![CDATA[霞霄铸雪竟蹁跹，荡入苍穹冻川峦。 乾坤万里皆悸颤，日恼月愧不胜寒。 借得阳煦三分暖，化作凌霜戏犂元。 莫道冰心无暖意，且看清洁满人间。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[踏莎行·缘归梦]]></title>
    <url>%2F2016%2F10%2F13%2F2016-10-13%2F</url>
    <content type="text"><![CDATA[晨曦送暖，莺韵翩跹，桃花春风共缠绵。 笑靥倾墨润青笺，无悔牵绊话尘缘。 暮色如烟，花落无言，江水未竭浸桑田。 梦里飞花随风远，空留一诺伴心眠。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长相思·空城]]></title>
    <url>%2F2016%2F09%2F15%2F2016-09-15%2F</url>
    <content type="text"><![CDATA[秋谧静，月朦胧， 中秋晚月浸空城。城涌人匆匆。 人味浓，情味空， 万径同归意难融。双袖迎清风。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六字令]]></title>
    <url>%2F2016%2F09%2F11%2F2016-09-11%2F</url>
    <content type="text"><![CDATA[琴，一曲弦歌揽客心。曲终尽，何处觅知音。 棋，黑白博弈方寸迷。红尘局，进退两迷离。 书，满腹离愁一纸出。皆归寂，墨韵话孤独。 画，妙笔浸润满庭花。花易落，秀色映谁家。 诗，相思化作墨中痴。声声慢，平仄为谁织。 酒，彼时笑靥遵底留。断肠人，独酌夜无休。 花，群芳争艳恋春霞。秋风起，流水逝芳华。 茶，一叶清香静繁华。淳意散，花叶隔天涯。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一剪梅·尘埃]]></title>
    <url>%2F2016%2F07%2F12%2F2016-07-12%2F</url>
    <content type="text"><![CDATA[风起流尘自轻狂，翛然而往，孑然飘扬。 奈何落地满凄凉，天也苍苍，路也茫茫。 泪浸尘埃人断肠，烟隐轩窗，人隐何方？ 莫如引歌醉残阳，一曲新词，笑尽沧桑。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参商永离]]></title>
    <url>%2F2016%2F06%2F20%2F2016-06-20%2F</url>
    <content type="text"><![CDATA[白首双星寄麒麟， 只是相觅恰黄昏。 夕阳有意聚离人， 冷月无情散星辰。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六字令]]></title>
    <url>%2F2016%2F05%2F21%2F2016-05-21%2F</url>
    <content type="text"><![CDATA[棉，细雨蒙蒙润娇颜，风飘絮，离絮苦缠绵。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云行在天]]></title>
    <url>%2F2016%2F04%2F26%2F2016-04-26%2F</url>
    <content type="text"><![CDATA[玄霄蔽月百生愁， 星海云游榆光羞。 御风万里乾坤尽， 谁人与我竞风流？]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情茧]]></title>
    <url>%2F2016%2F03%2F28%2F2016-03-28%2F</url>
    <content type="text"><![CDATA[残阳月掩掠青笺，青笺墨泣染长夜。 长夜辗转盼天明，天明又患残阳浅。 今宵又惊昨日梦，梦里飞花舞翩跹。 落英片片蝶成茧，为孰憔悴为孰残。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西江月·蝶双飞]]></title>
    <url>%2F2016%2F02%2F14%2F2016-02-14%2F</url>
    <content type="text"><![CDATA[华灯逐日争明，烟花伴月共辉。身隔千里心相随，胜过瑶池相会。今夕天涯独行，明夕伴君同归。风雨缠绵蝶双飞，换得此生无悔。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长相思·寄云梦]]></title>
    <url>%2F2016%2F02%2F08%2F2016-02-08%2F</url>
    <content type="text"><![CDATA[风萧萧， 雨萧萧， 风雨同程伴君老， 奈何山水遥。 云悄悄， 梦悄悄， 行云织梦芳踪渺， 梦里相思扰。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词穷墨尽]]></title>
    <url>%2F2016%2F01%2F28%2F2016-01-28%2F</url>
    <content type="text"><![CDATA[词叹墨尽难续情， 墨笑词穷一场空。 风润墨痕惊旧梦， 伊人随梦泪随风。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心泪无痕]]></title>
    <url>%2F2016%2F01%2F08%2F2016-01-08%2F</url>
    <content type="text"><![CDATA[瑟瑟寒风眷高楼， 街明巷寂夜悠悠。 独倚寒窗忆旧梦， 痴笑不觉心泪流。 青丝悄然落眉头， 欲笺新词只剩愁。 满腹情思何处寄？ 唯有黯然藏心头。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦里飞花]]></title>
    <url>%2F2015%2F12%2F27%2F2015-12-27%2F</url>
    <content type="text"><![CDATA[梦里飞花 浅悠悠 梨花点点， 琴瑟缓缓。 谁把情话， 浸润成芽？ …… 繁花艳艳， 诗意绵绵。 谁把韶光， 谱写成夏？ …… 黄花依依， 棋子稀稀。 谁把芳华， 飘落成砂？ …… 雪花凄凄， 画笔寂寂。 谁把青丝， 染成白发？ …… 梦里飞花， 孑然自暇。 谁的牵挂， 散尽天涯。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冲高]]></title>
    <url>%2F2015%2F12%2F19%2F2015-12-19%2F</url>
    <content type="text"><![CDATA[凌云雄鹰击红日，悬崖欲起先折翅； 梧桐枝头重生凤，涅槃之时浴火噬； 不经雨困长风袭，怎显鸿鹄冲天势； 孰敢与天试比高？且看我辈腾飞时。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冰清]]></title>
    <url>%2F2015%2F11%2F20%2F2015-11-20%2F</url>
    <content type="text"><![CDATA[霜飘雪绵竞翩跹， 巧借寒气铸玉颜。 冷面洁骨身如镜， 笑看浮云舞成眠。 栖居严冬梅相伴， 不与浑水染尘烟。 岂是冰蕊无情意？ 因守清纯在人间。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沁园春·约定]]></title>
    <url>%2F2015%2F11%2F07%2F2015-11-07%2F</url>
    <content type="text"><![CDATA[一日倾心，百日梦萦，终日魂销。 叹忆中所思，芳踪飘渺，梦中所念，素裹妖娆。 一向情深，奈何缘浅，咫尺之川万里遥。 平生意，化双飞双宿，共度花朝。 西风锐利如刀，惟连理双枝紧缠绕。 看风吹雾散，雨驻清涟。海誓山盟，怎能风飘。 山重水复，柳暗花明，一叶轻舟过险涛。 天涯路，愿青骢共骑，轻揽子腰。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鹧鸪天·断肠人]]></title>
    <url>%2F2015%2F10%2F31%2F2015-10-31%2F</url>
    <content type="text"><![CDATA[风袭青枝花欲坠，青枝倾尽心中累。 长恨残风戏嫩蕊，此身无力空心碎。 词中意，曲中悲。哀弦危柱有谁醉？ 潇潇冷雨送寒归，点滴皆是离人泪。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦·曲]]></title>
    <url>%2F2015%2F10%2F21%2F2015-10-21%2F</url>
    <content type="text"><![CDATA[夜轻轻舞动着寒衣， 风放纵着月色般的音律。 指尖轻触着跳动的音符， 在轻快的乐曲中将双目微闭。 …… 曲中回荡着少年悠扬的乐音， 陪伴着少女轻盈的笑语。 琴声轻拂着清脆的鸟鸣， 与你我一起赞美这自由的天地。 …… 风儿为这祥和的音符歌唱， 雨点为这宁静的四季舞动， 悠闲的人们不再追名逐利， 星星在你我怀中无忧的睡去。 …… 我没有那演绎梦境的曲， 只有一把弹奏孤独的琴。 漫天繁星早已没了踪迹， 只留下忧郁的孩子沉醉在梦里……]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遥光]]></title>
    <url>%2F2015%2F10%2F14%2F2015-10-14%2F</url>
    <content type="text"><![CDATA[日逐朝霞去昨痕， 轻抚晨光盼伊人。 繁星带月匆匆过， 只盼芳踪梦里寻。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月隐风轻]]></title>
    <url>%2F2015%2F09%2F27%2F2015-09-27%2F</url>
    <content type="text"><![CDATA[风暖寒霜月无踪， 惟有孤夜伴秋风。 纵使秋风解我意， 旧愁吹去新愁生。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鹊桥仙·一眼万年]]></title>
    <url>%2F2015%2F08%2F20%2F2015-08-20%2F</url>
    <content type="text"><![CDATA[双星作合， 金风玉露， 朗月惹得谁羡。 悠悠天上一光年， 隔不断、深情一眼。 丝落无声， 天涯遥望， 织云又忆初见。 依依心上一瞬间， 便无悔、挚爱万年。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蝶恋花·相思字]]></title>
    <url>%2F2015%2F08%2F14%2F2015-08-14%2F</url>
    <content type="text"><![CDATA[秋风落尽花憔悴， 蝶欲起舞， 只怜茧中愧。 共饮青春赋一醉， 却叹聚散最心累。 此刻相思赋予谁， 彼时笑语， 漫天随风归。 失散绝句谁轻吟， 空弹高山对流水。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>诗集</tag>
      </tags>
  </entry>
</search>
