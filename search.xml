<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）]]></title>
    <url>%2F2018%2F05%2F01%2F2018-05-01%2F</url>
    <content type="text"><![CDATA[今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。 Walking in the Forest （最大值最小化例题）题目描述 It’s universally acknowledged that there’re innumerable trees in the campus of HUST. Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step. 输入描述:12The first line contains two integer N and K as described above.Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone. 输出描述:1An integer, the minimum distance of the largest step. 示例1 输入126 31 3 2 2 5 输出15 题意： 有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。 题解： 典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;long long a[100010];int n, k;bool check(long long ld,long long rd,long long mind) &#123; long long cnt = 0; int stemp = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (cnt + a[i] &lt;= mind) &#123; cnt += a[i]; &#125; else &#123; cnt = a[i]; stemp++; &#125; if (stemp &gt; k) return false; &#125; if (stemp &lt;= k) return true; return false;&#125;int main() &#123; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123; long long maxn = 0, sumn = 0; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); sumn += a[i]; if (maxn &lt; a[i]) maxn = a[i]; &#125; long long ld = maxn; long long rd = sumn; long long mind = (ld + rd) / 2; while (ld &lt;= rd) &#123; bool flag = check(ld, rd, mind); if (!flag) &#123; ld = mind + 1; mind = (ld + rd) / 2; &#125; else &#123; rd = mind - 1; mind = (ld + rd) / 2; &#125; &#125; printf(&quot;%lld\n&quot;, ld); &#125; return 0;&#125; POJ2456疯牛 （最小值最大化例题）时间限制：1000 ms | 内存限制：65535 KB 难度：4 描述 农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入5 312849样例输出3 题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。 题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int v[100005]; int n, c; int check(int d) &#123; int tmp = v[0], cnt = 1; for (int i = 1; i &lt; n; i++) &#123; if (v[i] - tmp &gt;= d) &#123; cnt++; tmp = v[i]; &#125; &#125; if (cnt &gt;= c) return 1; return 0; &#125; int main() &#123; while (cin &gt;&gt; n &gt;&gt; c) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i]; sort(v, v + n); int l = 0, r = v[n - 1], mid; while (l &lt;= r) &#123; mid = (l + r) / 2; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; printf(&quot;%d\n&quot;, r); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解]]></title>
    <url>%2F2018%2F04%2F29%2F2018-04-29%2F</url>
    <content type="text"><![CDATA[4月29日，13:30-18:30，浙江大学程序设计校赛 A-Peak题意： 有一串数字，问这串数字是否符合以下情况： 存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。 题解： 水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。 B - King of Karaoke题意： 两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k 题解： 只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。 D - Sequence Swapping Time Limit: 1 Second Memory Limit: 65536 KB BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element in the pair is an integer. As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if , ‘(‘ and ‘)’. BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get? InputThere are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains an integer (), indicating the length of the sequence. The second line contains a string () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above. The third line contains integers (). Their meanings are described above. It’s guaranteed that the sum of of all test cases will not exceed . OutputFor each test case output one line containing one integer, indicating the maximum possible score BaoBao can get. Sample Input1234567891011121346)())()1 3 5 -1 3 26)())()1 3 5 -100 3 23())1 -1 -13())-1 -1 -1 Sample Output1234242102 HintFor the first sample test case, the optimal strategy is to select in order. For the second sample test case, the optimal strategy is to select in order. 题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。 题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即curweight[i]。否则将cur和curweight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;stack&gt;using namespace std;struct node &#123; int cur; int cnt;&#125;;char str[1010];int wei[1010];int main() &#123; int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%s&quot;, &amp;n, str); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;wei[i]); &#125; stack&lt;node&gt;st; int sum = 0; int cur = 0; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (str[i] == &apos;(&apos;) &#123; if (cur == 0) &#123; cur = wei[i]; &#125; else if (abs(cur) &lt; abs(cur + wei[i])) &#123; cur = cur + wei[i]; &#125; else &#123; cur = wei[i]; &#125; &#125; else if (str[i] == &apos;)&apos;) &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123; cnt = 0; do &#123; cur += st.top().cur; cnt += st.top().cnt; st.pop(); &#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]); sum += cur*wei[i] + cnt; &#125; else if (cur*wei[i] &gt; 0) &#123; sum += wei[i] * cur; &#125; else &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123; cur += st.top().cur; sum += cur*wei[i] + st.top().cnt; st.pop(); &#125; else &#123; if (!cur&amp;&amp;!st.empty()) &#123; st.top().cnt += st.top().cur*wei[i]; &#125; else &#123; node tmp; tmp.cnt = cur*wei[i]; tmp.cur = cur; st.push(tmp); cur = 0; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125; J - CONTINUE…? Time Limit: 1 Second Memory Limit: 65536 KB Special Judge DreamGrid has classmates numbered from to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has gems. DreamGrid would like to divide the classmates into four groups , , and such that: Each classmate belongs to exactly one group. Both and consist only of girls. Both and consist only of boys. The total number of gems in and is equal to the total number of gems in and . Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty. InputThere are multiple test cases. The first line of input is an integer indicating the number of test cases. For each test case: The first line contains an integer () – the number of classmates. The second line contains a string () consisting of 0 and 1. Let be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl. It is guaranteed that the sum of all does not exceed . OutputFor each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead. Sample Input123456789101151121031014000071101001 Sample Output12345-1-131412213413214 题意： 有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可） 题解： 看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;int a[100010], vis[100010];using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); long long int sum = 0, half = 0; while (t--) &#123; int n; sum = 0; scanf(&quot;%d&quot;, &amp;n); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%1d&quot;, &amp;a[i]); sum += i + 1; &#125; if (sum % 2 != 0) &#123; printf(&quot;-1\n&quot;); continue; &#125; else half = sum / 2; sum = 0; for (int i = n; i &gt; 0; i--) &#123; if (sum + i &lt;= half) &#123; sum += i; vis[i - 1] = 1; if (sum == half) break; else if (half - sum &lt; i) &#123; vis[half - sum - 1] = 1; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i]) &#123; if (vis[i]) printf(&quot;3&quot;); else printf(&quot;4&quot;); &#125; else if (!a[i]) &#123; if (vis[i]) printf(&quot;1&quot;); else printf(&quot;2&quot;); &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; L - Doki Doki Literature Club Time Limit: 1 Second Memory Limit: 65536 KB Doki Doki Literature Club! is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story! A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words. The poem writing mini-game (from wikipedia) BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of words is nothing more than a sequence of strings, and the happiness of Sayori after reading the poem is calculated by the formula Given a list of words and Sayori’s preference to each word, please help BaoBao select words from the list and finish the poem with these words to maximize the happiness of Sayori. Please note that each word can be used at most once! InputThere are multiple test cases. The first line of input contains an integer (about 100), indicating the number of test cases. For each test case: The first line contains two integers and (), indicating the number of words and the length of the poem. For the following lines, the -th line contains a string consisting of lowercased English letters () and an integer (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that for all . OutputFor each test case output one line containing an integer and strings separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one. Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect! A sequence of strings is lexicographically smaller than another sequence of strings , if there exists a () such that for all and is lexicographically smaller than . A string is lexicographically smaller than another string , if there exists a () such that for all and , or for all and . Sample Input1234567891011121314151617181920212223242526410 8hello 0world 0behind 0far 1be 2spring 10can 15comes 20winter 25if 2005 5collegiate 0programming -5zhejiang 10provincial 5contest -453 2bcda 1bcd 1bbbbb 13 2a 1aa 1aaa 1 Sample Output12342018 if winter comes can spring be far behind15 zhejiang provincial collegiate programming contest3 bbbbb bcd3 a aa 题意： 有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。 题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。 代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node&#123; string str; long long int weight;&#125;;node level[110];bool cmp(node a,node b) &#123; if (a.weight != b.weight) return a.weight &gt; b.weight; else &#123; return a.str &lt; b.str; &#125;&#125;int main() &#123; int t, n, m; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; long long int h = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; level[i].str &gt;&gt; level[i].weight; &#125; sort(level, level + n, cmp); for (int i = m; i &gt; 0; i--) h += level[m - i].weight*i; printf(&quot;%lld &quot;, h); for (int i = 0; i &lt; m - 1; i++) cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;; cout &lt;&lt; level[m - 1].str &lt;&lt; endl; &#125; return 0;&#125; K - Lucky 7给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。 题解： 每输入一个数直接进行判断即可。]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(高级篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-3%2F</url>
    <content type="text"><![CDATA[由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(进阶篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-2%2F</url>
    <content type="text"><![CDATA[本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。 基本流程1.安装主题 2.启用主题 3.验证主题 4.设置语言 5.设置菜单 6.侧栏设置 7.尾栏设置 8.附页 安装主题在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 即可获取最新版主题，后续更新只需输入指令： 1git pull 启用主题在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next 1theme: next 注意中间有空格。到此，NexT 主题安装完成。 验证主题在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 1hexo clean 首先启动 Hexo 本地站点，并开启调试模式，整个命令是 1hexo s 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000/。 如果端口号被占用还是得先修改端口号，然后启动服务。即先输入 1hexo server -p 5000 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:5000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:5000/。 完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是： Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 双栏Scheme，简约淡雅的风尚 注释 # 即可。 以Pisce为例，选择 Pisce Scheme 设置语言在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文） 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定实例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id 设置菜单菜单栏设置菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。 12345678menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 添加标签，分类添加标签页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面 1hexo new page tags 在新建的index.md文件中添加type: “tags” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 添加分类页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面 1hexo new page categories 在新建的index.md文件中添加type: “categories” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。 添加关于我页面，步骤和以上差不多 在新建的index.md文件中添加内容 侧栏设置设置侧栏位置，修改主题目录下sidebar的position值 设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 尾栏设置修改底部的官方logo，找到 \themes\next\layout\_partials\下面的footer.swig文件，打开会发现，如下的语句： 第一个框 是下面侧栏的“日期❤ XXX” 如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可） 看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 附页站点配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 浅悠悠的个人博客 #网站标题subtitle: 。。。 #网站副标题description: 。。。 #网站描述author: 王骏 #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有)# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/imwillxue/imwillxue.github.com.git branch: master 主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat: #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客（基础篇）]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-1%2F</url>
    <content type="text"><![CDATA[以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程： 基本流程：1.搭建前的准备（包括node.js，git，github账户的配置） 2.安装hexo 3.配置hexo 4.连接hexo与github page 5.发布文章 搭建前的准备1.安装node.js 2.安装git 3.github账户管理 配置Node.js下载node.js。根据自己电脑的配置自行安装。 安装完成后打开终端输入： 12node -vnpm -v 进行是否安装成功测试。如不正确，回头检查哪一步错误。 配置Gitgit官网。自行安装。 安装完成后打开终端输入： 1git --version 以上步骤进行是否安装成功。如果安装失败自行面壁。 github管理已拥有账号可跳过注册此步 打开github进行注册。 登录后点击右上角加号，选择New repository新建代码库。 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。 注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io 建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 安装hexo在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹 在命令行输入 1npm install hexo -g //进行安装 输入 1hexo -v //检验是否安装成功。 配置hexo输入 1hexo init //初始化该文件夹 看到后面的“Start blogging with Hexo！”证明正在执行。 输入 1npm install //安装所需要的组件 输入 1hexo g //生成 输入 1hexo s 开启服务器，访问该网址，正式体验Hexo 连接hexo与github page设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容 输入ssh-keygen -t rsa -C “xxxxxx@xx.com”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 发布文章新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 当然你也可以执行下面的命令，相当于上面两条命令的效果 1hexo g -d //在部署前先生成 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。 到此为止，最基本的也是最全面的hexo+github搭建博客完结。]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to My Blog! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server11$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言打造智能AI小游戏——三子棋]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22%2F</url>
    <content type="text"><![CDATA[三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3][3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。例如没有走时，9个格的权值为： [][][] 3 2 3 [][][] 2 4 2 [][][] 3 2 3 角落有横竖斜三种获胜方法，边有横竖两种方法，中心有横竖两斜4种方法。假如某格有X阻挡，那么权值会相应变化，例如 [][][] 2 1 2 []X[] 1 0 1 [][][] 2 1 2 由于有中心阻挡，那么角只有横竖两种方法赢，因此权值为2。但该AI还需继续优化。例如以下： []X[] 1 0 1 []0[] 1 0 2 XX0 0 0 0 AI面对这种情况，本来下在第一个格子就赢了，但他会选择权值为2的格子。因此我们可以在现有权值条件的情况下，在附加个权值。假如某一格子的路线上已经有AI的子了，那么该条路线上未落子的所有格子权值再加1，如果有两个已落子的AI格子权值就加2。例如以下情况： ​ 原权值 优化权值 []X[] 2 0 2 5 0 3 []0[] 2 0 2 3 0 4 []X0 2 0 0 3 0 0 第一个格子5是由于斜路线上有两个子，那在原有的基础2上先加1，再加2，所以权值为2+1+2。第2行第3列权值为4，因为横竖两条路线均有1个子，因此权值为2+1+1，其余格子路线上均有1个子，因此权值为2+1。这样落在权值5那个格子上AI就赢了。 但是仅仅这些判断是不够的。例如： ​ 初始 优化 X[]X 0 1 0 0 2 0 []0[] 1 0 1 2 0 2 [][]0 1 2 0 2 4 0 AI会选择权值为4的格子。那此时AI选择权值为2的格子时，你只需要走一步就赢了，AI就输了，因此该AI算法还得继续。 那么AI可以逆向思考一番，AI可以考虑一下当前情况在计算AI权值的同时再计算一次我们的权值。例如上面例子： ​ AI权值 你的权值 优化AI 优化你 X[]X 0 1 0 0 1 0 0 2 0 0 4 0 []0[] 1 0 1 1 0 0 2 0 2 2 0 0 [][]0 1 2 0 1 0 0 2 4 0 2 0 0 我们把两个权值相加（另外把AI的权值应该再加1，因为AI判断赢要优先于输或平，假如AI方有权值大的，代表一步能赢的，我方也有这种情况，那相加权值相同，AI既可以选择赢棋那一格，也可以选择堵你将要赢的那一格。但AI判断赢要优先于堵对方赢。例子就不举了）： ​ 相加权值 再加1权值 X[]X 0 6 0 0 7 0 []0[] 4 0 2 5 0 3 [][]0 4 4 0 5 4 0 因此AI判断到这里就会堵你了。 AI算法就介绍到这里，至于三子棋程序，由于过于简单，就不过多介绍了。主要介绍AI思想，Windows系统编译的程序。如果是Linux需要把以下代码改下。接下来我就贴上代码，供参考，如有不懂欢迎留言。 project.h 12345678910111213141516#pragma once #define COLUMN 3 #define ROW 3 #define GOON 0 #define WIN -1 #define DEFEAT 1 void init(char(*MAP)[COLUMN]); int victory(char(*MAP)[COLUMN]); bool check(char(*MAP)[COLUMN]); void show(char(*MAP)[COLUMN]); void check_stemp(char(*MAP)[COLUMN], int *x, int *y); void ai_auto(char(*MAP)[COLUMN]); int menu(); int first_hand(char(*MAP)[COLUMN]); int ai_hand(char(*MAP)[COLUMN]); void play(char(*MAP)[COLUMN]); project.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&quot;project.h&quot; int vis[ROW][COLUMN]; int weight[ROW][COLUMN]; int x, y; void init(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) &#123; MAP[i][j] = &apos; &apos;; vis[i][j] = 0; &#125; &#125; int victory(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] == &apos;X&apos;&amp;&amp;MAP[i][1] == &apos;X&apos;&amp;&amp;MAP[i][2] == &apos;X&apos;) return WIN; else if (MAP[i][0] == &apos;O&apos;&amp;&amp;MAP[i][1] == &apos;O&apos;&amp;&amp;MAP[i][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][i] == &apos;X&apos;&amp;&amp;MAP[1][i] == &apos;X&apos;&amp;&amp;MAP[2][i] == &apos;X&apos;) return WIN; else if (MAP[0][i] == &apos;O&apos;&amp;&amp;MAP[1][i] == &apos;O&apos;&amp;&amp;MAP[2][i] == &apos;O&apos;) return DEFEAT; &#125; if (MAP[0][0] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][2] == &apos;X&apos;) return WIN; else if (MAP[0][0] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][2] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][0] == &apos;X&apos;) return WIN; else if (MAP[0][2] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][0] == &apos;O&apos;) return DEFEAT; return GOON; &#125; bool check(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) if (!vis[i][j]) return false; return true; &#125; void show(char(*MAP)[COLUMN]) &#123; printf(&quot;-------------\n&quot;); for (int i = 0; i &lt; ROW; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt; COLUMN; j++) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; printf(&quot;\n&quot;); printf(&quot;-------------\n&quot;); &#125; &#125; void check_stemp(char(*MAP)[COLUMN], int *x, int *y) &#123; while (*x &gt; 3 || *x &lt;= 0 || *y&gt;3 || *y &lt;= 0 || MAP[*y - 1][*x - 1] != &apos; &apos;) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Input error, please reenter!\n&quot;); scanf(&quot;%d%d&quot;, x, y); &#125; MAP[*y - 1][*x - 1] = &apos;X&apos;; vis[*y - 1][*x - 1] = 1; &#125; void Empowerment(char(*MAP)[COLUMN], int(*weight)[COLUMN], char ai_X, char ai_0, int flag) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] != ai_X&amp;&amp;MAP[i][1] != ai_X&amp;&amp;MAP[i][2] != ai_X) &#123; weight[i][0]++; weight[i][1]++; weight[i][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[i][j] == ai_0) &#123; weight[i][0] += tmp+flag; weight[i][1] += tmp+flag; weight[i][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][i] != ai_X&amp;&amp;MAP[1][i] != ai_X&amp;&amp;MAP[2][i] != ai_X) &#123; weight[0][i]++; weight[1][i]++; weight[2][i]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][i] == ai_0) &#123; weight[0][i] += tmp+flag; weight[1][i] += tmp+flag; weight[2][i] += tmp+flag; tmp += 10; &#125; &#125; &#125; if (MAP[0][0] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][2] != ai_X) &#123; weight[0][0]++; weight[1][1]++; weight[2][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][j] == ai_0) &#123; weight[0][0] += tmp+flag; weight[1][1] += tmp+flag; weight[2][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][2] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][0] != ai_X) &#123; weight[0][2]++; weight[1][1]++; weight[2][0]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][2 - j] == ai_0) &#123; weight[0][2] += tmp+flag; weight[1][1] += tmp+flag; weight[2][0] += tmp+flag; tmp += 10; &#125; &#125; &#125; void ai_auto(char(*MAP)[COLUMN]) &#123; int weight[3][3] = &#123; 0 &#125;; Empowerment(MAP, weight, &apos;X&apos;, &apos;O&apos;, 1); Empowerment(MAP, weight, &apos;O&apos;, &apos;X&apos;, 0); int maxn = -1; int maxm = -1; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) &#123; if (vis[i][j]) weight[i][j] = -1; if (maxn &lt; weight[i][j]) &#123; maxn = weight[i][j]; maxm = i * 3 + j; &#125; &#125; MAP[maxm / 3][maxm % 3] = &apos;O&apos;; vis[maxm / 3][maxm % 3] = 1; &#125; int menu() &#123; int tmp; printf(&quot;*************************************************************\n&quot;); printf(&quot;* Please enter: * 1:First hand * 2.Back hand * Others:Close *\n&quot;); printf(&quot;*************************************************************\n&quot;); scanf(&quot;%d&quot;, &amp;tmp); return tmp; &#125; int first_hand(char(*MAP)[COLUMN]) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Please enter:x y\n&quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); check_stemp(MAP, &amp;x, &amp;y); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == WIN) &#123; printf(&quot;Congratulations on your victory, you are as smart as Qianyouyou.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; system(&quot;pause&quot;); return 0; &#125; int ai_hand(char(*MAP)[COLUMN]) &#123; ai_auto(MAP); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == DEFEAT) &#123; printf(&quot;You lose, you&apos;re as stupid as a pig.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; return 0; &#125; void play(char(*MAP)[COLUMN]) &#123; while (!check(MAP) || victory(MAP) == GOON) &#123; if (first_hand(MAP)) break; if (ai_hand(MAP)) break; &#125; system(&quot;pause&quot;); &#125; main.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&quot;project.h&quot; char MAP[ROW][COLUMN]; int main() &#123; char str[2]; do &#123; init(MAP); switch (menu()) &#123; case 1: first_hand(MAP); case 2: &#123; ai_hand(MAP); play(MAP); &#125; default: &#123; printf(&quot;Do you need to start again?(Y/N)&quot;); scanf(&quot;%s&quot;, str); &#125;break; &#125; &#125; while (str[0] == &apos;Y&apos; || str[0] == &apos;y&apos;); printf(&quot;Thank you for using!\n&quot;); system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>博弈论</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言实现小游戏——控制台扫雷]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-3%2F</url>
    <content type="text"><![CDATA[程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌。此处用到了dfs。仅供参考。 项目版： mine.h 1234567#pragma once #define BOOM 10 #define SIZE 10 void init(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b);//初始化扫雷页面void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j);//如果展开面为0，通过深搜将周围所以为0的区域展开 int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//判断胜利条件 void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//展示扫雷页面 mine.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; int stemp[8][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123; 1,1 &#125;,&#123; -1,-1 &#125;,&#123; 1,-1 &#125;,&#123; -1,1 &#125; &#125;;//深搜时上下左右四个方向搜索 void init(char (*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(MAP, visit, i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(MAP, visit, x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y;//坐标 int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(MAP, visit, x, y); scanf(&quot;%d%d&quot;, &amp;y, &amp;x); init(MAP,visit, x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;y, &amp;x); int res = check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125; 另附原始版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #define BOOM 10 #define SIZE 10 char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y; int stemp[8][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;, &#123;-1,1&#125; &#125;; void init(int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check() &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show() &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); init(x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(); system(&quot;cls&quot;); show(); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int res = check(); system(&quot;cls&quot;); show(); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现随机生成数独九宫格]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-2%2F</url>
    <content type="text"><![CDATA[一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; void main() &#123; int a[9][9] = &#123; 0 &#125;; int *p[3][3], *m[3][6], *n[3][6], *r[9][4], *aa[9][9]; int **q[9]; int i, j, k, l, h, t, s = 0; void rank(int *x, int *y); bool check(int a[9][9], int n); srand((int)time(0)); for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 3; j++) p[i][j] = &amp;a[i * 3 + 1][j * 3 + 1]; for (k = 0; k &lt; 9; k++) q[k] = &amp;p[k / 3][k % 3]; for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; m[i][j] = &amp;a[i * 3 + 1][2 * j - j / 2]; n[i][j] = &amp;a[2 * j - j / 2][i * 3 + 1]; &#125; for (k = 0; k &lt; 9; k++) for (l = 0; l &lt; 4; l++) r[k][l] = &amp;a[(k / 3) * 3 + (l / 2) * 2][(k % 3) * 3 + (l % 2) * 2]; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) aa[i][j] = &amp;a[i][j]; step1: for (i = 0; i &lt; 9; i++) &#123; next1: **q[i] = rand() % 10; if (**q[i] == 0) goto next1; for (j = 0; j &lt; i; j++) if (**q[j] == **q[i]) goto next1; &#125; step2: for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; next2: *m[i][j] = rand() % 10; if (*m[i][j] == 0) goto next2; for (k = 0; k &lt; 3; k++) if (*m[i][j] == *p[i][k]) goto next2; for (k = 0; k &lt; j; k++) if (*m[i][j] == *m[i][k]) goto next2; for (k = 0; k &lt; i; k++) if (*m[i][j] == *m[k][j]) goto step2; &#125; step3: for (i = 0; i &lt; 3; i++) &#123; next4: for (j = 0; j &lt; 6; j++) &#123; next3: *n[i][j] = rand() % 10; if (*n[i][j] == 0) goto next3; for (k = 0; k &lt; 3; k++) if (*n[i][j] == *p[k][i]) goto next3; for (k = 0; k &lt; j; k++) if (*n[i][j] == *n[i][k]) goto next3; for (l = 0; l &lt; 2; l++) &#123; if (*n[i][j] == *m[j / 2][i * 2 + l]) goto next4; &#125; for (k = 0; k &lt; i; k++) if (*n[i][j] == *n[k][j]) goto step3; &#125; &#125; step4: for (i = 0; i &lt; 3; i++) &#123; for (h = 0; h &lt; 2; h++) &#123; next6: for (l = 0; l &lt; 3; l++) for (j = 0; j &lt; 2; j++) &#123; next5: *r[i * 3 + l][h * 2 + j] = rand() % 10; if (*r[i * 3 + l][h * 2 + j] == 0) goto next5; if (*r[i * 3 + l][h * 2 + j] == **q[i * 3 + l]) goto next5; for (k = 0; k &lt; h * 2 + j; k++) if (*r[i * 3 + l][h * 2 + j] == *r[i * 3 + l][k]) goto next5; for (k = 0; k &lt; 2; k++) &#123; if (*r[i * 3 + l][h * 2 + j] == *m[i][l * 2 + k]) goto next5; if (*r[i * 3 + l][h * 2 + j] == *n[l][i * 2 + k]) goto next5; &#125; for (k = 0; k &lt;= l * 3 + j * 2; k++) for (t = 0; t &lt; k; t++) if (a[i * 3 + h * 2][k] == a[i * 3 + h * 2][t]) goto next6; &#125; &#125; &#125; step5: for (i = 0; i &lt; 3; i++) &#123; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); if (check(a, i) == false) rank(aa[j][i * 3], aa[j][i * 3 + 2]); else if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 9; l++) &#123; for (j = l + 1; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 6; l++) &#123; for (h = l + 1; h &lt; 7; h++) &#123; for (j = h + 1; j &lt; 8; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) goto step4; &#125; printf(&quot;+---------------+---------------+---------------+\n&quot;); printf(&quot;| | | |\n&quot;); for (i = 0; i &lt; 9; i++) &#123; printf(&quot;| &quot;); for (j = 0; j &lt; 9; j++) &#123; printf(&quot;%-4d&quot;, a[i][j]); if ((j + 1) % 3 == 0) printf(&quot;| &quot;); &#125; printf(&quot;\n&quot;); printf(&quot;| | | |\n&quot;); if ((i + 1) % 3 == 0) &#123; printf(&quot;+---------------+---------------+---------------+\n&quot;); if (i &lt; 8) printf(&quot;| | | |\n&quot;); &#125; &#125; system(&quot;pause&quot;); &#125; void rank(int *x, int *y) &#123; int t; t = *x; *x = *y; *y = t; &#125; bool check(int a[9][9], int n) &#123; int i, j; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; i; j++) if (a[i][n * 3] == a[j][n * 3]) return false; return true; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现控制台小游戏——数字拼图]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20%2F</url>
    <content type="text"><![CDATA[一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;math.h&gt; #include &lt;time.h&gt; #define max 10 int x, y, step, label = 0; typedef struct score &#123; int steps, steps2; double times; char name[18]; &#125;score; score sco[max + 1]; char ch, buff[3]; bool flag, flag1 = false; clock_t start, finish; bool over()&#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t\t\t您共用了 %d 步 ,耗时 %.3f 分钟\n&quot;, step, (double)(finish - start) / 40000); system(&quot;pause&quot;); system(&quot;cls&quot;); printf(&quot;\n\n\n\n\n\n\n\n\t******************* 您是否重新开始游戏 (Y/N) ? *******************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch != &apos;n&apos;&amp;&amp;ch != &apos;N&apos;) &#123; return false; &#125; else &#123; printf(&quot;\n\n\n\n\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n&quot;); printf(&quot;\t+++++++++++++++++++++++++ 感谢您的使用 +++++++++++++++++++++++++\n&quot;, step); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); system(&quot;pause&quot;); exit(0); &#125; return true; &#125; void rank(score sco[],int n) &#123; int i, j; sco[0] = sco[n]; for (i = 0; i &lt; n; i++) if (sco[n].steps2&gt;sco[i].steps2) &#123; for (j = n; j &gt; i; j--) sco[j] = sco[j - 1]; sco[i] = sco[0]; break; &#125; for (j = i - 1; j &gt; 0; j--) if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps &lt; sco[j].steps) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; else if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps == sco[j].steps) if (sco[i].times &lt; sco[j].times) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; &#125; int check2(int *p, int n) &#123; int i, j, flag2 = 0; for (i = 1; i &lt; n*n - 1; i++) for (j = 0; j &lt; i; j++) if (p[j] &gt; p[i]) flag2++; if (!flag2) return 0; else if (flag2 % 2 == 0) return 2; else return 1; &#125; bool check(int *p,int n) &#123; int i; flag = true; for (i = 0; i&lt;n*n - 1; i++) if (p[i] != i + 1) flag = false; if (flag) &#123; flag1 = false; return false; &#125; return true; &#125; int operation(int *p,int n) &#123; scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch &gt;= &apos;a&apos;&amp;&amp;ch &lt;= &apos;z&apos;) ch -= 32; switch (ch) &#123; case &apos;A&apos;: if (y == n - 1) return 1; p[x*n + y] = p[x*n + y + 1]; p[x*n + y + 1] = 0; y++; step++; return 1; case &apos;W&apos;: if (x == n - 1) return 1; p[x*n + y] = p[(x + 1)*n + y]; p[(x + 1)*n + y] = 0; x++; step++; return 1; case &apos;D&apos;: if (y == 0) return 1; p[x*n + y] = p[x*n + y - 1]; p[x*n + y - 1] = 0; y--; step++; return 1; case &apos;S&apos;: if (x == 0) return 1; p[x*n + y] = p[(x - 1)*n + y]; p[(x - 1)*n + y] = 0; x--; step++; return 1; case &apos;R&apos;: return 2; case &apos;M&apos;: return 3; case &apos;Q&apos;: printf(&quot;\n\n\t********************* 您是否要离开游戏 (Y/N) ? *********************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch == &apos;y&apos; || ch == &apos;Y&apos;) return 4; else return 1; default: return 1; &#125; return 0; &#125; void map(int *p, int n) &#123; int i, j; system(&quot;cls&quot;); printf(&quot;\n\n\n&quot;); for (i = 0; i &lt; n; i++) &#123; printf(&quot;\t&quot;); for (j = 0; j &lt; n; j++) &#123; if (p[n*i + j] != 0) printf(&quot;%-4d&quot;, p[n*i + j]); else printf(&quot; &quot;); &#125; printf(&quot;\n\n&quot;); &#125; printf(&quot;\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); finish = clock(); printf(&quot;\n\t\t\t\t步数: %d\t 使用时间: %.3f 分钟 \n\n&quot;, step, (double)(finish - start) / 40000); &#125; void reset(int *p, int n) &#123; int i, j, flag2; system(&quot;cls&quot;); do &#123; for (i = 0; i &lt; n*n - 1; i++) &#123; do &#123; flag2 = 1; p[i] = rand() % (n*n - 1) + 1; for (j = 0; j &lt; i; j++) if (p[i] == p[j]) flag2 = 0; &#125; while (!flag2); &#125; flag2 = check2(p, n); if (flag2 == 1) &#123; flag2 = p[n*n - 2]; p[n*n - 2] = p[n*n - 3]; p[n*n - 3] = flag2; &#125; &#125; while (!flag2); p[n*n - 1] = 0; for (i = 0; i&lt;n; i++) for (j = 0; j&lt;n; j++) if (p[i*n + j] == 0)&#123; x = i; y = j; &#125; &#125; void help() &#123; int i = 0; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t--------------------------------+ 基本操作 +--------------------------------\n\n&quot;); printf(&quot;\n\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); printf(&quot;\n\n\t---------------------------+ 浅悠悠（王骏）制作 +---------------------------\n\n&quot;); if (label == 0) printf(&quot;\n\n\t--------------------------+ 暂时没有任何游戏记录 +--------------------------\n\n&quot;); else for (i = 1; i &lt;= label; i++) printf(&quot;\n\n\t 第%02d名：%-18s 步数：%-5d 阶数：%-5d 时间：%-6.3lf分钟\n\n&quot;, i, sco[i].name, sco[i].steps, sco[i].steps2, sco[i].times); printf(&quot;\n\n\t----------------------------+ 按任意键返回菜单 +----------------------------\n\n&quot;); system(&quot;pause&quot;); &#125; void game() &#123; int n, *p; int mark; do &#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t------------------+ 请输入阶数（推荐3——20阶） +------------------\n\n&quot;); scanf(&quot;%d&quot;, &amp;n); if (n &gt; 1) p = (int*)calloc(n*n, sizeof(int)); else printf(&quot;\t********************** 您输入有误，请重新输入 **********************\n\n&quot;), system(&quot;pause&quot;); &#125; while (n &lt;= 1); next1: step = 0; start = clock(); reset(p, n); next2: map(p, n); if (check(p, n) == false) &#123; printf(&quot;\n\n\t=================+ 恭喜您完成游戏，请输入您的姓名 +=================\n\n&quot;); scanf(&quot;%s&quot;, sco[++label].name); sco[label].steps = step; sco[label].steps2 = n; sco[label].times = (double)(finish - start) / 40000; rank(sco, label); if (over() == false) return; &#125; mark = operation(p, n); if (mark == 1) goto next2; else if (mark == 2) goto next1; else if (mark == 3) return; else if (mark == 4) if (over() == false) return; free(p); &#125; int main()&#123; srand((int)time(0)); do &#123; system(&quot;cls&quot;); printf(&quot;\t-------------+ 欢迎来到浅悠悠数字拼图，请选择您的操作 +-------------\n\n&quot;); printf(&quot;\t-----+ 1.开始游戏 +-----+ 2.帮助 +-----+ 0(或其他).退出 +-----\n\n&quot;); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; switch (ch)&#123; case&apos;1&apos;: game(); break; case&apos;2&apos;: help(); break; case&apos;0&apos;: exit(0); default: exit(0); &#125; &#125; while (ch != &apos;0&apos;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模拟]来一瓶82年拉菲（酒杯问题）]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28%2F</url>
    <content type="text"><![CDATA[问题描述： 悠神最近过生日，朋友纷纷来贺。现有一瓶82年拉菲与若干酒杯。酒杯呈三角形酒塔摆放，即每一个酒杯摆放在下一层两个酒杯中间，最下面一层酒杯摆放在桌面上。共有N(1&lt;=N&lt;=20)层酒杯，第k层共有k个酒杯。悠神将拉菲倒进第一层的酒杯中，速度为1杯/s，倒满后酒会向左右两个方向溢出，假设会全部溢出到这个酒杯下面相邻的两个酒杯中。然而悠神有洁癖，他不喜欢浪费，更不喜欢浸湿他心爱的桌布，所以请你计算一下第几秒之后桌布会被浸湿。 eg：如图所示为3层时的情况。第一层倒满需要1s，第二次倒满需要2s，第三层首次倒满需要2s。所以共需1+2+2=5s。 输入： 输入N(1&lt;=N&lt;=20)。 输出： 桌布浸湿时至少所需时间（取整数）。 输入样例： 2 输出样例： 3 分析： 桌布浸湿只与最下层最中间位置何时倒满有关，因此只需计算最下层中间位置酒杯的状态。由于时间取整，所以只需模拟出第一杯共倒了多少杯酒，即为多少s。而每一个酒杯共倒了多少酒与上一层相邻两个酒杯相关，及第i层第j个酒杯的酒只与第i-1层第j-1个和第j个酒杯的酒相关。及wine[i][j]=wine[i-1][j-1]+wine[i-1][j];由于酒杯有两种状态，及未满状态和倒满状态，所以要判断wine[i-1]层的酒是否&gt;1。 12345678910111213141516171819202122#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define MAXN 20 int main() &#123; int N; while (~scanf(&quot;%d&quot;, &amp;N)) &#123; double wine[MAXN + 1][MAXN + 1] = &#123; 0 &#125;; double temp = 0; while (wine[N][N / 2 + 1] &lt; 1) &#123; memset(wine, 0, sizeof(wine)); temp++; wine[1][1] = temp; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; wine[i][j] += (wine[i - 1][j - 1] &gt; 1 ? (wine[i - 1][j - 1] - 1) / 2.0 : 0) + (wine[i - 1][j] &gt; 1 ? (wine[i - 1][j] - 1) / 2.0 : 0); &#125; &#125; &#125; printf(&quot;%g\n&quot;, wine[1][1]); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]愿天下有情人都是失散多年的兄妹]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-2%2F</url>
    <content type="text"><![CDATA[题目概述：L2-016. 愿天下有情人都是失散多年的兄妹时间限制 200 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？ 输入格式： 输入第一行给出一个正整数N（2 &lt;= N &lt;= 104），随后N行，每行按以下格式给出一个人的信息： 本人ID 性别 父亲ID 母亲ID 其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。 接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。 注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。 输出格式： 对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出“Never Mind”；如果是异性并且关系出了五服，输出“Yes”；如果异性关系未出五服，输出“No”。 输入样例： 12345678910111213141516171819202122232425262728293031323334352400001 M 01111 -100002 F 02222 0333300003 M 02222 0333300004 F 04444 0333300005 M 04444 0555500006 F 04444 0555500007 F 06666 0777700008 M 06666 0777700009 M 00001 0000200010 M 00003 0000600011 F 00005 0000700012 F 00008 0888800013 F 00009 0001100014 M 00010 0999900015 M 00010 0999900016 M 10000 0001200017 F -1 0001200018 F 11000 0001300019 F 11100 0001800020 F 00015 1111000021 M 11100 0002000022 M 00016 -100023 M 10012 0001700024 M 00022 10013900021 0002400019 0002400011 0001200022 0001800001 0000400013 0001600017 0001500019 0002100010 00011 输出样例： 123456789Never MindYesNever MindNoYesNoYesNoNo 1分析： 利用广度优先搜索，将每个人及双亲放入集合mab中，假如集合长度为改变，则说明mab中已存在这个人，则证明双方是近亲。visit用来记录层数。五层时结束搜索。 AC代码BFS： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define MAXN 100005 using namespace std; struct inf &#123; int fa; int ma; char sex; &#125;; inf node[MAXN]; int visit[MAXN]; bool flag[MAXN]; int N; bool BFS(int x1,int x2) &#123; memset(visit, 0, sizeof(visit)); queue&lt;int&gt;family; set&lt;int&gt;mab; family.push(x1); family.push(x2); visit[x1] = 1; visit[x2] = 1; while (!family.empty()) &#123; int top = family.front(); family.pop(); int size = mab.size(); mab.insert(top); if (mab.size() == size) &#123; return true; break; &#125; if (visit[top] &lt;= 4) &#123; if (node[top].fa) &#123; family.push(node[top].fa); visit[node[top].fa] += visit[top] + 1; &#125; if (node[top].ma) &#123; family.push(node[top].ma); visit[node[top].ma] += visit[top] + 1; &#125; &#125; &#125; return false; &#125; int main() &#123; cin &gt;&gt; N; memset(node, 0, sizeof(node)); memset(flag, 0, sizeof(flag)); while (N--) &#123; int id, fa, ma; char ch[2]; scanf(&quot;%d%s%d%d&quot;, &amp;id, ch, &amp;fa, &amp;ma); node[id].sex = ch[0]; flag[id] = true; if (fa != -1) &#123; node[id].fa = fa; node[fa].sex = &apos;M&apos;; flag[fa] = true; &#125; if (ma != -1) &#123; node[id].ma = ma; node[ma].sex = &apos;F&apos;; flag[ma] = true; &#125; &#125; cin &gt;&gt; N; while (N--) &#123; int per1, per2; cin &gt;&gt; per1 &gt;&gt; per2; if (node[per1].sex == node[per2].sex) printf(&quot;Never Mind\n&quot;); else &#123; if (BFS(per1, per2)) printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>BFS</tag>
        <tag>pat天梯赛</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector的嵌套实现二维数组，解决矩阵相乘问题]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26%2F</url>
    <content type="text"><![CDATA[定义vector的元素可以是一个vector。比如， vector&lt;vector&gt; 即表示一个二维int数组，里层的vector表示第一维， 外层的vector表示第二维。 例题描述：L1-048. 矩阵A乘以B时间限制 400 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。 输入格式： 输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。 输出格式： 若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出“Error: Ca != Rb”，其中Ca是A的列数，Rb是B的行数。 输入样例1： 12345672 31 2 34 5 63 47 8 9 0-1 -2 -3 -45 6 7 8 输出样例1： 1232 420 22 24 1653 58 63 28 输入样例2： 123456783 238 2643 -50 173 2-11 5799 6881 72 输出样例2： 1Error: 2 != 3 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int M1, N1, M2, N2; int main() &#123; cin &gt;&gt; M1 &gt;&gt; N1; vector&lt;int&gt;alie(N1); vector&lt;vector&lt;int&gt;&gt;ahang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N1; j++) &#123; scanf(&quot;%d&quot;, &amp;alie[j]); &#125; ahang[i] = alie; &#125; cin &gt;&gt; M2 &gt;&gt; N2; vector&lt;int&gt;blie(N2); vector&lt;vector&lt;int&gt;&gt;bhang(M2); for (int i = 0; i &lt; M2; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; scanf(&quot;%d&quot;, &amp;blie[j]); &#125; bhang[i] = blie; &#125; if (N1 != M2) printf(&quot;Error: %d != %d\n&quot;, N1, M2); else &#123; vector&lt;int&gt;anslie(N2); vector&lt;vector&lt;int&gt;&gt;anshang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; anslie[j] = 0; for (int k = 0; k &lt; N1; k++) anslie[j] += ahang[i][k] * bhang[k][j]; &#125; anshang[i] = anslie; &#125; printf(&quot;%d %d\n&quot;, M1, N2); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2 - 1; j++) printf(&quot;%d &quot;, anshang[i][j]); printf(&quot;%d\n&quot;, anshang[i][N2 - 1]); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>算法</tag>
        <tag>stl</tag>
        <tag>vector</tag>
      </tags>
  </entry>
</search>
