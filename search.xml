<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[昨世今生]]></title>
    <url>%2F2018%2F11%2F09%2F2018-11-09%2F</url>
    <content type="text"><![CDATA[author：浅悠悠 致亲人，致自己 5岁， 你的梦想是什么呢？ emm，环游世界！ 为什么呢？ 爷爷之前说的。 9岁，告别了童言无忌 然而玩耍依然是最大的乐趣。 那些年，是记忆里的伊甸园。 12岁，你开始了奋发学习 你并不理解知识改变命运， 但你却依旧坚持， 为了心中的荣誉。 那些年，你的理想是北大清华。 15岁，你读了高中 开始憧憬大人们的生活， 也开始尝试各种偶像剧。 你喜欢看好莱坞，听飞轮海。 你学明星留起了长发， 也在心里默默藏起了一个她。 17岁，快要高考了 你却接受了各式文化的洗礼， 渐渐喜欢弹琴写词， 喜欢吟诗作画， 喜欢古典音乐与欧美文学， 喜欢听《为你写诗》，看她笑靥如花 。 那些年，你眼里只有她。 18岁，你踏上了大学生活 昔日的她也断了联系。 你开始学李清照多愁善感， 也学苏轼一笑释然。 时而感时花溅泪， 时而欲与天公试比高。 那一年，你的理想是文学与艺术。 20岁，大二刚刚结束 你开始后悔两年的蹉跎， 也明白了人生几何。 身边有几个一直陪伴你的红颜， 但你每次都觉得和那个她比， 差了一点。 你封闭起自己奋发图强， 渐渐厌倦了与别人的交流， 却渴望着别人的理解。 那些年，你的理想是出人头地。 22岁，即将毕业 却发现很难找到一份令自己满意的工作， 你渐渐明白很多事情不是由自己决定。 你收起了曾经的轻狂， 也渐渐学着别人假装。 你开始喜欢看周星驰，听毛不易。 那一年，你的理想是找到一份稳定的工作。 24岁，忙碌的工作压得你喘不过气 看尽了天外有天有无常， 山外有山有他乡， 你已忘却了喜怒无常， 凡事都一笑而过。 你穿梭于各个城市之间， 有时也常常想起曾经环游世界的梦想， 但也只能感慨马路的纵横交错。 那些年，你只想轻松一点。 26岁，你依旧孑然一身 随着年纪增长的， 除了脱单的朋友们， 还有送去各种礼金。 过节回家，父母从带你串亲戚， 变成了催你找对象。 而你每次都是推辞说忙， 或者配不上别人家的姑娘。 28岁，你遇见了一个和你境遇类似的姑娘 初次见面，简单地交涉， 彼此没有脸红，也没有心跳，只剩下尴尬。 终于她喝了一口浓咖啡说，你还不错。 你愣了一下，说，你也不错。 29岁，你们结婚了 你并不确定她是否真的喜欢你， 就像你不确定是否真的喜欢她， 只是双方父母一直在催促。 攒了几年去实现理想的钱， 全部用在了这场婚宴上。 婚前的酒宴，朋友来的不多也不少。 你醉后对朋友说，不想结婚， 朋友说，你只是喝多了，想多了。 30岁，渐渐升职 独自负责几个项目， 管理几个刚毕业的入职者。 然而她怀孕了，辞掉了工作， 于是你又每日加班。 电话那边总是抱怨， 但你却不能争辩什么。 那些年，你的理想是简单安稳的生活。 31岁，有了孩子 大大小小的费用又花去了一笔钱， 不过都无所谓， 你看着你的孩子， 心中满是欣慰。 那一年，你的全部只为孩子。 32岁，人生最忙碌的一年， 孩子24小时的折腾， 第二天拖着疲惫的身体上班， 老板说你上班不干活， 回家媳妇说你不干活， 你想了半天也没明白，那谁干的活呢。 那些年，你不再提起理想。 35岁，你的身体越来越差， 加班越来越少， 晋升也越来越慢， 而孩子也要开始上幼儿园了， 各种培训机构与学费又花去了不少积蓄， 那一年，你本打算给自己过个生日，换个新电脑 40岁，曾经宣告世界的理想已不知去何方。 你常常希望将曾经未完成的心愿寄托给孩子， 但望着尚未还完的房贷，你笑笑摇摇头。 一天，他对你说，爸，我想学钢琴。 你没什么犹豫的，这些年你已经习惯了， 但那句“爸爸现在买不起”你始终说不出口。 孩子很懂事，说：爸爸没事，我学吉他也可以。 你看着这么懂事的孩子，却开心不起来。 那些年，你不再提起那些年。 50岁，孩子上了大学 他学的专业你有点不懂， 你知道工作不好找， 你和他深夜聊聊， 准备了四两白酒， 你说着那些曾经你最讨厌的话， 你们从交流变成了争吵， 你发现，你老了，老到可能都打不过这个18岁的孩子。 你说不过他，只能说一句：我是你爸！ 孩子看着你，知道再怎么争辩都没用， 这场确立你最后威严的酒局不欢而散， 在孩子回自己屋的路上叨叨了一句 “我不想活成你那样” 。 50岁的人了，怎么就哭了呢？ 一定是酒太烈了， 对，一定是酒太烈了 54岁，孩子也工作了 似乎有一点理解你了， 但你却反了过来， 告诉他说不要妥协 。 55岁，孩子结婚了 你问他，你喜欢他吗。 他愣了愣，喜欢吧。 60岁，有时间旅行了 你和老伴准备好了， 孩子却说：爸妈，我工作忙了。 帮我照顾一下孩子。 你们退了机票， 又回到了30年前 65岁，孩子的孩子也上学了 你下定决心说：一定要环游世界， 可是手边的拐杖， 只能支撑你走到楼下花园。 68岁，你已走到了人生的尽头。 你躺在医院的病床上， 望着窗外泛黄的枯叶不知何时落下来。 你迷迷糊糊的看见医生摇了摇头， 你明白了，你要死了。 你并没有感到害怕。 你这一生，无怨无悔。 只是，有好多遗憾啊。 听说，人死时是最清醒的。 因为那时你的大脑里会倒叙你的一生。 生命的倒叙走向了最后一秒， 忽然间，身边的人哭了，你却笑了。 原来画面又回到了18岁的离别季， 那一天离别前，你们端坐在操场的石凳上， 各自心中思绪万千，嘴上却沉默无言。 终于，你放下了腼腆， 攥紧了她的手， 笑着对她说， 往后余生， 愿你拥有全部的权力， 而我愿拥有全部的义务。]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F15%2F2018-04-24%2F</url>
    <content type="text"><![CDATA[Welcome to My Blog! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server11$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割求解最大权闭合子图]]></title>
    <url>%2F2018%2F10%2F10%2F2018-10-10%2F</url>
    <content type="text"><![CDATA[定义有一个有向图，每一个点都有一个权值（可以为正或负或0），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 如下图： 能选的子图有Ø,{4},{3,4},{2,4},{1,2,3,4},它们的权值分别为0,-1,5,-6,4. 所以最大权闭合子图为{3,4}，权值为5. 解法这个问题可以转化为最小割问题，用网络流解决。 从源点s向每个正权点连一条容量为权值的边，每个负权点向汇点t连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和-最小割）。 如何理解割掉一条边的含义由于原图的边都是无穷大，那么割边一定是与源点s或汇点t相连的。 割掉s与i的边，表示不选择i点作为子图的点； 割掉i与t的边，表示选择i点为子图的点。 如果s与i有边，表示i存在子图中； 如果i与t有边，表示i不存在于子图中。 合法性只有s与t不连通时，才能得到闭合子图。 如果s与t连通，则存在点i,j，使得s到i有边，i到j连通，j到t有边，所以j一定是i的后继，但选择了i，没有选择j，不是闭合子图。 如果s与t不连通，选择了正权点i，一定选择了i后继中的所有负权点。设j是i的后继中的正权点，则割掉s到j的边是没有意义的，最小割不会割掉它，则j一点被选中，所以i的所有后继都被选中，符合闭合图的定义。 最优性最小割=(不选的正权之和+要选的负权绝对值之和） 最大权闭合子图=（正权之和-不选的正权之和-要选的负权绝对值之和）=正权值和-最小割 因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。 例题POJ2987_Firing]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统三大经典同步问题]]></title>
    <url>%2F2018%2F10%2F09%2F2018-10-09%2F</url>
    <content type="text"><![CDATA[用专业术语来说, 进程是程序的一次动态执行.说简单点, 就是进程是系统中的某个任务.操作系统中有多个任务需要执行, 那么怎样执行才能使它们同步呢? 即如何让任务并发执行互不影响呢? 这就引出了进程同步中的经典问题: 生产者消费者问题, 哲学家进餐问题, 读写问题 生产者-消费者问题有一群生产者进程在生产产品, 并将这些产品提供给消费者进程取消费. 为使生产者进程与消费者进程能并发进行, 在两者间设置了一个具有n个缓冲区的缓冲池, 生产者进程将其所生产的产品翻入缓冲区中, 消费者进程可从一个缓冲区中取走产品取消费.生产者消费者进程都以异步方式进行, 但它们之间必须保持同步, 不允许消费者进程到空缓冲区去取产品, 也不允许生产者进程向已满的缓冲区投放产品. 一个缓冲池中有n个缓冲区, 只要缓冲池未满, 生产者便可以投放产品; 缓冲池为空, 消费者便可以消费产品 法一:记录型信号量1234567891011121314151617181920212223242526272829303132333435//生产者消费者问题//记录型信号量//缓冲池中有n个缓冲区, 互斥信号量mutex, //信号量empty表示空缓冲区数量, full表示满缓冲区的数量int in = out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; producer an item nextp; wait(empty); wait(mutex); buffer[in] = nextp; in = (in + 1) % n; signal(mutex); signal(full); &#125; while(true);&#125;void consumer() &#123; do &#123; wait(full); wait(mutex); nextc = buffer[out]; out = (out + 1) % n; signal(mutex); signal(empty); consumer the item in nextc; &#125; while(true);&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 注意: 对信号量的wait()和signal()操作必定是成对出现的. 法二:AND型信号量1234567891011121314151617181920212223242526272829303132//AND型信号量//Swait(empty, mutex)代替wait(empty)和wait(mutex)//Ssignal(mutex,full)代替signal(mutext)和signal(full)//Swait(full, mutex)代替wait(full)和wait(mutex)//Ssignal(mutex, empty)代替signal(mutex)和signal(empty)int in = out = 0;item buffer[n];semaphore mutex = 1, empty = n, full = 0;void producer() &#123; do &#123; producer an item nextp; Swait(empty, mutex); buffer[in] = nextp; in = (in + 1) % n; Ssignal(mutex, full); &#125; while(true);&#125;void consumer() &#123; do &#123; Swait(full, mutex); nextc = buffer[out]; out = (out + 1) % n; Ssignal(mutex, empty); consumer the item in nextc; &#125; while(true);&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 法三: 管程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//管程//建立管程producerconsumer,PC/*put(x), 生产者利用该过程将自己生产的产品投放到缓冲池中, 并用整型变量count表示缓冲池中已有的产品数目,当count&gt;=N时, 表示缓冲池已满,生产者需等待.get(x), 消费者利用该过程从缓冲池中取出一个产品, 当count&lt;=0时, 表示缓冲池已无可用的产品, 消费者需等待condition 为notfull和notemptycwait(condition), 当管程被一个进程占用时, 其他进程调用该进程时阻塞, 并挂在条件condition的队列上csignal(condition), 唤醒在cwait执行后阻塞在条件condition队列上的进程, 如果这样的进程不止一个, 则选择其中一个实施唤醒操作, 如果队列为空, 则无操作而返回.*/Monitor producerconsumer &#123; item buffer[N]; int in, out; condition notfull, notempty; int count; public: void put(item x) &#123; if (count &gt;= N) cwait(notfull); buffer[in] = x; in = (in + 1) % N; count++; ssignal(notempty); &#125; void get(item x) &#123; if (count &lt;= 0) cwait(notempty); x = buffer[out]; out = (out + 1) % N; count--; csignal(notfull); &#125; &#123; in = 0; out = 0; count = 0; &#125;&#125;PC;void producer() &#123; item x; while (true) &#123; producer an item in nextp; PC.put(x); &#125;&#125;void consumer() &#123; item x; while (true) &#123; PC.get(x); consumer the item in nextc; &#125;&#125;void main() &#123; cobegin producer(); consumer(); coend&#125; 哲学家进餐问题五个哲学家公用一张圆桌, 分别坐在周围的五张桌子上, 在圆桌上有五个碗和五只筷子交叉排列, 它们的生活方式是交替的进行思考和进餐. 哲学家进行思考时不用筷子, 饥饿时取一只他两边的任意一只筷子(默认取左边的筷子, 没有时取右边的, 都没有时就取不了), 当他有两只筷子时就能进餐. 进餐后, 放下筷子继续思考.若只有一只筷子, 不放弃该筷子并等待拥有另一只筷子时再进餐. 用一个信号量表示一只筷子, 共五个信号量 semaphore chopsitck[5] = {1, 1, 1, 1, 1}; , 为 1 表示筷子未拿起, 为0表示筷子被拿起.那么第i为科学家的进餐活动就可以描述为 法一:记录型信号量12345678do &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); //eat signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); //think&#125; while (true); 假设五位哲学家都要拿筷子(都拿左手边), 那么将没有人可以 用餐, 就会陷入死锁状态.则哲学家进餐的解决方法: 1.至多允许四位哲学家拿同一边的筷子, 则可让至少一位哲学家先用餐, 用餐完后释放筷子进而让其他哲学家有机会用餐. 2.五位哲学家先竞争奇数(偶数)好筷子, 在竞争偶数(奇数)号筷子, 总会有一位哲学家能进餐. 法二: AND型信号量12345678//AND型信号量semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;do &#123; //think Swait(chopsitck[(i + 1) % 5], chopsitck[i]); //eat Ssignal(chopsitck[(i + 1) % 5], chopsitck[i]);&#125; while (true); 读者-写者问题一个数据文件或记录可被多个进程所共享, 则我们称这个文件或记录为共享对象.读文件的进程称为Reader进程, 写文件的进程称为Writer进程.共享对象可以被多个Reader进程, 因为读进程并不会破坏数据, 但是Writer进程在任何时刻只能有一个, 且须与其他对象互斥的访问共享对象, 否则多个写进程会造成冲突. 读写者问题即一个Writer进程必须与其他进程互斥的访问共享对象. 设置写互斥信号量wmutex 设置读互斥信号量rmutex 整型变量readcount表示正在读的进程数目(Reader) 当readcount!=0时, 表示有Reader进程,此时不能进行Writer进程. 法一: 123456789101112131415161718192021222324252627282930313233343536//记录型信号量semaphore rmutext = 1, wmutext = 1;int readcount = 0;void Reader() &#123; do &#123; wait(rmutex); if (readcount == 0) &#123; wait(wmutex); &#125; readcount++; signal(rmutex); perform read operation; wait(rmutex); readcount--; if (readcount == 0) &#123; signal(wmutext); &#125; signal(rmutex); &#125; while (true);&#125;void Writer() &#123; do &#123; wait(wmutex); perform write operation; signal(wmutex); &#125; while (true);&#125;void main() &#123; cobegin Reader(); Writer(); coend&#125; 法二: 引入RN, 表示最多允许RN个Reader进程同时读 信号量L初始为RN 123456789101112131415161718192021222324252627//信号量集int RN;semaphore L = RN, mx = 1;void Reader() &#123; do &#123; Swait(L, 1, 1); Swait(mx, 1, 0); perform read operation; Ssignal(L, 1); &#125; while (true);&#125;void Writer() &#123; do &#123; Swait(mx, 1, 1; L, RN, 0); perform write operation; Ssignal(mx, 1); &#125; while (true);&#125;void main() &#123; cobegin Reader(); Writer(); coend&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>操作系统</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[强连通图经典算法——Tarjan算法]]></title>
    <url>%2F2018%2F10%2F08%2F2018-10-08%2F</url>
    <content type="text"><![CDATA[Tarjan 算法 一.算法简介 Tarjan 算法一种由Robert Tarjan提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。 我们定义： 如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。 例如：在上图中，{1 , 2 , 3 , 4 } , { 5 } , { 6 } 三个区域可以相互连通，称为这个图的强连通分量。 Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。 再Tarjan算法中，有如下定义。 DFN[ i ] : 在DFS中该节点被搜索的次序(时间戳) LOW[ i ] : 为i或i的子树能够追溯到的最早的栈中节点的次序号 当DFN[ i ]==LOW[ i ]时，为i或i的子树可以构成一个强连通分量。 二.算法图示 以1为Tarjan 算法的起始点，如图 顺次DFS搜到节点6 回溯时发现LOW[ 5 ]==DFN[ 5 ] , LOW[ 6 ]==DFN[ 6 ] ,则{ 5 } , { 6 } 为两个强连通分量。回溯至3节点，拓展节点4. 拓展节点1 ， 发现1再栈中更新LOW[ 4 ]，LOW[ 3 ] 的值为1 回溯节点1，拓展节点2 自此，Tarjan Algorithm 结束，{1 , 2 , 3 , 4 } , { 5 } , { 6 } 为图中的三个强连通分量。 不难发现，Tarjan Algorithm 的时间复杂度为O(E+V). 1234567891011121314151617181920212223void Tarjan ( int x ) &#123; dfn[ x ] = ++dfs_num ; low[ x ] = dfs_num ; vis [ x ] = true ;//是否在栈中 stack [ ++top ] = x ; for ( int i=head[ x ] ; i!=0 ; i=e[i].next )&#123; int temp = e[ i ].to ; if ( !dfn[ temp ] )&#123; Tarjan ( temp ) ; low[ x ] = gmin ( low[ x ] , low[ temp ] ) ; &#125; else if ( vis[ temp ])low[ x ] = gmin ( low[ x ] , dfn[ temp ] ) ; &#125; if ( dfn[ x ]==low[ x ] ) &#123;//构成强连通分量 vis[ x ] = false ; color[ x ] = ++col_num ;//染色 while ( stack[ top ] != x ) &#123;//清空 color [stack[ top ]] = col_num ; vis [ stack[ top-- ] ] = false ; &#125; top -- ; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>Tarjan算法</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM算法专用模板(持续更新中)]]></title>
    <url>%2F2018%2F10%2F05%2F2018-10-05%2F</url>
    <content type="text"><![CDATA[标签：位运算，gcd，exgcd，欧拉筛，快速乘，快速幂，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，树链剖分，莫队，LCA，Trie树，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyed，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim 数据结构基础并查集12345678910111213141516int fa[maxn];void init()&#123; for(int i = 0; i &lt; maxn; i++)&#123; fa[i] = i; &#125;&#125;int root(int x)&#123; return x==fa[x] ? x : x=root(fa[x]);&#125;void Union(int px, int py)&#123; px = root(px); py = root(py); if(px != py)&#123; fa[py] = px; &#125;&#125; 链式前向星12345678910111213141516int head[maxn], cnt;struct EDGE&#123; int next, to, u, w;&#125;edge[maxm];void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].u = u; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; cnt = 0; memset(head, -1, sizeof(head)); //memset(edge, 0, sizeof(edge));&#125; 树结构LCA(Tarjan)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e4 + 7;const int inf = 0x3f3f3f3f;int n, head[maxn], fa[maxn], head_2[maxn], cnt, cnt_2, sx;bool vis[maxn];struct EDGE&#123; int next, to, u;&#125;edge[maxn];struct QUERY&#123; int next, to, u, lca;&#125;query[maxn];void add_edge(int u, int v)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].u = u; head[u] = cnt++;&#125;void add_query(int u, int v)&#123; query[cnt_2].next = head_2[u]; query[cnt_2].to = v; query[cnt_2].u = u; head_2[u] = cnt_2++; query[cnt_2].next = head_2[v]; query[cnt_2].to = u; query[cnt_2].u = v; head_2[v] = cnt_2++;&#125;void init_edge()&#123; memset(head, -1, sizeof(head)); cnt = 0;&#125;void init_query()&#123; memset(head_2, -1, sizeof(head_2)); cnt_2 = 0;&#125;int root(int x)&#123; return x = x == fa[x] ? x : root(fa[x]);&#125;void tarjan(int x) &#123; fa[x] = x; for (int i = head[x]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; tarjan(v); fa[root(v)] = x; &#125; vis[x] = true; for (int i = head_2[x]; i != -1; i = query[i].next) &#123; int v = query[i].to; if (vis[v]) &#123; query[i].lca = query[i^1].lca = root(v); &#125; &#125;&#125;void read()&#123; int u, v; scanf(&quot;%d&quot;, &amp;n); memset(vis, false, sizeof(vis)); for(int i = 1; i &lt; n; i++)&#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_edge(u, v); vis[v] = true; &#125; for(int i = 1; i&lt;=n; i++)&#123; if(!vis[i])&#123; sx = i; break; &#125; &#125; memset(vis, false, sizeof(vis)); scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add_query(u, v);&#125;void solve()&#123; tarjan(sx); for(int i = 0; i &lt; cnt_2; i+=2)&#123; printf(&quot;%d\n&quot;, query[i].lca); &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; init_edge(); init_query(); read(); solve(); &#125; return 0;&#125;/*2161 148 510 165 94 68 44 101 136 1510 116 710 216 38 116 1216 752 33 43 11 53 5*///4 3 RMQ普通莫队1234567891011121314151617181920212223242526272829303132333435363738/* 解释： belong[x]x属于分块后的哪一块，Q[i]每个询问 modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析 注意： 最后也可以不对询问id排序，直接保存到一个数组里面输出即可*/int a[nmax], belong[nmax];ll ans = 0;struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];bool cmp(node a, node b) &#123; if (belong[a.l] != belong[b.l]) return a.l &lt; b.l; else return a.r &lt; b.r;&#125;bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;void modify(int pos, int tag) &#123; // ......... 增删操作&#125;int main() &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); int sz = sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= m; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; belong[i] = (i - 1) / sz + 1; &#125; sort(Q + 1, Q + 1 + m, cmp); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (l &lt; Q[i].l) modify(l++, -1); while (l &gt; Q[i].l) modify(--l, 1); while (r &gt; Q[i].r) modify(r--, -1); while (r &lt; Q[i].r) modify(++r, 1); Q[i].ans = ans; &#125; sort(Q + 1, Q + 1 + m, cmpid); for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans); return 0;&#125; 图论最短路Dijkstra(邻接矩阵)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 3007;const int inf = 0x3f3f3f3f;int road[maxn][maxn];int dis[maxn];bool vis[maxn];int n, m, sx, ex;void init()&#123; memset(road, inf, sizeof(road));&#125;int dijkstra(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); dis[sx] = 0; for(int u = 1; u&lt;=n; u++)&#123; int minD = inf, k = -1; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123; k = i; minD = dis[i]; &#125; &#125; //if(k == ex) // return dis[ex]; vis[k] = true; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123; dis[i] = dis[k] + road[k][i]; &#125; &#125; &#125; return dis[ex];&#125;void read()&#123; int u, v, w; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); road[u][v] = min(road[u][v], w); //road[v][u] = min(road[v][u], w); //双向边 &#125;&#125;void solve()&#123; printf(&quot;%d\n&quot;, dijkstra(sx, ex));&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123; init(); read(); solve(); &#125; return 0;&#125; Dijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 3007;const int inf = 0x3f3f3f3f;struct EDGE&#123; int next, to, w;&#125;edge[maxn&lt;&lt;4];int head[maxn], dis[maxn], cnt;bool vis[maxn];int n, m, sx, ex;void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;int dijkstra(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); dis[sx] = 0; for(int cas = 1; cas&lt;=n; cas++)&#123; int minD = inf, kk = -1; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123; kk = i; minD = dis[i]; &#125; &#125; //if(kk == ex) // return dis[ex]; vis[kk] = true; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123; dis[v] = dis[kk] + edge[i].w; &#125; &#125; &#125; return dis[ex];&#125;void read()&#123; int u, v, w; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); //add(v, u, w); //双向边 &#125;&#125;void solve()&#123; printf(&quot;%d\n&quot;, dijkstra(sx, ex));&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123; init(); read(); solve(); &#125; return 0;&#125; Dijkstra+heap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 3007;const int inf = 0x3f3f3f3f;struct EDGE&#123; int next, to, w;&#125;edge[maxn&lt;&lt;4];int head[maxn], dis[maxn], cnt;bool vis[maxn];int n, m, sx, ex;struct NODE&#123; int u; int dis; NODE()&#123;&#125; NODE(int x, int y) : u(x), dis(y)&#123;&#125; bool operator &lt;(const NODE &amp;a)const&#123; return dis&gt;a.dis; &#125;&#125;;void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;int dijkstra(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); dis[sx] = 0; priority_queue&lt;NODE&gt;que; que.push(NODE(sx, 0)); while(!que.empty())&#123; NODE tmp = que.top(); que.pop(); int kk = tmp.u; if(vis[kk])&#123; continue; &#125; vis[kk] = true; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123; dis[v] = dis[kk] + edge[i].w; que.push(NODE(v, dis[v])); &#125; &#125; &#125; return dis[ex];&#125;void read()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v, w; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); //双向边 &#125;&#125;void solve()&#123; printf(&quot;%d\n&quot;, dijkstra(sx, ex));&#125;int main()&#123; int T; while(T--)&#123; init(); read(); solve(); &#125; return 0;&#125; SPFA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 1e3+7;int n, m, sx, ex;int head[maxn], dis[maxn], cnt;bool vis[maxn];struct EDGE&#123; int next, to, w, u;&#125;edge[maxn&lt;&lt;3];void init()&#123; cnt = 0; memset(head, -1, sizeof(head));&#125;void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].u = u; edge[cnt].w = w; head[u] = cnt++;&#125;int SPFA(int sx, int ex)&#123; memset(vis, false, sizeof(vis)); memset(dis, inf, sizeof(dis)); queue&lt;int&gt;que; dis[sx] = 0; que.push(sx); while(!que.empty())&#123; int kk = que.front(); que.pop(); vis[kk] = false; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(dis[v] &gt; dis[kk] + edge[i].w)&#123; dis[v] = dis[kk] + edge[i].w; if(!vis[v])&#123; vis[v] = true; que.push(v); &#125; &#125; &#125; &#125; return dis[ex];&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123; init(); sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); //add(v, u, w); //双向边 &#125; printf(&quot;%d\n&quot;, SPFA(sx, ex)); &#125;&#125; 网络流DINIC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+7;const int inf = 0x3f3f3f3f;int n, m, sx, ex, cnt;int head[maxn], pre[maxn];struct EDGE&#123; int u, next, to, c;&#125;edge[maxn&lt;&lt;3];void add_edge(int u, int v, int c)&#123; edge[cnt].u = u; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].c = c&lt;=inf ? c : inf; head[u] = cnt++;&#125;void add(int u, int v, int c)&#123; add_edge(u, v, c); add_edge(v, u, 0);//双向边容量为c&#125;void init()&#123; //memset(edge, 0, sizeof(edge)); memset(head, -1, sizeof(head)); cnt = 0;&#125;void read()&#123; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;bool BFS(int sx, int ex)&#123; memset(pre, 0, sizeof(pre)); queue&lt;int&gt;que; que.push(sx); pre[sx] = 1; while(!que.empty())&#123; int kk = que.front(); que.pop(); for(int i = head[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!pre[v]&amp;&amp;edge[i].c)&#123; pre[v] = pre[kk] + 1; que.push(v); &#125; &#125; &#125; return pre[ex] != 0;&#125;int DFS(int pos, int flow)&#123; if(pos == ex || flow == 0) return flow; int f = flow; for(int i = head[pos]; i != -1; i = edge[i].next)&#123; int tmp, v = edge[i].to; if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123; edge[i].c -= tmp; edge[i^1].c += tmp; flow -= tmp; if(flow == 0)&#123; break; &#125; &#125; &#125; return f - flow;&#125;int Dinic(int sx, int ex)&#123; int flow = 0; while(BFS(sx, ex))&#123; flow += DFS(sx, inf); &#125; return flow;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123; init(); read(); printf(&quot;%d\n&quot;, Dinic(sx, ex)); &#125; return 0;&#125; DINIC优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+7;const int inf = 0x3f3f3f3f;int n, m, sx, ex, cnt;int head[maxn], pre[maxn], cur[maxn];struct EDGE&#123; int u, next, to, c;&#125;edge[maxn&lt;&lt;3];void add_edge(int u, int v, int c)&#123; edge[cnt].u = u; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].c = c&lt;=inf ? c : inf; head[u] = cnt++;&#125;void add(int u, int v, int c)&#123; add_edge(u, v, c); add_edge(v, u, 0);//双向边容量为c&#125;void init()&#123; //memset(edge, 0, sizeof(edge)); memset(head, -1, sizeof(head)); cnt = 0;&#125;void read()&#123; sx = 1, ex = n; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;bool BFS(int sx, int ex)&#123; memset(pre, 0, sizeof(pre)); queue&lt;int&gt;que; que.push(sx); pre[sx] = 1; while(!que.empty())&#123; int kk = que.front(); que.pop(); for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!pre[v]&amp;&amp;edge[i].c)&#123; pre[v] = pre[kk] + 1; que.push(v); &#125; &#125; &#125; return pre[ex] != 0;&#125;int DFS(int pos, int flow)&#123; if(pos == ex || flow == 0) return flow; int f = flow; for(int i = head[pos]; i != -1; i = edge[i].next)&#123; int tmp, v = edge[i].to; if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123; edge[i].c -= tmp; edge[i^1].c += tmp; flow -= tmp; if(flow == 0)&#123; break; &#125; &#125; &#125; return f - flow;&#125;int Dinic(int sx, int ex)&#123; int flow = 0; while(BFS(sx, ex))&#123; memcpy(cur, head, sizeof(head)); flow += DFS(sx, inf); &#125; return flow;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123; init(); read(); printf(&quot;%d\n&quot;, Dinic(sx, ex)); &#125; return 0;&#125; DINIC(邻接矩阵)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 307;struct NODE&#123; int c; int f;&#125;;int sx,ex;int pre[maxn];NODE road[maxn][maxn];int n, m, N;bool BFS()&#123; memset(pre,0,sizeof(pre)); queue&lt;int&gt;q; q.push(sx); pre[sx] = 1; while(!q.empty())&#123; int d = q.front(); q.pop(); for(int i = 1;i&lt;=N;i++)&#123; if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123; pre[i] = pre[d] + 1; q.push(i); &#125; &#125; &#125; return pre[ex]!=0;&#125;int dfs(int pos, int flow)&#123; int f = flow; if(pos==ex) return flow; for(int i = 1; i &lt;= N; i++)&#123; if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123; int a = road[pos][i].c - road[pos][i].f; int t = dfs(i, min(a, flow)); road[pos][i].f += t; road[i][pos].f -= t; flow -= t; &#125; &#125; return f - flow;&#125;int dinic()&#123; int sum = 0; while(BFS())&#123; sum+=dfs(sx,inf); &#125; return sum;&#125;void init()&#123; N = n; sx = 0; ex = N; memset(road,0,sizeof(road));&#125;void read()&#123; int u,v,w; for(int i = 1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); road[u][v].c+=w; &#125;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123; init(); read(); printf(&quot;%d\n&quot;,dinic()); &#125; return 0;&#125; MCMF123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxm = 1e5+7;const int maxn = 1e4+7;const int inf = 0x3f3f3f3f;int n, m, cnt, sx, ex;int head[maxn], pre[maxn], dis[maxn];bool vis[maxn];struct EDGE&#123; int next; int to; int w; int c;&#125;edge[maxm];void init()&#123; sx = 0; ex = 1; cnt = 0; memset(edge, 0, sizeof(edge)); memset(head, -1, sizeof(head));&#125;void add_edge(int u, int v, int c, int w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].c = c&lt;=inf ? c : inf; edge[cnt].w = w; head[u] = cnt++;&#125;void add(int u, int v, int c, int w)&#123; add_edge(u, v, c, w); add_edge(v, u, 0, -w);&#125;bool SPFA(int sx, int ex)&#123; memset(pre, -1, sizeof(pre)); memset(dis, inf, sizeof(dis)); memset(vis, false, sizeof(vis)); dis[sx] = 0; queue&lt;int&gt;que; que.push(sx); while(!que.empty())&#123; int kk = que.front(); que.pop(); vis[kk] = false; for(int i = head[kk]; i != -1; i = edge[i].next)&#123; EDGE tmp = edge[i]; if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123; dis[tmp.to] = dis[kk] + tmp.w; pre[tmp.to] = i; if(!vis[tmp.to])&#123; vis[tmp.to] = true; que.push(tmp.to); &#125; &#125; &#125; &#125; return pre[ex] != -1;&#125;int MCMF(int sx, int ex)&#123; int flow = 0, cost = 0; while(SPFA(sx, ex))&#123; int min_flow = inf; for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123; min_flow = min(min_flow, edge[i].c); &#125; for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123; edge[i].c -= min_flow; edge[i^1].c += min_flow; cost += min_flow * edge[i].w; &#125; flow += min_flow; &#125; return cost;&#125;void read()&#123; int u, v, c, w; ex = n+1; for(int i = 0;i&lt;m;i++)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w); add(u,v,c, w); &#125;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; if(n+m==0)&#123; break; &#125; init(); read(); printf(&quot;%d\n&quot;,MCMF(sx, ex)); &#125; return 0;&#125; 匹配匈牙利算法(邻接矩阵)123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 107;int N, K;int edge[maxn][maxn], head[maxn];bool vis[maxn];void init()&#123; memset(edge, 0, sizeof(edge)); memset(head, 0, sizeof(head));&#125;bool find_edge(int x) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (edge[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!head[i] || find_edge(head[i])) &#123; head[i] = x; return true; &#125; &#125; &#125; return false;&#125;int Magyar(int N)&#123; int ans = 0; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find_edge(i)) &#123; ans++; &#125; &#125; return ans;&#125;int main() &#123; while (cin &gt;&gt; N &gt;&gt; K) &#123; int x, y; for (int i = 1; i &lt;= K; i++)&#123; cin &gt;&gt; x &gt;&gt; y; edge[x][y] = 1; &#125; cout &lt;&lt; Magyar(N) &lt;&lt; endl; &#125; return 0;&#125; 匈牙利算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;int T, N, m;int head[maxn], link[maxn];bool vis[maxn];int cnt;struct EDGE&#123; int next, u, to, w;&#125;edge[maxn];void add(int u, int v, int w)&#123; edge[cnt].next = head[u]; edge[cnt].u = u; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt++;&#125;void init()&#123; memset(edge, 0, sizeof(edge)); memset(link, 0, sizeof(link)); memset(head, -1, sizeof(head)); cnt = 0;&#125;bool find_edge(int x)&#123; for(int i = head[x]; i!= -1; i = edge[i].next)&#123; int v = edge[i].to; if(!vis[v])&#123; vis[v] = true; if (!link[v] || find_edge(link[v])) &#123; link[v] = x; return true; &#125; &#125; &#125; return false;&#125;int Magyar(int N)&#123; int ans = 0; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find_edge(i)) &#123; ans++; &#125; &#125; return ans;&#125;int solve()&#123; int ans = Magyar(N); return ans;&#125;void read()&#123; scanf(&quot;%d%d&quot;,&amp;N, &amp;m); while(m--)&#123; int x, y; scanf(&quot;%d%d&quot;,&amp;x, &amp;y); add(x, y, 1); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; init(); read(); printf(&quot;%d\n&quot;, solve()); &#125; return 0;&#125; KM算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 207;const int maxm = 30007;const int inf = 0x3f3f3f3f;int n, m;int minD, cntx, cnty, edge[maxn][maxn];bool visx[maxn], visy[maxn];int linkx[maxn], link[maxn], wx[maxn], wy[maxn];bool dfs(int x)&#123; //匈牙利算法找增广路径 visx[x] = true; for(int i = 1; i &lt;= cnty; i++)&#123; if(!visy[i])&#123; int t = wx[x] + wy[i] - edge[x][i]; if(t == 0) &#123; visy[i] = true; if(link[i] == 0 || dfs(link[i]))&#123; linkx[x] = i; link[i] = x; return true; &#125; &#125; else if(t &gt; 0)&#123; //找出边权与顶标和的最小的差值 if(t &lt; minD)&#123; minD = t; &#125; &#125; &#125; &#125; return false;&#125;int km()&#123; memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(link, 0, sizeof link); memset(wy, 0, sizeof(wy)); for(int i = 1; i &lt;= cntx; i++)&#123; wx[i] = -inf; for(int j = 1; j &lt;= cnty; j++)&#123; if(wx[i] &lt; edge[i][j])&#123; wx[i] = edge[i][j];//初始化为权值最大的边的权值 &#125; &#125; &#125; for(int i = 1; i &lt;= cntx; i++)&#123; while(1)&#123; minD = inf; memset(visx, false, sizeof visx); memset(visy, false, sizeof visy); if(dfs(i))&#123; break; &#125; for(int j = 1; j &lt;= cntx; j++)&#123; //将交错树中X部的点的顶标减去minz if(visx[j])&#123; wx[j] -= minD; &#125; &#125; for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz if(visy[j])&#123; wy[j] += minD; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnty; i ++)&#123; if(link[i]!=0)&#123; ans += edge[link[i]][i]; &#125; &#125; return ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cntx = cnty = n; memset(edge, 0, sizeof(edge)); for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); edge[u][v] = max(edge[u][v], w); &#125; printf(&quot;%d\n&quot;, km()); &#125; return 0;&#125; KM算法最小权匹配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 207;const int maxm = 30007;const int inf = 0x3f3f3f3f;int n, m;int minD, cntx, cnty, edge[maxn][maxn];bool visx[maxn], visy[maxn];int linkx[maxn], link[maxn], wx[maxn], wy[maxn];bool dfs(int x)&#123; //匈牙利算法找增广路径 visx[x] = true; for(int i = 1; i &lt;= cnty; i++)&#123; if(!visy[i])&#123; int t = wx[x] + wy[i] - edge[x][i]; if(t == 0) &#123; visy[i] = true; if(link[i] == 0 || dfs(link[i]))&#123; linkx[x] = i; link[i] = x; return true; &#125; &#125; else if(t &gt; 0)&#123; //找出边权与顶标和的最小的差值 if(t &lt; minD)&#123; minD = t; &#125; &#125; &#125; &#125; return false;&#125;int km()&#123; memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(link, 0, sizeof link); memset(wy, 0, sizeof(wy)); for(int i = 1; i &lt;= cntx; i++)&#123; wx[i] = -inf; for(int j = 1; j &lt;= cnty; j++)&#123; if(wx[i] &lt; edge[i][j])&#123; wx[i] = edge[i][j];//初始化为权值最大的边的权值 &#125; &#125; &#125; for(int i = 1; i &lt;= cntx; i++)&#123; while(1)&#123; minD = inf; memset(visx, false, sizeof visx); memset(visy, false, sizeof visy); if(dfs(i))&#123; break; &#125; for(int j = 1; j &lt;= cntx; j++)&#123; //将交错树中X部的点的顶标减去minz if(visx[j])&#123; wx[j] -= minD; &#125; &#125; for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz if(visy[j])&#123; wy[j] += minD; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnty; i ++)&#123; if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123; ans += edge[link[i]][i]; &#125; &#125; return -ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cntx = cnty = n; for(int i = 0; i &lt;= cntx; i++)&#123; for(int j = 0; j &lt;= cnty; j++)&#123; edge[i][j] = -inf; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); edge[u][v] = max(edge[u][v], -w); &#125; printf(&quot;%d\n&quot;, km()); &#125; return 0;&#125; KM算法最小权匹配优化版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 207;const int maxm = 30007;const int inf = 0x3f3f3f3f;int n, m;int minD, cntx, cnty, edge[maxn][maxn];bool visx[maxn], visy[maxn];int linkx[maxn], link[maxn], wx[maxn], wy[maxn];bool dfs(int x)&#123; //匈牙利算法找增广路径 visx[x] = true; for(int i = 1; i &lt;= cnty; i++)&#123; if(!visy[i])&#123; int t = wx[x] + wy[i] - edge[x][i]; if(t == 0) &#123; visy[i] = true; if(link[i] == 0 || dfs(link[i]))&#123; linkx[x] = i; link[i] = x; return true; &#125; &#125; else if(t &gt; 0)&#123; //找出边权与顶标和的最小的差值 if(t &lt; minD)&#123; minD = t; &#125; &#125; &#125; &#125; return false;&#125;int km()&#123; memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(link, 0, sizeof link); memset(wy, 0, sizeof(wy)); for(int i = 1; i &lt;= cntx; i++)&#123; wx[i] = -inf; for(int j = 1; j &lt;= cnty; j++)&#123; if(wx[i] &lt; edge[i][j])&#123; wx[i] = edge[i][j];//初始化为权值最大的边的权值 &#125; &#125; &#125; for(int i = 1; i &lt;= cntx; i++)&#123; while(1)&#123; minD = inf; memset(visx, false, sizeof visx); memset(visy, false, sizeof visy); if(dfs(i))&#123; break; &#125; for(int j = 1; j &lt;= cntx; j++)&#123; //将交错树中X部的点的顶标减去minz if(visx[j])&#123; wx[j] -= minD; &#125; &#125; for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz if(visy[j])&#123; wy[j] += minD; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnty; i ++)&#123; if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123; ans += edge[link[i]][i]; &#125; &#125; return -ans;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cntx = cnty = n; for(int i = 0; i &lt;= cntx; i++)&#123; for(int j = 0; j &lt;= cnty; j++)&#123; edge[i][j] = -inf; &#125; &#125; for(int i = 0; i &lt; m; i++)&#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); edge[u][v] = max(edge[u][v], -w); &#125; printf(&quot;%d\n&quot;, km()); &#125; return 0;&#125; 强连通Tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 7;const int inf = 0x3f3f3f3f;int n, m;int head[maxn], cnt, top, dfs_num, col_num;int dfn[maxn], low[maxn], Stack[maxn], color[maxn];bool vis[maxn];struct EDGE&#123; int next, to, u;&#125;edge[maxn&lt;&lt;3];void add(int u, int v)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].u = u; head[u] = cnt++;&#125;void Tarjan(int x)&#123; dfn[x] = ++dfs_num; low[x] = dfs_num; vis[x] = true; //是否在栈中 Stack[++top] = x; for(int i = head[x]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if(!dfn[v])&#123; Tarjan(v); low[x] = min(low[x], low[v]); &#125; else if(vis[v])&#123; low[x] = min(low[x], dfn[v]); &#125; &#125; if(dfn[x] == low[x])&#123; //构成强连通分量 vis[x] = false; color[x] = ++col_num; //染色 while(Stack[top] != x)&#123; //清空 color[Stack[top]] = col_num; vis [ Stack[ top-- ] ] = false ; &#125; top--; &#125;&#125;void init()&#123; top = dfs_num = col_num = cnt = 0; memset(head, -1, sizeof(head)); memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(color, 0, sizeof(color)); memset(vis, false, sizeof(vis));&#125;void read()&#123; int u, v; for(int i = 0; i &lt; m; i++)&#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); add(u, v); &#125;&#125;void solve()&#123; for(int i = 1; i &lt;= n; i++)&#123; if(!color[i])&#123; Tarjan(i); &#125; &#125; if(col_num != 1)&#123; printf(&quot;No\n&quot;); &#125; else&#123; printf(&quot;Yes\n&quot;); &#125;&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m)&#123; init(); read(); solve(); &#125; return 0;&#125; 数论gcd123int gcd(int a, int b)&#123; return !b ? a : gcd(b, a%b);&#125; 快速乘如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。 O(logn)快速乘123456789inline LL quick_mul(LL a,LL n,LL m)&#123; LL ans=0; while(n)&#123; if(n&amp;1) ans=(ans+a)%m; a=(a&lt;&lt;1)%m; n&gt;&gt;=1; &#125; return ans;&#125; O(1)快速乘12345678typedef long long ll;#define MOL 123456789012345LLinline ll mul_mod_ll(ll a,ll b)&#123; ll d=(ll)floor(a*(long double)b/MOL+0.5); ll ret=a*b-d*MOL; if(ret&lt;0) ret+=MOL; return ret;&#125; 首先，使用浮点数计算 ab/MOL 的值，关键在于第二句，显然 ab - d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。 考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。 模板123inline ll ksc(ll x,ll y,ll mod)&#123; return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod; &#125; 因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。 其他离散化12345678int getid(int x)&#123; return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;&#125; for(int i = 1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); &#125; sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end()); 位运算统计1的个数12345678int NumberOfOne(int n) &#123; int count = 0; while(n) &#123; n &amp;= (n-1); count++; &#125; return count;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAIPC2016-F.Mountain Scenes]]></title>
    <url>%2F2018%2F10%2F02%2F2018-10-02%2F</url>
    <content type="text"><![CDATA[1000ms 262144K An artist begins with a roll of ribbon, one inch wide. She clips it into pieces of various integral lengths, then aligns them with the bottom of a frame, rising vertically in columns, to form a mountain scene. A mountain scene must be uneven; if all columns are the same height, it’s a plain scene, not a mountain scene! It is possible that she may not use all of the ribbon. If our artist has 44 inches of ribbon and a 2 \times 22×2 inch frame, she could form these scenes: She would not form these scenes, because they’re plains, not mountains! Given the length of the ribbon and the width and height of the frame, all in inches, how many different mountain scenes can she create? Two scenes are different if the regions covered by ribbon are different. There’s no point in putting more than one piece of ribbon in any column. InputEach input will consist of a single test case. Note that your program may be run multiple times on different inputs. The input will consist of a single line with three space-separated integers nn, ww and hh, where nn (0 \le n \le 10,000)(0≤n≤10,000) is the length of the ribbon in inches, w (1 \le w \le 100)w(1≤w≤100) is the width and hh (1 \le h \le 100)(1≤h≤100)is the height of the frame, both in inches. OutputOutput a single integer, indicating the total number of mountain scenes our artist could possibly make, modulo 10^9 + 7109+7. 样例输入1复制125 5 5 样例输出1复制17770 样例输入2复制115 5 5 样例输出2复制16050 样例输入3复制110 10 1 样例输出3复制11022 题解问题可以转化为有n个物品，现有w个盘子，每个盘子的容量为[0,h]，所有盘子放的物品不能全部相同，n个物品选[0,n]个物品放进盘中，共有多少种方法。 首先，利用dp，第一层i为第i个盘子，第2层j为前i个盘子共放置j个物品共有多少种方法。这样dp[i][j]+=dp[i-1][j-k]，其中k[0,h] 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxn = 1e4+7;const ll mod = 1e9+7;ll dp[107][maxn];ll n,w,h;ll solve()&#123; memset(dp,0,sizeof(dp)); ll ans = 0; if(n &gt; w * h)&#123; n = w*h; &#125; for(int i = 0;i&lt;=n;i++)&#123; dp[0][i] = 1; &#125; for(int i = 1; i&lt;=w; i++)&#123; for(int j = 0;j&lt;=n; j++)&#123; for(int k = 0; k&lt;=h&amp;&amp;k&lt;=j; k++)&#123; dp[i][j]+=dp[i-1][j-k]; dp[i][j]%=mod; &#125; &#125; &#125; ans = (dp[w][n] - 1 - n/w + mod)%mod; return ans;&#125;int main()&#123; while(~scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;w,&amp;h))&#123; printf(&quot;%lld\n&quot;,solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分时最短路+次小生成树+最小费用最大流题解]]></title>
    <url>%2F2018%2F09%2F29%2F2018-09-29%2F</url>
    <content type="text"><![CDATA[问题 A: 高速时间限制: 1 Sec 内存限制: 128 MB提交: 15 解决: 4[提交][状态][讨论版][命题人:qianyouyou] 题目描述教练开车去东北，因为比赛地点在东北。共有 n 座城，已知教练在 s 城，比赛地点在 t 城，n 座城之间共有 m 条高速，每条高速连接两座城市，每两座城市之间最多两条高速。每条高速都有权值 v，表示两个城市之间最快可以 v 小时到达。 然而高速不是永久开放的，每条高速都会有一段开放时间 [ a，b ]，表示该高速在 a ~ b 小时范围之间开放，其余时间处于关闭状态，不能通过任何车辆。例如 [ 24，27 ]表示该路在第 24 小时到 27 小时之间开放。 已知教练在 0 时刻出发，他最快多少小时可以到达 t 城。 （PS：由于刹车坏掉了，因此车一旦启动就不能停下来，也就是说车不能停于某点或某边，不过车可以来回无限次在两地之间穿梭） 输入多组测试样例，首行输入 t，表示 t 组样例。 图为无向图，s 城固定为 1 点，t 城固定为 n 点。 每组样例第 1 行，输入n，m（1 &lt; n ≤ 100，0 &lt; m ≤ 1000）。 接下来 m 行，每行 5 个数值x，y，v，l，f。表示 x 与 y 有一条高速，耗时为 v。该路开放时间为[ l，f ]。 数据保证教练可以到达终点，只不过是时间问题。 输出输出一个数值，即最少耗时。 样例输入12345615 42 3 1 5 112 5 1 3 184 3 1 7 141 4 1 0 15 样例输出110 tag：图论、分时最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//最短路#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxx = 0x3f3f3f3f;const int maxn = 1e5+7;int t,n,m,cnt;int dis[maxn]; //当前该点到原点最短距离bool vis[maxn]; //是否访问过int head[maxn]; //点集struct EDGE&#123; int next,to,w,l,r; //上一条边，下一个点，权值，左值，右值&#125;edge[2*maxn]; //边集struct NODE&#123; int u,dis; NODE()&#123;&#125; NODE(int u,ll w):u(u),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const&#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn]; //点集加最短距离void add(int u, int v, int w, int l,int r)&#123; //构建边集 edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].l = l; edge[cnt].r = r; head[u] = cnt; cnt++;&#125;void init()&#123; //初始化 cnt = 0; memset(head,-1,sizeof(head)); memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis));&#125;void read()&#123; //读入数据 int u,v,w,l,r; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 0;i &lt; m; i++)&#123; scanf(&quot;%d%d%d%d%d&quot;,&amp;u,&amp;v,&amp;w,&amp;l,&amp;r); add(u,v,w,l,r); add(v,u,w,l,r); &#125;&#125;void init_data(int kk)&#123; //初始化数据 vis[kk] = false; dis[kk] = maxx;&#125;int solve(int s)&#123; priority_queue&lt;NODE&gt;q; //储存最短距离 q.push(NODE(s,0)); //读入原点 while(!q.empty())&#123; //队列为空则无法到达 int kk = q.top().u; //储存当前最短距离下标 int minD = q.top().dis; //储存当前最短距离 q.pop(); if(kk==n) //若下标为目标值，return return minD; vis[kk] = true; //该点是否访问 for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; //松弛边 if(!vis[edge[l].to]&amp;&amp;minD&lt;=edge[l].r&amp;&amp;minD&gt;=edge[l].l&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123; dis[edge[l].to] = minD + edge[l].w; q.push(NODE(edge[l].to,dis[edge[l].to])); //将松弛后的边压入队列 &#125; &#125; init_data(kk); //初始化数据 &#125; return 0;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; init(); //初始化 read(); //读入 printf(&quot;%d\n&quot;,solve(1)); //解决方案 &#125; return 0;&#125; 问题 C: 千年老二时间限制: 1 Sec 内存限制: 128 MB提交: 24 解决: 12[提交][状态][讨论版][命题人:qianyouyou] 题目描述雷婷与万钧是青梅竹马，无论是考试还是玩游戏，雷婷总是第一，而万钧总是第二，尽管万钧有做第一的实力，但他每次都会把第一让给雷婷，仅因为每次读榜单时雷霆万钧听起来是那么顺耳。这天，雷婷参加了 acm 选拔，万钧也跟着雷婷参加。题目是这样的： 有 n 个节点，编号为 1~n，有 m 条边，每条边都有一个距离。两点之间最多只有 1 条边。现在你需要选取 n-1 条边，使得所有点都连接起来都有通路。n-1 条边距离之和越小分数越高。 万钧立马意识到这道题是求最小生成树的，并且每个人的答案不能相同，万钧根据瞪眼法立马瞪出了答案，然而他还是等待雷婷先做完。现在雷婷已经找到了距离最短的1种方案，不过他俩太心有灵犀了，答案一模一样，万钧想获得第 2 名，请你帮万钧想一种方案，距离之和越短越好，但不能和雷婷的结果相同。一条边不同即可认为不同。如果找不到输出 -1。当然存在一种情况，如果雷婷的方案是没有方案求出最短距离，即表示该图没有最小生成树，即输出 -1。总之雷婷的方案是最优解的一种。 输入存在多组数据，第一行一个正整数 t，表示有 t 组数据。 每组数据第一行有两个整数 n 和 m（2 ≤ n ≤ 100，1 ≤ m ≤ 1000)，之后 m 行，每行三个正整数 s，e，w，表示 s 到 e 的双向路的权值为 w。 输出输出次小生成树的值（如果存在多个最小生成树或仅有一个树，则次小生成树就是最小生成树，输出-1），如果不存在输出 -1。 样例输入1234513 33 1 31 2 12 3 2 样例输出14 tag：图论、次小生成树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//次小生成树#include&lt;bits/stdc++.h&gt;using namespace std;const int L=1e5+7;const int inf=0x3f3f3f3f;const int maxn=1000+7;int father[maxn],n,m,num[maxn],nPos; //父节点（并查集），点数，边数，最小生成树点集，当前访问方位struct node&#123; int s,y,w;&#125;edge[L]; //边集，左端点，右端点，权值void init()&#123; //初始化并查集 for(int i=0;i&lt;=n;i++) father[i]=i;&#125;int root(int x)&#123; //并查集，构造父节点 return father[x]==x?x:father[x]=root(father[x]);&#125;void unite(int x,int y)&#123; //并查集，合并两个联通图 x=root(x); y=root(y); if(x!=y) father[y]=x;&#125;int alike(int x,int y)&#123; //并查集，判断是否为同一连通图 return root(x)==root(y);&#125;int cmp(node a,node b)&#123; //sort结构体排序 return a.w&lt;b.w;&#125;int secondTree(int pos) //次小生成树&#123; init(); //初始化 int sum=0,cnt=0; for(int i=0;i&lt;m;i++) //对于删去边后的图进行最小生成树运算 &#123; if(cnt==n-1) break; if(i==pos) continue; if(!alike(edge[i].s,edge[i].y))&#123; unite(edge[i].s,edge[i].y); sum+=edge[i].w; cnt++; &#125; &#125; return cnt!=n-1?-1:sum; //判断删除边后是否能构成最小生成树&#125;int kruskal()&#123; //最小生成树 init(); sort(edge,edge+m,cmp); //对边进行权值排序 int sum=0,cnt=0; for(int i=0;i&lt;m;i++) //每次选择最小且未访问过的一条边 &#123; if(cnt==n-1) break; if(!alike(edge[i].s,edge[i].y))&#123; unite(edge[i].s,edge[i].y); sum+=edge[i].w; cnt++; num[++nPos]=i; &#125; &#125; return cnt!=n-1?-1:sum; //判断边是否大于等于n-1，否则输出-1&#125;void read()&#123; //读入数据 scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf(&quot;%d%d%d&quot;,&amp;edge[i].s,&amp;edge[i].y,&amp;edge[i].w);&#125;void solve()&#123; //解决方案 int Min=inf; nPos=0; int mst=kruskal(); //最小生成树值 if(mst==-1) &#123; //没有最小生成树即输出-1 printf(&quot;-1\n&quot;); return; &#125; for(int i=1;i&lt;=nPos;i++)&#123; //对最小生成树的每条边进行遍历，选择删边后的最小值 int secmst=secondTree(num[i]); if(secmst!=-1) //若没有次小生成树输出-1 Min=min(Min,secmst); &#125; if(Min!=inf&amp;&amp;Min!=mst) printf(&quot;%d\n&quot;,Min); //输出结果 else printf(&quot;-1\n&quot;);&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; read(); //读入数据 solve(); //解决方案 &#125; return 0;&#125; 问题 F: 给力台球厅时间限制: 1 Sec 内存限制: 128 MB提交: 10 解决: 3[提交][状态][讨论版][命题人:qianyouyou] 题目描述教练爱打台球。这天偶遇一家台球厅，便进去看看。然而这家台球厅貌似和平常的台球厅不太一样，它的每张桌面上的洞都是随机分布在桌面上的，球也是随机摆放的。 教练立即意识到，此台球厅的桌面不符合正态分布之概率密度函数，而是呈离散分布，顿时患有强迫症的教练心里就不舒服了。为了平缓一下翻腾的内心，教练随机选取了一张球和洞数量一样的球桌，望着奇怪的桌面与奇怪的球，教练脑袋上不禁长出了大把大把的草：如果能求出所有球入洞的最短距离之和该有多好啊。 现有一个桌面面积为 n×m 的台球桌，将台球桌分成 n×m 个小格，台球桌上有许多的洞和许多的球，均匀分布在小格里，且每个小格只有三种状态，有球，有洞，空白。球用 @ 表示，洞用 # 表示，空白的地方用 * 表示。每个洞只能容纳一个球，球每次只能按照上下左右的方向移动，且每移动一格视为移动 1 个单位长度。当一个球被另一个球挡住时，它可以跳球，所以每一个球都可以完全无视其他球或洞的存在而继续前行，直到进自己心仪的洞。现求所有球进洞的距离之和最小是多少。如果你能帮教练解决这道题，恭喜你就是 ACM 队员了（每个球只能进一个洞，每个洞内有球的话就变成空白状态） 输入多组测试样例，首行输入 m，n，即矩形台球桌面的边长。(2 ≤ m，n ≤ 20，球最多100个，洞最多100个，保证洞和球数量相等) 输出输出一个整数，即所有球入洞的距离最短是多少。 样例输入12345678910112 2*#@*7 8****#*******#*******#***@@@@#@@@****#*******#*******#*** 样例输出12228 tag：图论、最小费用最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//网络流#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f; //无穷大const int maxn = 60007;const int maxm = 1000007;int vis[maxn],d[maxn],pre[maxn],a[maxn],m,n; //是否访问，最短路，前置节点，流量，边集，点集char mp[107][107]; //台球地图struct Edge&#123; int u, v, c, cost, next;&#125;edge[maxm]; //网络流边集int s[maxn], cnt; //每个点流量void init()&#123; //初始化 cnt = 0; memset(s, -1, sizeof(s));&#125;void add(int u, int v, int c, int cost)&#123; //对两点之间进行单向边建立 edge[cnt].u = u; edge[cnt].v = v; edge[cnt].cost = cost; edge[cnt].c = c; edge[cnt].next = s[u]; s[u] = cnt++; //建立单向边 edge[cnt].u = v; edge[cnt].v = u; edge[cnt].cost = -cost; edge[cnt].c = 0; edge[cnt].next = s[v]; s[v] = cnt++; //建立双向边&#125;bool spfa(int ss, int ee,int &amp;flow,int &amp;cost)&#123; //以距离为费用寻找最短路，以最短路为当前增广路 queue&lt;int&gt; q; memset(d, INF, sizeof d); memset(vis, 0, sizeof vis); //初始化 d[ss] = 0, vis[ss] = 1, pre[ss] = 0, a[ss] = INF; q.push(ss); while (!q.empty())&#123; //spfa以费用为距离寻找最短路 int u = q.front();q.pop(); vis[u] = 0; for (int i = s[u]; ~i; i = edge[i].next)&#123; //和当前点相连所有边松弛过程 int v = edge[i].v; if (edge[i].c&gt;0&amp;&amp; d[v]&gt;d[u] + edge[i].cost)&#123; //松弛过程 d[v] = d[u] + edge[i].cost; pre[v] = i; a[v] = min(a[u], edge[i].c); //取最小值 if (!vis[v])&#123; vis[v] = 1; q.push(v); //压入待松弛队列 &#125; &#125; &#125; &#125; if (d[ee] == INF) return 0; //判断是否有最短路，无说明最大流完成 flow += a[ee]; cost += d[ee]*a[ee]; int u = ee; while (u != ss)&#123; //求当前最短路下的流量和 edge[pre[u]].c -= a[ee]; edge[pre[u] ^ 1].c += a[ee]; u = edge[pre[u]].u; &#125; return 1;&#125;int MCMF(int ss, int ee)&#123; //最小费用最大流 int cost = 0, flow=0; //初始化 while (spfa(ss, ee, flow, cost)); //寻找增广路径，直到没有增广路径为止 return cost; //返回最大流费用&#125;struct point&#123; int x,y; //球坐标，洞坐标&#125;;void solve()&#123; point H[107],P[107]; //建立球集与洞集 int h=0,p=0; for(int i=0;i&lt;n;i++)&#123; //输入地图 scanf(&quot;%s&quot;,&amp;mp[i]); for(int j=0;j&lt;m;j++)&#123; if(mp[i][j]==&apos;#&apos;)&#123; //若为洞则坐标加入洞集 H[h].x=i; H[h].y=j; h++; &#125; else if(mp[i][j]==&apos;@&apos;)&#123; //若为球则坐标加入球集 P[p].x=i; P[p].y=j; p++; &#125; &#125; &#125; init(); //初始化 for(int i=0;i&lt;h;i++) for(int j=0;j&lt;p;j++)&#123; int c=fabs(H[i].x-P[j].x)+fabs(H[i].y-P[j].y); add(i+1,h+j+1,1,c); &#125; //建立球与洞之间的路径 for(int i=0;i&lt;h;i++) //建立超级源点 add(0,i+1,1,0); for(int i=0;i&lt;p;i++) //建立超级汇点 add(h+1+i,h+p+1,1,0); printf(&quot;%d\n&quot;,MCMF(0,h+p+1)); //最小费用最大流&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; if(!(m||n)) break; solve(); //解决方案 &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>最小费用最大流</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用容斥原理求解范围内互素数对数例题]]></title>
    <url>%2F2018%2F09%2F26%2F2018-09-26%2F</url>
    <content type="text"><![CDATA[GCDGiven 5 integers: a, b, c, d, k, you’re to find x in a…b, y in c…d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs.Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.Yoiu can assume that a = c = 1 in all test cases. Input The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.Each case contains five integers: a, b, c, d, k, 0 &lt; a &lt;= b &lt;= 100,000, 0 &lt; c &lt;= d &lt;= 100,000, 0 &lt;= k &lt;= 100,000, as described above. Output For each test case, print the number of choices. Use the format in the example. Sample Input 12321 3 1 5 11 11014 1 14409 9 Sample Output 12Case 1: 9Case 2: 736427 Hint 1For the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5). 题意： 求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数 题解： gcd(a,b)=k，我们可以写成gcd(a/k,b/k)=1。因此我们只需求[1,b/k]和[1,d/k]范围内互素数的对数。首先利用欧拉函数很容易求解[1,min(a,b)]范围内互素数的对数，将φ(1~min(a,b))全部加起来，就求出1~min(a,b)所有互素对数，假设d永远＞=b,那么接下来我们只需求[1,b]范围内和[b+1,d]范围内互素的数，此时需用容斥原理。对于[1,b]范围内和x互素的数，最多为b个，而在这b个数中我们只需减去不互素的对数即可。我们需先求出x的所有质因数，然后这些质因数的倍数在[1,b]范围内的个数为b/g，因此只需减去这些对数即可，然而由于会有重复的情况出现，因此需用容斥原理处理一下。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;typedef long long ll;ll oula[maxn];int a,b,c,d,k;struct Number&#123; int cnt; int prime[20];&#125; fac[maxn];void getLa( int n)&#123; memset(fac,0,sizeof(fac)); for(int i = 0; i &lt; n; ++i) oula[i] = i; for(int i = 2; i &lt; n; ++i) if( oula[i] == i ) for(int j = 1; j*i &lt; n; ++j)&#123; oula[j*i] -= oula[j*i]/i; fac[j*i].prime[fac[j*i].cnt++]=i; &#125;&#125;ll inc(int index,int b,int m)&#123; ll r=0,t; for(int i=index; i&lt;fac[m].cnt; ++i) &#123; t=b/fac[m].prime[i];//b范围内有多少个数和m的因数为prime[i] r+=t-inc(i+1,t,m);//减去这些数就是b范围内和m互质的数的个数。 &#125; return r;&#125;ll solve()&#123; b/=k; d/=k; if(b&gt;d) swap(b,d); ll ans = 0; for(int i = 1; i &lt;= b; ++i) ans+=oula[i]; for(int i=b+1; i&lt;=d; ++i) ans+=b-inc(0,b,i); return ans;&#125;int main()&#123; getLa(maxn); int t; scanf(&quot;%d&quot;,&amp;t); for(int cas = 1; cas&lt;=t; ++cas)&#123; scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); if(k==0)&#123; printf(&quot;Case %d: 0\n&quot;,cas); continue; &#125; printf(&quot;Case %d: %lld\n&quot;,cas,solve()); &#125; return 0;&#125; 下面那道和上面这道类似，稍微改一下就好。 Visible TreesThere are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see.If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him. Input The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000) Output For each test case output one line represents the number of trees Farmer Sherlock can see. Sample Input 12321 12 3 Sample Output 1215 题意 求解[1,b]范围内和[1,d]范围内最大公约数为k的二元组的对数。当然和上面不同之处在于对数左右数不同也认为不同。(2,3)和(3,2)为不同的对数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;typedef long long ll;ll oula[maxn];int m,n;struct Number&#123; int cnt; int prime[20];&#125; fac[maxn];void getLa( int n)&#123; memset(fac,0,sizeof(fac)); for(int i = 0; i &lt; n; ++i) oula[i] = i; for(int i = 2; i &lt; n; ++i) if( oula[i] == i ) for(int j = 1; j*i &lt; n; ++j)&#123; oula[j*i] -= oula[j*i]/i; fac[j*i].prime[fac[j*i].cnt++]=i; &#125;&#125;ll inc(int index,int b,int m)&#123; ll r=0,t; for(int i=index; i&lt;fac[m].cnt; ++i) &#123; t=b/fac[m].prime[i]; r+=t-inc(i+1,t,m); &#125; return r;&#125;ll solve()&#123; if(m&gt;n) swap(m,n); ll ans = 0; for(int i = 1; i &lt;= m; ++i) ans+=oula[i]; ans=ans*2-1; for(int i=m+1; i&lt;=n; ++i) ans+=m-inc(0,m,i); return ans;&#125;int main()&#123; getLa(maxn); int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); printf(&quot;%lld\n&quot;,solve()); &#125; return 0;&#125; 跳蚤Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 Input 两个整数N和M(N &lt;= 15 , M &lt;= 100000000)。 Output 可以完成任务的卡片数。 Sample Input 12 4 Sample Output 112 Hint 这12张卡片分别是：(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4),(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long long intusing namespace std;const int maxn = 1005,maxm = 100005,INF = 1000000000;LL N,M;int fac[maxn],faci = 0;void Sp()&#123; LL e = M; for (LL i = 2; i * i &lt;= e; i++)&#123; if (e % i == 0)&#123; fac[++faci] = i; while (e % i == 0) e /= i; &#125; &#125; if (e - 1) fac[++faci] = e;&#125;LL qpow(LL a,LL b)&#123; LL ans = 1; for (; b; b &gt;&gt;= 1, a *= a) if (b &amp; 1) ans *= a; return ans;&#125;LL cal(int s)&#123; LL mult = 1,pos = 1; for (int i = 1; s; i++,s &gt;&gt;= 1)&#123; if (s &amp; 1)&#123; mult *= fac[i]; pos *= -1; &#125; &#125; return qpow(M/mult,N) * pos;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
        <tag>gcd</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容斥原理的三种运用方式]]></title>
    <url>%2F2018%2F09%2F25%2F2018-09-25-1%2F</url>
    <content type="text"><![CDATA[在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 集合相交通常情况为奇加偶减，即加上重叠为奇次的，减去重叠为偶次的。 容斥原理是属于一种模板题目，一般简单的都是之间打模板，稍难的题目运用到了数学分析和数论的其他知识。 容斥原理分为三种实现： 1.位运算与二进制枚举（容易理解） 2.队列数组（耗时最短） 3.递归（代码最短但不容易理解） http://blog.csdn.net/deepseazbw/article/details/76187211 HDU的一道题目用的三种方法实现，一般都是找出一个数字的素因子，然后用cnt（计算器）记录下来，然后分别三种方法实现. 实现容斥原理的时候 1.先计算出容斥部分，然后再用总数减去 http://blog.csdn.net/deepseazbw/article/details/76187211 2.在容斥部分的时候，就将总数带入进去 http://blog.csdn.net/deepseazbw/article/details/76660935 模板题目： HDU 4135 1695]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求解逆元的3种方法]]></title>
    <url>%2F2018%2F09%2F25%2F2018-09-25%2F</url>
    <content type="text"><![CDATA[简述逆元逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。 比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p 观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。 注意在下面所有的算法中，最好先把除数取个模再运算。 方法一：扩展欧几里得算法原理a∗b≡1(modp)a∗b≡1(modp) a∗b+k∗p=1a∗b+k∗p=1 然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。 如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元 代码1234567891011121314151617LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 &#123; if(b==0) &#123; x=1,y=0; return a; &#125; LL ret=exgcd(b,a%b,y,x); y-=a/b*x; return ret;&#125;LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 &#123; LL x,y; LL d=exgcd(a,mod,x,y); return d==1?(x%mod+mod)%mod:-1;&#125;1234567891011121314151617 注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大. 性能分析: 时间复杂度:O(logn)（实际是斐波那契数列） 适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。 方法二:费马小定理/欧拉定理原理费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp) ap−2∗a≡1(modp)ap−2∗a≡1(modp) ap−2ap−2就是a在mod p意义下的逆元啦。 欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式) aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp) aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。 代码123456789101112131415LL qkpow(LL a,LL p,LL mod)&#123; LL t=1,tt=a%mod; while(p) &#123; if(p&amp;1)t=t*tt%mod; tt=tt*tt%mod; p&gt;&gt;=1; &#125; return t;&#125;LL getInv(LL a,LL mod)&#123; return qkpow(a,mod-2,mod);&#125;123456789101112131415 性能分析： O(logmod) 适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。 但是如果是合数，相信一般没人无聊到去算个欧拉函数。 方法三：递推求逆元原理p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值 p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i k∗i+r≡0(modp)k∗i+r≡0(modp) k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp) i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp) i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi] 嗯。。好难看的公式 说白了就是:inv[i]=-(mod/i)*inv[i%mod] 然后边界是inv[1]=1 这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法 代码线性求逆元1234567LL inv[mod+5];void getInv(LL mod)&#123; inv[1]=1; for(int i=2;i&lt;mod;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;&#125;1234567 注意： 调用前要先预处理 调用的时候要先对除数取mod 性能分析： 时间复杂度O(n) 适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。 递归求逆元12345LL inv(LL i)&#123; if(i==1)return 1; return (mod-mod/i)*inv(mod%i)%mod;&#125;12345 性能分析 时间复杂度:O(logmod) 好像找到了最简单的算法了！！ 适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>逆元</tag>
        <tag>exgcd</tag>
        <tag>费马小定理</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数小结]]></title>
    <url>%2F2018%2F09%2F24%2F2018-09-24%2F</url>
    <content type="text"><![CDATA[母函数母函数是用于解决组合问题计数的一种方法。 在了解它之前我们先看看熟悉的杨辉三角。 杨辉三角的第n行(注意是从0开始标号的)的数字就是(1+x)n(1+x)n的展开式从低项到高项的各项系数，也可以表示为组合数的形式CinCni。如果将两者联系起来我们会发现，(1+x)(1+x)可以看成对于一件取舍，1=x01=x0就是不取，x就是取。这样在(1+x)n(1+x)n的展开式中xixi项的系数就是从n件物品选取i件的方案数。 定义给定数列a0,a1,a2…ana0,a1,a2…an，构造函数G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x)G(x)=a0f0(x)+a1f1(x)+a2f2(x)…anfn(x),其中G(x)G(x)就是该序列的母函数，f0(x),f1(x),f2(x)…fn(x)f0(x),f1(x),f2(x)…fn(x)为标志函数。 母函数主要有两种形式：普通型母函数和指数型母函数。 普通型母函数先看一个例题：HDU 1085 普通型母函数的标志函数一般为x0，x1,x2…xnx0，x1,x2…xn 因为每个硬币有个数限制，但是也不难构造出 G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5)G(x)=(1+x+x2+x3+…+xnum1)(1+x2+x4+…+x2∗num2)(1+x5+x10+…+x5∗num5) xixi 指数型母函数再看一个例题：HDU 1521 指数型母函数的标志函数一般为x00!,x11!,x22!…xnn!x00!,x11!,x22!…xnn!，对于xii!xii!表示在一个方案中某个元素出现了ii次，而不同位置的该种元素本质不同，所以在记方案数时只算作一种，所以最后结果应处以i！i！。 对于这道题就不难构造出母函数为 G(x)=(1/ 0!+X / 1!+X2 / 2!+…+Xa1 / a1!)(1 / 0!+X / 1!+X2 / 2!+…+Xa2 / a2!)( / 0!+X / 1!+X2 / 2!+…+Xan / an!)]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM/ICPC北京网络赛D题 80 Days（非暴力0(n)解法）]]></title>
    <url>%2F2018%2F09%2F22%2F2018-09-22-1%2F</url>
    <content type="text"><![CDATA[描述80 Days is an interesting game based on Jules Verne’s science fiction “Around the World in Eighty Days”. In this game, you have to manage the limited money and time. Now we simplified the game as below: There are n cities on a circle around the world which are numbered from 1 to n by their order on the circle. When you reach the city i at the first time, you will get ai dollars (ai can even be negative), and if you want to go to the next city on the circle, you should pay bi dollars. At the beginning you have c dollars. The goal of this game is to choose a city as start point, then go along the circle and visit all the city once, and finally return to the start point. During the trip, the money you have must be no less than zero. Here comes a question: to complete the trip, which city will you choose to be the start city? If there are multiple answers, please output the one with the smallest number. 输入The first line of the input is an integer T (T ≤ 100), the number of test cases. For each test case, the first line contains two integers n and c (1 ≤ n ≤ 10^6, 0 ≤ c ≤ 10^9). The second line contains n integers a1, …, an (-10^9 ≤ ai ≤ 10^9), and the third line contains n integers b1, …, bn (0 ≤ bi ≤ 10^9). It’s guaranteed that the sum of n of all test cases is less than 106 输出For each test case, output the start city you should choose. 提示For test case 1, both city 2 and 3 could be chosen as start point, 2 has smaller number. But if you start at city 1, you can’t go anywhere. For test case 2, start from which city seems doesn’t matter, you just don’t have enough money to complete a trip. 利用前缀和与后缀和优化dp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst LL maxn = 1e6+7;LL a[maxn],b[maxn],cha[maxn],qian[maxn],qian2[maxn], hou[maxn], hou2[maxn];void init(LL n,LL c)&#123; hou[n+1] = qian[0] = 0; hou2[n] = hou[n] = cha[n]; qian2[1] = qian[1] = cha[1]; for(int i = 2;i&lt;=n;i++)&#123; qian[i] = cha[i]+qian[i-1]; qian2[i] = min(qian[i],qian2[i-1]); &#125; LL sum = 0; for(int i = n-1;i&gt;0;i--)&#123; hou[i] = cha[i]+hou[i+1]; hou2[i] = min(hou[i]-sum,cha[i]); if(hou2[i]&gt;=0)&#123; sum=hou[i]; hou2[i]=0; &#125; &#125;&#125;int fun(LL n,LL c)&#123; if(qian[n]+c&lt;0) return -1; for(int i = 1;i&lt;=n;i++)&#123; if(cha[i]+c&gt;=0&amp;&amp;cha[i]+c+hou2[i+1]&gt;=0)&#123; if(hou[i]+c+qian2[i-1]&gt;=0)&#123; return i; &#125; &#125; &#125; return -1;&#125;int main()&#123; int t; LL n,c; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;c); for(int i = 1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; for(int i = 1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;b[i]); cha[i] = a[i] - b[i]; &#125; init(n,c); int tmp = fun(n,c); printf(&quot;%d\n&quot;,tmp); &#125; return 0;&#125; 尺取法 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#define MAX 1000005 int p[MAX&lt;&lt;1],a[MAX],b[MAX]; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n; long long c; scanf(&quot;%d%lld&quot;,&amp;n,&amp;c); for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); &#125; for(int i = 1;i &lt;= n;i++) &#123; p[i] = p[i + n] = a[i] - b[i]; &#125; int l = 1,r = 1; while(l &lt;= n &amp;&amp; r - l + 1 &lt;= n) &#123; c = c + p[r]; r ++; while(c &lt; 0) &#123; c = c - p[l]; l ++; &#125; &#125; if(l &gt; n) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;,l); &#125;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>动态规划</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[组合数学]动态规划解决整数划分问题]]></title>
    <url>%2F2018%2F09%2F22%2F2018-09-22%2F</url>
    <content type="text"><![CDATA[整数划分问题是将一个正整数n拆成一组数连加并等于n的形式，且这组数中的最大加数不大于n。 如6的整数划分为： 6 6 5 5 + 1 4 4 + 2, 4 + 1 + 1 3 3 + 3, 3 + 2 + 1, 3 + 1 + 1 + 1 2 2 + 2 + 2, 2 + 2 + 1 + 1, 2 + 1 + 1 + 1 + 1 1 1 + 1 + 1 + 1 + 1 + 1 设n为要划分的正整数，m是划分中的最大加数(当m &gt; n时，最大加数为n)， 1 当n = 1或m = 1时，split的值为1，可根据上例看出，只有一个划分1 或 1 + 1 + 1 + 1 + 1 + 1 可用程序表示为if(n == 1 || m == 1) return 1; 2 下面看一看m 和 n的关系。它们有三种关系 (1) m &gt; n 在整数划分中实际上最大加数不能大于n，因此在这种情况可以等价为split(n, n); 可用程序表示为if(m &gt; n) return split(n, n); (2) m = n 这种情况可用递归表示为split(n, m - 1) + 1，从以上例子中可以看出，就是最大加 数为6和小于6的划分之和 用程序表示为if(m == n) return (split(n, m - 1) + 1); (3) m &lt; n 这是最一般的情况，在划分的大多数时都是这种情况。 从上例可以看出，设m = 4，那split(6, 4)的值是最大加数小于4划分数和整数2的划分数的和。 因此，split(n, m)可表示为split(n, m - 1) + split(n - m, m) hdu1028 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 121;int n, dp[maxn][maxn];void init()&#123; memset(dp,0,sizeof(dp)); dp[0][0] = dp[1][0] = 1; for(int i = 1;i&lt;maxn;i++) dp[i][1] = 1; for(int i = 2;i&lt;maxn;i++) for(int j = 1;j&lt;=i;j++) dp[i][j] = dp[i][j-1] + dp[i-j][min(i-j,j)];&#125;int main()&#123; init(); while(~scanf(&quot;%d&quot;,&amp;n))&#123; printf(&quot;%d\n&quot;,dp[n][n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>动态规划</tag>
        <tag>划分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[容斥原理]Hard to prepare]]></title>
    <url>%2F2018%2F09%2F20%2F2018-09-20%2F</url>
    <content type="text"><![CDATA[After Incident, a feast is usually held in Hakurei Shrine. This time Reimu asked Kokoro to deliver a Nogaku show during the feast. To enjoy the show, every audience has to wear a Nogaku mask, and seat around as a circle. There are N guests Reimu serves. Kokoro has 2^k2k masks numbered from 0,1,\cdots,0,1,⋯, 2^k - 12k−1, and every guest wears one of the masks. The masks have dark power of Dark Nogaku, and to prevent guests from being hurt by the power, two guests seating aside must ensure that if their masks are numbered ii and jj , then ii XNOR jj must be positive. (two guests can wear the same mask). XNOR means ~(ii^jj) and every number has kk bits. (11 XNOR 1 = 11=1, 00XNOR 0 = 10=1, 11 XNOR 0 = 00=0) You may have seen 《A Summer Day’s dream》, a doujin Animation of Touhou Project. Things go like the anime, Suika activated her ability, and the feast will loop for infinite times. This really troubles Reimu: to not make her customers feel bored, she must prepare enough numbers of different Nogaku scenes. Reimu find that each time the same guest will seat on the same seat, and She just have to prepare a new scene for a specific mask distribution. Two distribution plans are considered different, if any guest wears different masks. In order to save faiths for Shrine, Reimu have to calculate that to make guests not bored, how many different Nogaku scenes does Reimu and Kokoro have to prepare. Due to the number may be too large, Reimu only want to get the answer modules 1e9+71e9+7 . Reimu did never attend Terakoya, so she doesn’t know how to calculate in module. So Reimu wishes you to help her figure out the answer, and she promises that after you succeed she will give you a balloon as a gift. InputFirst line one number TT , the number of testcases; (T \le 20)(T≤20) . Next TT lines each contains two numbers, NNand k(0&lt;N, k \le 1e6)k(0&lt;N,k≤1e6) . OutputFor each testcase output one line with a single number of scenes Reimu and Kokoro have to prepare, the answer modules 1e9+71e9+7 . 样例输入复制12323 14 2 样例输出复制12284 题目来源ACM-ICPC 2018 徐州赛区网络预赛 题目描述 有n个位置围成一个圈，2^k个数，每个位置随便放置一个数，要求范围在1到2^k之间，然而每个数都有一个互斥的数，且互斥的两个数不会和其他的重复，要求相邻位置不能有互斥的数。 题解 首先用快速幂求出2^k然后赋给k，即k = 2^k。然后假设这n个数依次排开，那么每一个数不能是上一个元素的互斥数，那么第1个元素共k种，那么之后每一种为k-1种。即k*(k-1)^(n-1)，然而这样的话最后一个元素可以为第一个元素的互斥数，因此要减去相应的数，根据容斥原理最终列出实在为k*(k-1)^(n-1)-k*(k-1)^(n-2)+k*(k-1)^(n-3)-k*(k-1)^(n-4)……然而这样做会超时，因此我们可以合并，即加一次减一次合并到一起重新得到公式。 当然我们也可以换一种思考方式，很容易想到，第1个数有种选择，第2个数到第n-1个数都有种选择，第n个数有种选择。 所以答案就是 但是这样会出现漏算：在第1个数和第n-1个数相同的情况下，第n个数有种选择， 而并非种 然后仔细分析可以发现，漏算的情况你可以把第1个数和第n-1个数当成同一个数，这样序列长度就变成n-2了，问题规模变小 递归或递推即可 代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1e9+7;ll quick_pow(ll ans, ll res, ll n)&#123; while(n)&#123; if(n&amp;1) ans = ans * res % mod; res = res * res % mod; n&gt;&gt;=1; &#125; return ans;&#125;ll solve(ll n, ll k)&#123; ll ans = 0; ll i = (n&amp;1)+2; ll res = pow(k-1,i-2); for(;i&lt;=n;i+=2)&#123; ans = (ans + res) % mod; res = res * (k - 1) % mod * (k - 1) % mod; &#125; ans = ans * k % mod * (k - 2) % mod; ans = (ans + k) % mod; return ans;&#125;int main()&#123; ll t,n,k; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); k = quick_pow(1,2,k); printf(&quot;%lld\n&quot;,solve(n,k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 ACM-ICPC Asia Regional Contest Shanghai Site - Onsite Contest]]></title>
    <url>%2F2018%2F09%2F18%2F2018-09-18-2%2F</url>
    <content type="text"><![CDATA[F - Friendship of Frog NN frogs from different countries are standing in a line. Each country is represented by a lowercase letter. The distance between adjacent frogs (e.g. the 1st1stand the 2nd2nd frog, the N−1thN−1th and the NthNth frog, etc) are exactly 11. Two frogs are friends if they come from the same country.The closest friends are a pair of friends with the minimum distance. Help us find that distance. Input First line contains an integer TT, which indicates the number of test cases.Every test case only contains a string with length NN, and the ithith character of the string indicates the country of ithith frogs.⋅⋅ 1≤T≤501≤T≤50.⋅⋅ for 80% data, 1≤N≤1001≤N≤100.⋅⋅ for 100% data, 1≤N≤10001≤N≤1000.⋅⋅ the string only contains lowercase letters. Output For every test case, you should output “ Case #x: y“, where xx indicates the case number and counts from 11 and yy is the result. If there are no frogs in same country, output −1−1 instead. Sample Input 1232abcecbaabc Sample Output 12Case #1: 2Case #2: -1 题解 超级水题，一次性遍历，顺便设置一个字母表，记录上一个字母位置，初始值为0，每遇到一个字母，对该字母表进行更新。如果上一个该字母表不为0，则先用当前位置减去表中上一个位置，然后记录下最小值，然后再更新。最终如果最小值为初始值，则输出-1，否则输出该最小值。 代码 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxx = 1e9+7;char str[1007];int a[26];int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); for(int cc = 1;cc&lt;=t;cc++)&#123; scanf(&quot;%s&quot;,&amp;str); int minD = maxx; memset(a,0,sizeof(a)); int len = strlen(str); for(int i = 0;i&lt;len;i++)&#123; int num = str[i]-&apos;a&apos;; if(a[num]) minD = min(minD,i - a[num] + 1); a[num] = i + 1; &#125; if(minD == maxx) printf(&quot;Case #%d: -1\n&quot;,cc); else printf(&quot;Case #%d: %d\n&quot;,cc,minD); &#125; return 0;&#125; K - Kingdom of Black and WhiteIn the Kingdom of Black and White (KBW), there are two kinds of frogs: black frog and white frog.Now NN frogs are standing in a line, some of them are black, the others are white. The total strength of those frogs are calculated by dividing the line into minimum parts, each part should still be continuous, and can only contain one kind of frog. Then the strength is the sum of the squared length for each part.However, an old, evil witch comes, and tells the frogs that she will change the color of at most one frog and thus the strength of those frogs might change.The frogs wonder the maximum possible strength after the witch finishes her job. Input First line contains an integer TT, which indicates the number of test cases.Every test case only contains a string with length NN, including only 00(representinga black frog) and 11 (representing a white frog).⋅⋅ 1≤T≤501≤T≤50.⋅⋅ for 60% data, 1≤N≤10001≤N≤1000.⋅⋅ for 100% data, 1≤N≤1051≤N≤105.⋅⋅ the string only contains 0 and 1. Output For every test case, you should output “ Case #x: y“,where xx indicates the case number and counts from 11 and yy is the answer. Sample Input 12320000110101 Sample Output 12Case #1: 26Case #2: 10 题解 解法有点偏暴力，首先将01分成m个联通块，一次性遍历，将m个联通块的长度储存起来，算出总值ans。然后对这m个联通块分别判断加1情况下是否变大，当然该值的计算要先用ans减去该联通块以及相邻左边或右边联通块的值，然后再加上更新的值。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); for(int cas=1;cas&lt;=t;cas++) &#123; cin&gt;&gt;s; int flag = -1; vector&lt;long long&gt; Q; int len = 0; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]-&apos;0&apos;!=flag) &#123; Q.push_back(len); len = 1; flag = s[i]-&apos;0&apos;; &#125; else len++; &#125; Q.push_back(len); Q.push_back(0); long long res = 0; for(int i=1;i&lt;Q.size()-1;i++) res += Q[i]*Q[i]; long long ans = res; for(int i=1;i&lt;Q.size()-1;i++) &#123; long long tmp = 0; if(Q[i]==1) ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]-Q[i+1]*Q[i+1]+(Q[i-1]+Q[i+1]+1)*(Q[i-1]+Q[i+1]+1)); else &#123; ans = max(ans,res-Q[i-1]*Q[i-1]-Q[i]*Q[i]+(Q[i-1]+1)*(Q[i-1]+1)+(Q[i]-1)*(Q[i]-1)); ans = max(ans,res-Q[i+1]*Q[i+1]-Q[i]*Q[i]+(Q[i+1]+1)*(Q[i+1]+1)+(Q[i]-1)*(Q[i]-1)); &#125; &#125; printf(&quot;Case #%d: %lld\n&quot;,cas,ans); &#125;&#125; L - LCM Walk A frog has just learned some number theory, and can’t wait to show his ability to his girlfriend.Now the frog is sitting on a grid map of infinite rows and columns. Rows are numbered 1,2,⋯1,2,⋯ from the bottom, so are the columns. At first the frog is sitting at grid (sx,sy)(sx,sy), and begins his journey.To show his girlfriend his talents in math, he uses a special way of jump. If currently the frog is at the grid (x,y)(x,y), first of all, he will find the minimum zzthat can be divided by both xx and yy, and jump exactly zz steps to the up, or to the right. So the next possible grid will be (x+z,y)(x+z,y), or (x,y+z)(x,y+z).After a finite number of steps (perhaps zero), he finally finishes at grid (ex,ey)(ex,ey). However, he is too tired and he forgets the position of his starting grid!It will be too stupid to check each grid one by one, so please tell the frog the number of possible starting grids that can reach (ex,ey)(ex,ey)! Input First line contains an integer TT, which indicates the number of test cases.Every test case contains two integers exex and eyey, which is the destination grid.⋅⋅ 1≤T≤10001≤T≤1000.⋅⋅ 1≤ex,ey≤1091≤ex,ey≤109. Output For every test case, you should output “ Case #x: y“, where xx indicates the case number and counts from 11 and yy is the number of possible starting grids. Sample Input 123436 106 82 8 Sample Output 123Case #1: 1Case #2: 2Case #3: 3 题解 设当前位置为(x,y)，gcd(x,y) = g。则可设x = m1g，y=m2g，LCM（x,y） = m1m2g，则目标值为（m1g+m1m2g，m2g）或（m1g，m2g+m1m2g）。已知目标值，求x，y。我们设目标值为x2，y2，则可推出m1 = x2/(g+y2)或m2 = y2/(g+x2)。递归过程，直到m1或m2不为0则返回值，否则次数加1，再继续递归。 最终得到结果。 代码 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll gcd(ll a,ll b)&#123; return a%b==0?b:gcd(b,a%b);&#125;ll dfs(ll g,ll x,ll y)&#123; ll ans = 0; if(!(x%(g+y)))&#123; ans++; ll tmp = x*g/(g+y); ans+=dfs(gcd(max(tmp,y),min(tmp,y)),tmp,y); &#125; if(!(y%(g+x)))&#123; ans++; ll tmp = y*g/(g+x); ans+=dfs(gcd(max(tmp,x),min(tmp,x)),x,tmp); &#125; return ans;&#125;int main()&#123; ll t,x,y; scanf(&quot;%lld&quot;,&amp;t); for(ll c = 1;c&lt;=t;c++)&#123; scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); ll tmp = gcd(max(x,y),min(x,y)); ll ans = dfs(tmp,x,y); printf(&quot;Case #%lld: %lld\n&quot;,c,++ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI手拉手问题]]></title>
    <url>%2F2018%2F09%2F18%2F2018-09-18-1%2F</url>
    <content type="text"><![CDATA[问题描述：n个人n双手，每一次选择两个空手让这两个空手拉起来，然后这两个手不再是空手。一个人有两只手，问最终所有手都拉起来构成环的个数的期望。PS：一个人的左手和右手也可以拉起来构成一个环。 例如：n为2时，期望为4/3，假设从第一个人的左手开始，他的左手和右手和第2个人的左手和右手拉起来的概率都为1/3，其中自己的左手和右手拉起来构成环数为2，其他为1，则期望为1/3*2+1/3*1+1/3*1 题解：1+1/3+1/5+……1/(2n-1) 如果直接看公式很容易理解，每多一个人，就多了两只手，假设除了这个人以外其他人的期望都算出来了，假设期望为F(n)，那么对于这个人来说无非两种情况，要么和自己拉，要么和别人拉，和自己拉的概率为1/(2n-1)，和别人拉的概率为(2n-2)/(2n-1)。和自己拉的话很好理解，在之前的期望上加1就好了，和别人拉的话就可以把这两个人绑定起来当成一个人就好了，期望就是之前的期望。所以用公式的话就是F(n+1)=F(n)*(2n-2)/(2n-1)+(F(n)+1)*1/(2n-1),化简就得F(n+1)=F(n)+1/(2n-1)，递归得F(n)=1+1/3+1/5+……1/(2n-1) 根据调和级数推到公式： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ld long doubleconst int maxn = 1e7+7;ld a[maxn];void init()&#123; a[0] = 0; a[1]=1; for(int i = 2;i&lt;maxn;i++)&#123; a[i]=a[i-1]+1.0/(2*i-1); &#125;&#125;int main()&#123; //freopen(&quot;head.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;head.out&quot;,&quot;w&quot;,stdout); long long tmp; init(); cin&gt;&gt;tmp; if(tmp*1.0&gt;=maxn) cout&lt;&lt;log(2*tmp-1) - log(((2*tmp-1)-1)/2)/ 2 + 0.57721566490153286060651209 / 2&lt;&lt;endl; else cout&lt;&lt;a[tmp]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>概率轮</category>
      </categories>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找距离最小点对]]></title>
    <url>%2F2018%2F09%2F18%2F2018-09-18%2F</url>
    <content type="text"><![CDATA[在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一。下面我们着重考虑平面上的最接近点对问题。 ​ 最接近点对问题的提法是:给定平面上n个点，找其中的一对点，使得在n个点的所有点对中，该点对的距离最小。 ​ 严格地说，最接近点对可能多于1对。为了简单起见，这里只限于找其中的一对。 参考解答 ​ 这个问题很容易理解，似乎也不难解决。我们只要将每一点与其他n-1个点的距离算出，找出达到最小距离的两个点即可。然而，这样做效率太低，需要O(n2)的计算时间。在问题的计算复杂性中我们可以看到，该问题的计算时间下界为Ω(nlogn)。这个下界引导我们去找问题的一个θ(nlogn)算法。 这个问题显然满足分治法的第一个和第二个适用条件，我们考虑将所给的平面上n个点的集合S分成2个子集S1和S2，每个子集中约有n/2个点，·然后在每个子集中递归地求其最接近的点对。在这里，一个关键的问题是如何实现分治法中的合并步骤，即由S1和S2的最接近点对，如何求得原集合S中的最接近点对，因为S1和S2的最接近点对未必就是S的最接近点对。如果组成S的最接近点对的2个点都在S1中或都在S2中，则问题很容易解决。但是，如果这2个点分别在S1和S2中，则对于S1中任一点p，S2中最多只有n/2个点与它构成最接近点对的候选者，仍需做n2/4次计算和比较才能确定S的最接近点对。因此，依此思路，合并步骤耗时为O(n2)。整个算法所需计算时间T(n)应满足: T(n)=2T(n/2)+O(n2) ​ 它的解为T(n)=O(n2)，即与合并步骤的耗时同阶，显示不出比用穷举的方法好。从解递归方程的套用公式法，我们看到问题出在合并步骤耗时太多。这启发我们把注意力放在合并步骤上。 ​ 为了使问题易于理解和分析，我们先来考虑一维的情形。此时S中的n个点退化为x轴上的n个实数x1,x2,..,xn。最接近点对即为这n个实数中相差最小的2个实数。我们显然可以先将x1,x2,..,xn排好序，然后，用一次线性扫描就可以找出最接近点对。这种方法主要计算时间花在排序上，因此如在排序算法中所证明的，耗时为O(nlogn)。然而这种方法无法直接推广到二维的情形。因此，对这种一维的简单情形，我们还是尝试用分治法来求解，并希望能推广到二维的情形。 ​ 假设我们用x轴上某个点m将S划分为2个子集S1和S2，使得S1={x∈S|x≤m}；S2={x∈S|x&gt;m}。这样一来，对于所有p∈S1和q∈S2有p ​ 递归地在S1和S2上找出其最接近点对{p1,p2}和{q1,q2}，并设δ=min{|p1-p2|,|q1-q2|}，S中的最接近点对或者是{p1,p2}，或者是{q1,q2}，或者是某个{p3,q3}，其中p3∈S1且q3∈S2。如图1所示。 图1 一维情形的分治法 我们注意到，如果S的最接近点对是{p3,q3}，即|p3-q3|&lt;δ，则p3和q3两者与m的距离不超过δ，即|p3-m|&lt;δ，|q3-m|&lt;δ，也就是说，p3∈(m-δ,m]，q3∈(m,m+δ]。由于在S1中，每个长度为δ的半闭区间至多包含一个点（否则必有两点距离小于δ），并且m是S1和S2的分割点，因此(m-δ,m]中至多包含S中的一个点。同理，(m,m+δ]中也至多包含S中的一个点。由图1可以看出，如果(m-δ,m]中有S中的点，则此点就是S1中最大点。同理，如果(m,m+δ]中有S中的点，则此点就是S2中最小点。因此，我们用线性时间就能找到区间(m-δ,m]和(m,m+δ]中所有点，即p3和q3。从而我们用线性时间就可以将S1的解和S2的解合并成为S的解。也就是说，按这种分治策略，合并步可在O(n)时间内完成。这样是否就可以得到一个有效的算法了呢？还有一个问题需要认真考虑，即分割点m的选取，及S1和S2的划分。选取分割点m的一个基本要求是由此导出集合S的一个线性分割，即S=S1∪S2 ，S1∩S2=Φ，且S1{x|x≤m}；S2{x|x&gt;m}。容易看出，如果选取m=[max(S)+min(S)]/2，可以满足线性分割的要求。选取分割点后，再用O(n)时间即可将S划分成S1={x∈S|x≤m}和S2={x∈S|x&gt;m}。然而，这样选取分割点m，有可能造成划分出的子集S1和S2的不平衡。例如在最坏情况下，|S1|=1，|S2|=n-1，由此产生的分治法在最坏情况下所需的计算时间T(n)应满足递归方程: T(n)=T(n-1)+O(n) ​ 它的解是T(n)=O(n2)。这种效率降低的现象可以通过分治法中”平衡子问题”的方法加以解决。也就是说，我们可以通过适当选择分割点m，使S1和S2中有大致相等个数的点。自然地，我们会想到用S的n个点的坐标的中位数来作分割点。在选择算法中介绍的选取中位数的线性时间算法使我们可以在O(n)时间内确定一个平衡的分割点m。 ​ 至此，我们可以设计出一个求一维点集S中最接近点对的距离的算法CPAIR1如下。 function CPAIR1(S); begin if |S|=2 then δ=|x[2]-x[1]| // x[1..n]存放的是S中n个点的坐标 else if (|S|=1) then δ:=∞ else begin m:=S中各点的坐标值的中位数; 构造S1和S2,使S1={x∈S|x≤m}，S2={x∈S|x&gt;m}; δ1:=CPAIRI(S1); δ2:=CPAIRI(S2); p:=max(S1); q:=min(S2); δ:=min(δ1,δ2,q-p); end; return(δ); end; 由以上的分析可知，该算法的分割步骤和合并步骤总共耗时O(n)。因此，算法耗费的计算时间T(n)满足递归方程： ​ 解此递归方程可得T(n)=O(nlogn)。 ​ 这个算法看上去比用排序加扫描的算法复杂，然而这个算法可以向二维推广。 ​ 下面我们来考虑二维的情形。此时S中的点为平面上的点，它们都有2个坐标值x和y。为了将平面上点集S线性分割为大小大致相等的2个子集S1和S2，我们选取一垂直线l:x=m来作为分割直线。其中m为S中各点x坐标的中位数。由此将S分割为S1={p∈S|px≤m}和S2={p∈S|px&gt;m}。从而使S1和S2分别位于直线l的左侧和右侧，且S=S1∪S2 。由于m是S中各点x坐标值的中位数，因此S1和S2中的点数大致相等。 ​ 递归地在S1和S2上解最接近点对问题，我们分别得到S1和S2中的最小距离δ1和δ2。现设δ=min(δ1,δ1)。若S的最接近点对(p,q)之间的距离d(p,q)&lt;δ则p和q必分属于S1和S2。不妨设p∈S1，q∈S2。那么p和q距直线l的距离均小于δ。因此，我们若用P1和P2分别表示直线l的左边和右边的宽为δ的2个垂直长条，则p∈P1，q∈P2，如图2所示。 图2 距直线l的距离小于δ的所有点 在一维的情形，距分割点距离为δ的2个区间(m-δ,m](m,m+δ]中最多各有S中一个点。因而这2点成为唯一的末检查过的最接近点对候选者。二维的情形则要复杂些，此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有n2/4对这样的候选者。但是P1和P2中的点具有以下的稀疏性质，它使我们不必检查所有这n2/4对候选者。考虑P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有d(p,q)&lt;δ。满足这个条件的P2中的点有多少个呢？容易看出这样的点一定落在一个δ×2δ的矩形R中，如图3所示。 图3 包含点q的δ×2δ的矩形R ​ 由δ的意义可知P2中任何2个S中的点的距离都不小于δ。由此可以推出矩形R中最多只有6个S中的点。事实上，我们可以将矩形R的长为2δ的边3等分，将它的长为δ的边2等分，由此导出6个（δ/2）×（2δ/3）的矩形。如图4(a)所示。 图4 矩形R中点的稀疏性 ​ 若矩形R中有多于6个S中的点，则由鸽舍原理易知至少有一个δ×2δ的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则 ​ 因此d(u,v)≤5δ/6&lt;δ 。这与δ的意义相矛盾。也就是说矩形R中最多只有6个S中的点。图4(b)是矩形R中含有S中的6个点的极端情形。由于这种稀疏性质，对于P1中任一点p，P2中最多只有6个点与它构成最接近点对的候选者。因此，在分治法的合并步骤中，我们最多只需要检查6×n/2=3n对候选者，而不是n2/4对候选者。这是否就意味着我们可以在O(n)时间内完成分治法的合并步骤呢？现在还不能作出这个结论，因为我们只知道对于P1中每个S1中的点p最多只需要检查P2中的6个点，但是我们并不确切地知道要检查哪6个点。为了解决这个问题，我们可以将p和P2中所有S2的点投影到垂直线l上。由于能与p点一起构成最接近点对候选者的S2中点一定在矩形R中，所以它们在直线l上的投影点距p在l上投影点的距离小于δ。由上面的分析可知，这种投影点最多只有6个。因此，若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。 ​ 至此，我们可以给出用分治法求二维最接近点对的算法CPAIR2如下: function CPAIR2(S); begin if |S|=2 then δ:=S中这2点的距离 else if |S|=0 then δ:=∞ else begin \1. m:=S中各点x坐标值的中位数; 构造S1和S2，使S1={p∈S|px≤m}和S2={p∈S|px&gt;m} \2. δ1:=CPAIR2(S1);δ2:=CPAIR2(S2); \3. δm:=min(δ1,δ2); \4. 设P1是S1中距垂直分割线l的距离在δm之内的所有点组成的集合， P2是S2中距分割线l的距离在δm之内所有点组成的集合。将P1和P2中的点依其y坐标值从小到大排序，并设P1和P2是相应的已排好序的点列; 通过扫描P1以及对于P1中每个点检查P2中与其距离在δm之内的所有点(最多6个)可以完成合并。当P1中的扫描指针逐次向上移动 时，P2*中的扫描指针可在宽为2δm的一个区间内移动。设δl是按 这种扫描方式找到的点对间的最小距离; \6. δ=min(δm,δl); end; return(δ); end; 下面我们来分析一下算法CPAIR2的计算复杂性。设对于n个点的平面点集S，算法耗时T(n)。算法的第1步和第5步用了O(n)时间，第3步和第6步用了常数时间，第2步用了2T(n/2)时间。若在每次执行第4步时进行排序，则在最坏情况下第4步要用O(nlogn)时间。这不符合我们的要求。因此，在这里我们要作一个技术上的处理。我们采用设计算法时常用的预排序技术，即在使用分治法之前，预先将S中n个点依其y坐标值排好序，设排好序的点列为P。在执行分治法的第4步时，只要对P作一次线性扫描，即可抽取出我们所需要的排好序的点列P1和P2。然后，在第5步中再对P1*作一次线性扫描，即可求得δl。因此，第4步和第5步的两遍扫描合在一起只要用O(n)时间。这样一来，经过预排序处理后的算法CPAIR2所需的计算时间T(n)满足递归方程： ​ 显而易见T(n)=O(nlogn)，预排序所需的计算时间为O(n1ogn)。因此，整个算法所需的计算时间为O(nlogn)。在渐近的意义下，此算法已是最优的了。]]></content>
      <categories>
        <category>程序人生</category>
        <category>训练之路</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重装系统后，如何快速搭建之前基于github的博客]]></title>
    <url>%2F2018%2F09%2F17%2F2018-09-17%2F</url>
    <content type="text"><![CDATA[声明：此文是针对于windows环境前提：我需要说几个条件; 1.当初搭建博客时的ssh没有删除，如果删除那就再重新配置一个，配置方法参照我上一篇博客； 2.当初搭建博客的仓库没有删除，如果删除，那就再重新搭一个吧，剩下的教程几乎没有关系了 3.如果，当时搭建博客时，如果按照我的教程，或者说按照网上大多数教程，有建了一个文件夹（例如：git pages或者hexo），这个文件夹在重装系统后还有保留下来，那最好不过。 先说第一种情况：如果那个文件夹在的情况下：不知道你们有没有按照其他的教程去配置静态页面，我按照那个方法有在github上新建了一个branch 那个gh-pages是我新建的branch，如果建了没关系 我们只需用点击master就好，回到原来的地方 然后再你原来的那个文件夹里打开git bash here 输入npm install hexo –save 然后可以试着输入hexo g 和hexo d 提示你需要重新配置邮箱和用户名，那么按照原来的邮箱和原来的用户名输入就好； 再次输入hexo g，如果有提示 就说明已经重新配置好了； 如果没有保留当初在桌面配置的文件夹首先先看看自己电脑上有没有ssh 在自己的一个盘里建一个文件夹，里面分别有三个文件夹（git，node，git pages） 分别在git和node里配置好git和node 然后再git pages里打开git bash here检查有没有ssh cd ~/. ssh 如果有 No such file or directory 说明是第一次使用，那么按照上一篇博客配置， 如果提示有，那么你可以先试试这个ssh能用不，先别急着删； 按照刚刚的步骤再输入 npm install hexo –save 然后按照刚刚的步骤再来一次； 如果最后hexo d后，文章没有推上去，那么就说明没有成功，需要重新配置ssh 先删除原来的sshssh-add -Drm -r ~/.ssh 最好查看一下上一篇博客里，Deployment的config.yml文件里面的deploy值有没有改好（参照上一篇） 配置好了之后再按照刚刚的步骤再来一次（记得配置邮箱和用户名） 如果git bash在这儿没有起作用的话， 那么win+r打开cmd，安装一个类似刚刚操作的扩展 输入 npm install hexo-deployer-git –save 然后再输入 hexo ghexo d 然后再进入自己的博客页面查看。]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数论小问题]]></title>
    <url>%2F2018%2F09%2F16%2F2018-09-16%2F</url>
    <content type="text"><![CDATA[输入x和y，有一个游戏，两人玩，第一轮赢的人得1分，第二轮2分…以此类推，n轮中至少需要几轮才能使得甲获得x分乙获得y分？ 答案：n = min( n*(n+1)/2&gt;=x+y ) 当时看到此题时脑海中浮现的并不是分数什么的，而是一个阶梯状的管子，往里面灌水，x代表一定容量的水，y代表一定容量的水，然后管子每升高1个高度就会多1个容量，最终刚好为n(n+1)/2或n(n+1)/2+1，n(n+1)/2即x+y=n(n+1)/2，否则为n*(n+1)/2+1。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[质因数分解原创算法]]></title>
    <url>%2F2018%2F09%2F13%2F2018-09-13%2F</url>
    <content type="text"><![CDATA[由于这几天电脑坏掉了，这个算法是之前总结出来的，当时没来的及总结。具体就不介绍了。作用是范围内某数快速分解质因数相乘。 12345678910111213void Prime()&#123; memset(tag,0,sizeof(tag)); int cnt=0; for(int i = 2; i&lt;N; i++)&#123; if(tag[i]) prime[cnt++]=i; for(int j=0;j&lt;cnt &amp;&amp; prime[j]*i&lt;N; j++)&#123; tag[i*prime[j]] = i; if(i % prime[j]==0) break; &#125; &#125;&#125; 打表时表中储存为该数最小质数，这样给一个数只需除以对应表中数，直到除到最后为1为止]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路径规划总结之A*搜索]]></title>
    <url>%2F2018%2F09%2F10%2F2018-09-10%2F</url>
    <content type="text"><![CDATA[路径规划路径规划是指的是机器人的最优路径规划问题，即依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。机器人的路径规划应用场景极丰富，最常见如游戏中NPC及控制角色的位置移动，百度地图等导航问题，小到家庭扫地机器人、无人机大到各公司正争相开拓的无人驾驶汽车等。 目前路径规划算法分为： A*算法首先，我们来看看A*算法的定义：A*（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法。 采用广度优先搜索策略，在搜索过程中使用启发函数，即有大致方向的向前进虽然目标有时候不是很明确。 在计算机科学中，A*算法作为Dijkstra算法的扩展，因其高效性而被广泛应用于寻路及图的遍历，如星际争霸等游戏中就大量使用。在理解算法前，我们需要知道几个概念： 搜索区域（The Search Area）：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点（Node）。 开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中。 父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针。 路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销。 启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和。 可能看定义不是很好理解，那么我们根据例子具体看看什么是A*算法吧。 详细讲解参考： 启发式算法 A*算法]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 2018 徐州赛区网络预赛]]></title>
    <url>%2F2018%2F09%2F09%2F2018-09-09%2F</url>
    <content type="text"><![CDATA[Characters with Hash问答 26.45% 1000ms 262144K Mur loves hash algorithm, and he sometimes encrypt another one’s name, and call him with that encrypted value. For instance, he calls Kimura KMR, and calls Suzuki YJSNPI. One day he read a book about SHA-256256 , which can transit a string into just 256256 bits. Mur thought that is really cool, and he came up with a new algorithm to do the similar work. The algorithm works this way: first we choose a single letter L as the seed, and for the input(you can regard the input as a string ss, s[i]s[i] represents the iith character in the string) we calculates the value(|(int) L - s[i]|∣(int)L−s[i]∣), and write down the number(keeping leading zero. The length of each answer equals to 22because the string only contains letters and numbers). Numbers writes from left to right, finally transfer all digits into a single integer(without leading zero(ss)). For instance, if we choose ‘z’ as the seed, the string “oMl” becomes “1111 4545 1414”. It’s easy to find out that the algorithm cannot transfer any input string into the same length. Though in despair, Mur still wants to know the length of the answer the algorithm produces. Due to the silliness of Mur, he can even not figure out this, so you are assigned with the work to calculate the answer. InputFirst line a integer TT , the number of test cases (T \le 10)(T≤10). For each test case: First line contains a integer NN and a character zz, (N \le 1000000)(N≤1000000). Second line contains a string with length NN . Problem makes sure that all characters referred in the problem are only letters. OutputA single number which gives the answer. 样例输入复制1234523 zoMl6 YYJSNPI 样例输出复制12610 题目来源ACM-ICPC 2018 徐州赛区网络预赛 代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;char str[1000007],ch[2];int main()&#123; int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%s%s&quot;,&amp;n,ch,str); int ans = 2*n; for(int i = 0; i&lt;n; i++)&#123; if(str[i]==ch[0]) ans-=2; else&#123; if(abs(str[i]-ch[0])&lt;10) ans-=1; break; &#125; &#125; if(ans==0) ans++; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC沈阳网络预赛K题-Supreme Number]]></title>
    <url>%2F2018%2F09%2F08%2F2018-09-08-1%2F</url>
    <content type="text"><![CDATA[Supreme Number问答 26.7% 1000ms 131072K A prime number (or a prime) is a natural number greater than 11 that cannot be formed by multiplying two smaller natural numbers. Now lets define a number NN as the supreme number if and only if each number made up of an non-empty subsequence of all the numeric digits of NN must be either a prime number or 11. For example, 1717 is a supreme number because 11, 77, 1717 are all prime numbers or 11, and 1919 is not, because 99 is not a prime number. Now you are given an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100), could you find the maximal supreme number that does not exceed NN? InputIn the first line, there is an integer T\ (T \leq 100000)T (T≤100000) indicating the numbers of test cases. In the following TT lines, there is an integer N\ (2 \leq N \leq 10^{100})N (2≤N≤10100). OutputFor each test case print &quot;Case #x: y&quot;, in which xx is the order number of the test case and yy is the answer. 样例输入复制12326100 样例输出复制12Case #1: 5Case #2: 73 题目来源ACM-ICPC 2018 沈阳赛区网络预赛 题解非空子序列必须为素数，那么每一位就只能由1,2,3,5,7组成，且除了1以外其他只能出现一次，那么最后算上1就只剩下20个数了，1,2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317，预处理以下就好了。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int pri[19] = &#123;2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317&#125;;int read()&#123; char ch=&apos; &apos;; int ans=0; while(ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;) ch=getchar(); while(ch&lt;=&apos;9&apos; &amp;&amp; ch&gt;=&apos;0&apos;) &#123; if(ans&lt;100000) ans=ans*10+ch-&apos;0&apos;; ch=getchar(); &#125; return ans;&#125;int main()&#123; int t; cin&gt;&gt;t; for(int aaa=1;aaa&lt;=t;aaa++)&#123; int ans = read(); int i; for(i = 0;i&lt;19;i++)&#123; if(pri[i]&gt;ans)&#123; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[i-1]&lt;&lt;endl; break; &#125; &#125; if(i==19) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;aaa&lt;&lt;&quot;: &quot;&lt;&lt;pri[18]&lt;&lt;endl; &#125; return 0;&#125; 打表代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;using namespace std;#define N 10000000int h=0;bool p[N];int prime[N];bool dfs(int x)&#123; if(p[x]==false) return false; int c = 1; while(c&lt;x)&#123; c*=10; if(p[x%c]==false) return false; if(c&gt;x) break; int tmp = x; while(tmp)&#123; if(p[tmp]==false) return false; if(p[tmp%c]==false) return false; tmp/=c; if(!tmp) break; if(dfs(tmp)==false) return false; &#125; &#125; return true;&#125;void db()&#123; memset(p,true,sizeof(p)); p[0] = false; for(int i=2;i&lt;N;i++) &#123; if(p[i]==false) continue; for(int j=2;i*j&lt;N;j++) &#123; p[i*j]=false; &#125; if(!dfs(i)) p[i] = false; if(p[i]==true) &#123; prime[h++]=i; &#125; &#125;&#125;int main()&#123; db(); int n; //打印前n个质数 for(int i=0;i&lt;=h;i++) cout&lt;&lt;prime[i]&lt;&lt;&quot;,&quot;; return 0;&#125;//2,3,5,7,11,13,17,23,31,37,53,71,73,113,131,137,173,311,317]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-ACM-ICPC沈阳网络预赛D题-A*模板题]]></title>
    <url>%2F2018%2F09%2F08%2F2018-09-08%2F</url>
    <content type="text"><![CDATA[Made In Heaven问答 14.67% 1000ms 131072K One day in the jail, F·F invites Jolyne Kujo (JOJO in brief) to play tennis with her. However, Pucci the father somehow knows it and wants to stop her. There are NN spots in the jail and MM roads connecting some of the spots. JOJO finds that Pucci knows the route of the former (K-1)(K−1)-th shortest path. If Pucci spots JOJO in one of these K-1K−1 routes, Pucci will use his stand Whitesnake and put the disk into JOJO’s body, which means JOJO won’t be able to make it to the destination. So, JOJO needs to take the KK-th quickest path to get to the destination. What’s more, JOJO only has TT units of time, so she needs to hurry. JOJO starts from spot SS, and the destination is numbered EE. It is possible that JOJO’s path contains any spot more than one time. Please tell JOJO whether she can make arrive at the destination using no more than TT units of time. InputThere are at most 5050 test cases. The first line contains two integers NN and MM (1 \leq N \leq 1000, 0 \leq M \leq 10000)(1≤N≤1000,0≤M≤10000). Stations are numbered from 11 to NN. The second line contains four numbers S, E, KS,E,K and TT ( 1 \leq S,E \leq N1≤S,E≤N, S \neq ES≠E, 1 \leq K \leq 100001≤K≤10000, 1 \leq T \leq 1000000001≤T≤100000000 ). Then MM lines follows, each line containing three numbers U, VU,V and WW (1 \leq U,V \leq N, 1 \leq W \leq 1000)(1≤U,V≤N,1≤W≤1000) . It shows that there is a directed road from UU-th spot to VV-th spot with time WW. It is guaranteed that for any two spots there will be only one directed road from spot AA to spot BB (1 \leq A,B \leq N, A \neq B)(1≤A,B≤N,A≠B), but it is possible that both directed road &lt;A,B&gt;&lt;A,B&gt;and directed road &lt;B,A&gt;&lt;B,A&gt; exist. All the test cases are generated randomly. OutputOne line containing a sentence. If it is possible for JOJO to arrive at the destination in time, output &quot;yareyaredawa&quot; (without quote), else output &quot;Whitesnake!&quot; (without quote). 样例输入复制12342 21 2 2 141 2 52 1 4 样例输出复制1yareyaredawa 题目来源ACM-ICPC 2018 沈阳赛区网络预赛 题意N个点，M条边，起始点为s，结束为n，求s到n的第k短的路的长度，判断长度是否大于T，如果大于，输出“Whitesnake!”，否则输出“yareyaredawa” 类似POJ2449 题解A*+SPFA A*算法：1234A*，启发式搜索，是一种较为有效的搜索方法。我们在搜索的时候，很多时候在当前状态，已经不是最优解了，但是我们却继续求解；这个就是暴力搜索浪费时间的原因。我们在有些时候，往往可以根据一些信息推断出继续搜索是一种劣解。所以如果能够判断出来的话，就可以不继续了，以达到节省运行时间的目的。 估价函数：12345678为了提高搜索效率，我们可以对未来可能产生的代价进行预估。我们设计一个估价函数，以任意状态输入，计算出从该状态到目标状态所需代价的估计值。在搜索时，我们总沿着当前代价+未来估价最小的状态进行搜索。估价函数需要满足： 设当前状态state到目标函数所需代价的估计值为f(state) 设在未来的搜索中，实际求出的从当前状态state到目标状态的最小代价为g(state) 对于任意的state，应该有f(state)&lt;=g(state)也就是说，估价函数的估值不能大于未来实际代价，估价比实际代价更优。 第K短路：12345678根据估价函数的设计准则，在第K短路中从x到T的估计距离f(x)应该不大于第K短路中从x到T的实际距离g(x)，于是，我们可以把估价函数f(x)定为从x到T的最短路径长度，这样不但能保证f(x)&lt;=g(x)，还能顺应g(x)的实际变化趋势。实现过程：1.预处理f(x)，在反向图上以T为起点求到每个点的最短路2.定义堆，维护&#123;p,g,h&#125;，p是某一个点，g是估价，h是实际，那么g+h更小的点p会优先访问3.取出堆顶元素u扩展，如果节点v被取出的次数尚未达到k，就把新的&#123;v,g,h+length(u,v)&#125;插入堆中4.重复第2-3步，直到第K次取出终点T，此时走过的路径长度就是第K短路因为估价函数的作用，图中很多节点访问次数远小于K 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define ll long longconst ll maxn=100010;ll n,m,dis[maxn];ll tot,head1[maxn],head2[maxn];bool flag[maxn];struct edge&#123; ll to; ll w; ll next;&#125;e[maxn*2],e2[maxn*2];struct node&#123; ll f; ll g; ll from; bool operator &lt; (node a)const &#123; if(a.f==f) return g&gt;a.g; return f&gt;a.f; &#125;&#125;;void add_edge(ll u,ll v,ll w)&#123; tot++; e[tot].to=v; e[tot].w=w; e[tot].next=head1[u]; head1[u]=tot; e2[tot].to=u; e2[tot].w=w; e2[tot].next=head2[v]; head2[v]=tot;&#125;void prepare()&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn;tot=0; memset(head1,0,sizeof(head1)); memset(head2,0,sizeof(head2));&#125;void spfa(ll t)&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn; dis[t]=0; queue&lt;ll&gt; q; q.push(t); flag[t]=1; while(!q.empty()) &#123; ll v=q.front(); q.pop();flag[v]=0; for(ll i=head2[v];i;i=e2[i].next) if(dis[e2[i].to]&gt;dis[v]+e2[i].w) &#123; dis[e2[i].to]=dis[v]+e2[i].w; if(!flag[e2[i].to]) &#123; q.push(e2[i].to); flag[e2[i].to]=1; &#125; &#125; &#125;&#125;ll a_star(ll s,ll t,ll k)&#123; if(s==t) k++; if(dis[s]==maxn) return -1; priority_queue&lt;node&gt; q; ll cnt=0; node tmp,to; tmp.from=s; tmp.g=0; tmp.f=tmp.g+dis[tmp.from]; q.push(tmp); while(!q.empty()) &#123; tmp=q.top(); q.pop(); if(tmp.from==t) cnt++; if(cnt==k) return tmp.g; for(ll i=head1[tmp.from];i;i=e[i].next) &#123; to.from=e[i].to; to.g=tmp.g+e[i].w; to.f=to.g+dis[to.from]; q.push(to); &#125; &#125; return -1;&#125;int main()&#123; ll x,y,z,s,t,k; ll T; while(cin&gt;&gt;n&gt;&gt;m) &#123; cin&gt;&gt;s&gt;&gt;t&gt;&gt;k&gt;&gt;T; prepare(); for(ll i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; add_edge(x,y,z); &#125; spfa(t); ll ans=a_star(s,t,k); if(ans&lt;=T&amp;&amp;ans!=-1) cout&lt;&lt;&quot;yareyaredawa&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Whitesnake!&quot;&lt;&lt;endl; &#125; return 0;&#125; k短路模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const ll maxn=100010;ll n,m,dis[maxn];ll tot,head1[maxn],head2[maxn];bool flag[maxn];struct edge&#123; ll to; ll w; ll next;&#125;e[maxn*2],e2[maxn*2];struct node&#123; ll f; ll g; ll from; bool operator &lt; (node a)const &#123; if(a.f==f) return g&gt;a.g; return f&gt;a.f; &#125;&#125;;void add_edge(ll u,ll v,ll w)&#123; tot++; e[tot].to=v; e[tot].w=w; e[tot].next=head1[u]; head1[u]=tot; e2[tot].to=u; e2[tot].w=w; e2[tot].next=head2[v]; head2[v]=tot;&#125;void prepare()&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn;tot=0; memset(head1,0,sizeof(head1)); memset(head2,0,sizeof(head2));&#125;void spfa(ll t)&#123; for(ll i=1;i&lt;=n;i++) dis[i]=maxn; dis[t]=0; queue&lt;ll&gt; q; q.push(t); flag[t]=1; while(!q.empty()) &#123; ll v=q.front(); q.pop();flag[v]=0; for(ll i=head2[v];i;i=e2[i].next) if(dis[e2[i].to]&gt;dis[v]+e2[i].w) &#123; dis[e2[i].to]=dis[v]+e2[i].w; if(!flag[e2[i].to]) &#123; q.push(e2[i].to); flag[e2[i].to]=1; &#125; &#125; &#125;&#125;ll a_star(ll s,ll t,ll k)&#123; if(s==t) k++; if(dis[s]==maxn) return -1; priority_queue&lt;node&gt; q; ll cnt=0; node tmp,to; tmp.from=s; tmp.g=0; tmp.f=tmp.g+dis[tmp.from]; q.push(tmp); while(!q.empty()) &#123; tmp=q.top(); q.pop(); if(tmp.from==t) cnt++; if(cnt==k) return tmp.g; for(ll i=head1[tmp.from];i;i=e[i].next) &#123; to.from=e[i].to; to.g=tmp.g+e[i].w; to.f=to.g+dis[to.from]; q.push(to); &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>A*算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>最短路</tag>
        <tag>A*算法</tag>
        <tag>k短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[最短路]SPFA的SLF与LLL优化]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05-2%2F</url>
    <content type="text"><![CDATA[SPFA是按照 FIFO 的原则更新距离的, 没有考虑到距离标号的作用。实现中 SPFA 有两个非常著名的优化: SLF 和 LLL。 SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) &lt; dist(i)，则将j插入队首，否则插入队尾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;deque&gt;const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11 ; using namespace std ;//1061109567int n , m , head[maxn] , dis[maxn] , cnt , sum , tot ;bool mark[maxn] ; struct id&#123; int nxt ,to , val ;&#125; edge[M] ;deque &lt; int &gt; Q ;inline void Init ( )&#123; freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin ) ; freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;&#125;int read( )&#123; char ch = getchar( ) ; int k = 1 , ret = 0 ; while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125; while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ; return k * ret ;&#125;void add( int u , int v , int va )&#123; edge[++cnt].nxt = head[u] , edge[cnt].to = v ; edge[cnt].val = va , head[u] = cnt ;&#125;void input( )&#123; n = read() , m = read( ) ; int u ,v , c ; memset( head , -1 , sizeof(head)) ; for( int x = 1 ; x &lt;= m ; ++x ) &#123; u = read( ) , v = read( ) , c = read( ) ; add( u ,v , c ) ; &#125;&#125;void spfa( )&#123; memset( dis , 127/2 , sizeof(dis) ) ; dis[1] = 0 , mark[1] = true ; Q.push_back( 1 ) ; while( !Q.empty( ) ) &#123; int u = Q.front( ) ; Q.pop_front( ) ; mark[u] = false ; for( int i = head[u] ; ~i ; i = edge[i].nxt ) &#123; int v = edge[i].to ; if( dis[v] &gt; dis[u] + edge[i].val ) &#123; dis[v] = dis[u] + edge[i].val ; if( !mark[v] ) &#123; mark[v] = true ; if( Q.empty( ) || dis[v] &gt; dis[Q.front( )] ) Q.push_back( v ) ; else Q.push_front( v ) ; &#125; &#125; &#125; &#125; if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ; else printf( &quot;%d\n&quot; , dis[n] ) ;&#125;int main( )&#123;// Init( ) ; input( ) ; spfa( ) ;// fclose( stdin ) ;// fclose( stdout ) ; return 0 ;&#125; LLL：Large Label Last 策略，设队首元素为i，每次弹出时进行判断，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，每次出队时，若 d[i]&gt;平均值，把 i 移到队列末尾，如此反复，直到找到某一i使得dist(i)&lt;=x，则将i出队进行松弛操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;deque&gt;const int inf = 1 &lt;&lt; 30 , maxn = 100000 + 11 , M = 200000 + 11 ; using namespace std ;//1061109567int n , m , head[maxn] , dis[maxn] , cnt , sum , tot ;bool mark[maxn] ; struct id&#123; int nxt ,to , val ;&#125; edge[M] ;deque &lt; int &gt; Q ;inline void Init ( )&#123; freopen( &quot;NSOOJ#10719.in&quot; , &quot;r&quot; , stdin ) ; freopen( &quot;NSOOJ#10719.out&quot; , &quot;w&quot; , stdout ) ;&#125;int read( )&#123; char ch = getchar( ) ; int k = 1 , ret = 0 ; while( ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos; ) &#123; if( ch == &apos;-&apos; ) k = -1 ; ch = getchar( ) ; &#125; while( ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos; ) ret = ret * 10 + ch - &apos;0&apos; , ch = getchar( ) ; return k * ret ;&#125;void add( int u , int v , int va )&#123; edge[++cnt].nxt = head[u] , edge[cnt].to = v ; edge[cnt].val = va , head[u] = cnt ;&#125;void input( )&#123; n = read() , m = read( ) ; int u ,v , c ; memset( head , -1 , sizeof(head)) ; for( int x = 1 ; x &lt;= m ; ++x ) &#123; u = read( ) , v = read( ) , c = read( ) ; add( u ,v , c ) ; &#125;&#125;void spfa( )&#123; memset( dis , 127/2 , sizeof(dis) ) ; dis[1] = 0 , mark[1] = true ; Q.push_back( 1 ) ; tot = 0 ; while( !Q.empty( ) ) &#123; int u = Q.front( ) ; Q.pop_front( ) ; if( dis[u] * tot &gt; sum ) &#123; Q.push_back( u ) ; continue; &#125; mark[u] = false ; tot-- ; sum -= dis[u] ; for( int i = head[u] ; ~i ; i = edge[i].nxt ) &#123; int v = edge[i].to ; if( dis[v] &gt; dis[u] + edge[i].val ) &#123; dis[v] = dis[u] + edge[i].val ; if( !mark[v] ) &#123; mark[v] = true ; if( Q.empty( ) || dis[v] * tot &gt; sum ) Q.push_back( v ) ; else Q.push_front( v ) ; tot++ ; sum += dis[v] ; &#125; &#125; &#125; &#125; if( dis[n] == 1061109567 ) printf( &quot;%d\n&quot; , -1 ) ; else printf( &quot;%d\n&quot; , dis[n] ) ;&#125;int main( )&#123;// Init( ) ; input( ) ; spfa( ) ;// fclose( stdin ) ;// fclose( stdout ) ; return 0 ;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++] pair和make_pair]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05-1%2F</url>
    <content type="text"><![CDATA[偶然间从一篇博客上看到了make_pair，所以顺便记录下来。博客地址：pair与make_pair std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair&lt;int,float&gt; 或者 std::pair&lt;double,double&gt;等。pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：template pair make_pair(T1 a, T2 b) { return pair(a, b); } 一般make_pair都使用在需要pair做参数的位置，可以直接调用make_pair生成pair对象。另一个使用的方面就是pair可以接受隐式的类型转换，这样可以获得更高的灵活度。但是这样会出现如下问题： 例如有如下两个定义： std::pair&lt;int, float&gt;(1, 1.1); std::make_pair(1, 1.1);其中第一个的second变量是float类型，而make_pair函数会将second变量都转换成double类型。这个问题在编程是需要引起注意。下面是一段pair与make_pair的例子程序： 123456789101112131415include &lt;iostream&gt;using namespace std;int main(int argc, char** argv)&#123; pair &lt;string,double&gt; product1 (&quot;tomatoes&quot;,3.25); pair &lt;string,double&gt; product2; pair &lt;string,double&gt; product3; product2.first =&quot;lightbulbs&quot;; // type of first is string product2.second =0.99; // type of second is double product3 = make_pair (&quot;shoes&quot;,20.0); cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product1.first &lt;&lt;&quot; is $&quot;&lt;&lt; product1.second &lt;&lt;&quot;\n&quot;; cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product2.first &lt;&lt;&quot; is $&quot;&lt;&lt; product2.second &lt;&lt;&quot;\n&quot;; cout &lt;&lt;&quot;The price of &quot;&lt;&lt; product3.first &lt;&lt;&quot; is $&quot;&lt;&lt; product3.second &lt;&lt;&quot;\n&quot;; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[单源最短路]两大优化算法争锋之SPFA与堆优化版Dijkstra]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05%2F</url>
    <content type="text"><![CDATA[单源最短路(SSSP)的算法有Dijkstra，Bellman-Ford， 两大算法优化后即为Dijkstra+heap与SPFA。 这两个优化版算法写起来非常相似。接下来就从算法思路、时间复杂度、写法和适用场景上进行对比分析。 基础算法Dijkstra时间复杂度：O(V2+E) n-1次循环 –&gt;找到未标记的d最小的点 –&gt;标记，松弛它的边 123456789101112131415161718192021void dijkstra(int s)&#123; memset(vis, false, sizeof(vis)); vis[s] = true; for(int i = 1; i &lt;= n; i++) dis[i] = road[s][i]; for(int u = 1; u&lt;n; u++)&#123; int minD = inf,k = -1; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i]&amp;&amp;dis[i]&lt;minD)&#123; k = i; minD = dis[i]; &#125; &#125; vis[k] = true; for(int i = 1; i&lt;= n; i++)&#123; if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i])&#123; dis[i]=dis[k]+road[k][i]; &#125; &#125; &#125;&#125; Bellman-Ford时间复杂度：O(VE) n-1次循环 –&gt;对所有边松弛 还能再松弛则有负环 12345678910int dis[10010];int u[10010],v[10010],w[10010];int n,m;void Bellman_ford(int a)&#123; memset(dis,inf,sizeof(dis));//赋初始值 dis[a]=0; for(int i=1;i&lt;=n-1;i++)//更新n-1次 for(int j=1;j&lt;=m;j++)//更新每一条边 dis[v[j]]=min(dis[v[j]],dis[u[j]]+w[j]);//判断是否更新 &#125; 两大基础算法对比 Dijkstra是每次确定了到一个点的最短距离，再用该点更新到其它点的距离。不能处理有负边的图。 Bellman-Ford是每次对所有边松弛。可以计算出有负边无负环的最短路，可以判断是否存在负环。 优化算法Dijkstra+heap优化时间复杂度：O((V+E)lgV) 用STL中的优先队列实现堆： while(优先队列非空) –&gt;队头出队，松弛它的边 –&gt;松弛了的&lt;新距离,点&gt;入队 12345678910111213141516typedef pair&lt;int,int&gt; PII;priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; q;...while(!q.empty())&#123; // O(V) 加上count&lt;n可以优化一点点 int w=q.top().first, u=q.top().second; q.pop(); // O(lgV) if(b[u])continue; b[u]=true; //++count; for(int i=head[u];i;i=e[i].next)&#123; // Sum -&gt; O(E) int v=e[i].to; if(d[u]+e[i].w&lt;d[v])&#123; d[v]=d[u]+e[i].w; q.push(PII(d[v],v)); // O(lgV) &#125; &#125;&#125; SPFA时间复杂度：O(kE) or O(VE) while(队非空) –&gt;队头出队，松弛它的边 –&gt;松弛了且不在队内的点入队 1234567891011while(!q.empty())&#123; int u=q.front(); q.pop(); b[u]=false; for(int i=head[u];i;i=e[i].next)&#123; int v=e[i].to; if(d[u]+e[i].w&lt;d[v])&#123; d[v]=d[u]+e[i].w; if(!b[v])b[v]=true,q.push(v); &#125; &#125;&#125; 算法思路对比 Dijkstra+heap是用小根堆，每次取出d最小的点，来更新距离，那么这个点来说，最小距离就是当前的d。 SPFA是用双端队列，每次取出队头，来更新距离，它之后可能还会入队。它是一种动态逼近法，因为每次松弛距离都会减小，所以松弛一定会有结束的。如果一个点入队超过n次就是存在负环。 复杂度分析对比Dijkstra+heap 因为是堆，取队头需要O(lgV)。 松弛边时，因为点的d改变了，所以点v需要以新距离重新入堆，O(lgV)，总共O(ElgV)。 因此总的是O((V+E)lgV) SPFA 论文证明也不严格。复杂度不太好分析。 总的是O(kE)。k大概为2。 复杂度应该是 O(VE)。 适用场景如果是稠密图，Dijkstra+heap比SPFA快。稀疏图则SPFA更快。SPFA可以有SLF和LLL两种优化，SLF就是d比队头小就插入队头，否则插入队尾。 另外，Dijkstra和Prim也很相似，它们的区别主要是d的含义，前者是到s的临时最短距离，后者是到树的临时最短距离，相同点是，每次找d最小的更新其它点的距离。 Dijkstra堆优化版代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxx = 0x3f3f3f3f3f3f3f3f;const int maxn = 1e5+7;int t,n,m,cnt;ll dis[maxn];bool vis[maxn];int head[maxn];struct EDGE&#123; int next; int to; ll w;&#125;edge[2*maxn];struct NODE&#123; int u; ll dis; NODE()&#123;&#125; NODE(int u,ll w):u(u),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const &#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn];void add(int u, int v, ll w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt; cnt++;&#125;void dijkstra(int s)&#123; memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis)); priority_queue&lt;NODE&gt;q; q.push(NODE(s,0)); while(!q.empty())&#123; int kk = q.top().u; ll minD = q.top().dis; q.pop(); if(vis[kk]) continue; vis[kk] = true; for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; if(!vis[edge[l].to]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123; dis[edge[l].to] = minD + edge[l].w; q.push(NODE(edge[l].to,dis[edge[l].to][j])); &#125; &#125; &#125;&#125;int main()&#123; ll u,v,w; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(head,-1,sizeof(head)); cnt = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 0;i &lt; m; i++)&#123; scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; dijkstra(1); if(dis[n]!=maxx) printf(&quot;%lld\n&quot;,dis[n]); else printf(&quot;0\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
        <tag>SPFA算法</tag>
        <tag>Bellman-Ford算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[分层最短路]Magical Girl Haze]]></title>
    <url>%2F2018%2F09%2F04%2F2018-09-04%2F</url>
    <content type="text"><![CDATA[问题描述一张图，共有m条路，从1走到n，一共可以使k条路的路程为0，求最短路。 思路去掉的k条路肯定全部在从1到n的某一条路径上，这样走这一条路径才有可能最短。我们可以对最短路分层，即分别求k为0，k为1，k为2……k为k的情况下最短路程。定义最短路时使用二维数组dis[n][k],n为结点数，k为分层数。设i为每次求得的最短路结点，kk为所在层，dis为最短路，原点到原点的距离为0，则： 最短路状态转移方程：dis[j][kk]=min(dis[i][kk]+road[i][j],dis[j][kk]) 分层状态转移方程：dis[j][kk+1]=min(dis[i][kk],dis[j][kk+1]) Magical Girl HazeThere are NN cities in the country, and MMdirectional roads from uu to v(1\le u, v\le n)v(1≤u,v≤n). Every road has a distance c_ici. Haze is a Magical Girl that lives in City 11, she can choose no more than KK roads and make their distances become 00. Now she wants to go to City NN, please help her calculate the minimum distance. InputThe first line has one integer T(1 \le T\le 5)T(1≤T≤5), then following TT cases. For each test case, the first line has three integers N, MN,M and KK. Then the following MM lines each line has three integers, describe a road, U_i, V_i, C_iUi,Vi,Ci. There might be multiple edges between uu and vv. It is guaranteed that N \le 100000, M \le 200000, K \le 10N≤100000,M≤200000,K≤10,0 \le C_i \le 1e90≤Ci≤1e9. There is at least one path between City 11 and City NN. OutputFor each test case, print the minimum distance. 样例输入复制1234567815 6 11 2 21 3 42 4 33 4 13 5 64 5 2 样例输出复制13 题目来源ACM-ICPC 2018 南京赛区网络预赛 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll maxx = 0x3f3f3f3f3f3f3f3f;const int maxn = 1e5+7;int t,n,m,k,cnt;ll dis[maxn][12];bool vis[maxn][12];int head[maxn];struct EDGE&#123; int next; int to; ll w;&#125;edge[2*maxn];struct NODE&#123; int u, j; ll dis; NODE()&#123;&#125; NODE(int u,int j,ll w):u(u),j(j),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const &#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn];void add(int u, int v, ll w)&#123; edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt; cnt++;&#125;void dijkstra(int s)&#123; memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis)); priority_queue&lt;NODE&gt;q; q.push(NODE(s,0,0)); while(!q.empty())&#123; int kk = q.top().u; int j = q.top().j; ll minD = q.top().dis; q.pop(); if(vis[kk][j]) continue; vis[kk][j] = true; for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; if(j&lt;k&amp;&amp;!vis[edge[l].to][j+1]&amp;&amp;dis[edge[l].to][j+1] &gt; minD)&#123; dis[edge[l].to][j+1] = minD; q.push(NODE(edge[l].to,j+1,dis[edge[l].to][j+1])); &#125; if(!vis[edge[l].to][j]&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to][j])&#123; dis[edge[l].to][j] = minD + edge[l].w; q.push(NODE(edge[l].to,j,dis[edge[l].to][j])); &#125; &#125; &#125;&#125;int main()&#123; ll u,v,w; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; memset(head,-1,sizeof(head)); cnt = 0; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i = 0;i &lt; m; i++)&#123; scanf(&quot;%d%d%lld&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; dijkstra(1); if(dis[n][k]!=maxx) printf(&quot;%lld\n&quot;,dis[n][k]); else printf(&quot;0\n&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>分层最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]辗转相除法求gcd的数学证明]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03-2%2F</url>
    <content type="text"><![CDATA[在写证明过程之前，我们先回顾一下最大公约数gcd的欧几里得求法。 gcd，即最大公因数。为了书写方便，人们常习惯以gcd(a,b)表示a,b的最大公因数。那最小公倍数呢？我们知道若已知a,b,gcd(a,b),那么最小公倍数就自然等于a * b / gcd(a,b)。这里就不证明了。 我们接着看gcd，如何高效求gcd呢？目前最快的方法算是欧几里得算法了。 欧几里得算法其实很简单，已知a，b，其中a&gt;b，求gcd(a,b)。 解：用b整除a，得到余数c，再用c整除b，得到余数d，再用d整除c，得到余数e……不断这样操作，最后直到没有余数为止。假设e再整除d，余数为0，则e为最大公因数。 列式子即为： a = x1 * b + r1; b = x2 * r1 + r2; r1 = x3 * r2 + r3; …… rn-1= xn+1 * rn + rn+1; rn = xn+2 * rn+1 + 0; 若设a为r-1，b为r0，则通项公式即为rn-1 / rn = xn+1 rn + rn+1，最后一项为rn / rn+1 = xn+2 rn+1。 很容易理解，若某一步余数为0，则上一步的余数即为最大公约数。很容易证明该循环一定会终止，因为最坏的情况下a和b的最大公因数是1，那么任何一个数都是1的倍数，所以任何数取余1都为0，所以循环必会结束。 该算法历经千年，直到现在依然为求解gcd最高效的算法，gcd(a,b)最坏的情况下运算次数最多才是b位数的7位，这里就不详细介绍了。 那么为什么最后的结果就是最大公因数呢，接下来我们来证明一下。 假设g为gcd(a,b)，即g为g，b的最大公因数，则带到上式记为rn = xn+2 * g，这个式子g必然为rn的因数。 那再带到上一个式子，rn-1 = xn+1 * rn + g，由于g既是rn的因数，又是g的因数，则g是rn-1的因数。 再带到上一个式子，rn-2 = xn * rn-1 + rn，由于g是rn-1，rn的因数，所以g必然是rn-2的因数。 …… 最终带到第一组式子中，即g既是a的因数，也是b的因数。 那如何证明它是最大公因数呢？ 我们假设h为a，b的任意因数，则h整除a，且h整除b，带到第一个式子，则h整除r1，再带到第2个式子，h整除r2，再带到第3个式子，h整除r3……直到倒数第二个式子，h整除rn+1，即h整除g由于最后一个式子余数为0，那么既然g为a，b的因数，h为g的因数，则h&lt;=g，故g为gcd(a,b)。 证毕。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An Olympian Math Problem]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03-1%2F</url>
    <content type="text"><![CDATA[问题描述： 求解(1 * 1! + 2 * 2! + …… + (n-2) * (n-2)! + (n-1) * (n-1)!) mod n = n - 1。 PS：n! = 1 * 2 * …… * n。 证明过程： Alice, a student of grade 66, is thinking about an Olympian Math problem, but she feels so despair that she cries. And her classmate, Bob, has no idea about the problem. Thus he wants you to help him. The problem is: We denote k!k!: k! = 1 \times 2 \times \cdots \times (k - 1) \times kk!=1×2×⋯×(k−1)×k We denote SS: S = 1 \times 1! + 2 \times 2! + \cdots +S=1×1!+2×2!+⋯+(n - 1) \times (n-1)!(n−1)×(n−1)! Then SS module nn is ____ You are given an integer nn. You have to calculate SS modulo nn. InputThe first line contains an integer T(T \le 1000)T(T≤1000), denoting the number of test cases. For each test case, there is a line which has an integer nn. It is guaranteed that 2 \le n\le 10^{18}2≤n≤1018. OutputFor each test case, print an integer SS modulo nn. HintThe first test is: S = 1\times 1!= 1S=1×1!=1, and 11modulo 22 is 11. The second test is: S = 1\times 1!+2 \times 2!= 5S=1×1!+2×2!=5, and 55 modulo 33 is 22. 样例输入复制123223 样例输出复制1212 题目来源ACM-ICPC 2018 南京赛区网络预赛 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll t,n;int main()&#123; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld&quot;,&amp;n); printf(&quot;%lld\n&quot;,n-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介于邻接矩阵与邻接表之间的存图方式————链式前向星]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03%2F</url>
    <content type="text"><![CDATA[链式前向星 图的存储一般有三种：邻接矩阵、邻接表、前向星。 若图是稀疏图，边很少，开二维数组很浪费; 若点很多(如10000个点)a[10000][10000]又会爆.只能用前向星做. 前向星的效率不是很高，优化后为链式前向星，直接介绍链式前向星。 （一）链式前向星1. 结构这里用两个东西： 1 结构体数组edge存边，edge[i]表示第i条边, 2 head[i]存以i为起点的第一条边(在edge中的下标) 123456struct EDGE&#123; int next; //下一条边的存储下标(默认0) int to; //这条边的终点 int w; //权值 &#125;; EDGE edge[500010]; 2.增边若以点i为起点的边新增了一条，在edge中的下标为j. 那么edge[j].next=head[i];然后head[i]=j. 即每次新加的边作为第一条边，最后倒序遍历 1234567void Add(int u, int v, int w) &#123; //起点u, 终点v, 权值w //cnt为边的计数，从1开始计 edge[++cnt].next = head[u]; edge[cnt].w = w; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 &#125; 3. 遍历遍历以st为起点的边 1for(int i=head[st]; i!=0; i=edge[i].next) i开始为第一条边，每次指向下一条(以0为结束标志) （若下标从0开始，next应初始化-1） 一个简单的输出有向图熟悉链式前向星： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;#define MAXM 500010#define MAXN 10010struct EDGE&#123; int next; //下一条边的存储下标 int to; //这条边的终点 int w; //权值 &#125;; EDGE edge[MAXM];int n, m, cnt;int head[MAXN]; //head[i]表示以i为起点的第一条边 void Add(int u, int v, int w) &#123; //起点u, 终点v, 权值w edge[++cnt].next = head[u]; edge[cnt].w = w; edge[cnt].to = v; head[u] = cnt; //第一条边为当前边 &#125; void Print() &#123; int st; cout &lt;&lt; &quot;Begin with[Please Input]: \n&quot;; cin &gt;&gt; st; for(int i=head[st]; i!=0; i=edge[i].next) &#123;//i开始为第一条边，每次指向下一条(以0为结束标志)若下标从0开始，next应初始化-1 cout &lt;&lt; &quot;Start: &quot; &lt;&lt; st &lt;&lt; endl; cout &lt;&lt; &quot;End: &quot; &lt;&lt; edge[i].to &lt;&lt; endl; cout &lt;&lt; &quot;W: &quot; &lt;&lt; edge[i].w &lt;&lt; endl &lt;&lt; endl; &#125;&#125;int main() &#123; int s, t, w; cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=m; i++) &#123; cin &gt;&gt; s &gt;&gt; t &gt;&gt; w; Add(s, t, w); &#125; Print(); return 0;&#125; （二）链式前向星实现SPFA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define MAXM 500010#define MAXN 10010#define ANS_MAX 2147483647struct EDGE &#123; int next; int to; int w;&#125;;EDGE edge[MAXM];int n, m, st, cnt;int head[MAXN];int d[MAXN];bool inq[MAXN];inline int Read() &#123; char c; int ans = 0; bool Sign = false; while(!isdigit(c=getchar()) &amp;&amp; c != &apos;-&apos;); if(c == &apos;-&apos;) &#123; Sign = true; c = getchar(); &#125; do &#123; ans = (ans&lt;&lt;3) + (ans&lt;&lt;1) + (c ^ &apos;0&apos;); &#125; while(isdigit(c=getchar())); return Sign ? -ans : ans;&#125;void Add(int u, int v, int w) &#123; edge[++cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; head[u] = cnt;&#125;void read() &#123; int x, y, w; n = Read(); m = Read(); st = Read(); for(int i=1; i&lt;=m; i++) &#123; x = Read(); y = Read(); w = Read(); Add(x, y, w); &#125;&#125;void SPFA(int x) &#123; d[x] = 0; for(int i=1; i&lt;=n; i++) d[i] = ANS_MAX; queue&lt;int&gt; Q; Q.push(x); inq[x] = true; while(!Q.empty()) &#123; int k = Q.front(); Q.pop(); inq[k] = false; for(int i=head[k]; i!=0; i=edge[i].next) &#123; int j = edge[i].to; if(d[j] &gt; d[k] + edge[i].w) &#123; d[j] = d[k] + edge[i].w; if(!inq[j]) &#123; Q.push(j); inq[j] = true; &#125; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) printf(&quot;%d &quot;, d[i]); printf(&quot;\n&quot;);&#125;int main() &#123; read(); SPFA(st); return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>链式前向星</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018中国大学生程序设计竞赛 - 网络选拔赛 1001 Buy and Resell]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25-2%2F</url>
    <content type="text"><![CDATA[Buy and ResellTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day:\1. spend ai dollars to buy a Power Cube\2. resell a Power Cube and get ai dollars if he has at least one Power Cube\3. do nothingObviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:The first line has an integer n. (1≤n≤105)The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)It is guaranteed that the sum of all n is no more than 5×105. Output For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 3 4 1 2 10 9 5 9 5 9 10 5 2 2 1 Sample Output Hint profit = - 1 - 2 + 10 + 9 = 16 profit = - 5 + 10 = 5 profit = 0 题解： n天，每天商品有个价格，或买或卖或不买不卖。 贪心策略：分为两个堆（或优先队列），一个堆v为储存买的价格，一个堆s储存卖的价格。第i天的商品和之前买与卖两个堆中的最小值进行比较。共分为四种情况：1.如果第i天的价格比买的堆v里最小值大，且买的堆v里最小值比卖的堆s里最小值小，则买掉买的堆v里最小的，再卖出去，交易次数加2，即v.pop(),s.push(),cnt+2。2.如果第i天的价格比卖的堆s里最小值大，且买的堆v里最小值比卖的堆s里最小值大，则买掉卖的堆s里最小的，再卖出去，意思为现在卖比之前卖的那次更划算，我们把它买回来就等于之前那次没有卖，再卖出去等于现在才卖，即s.pop(),v.push(),s.push()。3.如果当天的价格即小于s中最小又小于v中最小，则把他放到买的堆v里，即v.push()。 这样下来，最后买的堆里剩下的就是没买没卖的。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; ll t; scanf(&quot;%lld&quot;,&amp;t); while(t--)&#123; ll n, tmp, cnt = 0,sum = 0; scanf(&quot;%lld&quot;,&amp;n); priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;v,s; for(ll i = 0;i&lt;n;i++)&#123; scanf(&quot;%lld&quot;,&amp;tmp); if(!v.empty())&#123; if(!s.empty()&amp;&amp;tmp&gt;s.top()&amp;&amp;s.top()&lt;=v.top())&#123; sum+=tmp-(s.top()); v.push(s.top()); s.pop(); s.push(tmp); &#125; else if(tmp&gt;v.top()&amp;&amp;(s.empty()||s.top()&gt;v.top()))&#123; s.push(tmp); sum+=tmp-(v.top()); v.pop(); cnt++; &#125; else if(tmp&lt;=v.top())&#123; v.push(tmp); &#125; &#125; else&#123; if(!s.empty()&amp;&amp;tmp&gt;s.top())&#123; v.push(s.top()); sum+=tmp-s.top(); s.pop(); s.push(tmp); &#125; else v.push(tmp); &#125; &#125; printf(&quot;%lld %lld\n&quot;,sum,2*cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018中国大学生程序设计竞赛 - 网络选拔赛 1009 Tree and Permutation]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25-1%2F</url>
    <content type="text"><![CDATA[Tree and PermutationTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0 Problem Description There are N vertices connected by N?1 edges, each edge has its own length.The set { 1,2,3,…,N } contains a total of N! unique permutations, let’s say the i-th permutation is Pi and Pi,j is its j-th number.For the i-th permutation, it can be a traverse sequence of the tree with N vertices, which means we can go from the Pi,1-th vertex to the Pi,2-th vertex by the shortest path, then go to the Pi,3-th vertex ( also by the shortest path ) , and so on. Finally we’ll reach the Pi,N-th vertex, let’s define the total distance of this route as D(Pi) , so please calculate the sum of D(Pi) for all N! permutations. Input There are 10 test cases at most.The first line of each test case contains one integer N ( 1≤N≤105 ) .For the next N?1 lines, each line contains three integer X, Y and L, which means there is an edge between X-th vertex and Y-th of length L ( 1≤X,Y≤N,1≤L≤109 ) . Output For each test case, print the answer module 109+7 in one line. Sample Input 3 1 2 1 2 3 1 3 1 2 1 1 3 2 Sample Output 16 24 题意： 首先给出一个含有n个节点的树，边权为距离。 对于1-n的某一种排列p1,p2,p3……pn，贡献为dis(p1,p2)+dis(p2,p3)+dis(p3,p4)+……+dis(pn-1,pn) 求所有排列的贡献和 题解： 一棵树n个结点n-1条边，所以任意两点之间都有最短距离。由于所有遍历方式可以看做n个结点的排列，而每次有直接关系的只有两点之间的距离，因此只需求出两点之间的距离在所有排列中一共出现多少次即可。 比如n=2时，两个点1,2，共有两种排列方式，即1,2,和2,1 n=3时，三个点1,2,3,其中1,2共有4种方法得到，即1,2,3,和2,1,3,和3,1,2,和3,2,1 n=4时，三个点1,2,3,4,其中1,2共有12种方法得到，即1,2,3,4,和1,2,4,3,和2,1,3,4,和2,1,4,3,和3,1,2,4,和3,2,1,4和4,1,2,3,和4,2,1,3,和3,4,1,2,和4,3,1,2,和3,4,2,1,和4,3,2,1, n=jie[n-1]*（n-1）。 先用树状dp求出所有两两结点之间的距离之和，再乘以每条边在所有结点排列的n！方式中一共用到的次数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+7;const ll mod = 1e9+7;ll sum[maxn], n;ll dp[maxn];ll jie[maxn];ll jie2[maxn];struct Edge&#123; ll v, w;&#125;;vector&lt;Edge&gt; tree[maxn];void init()&#123; jie[2] = 2; for(ll i = 3;i&lt;maxn;i++)&#123; jie[i] = jie[i-1]*(i-1)%mod; &#125;&#125;void dfs(ll cur, ll father)&#123; sum[cur] = 1; for(ll i = 0; i &lt; tree[cur].size(); i++) &#123; ll son = tree[cur][i].v; ll len = tree[cur][i].w; if(father == son) continue; dfs(son, cur); sum[cur] += sum[son]%mod; sum[cur]%=mod; dp[cur] += (dp[son]%mod + (n-sum[son])%mod*sum[son]%mod * len%mod)%mod; dp[cur]%=mod; &#125;&#125;int main()&#123; init(); ll u, v, w; while(scanf(&quot;%lld&quot;, &amp;n)!=EOF) &#123; if(n&lt;=2)&#123; if(n==1)&#123; printf(&quot;0\n&quot;); continue; &#125; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w); printf(&quot;%lld\n&quot;, 2*w%mod); continue; &#125; for(ll i = 0; i &lt; n; i++) tree[i].clear(); memset(sum, 0, sizeof(sum)); memset(dp, 0, sizeof(dp)); for(ll i = 0; i &lt; n-1; i++) &#123; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w); u--,v--; Edge t1, t2; t1.v = v; t1.w = w; t2.v = u; t2.w = w; tree[u].push_back(t1); tree[v].push_back(t2); &#125; dfs(0, -1); printf(&quot;%lld\n&quot;, (dp[0]%mod)*jie[n]%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>组合数学</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018中国大学生程序设计竞赛 - 网络选拔赛 1004 Find Integer]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25%2F</url>
    <content type="text"><![CDATA[Find IntegerTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description people in USSS love math very much, and there is a famous math problem .give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn. Input one line contains one integer T;(1≤T≤1000000)next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000) Output print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);else print two integers -1 -1 instead. Sample Input 1 2 3 Sample Output 4 5 题解：本题首先用到了费马大定理，即a^n+b^n≠c^n。(a,b,c∈Z，n&gt;2) 所以当n大于2或者n为0时直接输出-1,-1，当n=1时直接输出1,a+1。 当n=2时，输出勾股数。 首先a²+b²=c²，a²=c²-b²，a²=(c+b)(c-b)。 设x=c+b，y=c-b，则a²=xy。 c=(x+y)/2，b=(x-y)/2。 当然我的方法是通过打表求得勾股数，方法有点偏暴力，即枚举x，y，然后用公式看c，b是否在范围内且为整数，当然在枚举的时候少不了剪枝，不然肯定tle。 不过后来听说根据费马大定理奇偶数列法则可。直接推出式子。 打表代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct node&#123; ll b,c;&#125;aa[40007];void init()&#123; memset(aa,0,sizeof(aa)); for(ll i = 3;i&lt;=40000;i++)&#123; for(ll j = 1;j&lt;i;j++)&#123; if(i*i%j==0)&#123; ll x = j; ll y = i*i/j; if((x+y)%2==0)&#123; aa[i].c=(x+y)/2; aa[i].b=(y-x)/2; break; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; ll a,b,c,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a); if(n&gt;2||n==0)&#123; printf(&quot;-1 -1\n&quot;); continue; &#125; else if(n==1)&#123; printf(&quot;1 %lld\n&quot;,a+1); continue; &#125; else&#123; if(aa[a].b)&#123; printf(&quot;%lld %lld\n&quot;,aa[a].b,aa[a].c); &#125; else printf(&quot;-1 -1\n&quot;); &#125; &#125; return 0;&#125; 0(1)代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll a,b,c,n; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;a); if(n&gt;2||n==0) &#123; printf(&quot;-1 -1\n&quot;); continue; &#125; else if(n==1) &#123; printf(&quot;1 %lld\n&quot;,a+1); continue; &#125; else &#123; if(a%2==1&amp;&amp;a&gt;1) &#123; ll cc=(a-1)/2; b=2*cc*(cc+1); c=2*cc*(cc+1)+1; printf(&quot;%lld %lld\n&quot;,b,c); &#125; else if(a%2==0&amp;&amp;a&gt;2) &#123; ll cc=a/2; b=cc*cc-1; c=cc*cc+1; printf(&quot;%lld %lld\n&quot;,b,c); &#125; else&#123; printf(&quot;-1 -1\n&quot;); &#125; &#125; &#125; return 0;&#125; 推导过程：a为任意情况 a² = c² - b² a² = (c+b)(c-b) a² = a² * 1 c + b = a² c - b = 1 c = (a² + 1) / 2 b = (a² - 1) / 2 a为偶数情况： if(a² % 2 == 0) a² = a²/2 * 2 c + b = a²/2 c - b = 2 c = a²/4 + 1 b =a²/4 - 1 证毕]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>数论</tag>
        <tag>CCPC</tag>
        <tag>费马大定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.23网络流专项训练题解]]></title>
    <url>%2F2018%2F08%2F23%2F2018-08-23%2F</url>
    <content type="text"><![CDATA[问题 A: 赛马时间限制: 1 Sec 内存限制: 128 MB提交: 32 解决: 5[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述古有田忌赛马戏齐王，今有悠悠赛马虐渣渣。悠悠和他的小老弟渣渣每人有n匹马，每匹马都有一个评分，分数越高速度越快。现在渣渣不甘于当小老弟，随着赛马曲的想起，渣渣决定挑战悠悠，规则同田忌赛马。每胜一局得1分，每负一局减一分，赵神做裁判，悠悠为了捍卫自己的王者地位，决定出老千，问了赵神关于渣渣的赛马顺序，请问悠悠最高能得多少分。 输入文件有多组测试样例，遇0为止。 首行一个整数n，n&lt;=1000; 第2行n个整数表示悠悠每匹马的分数。 第3行n个整数表示渣渣每匹马的分数。0&lt;=分数&lt;500; 输出输出悠悠最高分。 样例输入123456789103192 173 71195 177 74210 1010 102220 219222 2180 样例输出123100 提示水题，可以用网络流或者匹配，也可以用更简单的方法。 [提交][状态][Edit][TestData)] 题解本题贪心可解。贪心策略即田忌赛马的策略。第1步我们将我们最慢的马和对方最快的马进行比较，如果最慢的马比对方最慢的马快，那么我们就胜一局，然后返回第1步。反之我们进行第2步，继续拿我们最快的马和对方最快的马进行比较，如果获胜就胜一局，然后返回第1步。反之我们进行第3步，继续拿我们最慢的马和对方最快的马进行比较，这种情况下分为两种情况，一种是得分相等，另外一种是我方必败，必败得分减一，否则不变，然后我们再返回第1步。直到所有的马都结束为止，此时我们就得到了最高得分。 代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int a[1007],b[1007];int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int n; while(cin&gt;&gt;n)&#123; if(n==0) break; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; sort(a,a+n); sort(b,b+n); int s=0; for(int i=0,j=0,k=n-1,l=n-1; i&lt;=k;)&#123; if(a[i]&gt;b[j]) s++,i++,j++; else if(a[k]&gt;b[l]) s++,k--,l--; else&#123; if(a[i]&lt;b[l]) s--; i++,l--; &#125; &#125; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; 问题 B: 海上钢琴师时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述宁愿一生孤独，不愿随波逐流。海上钢琴师毅然留在了船上，与大海为伴，此生再不上岸。 然而，他的音乐却已名扬四海。为了将他的钢琴声可以传播到陆地以便欣赏，人们决定在陆地与钢琴师所在的船之间的n-2座岛屿上建立声音保留设备。每当声音传到该设备处时，以该设备为起点可以将声音信号发送到其他与该设备有信号连接的设备那里。信号传播是单向的，且是有限的。当该设备将一部分信号传给其他设备时，该设备所拥有的总信号要减去相应传出去的信号，所保留的信号可以继续传给其他的设备。船上也有该设备，由于岛屿与船的位置不同，所以钢琴声传到设备的声音有限。设备与设备之间的传播分贝也有限。陆地的总接收设备与某些岛屿上的设备有信号连接，请问陆地最多能收到多少分贝的钢琴声。 输入第一行输入两个数m，n。m代表共有m对设备建立了单向连接。n代表包括船和陆地在内共有n个设备。编号1为船，编号n为陆地，其他为岛屿（n&lt;=100，m&lt;=1000） 接下来m行，每行三个数a，b，c，代表a-&gt;b，即a的信号可以传到b信号，最大可以通过该信号传送c分贝。c&lt;=2000 输出输出陆地上最大可以收到多少分贝声音。（海上钢琴声不超过10000分贝） 样例输入1234565 41 2 1001 3 502 3 23 4 602 4 99 样例输出1150 提示样例解释：（容量，流量） 方案1： 方案2： [提交][状态][Edit][TestData)] 题解网络流最大流模板题。题面转化过来就是一个网络流模型，船为s，陆地为t，设备之间的连接就是弧。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+7;const int inf=0x3f3f3f3f;int r[maxn][maxn]; //残留网络，初始化为原图bool visit[maxn];int pre[maxn];int m,n;bool bfs(int s,int t) //寻找一条从s到t的增广路，若找到返回true&#123; int p; queue&lt;int &gt; q; memset(pre,-1,sizeof(pre)); memset(visit,false,sizeof(visit)); pre[s]=s; visit[s]=true; q.push(s); while(!q.empty()) &#123; p=q.front(); q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(r[p][i]&gt;0&amp;&amp;!visit[i]) &#123; pre[i]=p; visit[i]=true; if(i==t) return true; q.push(i); &#125; &#125; &#125; return false;&#125;int EdmondsKarp(int s,int t)&#123; int flow=0,d,i; while(bfs(s,t)) &#123; d=inf; for(i=t;i!=s;i=pre[i]) d=d&lt;r[pre[i]][i]? d:r[pre[i]][i]; for(i=t;i!=s;i=pre[i]) &#123; r[pre[i]][i]-=d; r[i][pre[i]]+=d; &#125; flow+=d; &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;m&gt;&gt;n) &#123; int u,v,w; memset(r,0,sizeof(r)); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r[u][v]+=w; &#125; cout&lt;&lt;EdmondsKarp(1,n)&lt;&lt;endl; &#125; return 0;&#125; 问题 C: 进击的巨人时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述那一年，巨人发起了第一轮进击，s城破，埃尔文团长带领众居民计划逃往较安全的t城。从s城到t城之间共有m坐城市，某些城市之间构成单向通路。由s城到t城恰构成一个有向无环图。然而每条路上都有限定的最大人流量。埃尔文团长想知道每一次最多有多少居民能到达t城。 输入首行输入两个数n，m（n，m&lt;=100），n0为s城，nn为t城。s城到t城之间的城用n1——nn表示。m表示单项通道数。 接下来m行，每行三个数a，b，c，代表a到b的最大人流量是c。c&lt;1000。 输出输出最多有多少人到t 样例输入1234567891011121314156 140 2 50 1 101 2 60 3 53 1 21 5 35 2 35 4 33 5 33 4 43 6 52 6 64 6 102 4 4 样例输出118 [提交][状态][Edit][TestData)] 题解网络流最大流模板题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+7;const int inf=0x3f3f3f3f;int r[maxn][maxn]; //残留网络，初始化为原图bool visit[maxn];int pre[maxn];int m,n;bool bfs(int s,int t) //寻找一条从s到t的增广路，若找到返回true&#123; int p; queue&lt;int &gt; q; memset(pre,-1,sizeof(pre)); memset(visit,false,sizeof(visit)); pre[s]=s; visit[s]=true; q.push(s); while(!q.empty()) &#123; p=q.front(); q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(r[p][i]&gt;0&amp;&amp;!visit[i]) &#123; pre[i]=p; visit[i]=true; if(i==t) return true; q.push(i); &#125; &#125; &#125; return false;&#125;int EdmondsKarp(int s,int t)&#123; int flow=0,d,i; while(bfs(s,t)) &#123; d=inf; for(i=t;i!=s;i=pre[i]) d=d&lt;r[pre[i]][i]? d:r[pre[i]][i]; for(i=t;i!=s;i=pre[i]) &#123; r[pre[i]][i]-=d; r[i][pre[i]]+=d; &#125; flow+=d; &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m) &#123; int u,v,w; memset(r,0,sizeof(r)); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r[u][v]+=w; &#125; cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl; &#125; return 0;&#125; 问题 D: X档案时间限制: 1 Sec 内存限制: 128 MB提交: 5 解决: 3[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述据X档案记载，倘若外星文明即将攻击地球，会在战争之前发动病毒袭击，最合理的对象是鸟或狗，因为鸟在空中传播病毒的范围2较广，而狗相较于其他动物来说和人类接触最频繁。X城作为全球反外星文明的重要基地，对外星文明来说威胁最大而作为外星文明首先攻击的目标。因此，X长官下令捕杀了全城的鸟，而狗由于受到爱狗人士们的保护免于此劫。然而灾难还是降临了，外星文明悄无声息地将病毒注入到一些狗体内。据全球卫星显示，X城的地形是一个nm的矩阵，划分成了nm个11的小矩阵。矩阵的四周被城墙所围。而在某些单位11的小矩阵中有居民，或者有被感染的狗。我们已经知道了狗的全部坐标，为了安全起见，X长官启动了X计划，将这些狗在未发作之前用围栏隔离起来以防止狗攻击人类，每个1*1的小矩阵四周均可建立围栏。该计划收录到了X档案中。围栏使得狗和人类均无法通过。由于计划的机密性，长官不想动用太多的财力，现求最少需要多长围栏才能将所有狗隔离。 输入输入包含多组样例，读到文件结束。 第一行为n，m，代表n*m的矩阵。（0&lt;n，m&lt;=150） 接下来n行，每行m个由0，1，2组成的数。 0代表此处没有任何东西，1代表此处有人，2代表此处有被感染的狗。 输出输出格式为：Case i: k i为第i组样例，k为所需最短的围栏长度。 样例输入12345678910115 60 0 0 1 0 02 0 0 0 0 10 0 1 0 0 00 0 2 0 0 10 0 0 1 0 04 60 0 1 0 0 10 0 0 1 1 00 0 0 0 2 20 1 1 0 2 0 样例输出12Case 1: 6Case 2: 4 提示第1组样例解释： 第2组样例解释： [提交][状态][Edit][TestData)] 题解题目描述那么多，其实就是最小割问题。只不过我们要建立一个超级源点指向所有狼（羊），再建立一个超级汇点指向所有羊（狼）。羊和狼为结点，两个节点直接一条边，权值为1。最终求解最大流即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define maxn 100100#define inf 0x3f3f3f3fusing namespace std;int to[maxn],c[maxn],first[maxn],Next[maxn],N;int d[maxn];int Q[maxn],bot,top,tag[maxn],can[maxn];int s,t,n,m,tmp,ans,cas=0;int TAG=5201314;void _init()&#123; ans=s=0,t=n*m+1,N=-1; for (int i=s; i&lt;=t; i++) first[i]=-1;&#125;void edge(int U,int V,int W)&#123; N++; to[N]=V,c[N]=W; Next[N]=first[U],first[U]=N;&#125;void _input()&#123; int cur=0; for (int i=1; i&lt;=n; i++) for (int j=1; j&lt;=m; j++) &#123; scanf(&quot;%d&quot;,&amp;tmp); cur++; if (i&lt;n) edge(cur,cur+m,1),edge(cur+m,cur,1); if (j&lt;m) edge(cur,cur+1,1),edge(cur+1,cur,1); if (tmp==2) edge(s,cur,inf),edge(cur,s,inf); else if (tmp==1) edge(cur,t,inf),edge(t,cur,inf); &#125;&#125;bool bfs()&#123; TAG++; Q[bot=top=1]=t,d[t]=0,tag[t]=TAG; while (bot&lt;=top) &#123; int cur=Q[bot++]; for (int i=first[cur]; i!=-1; i=Next[i]) &#123; if (c[i^1]&lt;=0 || tag[to[i]]==TAG) continue; tag[to[i]]=TAG,d[to[i]]=d[cur]+1,Q[++top]=to[i]; if (to[i]==s) return true; &#125; &#125; return false;&#125;int dfs(int cur,int num)&#123; if (cur==t) return num; int tmp=num,k; for (int i=first[cur]; i!=-1; i=Next[i]) &#123; if (d[cur]!=d[to[i]]+1 || c[i]&lt;=0 || tag[to[i]]!=TAG || can[to[i]]==TAG) continue; k=dfs(to[i],min(num,c[i])); if (k) c[i]-=k,c[i^1]+=k,num-=k; if (num==0) break; &#125; if (num) can[cur]=TAG; return tmp-num;&#125;void dinic()&#123; while (bfs()) ans+=dfs(s,inf);&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; _init(); _input(); dinic(); printf(&quot;Case %d: %d\n&quot;,++cas,ans); &#125; return 0;&#125; 问题 E: 同桌的你时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述据yoyo统计，青春期的情侣80%都是曾经的同桌。因此，选择好的同桌对你日后的感情发展有很大的帮助。高一7班共有n个男生，m个女生，男生们听过分析后纷纷要求重新排座位，以期待和心仪的女生做同桌。每个男生都有自己的暗恋对象，0&lt;=暗恋对象的个数&lt;=m，也就是说某个男生最多暗恋全班女生，最少一个都不暗恋。汪老师知道这件事后很是重视，于是开始调座位，优先考虑男生和他的暗恋女生坐在一起。男生用a表示，女生用n表示。请问最多有多少男生能和自己心仪的对象坐在一起。 输入首行输入n，m，e（0&lt;n，m&lt;=1000，0&lt;=e&lt;=10000）n男m女e为所有男生暗恋女生的个数之和。 接下来e行，每行两个数i，j，代表ai男生暗恋bj女生。 输出一个整数，最优分配下最多有多少男生能和自己心仪的对象坐在一起。 样例输入1232 1 22 11 1 样例输出11 提示样例解释： 全班两个男生暗恋班里唯一一个女生，无论怎么分配只能凑成一对。 [提交][状态][Edit][TestData)] 题解二分图最大匹配问题。男生和女生构成二分图，每个男生和暗恋的女生之间建立一条边。由于不涉及到权值，因此可用匈牙利算法求解，当然也可用网络流求解。网络流的话就是在二分图的两部分分别建立超级源点s和超级汇点t，每条边的容量固定是1，然后此题就转化成了网络流问题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int cnt=2;int alist[6000001];struct data&#123; int v;int next;int value;&#125;edge[6000001];void add(int u,int v,int value)&#123; edge[cnt].v=v; edge[cnt].value=value; edge[cnt].next=alist[u]; alist[u]=cnt++; return ;&#125;int h[1000001];int q[1000001];bool bfs()&#123; int x,next; memset(h,-1,sizeof(h)); int head=0,tail=1; q[head]=1; h[1]=0; while(head&lt;tail) &#123; x=q[head++]; next=alist[x]; while(next) &#123; int v=edge[next].v; int value=edge[next].value; if(value&amp;&amp;h[v]&lt;0) &#123; q[tail++]=v; h[v]=h[x]+1; &#125; next=edge[next].next; &#125; &#125; if(h[n]==-1) return false; return true;&#125;int ans;int dfs(int x,int y)&#123; if(x==n) return y; int next=alist[x]; int w,used=0; while(next) &#123; int v=edge[next].v; int value=edge[next].value; if(value&amp;&amp;h[v]==h[x]+1) &#123; w=y-used; w=dfs(v,min(w,value)); edge[next].value-=w; edge[next^1].value+=w; used+=w; if(used==y) return y; &#125; next=edge[next].next; &#125; if(!used) h[x]=-1; return used;&#125;void dinic()&#123; while(bfs()) ans+=dfs(1,0x7fffffff);&#125;int n1,m1,e1;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;m1,&amp;e1); n=n1+m1+2; for(int i=1;i&lt;=n1;i++) &#123; add(1,i+1,1); add(i+1,1,1); &#125; for(int i=1;i&lt;=e1;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(u&lt;=n1&amp;&amp;v&lt;=m1) add(u+1,v+n1+1,1), add(v+n1+1,u+1,1); &#125; for(int i=1;i&lt;=m1;i++) &#123; add(i+n1+1,n,1); add(n,i+n1+1,1); &#125; dinic();//暴力跑最大流 printf(&quot;%d&quot;,ans); return 0;&#125; 问题 F: 奇迹暖暖时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述梅拉抢走了绫罗的设计图，暖暖决定帮绫罗抢过来。于是梅拉和暖暖开始了搭配比赛。梅拉和暖暖各有n套衣服。由于暖暖是天才服装搭配师，且自带主角光环，又怎会输呢，（废话，输了你怎么通关啊）只不过暖暖为了让梅拉输的心服口服，决定狠狠虐梅拉一把。针对梅拉的n套衣服，暖暖的每套衣服i得分都比梅拉的任意一套衣服j得分高出score(ij)，0&lt;=score(ij)&lt;100000。然而每比完一场，他们之后的比赛都不能再用这套的衣服了。所以对于n场比赛，求出暖暖最高能比梅拉高多少分？（至少为0） 输入首行输入n(n&lt;=300) 接下来n行，第i行表示暖暖的第i套衣服，每行n个数，第j个数表示暖暖第i套衣服比梅拉第j套衣服的分高多少分。 0&lt;=score(ij)&lt;100000 输出输出一个整数，即最高高出多少分 样例输入1232100 520 23 样例输出1123 [提交][状态][Edit][TestData)] 题解最大权二分图匹配。暖暖和梅拉构成二分图。每条边均有权值，最终求解二分匹配下的最大权值。二分图匹配除了网络流以外还有两道专门解二分图的算法，即匈牙利算法和KM算法。匈牙利算法一般解决二分图最大匹配问题，即边没有权值。而km算法一般解决有权值的二分图。本题为KM算法模板题。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;const int N=300+7;const int INF=0x3f3f3f3f;int n,nx,ny;int linker[N],lx[N],ly[N],slack[N];int visx[N],visy[N],w[N][N];int DFS(int x)&#123; visx[x]=1; for(int y=1;y&lt;=ny;y++)&#123; if(visy[y]) continue; int tmp=lx[x]+ly[y]-w[x][y]; if(tmp==0)&#123; visy[y]=1; if(linker[y]==-1 || DFS(linker[y]))&#123; linker[y]=x; return 1; &#125; &#125;else if(slack[y]&gt;tmp)&#123; slack[y]=tmp; &#125; &#125; return 0;&#125;int KM()&#123; int i,j; memset(linker,-1,sizeof(linker)); memset(ly,0,sizeof(ly)); for(i=1;i&lt;=nx;i++) //lx初始化为与它关联边中最大的 for(j=1,lx[i]=-INF;j&lt;=ny;j++) if(w[i][j]&gt;lx[i]) lx[i]=w[i][j]; for(int x=1;x&lt;=nx;x++)&#123; for(i=1;i&lt;=ny;i++) slack[i]=INF; while(1)&#123; memset(visx,0,sizeof(visx)); memset(visy,0,sizeof(visy)); if(DFS(x)) //若成功（找到了增广轨），则该点增广完成，进入下一个点的增广 break; //若失败（没有找到增广轨），则需要改变一些点的标号，使得图中可行边的数量增加。 //方法为：将所有在增广轨中（就是在增广过程中遍历到）的X方点的标号全部减去一个常数d， //所有在增广轨中的Y方点的标号全部加上一个常数d int d=INF; for(i=1;i&lt;=ny;i++) if(!visy[i] &amp;&amp; d&gt;slack[i]) d=slack[i]; for(i=1;i&lt;=nx;i++) if(visx[i]) lx[i]-=d; for(i=1;i&lt;=ny;i++) //修改顶标后，要把所有不在交错树中的Y顶点的slack值都减去d if(visy[i]) ly[i]+=d; else slack[i]-=d; &#125; &#125; int res=0; for(i=1;i&lt;=ny;i++) if(linker[i]!=-1) res+=w[linker[i]][i]; return res;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(~scanf(&quot;%d&quot;,&amp;n))&#123; nx=ny=n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;w[i][j]); int ans=KM(); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125; 问题 G: 巨人也疯狂时间限制: 1 Sec 内存限制: 128 MB提交: 2 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述人类发现巨人控制吃人的神经是由一些神经元和一些神经通道组成的，每个神经通道两端各有一个神经元，且这个通道是单向的。吃人信号从脑部神经元S发出到控制吃人的神经元T，S、T之间是一个有向无环图。人类想把某些神经通道切断达到S的信号无法传到T（由于神经元太小不容易砍掉，所以考虑神经元），每个神经通道由于位置不同也有砍断所需的力量。人类想知道如何花最小的力气而使S的信号传不到T。 输入首行输入两个数，n，m，（n，m&lt;1000）。n代表包括s，t在内共有n个节点，1为s，n为t。 接下来m行，每行3个数，a，b，c，表示a到b的神经通路需要花费c力气。 输出输出最小的力气。 样例输入1234567897 81 2 21 3 22 4 22 5 23 5 24 6 26 7 25 7 2 样例输出14 [提交][状态][Edit][TestData)] 题解网络流最小割模板题。根据最小割最大流定理，求最小割问题即求最大流问题。用FF算法，EK算法，Dinic算法，SAP算法，预流推进，均可解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200+7;const int inf=0x3f3f3f3f;int r[maxn][maxn]; //残留网络，初始化为原图bool visit[maxn];int pre[maxn];int m,n;bool bfs(int s,int t) //寻找一条从s到t的增广路，若找到返回true&#123; int p; queue&lt;int &gt; q; memset(pre,-1,sizeof(pre)); memset(visit,false,sizeof(visit)); pre[s]=s; visit[s]=true; q.push(s); while(!q.empty()) &#123; p=q.front(); q.pop(); for(int i=1;i&lt;=n;i++) &#123; if(r[p][i]&gt;0&amp;&amp;!visit[i]) &#123; pre[i]=p; visit[i]=true; if(i==t) return true; q.push(i); &#125; &#125; &#125; return false;&#125;int EdmondsKarp(int s,int t)&#123; int flow=0,d,i; while(bfs(s,t)) &#123; d=inf; for(i=t;i!=s;i=pre[i]) d=d&lt;r[pre[i]][i]? d:r[pre[i]][i]; for(i=t;i!=s;i=pre[i]) &#123; r[pre[i]][i]-=d; r[i][pre[i]]+=d; &#125; flow+=d; &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); while(cin&gt;&gt;n&gt;&gt;m) &#123; int u,v,w; memset(r,0,sizeof(r)); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; r[u][v]+=w; &#125; cout&lt;&lt;EdmondsKarp(0,n)&lt;&lt;endl; &#125; return 0;&#125; 问题 H: 过河拆桥时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述猴子是一种自私的动物。动物世界由河流分成了n个岛屿。这天，猴子在a1岛屿上望见an岛屿上有一片桃林。a1到an之间有n-2个岛屿，分别是a2——an-1。岛屿之间共有m坐桥，每座桥都有一定的距离。现在猴子通过这些桥从a1走到了an，然而由于猴子怕其他动物也过去享受那片桃林，于是每走一座桥都会拆一座桥。终于到了an，吃完桃子后，正直涨潮，于是他必须马上回到a1，由于之前走过的桥被拆了，所以只能寻找一条新的路回到a1。请问猴子从a1到an，再从an回到a1的最短路径是多少。 输入首行输入nm（n&lt;=1000m&lt;=10000） 接下来m行，每行三个数x，y，z，代表ax岛与ay岛之间有桥，距离是z。（z&lt;=35000） 输出输出一个整数，为最短距离。 样例输入1234564 52 3 12 4 21 2 13 4 11 3 2 样例输出16 [提交][状态][Edit][TestData)] 题解最小费用最大流问题。本题可以转化为从1到n找两条不重边的路，使得这两条路的距离之和加起来相对于其他方案来说最小。转化成功之后就是建模过程。首先以1为源点，n为汇点。边的长度就是每条边的费用，每条边的容量为1。由于我们要找两条路到达t，那么我们s点的流量就必须是2，这样流到t点的最大流最大为2，为1证明无解，为2即有解。然而由于源点流量一般无限大，那么我们只需再建立一个超级源点sss，和源点s相连，且容量为2，当然sss到s的费用为0。建完模之后我们就可以用最小费用最大流模板代码求解了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+7;const int inf=0x3f3f3f3f;struct edge&#123; int to,cap,cost ,rev;&#125;;int V;vector&lt;edge&gt;G[maxn];int dist[maxn];int prevv[maxn],preve[maxn];void add(int from,int to,int cap,int cost)&#123; edge e,w; e.to=to; e.cap=cap; e.cost=cost; e.rev=G[to].size(); G[from].push_back(e); w.to=from; w.cap=0; w.cost=-cost; w.rev=G[from].size()-1; G[to].push_back(w);&#125;int min_ans(int s,int t,int f)&#123; int res=0; while(f&gt;0) &#123; for(int i=0; i&lt;V; i++) &#123; dist[i]=inf; &#125; dist[s]=0; bool update=true; while(update) &#123; update=false; for(int v=0; v&lt;V; v++) &#123; if(dist[v]==inf) &#123; continue; &#125; for(int i=0; i&lt;G[v].size(); i++) &#123; edge &amp;e=G[v][i]; if(e.cap&gt;0&amp;&amp;dist[e.to]&gt;dist[v]+e.cost) &#123; dist[e.to]=dist[v]+e.cost; prevv[e.to]=v; preve[e.to]=i; update=true; &#125; &#125; &#125; &#125; if(dist[t]==inf) return -1; int d=f; for(int v=t; v!=s; v=prevv[v]) &#123; d=min(d,G[prevv[v]][preve[v]].cap); &#125; f-=d; res+=d*dist[t]; for(int v=t; v!=s; v=prevv[v]) &#123; edge &amp;e =G[prevv[v]][preve[v]]; e.cap-=d; G[v][e.rev].cap+=d; &#125; &#125; return res;&#125;int N,M;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); int a,b,c; while(cin&gt;&gt;N&gt;&gt;M) &#123; V=N; for(int i=0; i&lt;=N; i++) G[i].clear(); for(int i=0; i&lt;M; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); a--; b--; add(a,b,1,c); add(b,a,1,c); &#125; printf(&quot;%d\n&quot;,min_ans(0,N-1,2)); &#125; return 0;&#125; 问题 I: 植物大战僵尸时间限制: 1 Sec 内存限制: 128 MB提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和Zombies（僵尸）是游戏的主角，其中Plants防守，而Zombies进攻。该款游戏包含多种不同的挑战系列，比如Protect Your Brain、Bowling等等。其中最为经典的，莫过于玩家通过控制Plants来防守Zombies的进攻，或者相反地由玩家通过控制Zombies对Plants发起进攻。 现在，我们将要考虑的问题是游戏中Zombies对Plants的进攻，请注意，本题中规则与实际游戏有所不同。游戏中有两种角色，Plants和Zombies，每个Plant有一个攻击位置集合，它可以对这些位置进行保护；而Zombie进攻植物的方式是走到植物所在的位置上并将其吃掉。 游戏的地图可以抽象为一个N行M列的矩阵，行从上到下用0到N–1编号，列从左到右用0到M–1编号；在地图的每个位置上都放有一个Plant，为简单起见，我们把位于第r行第c列的植物记为Pr c。 Plants分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个Plant，定义Score和Attack如下： Score[Pr c] Zombie击溃植物Pr c可获得的能源。若Score[Pr c]为非负整数，则表示击溃植物Pr c可获得能源Score[Pr c]，若为负数表示击溃Pr c需要付出能源 -Score[Pr c]。 Attack[Pr c] 植物Pr c能够对Zombie进行攻击的位置集合。 Zombies必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此Zombies的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻，Zombies必须首先攻击Pr M-1；若需要对Pr c（0≤c&lt;M-1）攻击，必须将PrM-1 Pr M-2 … Pr c+1先击溃，并移动到位置(r c)才可进行攻击。 在本题的设定中，Plants的攻击力是无穷大的，一旦Zombie进入某个Plant的攻击位置，该Zombie会被瞬间消灭，而该Zombie没有时间进行任何攻击操作。因此，即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。 Zombies的目标是对Plants的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套Zombies的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。 输入输入的第一行包含两个整数N M，分别表示地图的行数和列数。 接下来N×M行描述每个位置上植物的信息。第r×M + c + 1行按照如下格式给出植物Pr c的信息：第一个整数为Score[Pr c] 第二个整数为集合Attack[Pr c]中的位置个数w，接下来w个位置信息（r’ c’），表示Pr c可以攻击位置第r’ 行第c’ 列。 输出输出仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为0。 样例输入12345673 210 020 0-10 0-5 1 0 0100 1 2 1100 0 样例输出125 [提交][状态][Edit][TestData)] 题解最大权闭合图问题。最大权闭合图转化为最小割问题，再由最小割转化成最大流问题。课件上有详解。 （本题作为NOI的考试题，同时也是今天十道题中最难的一道题，是不是顿时感觉到了自己与高中生们的差距(ó﹏ò｡)ε=(´ο｀*)))唉） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define M 1000using namespace std;int now,tot,s,t,va[M],du[M],H[M],h[M],ok[M],d[M],v[M],cur[M];int n,m;queue&lt;int&gt; q;struct edge1&#123; int x,y,ne;&#125;e[500000];struct edge&#123; int from,to,cap,flow,ne;&#125;E[500000];int C(int x,int y)&#123; return (x-1)*m+y;&#125;void Add(int x,int y)&#123; e[++tot].y=y; e[tot].x=x; e[tot].ne=H[x]; H[x]=tot; du[y]++;&#125;void Addedge(int from,int to,int cap)&#123; E[++tot]=(edge)&#123;from,to,cap,0,h[from]&#125;; h[from]=tot; E[++tot]=(edge)&#123;to,from,0,0,h[to]&#125;; h[to]=tot;&#125;bool bfs()&#123; for (int i=s;i&lt;=t;i++) v[i]=0; v[s]=1; d[s]=0; q.push(s); while (!q.empty()) &#123; int x=q.front(); q.pop(); for (int i=h[x];i;i=E[i].ne) &#123; edge e=E[i]; if (!v[e.to]&amp;&amp;e.cap&gt;e.flow) &#123; v[e.to]=1; d[e.to]=d[x]+1; q.push(e.to); &#125; &#125; &#125; return v[t];&#125;int dfs(int x,int a)&#123; if (x==t||!a) return a; int flow=0; for (int &amp;i=cur[x];i;i=E[i].ne) &#123; edge &amp;e=E[i]; if (d[e.to]!=d[x]+1) continue; int f=dfs(e.to,min(a,e.cap-e.flow)); if (f) &#123; flow+=f; a-=f; e.flow+=f; E[i^1].flow-=f; if (!a) break; &#125; &#125; return flow;&#125;int dinic()&#123; int flow=0; while (bfs()) &#123; for (int i=s;i&lt;=t;i++) cur[i]=h[i]; flow+=dfs(s,inf); &#125; return flow;&#125;void Topsort()&#123; queue&lt;int&gt; q; for (int i=1;i&lt;=now;i++) if (!du[i]) ok[i]=1,q.push(i); while (!q.empty()) &#123; int x=q.front(); q.pop(); for (int i=H[x];i;i=e[i].ne) &#123; int y=e[i].y; du[y]--; if (!du[y]) &#123; ok[y]=1; q.push(y); &#125; &#125; &#125;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) &#123; now++; int w; scanf(&quot;%d%d&quot;,&amp;va[now],&amp;w); for (int k=1;k&lt;=w;k++) &#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); x++,y++; Add(now,C(x,y)); &#125; if (j!=m) Add(now+1,now); &#125; Topsort(); s=0,t=now+1; int ans=0; tot=1; for (int x=1;x&lt;=now;x++) if (ok[x]) &#123; if (va[x]&gt;0) ans+=va[x],Addedge(s,x,va[x]); else Addedge(x,t,-va[x]); for (int i=H[x];i;i=e[i].ne) &#123; int y=e[i].y; if (ok[y]) Addedge(y,x,inf); &#125; &#125; cout&lt;&lt;ans-dinic()&lt;&lt;endl; return 0;&#125; 问题 J: Pigs时间限制: 1 Sec 内存限制: 128 MB提交: 2 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述Mirko works on a pig farm that consists of M locked pig-houses and Mirko can’t unlock any pighouse because he doesn’t have the keys. Customers come to the farm one after another. Each of them has keys to some pig-houses and wants to buy a certain number of pigs.All data concerning customers planning to visit the farm on that particular day are available to Mirko early in the morning so that he can make a sales-plan in order to maximize the number of pigs sold.More precisely the procedure is as following: the customer arrives opens all pig-houses to which he has the key Mirko sells a certain number of pigs from all the unlocked pig-houses to him and if Mirko wants he can redistribute the remaining pigs across the unlocked pig-houses.An unlimited number of pigs can be placed in every pig-house.Write a program that will find the maximum number of pigs that he can sell on that day. 输入The first line of input contains two integers M and N 1 &lt;= M &lt;= 1000 1 &lt;= N &lt;= 100 number of pighouses and number of customers. Pig houses are numbered from 1 to M and customers are numbered from 1 to N.The next line contains M integeres for each pig-house initial number of pigs. The number of pigs in each pig-house is greater or equal to 0 and less or equal to 1000.The next N lines contains records about the customers in the following form ( record about the i-th customer is written in the (i+2)-th line):A K1 K2 … KA B It means that this customer has key to the pig-houses marked with the numbers K1 K2 … KA (sorted nondecreasingly ) and that he wants to buy B pigs. Numbers A and B can be equal to 0. 输出The first and only line of the output should contain the number of sold pigs. 样例输入123453 33 1 102 1 2 22 1 3 31 2 6 样例输出17 [提交][状态][Edit][TestData)] 题解课件上有建模讲解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int N=107,M=1007,INF=0x3f3f3f3f;inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-1; c=getchar();&#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;; c=getchar();&#125; return x*f;&#125;int m,n,s,t;int pig[M],now[M];struct edge&#123; int v,c,f,ne;&#125;e[N*M&lt;&lt;1];int cnt,h[N];inline void ins(int u,int v,int c)&#123; cnt++; e[cnt].v=v;e[cnt].c=c;e[cnt].f=0;e[cnt].ne=h[u];h[u]=cnt; cnt++; e[cnt].v=u;e[cnt].c=0;e[cnt].f=0;e[cnt].ne=h[v];h[v]=cnt;&#125;int q[N],head,tail,vis[N],d[N];bool bfs()&#123; memset(vis,0,sizeof(vis)); memset(d,0,sizeof(d)); head=tail=1; d[s]=0;vis[s]=1; q[tail++]=s; while(head!=tail)&#123; int u=q[head++]; for(int i=h[u];i;i=e[i].ne)&#123; int v=e[i].v; if(!vis[v]&amp;&amp;e[i].c&gt;e[i].f)&#123; vis[v]=1; d[v]=d[u]+1; q[tail++]=v; if(v==t) return true; &#125; &#125; &#125; return false;&#125;int cur[N];int dfs(int u,int a)&#123; if(u==t||a==0) return a; int flow=0,f; for(int &amp;i=cur[u];i;i=e[i].ne)&#123; int v=e[i].v; if(d[v]==d[u]+1&amp;&amp;(f=dfs(v,min(a,e[i].c-e[i].f)))&gt;0)&#123; flow+=f; e[i].f+=f; e[((i-1)^1)+1].f-=f; a-=f; if(a==0) break; &#125; &#125; return flow;&#125;int dinic()&#123; int flow=0; while(bfs())&#123; for(int i=s;i&lt;=t;i++) cur[i]=h[i]; flow+=dfs(s,INF); &#125; return flow;&#125;int main()&#123; freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin); m=read(); n=read(); s=0; t=n+1; for(int i=1;i&lt;=m;i++) pig[i]=read(); for(int i=1;i&lt;=n;i++)&#123; int A=read(),B,x; while(A--)&#123; x=read(); if(!now[x]) ins(s,i,pig[x]),now[x]=i; else ins(now[x],i,INF),now[x]=i; &#125; B=read(); ins(i,t,B); &#125; printf(&quot;%d&quot;,dinic());&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>匹配</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小费用最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的网络流]]></title>
    <url>%2F2018%2F08%2F22%2F2018-08-22%2F</url>
    <content type="text"><![CDATA[内容：网络流 网络流：2018-8-23 课件：by.浅悠悠 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>预流推进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论3(网络流 + 二分图 + 匹配)]]></title>
    <url>%2F2018%2F08%2F19%2F2018-08-19%2F</url>
    <content type="text"><![CDATA[网络流基础最大流问题的解决一般基于两种方法，即增广路算法与预流推进算法。 网络一个连通的赋权有向图D=（V、E、C），其中V是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。 流网络上的流就是由起点流向终点的可行流 正方向设P为容量网络中源点到汇点的一条链，由源点s到汇点t的方向就为正方向。 残量网络在一个图中，残留网络指在既有的容量和已具备的流量条件下，网络中仍然可以继续增大流量的边所组成的网络。 增广路经在残留网络中的一条从源点s流向汇点t的路径叫做一条增广路。 割图的割可以用来表示对图的一个划分，将原图 G=(V,E)的顶点集 V 分为 S、T 两部分，让源点 s 在 S 中，汇点 t 在 T 中，能够通过 S、T 间的最大净流量为割(S,T)的容量，最小割为图中具有最小容量的割。 最大流增广路算法利用不断寻找增广路并在其上对流量进行更新的方法寻找网络的最大流。 每次用BFS找一条最短的增广路径，然后沿着这条路径修改流量值（实际修改的是残量网络的边权）。当没有增广路时，算法停止，此时的流就是最大流。 最大流最小割定理：在网络的一个流量状态下，通过图的任意一个割的流量都与该流量相同，所以具有最小容量的割的的容量就是该图的流量的最大值即最大流。 最小费用最大流有上下界的最大流二分图网络流匹配]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>匹配</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
        <tag>KM算法</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们一起学过的线性代数]]></title>
    <url>%2F2018%2F08%2F17%2F2018-08-17%2F</url>
    <content type="text"></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>矩阵论</category>
      </categories>
      <tags>
        <tag>矩阵论</tag>
        <tag>快速幂</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学1（排列组合 + 鸽巢原理 + 容斥原理）]]></title>
    <url>%2F2018%2F08%2F16%2F2018-08-16%2F</url>
    <content type="text"><![CDATA[排列组合加法/乘法法则加法法则相互独立的事件 A、B 分别有 k 和 l 种方法产生，则产生 A 或 B 的方法数为 k+l 种。 集合论定义若|A|=k，|B|=l ，且A∩B=Φ ，则|A∪B| = k+l 。 S = S1 ∪ S2 ∪ · · · ∪ Sm, Si ∩ Sj = ∅ (i ≠ j) ⇒ |S| = |S1| + |S2| + · · · + |Sm|。 例1a食堂有3种汉堡，b食堂有4种小吃，c食堂有2种包子，你的早餐只想吃一种，共有多少种选择方法？ 解： 设S是所有食物的集合，Si是第i类食物的集合(i=1,2,3)，显然，Si∩Sj=Φ (i≠j) ，根据加法法则有： |S| = |S1| + |S2| + |S3| = 3 + 4 + 2 = 9。 例2大于0小于10的奇偶数有多少个？ 解： 设S是符合条件数的集合，S1、S2分别是符合条件的奇数、偶数集合，显然，S1∩S2=Φ ，根据加法法则有： |S| = |S1| + |S2| = 5 + 4 = 9。 乘法法则相互独立的事件 A、B 分别有 k 和 l 种方法产生，则选取A以后再选取B 的方法数为 k×l 种。 集合论定义若|A|=k，|B|=l ，A×B={(a,b)|a∈A，b∈B}，则|A×B| = k×l 。 S = P × Q ⇒ |S| = |P | × |Q|。 例从A 地到B地有二条不同的道路，从B地到C地有四条不同的道路，而从C地到D地有三条不同的道路。求从A地经B、C两地到达D地的道路数。 解： 设S是所求的道路数集合，S1、S2、S3分别是从A到B、从B到C、从C到D的道路集合，根据乘法法则有 |S| = |S1 | × |S2| × |S3| = 2 × 4 × 3 = 24。 计数问题的分类有序安排或有序选择 ​ ——允许重复/不允许重复 无序安排或无序选择 ​ ——允许重复/不允许重复 重集的概念标准集的特性：确定、无序、相异等。 重集：B={k1 b1, k2 b2, …, kn * bn}，其中：bi为n个互不相同的元素，称 ki为bi的重数， i = 1, 2, …, n，n=1,2,…, ∞，ki = 1, 2, …, ∞。 排列线排列从n个不同元素中，取r个(0≤r≤n)按一定顺序排列起来，其排列数P(n,r)。 集合论定义设A={an} ，从A中选择r个(0≤r≤n)元素排列起来，A的r−有序子集，A的r−排列。 定理若n, r∈Z且n≥r≥0, P(n,r)=n!/(n-r)!。 若n=r，称全排列P(n,n)= n!； 若n＜r, P(n,r)=0； 若r=0, P(n,r)=1。 证明构造集合A的r−排列时，可以从A的n各元素中任选一个作为排列的第一项，有n种选法；第一项选定后从剩下的n-1个元素中选排列的第二项有n-1种选法；…由此类推，第r项有n-r+1种选法。根据乘法原理有： P(n,r) = n(n-1)……(n-r+1) = n!/(n-r)! 。 推论1若n, r∈N且n≥r≥2，则P(n,r)=n×P(n-1,r-1) 。 证明在集合A的n个元素中，任一个元素都可以排在它的r−排列首位，故首位有n种取法；首位取定后，其他位置的元素正好是从A的另n-1个元素中取r-1个的排列，因此有P(n-1,r-1)种取法。由乘法法则有： P(n,r)=n×P(n-1,r-1) 推论2若n, r∈N且n≥r≥2，则P(n,r)= r×P(n-1,r-1)+P(n-1,r) 。 证明当r≥2时，把集合A的r−排列分为两大类：一类包含A中的某个固定元素，不妨设为a1，另一类不包含a1 。第一类排列相当于先从A-{a1}中取r-1个元素进行排列，有P(n-1,r-1)种取法，再将a1放入每一个上述排列中，对任一排列，a1都有r种放法。由乘法法则，第一类排列共有r×P(n-1,r-1)个。第二类排列实质上是A-{a1}的r−排列，共有P(n-1,r)个。再由加法法则有： P(n,r)= r×P(n-1,r-1)+P(n-1,r) 例1由数字1,2,3,4,5可以构成多少个所有数字互不相同的四位数？ 解： 由于所有的四位数字互不相同，故每一个四位数就是集合{1,2,3,4,5}的一个4−排列，因而所求的四位数个数为 P(5,4)=5!/(5-4)!=120。 例2将具有9个字母的单词FRAGMENTS进行排列，要求字母A总是紧跟在字母R的右边，问有多少种这样的排法？如果再要求字母M和N必须相邻呢？ 解： 由于A总是R的右边，故这样的排列相当于是8个元素的集合{F,RA,G,M,E,N,T,S}的一个全排列，个数为 P(8,8) = 8! = 40320。 如果再要求M和N必须相邻，可先把M和N看成一个整体={M,N}，进行7个元素的集合{F,RA,G,E,T,S,}的全排列，在每一个排列中再进行 {M,N}的全排列，由乘法法则，排列个数为 P(7,7) P(2,2) = 7! 2! = 10080。 例3有多少个5位数，每位数字都不相同，不能取0，且数字7和9不能相邻？ 解： 由于所有的5位数字互不相同，且不能取0，故每一个5位数就是集合{1,2,…,9}的一个5-排列，其排列数为P(9,5)，其中7和9相邻的排列数为[c(7,3)4!2]4×2×P(7,3)，满足题目要求的5位数个数为 P(9,5) - 4 2 P(7,3) = 15120 -1680 = 13440 圆排列设A={an} ，从A中取r个(0≤r≤n)元素按某种顺序（如逆时针）排成一个圆圈，称为圆排列（循环排列）。 定理设A={an}，A的r圆排列个数为P(n,r)/r。 证明由于把一个圆排列旋转所得到另一个圆排列视为相同的圆排列，因此线排列a1a2…ar，a2a3…ara1，… ara1a2…ar-1在圆排列中是一个，即一个圆排列可产生r个不同的线排列；同理， r个不同的线排列对应一个圆排列。而总共有P(n,r)个线排列，故圆排列的个数为 ​ P(n,r)/r= n!/(r×(n-r)!) 例1有8人围圆桌就餐，问有多少种就座方式？如果有两人不愿坐在一起，又有多少种就座方式？ 解： 由上述定理知8人围圆桌就餐，有8!/8=7!=5040种就座方式。 又有两人不愿坐在一起，不妨设此二人为A、B，当A、B坐在一起时，相当于7人围圆桌就餐，有7!/7=6!种就座方式。 而A、B坐在一起时，又有两种情况，或者A在B的左面，或者A在B的右面，因此A、B坐在一起时，共有2×6!种就座方式，因此如果有两人不愿坐在一起，就座方式为 7!-2×6!= 5×6!=3600 例24男4女围圆桌交替就座有多少种就座方式？ 解： 显然，这是一个圆排列问题。首先让4个男的围圆桌就座，有4!/4=3!种就座方式。 因为要求男女围圆桌交替就座，在男的坐定后，两两之间均需留有一个空位，女的就座相当于一个4元素集合的全排列，就座方式数为4!。由乘法法则知，就座方式数为 3!×4!=144 重排列从n个不同元素中，可重复选取r个按一定顺序排列起来，称为重排列。 集合论定义从重集B={k1 b1, k2 b2, … , kn * bn}中选取r个按一定顺序排列起来。 定理1重集B={∞ b1, ∞ b2, … , ∞ * bn} 的r−排列的个数为nr。 证明：构造B的r−排列如下：选择第一项时可从n个元素中任选一个，有n种选法，选择第二项时由于可以重复选取，仍有n种选法，…，同理，选择第r项时仍有n种选法，根据乘法法则，可得出r−排列的个数为nr。 例1由数字1,2,3,4,5,6这六个数字能组成多少个五位数？又可组成多少大于34500的五位数？ 解： 一个五位数的各位数字可重复出现，是一个典型的重排列问题，相当于重集B={∞ 1,∞ 2,…,∞*6}的5−排列，所求的五位数个数为6^5=7776。 大于34500的五位数可由下面三种情况组成： 万位选4,5,6中的一个，其余4位相当于重集B的4−排列，由乘法法则知，共有3×6^4个五位数； 万位是3，千位5,6中的一个，其余3位相当于重集B的3−排列，由乘法法则知，共有2×6^3个五位数； 万位是3，千位4中的一个，百位选5,6中的一个，其余2位相当于重集B的2−排列，由乘法法则知，共有2×6^2个五位数； 由加法法则知，大于34500的五位数个数为3×6^4 + 2×6^3 + 2×6^2=4392 定理2重集B={n1 b1,n2 b2,…,nk bk}的全排列个数为n! / ( n1! n2! …… nk! )，其中，n = n1 + n2 +…… +nk。 证明：将B中的ni个bi看作不同的ni个元素，赋予上标1,2,…, ni，即b(1,i),b(2,i)……,b(ni,i), i=1, 2,…… k，如此，重集B就变成具有n1+n2+…+nk=n个不同的元素集合A = {b(1,1),b(2,1)……,b(n1,1),b(1,2),b(2,2)……,b(n2,2),……b(1,k),b(2,k)……,b(nk,k,} 显然，集合A的全排列个数为n!。又由于ni个bi赋予上标的方法有ni!种，于是对重集B的任一个全排列，都可以产生集合A的n1!×n2!×…×nk!个排列（由乘法法则），故重集B的全排列个数为n! / ( n1! n2! …… * nk! )。 注：利用组合数的计数方法同样可以得出证明。 例2有四面红旗，三面蓝旗，二面黄旗，五面绿旗可以组成多少种由14面旗子组成的一排彩旗？ 解： 这是一个重排列问题，是求重集{4红旗,3蓝旗,2黄旗,5绿旗}的全排列个数，根据定理，一排彩旗的种数为 14! / ( 4! 3! 2! * 5! ) = 2522520。 例3用字母A、B、C组成五个字母的符号，要求在每个符号里，A至多出现2次，B至多出现1次，C至多出现3次，求此类符号的个数。 解： 这也是一个重排列问题。根据分析，符合题意的符号个数相当于求重集M={2A,1B,3*C}的5−排列个数，可分为三种情况：需要分别求M-{A}、M-{B}和M-{C}的全排列个数。根据加法法则，此类符号个数为 5! / (1! 1! 3!) + 5! / (2! 0! 3!) + 5! / (2! 1! 2!) = 60 项链排列对圆排列，通过转动、平移、翻转、可重合的，即可看作项链排列。 若n个不同元素的r−项链排列个数为P(n,r)/(2×r)，具体参照Pólya定理。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论1(辗转相除法 + 欧拉筛 + 杜教筛 + 模运算 + 快速幂)]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15%2F</url>
    <content type="text"></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论2（强连通 + 2-SAT + 欧拉图 + 着色问题）]]></title>
    <url>%2F2018%2F08%2F14%2F2018-08-14%2F</url>
    <content type="text"><![CDATA[图的连通性连通图所谓连通性，直观的讲，就是“连成一片”。 我们发现，按照上面的划分方法，我们可以把G1分为三部分，因此，G1是不连通的，但是，这三个部分，我们把它们叫做图G1的三个连通分量。 定义无向图G中，如果任意两顶点u和v，都能找到从一条u到v的路径。称无向图G是连通的。 当G为有向图时，若G中存在一条以 u为起点 v为终点的有向路P，则称从 u到 v是可达的。 如果G的任何两个顶点都是相互可达的 ，则称图G是强连通的；如果G的有向边被看作无向边时是连通的，则称有向图G是弱连通的 。 连通分量所谓连通分量，指的是图中的极大连通子图。 有了连通分量的概念，我们可以对图的连通性换言之为：如果图G中只有唯一一个连通分量，那么G是连通的，我们称G为连通图。 强连通无向图连通性在对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先遍历或广度优先遍历，便可访问到图中所有顶点；对于非连通图，则需从多个顶点出发进行遍历，而每次从一个新的起点出发进行遍历得到的顶点访问序列恰好是一个连通分量中的顶点集。 方法对无向图的连通性判定，一般我们采用搜索的方法，这里我们首先要提到应用非常广泛的深度优先搜索算法DFS，DFS在图论算法中有非常重要的地位。 例子对下图( a ) 所示无向图进行深度优先遍历，需分别从顶点 v 1 和 v 5 出发调用两次 DFS（或 BFS），得到的顶点序列分别为： v 1 v 2 v 3 v 4 和 v 5 v 6 。这两个顶点集分别加上所有依附于这些顶点的边，便构成了非连通图 G 的两个连通分量，如下图 ( b ) 所示。 代码因此，要想判定一个无向图是否为连通图，或有几个连通分量，可以设置一个计数器 count ，初始时取值为 0 ，每调用一次遍历算法，就给 count 增 1 。这样，当整个遍历算法结束时，依据 count 的值，就可确定图的连通性了。算法用伪代码描述如下： 12345678910111213141516171819无向图连通分支//无向图连通分支，dfs邻接阵形式，o（n^2）//返回分支数，id返回1..分支数的值//传入图的大小n和邻接阵mat，不相邻点边权0#define MAXN 100 void floodfill(int n,int mat[][MAXN],int* id,int now,int tag)&#123;int i; for (id[now]=tag,i=0;i&lt;n;i++) if (!id[i]&amp;&amp;mat[now][i]) floodfill(n,mat,id,i,tag); &#125;int find_components(int n,int mat[][MAXN],int* id)&#123; int count,i; for (i=0;i&lt;n;id[i++]=0); for (count=i=0;i&lt;n;i++) if (!id[i]) floodfill(n,mat,id,i,++count); return count; &#125; 有向图连通性假设，我们把一张有向图的所有边看做无向的，然后对转化后的无向图进行一次DFS，是不是就可以判断无向图的连通性呢？显然可以。 对于采用邻接矩阵表示的有向图G=&lt;E，V&gt;，如果存在一条边e(u,v),那么在矩阵中e(u,v)&gt;0，我们令e(v,u)=e(u,v)，这样就可以将一条有向边变成无向边。 之后，对于这个转化后的矩阵进行一次DFS，这样既可以判断有向图是否连通。 需要注意的是，一般情况下，我们在题目中应用到得不是简单的有向图是否连通，而是：求有向图的强连通分量。 有向图的强连通分量有向图G的极大强连通子图称为G的强连通分量(SCC)。 下图中，子图{1,2,3,4}为一个强连通分量，因为顶点 1,2,3,4 两两可达。{5},{6}也分别是两个强连通分量。 直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为 O(N^2+M)。更好的方法是 Kosaraju 算法或 和Tarjan 算法，两者的时间复杂度都是 O(N+M)。还有Gabow算法不介绍。 Kosaraju 算法Kosaraju算法的解释和实现都比较简单，为了找到强连通分支，首先对图G运行DFS，计算出各顶点完成搜索的时间f；然后计算图的逆图GT，对逆图也进行DFS搜索，但是这里搜索时顶点的访问次序不是按照顶点标号的大小，而是按照各顶点f值由大到小的顺序；逆图DFS所得到的森林即对应连通区域。具体流程如图(1~4)。 上面我们提及原图G的逆图GT，其定义为GT=(V, ET)，ET={(u, v):(v, u)∈E}}。也就是说GT是由G中的边反向所组成的，通常也称之为图G的转置。在这里值得一提的是，逆图GT和原图G有着完全相同的连通分支，也就说，如果顶点s和t在G中是互达的，当且仅当s和t在GT中也是互达的。 在这里顺便提一下在调用dfs的过程中，几种添加顶点到集合的顺序。一共有四种顺序： Pre-Order，在递归调用dfs之前将当前顶点添加到queue中 Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中 Post-Order，在递归调用dfs之后将当前顶点添加到queue中 Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中 最后一种的用途最广，至少目前看来是这样，比如步骤2-a以及拓扑排序中，都是利用的Reverse Post-Order来获取顶点集合。 步骤 (1)对G执行深度优先搜索，求出每个顶点的后序遍历顺序号postOrder。 (2)反转有向图G中的边，构造一个新的有向图G*。 (3)由最高的postOrder编号开始，对G*执行深度优先搜索。如果深度优先搜索未达到所有顶点，由未访问的最高postOrder编号的顶点开始，继续深度优先搜索。 (4)步骤三所产生的森林中的每一棵树，对应于一个强连通分支。 代码12345678910111213141516171819202122232425#define maxN 1024int marked[maxN];//用于记录某个点是否被访问过，0为没有被临幸过，1为被临幸过int id[maxN];//记录每个点所属的连通分量int count;//记录连通分量总数目void kosaraju(graph *g)&#123; int i; memset(marked,0,sizeof(marked)); memset(id,0,sizeof(id)); count=0; for(i=0;i&lt;g-&gt;V;i++)&#123;//之所以这里用循环就是因为g指向的无向图可能不是一个连通图，而是由多个连同分量组成 if(!marked[i])&#123;dfs(g,i); count++;&#125; &#125;&#125; void dfs(graph *g,int v)&#123; graphNode *t; marked[v]=1; id[v]=count; t=g-&gt;adjlist[v].next;//t指向v的邻接点 while(t)&#123; if(!marked[t-&gt;key])&#123;dfs(g,t-&gt;key);&#125;//这里是重点，就是你发现v到t-&gt;key有路径就把它算到跟自己在一个连通分量里了，这里有一个隐性前提，就是你提前知道t-&gt;key一定可以到v，所以你发现v可以到t-&gt;key的时候，你毫不犹豫把它算为跟自己一伙儿的了。Korasaju算法不同书上有不同的表述，区别是先遍历图g还是先遍历图g的逆向图，这只是顺序的区别。我把我看得版本完整说一下：（1）先DFS遍历图g的逆向图，记录遍历的逆后序。（什么叫逆后序？逆后序就是DFS时后序的逆序，注意逆后序不一定为DFS的前序。DFS前序为，访问某个顶点前，把它push进队列。DFS后序为访问完某个顶点后才把它push进队列。而DFS逆后序为访问完某个顶点后把它push进一个栈中。当DFS遍历完整个图后，后序队列的输出与逆后序栈的输出正好相反。）（2）然后按着图g逆向图的DFS遍历的逆后序序列遍历图g求所有的强连通分量，这一步的过程跟无向图求所有连通分量的算法一模一样！按着这里说的遍历顺序重复无向图求所有连通分量的步骤求出来的就是有向图的所有强连通分量，为什么呢？因为我们完成第一步后，按着第一步得到的逆后序要对有向图g进行DFS遍历的前一刻，前面这段过程就相当于我们完成了对这幅有向图g一个加工，把它加工成了一个无向图！也就是说，这个加工实现了我注释开头提到的那个隐性前提。所以后面按着无向图求所有连通分量的步骤求出来的就是有向图g的所有强连通分量。举个例子，比如有向图3-&gt;5-&gt;4-&gt;3，它的逆向图为3-&gt;4-&gt;5-&gt;3（你最好在纸上画下，就是个三角循环图），从逆向图的顶点3开始DFS，得到的逆后续为3，4,5 。按着这个顺序对原图进行DFS，DFS(3)时遇到5，则5肯定跟3在一个强连通分量中（为什么？因为我们逆向图DFS(5)时肯定能到达3，这就是隐形前提。所以正向图DFS(3)遇到5时，我们毫不犹豫把它算到自己一个强连通分量中。） t=t-&gt;next; &#125;&#125; Tarjan 算法Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。定义 DFN(u)为节点 u 搜索的次序编号(时间戳)，Low(u)为 u 或 u 的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出 123456Low(u)=Min &#123; DFN(u), Low(v),(u,v)为树枝边，u为v的父节点 DFN(v),(u,v)为指向栈中节点的后向边(非横叉边) &#125; 当 DFN(u)=Low(u)时，以 u 为根的搜索子树上所有节点是一个强连通分量。算法伪代码如下： 12345678910111213141516tarjan(u) &#123; DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值 Stack.push(u) // 将节点u压入栈中 for each (u, v) in E // 枚举每一条边 if (v is not visted) // 如果节点v未被访问过 tarjan(v) // 继续向下找 Low[u] = min(Low[u], Low[v]) else if (v in S) // 如果节点v还在栈内 Low[u] = min(Low[u], DFN[v]) if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根 repeat v = S.pop // 将v退栈，为该强连通分量中一个顶点 print v until (u== v) &#125; 流程从节点 1 开 始 DFS ，把遍历到的节点加入栈中。搜索到节点 u=6 时 ，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到 u=v 为止，{6}为一个强连通分量。 返回节点 5，发现 DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。 返回节点 3，继续搜索到节点 4，把 4 加入堆栈。发现节点 4 向节点 1 有后向边，节点 1 还在栈中，所以 LOW[4]=1。节点 6 已经出栈，(4,6)是横叉边，返回 3，(3,4)为树枝边，所以 LOW[3]=LOW[4]=1。 继续回到节点 1 ，最后访问节点 2 。访问边 (2,4) ， 4 还在栈中，所以LOW[2]=DFN[4]=5。返回 1 后，发现 DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。 至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。可以发现，运行 Tarjan 算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为 O(N+M)。 代码12345678910111213141516171819202122232425262728293031323334353637383940void tarjan(int i)&#123; int j; DFN[i]=LOW[i]=++Dindex; instack[i]=true; Stap[++Stop]==i; for (edge *e=V[i]; e; e=e-&gt;next) &#123; j=e-&gt;t; if (!DFN[j]) &#123; tarjan(j); if (LOW[j]&lt;LOW[i]) LOW[i]=LOW[j]; &#125; else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i] ) LOW[i]=DFN[j]; &#125; if (DFN[i]==LOW[i]) &#123; Bcnt++; do &#123; j=Stap[Stop--]; instack[j]=false; Belong[j]=Bcnt; &#125; while (j!=i); &#125;&#125;void solve()&#123; int i; Stop=Bcnt=Dindex=0; memset(DFN,0,sizeof(DFN)); for (i=1; i&lt;=N; i++) if (!DFN[i]) tarjan(i);&#125; Gabow算法这个算法其实就是Tarjan算法的变异体，我们观察一下，只是它用第二个堆栈来辅助求出强连通分量的根，而不是Tarjan算法里面的dfn[]和backn[]数组。那么，我们说一下如何使用第二个堆栈来辅助求出强连通分量的根。 我们使用类比方法，在Tarjan算法中，每次backn[i]的修改都是由于环的出现(不然，backn[i]的值不可能变小)，每次出现环，在这个环里面只剩下一个backnk[i]没有被改变(深度最低的那个)，或者全部被改变，因为那个深度最低的节点在另一个环内。那么Gabow算法中的第二堆栈变化就是删除构成环的节点，只剩深度最低的节点，或者全部删除，这个过程是通过出栈来实现，因为深度最低的那个顶点一定比前面的先访问，那么只要出栈一直到栈顶那个顶点的访问时间不大于深度最低的那个顶点。其中每个被弹出的节点属于同一个强连通分量。那有人会问：为什么弹出的都是同一个强连通分量？因为在这个节点访问之前，能够构成强连通分量的那些节点已经被弹出了，这个对Tarjan算法有了解的都应该清楚，那么Tarjan算法中的判断根我们用什么来代替呢？想想，其实就是看看第二个堆栈的顶元素是不是当前顶点就可以了。 现在，你应该明白其实Tarjan算法和Gabow算法其实是同一个思想的不同实现，但是，Gabow算法更精妙，时间更少(不用频繁更新backn[])。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stack&gt;using namespace std;bool map[100][100];//记录图形bool visited[100];//记录点是不是已经被访问过了bool del[100];//记录点是不是已经删除了int dfn[100];//记录点访问的次序stack&lt;int&gt;s1,s2;int dotn;void init()&#123; int line; cin&gt;&gt;dotn&gt;&gt;line; for(int i=1;i&lt;=line;i++) &#123; int u,v; cin&gt;&gt;u&gt;&gt;v; map[u][v]=1; &#125; memset(visited,0,sizeof(visited)); memset(del,0,sizeof(del));&#125;void dfs(int u,int &amp;time)&#123; visited[u]=1; dfn[u]=++time; s1.push(u); s2.push(u); for(int i=1;i&lt;=dotn;i++) &#123; if(map[u][i]) &#123; if(!visited[i]) &#123; dfs(i,time); &#125; else &#123; if(!del[i]) &#123; while(dfn[s2.top()]&gt;dfn[i])s2.pop();//注意这个地方 &#125; &#125; &#125; &#125; if(u==s2.top()) &#123; while(u!=s1.top()) &#123; cout&lt;&lt;s1.top()&lt;&lt;&quot; &quot;; del[s1.top()]=1; s1.pop(); &#125; cout&lt;&lt;u&lt;&lt;endl; del[s1.top()]=1; s1.pop(); s2.pop(); &#125;&#125;void Gadow()&#123; init(); int time=0; for(int i=1;i&lt;=dotn;i++) &#123; if(!visited[i]) &#123; dfs(i,time); &#125; &#125;&#125;int main()&#123; freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); Gadow(); return 0;&#125; 应用强连通分支问题的最大应用就在于两个字：缩点！ 所谓缩点，就是把图中属于同一个强连通分支中的点缩为一个点，这样，我们就得到了一个新的有向图，而且图中不存在回路。 POJ 1236 - Network of Schools（最小点基） 2-SAT有向图缩点一个很大的应用，就是2-SAT问题(2判定性问题 )。 POJ 3678 - Katu Puzzle POJ 3683 - Priest John’s Busiest Day 2-SAT定义 1:布尔变量 x，假如逻辑运算“或”和“与”分别用“∨”和“∧ ”来表示，﹁x表示 x 的非，布尔表达式是用算术运算符号连接起来的变量所构成的代数表达式。给定每个变量 x 的一个值 p(x)，可以像计算代数表达式一样计算布表达式的值。如果存在一个真值分配，使得布尔表达式的取值为真，则这个布尔表达式称为可适定性的，简称 SAT。 例如（x1∨x2）∧(﹁x1∨﹁x2) 这个布尔表达式，如果 p(x1)=真，p(x2)=假，则表达式的值为真，则这个表达式是适定性的。不是所有的布尔表达式都是可适定的。 例如x1∧﹁x2∧(﹁x1∨x2)，则不管 p(x1),p(x2)取何值，表达式都不可能为真，因此这个布尔表达式是不可适定的。 适定性问题的一般形式 X=｛x1,x2..,xn｝为一个有限的布尔变量集，包含 x1,x2，..,xn的“或”和“与”，运算的 m 个句子 C1,C2,..,Cm,布尔表达式 C1∧C2∧,..,∧Cm 是否可适定。 布尔表达式由用“与”连接起来的一些句子构成，则称这个表达式为“合取范式”。 定义 2:对于给定的句子 C1,C2,..,Cm,如果 max{|Ci|}=k(1≦i≦m),则称此适定性问题为 k 适定性问题，简称 k-SAT。 当 k&gt;2 时，k-SAT 是 NP 完全的，所以我们一般讨论2-SAT问题。 解题思路下面我们从一道例题来认识 2-SAT 问题，并提出对一类 2-SAT 问题通用的解法。Poi 0106 Peaceful Commission [和平委员会] 某国有 n 个党派，每个党派在议会中恰有 2 个代表。现在要成立和平委员会 ，该会满足： 每个党派在和平委员会中有且只有一个代表如果某两个代表不和，则他们不能都属于委员会代表的编号从 1 到 2n，编号为 2a-1、2a 的代表属于第 a 个党派 输入 n（党派数），m（不友好对数）及 m 对两两不和的代表编号其中 1≤n≤8000，0≤m ≤20000求和平委员会是否能创立。若能，求一种构成方式。 例： 输入： 3 2 1 3 2 4 输出： 1 4 5 分析原题可描述为： 有 n 个组，第 i 个组里有两个节点 Ai, Ai’ 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的 n 个点都能两两相容。（在这里把 Ai,Ai’ 的定义稍稍放宽一些，它们同时表示属于同一个组的两个节点。也就是说，如果我们描述 Ai，那么描述这个组的另一个节点就可以用 Ai’） 初步构图 如果 Ai 与 Aj 不相容，那么如果选择了 Ai，必须选择 Aj ‘ ；同样，如果选择了 Aj，就必须选择 Ai ’ 。 Ai → AjAj → Ai 这样的两条边对称 我们从一个例子来看： 假设 4 个组，不和的代表为：1 和 4，2 和 3，7 和 3，那么构图： 假设： 首先选 13 必须选，2 不可选5、6 可以任选一个8 必须选，4、7 不可选 矛盾的情况为：存在 Ai，使得 Ai 既必须被选又不可选。得到算法 1：枚举每一对尚未确定的 Ai, Ai‘ ，任选 1 个，推导出相关的组，若不矛盾，则可选择；否则选选另 1 个，同样推导。若矛盾，问题必定无解。 此算法正确性简要说明： 由于 Ai,Ai’ 都是尚未确定的，它们不与之前的组相关联，前面的选择不会影响 Ai,Ai’ 。算法的时间复杂度在最坏的情况下为 O(nm)。 在这个算法中，并没有很好的利用图中边的对称性观察图（1）可以发现，1 和 3 构成一个环，这样 1 和 3 要么都被选中，要么都不选。2和 4 也同样如此。 在每个一个环里，任意一个点的选择代表将要选择此环里的每一个点。不妨把环收缩成一个子节点。新节点的选择表示选择这个节点所对应的环中的每一个节点。 对于原图中的每条边 Ai → Aj（设 Ai 属于环 Si，Aj 属于环 Sj）如果 Si≠Sj，则在新图中连边： Si → Sj 这样构造的有向无环图和原图是等价的，这样我们就可以用之前介绍过的强连通分量的算法把图转化成有向无环图，在这个基础上，如果存在一对 Ai, Ai’属于同一个环，则判无解，否则将采用拓扑排序，以自底向上的顺序进行推导，一定能找到可行解。 下面给出 2-SAT 问题中常用的建边方式： 2-SAT 中元素关系常见有以下 11 种 A[x] NOT A[x] A[x] AND A[y] A[x] AND NOT A[y] A[x] OR A[y] A[x] OR NOT A[y] NOT (A[x] AND A[y]) NOT (A[x] OR A[y]) A[x] XOR A[y] NOT (A[x] XOR A[y]) A[x] XOR NOT A[y] And 结果为 1：建边 ~x-&gt;y, ~y-&gt;x (两个数都为 1)And 结果为 0：建边 y-&gt;~x , x-&gt;~y(两个数至少有一个为 0)OR 结果为 1：建边 ~x-&gt;y , ~y-&gt;x(两个数至少有一个为 1)OR 结果为 0：建边 x-&gt;~x , y-&gt;~y(两个数都为 0)XOR 结果为 1：建边 x-&gt;~y , ~x-&gt;y , ~y-&gt;x , y -&gt; ~x (两个数一个为 0，一个为 1)XOR 结果为 0：建边 x-&gt;y , ~x-&gt;~y , y-&gt;x ~y-&gt;~x(两个数同为 1 或者同为 0) 对于一般判定是不是有解的情况，我们可以直接采用 tarjan 算法求强联通，然后缩点，如果 x 与~x 染色相同，说明无解，否则有解。有的时候，可能需要用二分++tarjan 算法 欧拉图每个小点最后都会回到自己原来的位置上吗？注意，这些小点并不是沿着一个回路在运动，而是沿着三个交替出现的回路在运动。 答案是肯定的。 math 版上的 OmnipotentEntity 给出了一个简短的证明。假设某个地方的小点出发后永远不会回到原地。由于小点的运动规律是三步一个周期，因此每三步之后从此处出发的小点将会拥有完全相同的命运——永远不会回到原地。既然从这里出发的小点会不断地发生有去无回的情况，那么总有一个时候小点会被用光，此时就再也没有小点能从这里出发了。但这与我们看到的实际情况相矛盾：每个地方的小点都是用之不竭的。 熟悉群论的朋友会很快发现，这个结论几乎是显然的。小点的每一步运动都形成了一个置换，三个置换的复合本质上也还是一个置换，而这个置换的足够多次幂一定会变成单位置换。这意味着，不但每个点都能回到自己原来的位置，而且所有点能同时回到自己原来的位置（后者可能需要更长的时间）。事实上，有限群中的任意一个元素都有一个有限的阶，因而如果某类变换操作能构成一个有限群的话，不断地执行某一个操作，或者不断地循环执行某几个操作，最后总有一个时刻你会发现，一切又都重新变回了原样。拿出一副新的扑克牌，每次洗牌时都把牌分成两半并把它们完美地交叉在一起，那么不断这样洗下去之后，整副牌总会在某个时候重新变得有序。找一个复原好了的魔方，循环执行几个固定的操作，魔方很快就会被彻底打乱，但最终一定会奇迹般地再次复原。 欧拉图（E问题）起源：欧拉回路问题是图论中最古老的问题之一。它诞生于十八世纪的欧洲古城哥尼斯堡。普瑞格尔河流经这座城市，人们在两岸以及河中间的两个小岛之间建了七座桥（如图1）。 于是产生了这样一个问题：是否可以找到一种方案，使得人们从自己家里出发，不重复地走遍每一座桥，然后回到家中？这个问题如果用数学语言来描述，就是在图2中找出一条回路，使得它不重复地经过每一条边。这便是著名的“哥尼斯堡七桥问题”。 定义：​ 欧拉回路：图G=(V,E) (无向图or有向图) 的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。 ​ 欧拉通路：即可以不回到起点，但是必须经过每一条边，且只能一次。也叫”一笔画”问题。 ​ 欧拉图与半欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉通路而无欧拉回路的图称为半欧拉图。 ​ 桥：设无向图G=&lt;V,E&gt;，若存在边集E的一个非空子集E1，使得p(G-E1)&gt;p(G)，而对于E1的任意真子集E2，均有p(G-E2)=p(G)，则称E1是G的边割集，或简称割集；若E1是单元集，即E1={e}，则称e为割边或桥。[p(G)表示图G的连通分支数.] 图中，图（4）为欧拉图，图（3）为半欧拉图，图（1）（2）不是欧拉图。 性质： 欧拉回路：一个欧拉回路，删掉一个点，仍然是一个欧拉回路。从一个欧拉回路拖走一个小欧拉回路，结果也是一个欧拉回路。 判定（充要）： 欧拉回路：1: 图G是连通的，不能有孤立点存在。 2: 对于无向图来说度数为奇数的点个数为0;对于有向图来说每个点的入度必须等于出度。 欧拉通路：1: 图G是连通的，无孤立点存在。 2: 对于无向图来说，度数为奇数的的点可以有2个或者0个，并且这两个奇点其中一个为起点另外一个为终点。对于有向图来说，可以存在两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点。 算法（求欧拉回路）：Fleury算法:设图G是一个无向欧拉图，则按照下面算法求欧拉回路: 1:任取G中一个顶点v0,令P0 = v0. 2:假设沿Pi = v0e1v1e2v2……eivi 走到了顶点 vi,按照下面方法从E(i) = E(G) - {e1, e2, e3,…,ei} 中选e(i ＋ 1),选择后删除e(i +１)这条边. a):e(i+1)余vi关联 b):除非无别的边可选，否则e(i+1)不应是Gi = G – {e1,e2,…,ei} 中的桥.假若迫不得已选的是桥,除删除这条边之外,还应该再把孤立点从Gi中移除(选择桥边必然会形成孤立的点). 3:当步骤 2 无法继续执行时停止算法. 当算法停止时，所得到的简单回路 Pm = = v0e1v1e2v2e3v3……emvm (vm = v0) 为图G的一条欧拉回路. 下面用图来描述： 随便选择一个起点 v1。当前处在 v1 点，有两种走法 v1 – v9,v1 – v10，这俩条边都不是桥边，那么随便选择一个，&lt;v1, v10&gt;这条边吧。那么图就会成为这样.Eu = (走过的边集){&lt;v1, v10&gt;} 当前到了 V10 点，有&lt;v10,v4&gt;,&lt;v10,v3&gt;,&lt;v10, v8&gt;，先看&lt;v10,v8&gt;这条边吧，如果选择了这条边那么图就会成为这样： 很显然形成了两个图，上下两个图不连通，即&lt;v10, v8&gt;这条边就是所谓的桥边，算法中说除非别无他选，否则不应该选择桥边，那么这条边就不能选择。回到上面，由于&lt;v10,v4&gt;,&lt;v10,v3&gt;都不是桥边，所以随便选择&lt;v10,v4&gt;吧. Eu={&lt;v1, v10&gt;,&lt;v10,v4&gt;} 到了 v4 这个点，&lt;v4, v2&gt;这条边是桥边,但是别无选择，只好选择这条边.选择完这条边这时不仅要从原图中删除这条边，由于点4成为了孤点，所以这个点也该从原图删除。Eu={&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;}. 同理到达 v2 只好选择&lt;v2,v3&gt;，删除孤点 v2和边. Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;}. 别无他选，&lt;v3,v10&gt;。Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;}. 同样,选择&lt;v10, v8&gt;，Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;}. 此时到了 v8 同第一次到达v10时的情况，不能选择&lt;v8,v9&gt;这条桥边,选择&lt;v8,v6&gt;,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;}. 到达v6，选择&lt;v6,v7&gt;,删点删边,Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;}.以下就不给图了(逃; 然后接下来的选择都是别无他选,依次选择&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;，最后得到的欧拉边集Eu{&lt;v1,v10&gt;,&lt;v10,v4&gt;,&lt;v4,v2&gt;&lt;v2,v3&gt;,&lt;v3,v10&gt;,&lt;v10,v8&gt;,&lt;v8,v6&gt;,&lt;v6,v7&gt;,&lt;v7,v8&gt;&lt;v8,v9&gt;&lt;v9,v1&gt;},于是我们就得到了一条欧拉回路. 算法实现：这个算法在实现时也有很巧妙的方法。因为DFS本身就是一个入栈出栈的过程，所以我们直接利用DFS的性质来实现栈，其伪代码如下： 1234567DFS(u): While (u存在未被删除的边e(u,v)) 删除边e(u,v) DFS(v) End PathSize ← PathSize + 1 Path[ PathSize ] ← u 模板：1234567891011121314151617181920212223242526272829303132333435363738394041void DFS(Graph &amp;G,SqStack &amp;S,int x,int t)&#123; k=0;//一个标志,来标记当前访问的节点是否还有邻接边可供访问 Push(S,x); //将本次遍历边所经由的点入栈 for(i=t;i&lt;v;i++) //v是顶点数,e是边数 if(G[i][x]&gt;0) &#123; k=1; G[i][x]=0; G[x][i]=0; //此边已访问,删除此边 DFS(G,S,i,0);//寻找下一条关联的边,本次找到的是与x关联的i,在 //下一层中将寻找与i关联的边 break; &#125;//if,for if(k==0) //如果k=0,说明与当前顶点关联的边已穷尽 &#123; Pop(S); GetTop(S,m); G[x][m]=1;G[m][x]=1;//恢复在上一层中被删除的边 a=x+1;//如果可能的话,从当前节点的下一条关联边开始搜寻 if(StackLength(S)!=e)//继续搜寻,边还没有全部遍历完 &#123; Pop(S); //还原到上一步去 DFS(G,S,m,a);// &#125;//if else //搜寻完毕,将最后节点也入栈 Push(S,x); &#125;//if&#125;//DFSvoid Euler(Graph &amp;G,int x)&#123;//G是存储图的邻接矩阵,都处理成无向图形式,值为1代表有边,0代表无边,不包括自回路,x是出发点InitStack(S);//用来存放遍历边时依次走过的顶点DFS(G,S,x,0);//深度优先遍历查找,0是指查询的起点//输出 while(!StackEmpty(S)) &#123; GetTop(S,m); printf(&quot;-&gt;v%d&quot;,m); Pop(S); &#125;//while&#125;//Euler 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N = 1005;int n, m, flag, top, sum, du[N], ans[5005], map[N][N];void dfs(int x)&#123; ans[++top] = x; for(int i = 1; i &lt;= n; i++) &#123; if(map[x][i] &gt;= 1) &#123; map[x][i]--; map[i][x]--; dfs(i); break; &#125; &#125;&#125;void fleury(int x)&#123; top = 1; ans[top] = x; while(top &gt; 0) &#123; int k = 0; for(int i = 1; i &lt;= n; i++)//判断是否可扩展 &#123; if(map[ans[top]][i] &gt;= 1)//若存在一条从ans[top]出发的边 那么就是可扩展 &#123;k = 1; break;&#125; &#125; if(k == 0)//该点x没有其他的边可以先走了（即不可扩展）， 那么就输出它 &#123; printf(&quot;%d &quot;, ans[top]); top--; &#125; else if(k == 1)//如可扩展， 则dfs可扩展的哪条路线 &#123; top--;//这需要注意 dfs(ans[top+1]); &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) &#123; memset(du, 0, sizeof(du)); memset(map, 0, sizeof(map)); for(int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); map[x][y]++; //记录边， 因为是无向图所以加两条边， 两个点之间可能有多条边 map[y][x]++; du[x]++; du[y]++; &#125; flag = 1; // flag标记开始点。 如果所有点度数全为偶数那就从1开始搜 sum = 0; for(int i = 1; i &lt;= n; i++) &#123; if(du[i] % 2 == 1) &#123; sum++; flag = i;// 若有奇数边， 从奇数边开始搜 &#125; &#125; if(sum == 0 || sum == 2) fleury(flag); &#125; return 0;&#125; 基本(套圈)法1.在图中任意找一个回路C； 2.将图中属于C的边删除； 3.在残留图的各个极大连通分量中求欧拉回路； 4.将各极大连通分量中的欧拉回路合并到C上。 详细过程 首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，所停止的点必然也是起点(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，然后停止时，走过的路径形成了一个圈，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。 总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。 下面用图描述一遍： 假设我们选择从v1开始走,由于随便走，所以可能出现以下走法 第一步：v1 – v9 第二步：v9 – v8 第三步：v8 – v10 第四步：v10 – v1 此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么 第五步: v10 – v3 第六步: v3 – v2 第七步: v2 – v4 第八步: v4 – v10 发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么 第九步：v8 – v6 第十步：v6 –v7 第十一步：v7– v8 又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。 具体实现与分析: 使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;const int MAXV = 100 + 7;const int MAXE = 100 * 100 + 7;int head[MAXV];int V, E;typedef struct EdgeNode&#123; int to; int w; int next; &#125;edgeNode;edgeNode Edges[MAXE];bool visit[2 * MAXE];stack&lt;int&gt; stv;queue&lt;int&gt; quv;//点集queue&lt;int&gt; que;//边集void EulerDFS(int now)&#123; st.push(now);//每访问一个点，就把该点压入栈 for(int k = head[now]; k != -1; k = Edges[k].next) &#123; if(!visit[k]) &#123; visit[k] = true; //有向图每条边保存了两次，也要标记两次 if(k &amp; 1) visit[k + 1] = true; else visit[k - 1] = true; EulerDFS(Edges[k].to); que.push(k);//回溯时记录边 &#125; &#125; quv.push(stv.top());//记录点 stv.pop();&#125;int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); scanf(&quot;%d%d&quot;, &amp;V, &amp;E); memset(head, -1, sizeof(head)); for(int i = 1; i &lt;= E; i++) &#123; int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); Edges[2 * i - 1].to = v; //双向储存边 Edges[2 * i - 1].w = w; Edges[2 * i - 1].next = head[u]; head[u] = 2 * i - 1; Edges[2 * i].to = u; Edges[2 * i].w = w; Edges[2 * i].next = head[v]; head[v] = 2 * i; &#125; memset(visit, false, sizeof(visit)); EulerDFS(1); return 0;&#125; 例题例1 有N个盘子，每个盘子上写着一个仅由小写字母组成的英文单词。你需要给这些盘子按照合适的顺序排成一行，使得相邻两个盘子中，前一个盘子上面单词的末字母等于后一个盘子上面单词的首字母。请你编写一个程序，判断是否能达到这一要求。如果能，请给出一个合适的顺序。 分析以26个英文字母作为顶点。对于每一个单词，在图中从它的首字母向末字母连一条有向边。 问题转化为在图中寻找一条不重复地经过所有边的路径，即欧拉路径。这个问题能够在O(|E|)时间内解决。 例2PKU 2337 问题描述 给出一些字符串，让你首尾串起来串成一串，并且输出一个字典序最小的方案。如果不能，输出“**”。否则输出字典序最小的回路。 输入 2 6 aloha arachnid dog gopher rat tiger 3 oak maple elm 输出 aloha.arachnid.dog.gopher.rat.tiger ** 分析 在没有特殊要求的情况下，DFS遍历图的结点顺序是可以任选的。但是这里由于加上了字典序最小的要求，所以DFS遍历时需要按照以下的优先顺序： 如果有不是桥的边，遍历这些边中字典序最小的边。 否则，遍历这些这些桥中字典序最小的边。 比如一个单词，abcde，那么就连接一条a到e的有向边。如此构成的图一共最多有26个节点。每条边都代表一个单词，那么就转化成了：找一条路，遍历所有的边。就是欧拉通路问题。 遍历欧拉通路的方法： 确定一个起点（出度-入度=1，或者等于0（如果存在欧拉回路的话）） 从起点开始深搜（首先要保证图中存在欧拉回路或者通路） dfs(vid, eid) 其中vid表示当前搜到的点。eid表示当前搜到的边（一个点可能会有很多边） 对于每条边，都是等它搜索完了后，把它代表的内容（这里是单词）压入一个栈中。 最后深搜结束后，依次弹栈就是答案。 例3DOOR MAN 大意：给定N(&lt;=20)个房间,房间之间有门相隔，门的数目不超过100道，当前人在第M个房门，当前人每经过一道门的时候就把经过的门锁上，问有没有一条路可以使得我们走到第0个房门的时候所有的门都锁上了。 思路：我们可以把门看成是两个房间之间的边，那么问题可以转化成找一条欧拉路径。PS：判断的时候只要判断所有的边在一起就行了，所有的点不一定连通，当0点和M点不连通的时候，无解。注意这组数据。 中国邮递员问题(CPP)定义一个邮递员从邮局出发，要走完他所管辖范围内的每一条街道，至少一次再返回邮局，如何选择一条尽可能短的路线？这就是中国邮递员问题（CPP），其命名是因为中国数学家管梅谷在1962年首先提出了这个问题。如果用顶点表示交叉路口，用边表示街道，那么邮递员所管辖的范围可用一个赋权图来表示，其中边的权重表示对应街道的长度。 图论语言中国邮递员问题可用图论语言叙述为：在一个具有非负权的赋权连通图G中，找出一条权最小的环游。这种环游称为最优环游。若G是欧拉图，则G的任意欧拉环游都是最优环游，从而可利用弗勒里算法求解。若G不是欧拉图，则G的任意一个环游必定通过某些边不止一次。将边e的两个端点再用一条权为w(e)的新边连接时，称边e为重复的。此时CPP与下述问题等价，若G是给定的有非赋权的赋权连通图， （1）用添加重复边的方法求G的一个欧拉赋权母图 ，使得 尽可能小； （2）求 的欧拉环游。 此图图论中和中国邮递员问题类似的是旅行商问题，区别于中国邮递员问题，旅行商问题是说在边赋权的完全图中找一个权和最小的哈密尔顿圈。 埃德蒙兹（J.Edmonds）和约翰逊（E.L.Johnson)在1973年给出了求解（1）的多项式时间算法。 如果邮递员所通过的街道都是单向道，则对应的图应为有向图。1973年，埃德蒙兹和约翰逊证明此时CPP也有多项式时间算法。帕帕季米特里屋（C.H.Papadimitrious）在1976年证明，如果既有双向道，又有单向道，则CPP是NP困难的。 分析由于每边至少遍历一次，所以最短路的瓶颈就在于重复遍历。由于图一直保持连通性，所以两两奇点之间都存在欧拉路；又两两奇点之间的最短路可求；奇点个数为偶数。所以问题就等价于找一个奇点构成的完全图G’(V,E)的最小权匹配(Perfect Matching in General Graph)。V(G’)为原图G中的奇点，每条边为两奇点对应原图的最短路长度。 奇偶点图作业法 确定G中的奇点，构成G’。 确定G’两两结点在G中的最短路作为它们在G’中的边权。 对G’进行最小权匹配。 最小权匹配里的各匹配边所对应的路径在G中被重复遍历一次,得到欧拉图G’’。 对G’’找一条欧拉路即可。 有向的中国邮路问题，比较复杂。 哈密顿图（H问题） 1857年，英国数学家汉密尔顿(Hamilton)提出了著名的汉密尔顿回路问题，其后，该问题进一步被发展成为所谓的“货郎担问题”，即赋权汉密尔顿回路最小化问题：这两个问题成为数学史上著名的难题。 性质汉密尔顿路：给定图G，若存在一条路，经过图中每个结点恰好一次，这条路称作汉密尔顿路。 汉密尔顿回路：给定图G，若存在一条回路，经过图中每个结点恰好一次，这条回路称作汉密尔顿回路。 汉密尔顿图：具有汉密尔顿回路的图，称作汉密尔顿图。 解法必须说明，汉密尔顿回路问题是一个NP完全问题(NP-Complete)，也就是说，至今没有一个行之有效的多项式时间的算法能够找到这类问题的最优解，只有一些近似算法。关于NPC问题，我们这里不做讨论。我们一般情况下，直接用DFS进行搜索，当然，如果图的点比较多的时候(一般n&gt;10)，这个算法是不现实的。 旅行商问题(TSP) Traveling Salesman Problem，即旅行商问题， 旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值，这是一个NP难问题。 TSP的历史很久，最早的描述是1759年欧拉研究的骑士周游问题，即对于国际象棋棋盘中的64个方格，走访64个方格一次且仅一次，并且最终返回到起始点。 TSP由美国RAND公司于1948年引入，该公司的声誉以及线形规划]这一新方法的出现使得TSP成为一个知名且流行的问题。 解法状压DP 着色问题图的着色问题是由地图的着色问题引申而来的：用m种颜色为地图着色，使得地图上的每一个区域着一种颜色，且相邻区域颜色不同。问题处理：如果把每一个区域收缩为一个顶点，把相邻两个区域用一条边相连接，就可以把一个区域图抽象为一个平面图。 通常所说的着色问题是指下述两类问题： 1．给定无环图G=(V,E)，用m种颜色为图中的每条边着色，要求每条边着一种颜色，并使相邻两条边有着不同的颜色，这个问题称为图的边着色问题。 2．给定无向图G=(V,E)，用m种颜色为图中的每个顶点着色，要求每个顶点着一种颜色，并使相邻两顶点之间有着不同的颜色，这个问题称为图的顶着色问题。 边着色问题定义：给图G的边着色，使得有共同顶点的边异色的最少颜色数，称为边色数。 妖怪图（snark graph）妖怪图每个点都关联着3条边，用4种颜色可以把每条边涂上颜色，使得有公共端点的边异色，而用3种颜色办不到，切断任意3条边不会使它断裂成2个有边的图。 单星妖怪和双星妖怪： 时间表问题；设x1,x2,…,xm为m个工作人员，y1,y2,…,yn表为n种设备，工作人员对设备提出要求，使用时间均假定以单位时间计算，自然每一个工作人员在同一个时间只能使用一种设备，某一种设备在同一时间里只能为一个工作人员使用，问应如何合理安排，使得尽可能短时间里满足工作人员的要求？ 问题转换为X={x1,x2,…,xm}，Y={y1,y2,…,yn}的二分图G，工作人员xi要求使用设备yj，每单位时间对应一条从xi到yj的边，这样所得的二分图过xi ，yj的边可能不止一条。问题变为对所得二分图G的边着色问题。有相同颜色的边可以安排在同一时间里。 定理：二分图G的边色数＝图中顶点的最大度。 定理(Vizing 1964)：若图G为简单图，图中顶点最大度为d，则G的边色数为d或d+1。 目前仍无有效区分(判别)任给定图属第几类图的有效方法。 引申边的着色问题可以转化为顶点的着色问题。 点着色问题定义：给图G的顶点着色，使得相邻的顶点异色的最少颜色数，称为图G顶色数，简称色数；记作χ(G)。 四色猜想：平面图的色数不大于5。 色数的性质：（1）图G只有孤立点时，χ(G)=1； （2）n个顶点的完全图G有χ(G)=n； （3）若图G是n个顶点的回路，则χ(G)=2， n为偶数。χ(G) =3， n为奇数； （4）图G是顶点数超过1的树时，χ(G)=2； （5）若图G是二分图，则χ(G)=2。 定理：图G=(V,E)的色数χ(G)=2的充要条件是：(1)|E|≥1；(2)G不存在边数为奇数的回路。 若图G=(V,E)，d=max{d(vi)},vi∈V，则χ(G)≤d+1。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>欧拉图</tag>
        <tag>哈密顿图</tag>
        <tag>连通图</tag>
        <tag>着色问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ccpc-wannafly秦皇岛站集训部分题解]]></title>
    <url>%2F2018%2F08%2F13%2F2018-08-12%2F</url>
    <content type="text"><![CDATA[WANNAFLY_DAY1Problem A. Birthday恬恬的生日临近了。宇扬给她准备了一个大蛋糕。 正如往常一样，宇扬在蛋糕上插了n支蜡烛，并把蛋糕分为m个区域。因为某种原因，他必须把第i根蜡烛插在第ai个区域或第bi个区域。区域之间是不相交的。宇扬在一个区域内同时摆放x支蜡烛就要花费x2的时间。宇扬布置蛋糕所用的总时间是他在每个区域花的时间的和。 宇扬想快些见到恬恬，你能告诉他布置蛋糕最少需要多少时间吗？ Input第一行包含两个整数n，m（1 ≤ n ≤ 50， 2 ≤ m ≤ 50）。接下来n行，每行两个整数ai, bi（1 ≤ ai, bi ≤ m）。 Output一个整数表示答案 Examplesstandard input3 31 21 21 2 standard output 5 standard input 3 31 22 31 3 standard output 3 思路：考虑费用流时把每个part拆成n个点，选择第i个点的代表为放置i块蛋糕和(i - 1)块蛋糕的时间差，这个时间差是增的，因此在费用流的过程中必定会从小到大选择具体建图：左边n个点代表n个蛋糕，右边m * n个点代表m个part,每个part拆成n个点。源点向每个左边的点连一条流量1费用0的边，每个右边的点向汇点连一条流量1费用0的编。每个蛋糕向可以放的两个part的所有点连边，连向第i个点的费用为i^2 - (i - 1)^2，流量为1。这样求最小费用流既为答案。 Problem B. Board恬恬有一个n × n的数组。她在用这个数组玩游戏： 开始时，数组中每一个元素都是0。 恬恬会做某些操作。在一次操作中，她可以将某一行的所有元素同时加上一个值，也可以将某一列的所有元素同时加上一个值。 在几次操作后，一个元素被隐藏了。你能帮助她回忆隐藏的数是几吗？ Input第一行一个整数n（1 ≤ n ≤ 1000）。接下来n行每行n个整数表示数组a。第(i + 1)行的第j个元素表示aij（aij = −1或0 ≤ aij ≤ 100000）。−1表示隐藏的元素 Output仅一个整数表示答案 Examplestandard input31 2 10 -1 00 1 0 standard output 1 思路把格子N染色，第i行第j列格子的颜色为(i + j) % N。那么每次操作时，必定是N种不同的颜色都有一格被操作到，因此最后任何颜色格子的和必定是相等的。因此只需要记录每种颜色格子的和，并算出缺失格子的颜色C，用其余颜色的和减去颜色C的和即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1005;int map[maxn][maxn];int main()&#123; int n; int x,y; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]==-1) &#123; x=i; y=j; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==x) continue; int minn=0x3f3f3f; for(int j=0;j&lt;n;j++) &#123; minn=min(minn,map[i][j]); &#125; for(int j=0;j&lt;n;j++) &#123; map[i][j]-=minn; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; if(i==y) continue; int minn=0x3f3f3f; for(int j=0;j&lt;n;j++) &#123; minn=min(minn,map[j][i]); &#125; for(int j=0;j&lt;n;j++) &#123; map[j][i]-=minn; &#125; &#125; int ans1=0,ans2=0; for(int i=0;i&lt;n;i++) &#123; if(map[i][y]!=0 &amp;&amp; map[i][y]!=-1) ans1=map[i][y]; &#125; for(int i=0;i&lt;n;i++) &#123; if(map[x][i]!=0 &amp;&amp; map[x][i]!=-1) ans2=map[x][i]; &#125; cout&lt;&lt;ans1+ans2&lt;&lt;endl; &#125; return 0;&#125; Problem C. Circle现在我们要把1 . . . n这n个数字首尾连接组成一个环，使得相邻元素互质的对数尽可能多。请输出最大对数。 Input一行一个整数n(1 ≤ n ≤ 1000)。 Output一行一个整数表示答案。 Examplestandard input 4 standard output4 Note样例的一种构造方法为1 4 3 2。 思路因为(i,i+1)=1且(1,n)=1，所以把1…n依次放进一个环，就可以啦。答案为n。 代码12345678910#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+7;int main()&#123; int t; while(cin&gt;&gt;t)&#123; cout&lt;&lt;t&lt;&lt;endl; &#125; return 0;&#125; Problem D. 土龙弟弟Problem E. Growth弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。 为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a ≥ xi且b ≥ yi，则弱弱在接下来的每一天都可以得到zi的分数。 问m天以后弱弱最多能得到多少分数。 Input第一行一个两个整数n和m（1 ≤ n ≤ 1000，1 ≤ m ≤ 2000000000）。接下来n行，每行三个整数xi，yi，zi（1 ≤ xi, yi ≤ 1000000000，1 ≤ zi ≤ 1000000）。 Output一行一个整数表示答案。 Examplestandard input2 42 1 101 2 20 standard output 50 Note在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。共获得0 + 0 + 20 + 30 = 50分 思路把奖励的x拿出来从小到大排序，得到x1,x2,…,xn。把奖励的y拿出来从小到大排序，得到y1,y2,…,yn。用v[i][j]表示a值到达xi，b值达到yi时接下来每天可以得到的奖励。v[i][j] = v[i - 1][j] + v[i][j - 1] - v[i - 1][j - 1] + t[i][j]其中t[i][j]为满足x=i，y=j的奖励的总和。用f[i][j]表示a值达到xi，b值达到yj时已经拿到的奖励的最大值。f[i][j] + (x[i + 1] - x[i] - 1) t[i][j] + t[i + 1][j] -&gt; f[i + 1][j]f[i][j] + (y[j + 1] - y[j] - 1) t[i][j] + t[i][j + 1] -&gt; f[i][j + 1]最后统计一下答案就可以了。 Problem F. KingdomX王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个官员是这个上司的下属。上司的编号总比下属小。 我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力是1。国王的影响力总是n。 任何一位有下属的官员总是选择他的下属中影响力最高的作为他的心腹（有若干下属影响力相同的话则会选择编号最小的）。 一位官员得到一条消息后，他就要把消息传达给国王。我们定义一位官员的花费为他将消息传达给国王的花费。国王自己的花费为0。如果一位官员是他上司的心腹，则他的花费等于他上司的花费，否则他的花费为他上司的花费加1。 由于时代和平，消息并不需要传递的太快。我们希望你决定每位官员（除了国王）的上司，使得所有官员的花费之和和尽量小。 Input一个整数n（1 ≤ n ≤ 8000）表示包括国王在内的官员的总数。 Output一个整数表示最大的花费之和。 Examplestandard input4 standard output 2 思路f[i]代表i个点时的答案，g[i][j]代表若干颗树加起来，size和为i，每棵树size&lt;=j时，这些树的代价和最大是多少从1到n枚举i，在i固定时枚举心腹的影响力大小更新f[i]，然后用类似背包的思路更新g[i][1]~g[i][i]复杂度O(N^2) Problem G. Matrix弱弱有一个n × m的矩阵，第i行第j列位置上的值为aij。弱弱定义以(x, y)为顶点，大小为k的三角形为： 第x行y位置，第x + 1行y − 1，y，y + 1位置，. . .，第x + k − 1行y − k + 1，. . .，y + k − 1位置组成的区域。 比如说，以(1, 3)为顶点，大小为3的三角形为 OOXOOOOOXXXOOOXXXXXOOOOOOOOO中打叉的位置。 现在弱弱想要知道所有大小为k的三角形中，重心位置离顶点最近的是哪个？重心是三角形中每个位置按照它们的值加权平均所得的点。请输出这个最小距离（欧几里得距离）。 Input第一行一个三个整数n，m，k（1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，1 ≤ k ≤ min n,(m + 1)/2 接下来n行，每行m个整数aij（1 ≤ aij ≤ 1000）表示每个位置的重量。 Output一行一个数表示答案。相对误差或绝对误差在10−5（1e-5）之内均会被判断为正确。 Examplestandard input2 3 21 1 11 1 1 standard output 0.7500000000 Note只有一个大小为2的三角形。 思路w个格子的重心的坐标为（∑xiwi / ∑wi, ∑yiwi / ∑wi)。那么其实我们只要维护∑xiwi，∑yiwi，∑wi就可以了。假设我们现在有一个顶点为(x, y)的三角形，我们想要推到顶点为(x, y+1)的三角形，观察两者之间的差异，会发现在推过去的过程中，其实就是删去了一个斜条，又加入了一个斜条。同理，从(x, y)到(x+1, y)其实只是删去了两个斜条，加上了底上的横条，而这些关键的值都是可以通过前缀和的方法维护。 Problem H. Mountain平面上有n座山，每座山都有左右两面，第i座山的高度为ai，现在弱弱在第一座山的左边山脚下（高度为0），他想要依此爬过这些山，到达第n座山的右边山脚下。 除了简单的爬上爬下，还有一种特殊操作。 如果弱弱目前在第i座山右面的海拔x的位置，且第j(i &lt; j)座山的海拔大于等于x，且第i + 1, . . . , j − 1座山中没有一座山的海拔高于x，那么他可以使用绳索滑到第j座山左面海拔x的位置。 弱弱想找到一种方式，使得他在行程中海拔变化的幅度最小。请输出最小幅度。 Input第一行一个整数n（1 ≤ n ≤ 1000）。接下来一行n个整数ai（1 ≤ ai ≤ 1000）表示每座山的高度。 Output一行一个整数表示答案。 Examplestandard input51 3 5 4 2 standard output 10 思路考虑山中最高的一座，最优操作一定是从第一座山的左下角开始不停地往上爬，然后从最高的山不停地往下爬爬到最后一座山的右下角。所以答案为最高山的高度*2。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int a[1007], n;int main()&#123; while(cin&gt;&gt;n)&#123; int cnt = 0; a[0] = 0; int cur = 0; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i] &gt;= a[cur])&#123; cnt += abs(a[i] - a[cur]); cur = i; &#125; &#125; while(cur&lt;n)&#123; int cur2 = cur+1; for(int i = cur2;i&lt;=n;i++)&#123; if(a[i] &gt;= a[cur2])&#123; cur2 = i; &#125; &#125; cnt+=abs(a[cur2]-a[cur]); cur = cur2; &#125; cnt+=a[n]; cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125; Problem I. 清明梦超能力者黄黄YY是一个清明梦超能力者，同时也是一个记忆大师。他能够轻松控制自己在梦中的一切，在醒来之后还能清晰的记得梦中所有的细节，这让他的朋友们都十分羡慕。 又是一个晚上，黄YY又到了自己的梦中，并且随手造出了一棵有n个点的树，树上每个点有一个初始颜色0。为了让这棵树不那么单调，黄YY拿起了画笔在上面尽情上色。每一次上色可以用u, v, c来描述，代表黄YY把u, v这条路径上的点都染色成了c。 正当黄YY开心的完成了m次染色，准备在早上醒来之时向朋友们炫耀。但现实中的黄YY由于过于兴奋滚到了床下，撞到了脑袋，在剧痛中醒来。由于脑部受到了严重创伤，黄YY对刚才梦境中发生的一切发生了严重的信息丢失。 但英俊潇洒的黄YY当然不希望自己的窘态被朋友们发现。为了证明自己还是那个清明梦超能力者，他希望告诉朋友们自己上色后每个节点的颜色。同时为了更进一步证明他还是个记忆大师，他希望干脆直接说出每个点在倒数第k次染色时的颜色。 当然，现在的黄YY已经成了弱智了，作为黄YY最亲密的朋友，你快来帮帮黄YY吧！ Input第一行三个整数n, m, k，代表树的点数，黄YY染色的次数，以及最后求颜色时，倒数的次数（1 ≤ n, m, k ≤ 100000）。 接下来n − 1行，每行u, v代表u, v两点之间有一条边。这里保证1 ≤ u, v ≤ n，且无重边与自环，是一棵标准的树。 接下来m行，每一行三个数字u, v, c代表黄YY在第这次用c颜色的画笔从u涂到了v。 Output一行n个数字，输出每个点倒数第k次染色时的颜色。如果本身不足k次，输出0。 Examplestandard input 3 3 2 1 2 2 3 1 2 1 2 3 2 1 3 3 standard output 1 2 2 Note对于点1在第一次和第三次染色的时候分别被染色为1, 3，倒数第二次的颜色就是1。 对于点2在第一、二、三次染色的时候分别被染色为1, 2, 3，倒数第二次的颜色就是2。 对于点3在第二次和第三次染色的时候分别被染色为2, 3，倒数第二次的颜色就是2。 思路首先每条路径从LCA处分开可以拆成两条链假设链A-&gt;B执行了第i次染色操作，假设A是B的祖先，那么我们在B点加入一个”插入i”的事件，在A的父亲点加入一个”删除i”的事件然后dfs整颗树求解，每个点维护一个线段树。处理一个点时先合并所有儿子的线段树，然后再处理这个点上的事件，得到线段树之后询问第K大值既可得到答案。复杂度分析：Node merge(Node a, Node* b) { if (a == NULL) return b; if (b == NULL) return a; a-&gt;sum += b-&gt;sum; a-&gt;child[0] = merge(a-&gt;child[0], b-&gt;child[0]); a-&gt;child[1] = merge(a-&gt;child[1], b-&gt;child[1]); return a;}考虑以上的线段树合并，每次合并会减少一个区间。而在事件点插入、删除的时候会产生至多log个区间，因此复杂度为O(NLogN) Problem J. 最短路给一个连通图，每次询问两点间最短路。每条边的长度都是1。 Input第一行两个整数n和m，表示图的点数和边数（1 ≤ n ≤ 100000, 1 ≤ m ≤ n + 100）。 接下来m行每行两个整数a和b，表示一条边（1 ≤ a, b ≤ n）。保证没有自环和重边。保证图连通。 接下来一个整数q表示询问的个数（1 ≤ q ≤ 100000）。 接下来q行每行两个整数a和b表示询问a和b之间的最短路。 Output每个询问输出一行表示答案 Exampleinput 4 51 22 31 44 32 441 41 22 41 3 output 1112 思路本题十分直接。我们不断地把度数为1的点删掉，把度数为2的点收缩，最后会得到一个图，和原图的点数与边数之差相同，且新图中每个点的度数都至少是3。这就是说我们会得到一个200个点300条边以内的图。新图可以用Floyd算法预处理所有点对之间最短路。询问时，将询问转化到新图上即可。转化时需要注意细节。 WANNAFLY_DAY2Problem A. Tobaku Mokushiroku Kaiji开司正在与另外一人玩石头剪刀布。双方各有一些代表石头、剪刀、布的卡牌，每局两人各出一张卡牌，根据卡牌的内容决定这一局的胜负。胜负规则为：石头赢剪刀、剪刀赢布、布赢石头、相同为平局。每张卡牌至多被使用一次。已知双方的卡牌数量，问开司最多赢几局？ Input一行六个数字a, b, c, d, e, f(0 ≤ a, b, c, d, e, f ≤ 50)，a, b, c分别表示开司的石头、剪刀、布的牌的数量，d, e, f分别表示此时另一人的石头、剪刀、布的牌的数量。 Output一个整数表示开司最多赢几局 Examplein 29 7 41 14 12 42 out 33 代码123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[6]; for(int i = 0;i&lt;6;i++) cin&gt;&gt;a[i]; cout&lt;&lt;min(a[0],a[4])+min(a[1],a[5])+min(a[2],a[3])&lt;&lt;endl; return 0;&#125; Problem E. Eustia of the Tarnished WingsNovus Aither是一个潜藏着多个势力的城市。每个势力都有一个唯一的领导人，每个领导人有一个属性值。如果两个势力的领导人的属性值分别为a, b，且|a − b| ≤ m，说明这两个领导人的思想有一定的相似之处，这两个势力可以合并，新的领导人可以指定为原来的两个领导人中的任意一个。新产生的势力可以依照相同的的规则，继续与其他势力合并。问在所有可能的合并情况中，最少会剩下几个势力。 Input第一行两个空格隔开的整数n(1 ≤ n ≤ 106), m(0 ≤ m109)。n代表当前势力的个数。m的含义如题目描述。第二行n个空格隔开的整数di(0 ≤ di ≤ 109)，代表第i个势力的领导人的属性值。 Output输出一个数表示势力的最少数量。 Examplestandard input4 12 1 3 10 standard output 2 代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1e6+7;ll a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); ll n,m; cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); int cnt = 1; for(int i = 1;i&lt;n;i++)&#123; if(a[i]-a[i-1]&gt;m) cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; WANNAFLY_DAY3Problem D. Shopping你要买n件物品，其中有一些是凳子。商场正在举行促销活动，如果购物车中有至少一个凳子，那么你可以半价购买这个购物车中最贵的一个物品。你有m辆购物车，请最小小化你的花费。 Input第一行一个整数t表示数据组数(1 ≤ t ≤ 100)。 每组数据第一行两个整数n, m (1 ≤ n, m ≤ 1000)，接下来n行每行两个整数ai, bi，分别表示第i件物品的价格以及它是否是凳子(1 ≤ ai ≤ 105, 0 ≤ bi ≤ 1)。 Output每组数据输出一行一个实数表示最小花费，保留一位小数。 Examplestdin25 11 02 13 14 05 05 101 02 13 14 05 0 stdout 12.510.5 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;const int maxn = 1007;struct node&#123; double cost; int flag;&#125;a[maxn];int cmp(node a,node b)&#123; return a.cost&gt;b.cost;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m; int cnt = 0; double all = 0; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i].cost; cin&gt;&gt;a[i].flag; if(a[i].flag==1) cnt++; all+=a[i].cost; &#125; if(cnt&gt;m) cnt = m; sort(a,a+n,cmp); for(int i = 0;i&lt;cnt;i++)&#123; all-=(a[i].cost/2.0); &#125; printf(&quot;%.1lf\n&quot;,all); &#125; return 0; &#125; WANNAFLY_DAY47 贵族用户终于活成了自己讨厌的样子。充钱能让你变得更强。 在暖婊这个游戏里面，如果你充了 x 元钱，那么你能获得 10x 个钻石。同时暖婊也有 m 档VIP，如果你往暖婊里面充了 ai 个钻石，那么你能成为第 i 档贵族用户。当你成为为第 i 档贵族用户。当你成为第 i 档贵族用户之后，那么你可以获得 pi% 的优惠。 你需要 k 件材料合成衣服，其中第 i 件材料原价为 di 个钻石，你一共需要 ci 件这种材料。当你获得 p 的优惠时，这个材料的真实价格为 ⌈di(1 − p)⌉。请问栗子米最少需要氪多少钱，这里我们规定只能氪整数的钱。 7.2 输入格式第一行一个整数 T(T ≤ 1000)，表示数据组数。每组数据第一行两个整数 m, k(1 ≤ m, k ≤ 15)。 接下来 m 行每行两个正整数 1 ≤ ai ≤ 105, 1 ≤ pi ≤ 100，保证 ai &lt; ai+1, pi ≤ pi+1。接下来 k 行每行两个正整数 1 ≤ ci, di ≤ 1000。 7.3 输出格式对于每组数据，输出一个整数，表示至少要氪多少钱。 7.4 样例输入11 1100 100100 100 7.5 样例输出10 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int m,k;struct node&#123; int a; int p;&#125;vip[20];struct cost&#123; int cc; int dd;&#125;dim[20];int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;m&gt;&gt;k; for(int i = 0;i&lt;m;i++)&#123; cin&gt;&gt;vip[i].a&gt;&gt;vip[i].p; if(vip[i].a%10) vip[i].a+=10-(vip[i].a%10); &#125; int ans = 0; for(int i = 0;i&lt;k;i++)&#123; cin&gt;&gt;dim[i].cc&gt;&gt;dim[i].dd; ans+=dim[i].cc*dim[i].dd; &#125; if(ans%10) ans+=10-(ans%10); int minx = ans; for(int u = 0;u&lt;m;u++)&#123; int ans2 = 0; for(int i = 0;i&lt;k;i++)&#123; ans2 += dim[i].cc*(ceil((1-((double)vip[u].p/100.0))*dim[i].dd)); &#125; if(ans2%10)&#123; ans2+=10-(ans2%10); &#125; if(ans2&lt;=vip[u].a)&#123; ans2 = vip[u].a; &#125; minx = min(minx,ans2); &#125; cout&lt;&lt;minx/10&lt;&lt;endl; &#125; return 0;&#125; WANNAFLY_DAY6F平衡二叉树 代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 70;ll n,d;ll a,b;ll c[maxn];int main()&#123; cin&gt;&gt;n&gt;&gt;d; a = 1; b = 0; memset(c,0,sizeof(c)); for(int i = 0;i&lt;n-1;i++) a*=2; a-=1; for(int i = 0;i&lt;=d;i++)&#123; c[i] = 1; &#125; c[d+1] = 2; for(int i = d+2;i&lt;n-1-d;i++)&#123; c[i] = c[i-1]+c[i-d-1]; &#125; for(int i = 0;i&lt;n-1-d;i++) b+=c[i]; cout&lt;&lt;a-b&lt;&lt;endl; return 0;&#125; H卡牌游戏 代码123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; for(int u = 1;u&lt;=t;u++)&#123; long double x,y; int z; cin&gt;&gt;x&gt;&gt;y; cin&gt;&gt;z; printf(&quot;Case #%d: &quot;,u); long double ans = 0; for(int i = 0;i&lt;z;i++)&#123; ans += x/y; x--; y--; &#125; printf(&quot;%Lf\n&quot;,ans); &#125; return 0;&#125; WANNAFLY_DAY7A.机器学习 代码12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double n; cin&gt;&gt;n; printf(&quot;%.2lf\n&quot;,n); return 0;&#125; D最小生成树 代码1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 1e5+7;ll a[maxn];int main()&#123; int n; cin&gt;&gt;n; ll minx = 0x3fffffff; ll sum = 0; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; minx = min(minx,a[i]); sum+=a[i]; &#125; sum += minx*(n-1); sum-=minx; cout&lt;&lt;sum&lt;&lt;endl;; return 0;&#125; G区间权值 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxx = 1e7+7;const int maxn = 300007;const int mod = 1e9+7;ll a[maxn] = &#123;0&#125;;ll w[maxn] = &#123;0&#125;;ll dpa[maxn] = &#123;0&#125;;ll dpb[maxn] = &#123;0&#125;;ll dpl[maxn] = &#123;0&#125;;ll dpr[maxn] = &#123;0&#125;;int n;void init()&#123; for(int i = 1;i&lt;=n;i++)&#123; int tmp = min(i,n-i+1); dpb[i] = tmp*dpa[n]%mod; dpb[i] -= dpl[tmp-1]; dpb[i] -= dpr[n-tmp+2]; dpb[i]%=mod; dpb[i] *= w[i]; dpb[i]%=mod; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; dpa[i] = a[i]; dpa[i]+=dpa[i-1]; dpa[i]%=mod; dpl[i] = dpl[i-1]; dpl[i]+=dpa[i]; dpl[i]%=mod; &#125; dpr[n+1] = 0; for(int i = n;i&gt;=1;i--)&#123; dpr[i] = dpr[i+1]; dpr[i]+=dpa[n]-dpa[i-1]; dpr[i]%=mod; &#125; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;w[i]; &#125; ll ans = 0; init(); for(int i = 1;i&lt;=n;i++)&#123; ans+=dpb[i]; ans%=mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; I联通块计数 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxx = 1e7+7;const int maxn = 1e5+7;const ll mod = 998244353;int n;ll a[maxn];ll dp[maxn];void init()&#123; for(int i = 0;i&lt;n;i++)&#123; dp[i] = a[i]; dp[i]%=mod; if(i&gt;0)&#123; dp[i]*=dp[i-1]; dp[i]%=mod; dp[i]+=a[i]; dp[i]%=mod; dp[i]+=dp[i-1]; dp[i]%=mod; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; ll ans = 1; for(int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; ans+=(a[i]*(a[i]+1)/2)%mod; ans%=mod; &#125; init(); if(n&gt;0)&#123; ans+=dp[n-1]; ans%=mod; &#125; cout&lt;&lt;ans%mod&lt;&lt;endl; return 0;&#125; J寻找复读机 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+7;int n,m;int vis[maxn];int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof(vis)); string str1, tmp; int d; while(m--)&#123; cin&gt;&gt;d; cin&gt;&gt;tmp; if(str1==tmp)&#123; if(vis[d]!=-1) vis[d]++; &#125; else&#123; vis[d]=-1; &#125; str1 = tmp; &#125; int flag = 0; for(int i = 1;i&lt;=n;i++)&#123; if(vis[i]!=-1)&#123; if(flag==0)&#123; cout&lt;&lt;i; flag = 1; &#125; else cout&lt;&lt;&apos; &apos;&lt;&lt;i; &#125; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>ACM/ICPC</tag>
        <tag>CCPC</tag>
        <tag>wannafly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sg函数与nim博弈]]></title>
    <url>%2F2018%2F07%2F28%2F2018-07-28%2F</url>
    <content type="text"><![CDATA[内容：sg函数 时间：2018-7-28 课件by.浅悠悠 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>sg函数</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.26图论基础专项训练题解]]></title>
    <url>%2F2018%2F07%2F26%2F2018-07-26%2F</url>
    <content type="text"><![CDATA[问题 A: 签到题之青蛙爬楼梯时间限制: 1 Sec 内存限制: 128 MB提交: 117 解决: 37[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述楼梯有n阶台阶，青蛙每次可以跳1~n阶台阶，问青蛙共有多少种上楼梯的方法。 输入输入仅一行，一个整数n（n&lt;=50） 输出输出n阶台阶对应上楼梯的方法。 样例输入13 样例输出14 提示本题作为水题，不作为图论题。样例提示（1，1，1），（1，2），（2，1），（3）共4种方法 题解第n阶台阶，我们可以从n-1跳到n，可以从n-2跳到n……可以从1跳到n，也可以从0跳到n。那么要求第n阶的数量，只需求前n-1阶，前n-2阶……前1阶的方法，所以我们列出关系式为F(n)=F(n-1)+F(n-2)+……+F(1)+1。同理，第n-1阶的关系式为F(n-2)+F(n-3)+……+F(1)+1。两个式子合并得F(n)=2*F(n-1)。由于F(1)=1,所以F(n)=2^(n-1)。 代码参考12345678910#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main()&#123; int n; cin&gt;&gt;n; ll a = pow(2,n-1); cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 问题 B: 排名时间限制: 1 Sec 内存限制: 128 MB提交: 60 解决: 24[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述有 N 个比赛队（1&lt;=N&lt;=500），编号依次为 1，2，3……N 进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即 P1 赢 P2，用 P1，P2 表示，排名时 P1 在 P2之前。现在请你编程序确定排名。 符合条件的排名可能不是唯一的。此时要求输出时编号小的队伍在前。输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。 输入输入有若干组。每组中的第一行为二个数N（1&lt;=N&lt;=500）。M；当中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中。每行也有两个整数P1。P2表示即P1队赢了P2队。 输出给出一个符合要求的排名。输出时队伍号之间有空格。最后一名后面没有空格。 样例输入12344 31 44 32 3 样例输出11 2 4 3 题解拓扑排序模板题，唯一可能出现问题的地方就是题目要求同样拓扑序的两个编号小的要在前面，这点可以通过将普通拓扑排序中的队列改为使用优先队列或者堆来实现。 代码参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;const int maxn=510;int graph[maxn][maxn];//保存图int degree[maxn];//保存入度int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; memset(graph,0,sizeof(graph)); memset(degree,0,sizeof(degree)); for(int i=0;i&lt;m;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(!graph[u][v]) &#123; graph[u][v]=1; degree[v]++;//的入度++ &#125; &#125; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q; for(int i=1;i&lt;=n;i++) if(degree[i]==0) q.push(i); bool first=1; while(!q.empty()) &#123; int cur=q.top(); q.pop(); if(first) &#123; cout&lt;&lt;cur; first=0; &#125; else cout&lt;&lt;&quot; &quot;&lt;&lt;cur; for(int i=1;i&lt;=n;i++) &#123; if(graph[cur][i]==1) &#123; degree[i]--;//相连的点的入度减1 if(degree[i]==0)//假设入度为0，增加队列 q.push(i); &#125; &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; 问题 C: 系兄弟就来砍我时间限制: 1 Sec 内存限制: 128 MB提交: 34 解决: 10[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述渣渣灰因为一句“大家好，我系渣渣辉，系兄弟就来砍我”引得众粉丝纷纷拿两米长的大刀寻找。现有n个据点，编号（1~n），有m条单向路使据点相连。每个据点仅有一个人。这n个人中有k个粉丝。其中渣渣灰在s据点处。请问这k个粉丝到渣渣灰的最短距离是多少 输入首行输入nmks。(k&lt;=n&lt;=100m&lt;=500)s为渣渣灰所在位置 接下来m行，每行输入xyz，表示从x到y的距离是z，由于是单向边，则y到x的距离不一定是z。 接下来k个数字，表示粉丝所在据点。 输出对于每一个粉丝，输出对应的最短距离。 样例输入123453 3 2 11 2 12 3 13 1 12 3 样例输出12 1 提示数据保证k个粉丝均能到达渣渣灰的据点 题解首先，既然要求k个点到s点的最短路，我们可以反过来求s到这k个点的最短路。这样就变成了单源最短路问题，dijkstra算法和spfa算法都可以做。由于图为有向图，我们在存图时反向存图即可，原本a[i][j]表示i-&gt;j，我们可以将它重新定义为j-&gt;i，或者存图时直接写成a[j][i]即可。 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷infint n,m,k,s;int dis[maxn]; //储存各个点到源点的最短距离,dis[s]为0int road[maxn][maxn]; //两点之间直接距离关系bool vis[maxn]; //判断源点到该点的距离是否为最短距离int fans[maxn];void dijkstra(int s)&#123; memset(vis, false, sizeof(vis)); vis[s] = true; for(int i = 1; i &lt;= n; i++) dis[i] = road[s][i]; for(int u = 1; u&lt;n; u++) &#123; int minD = inf,k = -1; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[i]&lt;minD) &#123; k = i; minD = dis[i]; &#125; &#125; vis[k] = true; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i]) &#123; dis[i]=dis[k]+road[k][i]; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s; memset(road,inf,sizeof(road)); for(int i = 1; i&lt;=m; i++) &#123; int tmp; int x,y; cin&gt;&gt;x&gt;&gt;y&gt;&gt;tmp; road[y][x]=tmp; &#125; dijkstra(s); for(int i = 0; i&lt;k; i++) &#123; cin&gt;&gt;fans[i]; &#125; for(int i = 0; i&lt;k-1; i++) cout&lt;&lt;dis[fans[i]]&lt;&lt;&apos; &apos;; cout&lt;&lt;dis[fans[k-1]]&lt;&lt;endl; return 0;&#125; 问题 D: 躁动的小Z时间限制: 1 Sec 内存限制: 128 MB提交: 7 解决: 2[提交][状态][讨论版][命题人:外部导入][Edit] [TestData)] 题目描述你猜怎么样？小Z追到Gakki了！Gakki邀请小Z去她家共进晚餐，小Z喜出望外。小Z的家和Gakki的家隔着几个街区，所以他决定乘坐公交车前往 Gakki家赴约。小Z的家在公交站台的起始站（编号为1），而Gakki家正好在末站（编号为n）。城市中有许多公交站台，有些站台之间可以通过公交 线路互相到达。现在给你n个公交站台和m条不同的公交线路的时间花费，请你帮助小Z分析一下最短的可以从家里来到Gakki身边的路径？ 输入有多组测试样例。 第一行两个正整数n,m(2≤n≤10^5,0≤m≤10^5)，代表站台数与公交线路数量。 接下来m行每行三个正整数a[i],b[i],w[i],代表从公交站a[i]到b[i]需要花费的时间为w[i]。(1≤a[i],b[i]≤n,1≤w[i]≤10^6) 注意：公交线路可能会产生环，并且两个站台之间可能有多条公交线路。 输出单独一行，输出花费时间最小时小Z经过的公交站台编号，以空格隔开；如果小Z无法到达Gakki的家，则输出-1. 样例输入12345675 61 2 22 5 52 3 41 4 14 3 33 5 1 样例输出11 4 3 5 题解半年前写的代码。其实原理很简单，在dijkstra算法模板的基础上加上一个pre数组，用于记录该节点的上一个节点，即该点是经过哪一点才到达该点的。pre数组具体在边松弛的过程中进行重新赋值，松弛成功就将pre值记录k点，及该点是由起点经过k点后所得到的。最后把pre数组中的值递归输出一遍即可。 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;string.h&gt; #include&lt;stdlib.h&gt;#define max 900000typedef struct &#123; int d; int pre;&#125;path;path to[1000 + 2];int g[1000 + 2][1000 + 2], vis[1000 + 2]; void fun(int ddd) &#123; if (ddd == 1) &#123; printf(&quot;%d&quot;, ddd); return; &#125; int j= to[ddd].pre; fun(j); printf(&quot; %d&quot;, ddd);&#125;int main() &#123; int n, m, a, b, v, i, j, min, k, from; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; memset(vis, 0, sizeof(vis)); for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; g[i][j] = max; &#125; to[i].d = max; &#125; for (i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v); g[a][b] = v; g[b][a] = v; &#125; for (i = 2; i &lt;= n; i++) &#123; to[i].d = g[1][i]; if (g[1][i] != max) &#123; to[i].pre = 1; &#125; &#125; vis[1] = 1; for (i = 2; i &lt;= n; i++) &#123; min = max; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123; min = to[j].d; k = j; &#125; &#125; vis[k] = 1; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123; to[j].d = to[k].d + g[k][j]; to[j].pre = k; &#125; &#125; &#125; fun(n); printf(&quot;\n&quot;); &#125; return 0;&#125; 问题 E: 逛街时间限制: 1 Sec 内存限制: 128 MB提交: 8 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述假设渣渣灰有一个女朋友，他的女朋友要他陪着一起去公园。由于渣渣灰不喜欢运动，所以他想找一条最短的路到达公园。由于途中会有许多消费点，而每到一个消费点女朋友就要购物，而渣渣灰比较抠，所以假如有多条最短路，则他会选择途中消费点最便宜的。给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 输入输入nm，点的编号是1~n然后是m行，每行4个数 abdp，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 st;起点s，终点。n和m为0时输入结束。(1&lt;n&lt;=1000 0&lt;m&lt;100000 s != t) 输出输出 一行有两个数， 最短距离及其花费。 样例输入1234563 21 2 5 62 3 4 51 30 0 样例输出19 11 提示输入样例的空行只是为了让大家分辨数据，输入有没有空行都没关系。输出样例没有空行。 题解同上一道题的方法，我们再创建一个value数组储存花费情况。在松弛时对value进行改变。松弛成功则value（s-&gt;i）=value(s-&gt;k-&gt;i)。若最短路相等则对value值进行比较，即value（s-&gt;i）=min(value(s-&gt;k-&gt;i),value（s-&gt;i))。s为源点，i为当前终点，k为中间点。最终输出最短路及对应value值即可。 代码参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define INF 0x3f3f3f3f#define Min(a,b) a&gt;b?b:astruct Node&#123; int adj,val;&#125;g[1005][1005];int dist[1005];//距离int value[1005];//费用int used[1005];//标记int n,m,i,j;void Dijkstra(int s)&#123; memset(dist,0x3f,sizeof(dist)); memset(value,0x3f,sizeof(value)); memset(used,0,sizeof(used)); dist[s]=0;//从起点开始 value[s]=0; while(1) &#123; int k,u=-1,d[1005]; int min=INF; memset(d,0,sizeof(d)); for(i=1;i&lt;=n;i++) if(used[i]==0&amp;&amp;dist[i]&lt;min)//找出从起点到下一个最小距离的顶点 &#123; min=dist[i]; u=i;//记录下标 &#125; if(u==-1)//判断所有顶点是否都到达过 return ; for(i=1,k=0;i&lt;=n;i++) if(dist[u]==dist[i]&amp;&amp;used[i]==0) d[k++]=i;//从起点到下一个要访问的顶点的最小距离可能有多个 for(i=0;i&lt;k;i++) used[d[i]]=1; for(i=0;i&lt;k;i++)//多个满足的点分别进行迪杰斯特拉最短路查找 for(j=1;j&lt;=n;j++) if(g[d[i]][j].adj!=INF &amp;&amp; (dist[d[i]]+g[d[i]][j].adj)&lt;=dist[j]) &#123;//原理与 main()函数中建立邻接矩阵一样 if((dist[d[i]]+g[d[i]][j].adj)&lt;dist[j]) value[j]=value[d[i]]+g[d[i]][j].val; else value[j]=Min(value[j],value[d[i]]+g[d[i]][j].val); dist[j]=dist[d[i]]+g[d[i]][j].adj; &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; (n||m)) &#123; int a,b,d,p; memset(g,0x3f,sizeof(g)); for(i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;d,&amp;p); if(d&lt;=g[a][b].adj)//处理路径距离问题 &#123; if(d==g[a][b].adj)//如果距离相等，则存放最少的费用 g[a][b].val=g[b][a].val=Min(p,g[a][b].val); else//否则，存放新路径距离的费用 g[a][b].val=g[b][a].val=p; g[a][b].adj=g[b][a].adj=d;//填充路径距离 &#125; &#125; int s,t; scanf(&quot;%d%d&quot;,&amp;s,&amp;t); Dijkstra(s); printf(&quot;%d %d\n&quot;,dist[t],value[t]); &#125; return 0;&#125; 问题 F: 足球时间限制: 1 Sec 内存限制: 128 MB提交: 3 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述yoyo得到了一个足球，这个足球与其他的足球一样，表面有 12 个正五边形和 20 个正六边形组成，足球的每个面初始的时候都为白色。现在yoyo把这个足球拆解开来，32个面编号为1~32。爱画画的yoyo希望将足球的某些面涂为黑色（可能是 0 个），在每次涂色操作中，慢慢只可以将某一些相邻或者联通的面一起涂为黑色（两个面相邻当且仅当他们共用一条边）。例如，yoyo可以在一次涂色操作中将面 1、2、3、4、5 涂为黑色，但是他不可以将面11 和 24 涂为白色，因为面 11 和 24 是不相邻也不联通的。求yoyo所需要的最少的涂色次数。 输入第一行包含一个整数 t，表示有t组测试数据，对于每组测试数据： 输入包含一行，该行包含 32 个整数，每个数的值等于 0 时表示白色，等于 1 时表示黑色。 输出对于每组测试数据，输出Case c: ans，其中 c 为测试数据编号，ans 为最少的操作次数。 样例输入123431 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 01 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 样例输出123Case 1: 1Case 2: 0Case 3: 2 提示除了相邻的数面也相邻外，面 1 和面 13 是相邻的，面 13 和面 17 是相邻的，面 17 和面 32 是相邻的，面 15 和面 32 是相邻的，面 19 和面 32 是相邻的。 PS:1和32不相邻。 题解先把所有相邻的点赋值为1，再用Floyd算法把所有点之间的最短距离打表求出来。之后每输入一组样例，则对样例中的1dfs深搜，然后深搜把所有相邻为1且值为1的点重新赋值为0。最后记录下主循环中dfs的次数即可。 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 32 + 1;int dis[maxn][maxn];int vis[maxn];void init()&#123; memset(dis,0x3f3f3f3f,sizeof(dis)); dis[32][32] = 0; for(int i = 1; i &lt; maxn - 1; i++)&#123; dis[i][i] = 0; dis[i][i + 1] = 1; dis[i + 1][i] = 1; &#125; dis[1][13] = dis[13][1] = 1; dis[17][13] = dis[13][17] = 1; dis[17][32] = dis[32][17] = 1; dis[15][32] = dis[32][15] = 1; dis[19][32] = dis[32][19] = 1; for(int k = 1; k &lt; maxn; k++)&#123; for(int i = 1; i &lt; maxn; i++) for(int j = 1; j &lt; maxn; j++) if(dis[i][j] &gt; dis[i][k]+dis[k][j]) dis[i][j] = dis[i][k]+dis[k][j]; &#125;&#125;void dfs(int x)&#123; vis[x] = 0; for(int i = 1; i &lt; maxn; i++)&#123; if(vis[i]&amp;&amp;dis[x][i]==1) dfs(i); &#125;&#125;int main()&#123; init(); int t; cin&gt;&gt;t; for(int u = 1;u &lt;= t;u++)&#123; for(int i = 1;i &lt; maxn; i++) cin&gt;&gt;vis[i]; int ans = 0; for(int i = 1; i &lt; maxn; i++)&#123; if(vis[i])&#123; ans++; dfs(i); &#125; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;u&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 问题 G: 牌时间限制: 1 Sec 内存限制: 128 MB提交: 2 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌i，j，得到一个ai bj + bi aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。 输入首行输入n，代表n个点 接下来n行，每一行两个属性ab第i行代表第i张牌，属性为ai，bi。数据范围保持在200以内。 输出输出最大分数 样例输入12345652 43 31 72 54 4 样例输出1108 题解主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;string.h&gt; #include&lt;stdlib.h&gt;#define max 900000typedef struct &#123; int d; int pre;&#125;path;path to[1000 + 2];int g[1000 + 2][1000 + 2], vis[1000 + 2]; void fun(int ddd) &#123; if (ddd == 1) &#123; printf(&quot;%d&quot;, ddd); return; &#125; int j= to[ddd].pre; fun(j); printf(&quot; %d&quot;, ddd);&#125;int main() &#123; int n, m, a, b, v, i, j, min, k, from; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; memset(vis, 0, sizeof(vis)); for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= n; j++) &#123; g[i][j] = max; &#125; to[i].d = max; &#125; for (i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;v); g[a][b] = v; g[b][a] = v; &#125; for (i = 2; i &lt;= n; i++) &#123; to[i].d = g[1][i]; if (g[1][i] != max) &#123; to[i].pre = 1; &#125; &#125; vis[1] = 1; for (i = 2; i &lt;= n; i++) &#123; min = max; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &lt; min&amp;&amp;vis[j] == 0) &#123; min = to[j].d; k = j; &#125; &#125; vis[k] = 1; for (j = 2; j &lt;= n; j++) &#123; if (to[j].d &gt; to[k].d + g[k][j] &amp;&amp; vis[j] == 0) &#123; to[j].d = to[k].d + g[k][j]; to[j].pre = k; &#125; &#125; &#125; fun(n); printf(&quot;\n&quot;); &#125; return 0;&#125; 常用模板代码拓扑排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=510;int graph[maxn][maxn];//保存图int degree[maxn];//保存入度int TOP[maxn];//保存已删除点int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; int now = 0；//指针作用记录TOP中可插入的位置 memset(graph,0,sizeof(graph)); memset(degree,0,sizeof(degree)); for(int i=0;i&lt;m;i++) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(!graph[u][v]) &#123; graph[u][v]=1; degree[v]++;//v的入度++ &#125; &#125; queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++) if(degree[i]==0) q.push(i); while(!q.empty()) &#123; int cur=q.front(); q.pop(); TOP[now++]=cur; for(int i=1;i&lt;=n;i++) &#123; if(graph[cur][i]==1) &#123; degree[i]--;//相连的点的入度减1 if(degree[i]==0)//假设入度为0，增加队列 q.push(i); &#125; &#125; &#125; //这里可以添加输出，排序已保存在TOP数组中 &#125; return 0;&#125; dijkstra（单元最短路径）1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 107;const int inf = 0x3f3f3f3f; //需将road及dis初始化为正无穷infint n,m,k,s;int dis[maxn]; //储存各个点到源点的最短距离,dis[s]为0int road[maxn][maxn]; //两点之间直接距离关系bool vis[maxn]; //判断源点到该点的距离是否为最短距离void dijkstra(int s)&#123; memset(vis, false, sizeof(vis)); vis[s] = true; for(int i = 1; i &lt;= n; i++) dis[i] = road[s][i]; for(int u = 1; u&lt;n; u++) &#123; int minD = inf,k = -1; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[i]&lt;minD) &#123; k = i; minD = dis[i]; &#125; &#125; vis[k] = true; for(int i = 1; i&lt;= n; i++) &#123; if(!vis[i]&amp;&amp;dis[k]+road[k][i]&lt;dis[i]) &#123; dis[i]=dis[k]+road[k][i]; &#125; &#125; &#125;&#125;int main()&#123; memset(road,inf,sizeof(road)); //主函数添加程序与数据以及调用dijkstra return 0;&#125; SPFA（单元最短路径，可带负环）1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define N 105int res[N];//存储源点到每个顶点的最短距离值int g[N][N];int cnt[N];//每个点入队次数，判断是否出现负环int que[N*N];//队列bool in_que[N];//标记一个点是否已在队列中int front;//队首位置int rear;//队尾位置void spfa(int n,int src)&#123; rear=front=0; que[++rear]=src; memset(res,0x3f3f3f3f,sizeof(res)); memset(in_que,0,sizeof(in_que)); res[src]=0; while(front&lt;rear) &#123; int cur=que[++front]; in_que[cur]=0; int i; for(i=1; i&lt;=n; i++) &#123; if(res[cur]+g[cur][i]&lt;res[i]) &#123; res[i]=res[cur]+g[cur][i]; if(!in_que[i]) &#123; que[++rear]=i; in_que=1; &#125; &#125; &#125; &#125;&#125; Floyed（全源最短路径）123456789for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) /* 实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j] 都不是Inf ，只要一个是Inf，那么就肯定不必更新。 */ if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j]; Prim最小生成树1234567891011121314151617181920void Prim()&#123; int i,j,k,tmp,ans; for(i=1;i&lt;=n;i++) dis[i]=inf;//初始化 dis[1]=0; for(i=1;i&lt;=n;i++)&#123; tmp=inf; for(j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;tmp&gt;dis[j])&#123; tmp=dis[j]; k=j; &#125;//找出最小距离的节点 &#125; vis[k]=1;//把访问的节点做标记 for(j=1;j&lt;=n;j++)&#123; if(!vis[j]&amp;&amp;dis[j]&gt;map[k][j]) dis[j]=map[k][j];//更新最短距离 &#125; &#125;&#125; kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1007;int n,m;struct Edge&#123; int x; int y; int l;&#125; edge[maxn];int fa[maxn];int init()&#123; for(int i = 0; i&lt;maxn; i++) fa[i] = i;&#125;int findfa(int x)&#123; return fa[x] == x ? x : (fa[x] = findfa(fa[x]));&#125;int merge_1(int x,int y)&#123; fa[findfa(x)] = findfa(y);&#125;int kruskal()&#123; int cnt = 0; int sum = 0; for(int i = 0; i&lt;= m; i++) &#123; int fx = findfa(edge[i].x); int fy = findfa(edge[i].y); if(fx!=fy) &#123; merge_1(fx,fy); cnt++; sum+=edge[i].l; if(cnt&gt;=n-1) break; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;int main()&#123; init(); //此处填写边以及点等待输入数据，填写完成后须对边的权值进行排序 kruskal(); return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论1（拓扑排序 + 最短路 + 最小生成树）]]></title>
    <url>%2F2018%2F07%2F26%2F2018-07-26-1%2F</url>
    <content type="text"><![CDATA[内容：图论基础 时间：2018-7-26 课件by.浅悠悠 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
        <tag>SPFA算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.20-stl专项训练题解]]></title>
    <url>%2F2018%2F07%2F20%2F2018-07-20%2F</url>
    <content type="text"><![CDATA[问题A问题A同问题B，具体方法在问题B中介绍，此处仅贴代码 输入首行输入t，代表t组测试样例 对于每一行，输入四个整数a，b，c，d 输出对于每组样例，输出一个整数表示答案 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int maxn = 9;ll a[4], sum[4] = &#123; 0 &#125;;ll dp[maxn * 4][maxn * 4];//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; &#125; dp[i][i] = 1; &#125;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--)&#123; init();//打表 ll ans = 1; //这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里 for (int i = 0; i &lt; 4; i++) &#123; !i ? sum[i] = 0 : sum[i] = sum[i - 1]; cin &gt;&gt; a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i]; &#125; //将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d) for (int i = 1; i &lt; 4; i++) &#123; ans *= dp[sum[i]][a[i]]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; return 0;&#125; 问题 B: yoyo思维题(困难)问题A同问题B 提交: 4 解决: 2[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述小琳，小花，小薇，yoyo，他们每个人手上有一堆牌，牌的张数分别为x1，x2，x3，x4，每张牌都不一样。现有n名同学，n=x1+x2+x3+x4。每名同学均需要一张牌，于是他们按顺序每人随机到四个人那里拿取牌顶的一张牌，最后一个人刚好拿到剩下的最后一张牌。排队拿牌的同学的顺序是固定的，选择拿谁的牌是不确定的。假如发牌的人手上的牌发完了，则要拿牌的同学会选择其他发牌的人。请问有多少种取法取走所有的牌。 输入首行输入t，代表t组测试样例 对于每一行，输入四个整数a，b，c，d，输入为均不超过500的正整数 输出对于每组样例，输出一个整数表示答案，答案对10^9+7取模 样例输入1215 4 2 3 样例输出12522520 提示本题作为思维题，并未用到stl，仅锻炼一下大家解决问题的能力。用到的数学知识相对多一点。 题解题目大致可以理解为4堆牌a,b,c,d，每次从一堆牌里拿出牌顶的一张牌，问共有多少种拿法。其实我们可以一堆一堆的分析，假设只有一堆a时只有1种拿法，那两堆a,b时我们可以认为是从a个牌中插入b张牌，用数学表达式就是C(b,a+b);那么三堆的话我们可以把前两堆看成一堆，那么表达式就是C(c,a+b+c)，这是我们需要与前两堆的组成方法相乘，就是C(b,a+b)C(c,a+b+c)。4堆的话就是C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。所以答案就是C(a,a)C(b,a+b)C(c,a+b+c)C(d,a+b+c+d)。此外，有一公式C(a,b) = C(a,b-1)+C(a-1,b-1)，所以我们用数组来代替C(m,n)操作 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int maxn = 501;const ll mod = 1000000007;ll a[4], sum[4] = &#123; 0 &#125;;ll dp[maxn * 4][maxn * 4];//打表，递推公式C(a,b) = C(a,b-1)+C(a-1,b-1)void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; dp[i][j] %= mod; &#125; dp[i][i] = 1; &#125;&#125;int main() &#123; int t; cin&gt;&gt;t; while(t--)&#123; init();//打表 ll ans = 1; //这一步可要可不要，其实就是将a,a+b,a+b+c,a+b+c+d存进sum里 for (int i = 0; i &lt; 4; i++) &#123; !i ? sum[i] = 0 : sum[i] = sum[i - 1]; cin &gt;&gt; a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i]; &#125; //将对应3组排列组合相乘，及C(b,a+b)C(c,a+b+c)C(d,a+b+c+d) for (int i = 1; i &lt; 4; i++) &#123; ans *= dp[sum[i]][a[i]]; ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; return 0;&#125; 问题 C: 悠派计算器提交: 4 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit][TestData)] 题目描述yoyo的小老弟小渣渣灰特别懒，兴趣爱好并不多，就睡觉一个。为了多睡会儿懒觉，他把数学老师布置的作业全部推给yoyo计算。yoyo很头疼，于是请你帮他写一个计算器帮忙计算。现有多个数学表达式，请你写一个计算器算出结果，表达式只包含’+’’-‘’*’’/‘’%’’(‘’)’操作，其中表达式中’-‘作为减运算符，不会作为负号出现，此外’/‘为整除运算符，’%’为取余运算符。表达式保证合法。 输入输入第一行t，表示共有t行测试用例，接下来t行每一行均为一个合法的数学表达式。保证每个数在[09999]范围内，保证计算过程中不会出现超范围情况。（注：没有空格） 输出输出计算结果 样例输入1234567870*15%61-2*(3+4*5%6)+7/8-9*10%11*12(1+2*3)1-(100%5)(3+2*5)/(5)(11-11)+(33)*64-11 样例输出123456705-1357122101 提示数据很水，不用考虑long long或取余等情况。 题解逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如(a+b)(c+d)转换为ab+cd+ 如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。 例如(a+b)(c+d)转换为ab+cd+ 计算机在计算普通表达式时，要对运算优先级用递归进行判断，对于更为复杂的表达式会使计算机运算效率变低甚至崩溃。而逆波兰表达式只需要进行简单的入栈出栈操作就可以完成任何普通表达式的运算。 普通表达式——&gt;逆波兰表达式 (1)a+b——&gt;a b + (2)a+(b-c)——&gt;a b c - + (3)a+(b-c)d——&gt;a b c - d + 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100007;map&lt;char,int&gt;Pri;//其实可以不必用map，只是为了方便大家理解map而多添加的一步stack&lt;int&gt;num;stack&lt;char&gt;Ope;char str[maxn];//初始化void init()&#123; Pri[&apos;+&apos;] = Pri[&apos;-&apos;] = 1; Pri[&apos;*&apos;] = Pri[&apos;/&apos;] = Pri[&apos;%&apos;] = Pri[&apos;(&apos;] = Pri[&apos;)&apos;] = 2; while(!num.empty()) num.pop(); while(!Ope.empty()) Ope.pop();&#125;//基本运算操作void operation_1(int &amp;a,int &amp;b, char c)&#123; if(c == &apos;+&apos;) a += b; else if(c == &apos;-&apos;) a = b-a; else if(c == &apos;*&apos;) a *= b; else if(c == &apos;/&apos;) a = b/a; else if(c == &apos;%&apos;) a = b%a;&#125;//遇到+或者)时执行的操作void operation_2()&#123; char ch = Ope.top(); while(ch != &apos;(&apos;&amp;&amp;!Ope.empty())&#123; Ope.pop(); int a = num.top(); num.pop(); int b = num.top(); num.pop(); operation_1(a,b,ch); num.push(a); if(!Ope.empty()) ch = Ope.top(); &#125; if(!Ope.empty()&amp;&amp;Ope.top() == &apos;(&apos;) Ope.pop();&#125;int main()&#123; int t; cin&gt;&gt;t;getchar(); while(t--)&#123; cin.getline(str,maxn); stringstream s(str); init(); char tmp; while(s &gt;&gt; tmp)&#123; //遇到数字字符时，需要判断下一位是否依旧是数字，是的话需要合并 if(tmp &gt;= &apos;0&apos; &amp;&amp; tmp &lt;= &apos;9&apos;)&#123; int t = 0; do&#123; if(Pri[tmp])&#123; break; &#125; t *= 10; t += tmp - &apos;0&apos;; &#125;while(s &gt;&gt; tmp); num.push(t); &#125; //遇到&apos;)&apos;时 if(tmp == &apos;)&apos;)&#123; operation_2(); &#125; //遇到&apos;+&apos; ‘-’时 else if(Pri[tmp]==1)&#123; if(!Ope.empty()&amp;&amp;Ope.top()!=&apos;(&apos;)&#123; operation_2(); &#125; Ope.push(tmp); &#125; else if(Pri[tmp])&#123; Ope.push(tmp); &#125; &#125; int ans = num.top(); num.pop(); while(!num.empty()&amp;&amp;!Ope.empty())&#123; operation_1(ans,num.top(),Ope.top()); Ope.pop(); num.pop(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 问题 D: 留胡子提交: 53 解决: 6[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述众所周知，刘虎子同学爱留胡子，人送外号刘胡子。为了留一抹性感又忧郁的小胡子，刘虎子专门与yoyo合作研发了一套算法，俗称油胡子算法。油胡子算法原理很简单，要想获得油胡子，首先将胡子从左到右分为n撮胡子，第i撮胡子的平均长度为xi。现每次从n中选出最左边的相邻胡子长度之差的绝对值为1的两撮胡子，减掉较长的1撮胡子，减掉的那撮胡子可以认为从n撮胡子中删除，剩下n-1撮胡子待修剪，再将剩下的n-1撮胡子从左到右重新排列成相邻的数继续如此操作，直到没有两撮相邻差的绝对值为1的胡子为止。此时的胡子称为完美油胡子。请问刘虎子同学最多需要剪多少次才能得到自己心仪的性感小胡子。 输入输入第一行为n，接下来一行n个数x1x2…xi…xn。 输出输出最多执行次数。 样例输入1263 2 3 1 0 1 样例输出15 题解用栈来维护每次合并完的数，每入栈一个数以后栈顶和次栈顶比较，如果可以合并就合并为新的栈顶，并且再次与次栈顶比较直至无法合并，在合并过程中统计次数即可。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int n,x;int ans=0; //最大操作次数stack&lt;int&gt; st;int main()&#123; int i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; //将x与当前栈顶元素st.top()比较，若栈不空且st.top()比x大1，则合并一次(此时即当前栈顶元素出栈) //然后x与次栈顶比较，以此类推，直到不满足栈不空且st.top()比x大1 while(!st.empty() &amp;&amp; st.top()-x==1) &#123; st.pop(); ans++; &#125; //若栈不空且x比st.top()大1，则合并一次 //(此时即x&quot;出栈&quot;，也就是忽略此x继续看下一个输入的x 但栈不发生任何变化) if(!st.empty() &amp;&amp; x-st.top()==1) ans++; //其他情况(x为第一个元素或不满足上述两种情况)：将x入栈 else st.push(x); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 问题 E: 卜卦提交: 1 解决: 1[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述赵神是一个特别特别闷骚的人。别看他平日表现很高冷，其实他一直暗恋着自己的小迷妹小花花，一日不见兮，思之如狂。马上快七夕了，赵神想卜一卦算一下他的爱情幸运数，于是他找到了yoyo半仙替他卜卦。yoyo半仙需要赵神的3个幸运数字以及小花花的3个幸运数字方可进行卜卦。已知赵神的3个幸运数字是’5’’2’’0’而小花花的幸运数字是abc，(保证由5，2，0，a，b，c，这6个数各不相同，且abc均为30以内的素数)。卜卦规则如下：由{520abc}组成的6个各不相同数中选取最小的3个数作为加数，其余最大的3个数作为基数。每一个数若加上加数仅能被基数整除，其他素数均不能整除，则该数称为幸运数。其中第1314个幸运数为爱情幸运数。现在你刚好知道小花花的幸运数，请你帮yoyo完成卜卦吧。PS：顺利完成任务后则会收获赵神珍藏版kiss一枚。 输入首行输入t，代表t组测试样例 接下来t行输入三个数abc。 输出输出第1314个幸运值 样例输入12327 3 117 11 13 样例输出12295410156221775105893556 来源题解待写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int fort = 1314;ll coeff[6];int cmp(ll a,ll b)&#123; return a &gt; b;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;coeff[0]&gt;&gt;coeff[1]&gt;&gt;coeff[2]; coeff[3] = 5; coeff[4] = 2; coeff[5] = 0; sort(coeff, coeff + 6, cmp); priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; set&lt;ll&gt;s; set&lt;ll&gt;ans; pq.push(1); s.insert(1); for(int i = 0;;i++)&#123; ll x = pq.top(); pq.pop(); if(i)&#123; for(int k = 3;k &lt; 6;k++)&#123; ans.insert(x - coeff[k]); if(ans.size()==fort) break; &#125; if(ans.size()==fort)&#123; /*int ttt = 1; for(set&lt;ll&gt;::iterator it = ans.begin();it!=ans.end();it++) cout&lt;&lt;ttt++&lt;&lt;&apos; &apos;&lt;&lt;*it&lt;&lt;endl;*/ set&lt;ll&gt;::reverse_iterator it = ans.rbegin(); cout&lt;&lt;*it&lt;&lt;endl; break; &#125; &#125; for(int j = 0;j&lt;3;j++)&#123; ll x2=x*coeff[j]; if(!s.count(x2))&#123; s.insert(x2); pq.push(x2); &#125; &#125; &#125; &#125; return 0;&#125; 问题 F: 成绩互评提交: 117 解决: 40[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述学生互评作业的简单规则是这样定的：每个人的作业会被k个同学评审，得到k个成绩。系统需要去掉一个最高分和一个最低分，将剩下的分数取平均，就得到这个学生的最后成绩。本题就要求你编写这个互评系统的算分模块。 输入输入第一行给出3个正整数N（3&lt; N &lt;= 104，学生总数）、k（3&lt;= k &lt;= 10，每份作业的评审数）、M（&lt;= 20，需要输出的学生数）。随后N行，每行给出一份作业得到的k个评审成绩（在区间[0 100]内），其间以空格分隔。 输出按非递减顺序输出最后得分最高的M个成绩，保留小数点后3位。分数间有1个空格，行首尾不得有多余空格。 样例输入12345676 5 388 90 85 99 6067 60 80 76 7090 93 96 99 9978 65 77 70 7288 88 88 88 8855 55 55 55 55 样例输出187.667 88.000 96.000 题解total数组保存各个同学的平均分，v数组保存每次接收得到的分数，排序后取前m名，按递增输出 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;int cmp(double a, double b) &#123; return a &gt; b;&#125;int main() &#123; int N, K, M; while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; M) &#123; vector&lt;double&gt;v(K); vector&lt;double&gt;v2(N); for (int i = 0; i &lt; N; i++) &#123; double sum = 0; for (int j = 0; j &lt; K; j++) &#123; cin &gt;&gt; v[j]; sum += v[j]; &#125; sort(v.begin(), v.end(), cmp); sum -= v[0] + v[K - 1]; sum /= K - 2; v2[i] = sum; &#125; sort(v2.begin(), v2.end(), cmp); for (int i = M - 1; i &gt; 0; i--) printf(&quot;%.3lf &quot;, v2[i]); printf(&quot;%.3lf\n&quot;, v2[0]); &#125; return 0;&#125; 问题 G: 列车提交: 18 解决: 10[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述火车站的列车调度铁轨的结构如下图所示。tle=”” align=”” /&gt; 两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有N条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？ 输入输入第一行给出一个整数N (2 &lt;= N &lt;= 105)，下一行给出从1到N的整数序号的一个重排列。数字间以空格分隔。 输出在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。 样例输入1298 4 2 5 3 9 1 6 7 样例输出14 题解必须要车号大的先出，小的后出。所以列车排队的每一队必须是从大到小排列（从右往左看），才能保证开出去的车也是从大到小的。 对于每一个想要进入并列铁轨的车，如果车号大于每一队的队尾的车号，说明不能进入已经有的队伍，必须进入新的铁轨 否则，选择一个最接近它车号的尾部车号的队伍进入 其实无需保存每一个并行队列的所有值，只需要保存当前队伍的车尾（就是每一列最左边 即 每一列的最小值）即可 因为每一次都是需要排序比较大小的，所以用set自动排序 首先把set里面放入一个0值。每一次set的最后一个值s.rbegin()都是当前所有队列队尾的最大值. 如果当前想要进入排队队伍的t值比集合里面最大值小，就移除第一个比他大的值，然后把t插入集合中。表示的是将t值插入了最接近它车号的队伍的队尾 否则就直接插入进去t值。作为新的队伍。s.upper_bound(t)返回的是第一个大于t的迭代器的位置 在前面加星号表示取这个位置的值 所以s.erase(*(s.upper_bound(t)));表示删除当前这个刚好大于t的位置处的值 因为一开始插入了一个没有的0，所以最后输出是s.size()-1。** 123456789101112131415161718#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; int n, t; cin &gt;&gt; n; set&lt;int&gt; s; s.insert(0); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; t; if(t &lt; *s.rbegin()) &#123; s.erase(*(s.upper_bound(t))); &#125; s.insert(t); &#125; cout &lt;&lt; s.size() - 1; return 0;&#125; 问题 H: 新浪关注提交: 24 解决: 14[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。 输入输入首先在第一行给出某用户的关注列表，格式如下： 人数N 用户1 用户2 …… 用户N 其中N是不超过5000的正整数，每个“用户i”（i=1 … N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。 之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。 输出我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。 样例输入1234567891010 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao8Magi 50Pota 30LLao 3Ammy 48Dave 15GAO3 31Zoro 1Cath 60 样例输出123AmmyCathPota 题解将关注的人存储在集合set里，将点赞的人和点赞的次数存储在map中，并统计点赞的平均次数sum / M，遍历map，如果map的值大于平均次数，且在set中找不到该用户名，就输出当前用户名（因为map中的键是已经按照字典序排序过的，所以直接输出就可以），并用flag标记是否有过输出，如果从始至终没有输出，说明没有悄悄关注的人，就输出Bing Mei You 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; int m, n; while (cin &gt;&gt; n) &#123; set&lt;string&gt;id; while (n--) &#123; string name; cin &gt;&gt; name; id.insert(name); &#125; cin &gt;&gt; m; map&lt;string, int&gt;mm; int sum = 0; for (int i = 0; i &lt; m; i++) &#123; int cnt; string str; cin &gt;&gt; str &gt;&gt; cnt; mm[str] = cnt; sum += cnt; &#125; sum /= m; int flag = 0; for (auto it : mm) &#123; if (it.second &gt; sum&amp;&amp;id.find(it.first) == id.end()) &#123; cout &lt;&lt; it.first &lt;&lt; endl; flag = 1; &#125; &#125; if (!flag) cout &lt;&lt; &quot;Bing Mei You&quot; &lt;&lt; endl; &#125; return 0;&#125; 问题 I: 礼物提交: 94 解决: 44[提交][状态][讨论版][命题人:qianyouyou][Edit] [TestData)] 题目描述四月一日快到了，Vayko想了个愚人的好办法——送礼物。嘿嘿，不要想的太好，这礼物可没那么简单，Vayko为了愚人，准备了一堆盒子，其中有一个盒子里面装了礼物。盒子里面可以再放零个或者多个盒子。假设放礼物的盒子里不再放其他盒子。用()表示一个盒子，B表示礼物，Vayko想让你帮她算出愚人指数，即最少需要拆多少个盒子才能拿到礼物。 输入本题目包含多组测试，请处理到文件结束。每组测试包含一个长度不大于1000只包含’(‘’)’和’B’三种字符的字符串，代表Vayko设计的礼物透视图。你可以假设，每个透视图画的都是合法的。 输出对于每组测试，请在一行里面输出愚人指数。 样例输入12((((B)()))())(B) 样例输出1241 题解看上去像是编译原理的文法识别，要用到栈，其实不是，只要看准备上面红色的字，就知道，只有三种字符()B，且待处理的串为合法的文法，所以要知道包装盒的个数，只要知道B前面有多少(字符，但可能有(()B)这种情况，B前面有)，但因为合法，所以可以在B之前的找到(与)相匹配，就剔除掉了，所以盒子的个数就是B之前的串中(的个数减去)的个数。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() &#123; string str; while (cin &gt;&gt; str) &#123; int sco = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str[i] == &apos;(&apos;) sco++; else if (str[i] == &apos;)&apos;) sco--; else if (str[i] == &apos;B&apos;) break; &#125; cout &lt;&lt; sco &lt;&lt; endl; &#125; return 0;&#125; 问题 J: Sunscreen题意：有C头奶牛要去沐光浴，太阳光太强烈会晒坏皮肤，太弱又会没效果。每头牛都有一个太阳光适宜的范围经行沐光浴，分别给出minspf_i和maxspf_i。 有L种防晒霜，每种防晒霜可以把所受阳光固定于一个值spf_i，每种有cover_i瓶。 问最多会有几头牛得到合适的光晒强度？ 题解：贪心策略，在满足minspf的条件下，尽量将spf的防晒霜涂到maxspf小的奶牛身上，因为maxspf大的奶牛有更多的选择。这里就需要一个优先队列来储存满足minspf的奶牛的maxspf的值。 具体解题步骤如下： 1.将奶牛按照minspf升序排列，将防晒霜按照spf升序排列。 2.枚举防晒霜，将minspf&lt;=spf的奶牛的maxspf存到优先队列中，然后值小的先出队列，看是否满足maxspf&gt;=spf，更新记录值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXN = 12505;struct spf &#123; int max; int min; friend bool operator &lt; (spf a, spf b) &#123; return a.min &lt; b.min; &#125;&#125;cow[MAXN], bot[MAXN];struct cmp &#123; bool operator()(const int a, const int b)const &#123; return a &gt; b; &#125;&#125;;int main() &#123; int C, L, i; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;pq; while (cin &gt;&gt; C &gt;&gt; L) &#123; for (i = 0; i &lt; C; i++) cin &gt;&gt; cow[i].min &gt;&gt; cow[i].max; for (i = 0; i &lt; L;i++) cin &gt;&gt; bot[i].min &gt;&gt; bot[i].max; sort(cow, cow + C); sort(bot, bot + L); int cur = 0, ans = 0; for(int i=0;i&lt;L;i++)&#123; while(cur &lt; C&amp;&amp;cow[cur].min &lt;= bot[i].min) &#123; pq.push(cow[cur].max); cur++; &#125; while(!pq.empty()&amp;&amp;bot[i].max) &#123; int maxSPF = pq.top(); pq.pop(); if(maxSPF &gt;= bot[i].min)&#123; ans++; bot[i].max--; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>stl</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.20-C++标本模板库stl]]></title>
    <url>%2F2018%2F07%2F20%2F2018-07-20-1%2F</url>
    <content type="text"><![CDATA[内容：stl 时间：2018-7-20 主讲人：王骏]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>stl</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[少年班]天分与平凡，青春与坚守]]></title>
    <url>%2F2018%2F07%2F14%2F2018-07-14%2F</url>
    <content type="text"><![CDATA[好久没看电影了，不知何种原因，最近忽然又怀念起那段天天刷电影，写感想的感觉。不过为什么选择少年班呢？或许是因为剧中的IMC大赛与即将参加的ACM大赛很类似吧，想提高一下学习算法的动力；或许是因为时隔两年，也在大学中度过了两年，看看如今再看这部电影又是什么感觉，是否还秉持着初心呢；或许是经历过许许多多次起起伏伏，遇见过形形色色想遇或不想遇的人或事，又怀念起那段那段青涩的高中岁月；或许只是单纯的想再看看这部电影吧。不管为何，总之现在思绪万千。就让我将这万千的思绪草草记录一下吧。 这部电影剧情很简单，讲述的是几个天才少年与一个平凡少年被发掘功课数学难题却因青春的叛逆与时代的变迁而成长的故事。故事以主人公以吴未的少年班回忆而展开，主人公吴未就是那个平凡的少年。 少年班，顾名思义就是大学里专为年纪轻轻却智商非凡的天才们开设的精英班，某知名大学老师周知庸曾经就是少年班的成员，他的梦想是攻克IMC的题目，但曾经的他未能实现，于是将希望寄托在新时代的少年身上。在他的坚持下从全国各地找到了几名心仪的人选，其中包括了吴未。 然而，像其他天才系列电影一样，天才们拥有着平凡人所羡慕的才能之外，往往却拥有着平凡人所不能理解的烦恼。天才少年方厚政年纪最小，却智商超群，可谓前途无量，只是他IQ高。EQ却低，因此没有什么朋友。天才少年麦克因家庭原因而性格叛逆，打架斗殴无所不为。天才少年王大法无拘无束，自由散漫，因此总让别人捉摸不透，不想与之有交集。天才少女周兰品学兼优，是典型的别人家的子，但也是因为优秀而让所有人都敬而远之。但是和其他电影不同的是，这些天才们不可思议的烦恼其实我们都能理解。毕竟曾经或现在处于青春期的我们哪一个人曾经没有过类似的烦恼呢？他们的性格不过是我们所有人青春期各种性格的集合并放大罢了。 当然，我们的主人公也有着自己的烦恼，身为平凡人的代表，当他进入少年班后从之前的全校第二摇身一变变成班上的倒数第一，这种落差估计每个处于青春期的孩子都受不了吧。于是他一边仰望着天才们过人的天赋，一边忍受着天才们怪异的性格，一边照顾着正处于青春期幼稚的天才们，一边独自默默努力着，为了自己心中的荣誉。然而，努力在这满是天才的地方却显得那么多余。就在他一筹莫展，开始疑惑为何老师选中他的时候，周知庸老师出现，解开了她的心结。“运送金枪鱼的时候，要在里面混进几条鲶鱼，否则金枪鱼就会因懒惰而死，到不了岸。”老师鼓励他做好自己鲶鱼的身份，因为天才们离开了它的照顾就会堕入深渊。尽管是鲶鱼，但吴未却似乎找到了自己的归宿，并以此为荣，从此，吴未以天才们的快乐为快乐，以天才们的梦想为梦想，就在自己喜欢的人面前，也只能呼喊着天才们所喜欢的校花名字。 IMC马上开始了，老师想进各种办法激励着天才们去努力钻研，但是恃才傲物并且正处于青春期的天才们又怎会把新鲜的大学生活浪费在学习上呢？趁着大学生活的新鲜感犹在，天才们渐渐被校花江依琳所吸引，从此各种各样的新奇表白开始了。只有吴未从一开始就暗恋着同班的天才少女周兰。尽管周兰从来都看不起吴未，并且单恋这少年班的迈克。 比赛前一天，几名少年班朝夕相处的小伙伴们在酒后发泄着各种各样青春期的passion，来到女生宿舍楼下，大声表白校花，那一刻，漫天飞舞的纸花，洋洋洒洒，似乎整个世界都在期待着几个天才少年去改变。 比赛的一个月里，天才们尽管出现各种各样的矛盾，但在吴未的调节下，无伤大雅。但一次偶遇，校花与富家公子哥之间的隐曲之事深深刺激到了天才们。他们落荒而逃，逃得那么彻底。 老师闻讯，拿起了酒杯，向舞台赶去。天才们旧气难言，拿起了自制的化学炸药，向富二代的车赶去。老师将酒水泼向校花，门外传来雷鸣般的爆炸。这一刻，老师的梦想毁了，天才们的前途毁了，然而，世界依然有活力地在转，一如既往。 然而，老师仍心怀希望，尽力将此事最小化解决。这边，王大法作为被开除的学生被家人拖走，那边，吴未望向楼上的橱窗，老师站在橱窗望着吴未。这一刻，吴未明白，自己的价值将要发挥了。就这样，吴未顶替其他天才们而被学校开除。 奔驰的归家车上，吴未哭的撕心裂肺，将自己仅有的一枚荣誉勋章扔向窗外，像扔去回忆一样。身后周兰，方厚政，迈克，追的精疲力尽，他们将过去的笔记本扔向追不上的公交车，像追随友谊一样。 最终，天才们并没有解出题，也没有改变世界，但他们最终都找到了自己的方向。周知庸老师最后没能实现自己的天才梦，也丢掉了工作，像人间蒸发一样，随旧时代而去，但他却找到了自己的人生伴侣。吴未，平淡无味，但又快乐的漂浮着。 这部影片最大的亮点就在于其真实性。首先，少年班的故事从1978年起一直延续着。然而，随着时代的发展，如今的少年班已不复存在了。旧时代里，时代的推进是由天才们推进的，这就是为何周知庸老师为何执着于天才的原因之一。就像他说的，“高斯十七岁就发现了第二相反定理，这些天才当时他们不敢发表，因为怕人们不信。”因为这种理念的支撑，让他对所有平凡人带上了有色眼镜，以至于四十多岁依旧单身。然而，过去毕竟是过去，世界上有很多天才，但只有一个高斯，只有一个牛顿，只有一个爱因斯坦。牛顿他们所带表的这类基础科学并不是一个人所完成的，它需要所处时代的支持以及现有技术的支撑，就像牛顿自己也说过，自己是站在巨人肩膀上的，况且牛顿从未说过自己是天才，自己只是热爱探索而已，因此，想要天才改变世界的周知庸老师从一开始就错了，因为他不懂平凡人的价值，所以，他没有牛顿的成就，与牛顿唯一的共同点就是一直单身。世界是一个多元化的世界，不只是理论的世界，如果说基础科学是时代质的飞跃，那应用科学就是时代量的积累、倘若基础科学离开了应用科学，那么世界依旧停滞不前，基础科学反而成为了最没用的东西。故事的结尾，天才们并没有从事科研工作，而是选择了自己所喜欢的岗位，他们没有改变世界，只是生活的比平凡人更潇洒。平凡与天赋，其实离开谁都不行，正是因为天才们的研发，广大平凡的劳动者的坚持工作与制作，才使得这个世界不断推进向前。 然而，少年班不适宜于当下最主要的原因还是心智的为题。尽管天才们智商超群，但是年纪与经历更重要。十几岁就步入大学校门，尽管他们智商达标了，但心智并未达标。电影中表现的淋淋尽致。他们从未接触过社会，也并不懂得什么是责任，当然，那个时代的我们都一样，在心智上，人人都是平等的。我们就来分析一下各个主人公吧。 首先是主人公方厚政。作为年纪最小的天才，他的心情，性格，全都写在了脸上。目测智商150，心理年龄只有9岁。遇到委屈就哭，遇到自己看不上的事就挖苦，总之这个世界上只有自己是最厉害的，当面对丰富多彩的大学生活，他又怎会抵挡住各种各样的新鲜事物而去专心钻研呢。主人公迈克，看似成熟，其实心智同样幼稚，面对所有事第一个想到的就是用拳头来解决，从不会考虑后果。主人公王大法自由散漫，每天吃着馒头，听着经文，一副玩世不恭的样子。主人公周兰，可以说是所有优秀的女孩的代表，可以说是比较正常的一个，但正处于花季年纪的她并不适合大学生活，成绩优异不懂打扮的她让人只能敬而远之。尽管是天才，但是如今的大学并不只是学习知识的地方，如果说初中是每个人最会做梦的年纪，高中洋溢着每个人最具浓厚的青春，走向社会是一个人成长为打人的标志，那么大学时代则是每一个人从孩子长成大人的过度期，因此嚷处于做梦年纪的孩子直接去面向社会的残酷未免太过残忍。 校花江依琳可谓是剧中较完美的一个人，他承载着天才们对女性最完美的幻想。她可以说是剧中EQ最高的一位。尽管他是天才们放弃比赛的导火线，但是天才们又有几个真正懂得感情呢。她对方厚政的感情其实就是姐姐对弟弟的照顾，而对于心智只有9岁的方厚政来说，又怎会冬的何谓男女之情呢。方厚政对待像话的感觉也不过是弟弟对大姐姐的仰慕之情。王大法测试时便已说过他所期望的爱情是门当户对，显然校花并不是他所期待的人，因此他对校花的感情量自己都不会说清楚。至于迈克，校花也许的确对迈克有点好感，但迈克显然给不了校花幸福，首先，迈克并不知道什么是责任，测试时便已清楚他的情绪宣泄是暴力，倘若青春期那股passion磨灭了，后果自行脑补。其次迈克给不了校花真正需要的。之所以前期近似完美的校花最后会有那么一出戏，其实很容易看出的。江依琳需要一场舞蹈独秀以支撑日后的发展，身为天才的少年们有谁能给呢，因此江依琳选择了富家公子哥，这都是情理之中。而此时的天才们只顾自己的感受，仗着长久以来老师的庇护去炸车。所以，当看到周知庸老师泼江依琳水时，我倒有点替校花感到冤枉，自己争取来的前途就因为接近了天才们而被老师给毁了。而周老师之所以泼水，也许是曾经旧时代里被戏弄过，旧火新火全发泄在了江依琳身上。 周知庸老师，典型旧时代的人，因为自己未能拿奖的遗憾，而把希望寄托在新时代的少年天才们身上。也许努力学习没有错，但他忽略了当今世界已不是简简单单努力学习就能改变的了。当一个人不愿接受新时代时，他已经被这个时代所遗弃，成为旧时代的古董。当他最后不在从事教育事业，专心于交际时，此刻的他应该是幸福的。 不过，周老师错了吗，没人能说他错了。至少20多年来，他一直秉持着初心，坚守着梦想，对于现代人来说，这一点是多么的可贵呢。社会这个大染缸将每一个青春期怀穿着梦想的少年少女染成形形色色为生活而忙碌的机器，又有几个人能站出来说我要改变这个世界呢。我感觉说这话的人并不丢人，反而是那些早已面目全非的人让人可悲。 不知不觉，恭喜我又成功把我给绕进去了。我竟然有分不清自己的立场了，呵呵。不过不论什么样的人，坚持做好自己就好。正处于大学生活的我们，无论何时都要坚持自己的梦想，不必在意那些圆滑的人说你不够圆滑，不必在意那些所谓成熟的人说你不够成熟，不要照原样接受别人的生活。选择坚守，选择理想，选择倾听自己内心深处的呼唤。因为在这个充满怀疑的世界，我们依旧需要梦想。]]></content>
      <categories>
        <category>心路历程</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回忆若一指流沙，散落了谁的风华]]></title>
    <url>%2F2018%2F06%2F11%2F2018-06-11%2F</url>
    <content type="text"><![CDATA[宁静的夏天，天空中繁星点点。带上浓浓的睡意与滴滴答答的雨点，我们踏上了前往宁夏的航线。凌晨五点半，我们在的闹钟呼唤下出发了。 后天，同样的时间，宁夏理工学院，我们要比赛。伴着飞机超重又失重的压抑，我知道，起飞了。望着机窗外一览众山小的风景，顿时有一种憧憬，又有一种壮志凌云。 在宁夏，没有高楼大厦，但远处的山峰鳞次栉比。没有车水马龙，但广阔的天空一碧如洗。一切都安顿好之后，我们便奔向当地特色小吃而去。宁夏理工学院，坐落在湖心的一座岛屿之上，可以说，一座岛屿即一座城。很快我们便摸不清方向了。此时，一个小姐姐跑过来跟我们搭讪。由于比赛都发的队服，很是显眼，显然，她是被我们的队服吸引而来的。就这样莫名其妙的，我们渐渐熟悉。在她的带领下，我们逛了校园，逛了小吃摊…… 宁夏昼长夜短，即使到了晚上八九点，天依然为褪色。就这样逛着逛着，吃着吃着，天就黑了，当我们看时间时，已是十点多了。我们留下了联系方式，各自归宿。 第2天，宁夏理工学院组织我们所有参赛者一起去旅游，地点是沙湖，即沙漠中的一片绿洲。我们队和昨天的小姐姐约好今天一起游玩，而我们队刚好缺了一个教练，就这样理所当然的，她以我们教练的身份一起踏上了沙漠的旅程。 一路上，我们划过了湖泊，翻过了沙漠，跨过了沙丘，因为她的出现，在她的陪伴下，我们的旅程不再显得单调乏味。在沙漠中，偶然发现某片沙地里满是荆棘，当跨过荆棘之后，望到了一片花海。尽管花在强烈的阳光下已奄奄一息，然而它们仿佛在用生命证明自己存在的意义。同伴们纷纷前往亭下避暑，只有我守着安静的沙漠，等待着花开。 第3天，终于要比赛了。经过了上一次失败的经验，这次尽管最后一次提交因为时间到了没有提交成功，不过好在前两个半小时成功A了3道题，我们队最终斩获一枚铜奖，也算是这么多月的训练也算有了一个回报。 临别时，小姐姐教练来为我们送行，并带来当地的特产。因为赶飞机，我们草草照相留念之后，便踏上了返程的飞机。 戴上耳机，梳理着三天的回忆。其实我们每个人来到这个世界上，就只能义无反顾的前进。在人生的道路上，除了自己，其他人都只能伴我们走过一程。这一程，或长或短，也许转瞬已尽，也许直通彼岸，但永远不会是永远。当走完这一程，余下的路需由自己来走完。然而不必逗留着，因为每时每刻，都会有新的过客伴你走过新的一程。尽管离别之后，我们可能会永远不见，但彼此走过的那份欢乐，永远藏在心里。 谢谢你伴我们走过这三天，也许今后永远不会再见，但我们走过的那段旅程以及旅程中的你我永远不会失散。]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API函数配置读写文件]]></title>
    <url>%2F2018%2F06%2F03%2F2018-06-03%2F</url>
    <content type="text"><![CDATA[cfg_op.h 1234567891011#pragma once#ifdef __cplusplusextern &quot;C&quot; &#123;#endif //获取配置项 int GetCfgItem(char *pFileName/*in*/, char*pKey/*in*/, char *pValue/*in out*/, int *pValueLen/*out*/); //写配置项 int WriteCfgItem(char*pFileName/*in*/, char *pKey/*in*/, char *pValue/*in*/, int *ValueLen/*in*/);#ifdef __cplusplus&#125;#endif cfg_op.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#define Maxline 2048extern &quot;C&quot; &#123; int GetCfgItem(char *pFileName, char*pKey, char *pValue, int *pValueLen) &#123; int ret = 0; FILE *fp = NULL; char lineBuf[Maxline]; char *pTmp = NULL, *pEnd = NULL, *pBegin = NULL; fp = fopen(pFileName, &quot;r&quot;); if (fp == NULL) &#123; ret = -1; return ret; &#125; while (!feof(fp)) &#123; memset(lineBuf, 0, sizeof(lineBuf)); fgets(lineBuf, Maxline, fp); printf(&quot;lineBuf:%s &quot;, lineBuf); pTmp = strchr(lineBuf, &apos;=&apos;); if (pTmp == NULL) &#123; //没有=号 continue; &#125; pTmp = strstr(lineBuf, pKey); if (pTmp == NULL) &#123; //判断key是不是在//所在行 是不是有key continue; &#125; pTmp = pTmp + strlen(pKey); // mykey1 = myvalue11111111==&gt;&quot;myvalue11111111&quot; pTmp = strchr(pTmp, &apos;=&apos;); if (pTmp == NULL) &#123; //判断所在行是不是有key continue; &#125; pTmp++; printf(&quot;pTmp:%s &quot;, pTmp); //获取value起点 while (1) &#123; if (*pTmp == &apos; &apos;) &#123; pTmp++; &#125; else &#123; pBegin = pTmp; if (*pBegin == &apos;\n&apos;) &#123; //没有配置value printf(&quot;配置项:%s 没有配置value \n&quot;, pKey); goto End; &#125; break; &#125; &#125; //获取value结束点 while (1) &#123; if (*pTmp == &apos; &apos; || *pTmp == &apos;\n&apos;) &#123; break; &#125; else &#123; pTmp++; &#125; &#125; pEnd = pTmp; //赋值 *pValueLen = pEnd - pBegin; memcpy(pValue, pBegin, pEnd - pBegin); &#125; End: if (fp == NULL) fclose(fp); return ret; &#125; int WriteCfgItem(char*pFileName, char *pKey, char *pValue, int *ValueLen) &#123; int rv = 0, iTag = 0, length = 0; FILE *fp = NULL; char lineBuf[Maxline]; char *pTmp = NULL, *pBegin = NULL, *pEnd = NULL; char filebuf[1024 * 8] = &#123; 0 &#125;; if (pFileName == NULL || pKey == NULL || pValue == NULL) &#123; rv = -1; printf(&quot;SetCfgItem() err. param err \n&quot;); goto End; &#125; fp = fopen(pFileName, &quot;r+&quot;); if (fp == NULL) &#123; rv = -2; printf(&quot;fopen() err.\n&quot;); &#125; if (fp == NULL) &#123; fp = fopen(pFileName, &quot;w+t&quot;); if (fp == NULL) &#123; rv = -3; printf(&quot;fopen() err.\n&quot;); goto End; &#125; &#125; fseek(fp, 0L, SEEK_END);//把文件指针从0位置开始，移动到文件末尾 //获取文件长度 length = ftell(fp); fseek(fp, 0L, SEEK_SET); if (length &gt; 1024 * 8) &#123; rv = -3; printf(&quot;文件超过1024*8,nunsupport&quot;); goto End; &#125; while (!feof(fp)) &#123; //读每一行 memset(lineBuf, 0, sizeof(lineBuf)); pTmp = fgets(lineBuf, Maxline, fp); if (pTmp == NULL) &#123; break; &#125; //key关键字是否在本行 pTmp = strstr(lineBuf, pKey); if (pTmp == NULL)//key关键字不在本行，copy到filebuf中 &#123; strcat(filebuf, lineBuf); continue; &#125; else//key关键字在本行中，替换旧的行，再copy到filebuf中 &#123; sprintf(lineBuf, &quot;%s = %s\n&quot;, pKey, pValue); strcat(filebuf, lineBuf); //若存在key iTag = 1; &#125; &#125; //若key关键字，不存在 追加 if (iTag == 0) &#123; fprintf(fp, &quot;%s = %s\n&quot;, pKey, pValue); &#125; else &#123;//若key关键字，存在，则重新创建文件 if (fp != NULL) &#123; fclose(fp); fp = NULL;//避免野指针 &#125; fp = fopen(pFileName, &quot;w+t&quot;); if (fp == NULL) &#123; rv = -4; printf(&quot;fopen() err.\n&quot;); goto End; &#125; fputs(filebuf, fp); &#125; End: if (fp != NULL) &#123; fclose(fp); &#125; return rv; &#125;&#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define _CRT_SECURE_NO_WARNINGS#include&quot;cfg_op.h&quot;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define CFGNAME &quot;d:/mycfg.ini&quot;//读配置项int GetCfg() &#123; int ret = 0; char name[1024] = &#123; 0 &#125;; char value[1024] = &#123; 0 &#125;; int vlen = 0; printf(&quot;\n请输入Key:&quot;); scanf(&quot;%s&quot;, name); ret = GetCfgItem(CFGNAME, name, value, &amp;vlen); if (ret != 0) &#123; printf(&quot;func GetCfgItem err:%d \n&quot;, ret); return ret; &#125; printf(&quot;value:%s \n&quot;); return ret;&#125;//写配置项int TWriteCfg() &#123; int ret = 0; char name[1024] = &#123; 0 &#125;; char value[1024] = &#123; 0 &#125;; int vlen = 0; printf(&quot;\n请输入Key:&quot;); scanf(&quot;%s&quot;, name); printf(&quot;\n请输入Value:&quot;); scanf(&quot;%s&quot;, value); WriteCfgItem(CFGNAME, name, value, &amp;vlen); if (ret != 0) &#123; printf(&quot;func WriteCfgItem err:%d \n&quot;, ret); return ret; &#125; printf(&quot;您的输入是：%s = %s \n&quot;, name, value); return ret;&#125;void show_menu() &#123; printf(&quot;==========================\n&quot;); printf(&quot;1.测试写配置文件\n&quot;); printf(&quot;2.测试读配置文件\n&quot;); printf(&quot;0.退出\n&quot;); printf(&quot;==========================\n&quot;);&#125;int main() &#123; int choice; show_menu(); while (~scanf(&quot;%d&quot;, &amp;choice)) &#123; //显示一个菜单 switch (choice) &#123; case 1: TWriteCfg(); break; case 2: GetCfg(); break; default: exit(0); &#125; system(&quot;pause&quot;); system(&quot;cls&quot;); show_menu(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>文件</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>API函数</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客训练赛19之托米专场]]></title>
    <url>%2F2018%2F06%2F01%2F2018-06-01%2F</url>
    <content type="text"><![CDATA[托米的简单表示法题目描述 作为故事主角的托米是一名老师。 一天，他正在为解析算术表达式的课程准备课件。 在课程的第一部分，他只想专注于解析括号。 他为他的学生发明了一个有趣的正确括号序列的几何表示，如下图所示: 几何表示的定义： 1. 对于一个括号序列A，我们定义g(A)是A的几何表示形式,则 “()”的表示是一个1*1的方块，高度为1; 2.对于一个括号序列A，”(A)”的表示是由一个比g(A)宽2个单位高1个单位的矩形包围g(A)，它的高度为A+1; 3.对于两个括号序列A和B，A+B的几何表示形式为把g(B)放置在g(A)右边的一个单位，且高度为A和B的高度的较大值。 其中+指的是字符串的连接符。 ​ 在完成课件后，托米老师开始玩他做好的图片。 他将图像的有限区域交替地涂成黑色和白色，使最外面的区域全部涂成黑色。 对于上面的例子，这个着色如下所示： 输入描述:123输入的第一行包含一个整数T，表示指定测试用例的数量。每个测试用例前面都有一个空白行。每个测试用例由一个合法括号序列组成。 每行只包含字符&apos;(&apos;和&apos;)&apos;。 输出描述:1对于每个测试用例，输出一行包含一个整数,表示相应几何表示的黑色部分的面积。 示例1 输入复制 123452((()))(())(()(())) 输出复制 121020 说明1第二个测试案例是上图中显示的案例。 备注:121≤T≤10一个合法括号序列长度≤4 x 105 题解这道题提交了好多次，一直WA。后来改成long long就过了。原理很简单，就是遇见左括号入栈，遇见右括号出栈。在入栈出栈时执行操作。先入栈的高度比后入栈的最高高度要高1，初始宽度为1，每执行一次出栈操作，出栈元素前一个元素的宽度等于他自身宽度加上出栈元素宽度再加1。而出栈元素的面积等于宽乘高减去包含元素的面积。就这样，每次出栈时，前一个元素宽度加上该元素宽度加1，前元素将要减去的面积area等于出栈元素的面积minu。而出栈元素的面积area等于高乘宽减去将要减去的面积minu。最终由于0位置没有面积，就是全域，那他的minu即将要减去的面积就是总面积。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 200010;char str[maxn*2];ll high[maxn],wed[maxn],area[maxn],minu[maxn],mystack[maxn];ll fun()&#123; int cnt = 1,head = 1,tail = 1,len = strlen(str); memset(high,0,sizeof(high)); memset(wed,0,sizeof(wed)); memset(minu,0,sizeof(minu)); memset(mystack,0,sizeof(mystack)); for(int i = 0;i &lt; len;i++)&#123; if(str[i] == &apos;(&apos;)&#123; mystack[tail++]=cnt++; high[mystack[tail - 1]]++; wed[mystack[tail - 1]] = 1; if(high[mystack[tail - 2]] &lt;= high[mystack[tail - 1]]) high[mystack[tail - 2]] = high[mystack[tail - 1]] + 1; &#125; else if(str[i] == &apos;)&apos;)&#123; if(tail &gt; 1)&#123; if(high[mystack[tail-2]] &lt;= high[mystack[tail-1]]) high[mystack[tail-2]] = high[mystack[tail-1]] + 1; tail--; wed[mystack[tail - 1]] += wed[mystack[tail]] + 1; area[mystack[tail]] = wed[mystack[tail]] * high[mystack[tail]] - minu[mystack[tail]]; minu[mystack[tail - 1]] += area[mystack[tail]]; &#125; &#125; &#125; return minu[0];&#125;int main()&#123; int T; cin &gt;&gt; T; while(T--)&#123; scanf(&quot;%s&quot;,str); cout &lt;&lt; fun() &lt;&lt; endl; &#125; return 0;&#125; 托米的饮料题目描述 好了，现在是小托米的故事啦~~~ 可爱的小托米得到了n瓶饮料. 但他不小心把开盖的工具弄丢了,所以他只能利用饮料瓶来开盖. 已知第i个瓶子的品牌为a i ,且其能打开b i 品牌的瓶子. 问有几瓶饮料托米无法喝到. 被用于打开饮料瓶的瓶子不一定需要被打开. 一个瓶子不能打开其本身. 输入描述:12第一行一个整数n,表示饮料的瓶数.接下来n行,每行两个整数ai,bi. 输出描述:1输出一行一个整数,表示小托米无法喝到的饮料瓶数. 示例1 输入复制 1234541 12 23 34 4 输出复制 14 示例2 输入复制 1234541 22 33 44 1 输出复制 10 备注:121≤n≤1001≤ ai,bi≤ 1000 题解本题坑人之处在于理解题意。因为没理解题意导致提交了好多次才提交成功。本题实质很简单，就是每个瓶子对应有一个编号b，可以开这个编号b除了自己以外的所有的瓶子。但仅限于该瓶子，其他瓶子也只能执行自己的编号b。首先输入完成时记录下所有编号的瓶子个数，把n赋给瓶子个数cnt，因为一开始n个瓶子都没打开。接着对b按顺序进行遍历，如果对应编号的瓶子不存在，则不执行操作，否则接着判断，如果a和b不同，则cnt减去该瓶子的数量，然后数量置零，因为该类瓶子已经打开完了，之后不需要再打开，否则执行完操作后再加1，因为不能打开自己。最后cnt就是剩下没打开的数量。 代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int vis[1010]=&#123;0&#125;,a[1010],b[1010];int main()&#123; int n; cin&gt;&gt;n; int cnt = n; for(int i = 1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; vis[a[i]]++; &#125; for(int i = 1;i&lt;=n;i++)&#123; if(vis[b[i]])&#123; cnt-=vis[b[i]]; vis[b[i]]=0; if(a[i]==b[i])&#123; cnt++; vis[b[i]]=1; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 托米搭积木题目描述 小托米真的很可爱呀(&gt;_&lt;) 这天,可爱的小托米得到了n堆积木,且第i堆积木初始时有ai块积木. 输入描述:1234567第一行两个整数n,m.第二行n个整数,第i个整数代表ai的值.接下来m行,每行代表一个操作:第一个整数t代表操作的类型若t=1,则接下来两个整数v,x,代表操作1.若t=2,则接下来一个整数y,代表操作2.若t=3,则接下来一个整数q,代表操作3. 输出描述:1对于每个操作3,输出其对应的答案. 示例1 输入复制 1234567891011121310 111 2 3 4 5 6 7 8 9 103 23 92 103 13 101 1 102 102 103 13 103 9 输出复制 1234567291120304039 备注:1234561≤n,m≤ 1051≤ai≤1091≤t≤31≤v≤ n,1≤ x≤1091≤y≤1041≤q≤n 题解很简单的一道题，3种操作，第1操作是把第i位置的数该为另一个数x，第2个操作是所有数加v，第3个操作是查询某一位置的数。首先分析，第1种操作和第3种操作时间复杂度都是O(1),第2中操作如果每位加v的话时间复杂度O(n)。所以优化在于第2操作。不过对于此操作我们可以降维优化，因为是所有数都加v，那么我们只需把v记录下来，每次查询时对查询的数直接加v就行了。这样就又遇到了一个问题，就是假如所有的数现在的状态是加v，而i位置元素现在变成了x，这样就会造成所有元素相加不一致。解决也很简单，只需每次变成x后，给x减去v就行了，这样查询时再加上v结果并没变。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int m,n;int a[100010], cnt;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int t,x,y; cnt=0; while(m--)&#123; cin&gt;&gt;t; if(t==3)&#123; cin&gt;&gt;x; cout&lt;&lt;a[x]+cnt&lt;&lt;endl; &#125; else if(t==2)&#123; cin&gt;&gt;x; cnt+=x; &#125; else if(t==1)&#123; cin&gt;&gt;x&gt;&gt;y; a[x]=y; a[x]-=cnt; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[心路历程]心境决定处境，心界决定眼界]]></title>
    <url>%2F2018%2F05%2F31%2F2018-05-31%2F</url>
    <content type="text"><![CDATA[有时候，人们会因为看到别人取得的成就而感到迷茫。假如你身处此境，你往往会失去思考，失去冷静，忘记自己所走过的道路，忽略即将要走的路，从而打乱了最初的计划，进而迷失方向，愈发迷惘。这种感觉就像走在路上的你忽然掉进了水里，快要淹死的感觉。也许彼岸就在不远处，你只需游几步就能上岸，但此刻的你并没有精力寻找彼岸的方向，因为你的心思全放在了如何不被突如其来的大水淹没，于是你拼命的寻找救命稻草，以阻止自己下沉。就这样，在慌乱的过程中，阻止了你上岸的步伐。 假如一开始你没有目标，那么此时这种状态并非坏事。因为当你在水里抓住救命稻草之后，会寻找彼岸的方向。如果你足够冷静，此刻你会总结你和他的差距在哪里，从而为自己确立目标，并参考他的经历为自己制定计划。如果你不够冷静，那此时你也许会照搬别人的做法，以别人的目标为自己的目标。这样也许会走很多弯路，做许多无用功，但至少比之前毫无目标浑浑噩噩要好得多，同时这段经历也会成为你如何成长道路上的一比财富。 倘若你一开始就有自己的目标，有属于自己的彼岸，而当你看到有人已经走到人生的彼岸时，你会怀疑自己走过的路，即使彼岸就在前方，你也会动摇，因为你还没有到达彼岸，没有见过彼岸的风景。假如此时的你停下脚步眺望对方的彼岸，那无疑是致命的。它就像突如其来的潮水，可能会拖延了你前行的道路，更有可能会动摇你前行路上的决心，甚至改变你前进的方向。 我有一个计算机系的舍友，他的目标是考研。自大一以来一直成绩优异，大二时便已轻松通过四六级，而且交际甚广，可谓前程平坦，身边阳光明媚。但此时，某人给他发了一个自己做的贺卡程序，看起来挺酷，此时他开始动摇了。因为自进校以来同学们一直都是面对黑窗口敲代码，敲出来的也是黑窗口，从来没有想过有人能够编出应用来。他说，当他收到那份礼物时，心中交错的并不是喜悦，而是迷惘。就好像春天的果树看着繁花满庭，而自己却总是开不出花，便开始抱怨自己的价值，而忘记了自己的果实要等到秋天才能品尝。于是当他看到别人已经拥有了强大的实力并且取得相应的成果，而自己还停留在课本中的C语言基础知识，不会应用，顿时思绪万千，怀疑自己走的道路，怀疑学校的课程安排。那种感觉，就像走着走着掉进水里一样。 此时，他拼命的寻找救命稻草。终于，他抓到了第一根救命稻草。他开始跟着别人做项目，一起写程序，别人打比赛，他便开始模拟比赛。在这段时间，他感到生活变得充实，做事也有动力，因为他也想拥有像那个人一样的实力，像那个人一样去打比赛。但正当他感觉找到目标时，选拔结果出来了，正式比赛的名额没有他，他落选了。此时的他顿时感觉自己又失去了方向。于是他又开始寻找救命稻草。他抓到的第二根救命稻草是校外的编程培训班。于是他果断交了大笔费用去报了培训班。在培训班里，他又燃起了希望，因为在这里，老师讲的一些东西都是课本上所没有的，老师还经常在课堂上带他们写一些小应用，这些都是他们以前不曾经历过的。由于这种模式以前没有接触过，所以便对学的东西燃起了兴趣，即使一切都是从头开始学习，即使许多东西以前都学过。就这样过了两个月，当他冷静下来，重新审视自己时，才发现自己真正要走的路的还是考研，而这段时间所学的技术只是就业路上的一个工具。而培训班中的许多东西其实学校的课程里都有，只是他从未重视过，没接触过的东西未来也会学习。就这样，他又开始了最初的考研复习之路。 那么，当我们在前行的路上看到别人已经到达人生的彼岸或者接近人生的彼岸时该怎么办呢。 其实，一个人的心境决定了这个人的处境。假如心中拥抱黑暗，那么眼之所见也会变得暗淡。即使前程平坦，阳光盎然，你也望不见人生的彼岸。假如心中充满光明，那么黑夜也会为你亮起星光。即使道路坎坷，前程黑暗，你也会收获自信坚定向前。 以我为例，记得之前比赛失利，没有获奖，而朋友却在其他项目中表现优异，此时的我就像《三体》中经历水滴之战惨败而侥幸逃跑的舰队队长一样，当看到章北海率领的舰队未雨绸缪时，眼前是一片黑暗，不由自主地感叹:”好黑，真tm的黑啊”。此刻的我早已迷失了方向，整日思绪想的是同样是付出，朋友们一个个却硕果累累，而我却像墙角的蘑菇怎么也沐浴不到阳光。为了这场比赛，准备了一个多月，那段时间翘了许多节课，一心研究算法，而最后连个证明自己这段时间的成果都没有。眼前面临的是各种各样的考试，以及英语四级考试，顿时怀疑自己之前的付出是否值得。其实在不久之后又有一次比赛，而此时的我却整日处于悲观之中，害怕下次比赛同样拿不到成绩，害怕考试失利，害怕英语四级。此刻的我，感到人人都各有所长，就只有自己一直处于失败当中，人人都比我成功。于是我把自己包裹起来，不喜欢与人交流，感觉每个人都很虚伪，从此变得越来越冷漠。就这样，我一边准备比赛，一边疯狂复习，一边孤独，一边迷惘。由于同时选择多种方向，最终也一事无成。马上就要比赛了，此刻的我偶然间望见教室的窗外阳光依旧明媚，回忆起之前努力奋斗的日子里也是同样的阳光，望着这从未消逝的阳光，我重新总结了一下这段时间的经历，终于明白，其实阳光很好，世界很好，所有人都很好，只是我的心态变得暗淡了。当我重新投入到阳光灿烂的日子里，此时发现，其实许多人都在羡慕我。尽管我没有拿到奖，但这段时间我的实力已经突飞猛进。虽然我没有收获奖杯，但我却收获了成长，坚定了方向。 所以，心界决定了眼界。当你凝视黑暗的时候，黑暗也在呼唤着你。倘若一个人心中见不到光，那么对他而言，整个世界都是黑暗的。当看到别人取得的成就时，只会是羡慕嫉妒恨，自怨自艾。也许有人会说，悲观，是一种远见。但当一个人始终以悲观的态度看待世界，那么所看到的整个世界只剩下冷漠，背叛，黑暗，而你收获的也只有孤独，失望，迷茫。 不妨敞开心扉，让阳光渗透到我们的心中。此时你会发现，当你看到别人的成就时，更多的是送去祝福，而不是怀疑自己。这样，就不会迷失方向，同时别人的经历中总结经验，化作自己前行的垫脚石。 阳光很好，我亦很好，整个世界更好。]]></content>
      <categories>
        <category>心路历程</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++结构体中的深copy和浅copy&&结构体偏移量的两种求法]]></title>
    <url>%2F2018%2F05%2F30%2F2018-05-30%2F</url>
    <content type="text"><![CDATA[浅copy：编译器仅仅拷贝了结构体的值，而没有创建新的内存空间，而是共享同一块内存空间。当结构体成员中含有Buf的时候，拷贝之后释放内存就不会出现问题。但是如果结构体中含有指针变量的时候，编译器只会copy指针变量，而对应的内存空间却不会缺不再多分配。 代码： 1234567891011121314151617181920212223242526272829303132333435#define _CRT_SECUFE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct note &#123; char a[64]; int b; char*c;&#125;note;void my_copy(note*from, note*to) &#123; *to = *from; //memcpy(to,from,sizeof(note));//和上述操作等效&#125;int main() &#123; note d, e; strcpy(d.a, &quot;123&quot;); d.b = 456; while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL) exit(1); strcpy(d.c, &quot;789&quot;); printf(&quot;d的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c); my_copy(&amp;d, &amp;e); printf(&quot;e的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c); if (d.c != NULL) &#123; free(d.c); d.c = NULL; &#125; if (e.c != NULL) &#123; free(e.c); e.c = NULL; &#125; return 0;&#125; 以此样例为例，输出结果为： 12345678d的值为：123456789e的值为：123456789 然后接着某些编译器如vs的编译器就会报错。出错位置为 1234if (e.c != NULL) &#123; free(e.c); e.c = NULL; &#125; 这是由于将结构体d内存元素直接赋给结构体e时，即进行 e= d操作时，由于结构体中含有指针元素，d结构体中的指针已经动态分配内存，而操作完成之后e中指针的值也会写上d动态分配内存的地址，因此d和e指向同一内存空间。这样当d中指针d.c释放内存之后，由于e.c仍然指向该部分内存，而不指向空，此时会强制释放掉e.c所指向内存，由于此处内存已经释放过了，处于不能被访问状态，而e.c又强制释放该内存，就会造成vs编译器报错。这就是前copy的弊端。 深copy：编译器会为拷贝的对象分配一定的内存空间。 以上述代码为例，只需在进行 e= d操作之后再为e.c重新分配内存，然后执行strcpy(e,d)即可。这样e.c和d.c分别指向两块不同的内存，这样就不会出现上面那种错误。 代码: 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECUFE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct note &#123; char a[64]; int b; char*c;&#125;note;void my_copy(note*from, note*to) &#123; *to = *from; //memcpy(to,from,sizeof(note));//和上述操作等效 while ((to-&gt;c = (char*)malloc(64 * sizeof(char))) == NULL) exit(1); strcpy(to-&gt;c, from-&gt;c);&#125;int main() &#123; note d, e; strcpy(d.a, &quot;123&quot;); d.b = 456; while ((d.c = (char*)malloc(64 * sizeof(char))) == NULL) exit(1); strcpy(d.c, &quot;789&quot;); printf(&quot;d的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, d.a, d.b, d.c); my_copy(&amp;d, &amp;e); printf(&quot;e的值为：\n&quot;); printf(&quot;%s\n%d\n%s\n&quot;, e.a, e.b, e.c); if (d.c != NULL) &#123; free(d.c); d.c = NULL; &#125; if (e.c != NULL) &#123; free(e.c); e.c = NULL; &#125; return 0;&#125; 偏移量的求法123456struct note&#123; char name[64]; int age; int sex;&#125;a,*p;p=&amp;a; 以p为例求p-&gt;age偏移量 直接法1int offsize = (int)&amp;(p-&gt;age)-(int)p; 间接法1int offsize = (int)&amp;(((*note)0)-&gt;age);]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于模拟或暴力类型题的时间复杂度降维优化举例]]></title>
    <url>%2F2018%2F05%2F29%2F2018-05-29%2F</url>
    <content type="text"><![CDATA[首先，一般的模拟类型的题如果按照题面做一般就入坑了。因为此类题如果按照题面一步一步模拟，那时间复杂度会相当大，如果此模拟题数据不是很水，一般都不会通过，所以时间复杂度至少要降维处理。而模拟题一般的做法是推导，把模拟的过程推成一个公式，而公式的时间复杂度为常数，即O(1),即实现由0(…)0(N)-&gt;0(…)0(1)的降维过程。但推导公式往往是一件很麻烦的事情，因此推导公式是模拟类题的关键。以下两道题原本是用模拟或暴力来解决，但其实它们都是可以优化的，例如第一题只需要求周期内的数与周期即可，不用遍历全部数，第2题只需对该数n进行分析即可，时间复杂度0(1)，不用从1遍历到n一个个进行统计。 斐波那契数列百度熊对数学一直都非常感兴趣。最近在学习斐波那契数列的它，向你展示了一个数字串，它称之为“斐波那契”串： 1 111235813471123581347112358… 聪明的你当然一眼就看出了这个串是这么构造的： 先写下两位在0~9范围内的数字a, b，构成串ab； 取串最后的两位数字相加，将和写在串的最后面。 上面百度熊向你展示的串就是取a = b = 1构造出来的串。 显然，步骤1之后不停地进行步骤2，数字串可以无限扩展。现在，百度熊希望知道串的第n位是什么数字。 输入数据的第一行为一个整数T（1 ≤ T ≤1000）, 表示有T组测试数据；每组测试数据为三个正整数a, b, n（0 ≤ a, b &lt; 10, 0 &lt; n ≤109）。 对于每组测试数据，输出一行“Case #c: ans”（不包含引号） c是测试数据的组数，从1开始。 提示： 对于第一、二组数据，串为112358134711235… 对于第三组数据，串为14591459145914… 样例输入123431 1 21 1 81 4 8 样例输出123Case #1: 1Case #2: 3Case #3: 9 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500;int t, c, d, n, cyc, cnt;int a[maxn], vis[maxn];int init()&#123; memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis)); a[1] = c; a[2] = d; cnt = 2; while(!vis[a[cnt-1]*10+a[cnt-0]])&#123; vis[a[cnt-1]*10+a[cnt]] = cnt; int tmp = a[cnt-1] + a[cnt]; if(tmp&lt;10) a[++cnt]=tmp; else&#123; a[++cnt]=tmp/10; a[++cnt]=tmp%10; &#125; &#125; return vis[a[cnt-1]*10+a[cnt]];&#125;int main()&#123; cin&gt;&gt;t; for(int i = 1;i&lt;=t;i++)&#123; cin &gt;&gt; c &gt;&gt; d &gt;&gt; n; int res = init(); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i&lt;&lt;&quot;: &quot;; if(cnt&gt;=n) cout&lt;&lt;a[n]&lt;&lt;endl; else cout&lt;&lt;a[res+(n-res)%(cnt-res)]&lt;&lt;endl; &#125; return 0;&#125; 计数问题试计算在区间 11 到 nn 的所有整数中，数字 xx（0 \leq x \leq 90≤x≤9）共出现了多少次？例如，在 11 到 1111 中，即在 11、22、33、44、55、66、77、88、99、1010、1111 中，数字 11 出现了 4 次。 输入格式输入共 1 行，包含 2 个整数 nn、xx，之间用一个空格隔开。 输出格式输出共 1 行，包含一个整数，表示 xx 出现的次数。 数据规模与约定对于 100% 的数据，1 \leq n \leq 1,000,0001≤n≤1,000,000，0 \leq x \leq 90≤x≤9。 忽略每行输出的末尾多余空格 样例输入111 1 样例输出14 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n, x;int main()&#123; cin&gt;&gt;n&gt;&gt;x; int cnt = 0, res = 1, re = 1; int tmp = n; if(x)&#123; while(tmp)&#123; int mod = tmp%10; cnt+=(res-re)/10*mod; if(mod&gt;x) cnt+=re; else if(mod==x) cnt+=n%re+1; re*=10; res*=10; res+=re; tmp/=10; &#125; &#125; else&#123; for(int i = 1;i&lt;=n;i++) for(int j=i;j;j/=10) if(j%10==x)cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C指针进阶]二级指针做输入的3种内存模型]]></title>
    <url>%2F2018%2F05%2F26%2F2018-05-26%2F</url>
    <content type="text"><![CDATA[对于指针，我们只需要从两个角度进行分析即可。 第一角度，站在C/C++编译器的角度看待指针，对形参，如指针类型，c编译器只会把他当做一个指针变量来看。（分配四个字节的内存） 第二角度，我们只有在是用指针所指向的内存空间的时候我们才去关心内存是一维的还是二维的。 今天分析的二维指针三种内存模型都是指针做输入的情况，在主调函数中分配内存。 在分析指针之前，先回顾一下内存四区的知识。首先我们知道内存分为5大区，我们暂把BSS段与数据段合称为全局区或者常量区，构成内存四区。以下是内存5大区具体概况。 内存5大区 BSS段( bss segment ) 通常是指用来存放程序中未初始化的全局变量和静态变量 （这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。既然都是0那么就没必要把每个0都存储起来,从而节省磁盘空间,这是BSS的主要作用）的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。 数据段(data segment) 通常是指用来存放程序中已经初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,但一般都是放在只读数据段中。 代码段(code segment/text segment) 通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。 堆(heap) 堆是用于存放进程运行中被动态分配的内存段,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减) 栈 (stack) 栈又称堆栈, 是用户存放程序临时创建的局部变量,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在数据段中存放变 量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的先进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。 二阶指针做输入的3种内存模型接下来我们来讨论二阶指针做输入的3种内存模型。 第1种首先第一种就是指针数组，以字符型指针数组为例定义方式为： 1char*p1[10]; 指针数组的实质是表示存放指针的数组。 第2种第二种为二维数组，以字符型二维数组为例定义方式为： 1char p2[3][4]; 第3种第三种为二维指针，以字符型二维指针为例定义方式为： 1char **p3; 二维指针是一个存放指针的指针，因此使用前需先开辟一段空间。 区别指针数组与二维指针的区别：由于二维指针储存的是指针，因此二维指针首先需要开辟空间，然后再在子元素上继续开辟空间，因此需要两步完成。 而指针数组由于本质上是数组，因此省略了第1步，只需在子元素上继续开辟空间。因此只需要1步完成。 以动态分配内存为例： 第1步 1ptr =malloc(3 *sizeof(char *));//等价于 *ptr [3]; 第2步 123ptr =malloc(3 *sizeof (char *));等价于 *ptr [3];for(i =0;i&lt;3;i++) ptr[i] =malloc(sizeof(char)*10);//表示可以存放长度为10 的字符串。 指针数组只需第2步，二维指针则需要1,2步。 而除此之外，基本再没有什么区别。他们的步长都是4，即一个指针的内存大小。 指针数组与数组指针的区别：首先，我们知道，二维数组ptr[2].[2]，ptr的实质是一个数组指针。我们知道，对于一维指针数组a[2]，a本质是指针，只不过a是一个常量指针，即a的值不能被修改。那么对于二维数组ptr[2].[2],ptr是一个常量数组指针，即ptr的值不可修改。 那么，他们本质的区别是什么呢。首先，对于char p[3]，他的步长是4。即一个指针的内存大小。 (p+1)=p[1],(int)(p+1)-(int)p=4。对于char( p )[3],他的步长是3，即一个数组内存大小。 (p+1) = p[1].[3],(int)(p+1)-(int)p=3。所以这就是为什么指针数组和数组指针不能相互赋值的原因。 内存模型示意图 代码以下是针对二维指针的3种内存模型进行排序的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;/*排序并输出第1种内存模型:指针数组*/void sort_myArray1(char **myArray, int len) &#123; printf(&quot;排序前：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;******************\n&quot;); for (int i = 0; i &lt; len; i++) /*改变指针的指向*/ for (int j = len - 1; j &gt; i; j--) &#123; if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123; char *tmp = myArray[j]; myArray[j] = myArray[j - 1]; myArray[j - 1] = tmp; &#125; &#125; printf(&quot;排序后：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;\n&quot;);&#125;/*排序并输出第2种内存模型：二维数组（数组指针）*/void sort_myArray2(char(*myArray)[4], int len) &#123; printf(&quot;排序前：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;******************\n&quot;); for (int i = 0; i &lt; len; i++) /*改变指针所指向内存的值*/ for (int j = len - 1; j &gt; i; j--) &#123; if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123; char tmp[4]; strcpy(tmp, myArray[j]); strcpy(myArray[j], myArray[j - 1]); strcpy(myArray[j - 1], tmp); &#125; &#125; printf(&quot;排序后：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;\n&quot;);&#125;/*排序并输出第3种内存模型：二维指针*/void sort_myArray3(char **myArray, int len) &#123; printf(&quot;排序前：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;******************\n&quot;); for (int i = 0; i &lt; len; i++) /*改变指针所指向内存的值，也可以改写成改变指针的指向*/ for (int j = len - 1; j &gt; i; j--) &#123; if (strcmp(myArray[j], myArray[j - 1])&gt;0) &#123; char tmp[4]; strcpy(tmp, myArray[j]); strcpy(myArray[j], myArray[j - 1]); strcpy(myArray[j - 1], tmp); &#125; &#125; printf(&quot;排序后：\n&quot;); for (int i = 0; i &lt; len; i++) printf(&quot;%s\n&quot;, myArray[i]); printf(&quot;\n&quot;);&#125;/*为二级指针分配动态内存并赋值*/char**get_myArray3(int len) &#123; char**myArray = NULL; while ((myArray = (char**)malloc(3 * sizeof(char*))) == NULL) &#123; printf(&quot;Error.\n&quot;); exit(1); &#125; for (int i = 0; i &lt; 3; i++) &#123; while ((myArray[i] = (char*)calloc(100, sizeof(char))) == NULL) &#123; printf(&quot;Error.\n&quot;); exit(1); &#125; sprintf(myArray[i], &quot;%d%d%d&quot;, i + 1, i + 2, i + 3); &#125; return myArray;&#125;/*将动态分配的内存空间释放掉*/void init_myArray3(char**myArray, int len) &#123; for (int i = 0; i &lt; len; i++) if (myArray[i] != NULL) &#123; free(myArray[i]); myArray[i] = NULL; &#125;&#125;int main() &#123; char*p1[] = &#123; &quot;123&quot;,&quot;456&quot;,&quot;789&quot; &#125;; /*第1种内存模型：指针数组*/ char p2[3][4] = &#123; &quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot; &#125;; /*第2种内存模型：多维数组*/ char**p3 = get_myArray3(3); /*第3种内存模型：二维指针*/ sort_myArray1(p1, sizeof(p1) / sizeof(p1[0])); /*数组的指针个数*/ sort_myArray2(p2, sizeof(p2) / sizeof(p2[0])); /*数组的行数*/ sort_myArray3(p3, 3); /*由于sizeof(p3)为4，即一个指针的大小，故不能用sizeof(p3) / sizeof(p2[3])*/ init_myArray3(p3, 3); if (p3 != NULL) free(p3); /*释放掉二维指针分配的内存*/ p3 = NULL; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C常量]C语言中的伪装大佬——伪常量const]]></title>
    <url>%2F2018%2F05%2F25%2F2018-05-25-1%2F</url>
    <content type="text"><![CDATA[为什么要介绍C语言的const呢？首先声明它和C++中的const不一样。许多人经常.CPP和.C混用，导致C++与C的const分不清，有时候莫名其妙的错误，包括我。当然，这只是原因之一。最主要的原因是C语言的const实在是太虚伪了。所以今天把C语言中这个狡猾的const列出来，以免之后犯错。 用法首先以int为例定义整形常量a的两种方法： 12const int a;int const a; 当然，这两种方法其实是一样的，都代表的是整形常量。对于其他类型也是同样的方法。 不过对于指针，就有点特别了。首先强调，const和 的优先级是 优先级高于const。以下是以字符串为例的 3种定义方法。 123const char *p; //char const *p;char * const p;const char * const p; //char const * const p; 第一种指的是p是指向常量字符型数的指针，所指向的内存数据不可以被修改，但是本身可修改。 第2种指的是p是指向字符型数的常指针，所指向的内存数据可以被修改，但是本身不可被修改。 第3种是指向常量字符型数的常指针，所指向的内存数据补可被修改，本身也不可被修改。 伪常量用法介绍完了，但为什么说C的const是伪常量呢？因为常量是不可被更改的，但const可以通过简介赋值所改变。我们首先说一下C中的const使用时需要注意的一些细节。 const是伪常量，无法用于数组的初始化和全局变量的初始化,本质就是限定一个变量不能直接赋值。 如以下代码： 123456781 #define A 102 int arr[A];3 4 //const本质，伪常量 ,无法用于数组初始化和全局变量初始化5 /*6 const int B = 10;7 int arr[B];8 */ 但是如果局部变量是能够初始化编译并运行的 123451 void main()2 &#123;3 const int B = 10;4 int arr[B];5 &#125; const是伪常量，都知道常量是不能改变值的。例如这样是根本无法编译的。 1234561 void main() &#123;2 //num在栈区，只有栈区会自动回收释放3 //局部const常量在栈区，而不在静态区(静态区会一直存在)4 const int num = 10;//num就是一个常量5 //num = 11; //const本质，限定一个变量不能直接赋值6 &#125; 前面一直强调const是伪常量，因为可以间接的去改变它的值。利用指针变量 1234567891011121314 1 void main() &#123; 2 //num在栈区，只有栈区会自动回收释放 3 //局部const常量在栈区，而不在静态区(静态区会一直存在) 4 const int num = 10;//num就是一个常量 5 //num = 11; //error const本质，限定一个变量不能直接赋值 6 7 //间接改变常量值 8 const int *p = &amp;num;//定义一个指针指向一个常量，存储num的地址 9 int *pv = (int *)p;//对指向常量的指针进行强制转换10 *pv = 8;//对指针指向内容赋值11 12 printf(&quot;%d&quot;,num); //813 14 &#125; 结论c语言的const是冒牌货。C语言const的含义是被称为一个不能被改变的普通变量 ，它会分配内存。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>C语言基础</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>const</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[组合数学]取石子]]></title>
    <url>%2F2018%2F05%2F25%2F2018-05-25%2F</url>
    <content type="text"><![CDATA[为什么要写关于这道题的博客呢？首先本题本人用python成功ac，要知道很少有人用Python做算法题。而且本人已经好几个月没用Python了，所以记录一下。此外，本题用到了排列组合打表，整理好代码，以后要用模板就不用再找了。 取石子题目描述给出四堆石子，石子数分别为a,b,c,d。规定每次只能从堆顶取走石子，问取走所有石子的方案数。 输入描述:1在一行内读入四个由空格分隔的整数a,b,c,d， 输入均为不超过500的正整数 输出描述:1输出一个整数表示答案，答案对109+7取模 输入13 5 4 2 输出12522520 备注:输入均为不超过500的正整数 题解：我们一堆一堆的考虑。第一堆a，第2堆b，第3堆c，第4堆d。假如只有一堆，则只有1种情况，即C(a,a)。假如有两堆，我们可以当做这两堆石子的排列组合。可以算出两堆石子的方案数。即C(b,a+b)。第三堆我们可以把前两堆看成一堆，然后继续排列组合，即C(c,a+b+c)。第4队即C(d,a+b+c+d)。最后全部相乘即可，即C(a,a) C(b,a+b) C(c,a+b+c)*C(d,a+b+c+d)。 暴力枚举首先想到暴力枚举，虽然一定超时。以下是代码。只需要把所有情况列一遍即可。 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define ll long longll a[4];ll cnt = 0;void dfs(ll a, ll b, ll c, ll d) &#123; if (!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!d) &#123; cnt++; cnt %= 1000000000 + 7; return; &#125; if (a) dfs(a - 1, b, c, d); if (b) dfs(a, b - 1, c, d); if (c) dfs(a, b, c - 1, d); if (d) dfs(a, b, c, d - 1);&#125;int main() &#123; for (int i = 0; i &lt; 4; i++) scanf(&quot;%lld&quot;, &amp;a[i]); dfs(a[0], a[1], a[2], a[3]); printf(&quot;%lld\n&quot;, cnt); return 0;&#125; python由于数据过大，c++没有大数类，所以用python首先A了一下。 123456789101112f = input().split()ans = 1sum = [int(f[0]),0,0,0]for i in range(1,4): sum[i]=sum[i-1]+int(f[i]) for j in range(sum[i]-int(f[i])+1,sum[i]+1): ans*=jfor i in range(1,4): for j in range(1,int(f[i])+1): ans//=jans%=1000000007print(ans) c++由于acm不能用python，所以只能再考虑c++。首先由于涉及到除法，所以不能直接取余。 我没知道公式：C(M,N)=C(M-1,N)+C(M-1，N-1)，这样把除法转化成加法，就可以模运算了。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;#define ll long longusing namespace std;const int maxn = 501;const ll mod = 1000000007;ll a[4], sum[4] = &#123; 0 &#125;;ll dp[maxn * 4][maxn * 4];void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; dp[i][j] %= mod; &#125; dp[i][i] = 1; &#125;&#125;int main() &#123; init(); ll ans = 1; for (int i = 0; i &lt; 4; i++) &#123; !i ? sum[i] = 0 : sum[i] = sum[i - 1]; cin &gt;&gt; a[i]; sum[i] += a[i]; if (a[i] &gt; sum[i] - a[i]) a[i] = sum[i] - a[i]; &#125; for (int i = 1; i &lt; 4; i++) &#123; ans *= dp[sum[i]][a[i]]; ans %= mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; C(M,N)模板1234567891011void init() &#123; dp[0][0] = 0; for (int i = 1; i &lt; 4 * maxn; i++) &#123; dp[i][0] = 1; for (int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; dp[i][j] %= mod; &#125; dp[i][i] = 1; &#125;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>组合数学</tag>
        <tag>暴力枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据库]关系数据库标准语言sql]]></title>
    <url>%2F2018%2F05%2F22%2F2018-05-22%2F</url>
    <content type="text"><![CDATA[有些人生而成功，像你。有些人生而失败，像我。——随笔 概述SQL（Structured Query Language） 结构化查询语言，是关系数据库的标准语言。 SQL是一个通用的、功能极强的关系数据库语言。 特点综合统一集数据查询，数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。 可以独立完成数据库生命周期中的全部活动： 定义关系模式，插入数据，建立数据库； 对数据库中的数据进行查询和更新； 数据库重构和维护 数据库安全性、完整性控制等 用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据的运行。 数据操作符统一 高度非过程化非关系数据模型的数据操纵语言“面向过程”，必须制定存取路径。 SQL只要提出“做什么”，无须了解存取路径。 存取路径的选择以及SQL的操作过程由系统自动完成。 面向集合的操作方式非关系数据模型采用面向记录的操作方式，操作对象是一条记录。 SQL采用集合操作方式 操作对象、查找结果可以是元组的集合 一次插入、删除、更新操作的对象可以是元组的集合 以同一种语法结构提供多种使用方式SQL是独立的语言，能够独立地用于联机交互的使用方式。 SQL又是嵌入式语言，SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用。 语言简洁，易学易用SQL功能极强，完成核心功能只用了9个动词。 SQL功能 动词 数据查询 SELECT 数据定义 CREATE, DROP, ALTER 数据操纵 INSERT, UPDATE, DELETE 数据控制 GRANT, REVOKE SQL基本概念SQL支持关系数据库三级模式结构 基本表本身独立存在的表 SQL中一个关系就对应一个基本表 一个(或多个)基本表对应一个存储文件 一个表可以带若干索引 存储文件逻辑结构组成了关系数据库的内模式 物理结构是任意的，对用户透明 视图从一个或几个基本表 导出的表数据库中只存放视图的定义而不存放视图对应的数据 视图是一个虚表 用户可以在视图上再定义视图 学生-课程数据库学生-课程模式 S-T :学生表：Student(Sno,Sname,Ssex,Sage,Sdept) 课程表：Course(Cno,Cname,Cpno,Ccredit) 学生选课表：SC(Sno,Cno,Grade) Student表 学 号 Sno 姓 名 Sname 性 别 Ssex 年 龄 Sage 所 在 系 Sdept 200215121 李勇 男 20 CS 200215122 刘晨 女 19 CS 200215123 王敏 女 18 MA 200515125 张立 男 19 IS Course表 课程号 Cno 课程名 Cname 先行课 Cpno 学分 Ccredit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 PASCAL语言 6 4 SC表 学 号 Sno 课程号 Cno 成绩 Grade 200215121 1 92 200215121 2 85 200215121 3 88 200215122 2 90 200215122 3 80 数据定义SQL的数据定义功能: 模式定义、表定义、视图和索引的定义 模式的定义与删除[例1]定义一个学生-课程模式S-T CREATE SCHEMA “S-T” AUTHORIZATION WANG; 为用户WANG定义了一个模式S-T [例2]CREATE SCHEMA AUTHORIZATION WANG； &lt;模式名&gt;隐含为用户名WANG 如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt; 定义模式定义模式实际上定义了一个命名空间 在这个空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引等。 在CREATE SCHEMA中可以接受CREATE TABLE，CREATE VIEW和GRANT子句。 CREATE SCHEMA [&lt;模式名&gt;] AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;] [例3] CREATE SCHEMA TEST AUTHORIZATION ZHANG ​ CREATE TABLE TAB1(COL1 SMALLINT， ​ COL2 INT， ​ COL3 CHAR(20)， ​ COL4 NUMERIC(10，3)， ​ COL5 DECIMAL(5，2) ​ )； ​ 为用户ZHANG创建了一个模式TEST，并在其中定义了一个表TAB1。 删除模式DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE(级联) 删除模式的同时把该模式中所有的数据库对象全部删除RESTRICT(限制) 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。 当该模式中没有任何下属的对象时才能执行。 [例4] DROP SCHEMA TEST CASCADE； ​ 删除模式ZHANG ​ 同时该模式中定义的表TAB1也被删除 基本表的定义、删除与修改定义基本表CREATE TABLE &lt;表名&gt; ​ （&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] ​ [，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] … ​ [，&lt;表级完整性约束条件&gt; ] ）； 如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。 [例5] 建立“学生”表Student，学号是主码，姓名取值唯一。 CREATE TABLE Student ​ (Sno CHAR(9) PRIMARY KEY， / 列级完整性约束条件 / ​ Sname CHAR(20) UNIQUE， / Sname取唯一值/ ​ Ssex CHAR(2)， ​ Sage SMALLINT， ​ Sdept CHAR(20) ​ )； ​ [，PRIMARY KEY （Sno）] [例6] 建立一个“课程”表Course CREATE TABLE Course ​ ( Cno CHAR(4) PRIMARY KEY， ​ Cname CHAR(40)， ​ Cpno CHAR(4) ， / 先行课 / ​ Ccredit SMALLINT， ​ FOREIGN KEY (Cpno) REFERENCES Course(Cno) / Cpno是外码，被参照表是Course，被参照列是Cno / ​ ); [例7] 建立一个“学生选课”表SC CREATE TABLE SC ​ (Sno CHAR(9)， ​ Cno CHAR(4)， ​ Grade SMALLINT， ​ PRIMARY KEY (Sno，Cno)，/ 主码由两个属性构成，必须作为表级完整性进行定义/ ​ FOREIGN KEY (Sno) REFERENCES Student(Sno)， / 表级完整性约束条件，Sno是外码，被参照表是Student / ​ FOREIGN KEY (Cno) REFERENCES Course(Cno) / 表级完整性约束条件， Cno是外码，被参照表是Course/ ); 数据类型SQL中域的概念用数据类型来实现 定义表的属性时 需要指明其数据类型及长度 选用哪种数据类型 取值范围 要做哪些运算 数据类型 含义 CHAR(n) 长度为n的定长字符串 VARCHAR(n) 最大长度为n的变长字符串 INT 长整数（也可以写作INTEGER） SMALLINT 短整数 NUMERIC(p，d) 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字 REAL 取决于机器精度的浮点数 Double Precision 取决于机器精度的双精度浮点数 FLOAT(n) 浮点数，精度至少为n位数字 DATE 日期，包含年、月、日，格式为YYYY-MM-DD TIME 时间，包含一日的时、分、秒，格式为HH:MM:SS 模式与表每一个基本表都属于某一个模式 一个模式包含多个基本表 定义基本表所属模式方法一：在表名中明显地给出模式名 Create table “S-T”.Student（……）; /模式名为 S-T/ Create table “S-T”.Cource（……）; Create table “S-T”.SC（……）; 方法二：在创建模式语句中同时创建表 方法三：设置所属的模式 创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式。 RDBMS会使用模式列表中第一个存在的模式作为数据库对象的模式名 。 若搜索路径中的模式名都不存在，系统将给出错误 显示当前的搜索路径： SHOW search_path; 搜索路径的当前默认值是：$user， PUBLIC 先搜索与用户名相同的模式，若不存在，则使用PUBLIC 模式与表DBA用户可以设置搜索路径，然后定义基本表 ​ SET search_path TO “S-T”，PUBLIC； ​ Create table Student（……）; 结果建立了S-T.Student基本表。 RDBMS发现搜索路径中第一个模式名S-T存在，就把该模式作为基本表Student所属的模式。 修改基本表ALTER TABLE &lt;表名&gt; [ ADD [&lt;新列名&gt; &lt;数据类型&gt;].[完整性约束 ]] [ DROP &lt;完整性约束名&gt; ] [ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]； MODIFY 约束（属性名）]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据库]数据库概论基础整理]]></title>
    <url>%2F2018%2F05%2F21%2F2018-05-21%2F</url>
    <content type="text"><![CDATA[努力，努力，再努力。因为我要在这虚假的世界里为她撑起一片童话的天空。——随笔 数据库系统概述四个基本概念数据（Data）数据(Data)：数据库中存储的基本对象。 定义：描述事物的符号记录 种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等 特点：数据与其语义是不可分的。 eg： 54是一个数据 语义1：学生某门课的成绩 语义2：某人的体重 语义3：计算机系2011级学生人数 eg: 学生档案中的学生记录 （张三，男，19941014，陕西西安市，计算机系，2011） 语义：学生姓名、性别、出生年月、籍贯、所在院系、入学时间 解释：张三是个大学生，1994年10月14日出生，陕西省西安市人，2011年考入计算机系 数据库（DB）数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。 特征数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统（DBMS）定义位于用户与操作系统之间的一层数据管理软件。 是基础软件，是一个大型复杂的软件系统 用途科学地组织和存储数据、高效地获取和维护数据。 数据库在计算机系统中的位置 功能 数据定义功能 提供数据定义语言(DDL) 定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各种数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方法提高存取效率 数据操纵功能 提供数据操纵语言(DML) 实现对数据库的基本操作 (增删改查) 数据库的事务管理和运行管理 数据库在建立、运行和维护时由DBMS统一管理和控制 保证数据的安全性、完整性、多用户对数据的并发使用 发生故障后的系统恢复 数据库的建立和维护功能(实用程序和管理工具) 数据库初始数据装载转换 数据库转储 介质故障恢复 数据库的重组织 性能监视分析等 其它功能 DBMS与网络中其它软件系统的通信 两个DBMS系统的数据转换 异构数据库之间的互访和互操作 数据库系统（DBS)Database System，在计算机系统中引入数据库后的系统。 构成数据库 数据库管理系统（及其开发工具） 应用系统 数据库管理员 数据管理技术的产生和发展什么是数据管理对数据进行分类、组织、编码、存储、检索和维护 是数据处理的中心问题 数据处理：对各种数据进行收集、存储、加工和传播。 数据管理技术的发展过程人工管理阶段(20世纪40年代中–50年代中) 文件系统阶段(20世纪50年代末–60年代中) 数据库系统阶段(20世纪60年代末–现在) 数据管理技术的发展动力应用需求的推动 计算机硬件的发展 计算机软件的发展 数据库系统的特点数据结构化整体数据的结构化是数据库的主要特征之一。 整体结构化不再仅仅针对某一个应用，而是面向全组织 不仅数据内部结构化，整体是结构化的，数据之间具有联系 数据库中实现的是数据的真正结构化数据的结构用数据模型描述，无需程序定义和解释 数据可以变长 数据的最小存取单位是数据项 数据的共享性高，冗余度低，易扩充数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。 数据共享的好处减少数据冗余，节约存储空间 避免数据之间的不相容性与不一致性 使系统易于扩充 数据独立性高数据独立性是由DBMS的二级映像功能来保证的。 物理独立性指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。 逻辑独立性指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。 数据由DBMS统一管理和控制DBMS提供的数据控制功能(1)数据的安全性（Security） 保护保护数据，以防止不合法的使用造成的数据的泄密和破坏。 (2)数据的完整性（Integrity） 检查将数据控制在有效的范围内，或保证数据之间满足一定的关系。 (3)并发（Concurrency） 控制对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。 (4)数据库恢复（Recovery） 将数据库从错误状态恢复到某一已知的正确状态。 应用程序与数据的对应关系(数据库系统) 数据模型两大类数据模型数据模型分为两类（分属两个不同的层次） (1) 概念模型 也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。 (2) 逻辑模型和物理模型 逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型等，按计算机系统的观点对数据建模，用于DBMS实现。 物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。 设计人员了解和选择物理模型。 客观对象的抽象过程—两步抽象 现实世界中的客观对象抽象为概念模型； 把概念模型转换为某一DBMS支持的数据模型。 数据模型组成元素数据结构，数据操作，完整性约束条件 数据结构描述数据库的组成对象，以及对象之间的联系 数据结构是对系统静态特性的描述（描述对象类型的集合） 描述的内容与数据类型、内容、性质有关的对象（域、属性、关系） 与数据之间联系有关的对象 数据操作对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则 数据操作的类型查询 更新(包括插入、删除、修改) 数据模型对操作的定义操作的确切含义 操作符号 操作规则（如优先级） 实现操作的语言 数据操作是对系统动态特性的描述 数据的完整性约束条件一组完整性规则的集合。 完整性规则：给定的数据模型中数据及其联系所具有的制约和储存规则 用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。 定义反映和规定本数据模型必须遵守的基本的通用的完整性约束条件。例如在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。如：退休 概念模型用途概念模型用于信息世界的建模 是现实世界到机器世界的一个中间层次 是数据库设计的有力工具 数据库设计人员和用户之间进行交流的语言 对概念模型的基本要求较强的语义表达能力 能够方便、直接地表达应用中的各种语义知识 简单、清晰、易于用户理解 信息世界中的基本概念实体（Entity）客观存在并可相互区别的事物称为实体。 可以是具体的人、事、物或抽象的概念。如：选课 属性（Attribute）实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画。 码（Key） 唯一标识实体的属性集称为码。如：Snum 域（Domain）属性的取值范围称为该属性的域。 如：Grade 实体型（Entity Type） 用实体名及其属性名集合来抽象和刻画同类实体称为实体型 如：Student(Snum,Sname,Grade ) 实体集（Entity Set）同一类型实体的集合称为实体集 联系（Relationship）现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。 实体内部的联系通常是指组成实体的各属性之间的联系 实体之间的联系通常是指不同实体集之间的联系 两个实体型之间的联系用图形来表示两个实体型之间的这三类联系 一对一联系（1:1） 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1 实例 一个班级只有一个正班长，一个班长只在一个班中任职 一对多联系（1：n）如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:n 实例 一个班级中有若干名学生，每个学生只在一个班级中学习 多对多联系（m:n）如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体（m≥0）与之联系，则称实体集A与实体B具有多对多联系，记为m:n 实例 课程与学生之间的联系：一门课程同时有若干个学生选修，一个学生可以同时选修多门课程 两个以上实体型之间的联系两个以上实体型之间一对多联系若实体集E1，E2，…，En存在联系，对于实体集Ej（j=1，2，…，i-1，i+1，…，n）中的给定实体，最多只和Ei中的一个实体相联系，则我们说Ei与E1，E2，…，Ei-1，Ei+1，…，En之间的联系是一对多的 实例 课程、教师与参考书三个实体型一门课程可以有若干个教师讲授，使用若干本参考书，每一个教师只讲授一门课程，每一本参考书只供一门课程使用课程与教师、参考书之间1：n 两个以上实体型间的多对多联系两个以上实体型间的多对多联系 实例 供应商、项目、零件三个实体型,一个供应商可以供给多个项目多种零件,每个项目可以使用多个供应商供应的零件,每种零件可由不同供应商供给 单个实体型内的联系一对一联系一对多联系实例 职工实体型内部具有领导与被领导的联系,某一职工（干部）“领导”若干名职工,一个职工仅被另外一个职工直接领导,这是一对多的联系 多对多联系 概念模型的一种表示方法实体－联系方法(E-R方法)用E-R图来描述现实世界的概念模型 E-R方法也称为E-R模型 E-R图实体型 用矩形表示，矩形框内写明实体名。 属性 用椭圆形表示，并用无向边将其与相应的实体连接起来 联系 联系本身： 用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n或m:n） 联系的属性： 联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 最常用的数据模型非关系模型（格式化模型）层次模型(Hierarchical Model) 实体-&gt;记录 网状模型(Network Model) 属性-&gt;字段（数据项） 非关系模型中数据结构基本单位基本层次联系：两个记录以及它们之间的一对多（包括一对一）的联系。 关系模型(Relational Model)面向对象模型(Object Oriented Model）对象关系模型(Object Relational Model)层次模型(最早的模型)层次模型用树形结构来表示各类实体以及实体间的联系 满足下面两个条件的基本层次联系的集合为层次模型 有且只有一个结点没有双亲结点，这个结点称为根结点 根以外的其它结点有且只有一个双亲结点 层次模型中的几个术语 根结点，双亲结点，兄弟结点（同一双亲的节点），叶结点（没有子女的节点） 网状模型网状数据库系统采用网状模型作为数据的组织方式 满足下面两个条件的基本层次联系的集合： 允许一个以上的结点无双亲； 一个结点可以有多于一个的双亲。 表示方法(与层次数据模型相同) 实体型：用记录类型描述每个结点表示一个记录类型（实体） 属性：用字段描述每个记录类型可包含若干个字段 联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系 关系模型关系数据库系统采用关系模型作为数据的组织方式。 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。 关系（Relation）一个关系对应通常说的一张表 元组（Tuple）表中的一行即为一个元组 属性（Attribute）表中的一列即为一个属性，给每一个属性起一个名称即属性名 主码（Key）表中的某个属性或属性组，它可以唯一确定一个元组。 域（Domain）属性的取值范围。 分量元组中的一个属性值。 关系模式对关系的描述 关系名（属性1，属性2，…，属性n） 学生（学号，姓名，年龄，性别，系，年级） 术语对比 关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中有表（大表中嵌有小表） 关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表。 数据操作查询 插入 删除 更新 数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合 存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干” 关系的完整性约束条件实体完整性 参照完整性 用户定义的完整性 数据库系统结构从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。 从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为: 单用户结构 主从式结构分布式结构 客户／服务器 浏览器／应用服务器／数据库服务器多层结构等 数据库系统模式的概念“型” 和“值” 的概念型(Type)对某一类数据的结构和属性的说明 值(Value)是型的一个具体赋值例如学生记录 型： （学号，姓名，性别，系别，年龄，籍贯）一个记录 值： （900201，李明，男，计算机，22，江苏） 模式（Schema）数据库逻辑结构和特征的描述 是型的描述 反映的是数据的结构及其联系 模式是相对稳定的 实例（Instance）模式的一个具体值 反映数据库某一时刻的状态 同一个模式可以有很多实例实例 随数据库中的数据的更新而变动 例如：在学生选课数据库模式中，包含学生记录、课程记录和学生选课记录 2013年的一个学生数据库实例，包含： 2013年学校中所有学生的记录 学校开设的所有课程的记录 所有学生选课的记录 2012年度学生数据库模式对应的实例与2013年度学生数据库模式对应的实例是不同的 数据库系统的三级模式结构 模式（Schema也称逻辑模式）数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图，综合了所有用户的需求 一个数据库只有一个模式 模式的地位：是数据库系统模式结构的中间层与数据的物理存储细节和硬件环境无关 与具体的应用程序、开发工具及高级程序设计语言无关 模式的定义数据的逻辑结构（数据项的名字、类型、取值范围等） 数据之间的联系 数据有关的安全性、完整性要求 外模式（External Schema也称子模式或用户模式）数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 模式与外模式的关系：一对多外模式通常是模式的子集 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求 对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同 外模式与应用的关系：一对多同一外模式也可以为某一用户的多个应用系统所使用 但一个应用程序只能使用一个外模式 外模式的用途保证数据库安全性的一个有力措施 每个用户只能看见和访问所对应的外模式中的数据 内模式（Internal Schema也称存储模式）一个数据库只有一个内模式 是数据物理结构和存储方式的描述是数据在数据库内部的表示方式记录的存储方式（堆存储，顺序存储，聚簇存储） 索引的组织方式（B+树索引，按hash索引存储） 数据是否压缩存储 数据是否加密 数据存储记录结构的规定 数据库的二级映像功能与数据独立性 数据库的二级映像功能与数据独立性三级模式是对数据的三个抽象级别 二级映象在DBMS内部实现这三个抽象层次的联系和转换 外模式／模式映象模式：描述的是数据的全局逻辑结构 外模式：描述的是数据的局部逻辑结构 同一个模式可以有任意多个外模式 每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系 映象定义通常包含在各自外模式的描述中 保证数据的逻辑独立性当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 模式／内模式映像模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的 数据库中模式／内模式映象是唯一的 该映象定义通常包含在模式描述中 保证数据的物理独立性当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变 应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。 数据库模式即全局逻辑结构是数据库的中心与关键 独立于数据库的其他层次 设计数据库模式结构时应首先确定数据库的逻辑模式 数据库的内模式依赖于它的全局逻辑结构 独立于数据库的用户视图，即外模式 独立于具体的存储设备 将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 数据库的外模式面向具体的应用程序 定义在逻辑模式之上 独立于存储模式和存储设备 当应用需求发生较大变化，相应外模式不能满足其视图要求时，该外模式就得做相应改动 设计外模式时应充分考虑到应用的扩充性 特定的应用程序在外模式描述的数据结构上编制的 依赖于特定的外模式 与数据库的模式和存储结构独立 不同的应用程序有时可以共用同一个外模式 数据库的二级映像保证了数据库外模式的稳定性 从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改 数据与程序之间的独立性，使得数据的定义和描述可以从应用程序中分离出去 数据的存取由DBMS管理用户不必考虑存取路径等细节 简化了应用程序的编制 大大减少了应用程序的维护和修改 数据库系统的组成数据库 数据库管理系统（及其开发工具） 应用系统 数据库管理员]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据库</category>
        <category>关系数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM全国邀请赛热身赛题2并查集]]></title>
    <url>%2F2018%2F05%2F19%2F2018-05-19%2F</url>
    <content type="text"><![CDATA[真是糟糕的一天，愿不要影响到明天邀请赛发挥。 题意： 有n个人。m次询问。每次询问包含两个数x和y，代表第x人和和第y人中有一个人是叛徒，一个不是叛徒。如果遇到第i次询问和之前询问出现冲突，则该询问为谎言。如果m条询问没有谎言，则输出1，和最大可能叛徒数，否则输出-1，遇到第几条时判断是谎言。 例： 输入 3 3 1 2 2 3 3 1 输出 -1 3 输入 5 4 1 2 2 3 3 4 4 1 输出 1 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int MAXX = 100010;int fa[MAXX], r[MAXX];int vis[MAXX];int find(int x)&#123; if (fa[x] == x) return fa[x]; int tmp = fa[x]; fa[x] = find(fa[x]); r[x] = (r[tmp] + r[x]) % 2; return fa[x];&#125;void fun(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx == fy) return; fa[fy] = fx; r[fy] = (r[x] + 1 - r[y]) % 2;&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int N, M, x, y, flag = 0, cnt = 0; scanf(&quot;%d%d&quot;, &amp;N, &amp;M); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt;= N; i++) fa[i] = i, r[i] = 0; for (int i = 1; i &lt;= M; i++) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (!vis[x]) cnt++; if (!vis[y]) cnt++; vis[x] = vis[y] = 1; if (flag) continue; if (find(x) == find(y)) &#123; if (r[x] == r[y]) flag = i; &#125; else fun(x, y); &#125; if (flag) printf(&quot;-1 %d\n&quot;, flag); else &#123; int cnt2 = 0; for (int i = 1; i &lt;= N; i++) &#123; find(i); if (r[i] == 1 || !vis[i]) cnt2++; &#125; printf(&quot;1 %d\n&quot;, cnt - cnt2 &gt; cnt2 ? cnt - cnt2 : cnt2); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛&&艾教习题总结]]></title>
    <url>%2F2018%2F05%2F16%2F2018-05-16%2F</url>
    <content type="text"><![CDATA[管道取珠 输入 第一行包含两个整数n, m，分别表示上下两个管道中球的数目。 第二行为一个AB字符串，长度为n，表示上管道中从左到右球的类型。其中A表示浅色球，B表示深色球。 第三行为一个AB字符串，长度为m，表示下管道中的情形。 输出 仅包含一行，即为 Sigma(Ai^2) i从1到k 除以1024523的余数。 输入示例 1232 1ABB 输出示例 15 数据规模及约定 约30%的数据满足 n, m ≤ 12；约100%的数据满足n, m ≤ 500。 题解 这题思路比较妙，我们需要先想想 ∑ai2 有什么意义。如果我们构造出这样一个游戏场景，即两个人同时玩两份同样的如题目所述的管道取珠的游戏，那么这两个人游戏结束后取到的珠子颜色序列一模一样的方案数就是题目里要求的答案。 令这两个人分别是 p1 和 p2。于是设 f[i][j][k] 表示 p1 取了第二个管道中的前 i 个珠子，第一个管道中的前 j 个珠子；p2 取了第一个管道的前 k 个珠子，这个状态下颜色序列相同的方案数，转移显然。 注：n为12以内一般是阶乘的题，n为30以内可以考虑状态压缩，莫队，线段树等各种情况，50左右选择二分，100以上需要另想方法。 问号猜数有一堆数按照递增的顺序排列，然而这些数的某些位我们并不知道，我们知道的只是这些数是从小到大排列的，现在依次给出这些数，不知道的位用？表示。我们需要猜这个数能满足递增条件的最小数。例如： ?? 1? ?1 ??? ?99 ?9? ?4?5 第一个数是10，第2个11，第3个21，第4个100，第5个199，第6个290，第7个1405。 题解 用贪心虽然比较快，但代码不容易写，须考虑情况挺多。因此我们分析一下。首先n&lt;=6，代表最大位数是6，也就是说最大的数也就是百万位。因此直接从1枚举，另设指针指向第1个数，每枚举到某个数满足该指针指向的数，则将指针指向下一个数，然后继续枚举，因此扫描一遍之后就得到所有的答案了。 接下来，假如n&lt;=15，由于数是递增的，则将枚举用二分来完成。假如n&gt;=100，这时再考虑贪心。 取牌去牌有n张牌，每个牌有一个a属性和1个b属性，第i张牌的属性为ai，bi。现在每次从牌中选两张牌ii.j，得到一个ai bj + bi aj的分数，然后从这两张牌中去掉1张牌。经过n-1次操作之后就剩1张牌了。问经过n-1次操作后得到的最大的分数和是多少。 题解 主要是删除牌的问题。但是假如我们将每张牌看成1个结点，属性的乘积得到的分数为1条路径，那么n张牌构成了n个结点n*（n-1）/2条边的强联通无向图，那么只需求每次分数最大的最小生成树即可。 铁索连环有n个数，现在有m次查询，每次查询[l,r]范围所有不同的数。假设n很大 题解 我的思路是打表记录上一个相同元素的位置，比如a[1-10]=1,2,4,3,2,4,5,6,3,4,那么b[1-10]=0,0,0,0,2,3,0,0,4,6。这样l，r的范围内只需扫描1遍即可，扫到0结果加1，扫到非0的数看该下标是否 &lt; l，是则加1，否则不处理。时间复杂度是0mn。 艾教的方法不是很懂，不过举了一个例子，假如(3(3(3(3(3)))))，查询范围为括号所示，那么只需将第5个3赋为1，其他3赋为0即可。看起来最后就像一条链子捆绑着相同的元素。 狭路相逢有一个图，每条路上都有强盗，每个节点都有驴友，假如到某条路上，该路上的强盗抢劫你的条件是强盗人数大于等于你们人数。你们每经过一个节点可以拉驴友入伍结伴而行，问（忘记问什么了，尴尬~QAQ~） 题解 并查集 区间gcd给定l，r，问多少种gcd(l,r)==gcd(l2.r2) 题解 1、两个条件，从1到n，最大公约数呈递减阶梯式。 2、gcd(gcd（a,b）,gcd(c,d))==gcd(a,d) 根据性质2可以用st表列出范围内l，r的最大公约数，即1，n最大公约数 根据性质1，二分求解 信号误差艾教给女朋友传情发信号，信号是01串（16位）组成的字母，但是有情敌的干扰，途中可能至多会有两位进制会发生改变。问如何设置01串才能无视干扰准确将信号传给女盆友。例如1111111111111111，那么该2个1也是比0多，所以无视干扰。但每次只能处理一个字母，效率太慢。 题解 图论。将距离2以内的所有结点全部连起来。贪心选取结点，可以直接选择第一个结点开始。 牛客小白月赛音标题目描述 我们规定元音字母有a、e、i、o、u，并且规定半元音字母y也是元音字母。 Cwbc在学习英语，XHRlyb为了让Cwbc的记忆更加深刻，于是她让Cwbc把每个字符串的所有字母都变成一个恰好**不大于它本身的小写元音字母**。 输入描述:1输入数据有多行，每行有一个仅包含小写字母的字符串。 输出描述:1输出数据应有多行，每行有一个变化后的字符串。 示例1 输入1aeiou 输出1aeiou 说明1元音字母变为一个恰好不大于它本身的字母，也就是元音字母本身 示例2 输入1bfjpv 输出1aeiou 说明1输入样例是由元音字母a、e、i、o、u的后一个字母组成，每个字母变为一个恰好不大于它本身的字母，也就是a、e、i、o、u。 备注:1每行字符串长度不超过2×105，字符串总长度不超过106。 代码upper_bound的应用 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[210000];char a[]=&quot;aeiouy&quot;;int main()&#123; while(cin&gt;&gt;s) &#123; for(int i=0;s[i];i++) &#123; s[i]=a[upper_bound(a,a+6,s[i])-a-1]; &#125; puts(s); &#125;&#125; 躲藏题目描述XHRlyb和她的小伙伴Cwbc在玩捉迷藏游戏。 Cwbc藏在多个不区分大小写的字符串中。 好奇的XHRlyb想知道，在每个字符串中Cwbc作为子序列分别出现了多少次。 由于Cwbc可能出现的次数过多，你只需要输出每个答案对2000120420010122取模后的结果。 聪明的你在仔细阅读题目后，一定可以顺利的解决这个问题！ 输入描述:1输入数据有多行，每行有一个字符串。 输出描述:1输出数据应有多行，每行表示一个答案取模后的结果。 示例1 输入1Cwbc 输出11 说明1Cwbc作为子序列仅出现了1次。 示例2 输入1acdcecfwgwhwibjbkblcmcnco 输出181 说明1Cwbc作为子序列出现了34=81次。 备注:1每行字符串长度不超过2×105，字符串总长度不超过106。 代码一个memset导致超时，也是够无语。时间复杂度4 On，加上memset是5 On，就差1个On就超时。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;char str[200010];long long dp[5][200010];int main() &#123; int i; while (scanf(&quot;%s&quot;, str + 2) != EOF) &#123; dp[1][0] = &apos;c&apos;, dp[2][0] = &apos;w&apos;, dp[3][0] = &apos;b&apos;,dp[4][0] = &apos;c&apos;; for (i = 2; str[i]; i++) &#123; dp[0][i] = 1; str[i] = tolower(str[i]); for (int k = 1; k &lt; 5; k++) &#123; dp[k][i] = dp[k][i - 1]; if (str[i] == dp[k][0]) &#123; dp[k][i] += dp[k - 1][i]; dp[k][i] %= 2000120420010122; &#125; &#125; &#125; printf(&quot;%lld\n&quot;, dp[4][i - 1]); &#125; return 0;&#125; 博弈 博弈双方都是绝顶聪明的，并且XHRlyb先手，请你来帮XHRlyb预测这一局游戏谁会获胜。 如果博弈双方谁也无法取胜，那么判定为平局。 输入描述:1输入数据有多行，每行有三个正整数，l，r，k。 输出描述:1输出数据应有多行，如果这一局XHRlyb获胜，那么请输出XHRlyb；如果Cwbc获胜，请输出Cwbc；如果两人平局，请输出Draw。 示例1 输入11 3 2 输出1XHRlyb 示例2 输入11 4 2 输出1Cwbc 备注:1231 ≤ l ≤ r ≤ 105。1 ≤ k ≤ 100。1 ≤ T ≤ 1000。 代码水dp，l，r写反了，一直报错 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int dp[100005];int sum[100005];int main() &#123; int l, r, k; while (cin &gt;&gt; l &gt;&gt; r &gt;&gt; k) &#123; memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum)); if (k == 1) &#123; cout &lt;&lt; &quot;Draw&quot; &lt;&lt; endl; continue; &#125; for (int i = 1; i &lt; k; i++) &#123; dp[i] = 1; sum[i] = (sum[i - 1] + 1); &#125; for (int i = k; i &lt;= r; i++) &#123; dp[i] = (dp[i / k] * k + 1); sum[i] = (sum[i - 1] + dp[i]); &#125; if (abs(sum[r] - sum[l - 1]) % 2 == 1) cout &lt;&lt; &quot;XHRlyb&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Cwbc&quot; &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陕西师范大学第七届程序设计竞赛题解]]></title>
    <url>%2F2018%2F05%2F14%2F2018-05-14%2F</url>
    <content type="text"><![CDATA[WWX的520题目描述520，因为谐音为我爱你，所以也被称之为表白日。 这一天，人们借机把藏在心底的洪荒之力通过表白、撒娇、传情、送礼、结婚等形式释放出来，商家也会趁势开展各类优惠促销活动，掀起一波或浪漫或虐狗的节日热浪。 这一天，也是送男朋友礼物、送女朋友礼物、送自己礼物、送亲朋好友礼物的好时机。 在520即将到来之际，wwx准备为她的女朋友购买一批礼物。于是他列出了一份礼物清单，但由于预算有限，必须删掉一种礼物。经过深思熟虑，他决定删掉价格第k高的礼物，你能帮帮他，找出是哪一种礼物吗? 输入描述:1234第一行是一个整数T（1&lt;=T&lt;=80），表示有T组数据.对于每一组数据，首先一行输入N(3&lt;=N&lt;=1000)，接下来的N行每行输入一个字符串和一个整数，以空格间隔，分别作为每种礼物的名字和价格。接下来一行输入k，表示要删去第k(1&lt;=&lt;=N)高的礼物礼物的名字的长度不超过30，礼物的价格不超过1000，且均为整数。 输出描述:12对于每组输入数据，依次输出它的组号和要删去的礼物的名字和价格,以空格间隔。若两种商品的价格相同，则比较礼物名字的字典序大小。即:两种礼物的价格相同时，字典序大者若为第k高，字典序小者则为第k+1高。 示例1 输入12345678910111223Apple 18Book 30Milk 800034Apple 300Bananas 200Bracelet 200Candy 2003 输出12#1: Apple 18#2: Bracelet 200 备注:123451.可用strcmp(s1,s2)函数进行字符串的比较。2.对于样例一中第二组数据:Apple 300是价格第一大，Candy 200是价格第二高，Bracelet200是价格第三大。 题解直接按照价格从大到小排序，如果价格相同按照字母序从大到小排序。排完序之后直接输出第k位的礼物名称与价格即可。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node &#123; string str; int v;&#125;a[1005];int cmp(node a, node b) &#123; if (a.v == b.v) &#123; return a.str&gt;b.str; &#125; return a.v&gt;b.v;&#125;int main() &#123; int t; cin &gt;&gt; t; for (int z = 1; z &lt;= t; z++) &#123; int n, k; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].str; cin &gt;&gt; a[i].v; &#125; sort(a, a + n, cmp); cin &gt;&gt; k; cout &lt;&lt; &quot;#&quot; &lt;&lt; z &lt;&lt; &quot;: &quot; &lt;&lt; a[k - 1].str &lt;&lt; &quot; &quot; &lt;&lt; a[k - 1].v &lt;&lt; endl; &#125; return 0;&#125; 配环境题目描述​ 黑猫在给校赛配环境，结果被服务器的各种入站规则出站规则搞得头疼，想到自己要上传GVIM、EMACS、VSCODE、Jetbrain全家桶、Visual Studio、Gedit、Microsoft Office Word、Eclipse等等，完全不知道要要花费多少时间才能上传完校赛需要的环境。 ​ 黑猫跑去问ddjing，谁知道ddjing说：“我要去实习了，没功夫解决这个问题，你去问问其他人吧。“ ​ 于是黑猫想请你帮他解决这个问题。 ​ 服务器总传输速度为每秒M个单位（本题出现的所有单位都统一），黑猫现在需要上传总共n个软件（按优先级顺序从高到低给出），每个软件的大小分别为v1、v2….vn，每个软件为保持稳定连接，上传需要一个最小的传输速度为m1、m2…mn。 ​ 服务器带宽分配的策略是：按优先级满足每一个软件要求的传输速度。如果服务器剩余的带宽不能满足某个软件最小传输速度的话，服务器将继续寻找下去，直到找到能满足最小传输速度的软件。 ​ 如果目前服务器的总传输速度不能满足所有还需要上传的软件的话，服务器将把传输速度全部给予当前优先级最高的（即使不能满足其最小传输速度）。 ​ 如果目前对所有软件都满足了其最小传输速度的话，服务器将把剩余所有传输速度全部给予当前优先级最高的软件。 输入描述:12345第一行给出一个正整数，表示服务器总带宽M第二行给出整数n，表示需要上传的n个软件。第三行为n个正整数，第i个数表示vi。第四行为n个正整数，第i个数表示mi。( 1 &lt;= M &lt;= 1000, 1 &lt;= n &lt;= 100 , 1 &lt;= vi &lt;= 1000 , 1 &lt;= mi &lt;= 1000 ) 输出描述:1输出一行，为上传完毕所有软件所需要的时间，保留两位小数。 示例1 输入12341061 1 4 5 1 4 10 9 8 7 6 5 输出11.60 示例2 输入123410610 9 8 7 6 51 1 4 5 1 4 输出14.50 题解原本是一道水题，结果成功被题面绕进去了。其实只需要把所有软件的大小V加起来除以宽带大小M即可。所谓最小速度都是迷惑人的。 代码12345678910111213141516#include&lt;stdio.h&gt;int main() &#123; int M, n; scanf(&quot;%d%d&quot;, &amp;M, &amp;n); double tmp, ans = 0; for (int i = 0; i &lt; n;i++) &#123; scanf(&quot;%lf&quot;, &amp;tmp); ans += tmp; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%lf&quot;, &amp;tmp); &#125; ans /= M; printf(&quot;%.2lf\n&quot;, ans); return 0;&#125; 下面是一段超时代码，成功将题面的过程给模拟了出来，当时没仔细看数据是怎么得到的，一直超时很不可思议。因此总结出了经验，以后做题一定得分析出数据是怎么得到的，有时候就很容易找到规律或者发现玄机。另外下面的代码总结出了一个新的方法，就是利用滚动数组实现删除元素，虽然vector有删除功能，但删除效率低。以下的方法是利用滚动数组，将未删除的元素重新压入数组，删除的元素不进行操作，然后清空数组，这样循环操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;#define inf 0x3f3f3f3fint M, n;struct node&#123; double v; int m;&#125;a[1005];int vis[1005];vector&lt;int&gt;vv[2];int main() &#123; cin &gt;&gt; M &gt;&gt; n; double ans = 0, wei; int ff[2] = &#123; 0,1 &#125;; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i].v; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].m; vv[ff[0]].push_back(i); &#125; int flag = 1; while (flag &gt;= 0) &#123; flag = -1; wei = M; double mint = inf; vv[ff[1]].clear(); vector&lt;int&gt;::iterator it; for (it = vv[ff[0]].begin(); it != vv[ff[0]].end(); it++) &#123; if (a[*it].v &lt;= 0) &#123; continue; &#125; vis[*it] = 0; vv[ff[1]].push_back(*it); if (flag &lt; 0) flag = *it; if (a[*it].v &lt;= wei) &#123; vis[*it] = 1; wei -= a[*it].m; if (*it != flag) mint = min(mint, a[*it].v / a[*it].m); &#125; &#125; if (flag &lt; 0) break; mint = min(mint, a[flag].v / (vis[flag] ? a[flag].m + wei : wei)); for (it = vv[ff[1]].begin(); it != vv[ff[1]].end(); it++) &#123; if (a[*it].v &lt;= 0 || !vis[*it] || flag == *it) continue; a[*it].v -= a[*it].m*mint; &#125; a[flag].v -= (vis[flag] ? a[flag].m + wei : wei)*mint; ans += mint; ff[0] = ff[0] ^ ff[1]; ff[1] = ff[0] ^ ff[1]; ff[0] = ff[0] ^ ff[1]; //cout &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; mint &lt;&lt; endl; &#125; printf(&quot;%.2lf\n&quot;, ans); return 0;&#125; iko和她的糖题目描述​ iko超级超级喜欢吃糖，有一天iko想出去玩，她计划从1点走到N点（按1,2,3，…，n的顺序走），每个点都有一个补给站，第i点的补给站有a[i]颗糖，从i点走到i+1点会消耗掉b[i]颗糖，iko在出游的途中可以选择三个补给站，iko想知道她走完全程到达N点时口袋里最多还能剩下几颗糖（初始时iko的口袋里一颗糖都没有）。 输入描述:123第一行输入N（3&lt;=N&lt;=1000）第二行输入N个数代表a[1].......a[N] (0&lt;=a[i]&lt;=1000 )第三行输入N-1个数代表b[1]......b[N-1] ( 1&lt;=b[i]&lt;=1000 ) 输出描述:12输出一个数字表示iko到达n点时口袋里最多剩下的糖，若不能到达N点输出-1。 示例1 输入12331 3 43 4 输出1-1 示例2 输入12353 4 5 2 43 2 2 2 输出13 题解首先，3个补给站必须得选择第1个，因为一开始没有糖，而每条路都需要消耗糖，所以必须拿起点的糖。之后就很好理解了，每走一条路记录当前走过的补给站最大的两个，如果哪一条路糖果不够了，就把最大的补给站加上，如果还不够就把次大的也加上。每次记录走到这条路经过的最大补给站记录下来，然后现有糖果减去消耗的糖果，如果为负就把之前的最大补给站的糖果加上。例如第2组数据，初始是3，走到第1条路剩余糖果为0，此时记录的最大补给站是4，然后走到下一条路糖果变成了-2，那就把最大补给站的加上，现在剩余糖果是2。此时最大补给站记录5，再往下走是2，剩余糖果是0，继续走，消耗2个为-2，则加上最大补给站的糖5。最终就是3。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1005;int N, cur, MAX1, MAX2, flag, a[maxn];void check(int &amp;cnt) &#123; while (cnt&amp;&amp;cur &lt; 0) &#123; cur += MAX1; MAX1 = MAX2; cnt--; &#125;&#125;void fun(int i) &#123; if (MAX1 &lt;= a[i]) &#123; MAX2 = MAX1; MAX1 = a[i]; &#125; else if (MAX2 &lt; a[i]) &#123; MAX2 = a[i]; &#125;&#125;int main() &#123; while (cin &gt;&gt; N) &#123; memset(a, 0, sizeof(a)); MAX1 = -1, MAX2 = -1, flag = 0; int tmp, cnt = 3; cur = 0; for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; N - 1; i++) &#123; fun(i); cin &gt;&gt; tmp; cur -= tmp; if (cur &lt; 0) &#123; check(cnt); &#125; if (cur &lt; 0) flag = 1; &#125; fun(N - 1); if (flag) printf(&quot;-1\n&quot;); else &#123; if (cnt == 2) cur += MAX1 + MAX2; else if (cnt == 1) cur += MAX1; printf(&quot;%d\n&quot;, cur); &#125; &#125; return 0;&#125; ZQ的睡前故事题目描述​ ZQ是一个拥有n女朋友的万人迷，她的每一个女朋友每天晚上都会挨个给他打电话，要他讲了睡前故事才能睡觉。可是，每次他的女朋友都会挑他在吃鸡的时候打电话，ZQ总是因为挂机被舍友赶出宿舍，于是，ZQ告诉他的女朋友们，别打电话了，他会主动打过去给他们讲故事，再打电话就分手！ ​ 于是，ZQ把他的女朋友名字写在纸上，画成一圈，顺时针编号为1~n，然后从1开始顺时针数。在每一次数数中，ZQ数k个就停下来，然后给选中的女朋友打电话讲故事。 输入描述:1先输入一个t，然后t组数据，每行包含两个数字n,k，n&lt;20,k&gt;0 输出描述:1按顺序输出每轮被选中的女朋友的编号。 示例1 输入1234310 35 211 4 输出1233 6 9 2 7 1 8 5 10 42 4 1 5 34 8 1 6 11 7 3 2 5 10 9 题解约瑟夫环。由于数据比较水，所以多种方法求解，这里不介绍了。 代码12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main() &#123; int n, k, t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); int i = 0; int cnt = n; int vis[20] = &#123; 0 &#125;; while (cnt) &#123; int kk = k; while (vis[i%n]) i++; for (int j = 1; j &lt; kk; j++) &#123; i++; while (vis[i%n]) i++; &#125; vis[i%n] = 1; cnt--; cnt ? printf(&quot;%d &quot;, i%n + 1) : printf(&quot;%d\n&quot;, i%n + 1); &#125; &#125; return 0;&#125; 附加：hdu5135 Little Zu Chongzhi’s Triangles题意： 有n条边组三角形，每个三角形必须由3条边组成，三角形边不可以重复利用，不可以共线，只能是分开的三角形。问这n条边组成的所有三角形的面积和最大为多少。 题解原本状压dp求解，但数据比较水，因此递归还没有记忆化搜索直接就过了。每次从n条边里面选择3条边组成三角形，方程maxx[i],[j] = max(maxx[i-1],[j],[1~n] );由于状态是集合，因此需要状压以下。这里主要说的是一个常犯的错误。我没找到vis是当前状态是否已经选过，尤其是搜索时vis的作用非常重要。但本题用深搜时犯了一个错误，就是在vis=1,与vis=0之间多了一个continue，即vis=1，continue，dfs，vis=0，导致状态更改，数据一直错误。正确顺序应该是continue，vis=1，dfs，vis=0。因此之后比赛时一定要注意此细节。在vis=1与vis=0之间一定要注意是否有其他条件导致循环结束而状态还未还原。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n;int vis[15];double a[15];double dfs(int x) &#123; double ans = 0, maxx = 0; for (int i = x; i&lt;n; i++) &#123; if (vis[i]) continue; vis[i] = 1; for (int j = i + 1; j&lt; n; j++) &#123; if (vis[j]) continue; vis[j] = 1; for (int k = j + 1; k&lt;n; k++) &#123; if (vis[k]) continue; if (a[k] &gt;= a[i] + a[j] || a[j] &gt;= a[i] + a[k] || a[i] &gt;= a[j] + a[k]) continue; vis[k] = 1; double c = (a[i] + a[k] + a[j]) / 2.0; ans = sqrt(c*(c - a[i])*(c - a[j])*(c - a[k])); ans += dfs(i + 1); maxx = max(maxx, ans); vis[k] = 0; &#125; vis[j] = 0; &#125; vis[i] = 0; &#125; return maxx;&#125;int main() &#123; while (cin &gt;&gt; n) &#123; if (!n) break; memset(a, 0, sizeof(a)); for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; a[i]; &#125; memset(vis, 0, sizeof(vis)); double ans = dfs(0); printf(&quot;%.2lf\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018计蒜之道初赛第一场A题百度无人车]]></title>
    <url>%2F2018%2F05%2F12%2F2018-05-12%2F</url>
    <content type="text"><![CDATA[百度无人车百度一共制造了 n 辆无人车，其中第 ii 辆车的重量为 a_i\ \mathrm{kg}ai kg。 由于车辆过重会增大轮胎的磨损程度，现在要给这 n 辆车减轻重量。每将一辆车减轻 1\ \mathrm{kg}1 kg需要消耗 p 万百度币，总预算为 s 万百度币。 现在希望你设计一种最优的减重方案，使得最重的车辆的重量是所有减重方案中最小的。任何时候，每辆车的重量必须大于等于 1\ \mathrm{kg}1 kg。并且减重方案只能减轻整数 \mathrm{kg}kg。 输入格式第一行输入一个整数 n，表示百度无人车的数量。 接下来一行输入 n 个整数，其中第 ii 个整数 a_iai表示第 ii 辆车的重量。 接着一行输入两个整数 p,s，分别表示把一辆车减重 1\ \mathrm{kg}1 kg 需要花费 p 万百度币，总的预算是 s 万百度币。 保证 1 \le n \le 200001≤n≤20000，1 \le a_i \le 200001≤ai≤20000，1 \le p \le 200001≤p≤20000，1 \le s \le 10^{18}1≤s≤1018。 输出格式输出一个整数，表示经过你设计的最优减重方案后，最重的车辆的重量是多少 \mathrm{kg}kg。 样例输入112346 7 8 91 3 样例输出117 样例输入2123511 14 6 13 114 68 样例输出218 题解每1kg消耗p元，一共s元，因此一共可以减s/p（kg），直接s=s/p就行了。先对整个数组进行排序，然后再进行操作。一开始用二分，时间复杂度Onlogn，通不过，因此换了一种线性的方法，时间复杂度On。首先建一个差分数组，储存该元素和前一个元素的差值。以1， 2， 4， 6， 9为例，差分数组为1,1,2,2,3。然后从后往前操作。假设s=s/p之后s为10，首先s与第n个元素差分数组比较，如果大，则s-3=7。再和第n-1比较，由于该位置后面还有一个元素，因此若要改变该元素使最大值变小，需同时改变这两个数，后面以此类推三个四个数等等。s和b[n-1]2即2 2比较，大，则s=7-22=3。再和b[n-2] 3比较。比它小，则证明最大部分再该部分。b[n-2]=b[n-2]-s/3即1，结束循环。现在的差分数组为1,1,1,0,0，现在依次从从b[1]加到b[n就好了，即3。另外由于最小值为1，因此需要对第一个元素特判一下，如果小于1需改为1。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 200007;typedef long long ll;int a[maxn], b[maxn];ll p, s, n;int main() &#123; cin &gt;&gt; n; a[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; i++) &#123; b[i] = a[i] - a[i - 1]; &#125; cin &gt;&gt; p &gt;&gt; s; s /= p; ll ans = 0; for (int i = n; i&gt;0; i--) &#123; if (s &gt;= b[i] * (n - i + 1)) &#123; s -= b[i] * (n - i + 1); b[i] = 0; &#125; else &#123; b[i] -= s / (n - i + 1); for (int j = 2; j &lt;= i; j++) ans += b[j]; break; &#125; if (i == 1 &amp;&amp; b[i] &lt;= 1) break; &#125; if (b[1] &lt;= 1) b[1] = 1; ans += b[1]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>差分数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛15]]></title>
    <url>%2F2018%2F05%2F11%2F2018-05-11%2F</url>
    <content type="text"><![CDATA[最小化价格题目描述 要求一种方式，使得每组人都到一个各不相同的地点，最小化选择的价格 每个队伍的人都要在同一个地方每个地方只能有一个队伍 输入描述:123第一行n,m第二行n个数，表示每组的人数接下来m行，每行两个数，表示可容纳的最大人数和选择的价格 输出描述:1输出最小化选择的价格，无解输出-1 示例1 输入1234563 42 3 41 22 33 44 5 输出112 备注:1所有数据小于1e5 题解首先对地点以价格从小到大排序，如果相同按容量从小到大排序。由于集合每次插入自动排序，而且可以执行删除操作，因此我们可以用集合储存队伍。然后将队伍放入集合中。对排完序的地点进行遍历，每个地点对容量进行判断，直接对集合up_bound-1操作，就是能被该地点容纳的人数最多的队伍。若存在该队伍，将该队伍从集合中删除，意为该队伍匹配到该地点。然后将总价格加上该地点所需的价格。否则不执行操作，意为当前没有队伍能和该地点匹配。最后对集合判断是否为空，若为空，则证明队伍已经匹配完毕，输出总价格即可，否则意为不是所有队伍都能被容纳，输出-1。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;int const maxn = 100020;struct node &#123; int pri; int num;&#125;loc[maxn];int cmp(node a, node b) &#123; if (a.pri == b.pri) return a.num &lt; b.num; else return a.pri &lt; b.pri;&#125;int main()&#123; int n, m, tmp, ans = 0; cin &gt;&gt; n &gt;&gt; m; multiset&lt;int&gt;a; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; a.insert(tmp); &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; loc[i].num &gt;&gt; loc[i].pri; &#125; sort(loc, loc + m, cmp); multiset&lt;int&gt;::iterator it; for (int i = 0; i &lt; m; i++) &#123; if (a.empty()) break; it = a.upper_bound(loc[i].num); if (it == a.begin()) continue; it--; ans += loc[i].pri; a.erase(it); &#125; if (a.empty()) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; return 0;&#125; 车辆安排题目描述有n个队伍，每个队伍的人数小于等于5，每辆车最多坐5个人，要求一个队伍的人都在一辆车上，求最少的车数 输入描述:12第一行n第二行n个数，表示每个队伍的人数 输出描述:1输出最少车数 示例1 输入1233 4 5 输出13 备注:12n≤1e5每个数小于等于5 题解设置一个数组，分别储存1,2,3,4,5人队伍的个数。总车数=人数为5的队伍数+（人数为4+1或4的队伍数）+（人数为3+2或3+1+1或3的队伍数）+（人数为2+2+1或2+1+1+1或2的队伍数）+（人数为1*5或1的队伍数），（组合方式按优先级排列）。时间复杂度O(1)。 代码123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main() &#123; int n, tmp; scanf(&quot;%d&quot;, &amp;n); int a[6] = &#123; 0 &#125;, sum = 0; while (n--) &#123; scanf(&quot;%d&quot;, &amp;tmp); a[tmp]++; &#125; sum += a[5] + a[4] + a[3]; a[1] = a[1] - a[4]; if (a[3] - a[2] &gt; 0) a[1] -= 2 * (a[3] - a[2]); a[2] -= a[3]; if (a[2] &lt; 0) a[2] = 0; a[1] -= a[2] / 2; if (a[2] % 2 == 0) &#123; sum += a[2] / 2; &#125; else &#123; sum += a[2] / 2 + 1; a[1] -= 3; &#125; if (a[1] &lt; 0) a[1] = 0; a[1] % 5 == 0 ? sum += a[1] / 5 : sum += a[1] / 5 + 1; printf(&quot;%d\n&quot;, sum); return 0;&#125; 出队题目描述约瑟夫问题(约瑟夫问题)，n个人，1 2报数 1出队( 就是体育课的时候1 2报数 1出队，2留下)，q次询问，每次求第x个人是第几个出队的 输入描述:12第一行两个数n,q接下来q行，每行一个数x，表示询问 输出描述:1一行输出一个询问的答案 示例1 输入12344 3234 输出123324 说明11 2 3 4围成一圈，第一轮：1 2报数，1出队，2留下，3出队，4留下，第二轮，2出队，4留下 备注:12q≤500000n和x≤1e18 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;#define ll unsigned long long intmap&lt;ll, ll&gt;ma;vector&lt;ll&gt;v;int main()&#123; int n, q , cnt; cin &gt;&gt; n &gt;&gt; q; ma[1] = 1; cnt = 1; for (int i = 2; i &lt;= n; i++) &#123; if (i % 2 == 0) v.push_back(i); else &#123; ma[i] = ++cnt; &#125; &#125; ll it = 0; if (n % 2) it++; while (!v.empty()) &#123; if (it == v.size()) it = 0; ma[*(v.begin() + it)] = ++cnt; v.erase(v.begin() + it); if (v.empty()) break; if (it == v.size()) it = 0; it++; &#125; while (q--) &#123; int x; cin &gt;&gt; x; cout &lt;&lt; ma[x] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[计算几何]二维计算几何基础]]></title>
    <url>%2F2018%2F05%2F09%2F2018-05-09%2F</url>
    <content type="text"><![CDATA[三寸青笺，写不尽对你的思念。——随笔 用解析几何借助计算机处理几何问题存在着两大缺陷： 1）方程解的情况复杂，例如Ax+By+C=0； 2）存在着浮点误差积累。 计算几何采用了介于代数与几何之间的方式解决几何问题。它利用几何特性辅助简单的代数运算解决几何问题，既能精确求解，有提高了算法效率，并且不失几何的优美特性。 向量向量向量：既有大小又有方向的量。 向量的比较在平面坐标系下，某点的坐标用（x，y）表示，向量和点一样，也可以用x,y表示。 12345struct Point&#123; //点 double x,y; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; //构造函数方便代码编写&#125;;typedef Point Vector; //向量。从程序实现上，Vector只是Point的别名 向量的加减乘除12345678910111213141516//向量+向量=向量，点+向量=点Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y);&#125;//点-点=向量Vector operator - (Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y);&#125;//向量*数=向量Vector operator * (Vector A, double p) &#123; return Vector(A.x * p, A.y * p);&#125;//向量/数=向量Vector operator / (Vector A, double p) &#123; return Vector(A.x / p, A.y / p);&#125; 向量的比较123456789101112131415bool operator &lt; (const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x&amp;&amp;a.y &lt; b.y);&#125;//减下误差的必要比较const double eps=1e-8;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; if(x&gt;0) return 1; return -1;&#125;bool operator ==(const point&amp; a,const point&amp; b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125; 注意上面的“相等”函数用到“三态函数”dcmp,减少了精度问题。另外，向量有一个所谓的“极角”，即从x轴正半轴旋转到该向量方向所需要的角度。C标注库里的atan2函数就是用来求极角的。如向量（x,y）的极角就是atan2（y，x）（单位：弧度） 向量內积（点积）点积，向量α和β的点积等于二者长度的乘积再乘上它们夹角的余弦。当夹角大于90°时点积为负。两向量的点积为一个标量 α·β，它的大小为α·β=|α||β|cosθ，其中θ是&lt;α,β&gt; 余弦为偶函数，因此点积满足交换率。如果两向量垂直，点积为0。 几何意义α在β的投影α’与β的长度乘积 由定义易知当两向量夹角为锐角时点积值为正，夹角钝角为负，垂直为0 123456789double dot(Vector A,Vector B)&#123; //向量点积 return A.x*B.x+A.y*B.y;&#125;double Length(Vector A)&#123; //向量A长度 return sqrt(dot(A,A));&#125;double angle(Vector A,Vector B)&#123; //向量A和B夹角 return acos(dot(A,B)/Length(A)/Length(B));&#125; 向量外积（叉积）简单地说，两个向量u和w得叉积等于u和w组成的三角形的有向面积的两倍。 叉积的二维意义—-有向面积：外积大小为由u，w这两个向量围成的平行四边形有向面积。 两向量的叉积为一个矢量 a×b，设向量 P(x1,y1),Q(x2,y2)，向量 a 和向量 b 的叉积还是一个向量，长度为|PQ|=x1y2-x2y1;即为向量 P,Q 围成的四边形的面积。它的方向与向量PQ 垂直，并且使(P,Q,P×Q)成右手系。 几何意义 不难发现，叉积不满足交换率，cross（u，w）=-corss（w，u）。 12345678double cross(Vector A,Vector B) //叉积&#123; return A.x*B.y-A.y*B.x;&#125;double area(point A,point B,point C) //已知三个点 p0,p1,p2 的叉积函数&#123; return cross(B-A,C-A);&#125; 叉积的一个重要性质，判断两向量互相之间的顺逆时针关系。若 P×Q&gt;0，则P在Q 的顺时针方向；若 P×Q&lt;0，则P在Q 的逆时针方向；若 P×Q=0，则P和Q 共线，但可能同向也可能反向； 利用这一性质，可以将一个多边形的顶点按照顺时针或者逆时针方向排序，这就是极角排序。利用 sort 或者 qsort 函数，自己定义 cmp 函数即可。 12345678910//逆时针极角排序比较函数(double) bool cmp(const point &amp;a, const point &amp;b) &#123; double x = atan2(a.y, a.x), y = atan2(b.y, b.x); return x &lt; y; &#125; //象限极角排序比较函数(int)，不失精度 int cross(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y); &#125; sort(p+1,p+n,cmp); 两向量的位置关系把叉积和点积组合在一起，很容易判断两向量的位置关系。如图所示，括号第一个数是点积的符号，第二个是叉积的符号。第一个向量u总是向右，另一个向量w的各种情况都包含在了图中。比如当w的中点在下图左上方的第二象限时点积为负担叉积均为正，用（-，+）表示。 点和直线点到直线的距离点到直线的距离是一个常用函数，可以用叉积求出，即用平行四边形的面积除以底。代码如下： 12345double DistoLine(point P,point A,point B) //点p到直线AB距离&#123; Vector v1=B-A,v2=P-A; return fabs(cross(v1,v2))/Length(v1); //如果不取绝对值，得到的是有向距离&#125; 点到线段的距离点到线段有两种可能： 简单地说，设投影点为Q，如果Q在线段AB上，则所求距离就是P点直线AB的距离（右）。如果Q在射线BA上，则所求为PA距离；否则为PB距离。判断Q的位置可以用点积进行。 1234567double DistoSegment(point P,point A,point B)&#123; if(A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if(dcmp(dot(v1,v2))&lt;0) return Length(v2); if(dcmp(dot(v1,v3))&gt;0) return Length(v3); return fabs(cross(v1,v2))/Length(v1);&#125; 判断点是否在线段上判断点 Q 在线段 P1P2 上的两条依据：①(Q-P1)*(P2-P1)=0;②Q 在以 P1,P2 为对角顶点的矩形内。 12345bool onSegment(point p1,point p2,point Q)&#123;if( (Q.x-p1.x)*(p2.y-p1.y)==(p2.x-p1.x)*(Q.y-p1.y)&amp;&amp;min(p1.x,p2.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(p1.x,p2.x)&amp;&amp;min(p1.y,p2.y)&lt;=Q.y&amp;&amp;Q.y&lt;= max(p1.y,p2.y) )return 1;else return 0;&#125; 线段相交最为直观的想法：解析几何法 弊端：运算误差大，运算次数多 误差来源：浮点运算 另外，编程难度事实上也很大（区域判断） 计算几何做法：运用叉积点积和位置关系 线段规范相交定义线段规范相交为两线段相交恰好有一个公共点且不是任一线段的端点 充要条件：每条线段的两个端点都在另一条线段的两侧 只有（1）是规范相交，其它是非规范相交。非规范相交的情况还有很多。 跨立实验 规范相交123456bool SegmentItersection(point a1, point a2, point b1, point b2)&#123; double c1 = cross(a2-a1, b1-a1), c2 = cross(a2-a1, b2-a1), c3 = cross(b2-b1, a1-b1), c4 = cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125; 线段相交如果允许在端点处相交怎么办？ 首先可能共线重叠 其次就是交点是端点 如果交点是端点 就判断几次点是否在线段上 12345//判断点p是否在线段a1 a2上bool OnSegment(point p,point a1,point a2)&#123; return dcmp(cross(a1-p,a2-p))==0&amp;&amp;dcmp(dot(a1-p,a2-p))&lt;0; //线段包含端点时改成&lt;=&#125; 多边形问题多边形面积两向量的叉积的几何意义是以这两个向量为邻边的平行四边形的有向面积，我们可以利用这一点来求简单多边形的面积。所谓简单多边形就是任何不相邻的两条边都没有交点，包括凸多边形和凹多边形。 求下面多边形的面积，已知个顶点的坐标。 注意：在引入叉积后，面积就可以为负值，就有了“负面积”的概念。“负面积”方便了我们的运算。 可以取p[0]点为划分顶点，一方面可以少算两个叉积（0和任何向量的叉积都等于0），另一方面也减少乘法溢出的可能性，还不用特殊处理（i=n-1时，下一个顶点p[0]而不是p[n]，因为p[n]不存在） 12345678//取p[0]为划分顶点double PolygonArea(vector&lt;Point&gt; p) &#123; int n = p.size(); double area = 0; for(int i = 1; i &lt; n-1; i++) area += Cross(p[i]-p[0], p[i+1]-p[0]); return area/2;&#125; 也可以取坐标原点为划分点，乘法次数减少。 点在多边形内外判断判断点是否在三角形内点 P 在三角形 ABC 内部常用的又两种方法，面积法和叉积法，面积法即为 S△PAB+S△PAC+S△PBC=S△ABC 其中三角形面积计算公式为 S=1/2×|cross(a,b)| 叉积法 利用叉积的正负号判断，如图所示，AP 在向量 AC 的顺时针方向，CP 在向量 BC 的顺时针方向，BP 在向量 BC 的顺时针方向，利用这一性质推广，那么可以利用叉积的正负号来判断一个点是否在一个凸多边形内部。 判断点是否在多边形内一般而言，该问题有射线法和转角法两种处理手段 射线法：从这个点出发引向无穷远点一条直线，根据交点情况确定点的位置 转角法：计算多边形每条边的转角，若最后相消为0则在外部，否则在内部 射线法：特殊情况不易处理 转角法：三角运算时间开销大 射线法以要判断的点为起点任作一射线，计算该射线与多边形的交点数目。 若有偶数个交点则在形外，否则在形内。 若与线段在端点处相交或重合，则要进行复杂的判断。此时可另取一射线。 转角法把多边形每条边的转角加起来，如果是360度，就在多边形内，如果是0度就在外面，180度则是在边界上 直接最要求角度用到反三角函数精度差且费时 改进假设有一条向右的射线，统计多边形穿过这条射线正反多少次，把这个数记为绕数wn，逆时针穿过时，wn加1，顺时针穿过时，wn减1。 注意在程序实现时，判断是否穿过，以及穿过方向时，需要用叉积判断输入点在左边还是右边。 实现代码12345678910111213141516int isPointinPolygon(point p,vector&lt;point&gt;poly)&#123; int wn=0; int n=poly.size(); for (int i=0;i&lt;n;i++) &#123; if (OnSegment(p,poly[i],poly[(i+1)%n])) return -1; //边界 int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i])); int d1=dcmp(poly[i].y-p.y); int d2=dcmp(poly[(i+1)%n].y - p.y); if (k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++; if (k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--; &#125; if (wn!=0) return 1; //内部 return 0; //外部&#125; 点在凸多边形内的判定更简单，只需判断是否在所有边的左边（假设各个顶点按照逆时针顺序排列） 多边形重心三角形重心 多边形重心将多边形拆分为N个三角形，分别求其重心和面积，可以想象，原来的质量均匀分布在内部的区域上，而现在质量仅分布在这N个重心点上（等价变换），这时就可以利用刚才猜想的公式了。 12345678910111213point PolyGravity(point *p,int n)&#123; point ans=point(0,0); double sumArea=0,area; for(int i=2;i&lt;n;i++) &#123; area=cross(p[i-1]-p[0],p[i]-p[0]); sumArea+=area; ans.x+=(p[0].x+p[i-1].x+p[i].x)*area; ans.y+=(p[0].y+p[i-1].y+p[i].y)*area; &#125; return ans/(sumArea*3);&#125; 解析几何交点的计算：求两线段，两直线，线段和直线的交点①判断两线段是否相交：我们分两步确定两条线段是否相交：(1)快速排斥试验设以线段 P1P2 为对角线的矩形为 R， 设以线段 Q1Q2 为对角线的矩形为 T，如果R和T不相交，显然两线段不会相交。(2)跨立试验如果两线段相交，则两线段必然相互跨立对方。若 P1P2 跨立 Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，即 ( P1 - Q1 ) × ( Q2 - Q1 ) ( P2 - Q1 ) × ( Q2 - Q1 ) &lt; 0。上式可改写成 ( P1 - Q1 ) × ( Q2 - Q1 ) ( Q2 - Q1 ) × ( P2 - Q1 ) &gt; 0。当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2 上；同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2 上。所以判断 P1P2 跨立 Q1Q2 的依据是： ( P1 - Q1 ) × ( Q2 - Q1 ) ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。同理判断 Q1Q2 跨立 P1P2 的依据是：( Q1 - P1 ) × ( P2 - P1 ) ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。 另外，“规范相交”指的是两条线段恰有唯一一个不是端点的公共点；而如果一条线段的一个端点在另一条线段上，或者两条线段部分重合，则视为“非规范相交”，以下代码是“非规范相交”。 结合 poj2653 练习，代码可参考： 12345678910111213141516const double eps = 1e-10;struct point &#123; double x, y; &#125;;struct Line &#123; point begin, end; &#125;line[100001];double min(double a, double b) &#123; return a&lt;b ? a : b; &#125;double max(double a, double b) &#123; return a&gt;b ? a : b; &#125;bool inter(const Line &amp; M, const Line &amp; N) &#123; point a = M.begin; point b = M.end; point c = N.begin; point d = N.end; if (min(a.x, b.x) &gt; max(c.x, d.x) || min(a.y, b.y)&gt;max(c.y, d.y) || min(c.x, d.x)&gt;max(a.x, b.x) || min(c.y, d.y) &gt; max(a.y, b.y)) return 0; double h, i, j, k; h = (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x); i = (b.x - a.x)*(d.y - a.y) - (b.y - a.y)*(d.x - a.x); j = (d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x); k = (d.x - c.x)*(b.y - c.y) - (d.y - c.y)*(b.x - c.x); return h*i &lt;= eps&amp;&amp;j*k &lt;= eps;&#125; ②判断两直线是否相交：首先判断两条直线是否在一条直线上，或者两条直线平行，否则一定相交，不平行且不在一条直线上则相交并且求出交点。可结合 hrbustoj1104 练习，代码可参考： 123456789101112131415161718192021222324#include&lt;stdio.h&gt; int main() &#123; int t; double x1, x2, x3, x4, y1, y2, y3, y4, x, y; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x3, &amp;y3, &amp;x4, &amp;y4); if ((x2 - x1)*(y4 - y3) == (x4 - x3)*(y2 - y1)) &#123; if ((x3 - x1)*(y4 - y2) == (x4 - x2)*(y3 - y1) &amp;&amp; (y4 - y3) != 0) puts(&quot;LINE&quot;);//在一条直线的情况 else puts(&quot;NONE&quot;);//平行的情况 &#125; else &#123; x = ((y1*(x2 - x1) - x1*(y2 - y1))*(x4 - x3) - (y3*(x4 - x3) - x3*(y4 - y3))*(x2 - x1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3)); y = ((y1*(x2 - x1) - x1*(y2 - y1))*(y4 - y3) - (y3*(x4 - x3) - x3*(y4 - y3))*(y2 - y1)) / ((y4 - y3)*(x2 - x1) - (y2 - y1)*(x4 - x3)); printf(&quot;POINT %.2f %.2f\n&quot;, x, y); &#125; &#125; return 0;&#125; ③判断线段和直线的交点：poj1039 判断直线和线段是否相交并求出交点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define eps 1.0e-8 struct Point &#123; double x, y;&#125; point[25];int n;double ans;bool ok;double intersect(Point a1, Point b1, Point a2, Point b2) &#123; double x1 = a1.x, x2 = b1.x, x3 = a2.x, x4 = b2.x; double y1 = a1.y, y2 = b1.y, y3 = a2.y, y4 = b2.y; double x = (y3 - y1 + x1*(y2 - y1) / (x2 - x1) - x3*(y4 - y3) / (x4 - x3)) / ((y2 - y1) / (x2 - x1) - (y4 - y3) / (x4 - x3)); return x;&#125;void work(Point a, Point b) &#123; b.y -= 1; for (int i = 0; i&lt;n; i++) &#123; Point p, q1, q2; p.x = point[i].x; p.y = a.y - (b.y - a.y) / (b.x - a.x)*(a.x - p.x); if ((p.y + eps&lt;point[i].y&amp;&amp;p.y - eps&gt;point[i].y - 1) || abs(p.y - point[i].y)&lt;eps || abs(p.y - point[i].y + 1)&lt;eps) continue; if (i == 0) return; if (p.y - eps&gt;point[i].y) ans = max(ans, intersect(a, b, point[i - 1], point[i])); else &#123; q1 = point[i - 1]; q1.y -= 1; q2 = point[i]; q2.y -= 1; ans = max(ans, intersect(a, b, q1, q2)); &#125; return; &#125; ok = true;&#125;int main() &#123; while (scanf(&quot;%d&quot;, &amp;n), n) &#123; for (int i = 0; i&lt;n; i++) scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y); ans = point[0].x; ok = false; for (int i = 0; i&lt;n; i++) for (int j = 0; j&lt;n; j++) if (i != j&amp;&amp;!ok) work(point[i], point[j]); if (ok) printf(&quot;Through all the pipe.\n&quot;); else printf(&quot;%.2f\n&quot;, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>点积/叉积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[博弈论]博弈论基本题型及5大常见博弈论原理]]></title>
    <url>%2F2018%2F05%2F08%2F2018-05-08%2F</url>
    <content type="text"><![CDATA[取石子游戏根据题目的意思，看它属于哪种博弈，属于哪种博弈的变形。 然后根据对应的博弈模型的解题策略来求解， 有时候并不一定能够直接看出它属于哪种模型，那这个时候就可以通过判断自己每步可选的策略，对于自己每步走的，对当前局势的影响。然后推断出与之相对应的博弈模型。 巴什博奕（Bash Game）有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。 假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。 胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 12345678910111213#include &lt;iostream&gt; using namespace std;int main() &#123; int iCase; cin &gt;&gt; iCase; while (iCase--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl; &#125; return 0;&#125; 威佐夫博奕（Wythoff Game）有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 2。任意操作都可将奇异局势变为非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。 如何判定是否是奇异局势呢？ 有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 其中（1+√5）/2 = 1.618…,即为黄金分割数。因此,由 ak，bk 组成的矩形近似为黄金矩形，由于 2/（1+√5）=（√5-1）/2，可以先求出 j=[a（√5-1）/2]，若a=[ j（1+√5）/2]，那么 a = aj，bj = aj + j，若不等于，那么 a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 1234567891011121314151617181920#include &lt;stdio.h&gt; #include &lt;math.h&gt; const double ep1 = (sqrt(5.0) - 1.0) / 2.0;const double ep2 = (sqrt(5.0) + 1.0) / 2.0;int main() &#123; int m, n; while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123; if (m &gt; n) &#123; int tmp; tmp = m, m = n, n = tmp; &#125; int id = m * ep1; int tmp1 = ep2 * id, tmp2 = id + tmp1; int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3; if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;); else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;); else printf(&quot;1\n&quot;); &#125; return 0;&#125; 斐波那契博弈（Fibonacci Nim）有一堆个数为 n 的石子，游戏双方轮流取石子，满足 1)先手不能在第一次把所有的石子取完； 2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。 约定取走最后一个石子的人为赢家，求必败态。 这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 证明： 这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 FIB 数列的必败证明： 1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std;long long int f[50];int main() &#123; int n, i; f[0] = f[1] = 1; for (i = 2; i &lt; 50; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; while (cin &gt;&gt; n) &#123; if (n == 0) break; for (i = 0; i &lt; 50; i++) &#123; if (f[i] == n) break; &#125; if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl; &#125; return 0;&#125; K倍博弈共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。 当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1，然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。 当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。 设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; using namespace std;const int maxn = 2000000;int a[maxn], b[maxn];int main()&#123; int n, k; int cas = 0, cass; for (scanf(&quot;%d&quot;, &amp;cass); cass--;) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ++cas; printf(&quot;Case %d: &quot;, cas); int i = 0, j = 0; a[0] = b[0] = 1; while (a[i]&lt;n) &#123; i++; a[i] = b[i - 1] + 1; while (a[j + 1] * k&lt;a[i]) j++; if (a[j] * k&lt;a[i]) b[i] = a[i] + b[j]; else b[i] = a[i]; &#125; if (a[i] == n) puts(&quot;lose&quot;); else puts(&quot;win&quot;); &#125; return 0;&#125; ＳＧ函数的求解(SG博弈）给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。 这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。 下 面我们就在有向无环图的顶点上定义 Sprague-Garundy 函数。首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的 Sprague-Grundy 函数 g如下：g(x)=mex{ g(y) | y 是 x 的后继 }。 SG 函数的性质： 1.首先，所有的 terminal position 所对应的顶点，也就是没有出边的顶点，其 SG 值为 0，因为它的后继集合是空集。 2.然后对于一个 g(x)=0 的顶点 x，它的所有后继 y 都满足 g(y)!=0。 3.对于一个 g(x)!=0 的顶点，必定存在一个后继 y 满足 g(y)=0。 以上这三句话表明，顶点 x 所代表的 postion 是 P-position 当且仅当 g(x)=0。我们通过计算有向无环图的每个顶点的 SG 值，就可以对每种局面找到必胜策略了。 Nim 游戏的规则：每次选择 一堆数量为 k 的石子，可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k不变。 变形假设不是一枚棋子，而是n枚棋子，如何获胜？ 让我们再来考虑一下顶点的 SG 值的意义。当 g(x)=k 时，表明对于任意一个0&lt;=i&lt;k，都存在 x 的一个后继 y 满足 g(y)=i。也 就是说，当某枚棋子的 SG 值是 k 时，我们可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k 不变。 这表明，如果将 n 枚棋子所在的顶 点的 SG 值看作 n 堆相应数量的石子，那么这个 Nim 游戏的每个必胜策略都对应于原来这 n 枚棋子的必胜策略！ 对于 n 个棋子，设它们对应的顶点的 SG 值分别为(a1,a2,…,an)，再设局面(a1,a2,…,an)时的 Nim 游戏的一种必胜策略是把 ai 变成 k，那么原游戏的一种必胜策略就是把第 i 枚棋子移动到一个 SG 值为 k 的顶点。 其实我们还是只要证明这种多棋子的有向图游戏的局面是 P-position 当且仅当所有棋子所在的位置的 SG 函数的异或为 0。这个证明与上节的 Bouton’s Theorem 几乎是完全相同的，只需要适当的改几个名词就行了。 刚才，我为了使问题看上去更容易一些，认为 n 枚棋子是在一个有向图上移动，但如果不是在一个有向图上，而是每个棋子在一个有向图上，每次可 以任选一个棋子（也就是任选一个有向图）进行移动，这样也不会给结论带来任何变化。 所以我们可以定义有向图游戏的和(Sum of Graph Games)：设 G1、G2、……、Gn是 n 个有向图游戏，定义游戏 G 是 G1、G2、……、Gn 的和(Sum)，游戏 G的移动规则是：任选一个子游戏 Gi 并移动上面的棋子。Sprague-Grundy Theorem 就是：g(G)=g(G1)^g(G2)^…^g(Gn)。也就是说，游戏的和的 SG 函数值是它的所有子游戏的 SG 函数值的异或。 再考虑在本文一开头的一句话：任何一个 ICG 都可以抽象成一个有向图游戏。所以“SG 函数”和“游戏的和”的概念就不是局限于有向图游戏。我们给每 个 ICG 的每个 position 定义 SG 值，也可以定义 n 个 ICG 的和。所以说当我们面对由 n 个游戏组合成的一个游戏时，只需对于每个游戏找出求它的每个 局面的 SG 值的方法，就可以把这些 SG 值全部看成 Nim 的石子堆，然后依照找 Nim 的必胜策略的方法来找这个游戏的必胜策略了！ NIM游戏有 n 堆石子，每次可以从第 1 堆石子里取 1 颗、2 颗或 3颗，可以从第 2 堆石子里取奇数颗，可以从第 3 堆及以后石子里取任意颗… … 我们可以把它看作 3 个子游戏，第 1 个子游戏只有一堆石子，每次可以取 1、2、3颗，很容易看出 x 颗石子的局面的 SG 值是 x%4。第 2 个子游戏也是只有一 堆 石子，每次可以取奇数颗，经过简单的画图可以知道这个游戏有 x 颗石子时的 SG值是 x%2。第 3 个游戏有 n-2 堆石子，就是一个 Nim 游戏。对于原游戏的每 个局面，把三个子游戏的 SG 值异或一下就得到了整个游戏的 SG 值，然后就可以根据这个 SG 值判断是否有必胜策略以及做出决策了。其实看作 3 个子游戏还是保守了些，干脆看作 n 个子游戏，其中第 1、2 个子游戏如上所述，第 3 个及以后的子游戏都是“1 堆石子，每次取几颗都可以”，称为“任取石子游戏”，这个超简 单的游戏有 x 颗石子的 SG 值显然就是 x。其实，n 堆石子的 Nim 游戏本身不就是 n 个“任取石子游戏”的和吗？ 总结SG 函数与“游戏的和”的概念不是让我们去组合、制造稀奇古怪的游戏，而是把遇到的看上去有些复杂的游戏试图分成若干个子游戏，对于每个比原游戏简化很多的子游戏找出它的 SG 函数，然后全部异或起来就得到了原游戏的 SG 函数，就可以解决原游戏了。 HDU 3032 Nim or not NimLasker’s Nim 游戏：每一轮允许两会中操作之一：①、从一堆石子中取走任意多个，②、将一堆数量不少于 2 的石子分成都不为空的两堆。 很明显：sg(0) = 0，sg(1) = 1。 状态 2 的后继有：0，1 和（1，1），他们的 SG 值分别为 0，1，0，所以 sg(2)=2。 状态 3 的后继有：0、1、2、（1，2），他们的 SG 值分别为 0、1、2、3，所以sg(3) = 4。 状态 4 的后继有：0、1、2、3、（1，3）和（2，2），他们的 SG 值分别为 0，1，2，4，5，0，所以 sg(4) = 3. 由数学归纳法可以得出 sg(4k)=4k-1;sg(4k+1)=4k+1;sg(4k+2)=4k+2;sg(4k+3)=4k+4; 12345678910111213141516171819#include &lt;iostream&gt; using namespace std;int main() &#123; int iCase; cin &gt;&gt; iCase; while (iCase--) &#123; int n, cnt = 0, num; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; num; if (num % 4 == 0) num--; else if (num % 4 == 3) num++; cnt ^= num; &#125; if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; &#125; return 0;&#125; 寻找必败态必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。 必败态和胜态有着如下性质： 1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。 解题思路分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>博弈论</tag>
        <tag>SG函数</tag>
        <tag>NIM游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]数论与与组合数学与线性代数中的常用算法总结]]></title>
    <url>%2F2018%2F05%2F07%2F2018-05-07%2F</url>
    <content type="text"><![CDATA[数论欧几里得算法（gcd）欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b) 证明设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b) 应用如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。 代码123456789101112131415//递归版int gcd(int a, int b) &#123; return b ? a : gcd(b, a%b);&#125;//非递归版int gcd(int a, int b) &#123; if (!a) return b; while (b) &#123; int temp = b; b = a%b; a = temp; &#125; return a;&#125; 扩展欧几里得算法（exgcd）若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1a+0b,因为 gcd(a,b)=gcd(b,a%b)则有 xa+yb=x1b+y1(a%b) 。将等式右边变形，bx1+(a%b)y1=bx1+(a-(a/b)b)y1=ay1+b(x1-(a/b)y1)则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y 应用对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)t,y-y0-a/gcd(a,b)t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。 代码1234567891011121314int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a%b, x, y); int t = x; x = y; y = t - a / b*y; return d;&#125; 筛法求素数筛素数的基本方法是用来筛选出一定范围内的素数 原理利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。 123456789101112131415161718bool isprime[N];//N 表示范围int prime[N], cnt;void f()&#123; int i, j; cnt = 0; memset(isprime, true, sizeof(isprime)); isprime[1] = false; for (i = 2; i &lt;= N; i++) &#123; if (isprime[i]) &#123; prime[cnt++] = i;//记录素数 for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了 isprime[j] = false; &#125; &#125;&#125; 快速幂快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。 原理 假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0a2^1a2^3，也就是a1 a2 a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。 12345678910int poww(int a, int b) &#123; int ans = 1, base = a; while (b != 0) &#123; if (b &amp; 1 != 0) ans *= base; base *= base; b &gt;&gt;= 1; &#125; return ans;&#125; 以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)a^(2^1)a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。 其中要理解base =base这一步：因为 base base==base2，下一步再乘，就是base2 base2==base4，然后同理 base4 base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1a2a8，这三项就可以完美解决了 矩阵快速幂矩阵乘法 简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C 其中c[i][j]为A的第i行与B的第j列对应乘积的和，即: 12345678910const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N &#123; memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; &#125; 方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。 1234567891011121314151617181920212223242526const int N=10; int tmp[N][N]; void multi(int a[][N],int b[][N],int n) &#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) tmp[i][j]+=a[i][k]*b[k][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) a[i][j]=tmp[i][j]; &#125; int res[N][N]; void Pow(int a[][N],int n) &#123; memset(res,0,sizeof res);//n是幂，N是矩阵大小 for(int i=0;i&lt;N;i++) res[i][i]=1; while(n) &#123; if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; &#125; &#125; 下面放一个求斐波那契数列的矩阵快速幂模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int mod = 10000;const int maxn = 35;int N;struct Matrix &#123; int mat[maxn][maxn]; int x, y; Matrix() &#123; memset(mat, 0, sizeof(mat)); for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1; &#125;&#125;;inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123; memset(c.mat, 0, sizeof(c.mat)); c.x = a.x; c.y = b.y; for (int i = 1; i &lt;= c.x; i++) &#123; for (int j = 1; j &lt;= c.y; j++) &#123; for (int k = 1; k &lt;= a.y; k++) &#123; c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod; c.mat[i][j] %= mod; &#125; &#125; &#125; return ;&#125;inline void mat_pow(Matrix &amp;a, int z) &#123; Matrix ans, base = a; ans.x = a.x; ans.y = a.y; while (z) &#123; if (z &amp; 1 == 1) mat_mul(ans, base, ans); mat_mul(base, base, base); z &gt;&gt;= 1; &#125; a = ans;&#125;int main() &#123; while (cin &gt;&gt; N) &#123; switch (N) &#123; case -1: return 0; case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; &#125; Matrix A, B; A.x = 2; A.y = 2; A.mat[1][1] = 1; A.mat[1][2] = 1; A.mat[2][1] = 1; A.mat[2][2] = 0; B.x = 2; B.y = 1; B.mat[1][1] = 1; B.mat[2][1] = 1; mat_pow(A, N - 1); mat_mul(A, B, B); cout &lt;&lt; B.mat[1][1] &lt;&lt; endl; &#125; return 0;&#125; 欧拉函数φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。 设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n sum(1-1/pi)/pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。 模运算基本的模运算(a + b)mod n=((a mod n) + (b mod n))mod n; (a - b)mod n=((a mod n) - (b mod n))mod n; (a b)mod n=((a mod n) (b mod n))mod n; 数论4大定理威尔逊定理若p为质数，则p可整除(p-1)!+1。 欧拉定理若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n) 证明设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。 于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n）， 所以a^φ(n) ≡ 1 (mod n)。 费马小定理假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。 若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 证明因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。 孙子定理（中国剩余定理） 高斯消元高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。 要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。 组合数学排列组合加法原理加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。 分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏） 乘法原理乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。 合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。 公式排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) 其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。 容斥原理设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|这个定理，常称作包含排斥原理，也就是容斥原理。 对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>数论</tag>
        <tag>高斯消元</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]最短路三大算法——Dijkstra算法，Bellman-ford，floyed]]></title>
    <url>%2F2018%2F05%2F06%2F2018-05-06-1%2F</url>
    <content type="text"><![CDATA[Dijkstra算法（单源最短路径）步骤 初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。 从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。 重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。 12345678910111213141516171819202122232425262728293031323334const int INF=0x3f3f3f3f;const int maxn=1200;int dist[maxn],g[maxn][maxn],N;bool vis[maxn];void dijkstra()&#123; for(int i=1;i&lt;=N;i++) dist[i]=(i==1)?0:INF; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=N;i++) &#123; int mark=-1,mindis=INF; for(int j=1;j&lt;=N;j++) &#123; if(!vis[j]&amp;&amp;dist[j]&lt;mindis) &#123; mindis=dist[j]; mark=j; &#125; &#125; vis[mark]=1; for(int j=1;j&lt;=N;j++) &#123; if(!vis[j]) &#123; dist[j]=min(dist[j],dist[mark]+g[mark][j]); &#125; &#125; &#125;&#125; Bellman-ford（单元最短路径，可带负环）为了能够求解边上带有负值的单源最短路径问题，Bellman(贝尔曼，动态规划提出者)和Ford(福特)提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度的方法。Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellman-ford算法有一个小优化：每次松弛先设一个flag，初值为FALSE，若有边更新则赋值为TRUE，最终如果还是FALSE则直接成功退出。Bellman-ford算法浪费了许多时间做无必要的松弛，所以SPFA算法用队列进行了优化，效果十分显著，高效难以想象。SPFA还有SLF，LLL，滚动数组等优化。 递推公式(求顶点u到源点v的最短路径)：$$dist 1 [u] = Edge[v][u]$$ $$dist k [u] = min{ dist k-1 [u], min{ dist k-1 [j] + Edge[j][u] } }, j=0,1,…,n-1,j≠u$$ Dijkstra算法和Bellman算法思想有很大的区别：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改 的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。 使用条件 单源最短路径(从源点s到其它所有顶点v) 有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图) 边权可正可负(如有负权回路输出错误提示) 差分约束系统(至今貌似只看过一道题) 描述 初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次，看下面的描述性证明(当做树)） 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在d[v]中 Bellman-Ford算法是否一定要循环n-1次么？未必！其实只要在某次循环过程中，考虑每条边后，都没能改变当前源点到所有顶点的最短路径长度，那么Bellman-Ford算法就可以提前结束了(开篇提出的小优化就是这个)。 123456789101112131415161718192021222324252627282930313233343536373839bool Bellman_Ford()&#123; for(int i = 1; i &lt;= nodenum; ++i) //初始化 dis[i] = (i == original ? 0 : MAX); for(int i = 1; i &lt;= nodenum - 1; ++i) for(int j = 1; j &lt;= edgenum; ++j) if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost) //松弛（顺序一定不能反~） &#123; dis[edge[j].v] = dis[edge[j].u] + edge[j].cost; pre[edge[j].v] = edge[j].u; &#125; bool flag = 1; //判断是否含有负权回路 for(int i = 1; i &lt;= edgenum; ++i) if(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost) &#123; flag = 0; break; &#125; return flag;&#125; SPFA1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define N 105int res[N];//存储源点到每个顶点的最短距离值int g[N][N];int cnt[N];//每个点入队次数，判断是否出现负环int que[N*N];//队列bool in_que[N];//标记一个点是否已在队列中int front;//队首位置int rear;//队尾位置void spfa(int n,int src)&#123; rear=front=0; que[++rear]=src; memset(res,0x3f3f3f3f,sizeof(res)); memset(in_que,0,sizeof(in_que)); res[src]=0; while(front&lt;rear) &#123; int cur=que[++front]; in_que[cur]=0; int i; for(i=1; i&lt;=n; i++) &#123; if(res[cur]+g[cur][i]&lt;res[i]) &#123; res[i]=res[cur]+g[cur][i]; if(!in_que[i]) &#123; que[++rear]=i; in_que=1; &#125; &#125; &#125; &#125;&#125; floyed（全源最短路径）Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 123456789for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) /* 实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j] 都不是Inf ，只要一个是Inf，那么就肯定不必更新。 */ if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j]; Floyd算法另一种理解DP，为理论爱好者准备的，上面这个形式的算法其实是Floyd算法的精简版，而真正的Floyd算法是一种基于DP(Dynamic Programming)的最短路径算法。设图G中n 个顶点的编号为1到n。令c [i, j, k]表示从i 到j 的最短路径的长度，其中k 表示该路径中的最大顶点，也就是说c[i,j,k]这条最短路径所通过的中间顶点最大不超过k。因此，如果G中包含边&lt;i, j&gt;，则c[i, j, 0] =边&lt;i, j&gt; 的长度；若i= j ，则c[i,j,0]=0；如果G中不包含边&lt;i, j&gt;，则c (i, j, 0)= +∞。c[i, j, n] 则是从i 到j 的最短路径的长度。对于任意的k&gt;0，通过分析可以得到：中间顶点不超过k 的i 到j 的最短路径有两种可能：该路径含或不含中间顶点k。若不含，则该路径长度应为c[i, j, k-1]，否则长度为 c[i, k, k-1] +c [k, j, k-1]。c[i, j, k]可取两者中的最小值。状态转移方程：c[i, j, k]=min{c[i, j, k-1], c [i, k, k-1]+c [k, j, k-1]}，k＞0。这样，问题便具有了最优子结构性质，可以用动态规划方法来求解。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
        <tag>Floyed算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]二分图匹配基本算法之KM算法解析]]></title>
    <url>%2F2018%2F05%2F06%2F2018-05-06%2F</url>
    <content type="text"><![CDATA[最佳匹配如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。 如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，或者Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。 带权二分图的权值最大的完备匹配称为最佳匹配。二分图的最佳匹配不一定是二分图的最大权匹配。 可以添加一些权值为0的边，使得最佳匹配和最大权匹配统一起来。 如图所示： KM算法求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。 1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。 2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。 3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。 相等子图因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。 相等子图性质 在任意时刻，相等子图上的最大权匹配一定小于等于相等子图的顶标和。 在任意时刻，相等子图的顶标和即为所有顶点的顶标和。 扩充相等子图后，相等子图的顶标和将会减小。 当相等子图的最大匹配为原图的完备匹配时，匹配边的权值和等于所有顶点的顶标和，此匹配即为最佳匹配。 演示过程1.如图所示，1与a匹配权值为3，与c为4。2与a权值为2，与b权值为1，与c权值为3。3与c权值为5。 2.首先对每个顶点赋值，将左边的顶点赋值为最大权重，右边的顶点赋值为0。 3.进行匹配，我们匹配的原则是：只与权重相同的边匹配，若是找不到边匹配，对此条路径的所有左边顶点-1，右边顶点+1，再进行匹配，若还是匹配不到，重复+1和-1操作。对1进行匹配，符合匹配条件的边只有1-c边。 4.接着对2匹配，顶点2值为3，2-c边权重为3，但是，1已经匹配c了，发生了冲突，我们这时候第一时间应该想到的是，让2换个工作，但根据匹配原则，只有2-c边 3+0=0 满足要求，于是2不能换边了，那1能不能换边呢？对1来说，也是只有1-c边满足4+0=4的要求，于是1也不能换边，走投无路了，怎么办？ 5.从常识的角度思考：其实我们寻找最优匹配的过程，也就是帮每个X顶点找到他们权值最高的Y顶点，但是，有些顶点会冲突，比如现在，1，2和c的权值都是最高，这时我们应该让1或者3换顶点，但是这时候换的话我们只能换到降低权值的Y顶点，也就是说，如果令R=左边顶点所有值相加，若发生了冲突，则最终权值一定小于R，但是，我们现在只要求最优匹配，所以，如果1换顶点降低的权值比较少的话，我们是能接受的（对2同样如此）。 在KM算法中如何体现呢？ 现在参与到这个冲突的顶点是1,2和c，令所有左边顶点值-1，右边顶点值+1，即 1-1,2-1. c+1。 我们进行了上述操作后会发现，若是左边有n个顶点参与运算，则右边就有n-1个顶点参与运算，整体效率值下降了1*（n-（n-1））=1，而对于1来说，1-c本来为可匹配的边，现在仍为可匹配边（3+1=4），对于2来说，2-c本来为可匹配的边，现在仍为可匹配的边（2+1=4），我们通过上述操作，为1增加了一条可匹配的边1-a，为B增加了一条可匹配的边2-a。 现在我们再来匹配，对2来说，2-a边 2+0=2，满足条件，所以2换边，a现在为未匹配状态，2-a匹配！ 6.我们现在匹配最后一条边3，3-c 5+1！=5，3边无边能匹配，所以3-1。现在3-c边 4+1=5，可以匹配，但是c已匹配了，发生冲突，3此时不能换边，于是便去找1，对于1来说，1-a此时也为可匹配边，但是a已匹配，1又去找2。 7.2现在无边可以匹配了，2+0！=1 ，现在的路径是3→c→1→a→2，所以1-1,2-1,3-1,a+1，c+1。如下图所示。 8.对于2来说，现在2-b 1+0=1 可匹配！使用匈牙利算法，对此条路径上的边取反。 实现代码：12345678910111213141516171819202122232425262728293031323334353637bool dfs(int s) //匈牙利算法找增广路径&#123; visx[s]=1; for(int i=1;i&lt;=cnty;i++) if(!visy[i])&#123; int t=wx[s]+wy[i]-dis[s][i]; if(t==0) &#123; visy[i]=1; if(linky[i]==0||dfs(linky[i]))&#123; linkx[s]=i,linky[i]=s; return true; &#125; &#125; else if(t&gt;0) //找出边权与顶标和的最小的差值 &#123; if(t&lt;minz)minz=t; &#125; &#125; return false;&#125;void km()&#123; memset(linkx,0,sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(linky,0,sizeof linky); for(int i=1;i&lt;=cntx;i++)&#123; while(1)&#123; minz=INF; memset(visx,0,sizeof visx); memset(visy,0,sizeof visy); if(dfs(i))break; for(int j=1;j&lt;=cntx;j++) //将交错树中X部的点的顶标减去minz if(visx[j])wx[j]-=minz; for(int j=1;j&lt;=cnty;j++) //将交错树中Y部的点的顶标加上minz if(visy[j])wy[j]+=minz; &#125; &#125;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>匹配</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>KM算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]二分图匹配基本算法之匈牙利算法解析]]></title>
    <url>%2F2018%2F05%2F05%2F2018-05-05%2F</url>
    <content type="text"><![CDATA[二分图概念二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（ i，j ）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 简而言之，一个图所有的顶点被分成两部分，同一部分的顶点之间没有边。如图所示： 二分图匹配给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。 增广路经增广路径的定义：设M为二分图G已匹配边的集合，若P是图G中一条连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行,显然P有奇数条边 由增广路的定义可以推出下述三个结论： P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 P经过取反操作可以得到一个更大的匹配M’。 M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。 匈牙利算法基本模式： 初始时最大匹配为空 ​ while 找到增广路经 ​ do 把增广路径加入到最大匹配中去 具体过程如图所示： 1.如图所示，1可以与a，c匹配，2可以与a，b匹配，3可以与c匹配 2.首先将对1进行搜索，1可以与a匹配，则将1与a相连 3.再对2进行搜索，2可以与a匹配 4.但是a已经与1匹配了，那么顺着a-&gt;1这条路找到1，再对1进行搜索，发现1还可以与c进行匹配，并且当前c还未与任何X区顶点匹配，则将1与c相连 5.现在对3进行匹配，发现3可以与c匹配 6.这时发现c已经匹配了，则顺着c-&gt;1这条路找到1，再对1进行搜索，发现1还可以与a匹配 7.但a也已经匹配了，则顺着a-&gt;2这条路找到2，这时发现2还可以与b匹配，并且b当前还未与任何X顶点匹配，则将2与b匹配，之后得到的结果即为最大匹配 以下是实现代码 123456789101112bool find(int x) &#123; //寻找增广路 for (int i = 1; i &lt;= N; i++) &#123; //遍历Y部分顶点 if (road[x][i] &amp;&amp; !vis[i]) &#123; //Y某顶点与X有路且未标记 vis[i] = true; if (!link[i] || find(link[i])) &#123; //如果Y顶点当前未与其他X匹配则直接与该点匹配，否则寻找增广路，然后将Y顶点与该顶点匹配 link[i] = x; return true; &#125; &#125; &#125; return false;&#125; 主程序调用： 123456for(int i = 1; i &lt;= N; i++)&#123; //对每一个X部分顶点进行遍历 memset(vis,false,sizeof(vis)); if(find(i))&#123; //寻找增光路 ans++; //最大匹配数量加1 &#125;&#125; 例题：POJ3041 给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍， 最少要几次。这里将每行x看成一个X结点，每列Y看成一个Y结点，障碍的坐标x,y看成X到Y的 一条边，构建出图后，就变成了找最少的点，使得这些点与所有的边相邻，即最小点覆盖问题。 又继续敲了一遍匈牙利算法 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int N, K, ans;int road[520][520], head[520];bool vis[520];bool find(int x) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (road[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!head[i] || find(head[i])) &#123; head[i] = x; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; while (cin &gt;&gt; N &gt;&gt; K) &#123; ans = 0; int x, y; memset(road, 0, sizeof(road)); memset(head, 0, sizeof(head)); for (int i = 1; i &lt;= K; i++) &#123; cin &gt;&gt; x &gt;&gt; y; road[x][y] = 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find(i)) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>匹配</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++实战qqHelper]C++打造qq消息一键群发工具]]></title>
    <url>%2F2018%2F05%2F03%2F2018-05-03%2F</url>
    <content type="text"><![CDATA[物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此次借此小程序练习C++，用C++打造qq聊天一键群发功能。该小程序还在完善中。目前只能作用于电脑Windows操作系统，并且电脑聊天界面发送按钮需切换到按Enter直接发送，不要选择Ctrl+Enter。当前仅有发送功能，因此消息的对象是所有好友。之后有时间会陆续添加暂停，继续等操作。 具体代码以及实现过程在代码中逐条说明。这里就不具体说明了。 QQmessage.h 12345678910111213141516171819202122232425262728293031323334353637383940#pragma onceclass QQmessage&#123;public: QQmessage(); ~QQmessage(); //类的入口 static QQmessage *Instance() &#123; static QQmessage object; return &amp;object; &#125; //入口函数 void Start(const wchar_t *msg);private: //开始线程 static unsigned int WINAPI RunThreadproc(void* param); //发送主函数 void SendAll(); //找到QQ窗口 HWND FindQQWindow(); //模拟按键 void PressKey(BYTE vkey); //发送消息 void SendMsg(); //添加文本到剪贴板 void AddTextToClipboard();private: CString m_msg;&#125;; QQmessage.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &quot;stdafx.h&quot;#include &quot;QQmessage.h&quot;QQmessage::QQmessage()&#123;&#125;QQmessage::~QQmessage()&#123;&#125;//入口函数void QQmessage::Start(const wchar_t *msg)&#123; m_msg = CString(msg); //输入的文本 _beginthreadex(NULL, 0, QQmessage::RunThreadproc, NULL, 0, NULL);&#125;//开始线程unsigned int QQmessage::RunThreadproc(void* param)&#123; QQmessage::Instance()-&gt;SendAll(); return 0;&#125;//发送主函数void QQmessage::SendAll()&#123; int errorTimes = 0; //打开对话框错误的次数! //把text复制到剪贴板 AddTextToClipboard(); //技术到家. 做项目能力. while (errorTimes&lt;= 4) &#123; HWND hQQWnd = FindQQWindow(); HWND hFrontWnd = GetForegroundWindow(); if (hQQWnd != hFrontWnd) &#123; if (!SetForegroundWindow(hQQWnd)) &#123; MessageBox(NULL, L&quot;没有找到QQ窗口&quot;, NULL, NULL); break; &#125; &#125; if (errorTimes == 0) &#123; PressKey(VK_TAB); PressKey(VK_TAB); &#125; PressKey(VK_DOWN); PressKey(VK_RETURN); HWND hCurFrontWnd = GetForegroundWindow(); if (hCurFrontWnd == hQQWnd) // &#123; ++errorTimes; continue; &#125; errorTimes = 0; SendMsg(); &#125;&#125;//找到QQ窗口HWND QQmessage::FindQQWindow()&#123; HWND hWnd = FindWindow(L&quot;TXGuiFoundation&quot;,L&quot;QQ&quot;); //Find Window //获取QQ的窗口!!! //辅助工具就是这么做的 return hWnd;&#125;//模拟按键void QQmessage::PressKey(BYTE vkey)&#123; keybd_event(vkey, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(vkey, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100);&#125;//发送消息 16GU盘void QQmessage::SendMsg()&#123; //粘贴 + 发送 keybd_event(VK_CONTROL, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(0x56, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(0x56, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100); keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100); //你好 鲜花刷起来! //发送 PressKey(VK_RETURN); PressKey(VK_ESCAPE);&#125;//添加文本到剪贴板void QQmessage::AddTextToClipboard()&#123; //1.把文本拷贝到全局变量! int memLen = m_msg.GetLength() * sizeof(wchar_t) + 2; HANDLE hGloBal = GlobalAlloc(GHND,memLen); //malloc calloc relloc void* memAddr = GlobalLock(hGloBal); ZeroMemory(memAddr, memLen); memcpy(memAddr, (const void*)m_msg.GetBuffer(), memLen); GlobalUnlock(hGloBal); //操作剪贴板! 怎么把大象装进冰箱! OpenClipboard(NULL); EmptyClipboard(); SetClipboardData(CF_UNICODETEXT, hGloBal); CloseClipboard();&#125; QQHelperDlg.h 12345678910111213141516171819202122232425262728293031323334353637// QQHelperDlg.h : 头文件//#pragma once// CQQHelperDlg 对话框class CQQHelperDlg : public CDialogEx&#123;// 构造public: CQQHelperDlg(CWnd* pParent = NULL); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_QQHELPER_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: CString m_Msg; afx_msg void OnBnClickedButton1();&#125;; QQHelperDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// QQHelperDlg.cpp : 实现文件//#include &quot;stdafx.h&quot;#include &quot;QQHelper.h&quot;#include &quot;QQHelperDlg.h&quot;#include &quot;afxdialogex.h&quot;#include &quot;QQmessage.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CQQHelperDlg 对话框CQQHelperDlg::CQQHelperDlg(CWnd* pParent /*=NULL*/) : CDialogEx(IDD_QQHELPER_DIALOG, pParent) , m_Msg(_T(&quot;&quot;))&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CQQHelperDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Text(pDX, IDC_EDIT1, m_Msg);&#125;BEGIN_MESSAGE_MAP(CQQHelperDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON1, &amp;CQQHelperDlg::OnBnClickedButton1)END_MESSAGE_MAP()// CQQHelperDlg 消息处理程序BOOL CQQHelperDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CQQHelperDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CQQHelperDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CQQHelperDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;//发送void CQQHelperDlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); QQmessage::Instance()-&gt;Start(m_Msg.GetBuffer());//m_Msg实例编辑框的变量 文字&#125; QQHelper.h 1234567891011121314151617181920212223242526272829303132// QQHelper.h : PROJECT_NAME 应用程序的主头文件//#pragma once#ifndef __AFXWIN_H__ #error &quot;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&quot;#endif#include &quot;resource.h&quot; // 主符号// CQQHelperApp: // 有关此类的实现，请参阅 QQHelper.cpp//class CQQHelperApp : public CWinApp&#123;public: CQQHelperApp();// 重写public: virtual BOOL InitInstance();// 实现 DECLARE_MESSAGE_MAP()&#125;;extern CQQHelperApp theApp; QQHelper.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// QQHelper.cpp : 定义应用程序的类行为。//#include &quot;stdafx.h&quot;#include &quot;QQHelper.h&quot;#include &quot;QQHelperDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CQQHelperAppBEGIN_MESSAGE_MAP(CQQHelperApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CQQHelperApp 构造CQQHelperApp::CQQHelperApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的一个 CQQHelperApp 对象CQQHelperApp theApp;// CQQHelperApp 初始化BOOL CQQHelperApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CQQHelperDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != NULL) &#123; delete pShellManager; &#125;#ifndef _AFXDLL ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; stdafx.h 12345678910111213141516171819202122232425262728293031323334353637383940414243// stdafx.h : 标准系统包含文件的包含文件，// 或是经常使用但不常更改的// 特定于项目的包含文件#pragma once#ifndef VC_EXTRALEAN#define VC_EXTRALEAN // 从 Windows 头中排除极少使用的资料#endif#include &quot;targetver.h&quot;#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS // 某些 CString 构造函数将是显式的// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏#define _AFX_ALL_WARNINGS#include &lt;afxwin.h&gt; // MFC 核心组件和标准组件#include &lt;afxext.h&gt; // MFC 扩展#include &lt;afxdisp.h&gt; // MFC 自动化类#ifndef _AFX_NO_OLE_SUPPORT#include &lt;afxdtctl.h&gt; // MFC 对 Internet Explorer 4 公共控件的支持#endif#ifndef _AFX_NO_AFXCMN_SUPPORT#include &lt;afxcmn.h&gt; // MFC 对 Windows 公共控件的支持#endif // _AFX_NO_AFXCMN_SUPPORT#include &lt;afxcontrolbars.h&gt; // 功能区和控件条的 MFC 支持#ifdef _UNICODE#if defined _M_IX86#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;x86&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#elif defined _M_X64#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;amd64&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#else#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;*&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#endif#endif stdafx.cpp 123456// stdafx.cpp : 只包括标准包含文件的源文件// QQHelper.pch 将作为预编译头// stdafx.obj 将包含预编译类型信息#include &quot;stdafx.h&quot; Resource.h 12345678910111213141516171819202122//&#123;&#123;NO_DEPENDENCIES&#125;&#125;// Microsoft Visual C++ 生成的包含文件。// 供 QQHelper.rc 使用//#define IDM_ABOUTBOX 0x0010#define IDD_ABOUTBOX 100#define IDS_ABOUTBOX 101#define IDD_QQHELPER_DIALOG 102#define IDR_MAINFRAME 128#define IDC_EDIT1 1000#define IDC_BUTTON1 1001// Next default values for new objects// #ifdef APSTUDIO_INVOKED#ifndef APSTUDIO_READONLY_SYMBOLS#define _APS_NEXT_RESOURCE_VALUE 130#define _APS_NEXT_COMMAND_VALUE 32771#define _APS_NEXT_CONTROL_VALUE 1002#define _APS_NEXT_SYMED_VALUE 101#endif#endif targetver.h 12345678#pragma once// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。#include &lt;SDKDDKVer.h&gt; 资源文件]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）]]></title>
    <url>%2F2018%2F05%2F01%2F2018-05-01%2F</url>
    <content type="text"><![CDATA[今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。 Walking in the Forest （最大值最小化例题）题目描述 It’s universally acknowledged that there’re innumerable trees in the campus of HUST. Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step. 输入描述:12The first line contains two integer N and K as described above.Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone. 输出描述:1An integer, the minimum distance of the largest step. 示例1 输入126 31 3 2 2 5 输出15 题意： 有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。 题解： 典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;long long a[100010];int n, k;bool check(long long ld,long long rd,long long mind) &#123; long long cnt = 0; int stemp = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (cnt + a[i] &lt;= mind) &#123; cnt += a[i]; &#125; else &#123; cnt = a[i]; stemp++; &#125; if (stemp &gt; k) return false; &#125; if (stemp &lt;= k) return true; return false;&#125;int main() &#123; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123; long long maxn = 0, sumn = 0; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); sumn += a[i]; if (maxn &lt; a[i]) maxn = a[i]; &#125; long long ld = maxn; long long rd = sumn; long long mind = (ld + rd) / 2; while (ld &lt;= rd) &#123; bool flag = check(ld, rd, mind); if (!flag) &#123; ld = mind + 1; mind = (ld + rd) / 2; &#125; else &#123; rd = mind - 1; mind = (ld + rd) / 2; &#125; &#125; printf(&quot;%lld\n&quot;, ld); &#125; return 0;&#125; POJ2456疯牛 （最小值最大化例题）时间限制：1000 ms | 内存限制：65535 KB 难度：4 描述 农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入5 312849样例输出3 题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。 题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int v[100005]; int n, c; int check(int d) &#123; int tmp = v[0], cnt = 1; for (int i = 1; i &lt; n; i++) &#123; if (v[i] - tmp &gt;= d) &#123; cnt++; tmp = v[i]; &#125; &#125; if (cnt &gt;= c) return 1; return 0; &#125; int main() &#123; while (cin &gt;&gt; n &gt;&gt; c) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i]; sort(v, v + n); int l = 0, r = v[n - 1], mid; while (l &lt;= r) &#123; mid = (l + r) / 2; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; printf(&quot;%d\n&quot;, r); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解]]></title>
    <url>%2F2018%2F04%2F29%2F2018-04-29%2F</url>
    <content type="text"><![CDATA[4月29日，13:30-18:30，浙江大学程序设计校赛 A-Peak题意： 有一串数字，问这串数字是否符合以下情况： 存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。 题解： 水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。 B - King of Karaoke题意： 两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k 题解： 只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。 D - Sequence Swapping Time Limit: 1 Second Memory Limit: 65536 KB BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element in the pair is an integer. As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if , ‘(‘ and ‘)’. BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get? InputThere are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains an integer (), indicating the length of the sequence. The second line contains a string () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above. The third line contains integers (). Their meanings are described above. It’s guaranteed that the sum of of all test cases will not exceed . OutputFor each test case output one line containing one integer, indicating the maximum possible score BaoBao can get. Sample Input1234567891011121346)())()1 3 5 -1 3 26)())()1 3 5 -100 3 23())1 -1 -13())-1 -1 -1 Sample Output1234242102 HintFor the first sample test case, the optimal strategy is to select in order. For the second sample test case, the optimal strategy is to select in order. 题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。 题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即curweight[i]。否则将cur和curweight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;stack&gt;using namespace std;struct node &#123; int cur; int cnt;&#125;;char str[1010];int wei[1010];int main() &#123; int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%s&quot;, &amp;n, str); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;wei[i]); &#125; stack&lt;node&gt;st; int sum = 0; int cur = 0; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (str[i] == &apos;(&apos;) &#123; if (cur == 0) &#123; cur = wei[i]; &#125; else if (abs(cur) &lt; abs(cur + wei[i])) &#123; cur = cur + wei[i]; &#125; else &#123; cur = wei[i]; &#125; &#125; else if (str[i] == &apos;)&apos;) &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123; cnt = 0; do &#123; cur += st.top().cur; cnt += st.top().cnt; st.pop(); &#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]); sum += cur*wei[i] + cnt; &#125; else if (cur*wei[i] &gt; 0) &#123; sum += wei[i] * cur; &#125; else &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123; cur += st.top().cur; sum += cur*wei[i] + st.top().cnt; st.pop(); &#125; else &#123; if (!cur&amp;&amp;!st.empty()) &#123; st.top().cnt += st.top().cur*wei[i]; &#125; else &#123; node tmp; tmp.cnt = cur*wei[i]; tmp.cur = cur; st.push(tmp); cur = 0; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125; J - CONTINUE…? Time Limit: 1 Second Memory Limit: 65536 KB Special Judge DreamGrid has classmates numbered from to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has gems. DreamGrid would like to divide the classmates into four groups , , and such that: Each classmate belongs to exactly one group. Both and consist only of girls. Both and consist only of boys. The total number of gems in and is equal to the total number of gems in and . Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty. InputThere are multiple test cases. The first line of input is an integer indicating the number of test cases. For each test case: The first line contains an integer () – the number of classmates. The second line contains a string () consisting of 0 and 1. Let be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl. It is guaranteed that the sum of all does not exceed . OutputFor each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead. Sample Input123456789101151121031014000071101001 Sample Output12345-1-131412213413214 题意： 有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可） 题解： 看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;int a[100010], vis[100010];using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); long long int sum = 0, half = 0; while (t--) &#123; int n; sum = 0; scanf(&quot;%d&quot;, &amp;n); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%1d&quot;, &amp;a[i]); sum += i + 1; &#125; if (sum % 2 != 0) &#123; printf(&quot;-1\n&quot;); continue; &#125; else half = sum / 2; sum = 0; for (int i = n; i &gt; 0; i--) &#123; if (sum + i &lt;= half) &#123; sum += i; vis[i - 1] = 1; if (sum == half) break; else if (half - sum &lt; i) &#123; vis[half - sum - 1] = 1; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i]) &#123; if (vis[i]) printf(&quot;3&quot;); else printf(&quot;4&quot;); &#125; else if (!a[i]) &#123; if (vis[i]) printf(&quot;1&quot;); else printf(&quot;2&quot;); &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; L - Doki Doki Literature Club Time Limit: 1 Second Memory Limit: 65536 KB Doki Doki Literature Club! is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story! A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words. The poem writing mini-game (from wikipedia) BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of words is nothing more than a sequence of strings, and the happiness of Sayori after reading the poem is calculated by the formula Given a list of words and Sayori’s preference to each word, please help BaoBao select words from the list and finish the poem with these words to maximize the happiness of Sayori. Please note that each word can be used at most once! InputThere are multiple test cases. The first line of input contains an integer (about 100), indicating the number of test cases. For each test case: The first line contains two integers and (), indicating the number of words and the length of the poem. For the following lines, the -th line contains a string consisting of lowercased English letters () and an integer (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that for all . OutputFor each test case output one line containing an integer and strings separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one. Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect! A sequence of strings is lexicographically smaller than another sequence of strings , if there exists a () such that for all and is lexicographically smaller than . A string is lexicographically smaller than another string , if there exists a () such that for all and , or for all and . Sample Input1234567891011121314151617181920212223242526410 8hello 0world 0behind 0far 1be 2spring 10can 15comes 20winter 25if 2005 5collegiate 0programming -5zhejiang 10provincial 5contest -453 2bcda 1bcd 1bbbbb 13 2a 1aa 1aaa 1 Sample Output12342018 if winter comes can spring be far behind15 zhejiang provincial collegiate programming contest3 bbbbb bcd3 a aa 题意： 有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。 题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node&#123; string str; long long int weight;&#125;;node level[110];bool cmp(node a,node b) &#123; if (a.weight != b.weight) return a.weight &gt; b.weight; else &#123; return a.str &lt; b.str; &#125;&#125;int main() &#123; int t, n, m; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; long long int h = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; level[i].str &gt;&gt; level[i].weight; &#125; sort(level, level + n, cmp); for (int i = m; i &gt; 0; i--) h += level[m - i].weight*i; printf(&quot;%lld &quot;, h); for (int i = 0; i &lt; m - 1; i++) cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;; cout &lt;&lt; level[m - 1].str &lt;&lt; endl; &#125; return 0;&#125; K - Lucky 7给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。 题解： 每输入一个数直接进行判断即可。]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(高级篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-3%2F</url>
    <content type="text"><![CDATA[由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(进阶篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-2%2F</url>
    <content type="text"><![CDATA[本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。 基本流程1.安装主题 2.启用主题 3.验证主题 4.设置语言 5.设置菜单 6.侧栏设置 7.尾栏设置 8.附页 安装主题在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 即可获取最新版主题，后续更新只需输入指令： 1git pull 启用主题在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next 1theme: next 注意中间有空格。到此，NexT 主题安装完成。 验证主题在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 1hexo clean 首先启动 Hexo 本地站点，并开启调试模式，整个命令是 1hexo s 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000/。 如果端口号被占用还是得先修改端口号，然后启动服务。即先输入 1hexo server -p 5000 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:5000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:5000/。 完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是： Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 双栏Scheme，简约淡雅的风尚 注释 # 即可。 以Pisce为例，选择 Pisce Scheme 设置语言在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文） 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定实例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id 设置菜单菜单栏设置菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。 12345678menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 添加标签，分类添加标签页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面 1hexo new page tags 在新建的index.md文件中添加type: “tags” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 添加分类页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面 1hexo new page categories 在新建的index.md文件中添加type: “categories” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。 添加关于我页面，步骤和以上差不多 在新建的index.md文件中添加内容 侧栏设置设置侧栏位置，修改主题目录下sidebar的position值 设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 尾栏设置修改底部的官方logo，找到 \themes\next\layout\_partials\下面的footer.swig文件，打开会发现，如下的语句： 第一个框 是下面侧栏的“日期❤ XXX” 如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可） 看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 附页站点配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 浅悠悠的个人博客 #网站标题subtitle: 。。。 #网站副标题description: 。。。 #网站描述author: 王骏 #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有)# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/imwillxue/imwillxue.github.com.git branch: master 主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat: #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客（基础篇）]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-1%2F</url>
    <content type="text"><![CDATA[以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程： 基本流程：1.搭建前的准备（包括node.js，git，github账户的配置） 2.安装hexo 3.配置hexo 4.连接hexo与github page 5.发布文章 搭建前的准备1.安装node.js 2.安装git 3.github账户管理 配置Node.js下载node.js。根据自己电脑的配置自行安装。 安装完成后打开终端输入： 12node -vnpm -v 进行是否安装成功测试。如不正确，回头检查哪一步错误。 配置Gitgit官网。自行安装。 安装完成后打开终端输入： 1git --version 以上步骤进行是否安装成功。如果安装失败自行面壁。 github管理已拥有账号可跳过注册此步 打开github进行注册。 登录后点击右上角加号，选择New repository新建代码库。 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。 注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io 建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 安装hexo在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹 在命令行输入 1npm install hexo -g //进行安装 输入 1hexo -v //检验是否安装成功。 配置hexo输入 1hexo init //初始化该文件夹 看到后面的“Start blogging with Hexo！”证明正在执行。 输入 1npm install //安装所需要的组件 输入 1hexo g //生成 输入 1hexo s 开启服务器，访问该网址，正式体验Hexo 连接hexo与github page设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容 输入ssh-keygen -t rsa -C “xxxxxx@xx.com”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 发布文章新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 当然你也可以执行下面的命令，相当于上面两条命令的效果 1hexo g -d //在部署前先生成 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。 到此为止，最基本的也是最全面的hexo+github搭建博客完结。]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据结构]堆的基本操作]]></title>
    <url>%2F2018%2F04%2F23%2F2018-04-23%2F</url>
    <content type="text"><![CDATA[堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 1.堆总是一棵完全二叉树。 2.堆中某个节点的值总是不大于或不小于其父节点的值。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 本次操作具体以小根堆为例进行演示。 堆的存储一般采用树组存储，i结点的父结点下标为( i - 1 ) / 2。左子树的下标为2 i + 1,右子树的下标为2 i + 2。 堆的操作堆的插入每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。 1234567891011121314151617// 新加入i结点 其父结点为(i - 1) / 2 void MinHeapFixup(int a[], int i) &#123; int j, temp; temp = a[i]; j = (i - 1) / 2; //父结点 while (j &gt;= 0 &amp;&amp; i != 0) &#123; if (a[j] &lt;= temp) break; a[i] = a[j]; //把较大的子结点往下移动,替换它的子结点 i = j; j = (i - 1) / 2; &#125; a[i] = temp; 插入时 12345void MinHeapAddNumber(int a[], int n, int nNum) &#123; a[n] = nNum; MinHeapFixup(a, n); &#125; 堆的删除堆中每次都只能删除根结点，即第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。 123456789101112131415161718192021222324252627// 从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2 void MinHeapFixdown(int a[], int i, int n) &#123; int j, temp; temp = a[i]; j = 2 * i + 1; while (j &lt; n) &#123; if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的 j++; if (a[j] &gt;= temp) break; a[i] = a[j]; //把较小的子结点往上移动,替换它的父结点 i = j; j = 2 * i + 1; &#125; a[i] = temp; &#125; //在最小堆中删除数 void MinHeapDeleteNumber(int a[], int n) &#123; Swap(a[0], a[n - 1]); MinHeapFixdown(a, 0, n - 1); &#125; 构建堆有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。 123456//建立最小堆 void MakeMinHeap(int a[], int n) &#123; for (int i = n / 2 - 1; i &gt;= 0; i--) MinHeapFixdown(a, i, n); &#125; 堆排序首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。 由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。 12345678void MinheapsortTodescendarray(int a[], int n) &#123; for (int i = n - 1; i &gt;= 1; i--) &#123; Swap(a[i], a[0]); MinHeapFixdown(a, 0, i); &#125; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[爬虫]python自动调用浏览器访问网页增加访问量]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-1%2F</url>
    <content type="text"><![CDATA[该程序主要是为了增长访问量而写的，主要针对一些访问量与用户信息无关的网页，比如CSDN。当然前提是python安装相应的库。原理很简单，没有用到什么高端的爬虫技术，没有用到正则表达式什么的。其实就是调用你的浏览器，然后程序自动帮你打开你的博客网页，隔一段时间自动关闭，以此循环，刷访问量。不多说了，直接贴代码吧。 123456789101112131415161718192021import webbrowser as web import time import os import random count = random.randint(1, 2) j = 0 aa = [80042845,80025162,80035076,80025133,80025068,80024813,79986200,79935658,79933992,79783339,79747976,79747322,79734593,79734363,79706272,79700188,79725018,79724244] while j &lt; count: i = 0 while i &lt;= 8: k = random.randint(0,17) web.open_new_tab(&apos;https://blog.csdn.net/qian_youyou/article/details/&apos;+str(aa[k])) i = i + 1 time.sleep(3) else: time.sleep(20) os.system(&apos;taskkill /F /IM chrome.exe&apos;) # print &apos;time webbrower closed&apos; j = j + 1]]></content>
      <categories>
        <category>程序人生</category>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言打造智能AI小游戏——三子棋]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22%2F</url>
    <content type="text"><![CDATA[三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3]，[3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。例如没有走时，9个格的权值为： [] [] [] 3 2 3 [] [] [] 2 4 2 [] [] [] 3 2 3 角落有横竖斜三种获胜方法，边有横竖两种方法，中心有横竖两斜4种方法。假如某格有X阻挡，那么权值会相应变化，例如 [] [] [] 2 1 2 [] X [] 1 0 1 [] [] [] 2 1 2 由于有中心阻挡，那么角只有横竖两种方法赢，因此权值为2。但该AI还需继续优化。例如以下： [] X [] 1 0 1 [] 0 [] 1 0 2 X X 0 0 0 0 AI面对这种情况，本来下在第一个格子就赢了，但他会选择权值为2的格子。因此我们可以在现有权值条件的情况下，在附加个权值。假如某一格子的路线上已经有AI的子了，那么该条路线上未落子的所有格子权值再加1，如果有两个已落子的AI格子权值就加2。例如以下情况： 原权值 优化 [] X [] 2 0 2 5 0 3 [] 0 [] 2 0 2 3 0 4 [] X 0 2 0 0 3 0 0 第一个格子5是由于斜路线上有两个子，那在原有的基础2上先加1，再加2，所以权值为2+1+2。第2行第3列权值为4，因为横竖两条路线均有1个子，因此权值为2+1+1，其余格子路线上均有1个子，因此权值为2+1。这样落在权值5那个格子上AI就赢了。 但是仅仅这些判断是不够的。例如： 原权值 优化 X [] X 0 1 0 0 2 0 [] 0 [] 1 0 1 2 0 2 [] [] 0 1 2 0 2 4 0 AI会选择权值为4的格子。那此时AI选择权值为2的格子时，你只需要走一步就赢了，AI就输了，因此该AI算法还得继续。 那么AI可以逆向思考一番，AI可以考虑一下当前情况在计算AI权值的同时再计算一次我们的权值。例如上面例子： AI 你 X [] X 0 1 0 0 1 0 [] 0 [] 1 0 1 1 0 0 [] [] 0 1 2 0 1 0 0 优化AI 优化你 0 2 0 0 4 0 2 0 2 2 0 0 2 4 0 2 0 0 我们把两个权值相加（另外把AI的权值应该再加1，因为AI判断赢要优先于输或平，假如AI方有权值大的，代表一步能赢的，我方也有这种情况，那相加权值相同，AI既可以选择赢棋那一格，也可以选择堵你将要赢的那一格。但AI判断赢要优先于堵对方赢。例子就不举了）： 相加权 加1权 X [] X 0 6 0 0 7 0 [] 0 [] 4 0 2 5 0 3 [] [] 0 4 4 0 5 4 0 因此AI判断到这里就会堵你了。 AI算法就介绍到这里，至于三子棋程序，由于过于简单，就不过多介绍了。主要介绍AI思想，Windows系统编译的程序。如果是Linux需要把以下代码改下。接下来我就贴上代码，供参考，如有不懂欢迎留言。 project.h 12345678910111213141516#pragma once #define COLUMN 3 #define ROW 3 #define GOON 0 #define WIN -1 #define DEFEAT 1 void init(char(*MAP)[COLUMN]); int victory(char(*MAP)[COLUMN]); bool check(char(*MAP)[COLUMN]); void show(char(*MAP)[COLUMN]); void check_stemp(char(*MAP)[COLUMN], int *x, int *y); void ai_auto(char(*MAP)[COLUMN]); int menu(); int first_hand(char(*MAP)[COLUMN]); int ai_hand(char(*MAP)[COLUMN]); void play(char(*MAP)[COLUMN]); project.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&quot;project.h&quot; int vis[ROW][COLUMN]; int weight[ROW][COLUMN]; int x, y; void init(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) &#123; MAP[i][j] = &apos; &apos;; vis[i][j] = 0; &#125; &#125; int victory(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] == &apos;X&apos;&amp;&amp;MAP[i][1] == &apos;X&apos;&amp;&amp;MAP[i][2] == &apos;X&apos;) return WIN; else if (MAP[i][0] == &apos;O&apos;&amp;&amp;MAP[i][1] == &apos;O&apos;&amp;&amp;MAP[i][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][i] == &apos;X&apos;&amp;&amp;MAP[1][i] == &apos;X&apos;&amp;&amp;MAP[2][i] == &apos;X&apos;) return WIN; else if (MAP[0][i] == &apos;O&apos;&amp;&amp;MAP[1][i] == &apos;O&apos;&amp;&amp;MAP[2][i] == &apos;O&apos;) return DEFEAT; &#125; if (MAP[0][0] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][2] == &apos;X&apos;) return WIN; else if (MAP[0][0] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][2] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][0] == &apos;X&apos;) return WIN; else if (MAP[0][2] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][0] == &apos;O&apos;) return DEFEAT; return GOON; &#125; bool check(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) if (!vis[i][j]) return false; return true; &#125; void show(char(*MAP)[COLUMN]) &#123; printf(&quot;-------------\n&quot;); for (int i = 0; i &lt; ROW; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt; COLUMN; j++) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; printf(&quot;\n&quot;); printf(&quot;-------------\n&quot;); &#125; &#125; void check_stemp(char(*MAP)[COLUMN], int *x, int *y) &#123; while (*x &gt; 3 || *x &lt;= 0 || *y&gt;3 || *y &lt;= 0 || MAP[*y - 1][*x - 1] != &apos; &apos;) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Input error, please reenter!\n&quot;); scanf(&quot;%d%d&quot;, x, y); &#125; MAP[*y - 1][*x - 1] = &apos;X&apos;; vis[*y - 1][*x - 1] = 1; &#125; void Empowerment(char(*MAP)[COLUMN], int(*weight)[COLUMN], char ai_X, char ai_0, int flag) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] != ai_X&amp;&amp;MAP[i][1] != ai_X&amp;&amp;MAP[i][2] != ai_X) &#123; weight[i][0]++; weight[i][1]++; weight[i][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[i][j] == ai_0) &#123; weight[i][0] += tmp+flag; weight[i][1] += tmp+flag; weight[i][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][i] != ai_X&amp;&amp;MAP[1][i] != ai_X&amp;&amp;MAP[2][i] != ai_X) &#123; weight[0][i]++; weight[1][i]++; weight[2][i]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][i] == ai_0) &#123; weight[0][i] += tmp+flag; weight[1][i] += tmp+flag; weight[2][i] += tmp+flag; tmp += 10; &#125; &#125; &#125; if (MAP[0][0] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][2] != ai_X) &#123; weight[0][0]++; weight[1][1]++; weight[2][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][j] == ai_0) &#123; weight[0][0] += tmp+flag; weight[1][1] += tmp+flag; weight[2][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][2] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][0] != ai_X) &#123; weight[0][2]++; weight[1][1]++; weight[2][0]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][2 - j] == ai_0) &#123; weight[0][2] += tmp+flag; weight[1][1] += tmp+flag; weight[2][0] += tmp+flag; tmp += 10; &#125; &#125; &#125; void ai_auto(char(*MAP)[COLUMN]) &#123; int weight[3][3] = &#123; 0 &#125;; Empowerment(MAP, weight, &apos;X&apos;, &apos;O&apos;, 1); Empowerment(MAP, weight, &apos;O&apos;, &apos;X&apos;, 0); int maxn = -1; int maxm = -1; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) &#123; if (vis[i][j]) weight[i][j] = -1; if (maxn &lt; weight[i][j]) &#123; maxn = weight[i][j]; maxm = i * 3 + j; &#125; &#125; MAP[maxm / 3][maxm % 3] = &apos;O&apos;; vis[maxm / 3][maxm % 3] = 1; &#125; int menu() &#123; int tmp; printf(&quot;*************************************************************\n&quot;); printf(&quot;* Please enter: * 1:First hand * 2.Back hand * Others:Close *\n&quot;); printf(&quot;*************************************************************\n&quot;); scanf(&quot;%d&quot;, &amp;tmp); return tmp; &#125; int first_hand(char(*MAP)[COLUMN]) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Please enter:x y\n&quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); check_stemp(MAP, &amp;x, &amp;y); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == WIN) &#123; printf(&quot;Congratulations on your victory, you are as smart as Qianyouyou.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; system(&quot;pause&quot;); return 0; &#125; int ai_hand(char(*MAP)[COLUMN]) &#123; ai_auto(MAP); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == DEFEAT) &#123; printf(&quot;You lose, you&apos;re as stupid as a pig.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; return 0; &#125; void play(char(*MAP)[COLUMN]) &#123; while (!check(MAP) || victory(MAP) == GOON) &#123; if (first_hand(MAP)) break; if (ai_hand(MAP)) break; &#125; system(&quot;pause&quot;); &#125; main.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&quot;project.h&quot; char MAP[ROW][COLUMN]; int main() &#123; char str[2]; do &#123; init(MAP); switch (menu()) &#123; case 1: first_hand(MAP); case 2: &#123; ai_hand(MAP); play(MAP); &#125; default: &#123; printf(&quot;Do you need to start again?(Y/N)&quot;); scanf(&quot;%s&quot;, str); &#125;break; &#125; &#125; while (str[0] == &apos;Y&apos; || str[0] == &apos;y&apos;); printf(&quot;Thank you for using!\n&quot;); system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>博弈论</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[排序]求解第k大分值]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21%2F</url>
    <content type="text"><![CDATA[描述： Arch0n老师is a rich man, 他靠自己的才华和智商年纪轻轻就赚了不少钱。为了训练自己的智商，他经常玩一些interesting的游戏来训练自己的智商，比如什么RGB游戏，还有和妹子一块玩Don’t Starve。 言归正传，今天他又发明了一个新的interesting game。Ar老师手上有一堆卡牌，然后卡牌上写了一个数字Ai(正整数)，当前他有n张牌，然后他总是随机取出两张来，然后他一眼就能看出这两牌中哪一张小（相同就取相同的，这操作好像对于Ar老师来说太简单了），作为这两张牌的有效分值，然后呢他陷入了沉思，对于n张牌取两张牌显然有确定的组合可能性，有n(n-1)/2对组合，然后他想知道所有这些组合中第k大的分值是多少。输入描述:输入一个t表示数据组数；(0&lt;t&lt;=10)接下来一行是n,k,表示n张牌和最后第k大的分值；（1&lt;n&lt;2500,保证0&lt;k&lt;=n(n-1)/2）接下来一行是n个值ai，表示第i张牌上的数字(0 &lt; ai &lt;= 10000000)。输出描述:每组数据输出一行，即第k大的分值为多少。 示例 输入 2 3 2 1 2 3 3 1 4 2 1 输出 1 2 题解： 首先将这n个数进行从大到小排序，a[0]储存第1大，a[1]储存第2大……第2个和第1个比较最小的是第2个，第3个和前两个比较较小的均是第3个，第4个和前3个比较均是第4个，以此递推，第n个数和n前n-1个比较均是n较小。将所有情况全排列很容易超时，因此我们可以从第k大这个k下手。由于a[0]最大，因此a[0]和任意比较都不会输出a[0]。那么首先k为1输出a[1],1&lt;k&lt;=1+2输出a[2],1+2&lt;k&lt;=1+2+3输出a[3]……现在应该很清楚了吧。可以设置一个变量cnt，和i,从1开始，cnt每次加1，i每次加cnt，直到i加到比k大或者等于时，那么此时的a[cnt]就是第k大的数。 1234567891011121314151617181920212223#include&lt;iostream&gt; #include&lt;algorithm&gt; int cmp(int a, int b) &#123; return a &gt; b; &#125; int T, N, k, a[100010]; using namespace std; int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; k; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + N, cmp); int cnt = 1, i = 1; for (int i = 1; i &lt; k; i += cnt) &#123; cnt++; &#125; cout &lt;&lt; a[cnt] &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言实现小游戏——控制台扫雷]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-3%2F</url>
    <content type="text"><![CDATA[程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌。此处用到了dfs。仅供参考。 项目版： mine.h 1234567#pragma once #define BOOM 10 #define SIZE 10 void init(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b);//初始化扫雷页面void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j);//如果展开面为0，通过深搜将周围所以为0的区域展开 int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//判断胜利条件 void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//展示扫雷页面 mine.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; int stemp[8][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123; 1,1 &#125;,&#123; -1,-1 &#125;,&#123; 1,-1 &#125;,&#123; -1,1 &#125; &#125;;//深搜时上下左右四个方向搜索 void init(char (*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(MAP, visit, i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(MAP, visit, x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y;//坐标 int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(MAP, visit, x, y); scanf(&quot;%d%d&quot;, &amp;y, &amp;x); init(MAP,visit, x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;y, &amp;x); int res = check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125; 另附原始版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #define BOOM 10 #define SIZE 10 char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y; int stemp[8][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;, &#123;-1,1&#125; &#125;; void init(int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check() &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show() &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); init(x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(); system(&quot;cls&quot;); show(); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int res = check(); system(&quot;cls&quot;); show(); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现随机生成数独九宫格]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-2%2F</url>
    <content type="text"><![CDATA[一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; void main() &#123; int a[9][9] = &#123; 0 &#125;; int *p[3][3], *m[3][6], *n[3][6], *r[9][4], *aa[9][9]; int **q[9]; int i, j, k, l, h, t, s = 0; void rank(int *x, int *y); bool check(int a[9][9], int n); srand((int)time(0)); for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 3; j++) p[i][j] = &amp;a[i * 3 + 1][j * 3 + 1]; for (k = 0; k &lt; 9; k++) q[k] = &amp;p[k / 3][k % 3]; for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; m[i][j] = &amp;a[i * 3 + 1][2 * j - j / 2]; n[i][j] = &amp;a[2 * j - j / 2][i * 3 + 1]; &#125; for (k = 0; k &lt; 9; k++) for (l = 0; l &lt; 4; l++) r[k][l] = &amp;a[(k / 3) * 3 + (l / 2) * 2][(k % 3) * 3 + (l % 2) * 2]; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) aa[i][j] = &amp;a[i][j]; step1: for (i = 0; i &lt; 9; i++) &#123; next1: **q[i] = rand() % 10; if (**q[i] == 0) goto next1; for (j = 0; j &lt; i; j++) if (**q[j] == **q[i]) goto next1; &#125; step2: for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; next2: *m[i][j] = rand() % 10; if (*m[i][j] == 0) goto next2; for (k = 0; k &lt; 3; k++) if (*m[i][j] == *p[i][k]) goto next2; for (k = 0; k &lt; j; k++) if (*m[i][j] == *m[i][k]) goto next2; for (k = 0; k &lt; i; k++) if (*m[i][j] == *m[k][j]) goto step2; &#125; step3: for (i = 0; i &lt; 3; i++) &#123; next4: for (j = 0; j &lt; 6; j++) &#123; next3: *n[i][j] = rand() % 10; if (*n[i][j] == 0) goto next3; for (k = 0; k &lt; 3; k++) if (*n[i][j] == *p[k][i]) goto next3; for (k = 0; k &lt; j; k++) if (*n[i][j] == *n[i][k]) goto next3; for (l = 0; l &lt; 2; l++) &#123; if (*n[i][j] == *m[j / 2][i * 2 + l]) goto next4; &#125; for (k = 0; k &lt; i; k++) if (*n[i][j] == *n[k][j]) goto step3; &#125; &#125; step4: for (i = 0; i &lt; 3; i++) &#123; for (h = 0; h &lt; 2; h++) &#123; next6: for (l = 0; l &lt; 3; l++) for (j = 0; j &lt; 2; j++) &#123; next5: *r[i * 3 + l][h * 2 + j] = rand() % 10; if (*r[i * 3 + l][h * 2 + j] == 0) goto next5; if (*r[i * 3 + l][h * 2 + j] == **q[i * 3 + l]) goto next5; for (k = 0; k &lt; h * 2 + j; k++) if (*r[i * 3 + l][h * 2 + j] == *r[i * 3 + l][k]) goto next5; for (k = 0; k &lt; 2; k++) &#123; if (*r[i * 3 + l][h * 2 + j] == *m[i][l * 2 + k]) goto next5; if (*r[i * 3 + l][h * 2 + j] == *n[l][i * 2 + k]) goto next5; &#125; for (k = 0; k &lt;= l * 3 + j * 2; k++) for (t = 0; t &lt; k; t++) if (a[i * 3 + h * 2][k] == a[i * 3 + h * 2][t]) goto next6; &#125; &#125; &#125; step5: for (i = 0; i &lt; 3; i++) &#123; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); if (check(a, i) == false) rank(aa[j][i * 3], aa[j][i * 3 + 2]); else if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 9; l++) &#123; for (j = l + 1; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 6; l++) &#123; for (h = l + 1; h &lt; 7; h++) &#123; for (j = h + 1; j &lt; 8; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) goto step4; &#125; printf(&quot;+---------------+---------------+---------------+\n&quot;); printf(&quot;| | | |\n&quot;); for (i = 0; i &lt; 9; i++) &#123; printf(&quot;| &quot;); for (j = 0; j &lt; 9; j++) &#123; printf(&quot;%-4d&quot;, a[i][j]); if ((j + 1) % 3 == 0) printf(&quot;| &quot;); &#125; printf(&quot;\n&quot;); printf(&quot;| | | |\n&quot;); if ((i + 1) % 3 == 0) &#123; printf(&quot;+---------------+---------------+---------------+\n&quot;); if (i &lt; 8) printf(&quot;| | | |\n&quot;); &#125; &#125; system(&quot;pause&quot;); &#125; void rank(int *x, int *y) &#123; int t; t = *x; *x = *y; *y = t; &#125; bool check(int a[9][9], int n) &#123; int i, j; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; i; j++) if (a[i][n * 3] == a[j][n * 3]) return false; return true; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现控制台小游戏——数字拼图]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20%2F</url>
    <content type="text"><![CDATA[一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;math.h&gt; #include &lt;time.h&gt; #define max 10 int x, y, step, label = 0; typedef struct score &#123; int steps, steps2; double times; char name[18]; &#125;score; score sco[max + 1]; char ch, buff[3]; bool flag, flag1 = false; clock_t start, finish; bool over()&#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t\t\t您共用了 %d 步 ,耗时 %.3f 分钟\n&quot;, step, (double)(finish - start) / 40000); system(&quot;pause&quot;); system(&quot;cls&quot;); printf(&quot;\n\n\n\n\n\n\n\n\t******************* 您是否重新开始游戏 (Y/N) ? *******************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch != &apos;n&apos;&amp;&amp;ch != &apos;N&apos;) &#123; return false; &#125; else &#123; printf(&quot;\n\n\n\n\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n&quot;); printf(&quot;\t+++++++++++++++++++++++++ 感谢您的使用 +++++++++++++++++++++++++\n&quot;, step); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); system(&quot;pause&quot;); exit(0); &#125; return true; &#125; void rank(score sco[],int n) &#123; int i, j; sco[0] = sco[n]; for (i = 0; i &lt; n; i++) if (sco[n].steps2&gt;sco[i].steps2) &#123; for (j = n; j &gt; i; j--) sco[j] = sco[j - 1]; sco[i] = sco[0]; break; &#125; for (j = i - 1; j &gt; 0; j--) if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps &lt; sco[j].steps) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; else if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps == sco[j].steps) if (sco[i].times &lt; sco[j].times) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; &#125; int check2(int *p, int n) &#123; int i, j, flag2 = 0; for (i = 1; i &lt; n*n - 1; i++) for (j = 0; j &lt; i; j++) if (p[j] &gt; p[i]) flag2++; if (!flag2) return 0; else if (flag2 % 2 == 0) return 2; else return 1; &#125; bool check(int *p,int n) &#123; int i; flag = true; for (i = 0; i&lt;n*n - 1; i++) if (p[i] != i + 1) flag = false; if (flag) &#123; flag1 = false; return false; &#125; return true; &#125; int operation(int *p,int n) &#123; scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch &gt;= &apos;a&apos;&amp;&amp;ch &lt;= &apos;z&apos;) ch -= 32; switch (ch) &#123; case &apos;A&apos;: if (y == n - 1) return 1; p[x*n + y] = p[x*n + y + 1]; p[x*n + y + 1] = 0; y++; step++; return 1; case &apos;W&apos;: if (x == n - 1) return 1; p[x*n + y] = p[(x + 1)*n + y]; p[(x + 1)*n + y] = 0; x++; step++; return 1; case &apos;D&apos;: if (y == 0) return 1; p[x*n + y] = p[x*n + y - 1]; p[x*n + y - 1] = 0; y--; step++; return 1; case &apos;S&apos;: if (x == 0) return 1; p[x*n + y] = p[(x - 1)*n + y]; p[(x - 1)*n + y] = 0; x--; step++; return 1; case &apos;R&apos;: return 2; case &apos;M&apos;: return 3; case &apos;Q&apos;: printf(&quot;\n\n\t********************* 您是否要离开游戏 (Y/N) ? *********************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch == &apos;y&apos; || ch == &apos;Y&apos;) return 4; else return 1; default: return 1; &#125; return 0; &#125; void map(int *p, int n) &#123; int i, j; system(&quot;cls&quot;); printf(&quot;\n\n\n&quot;); for (i = 0; i &lt; n; i++) &#123; printf(&quot;\t&quot;); for (j = 0; j &lt; n; j++) &#123; if (p[n*i + j] != 0) printf(&quot;%-4d&quot;, p[n*i + j]); else printf(&quot; &quot;); &#125; printf(&quot;\n\n&quot;); &#125; printf(&quot;\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); finish = clock(); printf(&quot;\n\t\t\t\t步数: %d\t 使用时间: %.3f 分钟 \n\n&quot;, step, (double)(finish - start) / 40000); &#125; void reset(int *p, int n) &#123; int i, j, flag2; system(&quot;cls&quot;); do &#123; for (i = 0; i &lt; n*n - 1; i++) &#123; do &#123; flag2 = 1; p[i] = rand() % (n*n - 1) + 1; for (j = 0; j &lt; i; j++) if (p[i] == p[j]) flag2 = 0; &#125; while (!flag2); &#125; flag2 = check2(p, n); if (flag2 == 1) &#123; flag2 = p[n*n - 2]; p[n*n - 2] = p[n*n - 3]; p[n*n - 3] = flag2; &#125; &#125; while (!flag2); p[n*n - 1] = 0; for (i = 0; i&lt;n; i++) for (j = 0; j&lt;n; j++) if (p[i*n + j] == 0)&#123; x = i; y = j; &#125; &#125; void help() &#123; int i = 0; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t--------------------------------+ 基本操作 +--------------------------------\n\n&quot;); printf(&quot;\n\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); printf(&quot;\n\n\t---------------------------+ 浅悠悠（王骏）制作 +---------------------------\n\n&quot;); if (label == 0) printf(&quot;\n\n\t--------------------------+ 暂时没有任何游戏记录 +--------------------------\n\n&quot;); else for (i = 1; i &lt;= label; i++) printf(&quot;\n\n\t 第%02d名：%-18s 步数：%-5d 阶数：%-5d 时间：%-6.3lf分钟\n\n&quot;, i, sco[i].name, sco[i].steps, sco[i].steps2, sco[i].times); printf(&quot;\n\n\t----------------------------+ 按任意键返回菜单 +----------------------------\n\n&quot;); system(&quot;pause&quot;); &#125; void game() &#123; int n, *p; int mark; do &#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t------------------+ 请输入阶数（推荐3——20阶） +------------------\n\n&quot;); scanf(&quot;%d&quot;, &amp;n); if (n &gt; 1) p = (int*)calloc(n*n, sizeof(int)); else printf(&quot;\t********************** 您输入有误，请重新输入 **********************\n\n&quot;), system(&quot;pause&quot;); &#125; while (n &lt;= 1); next1: step = 0; start = clock(); reset(p, n); next2: map(p, n); if (check(p, n) == false) &#123; printf(&quot;\n\n\t=================+ 恭喜您完成游戏，请输入您的姓名 +=================\n\n&quot;); scanf(&quot;%s&quot;, sco[++label].name); sco[label].steps = step; sco[label].steps2 = n; sco[label].times = (double)(finish - start) / 40000; rank(sco, label); if (over() == false) return; &#125; mark = operation(p, n); if (mark == 1) goto next2; else if (mark == 2) goto next1; else if (mark == 3) return; else if (mark == 4) if (over() == false) return; free(p); &#125; int main()&#123; srand((int)time(0)); do &#123; system(&quot;cls&quot;); printf(&quot;\t-------------+ 欢迎来到浅悠悠数字拼图，请选择您的操作 +-------------\n\n&quot;); printf(&quot;\t-----+ 1.开始游戏 +-----+ 2.帮助 +-----+ 0(或其他).退出 +-----\n\n&quot;); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; switch (ch)&#123; case&apos;1&apos;: game(); break; case&apos;2&apos;: help(); break; case&apos;0&apos;: exit(0); default: exit(0); &#125; &#125; while (ch != &apos;0&apos;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]正向BFS+hash解决八码问题]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18%2F</url>
    <content type="text"><![CDATA[八数码问题，可以用单向广搜、双向广搜、A*、IDA等多种方法求解。具体可以参考：八数码的八境界 Description 1234567 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 x 123456789 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 12 13 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x r-&gt; d-&gt; r-&gt; Input 123451 2 3 x 4 6 7 5 8 11 2 3 x 4 6 7 5 8 Output You will print to standard output either the word unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Sample Input 12 3 4 1 5 x 7 6 8 Sample Output 1ullddrurdllurdruldr 题解： 本题一共仅有9！种结果，因此求解方法很多。一开始采用stl进行存储，但一直超时，后来改用hash轻轻松松就过了。判重时9！个排列如果用数组直接保存，每一位保存一个维度，数组开不了那么大。因此可以根据康托展开进行判重，每一种排列对应成一个整形数字，9！种排列一共9！个数字，提高了hash效率。此外，对于x我们暂且当做9处理，而123456789的康托展开是1，因此bfs的终止条件就设为当前状态的康拓展开是否为1。此外，由于本次采用正向bfs，而输出结果时需要输出之前的状态，string储存太慢，queue队列会丢失之前的状态，因此用数组充当队列，用pre追溯上一个状态在队列中的下标。解决代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; using namespace std; const int MAXN = 400000; int fac[9] = &#123; 1, 1, 2, 6, 24, 120, 720, 5040, 40320&#125;; int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;; int opp[4] = &#123; &apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos; &#125;; bool vis[MAXN]; struct node &#123; int stadus; int cur[9]; int loc; char path; int pre; &#125;; node qu[MAXN]; int cantor(int s[]) &#123; int sum = 0; for (int i = 0; i&lt;9; i++) &#123; int num = 0; for (int j = i + 1; j&lt;9; j++) if (s[j]&lt;s[i]) num++; sum += num*fac[8 - i]; &#125; return sum + 1; &#125; int bfs(node now) &#123; memset(vis, false, sizeof(vis)); int x, y; int front = 0, end = 0; node no = now; qu[end++] = no; vis[now.stadus] = true; while (front &lt; end) &#123; no = qu[front++]; x = no.loc / 3; y = no.loc % 3; if (no.stadus == 1) return front - 1; for (int i = 0; i &lt; 4; i++) &#123; node cc = no; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 3 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; 3 &amp;&amp; yy &gt;= 0) &#123; cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.cur[xx * 3 + yy] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.stadus = cantor(cc.cur); if (!vis[cc.stadus]) &#123; vis[cc.stadus] = true; cc.loc = xx * 3 + yy; cc.path = opp[i]; cc.pre = front - 1; qu[end++] = cc; &#125; &#125; &#125; &#125; return -1; &#125; void show(int a) &#123; if (qu[a].pre) &#123; show(qu[a].pre); &#125; printf(&quot;%c&quot;, qu[a].path); &#125; int main() &#123; string tmp; while (getline(cin, tmp)) &#123; int i = 0, cnt = 0; node temp; while (tmp[i]) &#123; if (tmp[i] == &apos; &apos;) &#123; i++; continue; &#125; else if (tmp[i] == &apos;x&apos;) &#123; temp.loc = cnt; temp.cur[cnt] = 9; cnt++; i++; &#125; else &#123; temp.cur[cnt] = tmp[i] - &apos;0&apos;; cnt++; i++; &#125; &#125; temp.stadus = cantor(temp.cur); int ans = bfs(temp); ans != -1 ? show(ans) : printf(&quot;-1&quot;); cout &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>康托展开</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[位运算]dfs+位运算解决N皇后问题]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13%2F</url>
    <content type="text"><![CDATA[在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的N，求出有多少种合法的放置方法。共有若干行，表示棋盘和皇后的数量；如果N=0，表示结束。 分析： 本篇文章重点介绍位运算解决N皇后的思想，并不是解决特定的问题。和普通算法一样，这是一个递归过程，程序一行一行地寻找可以放皇后的地方。过程带三个参数，row、ld和rd，分别表示在纵列和两个对角线方向的限制条件下这一行的哪些地方不能放。我们以6×6的棋盘为例，看看程序是怎么工作的。假设现在已经递归到第四层，前三层放的子已经标在左图上了。红色、蓝色和绿色的线分别表示三个方向上有冲突的位置，位于该行上的冲突位置就用row、ld和rd中的1来表示。把它们三个并起来，得到该行所有的禁位，取反后就得到所有可以放的位置。注意递归调用时三个参数的变化，每个参数都加上了一个禁位，但两个对角线方向的禁位对下一行的影响需要平移一位。最后，如果递归到某个时候发现row=111111了，说明六个皇后全放进去了，此时程序从第1行跳到第11行，找到的解的个数加一。 123456789101112131415161718192021#include&lt;stdio.h&gt; #include&lt;math.h&gt; int N, Count, res; void dfs(int row, int ld, int rd) &#123; if (row == res) &#123; Count++; return; &#125; for (int j = 1; j &lt;= res; j &lt;&lt;= 1) if (row != (row | j) &amp;&amp; ld != (ld | j) &amp;&amp; rd != (rd | j)) dfs(row | j, (ld | j) &lt;&lt; 1 &amp; res, (rd | j) &gt;&gt; 1); &#125; int main() &#123; while (~scanf(&quot;%d&quot;, &amp;N), N) &#123; Count = 0; res = pow(2, N) - 1; dfs(0, 0, 0); printf(&quot;%d\n&quot;, Count); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DFS</tag>
        <tag>ACM/ICPC</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[位运算]位运算的4个简单应用]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13%20-%201%2F</url>
    <content type="text"><![CDATA[\1. 不用任何比较判断两个数中大的那个数 我们将两个数做差，得到另一个数，判断这个数的符号位就可以了。当然，不能直接使用判断语句，所以我们使用位运算来操作。 \2. 两个相同的数异或结果等于0。 就这道题而言，在运算过程中会产生一个中间值，即a与b的异或结果，a异或b再异或b就会等于a，如果第二次异或a就会等于b。 所以直接三个异或就可以搞定 \3. 整数的二进制中有多少个1 每次循环采用n&amp;=(n-1)，这样可以跳过二进制位是0的数。 \4. 数组中只有一个数出现了奇数次，其他数都出现偶数次，找出这个数 这道题还是使用了异或的性质，两个相同的数异或等于0，遍历一遍数组就可以得到出现奇数次的那个数。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F04%2F11%2F2018-04-11%2F</url>
    <content type="text"><![CDATA[每个人曾经都是这样。生病时才会回忆健康的时光是多么舒畅，重病时才会怀念轻病时的日子是多么安详。陷入低谷时才会醒悟平坦的道路上多么晴朗，堕入深渊时才会感谢低谷时的阳光多么豁亮。终于明白，每时每刻的我们都是幸运的，因为任何苦难之后都可能会加上一个“更”字。]]></content>
      <categories>
        <category>心路历程</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言允许初始化列表中末尾出现多余的逗号]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-1%2F</url>
    <content type="text"><![CDATA[C语言允许初始化列表中出现多余的逗号，例如： 1int days[] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, &#125;; 为什么这种特性是有用的？ 123456789101112#include &lt;stdio.h&gt; int main(int argc,char** argv)&#123; enum qs&#123; Va = 5, Vb, Vc, &#125; s; printf(&quot;a=%d,b=%d,c=%d&quot;,Va,Vb,Vc); return 0; &#125; 像enum枚举中的条目有可能是根据其它资源来的，而程序员会制作代码生成工具来生成它，所以就允许enum中的多余逗号。像int i = 9,j = 0;这种用法完全可以拆成int i=9;int j=0;因此不会增加代码生成器的负担，所以不支持int i=9,j=0,; 像这种代码，如果用代码生成器去读资源然后写进去，那么每生成一行都需要在末尾加一个逗号来分隔。C允许最后一行有多余的逗号，那就可以不用单独去处理最后一行了，减轻了代码生成器的制作负担，同时因为不用自行删除最后一个逗号，代码生成器的编写也就更不容易出错了。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历（根据后序遍历中序遍历推出层序遍历）]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%2F</url>
    <content type="text"><![CDATA[对于二叉树的遍历，分为深度优先遍历与广度优先遍历，广度优先遍历有时又称作层序遍历。而深度优先遍历又分为前序遍历，中序遍历和后序遍历。三者之间的区别主要在于根结点的遍历顺序。前序遍历的顺序是根结点-&gt;左子树-&gt;右子树，中序遍历顺序是左子树-&gt;根结点-&gt;右子树，后序遍历顺序是左子树-&gt;右子树-&gt;根结点。现在给出树的后序遍历与中序遍历，要求写出该树的层序遍历。以下是pat上的例题： 给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。 输入格式： 输入第一行给出一个正整数N（&lt;=30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。 输出格式： 在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例： 12372 3 1 5 7 6 41 2 3 4 5 6 7 输出样例： 14 1 6 3 5 7 2 分析： 树的后序遍历特点是最后一个遍历的永远是根结点，由样例很容易看到4即为该树的根结点。而中序遍历的特点是根结点的左边永远是根结点的左子树部分，右边永远是根结点的右子树部分。而树的每一个子树都可以作为新的根。因此二者结合起来很容易将整个树构建出来。以样例为例，首先可以从后序遍历确定4为根结点，然后对照着中序遍历找到4的中序位置为第4位，然后以4为界将树分为以左子树为根的树和以右子树为根的树。现在可以确定根的左子树与右子树的个数分别为m，n，而后序遍历先遍历左子树部分，因此可以确定左子树部分为第1~m位，右子树部分为m+1~m+n位，最后一位为根结点。而左子树部分最后一位即第n位为左子树部分的根即左子树，同理右子树也一样。由此我们只需建立一个树遍历的函数ergodic(int root, int start, int end, int index)即可。其中root为根结点，start与end为由该根结点所衍生出的所有子树的范围，index记录该树的位置。由后序遍历可知end即为根结点的位置，有start开始遍历中序，直到找到根结点在中序遍历中的位置i，在以i为界划分为（start，i-1）与（i+1，end）两部分，而root则为后序遍历中（start，end）中的end位置，即为root-end+i-1的位置。我们初始树的所有结点为-1，意味空值，因此最终搭建的树只需按顺序遍历所有有值部分即可。以下是代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;post, in, level(100000, -1); int N; void ergodic(int root, int start, int end, int index) &#123; int i = start; if (start &gt; end) return; while (i &lt; end&amp;&amp;in[i] != post[root]) i++; level[index] = post[root]; //cout &lt;&lt; root &lt;&lt; start &lt;&lt; end &lt;&lt; i &lt;&lt; endl; ergodic(root - 1 - end + i, start, i - 1, 2 * index + 1); ergodic(root - 1, i + 1, end, 2 * index + 2); &#125; int main() &#123; cin &gt;&gt; N; post.resize(N); in.resize(N); for (int i = 0; i &lt; N; i++) cin &gt;&gt; post[i]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; in[i]; ergodic(N - 1, 0, N - 1, 0); for (int i = 0, cnt = 0; i &lt; level.size(); i++) &#123; if (level[i] != -1) &#123; cout &lt;&lt; level[i]; cnt != N - 1 ? cout &lt;&lt; &apos; &apos; : cout &lt;&lt; endl; cnt++; &#125; &#125; return 0; &#125; 对于前序遍历也一样，因为前序遍历的特点和后序遍历的特点刚好相反，前序遍历第第一位总是根结点。根据两种遍历即可推出整棵树的结构，搭建完树的结构，任何遍历都会很方便。]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++八进制赋值与输入常见陷阱]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%20-%201%2F</url>
    <content type="text"><![CDATA[在C语言及C++中，一个整形数值前如果有一个数字0，则代表该整形数值为八进制数。例如int a，a = 010，则a的十进制数值为8，八进制数值为10。但是在输入a的时候，输入010，如果用scanf（“%d”，&amp;a），则将会被当做十进制10识别。而在c++中使用cout&lt;&lt;a时，也将会被默认为十进制输入。以下是测试用例。 12345678910#include&lt;iostream&gt; using namespace std; int main() &#123; int a = 010; cout &lt;&lt;&quot;将010赋给a时：a = &quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;请输入a:&quot;; cin &gt;&gt; a; cout &lt;&lt; &quot;将010输入给a时：a = &quot; &lt;&lt; a; return 0; &#125; 由此可知，cout默认是以十进制进行输入的。因此，我们在赋值与输入时，得格外注意进制之间的转换。例如： 12345678struct temp&#123; int a; int b; int c; &#125;temp_1 = &#123; 001, 010, 222 &#125;; 我们经常会在赋值时为了将数值对齐显得美观而在数值之前添加0，这样往往会导致得到的结果错误，因为系统将之默认为八进制赋值。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>C语言基础</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>进制</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据结构]L2-022. 重排链表]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-3%2F</url>
    <content type="text"><![CDATA[L2-022. 重排链表给定一个单链表 L1→L2→…→Ln-1→Ln，请编写程序将链表重新排列为 Ln→L1→Ln-1→L2→…。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。 输入格式： 每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (&lt;= 105)。结点的地址是5位非负整数，NULL地址用-1表示。 接下来有N行，每行格式为： Address Data Next 其中Address是结点地址；Data是该结点保存的数据，为不超过105的正整数；Next是下一结点的地址。题目保证给出的链表上至少有两个结点。 输出格式： 对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 输入样例： 123456700100 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 输出样例： 12345668237 6 0010000100 1 9999999999 5 1230912309 2 0000000000 4 3321833218 3 -1 分析： 一道数据结构链表题。由于每一次输出链表两边的元素，因此可以构建一个双向链表。即结构体中储存上一个元素pre，数据data，下一个元素next。然后设置一个根结点root和尾结点tail，分别指向第一个结点地址和最后一个结点地址。先输出tail，tail指向对应上一个元素pre。再输出root，root指向对应下一个元素next，以此循环。直到tail与root相遇时输出tail，终止循环。输出tail对应数据时，可以输出tail，data，root，输出root对应数据时，可以输出root，data，tail。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt; #define Maxn 100000 using namespace std; struct Lists &#123; int pre; int data; int next; Lists() &#123; pre = -1; data = 0; next = -1; &#125; &#125;List[Maxn]; int main() &#123; int root, N, tail; scanf(&quot;%d%d&quot;, &amp;root, &amp;N); for (int i = 0; i &lt; N; i++) &#123; int temp; scanf(&quot;%d&quot;, &amp;temp); scanf(&quot;%d%d&quot;, &amp;List[temp].data, &amp;List[temp].next); if (List[temp].next != -1) List[List[temp].next].pre = temp; else tail = temp; &#125; int flag = 0; while (root != tail) &#123; printf(&quot;%05d %d %05d\n&quot;, tail, List[tail].data, root); tail = List[tail].pre; if (root == tail) break; printf(&quot;%05d %d %05d\n&quot;, root, List[root].data, tail); root = List[root].next; &#125; printf(&quot;%05d %d -1\n&quot;, root, List[root].data); return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[并查集]L2-024. 部落]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-2%2F</url>
    <content type="text"><![CDATA[L2-024. 部落时间限制 120 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。 输入格式： 输入在第一行给出一个正整数N（&lt;= 104），是已知小圈子的个数。随后N行，每行按下列格式给出一个小圈子里的人： K P[1] P[2] … P[K] 其中K是小圈子里的人数，P[i]（i=1, .., K）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。 之后一行给出一个非负整数Q（&lt;= 104），是查询次数。随后Q行，每行给出一对被查询的人的编号。 输出格式： 首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出“Y”，否则输出“N”。 输入样例： 1234567843 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 输出样例： 12310 2YN 分析： 本题又是一道并查集。我的做法是用映射，将所有人映射到对应的圈子中。例如第i个圈子共有k个人，分别为k1…kj…kk。则map[kj]=i。倘若kj已经有对应的圈子，那将两个圈子联系起来。即Union（map[kj]，i）。此外设置计数器sum，每一次执行完map[kj]=i之后sum++，即未重复的人加一。最后计算每一个圈子i是否等于pre[i]，计算独立圈子的个数。判断两个人是否是一个部落，只需查询他们映射的圈子是否相同，即root(map[a])是否等于root(map[b])。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt; #include&lt;cstdio&gt; #define MAXN 10005 using namespace std; int N, k; int pre[MAXN]; int maps[MAXN]; int root(int x) &#123; while (x != pre[x]) &#123; pre[x] = pre[pre[x]]; x = pre[x]; &#125; return x; &#125; void Union(int px,int py) &#123; px = root(px); py = root(py); if (px != py) pre[py] = px; &#125; int main() &#123; cin &gt;&gt; N; int sum = 0; for (int i = 0; i &lt; MAXN; i++) &#123; pre[i] = i; maps[i] = 0; &#125; for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; k; while (k--) &#123; int temp; cin &gt;&gt; temp; if (!maps[temp]) &#123; maps[temp] = i; sum++; &#125; else Union(maps[temp], i); &#125; &#125; int count = 0; for (int i = 1; i &lt;= N; i++) if (pre[i] == i) count++; printf(&quot;%d %d\n&quot;, sum, count); cin &gt;&gt; k; while (k--) &#123; int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; if (root(maps[xx]) == root(maps[yy])) printf(&quot;Y\n&quot;); else printf(&quot;N\n&quot;); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++结构体内部初始化]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-1%2F</url>
    <content type="text"><![CDATA[我都知道，c语言中结构体内部是不支持初始化的。如果要初始化结构体，可以在声明变量时进行初始化。例如： 123456struct Test&#123; int a; char b; double c; &#125;; Test test_1 = &#123; 1, &apos;a&apos;, 0 &#125;; 然而c++中结构体内部在声明变量的同时可以声明函数，这为结构体内部初始化提供了很大的便利。 因此上面用例可以写成： 12345678910struct Test&#123; int a; char b; double c; Test()&#123; a = 1; b = &apos;a&apos;; c = 0; &#125; &#125;; 这为定义结构体时关于初始化问题提供了很大的便利。 以下是代码及运行结果： 12345678910111213141516#include&lt;iostream&gt; using namespace std; struct Test &#123; int a; char b; double c; Test() &#123; a = 1; b = &apos;a&apos;; c = 0; &#125; &#125;Text_1; int main() &#123; cout &lt;&lt; Text_1.a &lt;&lt; endl &lt;&lt; Text_1.b &lt;&lt; endl &lt;&lt; Text_1.c; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模拟]来一瓶82年拉菲（酒杯问题）]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28%2F</url>
    <content type="text"><![CDATA[问题描述： 悠神最近过生日，朋友纷纷来贺。现有一瓶82年拉菲与若干酒杯。酒杯呈三角形酒塔摆放，即每一个酒杯摆放在下一层两个酒杯中间，最下面一层酒杯摆放在桌面上。共有N(1&lt;=N&lt;=20)层酒杯，第k层共有k个酒杯。悠神将拉菲倒进第一层的酒杯中，速度为1杯/s，倒满后酒会向左右两个方向溢出，假设会全部溢出到这个酒杯下面相邻的两个酒杯中。然而悠神有洁癖，他不喜欢浪费，更不喜欢浸湿他心爱的桌布，所以请你计算一下第几秒之后桌布会被浸湿。 eg：如图所示为3层时的情况。第一层倒满需要1s，第二次倒满需要2s，第三层首次倒满需要2s。所以共需1+2+2=5s。 输入： 输入N(1&lt;=N&lt;=20)。 输出： 桌布浸湿时至少所需时间（取整数）。 输入样例： 2 输出样例： 3 分析： 桌布浸湿只与最下层最中间位置何时倒满有关，因此只需计算最下层中间位置酒杯的状态。由于时间取整，所以只需模拟出第一杯共倒了多少杯酒，即为多少s。而每一个酒杯共倒了多少酒与上一层相邻两个酒杯相关，及第i层第j个酒杯的酒只与第i-1层第j-1个和第j个酒杯的酒相关。及wine[i][j]=wine[i-1][j-1]+wine[i-1][j];由于酒杯有两种状态，及未满状态和倒满状态，所以要判断wine[i-1]层的酒是否&gt;1。 12345678910111213141516171819202122#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define MAXN 20 int main() &#123; int N; while (~scanf(&quot;%d&quot;, &amp;N)) &#123; double wine[MAXN + 1][MAXN + 1] = &#123; 0 &#125;; double temp = 0; while (wine[N][N / 2 + 1] &lt; 1) &#123; memset(wine, 0, sizeof(wine)); temp++; wine[1][1] = temp; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; wine[i][j] += (wine[i - 1][j - 1] &gt; 1 ? (wine[i - 1][j - 1] - 1) / 2.0 : 0) + (wine[i - 1][j] &gt; 1 ? (wine[i - 1][j] - 1) / 2.0 : 0); &#125; &#125; &#125; printf(&quot;%g\n&quot;, wine[1][1]); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]愿天下有情人都是失散多年的兄妹]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-2%2F</url>
    <content type="text"><![CDATA[题目概述：L2-016. 愿天下有情人都是失散多年的兄妹时间限制 200 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？ 输入格式： 输入第一行给出一个正整数N（2 &lt;= N &lt;= 104），随后N行，每行按以下格式给出一个人的信息： 本人ID 性别 父亲ID 母亲ID 其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。 接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。 注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。 输出格式： 对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出“Never Mind”；如果是异性并且关系出了五服，输出“Yes”；如果异性关系未出五服，输出“No”。 输入样例： 12345678910111213141516171819202122232425262728293031323334352400001 M 01111 -100002 F 02222 0333300003 M 02222 0333300004 F 04444 0333300005 M 04444 0555500006 F 04444 0555500007 F 06666 0777700008 M 06666 0777700009 M 00001 0000200010 M 00003 0000600011 F 00005 0000700012 F 00008 0888800013 F 00009 0001100014 M 00010 0999900015 M 00010 0999900016 M 10000 0001200017 F -1 0001200018 F 11000 0001300019 F 11100 0001800020 F 00015 1111000021 M 11100 0002000022 M 00016 -100023 M 10012 0001700024 M 00022 10013900021 0002400019 0002400011 0001200022 0001800001 0000400013 0001600017 0001500019 0002100010 00011 输出样例： 123456789Never MindYesNever MindNoYesNoYesNoNo 1分析： 利用广度优先搜索，将每个人及双亲放入集合mab中，假如集合长度为改变，则说明mab中已存在这个人，则证明双方是近亲。visit用来记录层数。五层时结束搜索。 AC代码BFS： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define MAXN 100005 using namespace std; struct inf &#123; int fa; int ma; char sex; &#125;; inf node[MAXN]; int visit[MAXN]; bool flag[MAXN]; int N; bool BFS(int x1,int x2) &#123; memset(visit, 0, sizeof(visit)); queue&lt;int&gt;family; set&lt;int&gt;mab; family.push(x1); family.push(x2); visit[x1] = 1; visit[x2] = 1; while (!family.empty()) &#123; int top = family.front(); family.pop(); int size = mab.size(); mab.insert(top); if (mab.size() == size) &#123; return true; break; &#125; if (visit[top] &lt;= 4) &#123; if (node[top].fa) &#123; family.push(node[top].fa); visit[node[top].fa] += visit[top] + 1; &#125; if (node[top].ma) &#123; family.push(node[top].ma); visit[node[top].ma] += visit[top] + 1; &#125; &#125; &#125; return false; &#125; int main() &#123; cin &gt;&gt; N; memset(node, 0, sizeof(node)); memset(flag, 0, sizeof(flag)); while (N--) &#123; int id, fa, ma; char ch[2]; scanf(&quot;%d%s%d%d&quot;, &amp;id, ch, &amp;fa, &amp;ma); node[id].sex = ch[0]; flag[id] = true; if (fa != -1) &#123; node[id].fa = fa; node[fa].sex = &apos;M&apos;; flag[fa] = true; &#125; if (ma != -1) &#123; node[id].ma = ma; node[ma].sex = &apos;F&apos;; flag[ma] = true; &#125; &#125; cin &gt;&gt; N; while (N--) &#123; int per1, per2; cin &gt;&gt; per1 &gt;&gt; per2; if (node[per1].sex == node[per2].sex) printf(&quot;Never Mind\n&quot;); else &#123; if (BFS(per1, per2)) printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>pat天梯赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector的嵌套实现二维数组，解决矩阵相乘问题]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26%2F</url>
    <content type="text"><![CDATA[定义vector的元素可以是一个vector。比如， vector&lt;vector&gt; 即表示一个二维int数组，里层的vector表示第一维， 外层的vector表示第二维。 例题描述：L1-048. 矩阵A乘以B时间限制 400 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。 输入格式： 输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。 输出格式： 若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出“Error: Ca != Rb”，其中Ca是A的列数，Rb是B的行数。 输入样例1： 12345672 31 2 34 5 63 47 8 9 0-1 -2 -3 -45 6 7 8 输出样例1： 1232 420 22 24 1653 58 63 28 输入样例2： 123456783 238 2643 -50 173 2-11 5799 6881 72 输出样例2： 1Error: 2 != 3 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int M1, N1, M2, N2; int main() &#123; cin &gt;&gt; M1 &gt;&gt; N1; vector&lt;int&gt;alie(N1); vector&lt;vector&lt;int&gt;&gt;ahang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N1; j++) &#123; scanf(&quot;%d&quot;, &amp;alie[j]); &#125; ahang[i] = alie; &#125; cin &gt;&gt; M2 &gt;&gt; N2; vector&lt;int&gt;blie(N2); vector&lt;vector&lt;int&gt;&gt;bhang(M2); for (int i = 0; i &lt; M2; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; scanf(&quot;%d&quot;, &amp;blie[j]); &#125; bhang[i] = blie; &#125; if (N1 != M2) printf(&quot;Error: %d != %d\n&quot;, N1, M2); else &#123; vector&lt;int&gt;anslie(N2); vector&lt;vector&lt;int&gt;&gt;anshang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; anslie[j] = 0; for (int k = 0; k &lt; N1; k++) anslie[j] += ahang[i][k] * bhang[k][j]; &#125; anshang[i] = anslie; &#125; printf(&quot;%d %d\n&quot;, M1, N2); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2 - 1; j++) printf(&quot;%d &quot;, anshang[i][j]); printf(&quot;%d\n&quot;, anshang[i][N2 - 1]); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>stl</tag>
        <tag>算法</tag>
        <tag>vector</tag>
        <tag>pat天梯赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F03%2F13%2F2018-03-13%20-%201%2F</url>
    <content type="text"><![CDATA[每个人都会仰赖自己的知识和认识，并被这些东西所束缚着，还将这些东西称为现实。知识和认识是很暧昧的东西，现实也许只是镜中花水中月，人都是活在自己的执念中的。]]></content>
      <categories>
        <category>心路历程</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F03%2F13%2F2018-03-13%2F</url>
    <content type="text"><![CDATA[我终究是个小人物，却整日想着帮助身边的人找到归属。哪怕最后只剩下我一个人。然而，我从未后悔。因为走过的路，总有花香相陪。前程的路，还有清风相随。]]></content>
      <categories>
        <category>心路历程</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F02%2F22%2F2018-02-22%2F</url>
    <content type="text"><![CDATA[缘，妙不可言，在于你永远无法预料，下一秒将会和谁分离，一个转身，永不相见：在于你永远无法预料，下一秒将会和谁相遇，一个眼神，为他沦陷。]]></content>
      <categories>
        <category>心路历程</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F02%2F03%2F2018-02-03%2F</url>
    <content type="text"><![CDATA[韶光浅， 岁月转轴调弦 悠悠流曲耳边， 依依情记心间 又是一季似水流年 愿你跨过千山， 归来一如从前 ——浅悠悠]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS的用途与选择]]></title>
    <url>%2F2018%2F02%2F01%2F2018-02-01%2F</url>
    <content type="text"><![CDATA[1.BFS是用来搜索最短径路的解是比较合适的，比如求最少步数的解，最少交换次数的解，因为BFS搜索过程中遇到的解一定是离根最近的，所以遇到一个解，一定就是最优解，此时搜索算法可以终止。这个时候不适宜使用DFS，因为DFS搜索到的解不一定是离根最近的，只有全局搜索完毕，才能从所有解中找出离根的最近的解。（当然这个DFS的不足，可以使用迭代加深搜索ID-DFS去弥补）2.空间优劣上，DFS是有优势的，DFS不需要保存搜索过程中的状态，而BFS在搜索过程中需要保存搜索过的状态，而且一般情况需要一个队列来记录。3.DFS适合搜索全部的解，因为要搜索全部的解，那么BFS搜索过程中，遇到离根最近的解，并没有什么用，也必须遍历完整棵搜索树，DFS搜索也会搜索全部，但是相比DFS不用记录过多信息，所以搜素全部解的问题，DFS显然更加合适。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类的3种继承方式]]></title>
    <url>%2F2018%2F01%2F24%2F2018-01-24%2F</url>
    <content type="text"><![CDATA[简单地说下C++类的3种继承方式，分别是public继承，protected继承，private继承。 最常用的还是public继承。class默认的是private继承，它的member如果没写权限也是默认 private。struct则相反，默认的是public继承。结合下面的图示和代码，对C++的继承就有了 比较清晰的认识了。 继承之后，derived class 继承过后的member的属性就是图中所示。 代码主要从： 1.基类成员对其对象的可见性： 基类成员对派生类的可见性： 基类成员对派生类对象的可见性： 这3个方面谈的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt; class base&#123; public: base()&#123; a = 0; b = 1; c = 2; &#125; int a; protected: int b; private: int c; &#125;; class derived1 : public base&#123;//public继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived2 : protected base&#123;//protected继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived3 : private base&#123;//private继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived4 : public derived3&#123;//base的member不能被private继承的派生类的子类访问 public: void fun()&#123; // std::cout&lt;&lt;a; &#125; &#125;; class derived5 : base&#123;//默认private继承 void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; int main(void) &#123; base b1; derived1 d1; derived2 d2; derived3 d3; d1.fun(); d2.fun(); d3.fun(); std::cout&lt;&lt;b1.a;//base class Object只能访问public member std::cout&lt;&lt;d1.a;//public继承时 derived class Object只能访问base class的public member //std::cout&lt;&lt;d1.b&lt;&lt;d1.c;//不能访问 //std::cout&lt;&lt;d2.a&lt;&lt;d2.b;//protected继承时 derived class Object不能问访base class的member //std::cout&lt;&lt;d3.a;//private继承时 derived class Object不能问访base class的member return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sstream和strstream的用法]]></title>
    <url>%2F2018%2F01%2F24%2F2018-01-24%20-%201%2F</url>
    <content type="text"><![CDATA[在C++有两种字符串流,也称为数组I/O流，一种在 strstream 中定义，另一种在 sstream 中定义。它们实现的东西基本一样。strstream里包含： 1234class strstreambuf;class istrstream;class ostrstream;class strstream; 它们是基于C类型字符串char*编写的 sstream中包含： 1234class stringbuf;class istringstream;class ostringstream;class stringstream; 它们是基于std::string编写的 因此ostrstream::str()返回的是char*类型的字符串而ostringstream::str()返回的是std::string类型的字符串在使用的时候要注意到二者的区别，一般情况下推荐使用std::string类型的字符串当然如果为了保持和C的兼容，使用strstream也是不错的选择。但要记住一点,strstream虽仍然是C++语言标准的一部分,但已被C++标准宣称为“deprecated”，也就是不再提倡使用了，也说不定以后干粹就没了。 先介绍一下sstream 123456789//strigstream流以空格为边界符,使用其须包含sstream头文件//istringstream 用法istringstream istring;string ss(&quot;ss 8346520&quot;);istring.str(ss);int i=0;string s;istring&gt;&gt;s&gt;&gt;i;cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; 或者 12345istringstream istring(&quot;ss 8346520&quot;);int i=0;string s;istring&gt;&gt;s&gt;&gt;i;cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; 都将打印：s内容是ss,i内容是8346520的结果; 1234567891011//ostringstream 用法string s=&quot;test&quot;;int i=8346520;int j=0;string s1;ostringstream ostring; //不能写成ostringstream ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;cout&lt;&lt;ostring.str()&lt;&lt;endl; //ostring流内保存内容是test 8346520istringstream istring(ostring.str());istring&gt;&gt;s1&gt;&gt;j;//要注意此处的顺序;cout&lt;&lt;s1&lt;&lt;&quot;――――&quot;&lt;&lt;j&lt;&lt;endl; 简单说说strstream:基于数组的类有istrstream、ostrstream和strstream。它们分别用来创建输入、输出和输入／输出流。这些类的基类之一是strstreambuf，它定义了派生类使用的几个底层的具体属性。除了strstreambuf以外，istream也是istrstream的基类。类ostrstream包括了类ostream。strstream也包括了类iostream。所以，所有基于数组的类和“普通”I／O类一样存取相同的成员函数。创建基于数组的输出流要将一个输出流和一个数组关联起来，可使用下列ostream的构造函数：ostrstream ostr（char＊buf，int size，int mode＝ios：：out）；其中，buf是指向数组的指针，该数组接收写入流的字符。数组的长度由参数size确定。缺省时，流以输出方式打开，但也可以将几项或在一起复合为所需的方式（例如，可以包含ios：：app使输出添加在数组中已存在的信息的尾部）。mode的缺省值可以满足大多数的要求。一旦打开了一个基于数组的输出流，所有对这个流的输出就放在数组中。但是，任何输出都不能写到数组的限界之外，任何这种企图都会导致错误。 下面是一个介绍基于数组的输出流的简单程序。 12345678910111213141516#include &lt;iostream&gt;#include &lt;strstream&gt;using namespace std;int main()&#123;int arraysize=50;char *pbuffer=new char[arraysize];ostrstream ostr(pbuffer,arraysize,ios::out);ostr&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot; &quot;;ostr&lt;&lt;99-14&lt;&lt;hex&lt;&lt;&quot; &quot;;ostr.setf(ios::showbase);ostr&lt;&lt;100&lt;&lt;ends; //使用ostrstream输出到流对象的时候,要用ends结束字符串cout&lt;&lt;pbuffer;delete[] pbuffer;return 0;&#125; 使用数组作输入:要将输入流和数组关联起来，可使用下列istrstream的构造函数： 1istrstream istr（char*buf）； 其中，buf是指向数组的指针，该数组作为每次向流输入的字符源。buf所指的数组必须以空结束。空结束符从不从数组中读取。 下面是一个用字符串输入的例子: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;strstream&gt;using namespace std;int main()&#123;const char s[]=&quot;10 Hello 15 12.23 done&quot;;istrstream ins(s);int i;char str[80];float f;//reading： 10 Helloins &gt;&gt;i;ins &gt;&gt;str;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;str&lt;&lt;endl;// reading：f 12.23 done.ins&gt;&gt;i;ins&gt;&gt;f;ins&gt;&gt;str;cout&lt;&lt;hex&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;str;return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>C/C++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式练习题集(附答案)]]></title>
    <url>%2F2018%2F01%2F21%2F2018-01-21%2F</url>
    <content type="text"><![CDATA[前言​ 好久到没有去写关于正则表达式的总结了，虽然自己写了一些关于正则表达式的东西。但是 ​ 感觉上对正则表达式还停留在网上查找的阶段，对于大部分的人来说，很难写自己的正则表达式 ​ 对于正则表达式笔者也做过相关的总结。呃，过了一段时间还是模糊了。因此找一些练习题来找 ​ 回自己的记忆。 ​ 需要说明的是这些练习题有的是网上的！ 初级练习​ 1、求非负整数 : ^\d+$ ​ Tips:需要注意的是这个匹配模式为多行模式下进行的 ​ ​ 2、匹配正整数： ^[1-9][1-9][0-9]$ 在网上也有这种写法的 ^[0-9][1-9][0-9]$ ​ 这里截图我也不贴了，前者指能匹配123012这种整数，而后者可以匹配001230。 ​ 取舍就看实际的需要了 ​ 3、非正整数：^(-\d+|(0+))$ ​ 4、负整数：^-[0-9][1-9][0-9]$ ​ 5、整数 ：^-?\d+$ ​ 6、非负浮点数 ：^\d+(.\d+)?$ ​ 7、正浮点数 ：^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ ​ 8、非正浮点数 ：^((-\d+(.\d+)?)|(0+(.0+)?))$ ​ 9、负浮点数：^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ ​ 10、浮点数：^(-?\d+)(.\d+)?$ ​ 11、有数字、26个英文字母组成的字符串：^[A-Za-z0-9]+$ 中级练习​ 1、长度为8-10的用户密码（以字母开头、数字、下划线） ​ ^[a-zA-Z]\w{7,10}$ ​ 2、验证输入只能是汉字 ： ^[\u4e00-\u9fa5]{0,}$ ​ 3、电子邮箱验证：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ ​ 4、URL地址验证：^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ​ 5、电话号码的验证：请参考：http://blog.csdn.net/kiritor/article/details/8733469 ​ 6、简单的身份证号验证：\d{15}|\d{18}$ ​ ………………………… 高级练习​ 1、提取并捕获html标签内容： ​ &lt;a(?: [^&gt;])+href=([^ &gt;])(?: [^&gt;])&gt; ​ ​ &lt;OPTION\s.*?&gt; ​]]></content>
      <categories>
        <category>程序人生</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦的索引]]></title>
    <url>%2F2017%2F05%2F20%2F2017-5-20%2F</url>
    <content type="text"><![CDATA[梦的索引 浅悠悠 5.20 to.** (从此，某人不理我) 一 风，轻拢着寒衣， 愁云，悄然漫入天际。 夜，显得如此孤寂。 寂静，淹没了每一个字节， 而我，沉浸在如梦般的程序。 不妨覆盖这寂寞的夜色， 将整个世界虚拟。 二 调用一个time函数， 永不熄灭的星空由我来设计。 早晨迎接春的花香， 午后拥抱夏的暖阳， 黄昏品尝秋的硕果， 静夜寻觅冬的足迹。 四季以奇幻的循环交替。 三 调用一个process函数， 柏拉图的理想国由我来开辟。 辽阔的天空一碧如洗， 雄鹰与黄鹂整齐地共鸣， 城市以和谐的进程刷新， 物竞天择已被仁爱更替。 世界如蒲公英般无忧无虑。 四 再定义一个爱你的函数， 永恒是爱的生命周期。 星空因你而努力闪耀， 四季因你而相伴朝夕， 花儿酿香渲染着你的气息， 阳光拂晓映射着你的甜蜜。 在这个世界里， 你是唯一的主题。 五 我将自己作为参数， 向爱你的函数传递， 却意外发现你并不在我的域。 我开始不断重载爱的定义， 将你我的变量封存在同一结构体。 但很快系统出现了bug。 当进程陷入死循环时， 才发现此算法不可逆。 六 也许你已在我的世界 永远赋上了静态的属性。 系统不断将思念返回压入我的堆栈， 而我的内存此刻已满满是你。 我向系统申请最后一点内存， 打开心的端口监听你的信息， 返回却总是操作失败的消息。 七 我想重写爱的模板， 再一次将爱传递， 却无法返回你也爱我的信息。 我试图虚拟出最后一点内存， 将“你爱我吗”的字符串压入栈尾， 打开最后的端口传递给你。 八 倘若返回值为真， 我愿释放掉整个世界的内存， 从此只储存关于你的回忆。 否则我愿析构自己， 将所有的喜怒哀乐封进内域。 从此不需要让你知道， 我一直爱你。 九 此端，彼岸， 谁在孤独地将二叉树上的结点遍历？ 谁苦苦寻找连接着爱的网络服务器？ 虚拟，现实， 我是茫茫内存中哪一个孤独的进程？ 又是匆匆人海里哪一个寻梦的躯体？ 十 我能编译出整个世界， 却无法虚拟真实的你。 爱的程序， 也解不开你我的局。 也许程序注定是梦， 而你， 永远是我梦的索引。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丽日芳馨]]></title>
    <url>%2F2017%2F05%2F11%2F2017-05-11%2F</url>
    <content type="text"><![CDATA[映日清风浴春蕾，萋萋谁解芳草馨。 蝶羽蹁跹花儿醉，野韵泊然守天浔。 春风化雨蝶双去，冷月袭风蕊浸淋。 愁霖散尽曙光见，一片清新护花魂。 （本来是写给方大仙的，然后就误会了，方大仙再也没理过我。唉，从此江郎才尽。不过至少曾经我一直在像她学习）]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绛影流风]]></title>
    <url>%2F2016%2F12%2F09%2F2016-12-09%2F</url>
    <content type="text"><![CDATA[红尘滚滚浸离情，泪眼朦胧残月明。 乍见羲和乘风耀，一笑淡然气自雄。 流飞翰墨升丹气，朗润丹青贯玉虹。 愿效流风倾岁月，何人与我竞峥嵘。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雪韵]]></title>
    <url>%2F2016%2F11%2F23%2F2016-11-23%2F</url>
    <content type="text"><![CDATA[霞霄铸雪竟蹁跹，荡入苍穹冻川峦。 乾坤万里皆悸颤，日恼月愧不胜寒。 借得阳煦三分暖，化作凌霜戏犂元。 莫道冰心无暖意，且看清洁满人间。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[踏莎行·缘归梦]]></title>
    <url>%2F2016%2F10%2F13%2F2016-10-13%2F</url>
    <content type="text"><![CDATA[晨曦送暖，莺韵翩跹，桃花春风共缠绵。 笑靥倾墨润青笺，无悔牵绊话尘缘。 暮色如烟，花落无言，江水未竭浸桑田。 梦里飞花随风远，空留一诺伴心眠。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长相思·空城]]></title>
    <url>%2F2016%2F09%2F15%2F2016-09-15%2F</url>
    <content type="text"><![CDATA[秋谧静，月朦胧， 中秋晚月浸空城。城涌人匆匆。 人味浓，情味空， 万径同归意难融。双袖迎清风。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六字令]]></title>
    <url>%2F2016%2F09%2F11%2F2016-09-11%2F</url>
    <content type="text"><![CDATA[琴，一曲弦歌揽客心。曲终尽，何处觅知音。 棋，黑白博弈方寸迷。红尘局，进退两迷离。 书，满腹离愁一纸出。皆归寂，墨韵话孤独。 画，妙笔浸润满庭花。花易落，秀色映谁家。 诗，相思化作墨中痴。声声慢，平仄为谁织。 酒，彼时笑靥遵底留。断肠人，独酌夜无休。 花，群芳争艳恋春霞。秋风起，流水逝芳华。 茶，一叶清香静繁华。淳意散，花叶隔天涯。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一剪梅·尘埃]]></title>
    <url>%2F2016%2F07%2F12%2F2016-07-12%2F</url>
    <content type="text"><![CDATA[风起流尘自轻狂，翛然而往，孑然飘扬。 奈何落地满凄凉，天也苍苍，路也茫茫。 泪浸尘埃人断肠，烟隐轩窗，人隐何方？ 莫如引歌醉残阳，一曲新词，笑尽沧桑。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参商永离]]></title>
    <url>%2F2016%2F06%2F20%2F2016-06-20%2F</url>
    <content type="text"><![CDATA[白首双星寄麒麟， 只是相觅恰黄昏。 夕阳有意聚离人， 冷月无情散星辰。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十六字令]]></title>
    <url>%2F2016%2F05%2F21%2F2016-05-21%2F</url>
    <content type="text"><![CDATA[棉，细雨蒙蒙润娇颜，风飘絮，离絮苦缠绵。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云行在天]]></title>
    <url>%2F2016%2F04%2F26%2F2016-04-26%2F</url>
    <content type="text"><![CDATA[玄霄蔽月百生愁， 星海云游榆光羞。 御风万里乾坤尽， 谁人与我竞风流？]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[情茧]]></title>
    <url>%2F2016%2F03%2F28%2F2016-03-28%2F</url>
    <content type="text"><![CDATA[残阳月掩掠青笺，青笺墨泣染长夜。 长夜辗转盼天明，天明又患残阳浅。 今宵又惊昨日梦，梦里飞花舞翩跹。 落英片片蝶成茧，为孰憔悴为孰残。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西江月·蝶双飞]]></title>
    <url>%2F2016%2F02%2F14%2F2016-02-14%2F</url>
    <content type="text"><![CDATA[华灯逐日争明，烟花伴月共辉。身隔千里心相随，胜过瑶池相会。今夕天涯独行，明夕伴君同归。风雨缠绵蝶双飞，换得此生无悔。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长相思·寄云梦]]></title>
    <url>%2F2016%2F02%2F08%2F2016-02-08%2F</url>
    <content type="text"><![CDATA[风萧萧， 雨萧萧， 风雨同程伴君老， 奈何山水遥。 云悄悄， 梦悄悄， 行云织梦芳踪渺， 梦里相思扰。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词穷墨尽]]></title>
    <url>%2F2016%2F01%2F28%2F2016-01-28%2F</url>
    <content type="text"><![CDATA[词叹墨尽难续情， 墨笑词穷一场空。 风润墨痕惊旧梦， 伊人随梦泪随风。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心泪无痕]]></title>
    <url>%2F2016%2F01%2F08%2F2016-01-08%2F</url>
    <content type="text"><![CDATA[瑟瑟寒风眷高楼， 街明巷寂夜悠悠。 独倚寒窗忆旧梦， 痴笑不觉心泪流。 青丝悄然落眉头， 欲笺新词只剩愁。 满腹情思何处寄？ 唯有黯然藏心头。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦里飞花]]></title>
    <url>%2F2015%2F12%2F27%2F2015-12-27%2F</url>
    <content type="text"><![CDATA[梦里飞花 浅悠悠 梨花点点， 琴瑟缓缓。 谁把情话， 浸润成芽？ …… 繁花艳艳， 诗意绵绵。 谁把韶光， 谱写成夏？ …… 黄花依依， 棋子稀稀。 谁把芳华， 飘落成砂？ …… 雪花凄凄， 画笔寂寂。 谁把青丝， 染成白发？ …… 梦里飞花， 孑然自暇。 谁的牵挂， 散尽天涯。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冲高]]></title>
    <url>%2F2015%2F12%2F19%2F2015-12-19%2F</url>
    <content type="text"><![CDATA[凌云雄鹰击红日，悬崖欲起先折翅； 梧桐枝头重生凤，涅槃之时浴火噬； 不经雨困长风袭，怎显鸿鹄冲天势； 孰敢与天试比高？且看我辈腾飞时。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冰清]]></title>
    <url>%2F2015%2F11%2F20%2F2015-11-20%2F</url>
    <content type="text"><![CDATA[霜飘雪绵竞翩跹， 巧借寒气铸玉颜。 冷面洁骨身如镜， 笑看浮云舞成眠。 栖居严冬梅相伴， 不与浑水染尘烟。 岂是冰蕊无情意？ 因守清纯在人间。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沁园春·约定]]></title>
    <url>%2F2015%2F11%2F07%2F2015-11-07%2F</url>
    <content type="text"><![CDATA[一日倾心，百日梦萦，终日魂销。 叹忆中所思，芳踪飘渺，梦中所念，素裹妖娆。 一向情深，奈何缘浅，咫尺之川万里遥。 平生意，化双飞双宿，共度花朝。 西风锐利如刀，惟连理双枝紧缠绕。 看风吹雾散，雨驻清涟。海誓山盟，怎能风飘。 山重水复，柳暗花明，一叶轻舟过险涛。 天涯路，愿青骢共骑，轻揽子腰。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鹧鸪天·断肠人]]></title>
    <url>%2F2015%2F10%2F31%2F2015-10-31%2F</url>
    <content type="text"><![CDATA[风袭青枝花欲坠，青枝倾尽心中累。 长恨残风戏嫩蕊，此身无力空心碎。 词中意，曲中悲。哀弦危柱有谁醉？ 潇潇冷雨送寒归，点滴皆是离人泪。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦·曲]]></title>
    <url>%2F2015%2F10%2F21%2F2015-10-21%2F</url>
    <content type="text"><![CDATA[夜轻轻舞动着寒衣， 风放纵着月色般的音律。 指尖轻触着跳动的音符， 在轻快的乐曲中将双目微闭。 …… 曲中回荡着少年悠扬的乐音， 陪伴着少女轻盈的笑语。 琴声轻拂着清脆的鸟鸣， 与你我一起赞美这自由的天地。 …… 风儿为这祥和的音符歌唱， 雨点为这宁静的四季舞动， 悠闲的人们不再追名逐利， 星星在你我怀中无忧的睡去。 …… 我没有那演绎梦境的曲， 只有一把弹奏孤独的琴。 漫天繁星早已没了踪迹， 只留下忧郁的孩子沉醉在梦里……]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>摘星集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遥光]]></title>
    <url>%2F2015%2F10%2F14%2F2015-10-14%2F</url>
    <content type="text"><![CDATA[日逐朝霞去昨痕， 轻抚晨光盼伊人。 繁星带月匆匆过， 只盼芳踪梦里寻。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[月隐风轻]]></title>
    <url>%2F2015%2F09%2F27%2F2015-09-27%2F</url>
    <content type="text"><![CDATA[风暖寒霜月无踪， 惟有孤夜伴秋风。 纵使秋风解我意， 旧愁吹去新愁生。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鹊桥仙·一眼万年]]></title>
    <url>%2F2015%2F08%2F20%2F2015-08-20%2F</url>
    <content type="text"><![CDATA[双星作合， 金风玉露， 朗月惹得谁羡。 悠悠天上一光年， 隔不断、深情一眼。 丝落无声， 天涯遥望， 织云又忆初见。 依依心上一瞬间， 便无悔、挚爱万年。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蝶恋花·相思字]]></title>
    <url>%2F2015%2F08%2F14%2F2015-08-14%2F</url>
    <content type="text"><![CDATA[秋风落尽花憔悴， 蝶欲起舞， 只怜茧中愧。 共饮青春赋一醉， 却叹聚散最心累。 此刻相思赋予谁， 彼时笑语， 漫天随风归。 失散绝句谁轻吟， 空弹高山对流水。]]></content>
      <categories>
        <category>诗词歌赋</category>
        <category>冰清集</category>
      </categories>
      <tags>
        <tag>原创诗词</tag>
      </tags>
  </entry>
</search>
