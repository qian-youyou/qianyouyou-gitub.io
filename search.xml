<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[计算几何]二维计算几何基础]]></title>
    <url>%2F2018%2F05%2F09%2F2018-05-09%2F</url>
    <content type="text"><![CDATA[三寸青笺，写不尽对你的思念。——随笔 用解析几何借助计算机处理几何问题存在着两大缺陷： 1）方程解的情况复杂，例如Ax+By+C=0； 2）存在着浮点误差积累。 计算几何采用了介于代数与几何之间的方式解决几何问题。它利用几何特性辅助简单的代数运算解决几何问题，既能精确求解，有提高了算法效率，并且不失几何的优美特性。 向量向量向量：既有大小又有方向的量。 向量的比较在平面坐标系下，某点的坐标用（x，y）表示，向量和点一样，也可以用x,y表示。 12345struct Point&#123; //点 double x,y; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; //构造函数方便代码编写&#125;;typedef Point Vector; //向量。从程序实现上，Vector只是Point的别名 向量的加减乘除12345678910111213141516//向量+向量=向量，点+向量=点Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y);&#125;//点-点=向量Vector operator - (Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y);&#125;//向量*数=向量Vector operator * (Vector A, double p) &#123; return Vector(A.x * p, A.y * p);&#125;//向量/数=向量Vector operator * (Vector A, double p) &#123; return Vector(A.x / p, A.y / p);&#125; 向量的比较123456789101112131415bool operator &lt; (const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x&amp;&amp;a.y &lt; b.y);&#125;//减下误差的必要比较const double eps=1e-8;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; if(x&gt;0) return 1; return -1;&#125;bool operator ==(const point&amp; a,const point&amp; b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125; 注意上面的“相等”函数用到“三态函数”dcmp,减少了精度问题。另外，向量有一个所谓的“极角”，即从x轴正半轴旋转到该向量方向所需要的角度。C标注库里的atan2函数就是用来求极角的。如向量（x,y）的极角就是atan2（y，x）（单位：弧度） 向量內积（点积）点积，向量α和β的点积等于二者长度的乘积再乘上它们夹角的余弦。当夹角大于90°时点积为负。两向量的点积为一个标量 α·β，它的大小为α·β=|α||β|cosθ，其中θ是&lt;α,β&gt; 余弦为偶函数，因此点积满足交换率。如果两向量垂直，点积为0。 几何意义α在β的投影α’与β的长度乘积 由定义易知当两向量夹角为锐角时点积值为正，夹角钝角为负，垂直为0 123456789double dot(Vector A,Vector B)&#123; //向量点积 return A.x*B.x+A.y*B.y;&#125;double Length(Vector A)&#123; //向量A长度 return sqrt(dot(A,A));&#125;double angle(Vector A,Vector B)&#123; //向量A和B夹角 return acos(dot(A,B)/Length(A)/Length(B));&#125; 向量外积（叉积）简单地说，两个向量u和w得叉积等于u和w组成的三角形的有向面积的两倍。 叉积的二维意义—-有向面积：外积大小为由u，w这两个向量围成的平行四边形有向面积。 两向量的叉积为一个矢量 a×b，设向量 P(x1,y1),Q(x2,y2)，向量 a 和向量 b 的叉积还是一个向量，长度为|PQ|=x1y2-x2y1;即为向量 P,Q 围成的四边形的面积。它的方向与向量PQ 垂直，并且使(P,Q,P×Q)成右手系。 几何意义 不难发现，叉积不满足交换率，cross（u，w）=-corss（w，u）。 12345678double cross(Vector A,Vector B) //叉积&#123; return A.x*B.y-A.y*B.x;&#125;double area(point A,point B,point C) //已知三个点 p0,p1,p2 的叉积函数&#123; return cross(B-A,C-A);&#125; 叉积的一个重要性质，判断两向量互相之间的顺逆时针关系。若 P×Q&gt;0，则P在Q 的顺时针方向；若 P×Q&lt;0，则P在Q 的逆时针方向；若 P×Q=0，则P和Q 共线，但可能同向也可能反向； 利用这一性质，可以将一个多边形的顶点按照顺时针或者逆时针方向排序，这就是极角排序。利用 sort 或者 qsort 函数，自己定义 cmp 函数即可。 12345678910//逆时针极角排序比较函数(double) bool cmp(const point &amp;a, const point &amp;b) &#123; double x = atan2(a.y, a.x), y = atan2(b.y, b.x); return x &lt; y; &#125; //象限极角排序比较函数(int)，不失精度 int cross(point p1,point p2,point p0)&#123; return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y); &#125; sort(p+1,p+n,cmp); 两向量的位置关系把叉积和点积组合在一起，很容易判断两向量的位置关系。如图所示，括号第一个数是点积的符号，第二个是叉积的符号。第一个向量u总是向右，另一个向量w的各种情况都包含在了图中。比如当w的中点在下图左上方的第二象限时点积为负担叉积均为正，用（-，+）表示。 点和直线点到直线的距离点到直线的距离是一个常用函数，可以用叉积求出，即用平行四边形的面积除以底。代码如下： 12345double DistoLine(point P,point A,point B) //点p到直线AB距离&#123; Vector v1=B-A,v2=P-A; return fabs(cross(v1,v2))/Length(v1); //如果不取绝对值，得到的是有向距离&#125; 点到线段的距离点到线段有两种可能： 简单地说，设投影点为Q，如果Q在线段AB上，则所求距离就是P点直线AB的距离（右）。如果Q在射线BA上，则所求为PA距离；否则为PB距离。判断Q的位置可以用点积进行。 1234567double DistoSegment(point P,point A,point B)&#123; if(A==B) return Length(P-A); Vector v1=B-A,v2=P-A,v3=P-B; if(dcmp(dot(v1,v2))&lt;0) return Length(v2); if(dcmp(dot(v1,v3))&gt;0) return Length(v3); return fabs(cross(v1,v2))/Length(v1);&#125; 判断点是否在线段上判断点 Q 在线段 P1P2 上的两条依据：①(Q-P1)*(P2-P1)=0;②Q 在以 P1,P2 为对角顶点的矩形内。 12345bool onSegment(point p1,point p2,point Q)&#123;if( (Q.x-p1.x)*(p2.y-p1.y)==(p2.x-p1.x)*(Q.y-p1.y)&amp;&amp;min(p1.x,p2.x)&lt;=Q.x&amp;&amp;Q.x&lt;=max(p1.x,p2.x)&amp;&amp;min(p1.y,p2.y)&lt;=Q.y&amp;&amp;Q.y&lt;= max(p1.y,p2.y) )return 1;else return 0;&#125; 线段相交最为直观的想法：解析几何法 弊端：运算误差大，运算次数多 误差来源：浮点运算 另外，编程难度事实上也很大（区域判断） 计算几何做法：运用叉积点积和位置关系 线段规范相交定义线段规范相交为两线段相交恰好有一个公共点且不是任一线段的端点 充要条件：每条线段的两个端点都在另一条线段的两侧 只有（1）是规范相交，其它是非规范相交。非规范相交的情况还有很多。 跨立实验 规范相交123456bool SegmentItersection(point a1, point a2, point b1, point b2)&#123; double c1 = cross(a2-a1, b1-a1), c2 = cross(a2-a1, b2-a1), c3 = cross(b2-b1, a1-b1), c4 = cross(b2-b1, a2-b1); return dcmp(c1)*dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3)*dcmp(c4) &lt; 0;&#125; 线段相交如果允许在端点处相交怎么办？ 首先可能共线重叠 其次就是交点是端点 如果交点是端点 就判断几次点是否在线段上 12345//判断点p是否在线段a1 a2上bool OnSegment(point p,point a1,point a2)&#123; return dcmp(cross(a1-p,a2-p))==0&amp;&amp;dcmp(dot(a1-p,a2-p))&lt;0; //线段包含端点时改成&lt;=&#125; 多边形问题多边形面积两向量的叉积的几何意义是以这两个向量为邻边的平行四边形的有向面积，我们可以利用这一点来求简单多边形的面积。所谓简单多边形就是任何不相邻的两条边都没有交点，包括凸多边形和凹多边形。 求下面多边形的面积，已知个顶点的坐标。 注意：在引入叉积后，面积就可以为负值，就有了“负面积”的概念。“负面积”方便了我们的运算。 可以取p[0]点为划分顶点，一方面可以少算两个叉积（0和任何向量的叉积都等于0），另一方面也减少乘法溢出的可能性，还不用特殊处理（i=n-1时，下一个顶点p[0]而不是p[n]，因为p[n]不存在） 12345678//取p[0]为划分顶点double PolygonArea(vector&lt;Point&gt; p) &#123; int n = p.size(); double area = 0; for(int i = 1; i &lt; n-1; i++) area += Cross(p[i]-p[0], p[i+1]-p[0]); return area/2;&#125; 也可以取坐标原点为划分点，乘法次数减少。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>计算几何</tag>
        <tag>点积/叉积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[博弈论]博弈论基本题型及5大常见博弈论原理]]></title>
    <url>%2F2018%2F05%2F08%2F2018-05-08%2F</url>
    <content type="text"><![CDATA[取石子游戏巴什博奕（Bash Game）有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 m个。最后取光者得胜。 假设n = m + 1，那么无论如何取，先取者必输。因为先取者无论取多少，后者一次性便可将剩余取完。 胜利法则：如果 n=（m+1）r+s，（r 为任意自然数，s≤m),那么先取者要拿走 s 个物品，如果后取者拿走 k（≤m)个，那么先取者再拿走 m+1-k 个，结果剩下 （m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 12345678910111213#include &lt;iostream&gt; using namespace std;int main() &#123; int iCase; cin &gt;&gt; iCase; while (iCase--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n % (m + 1) == 0) cout &lt;&lt; &quot;lost&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;win&quot; &lt;&lt; endl; &#125; return 0;&#125; 威佐夫博奕（Wythoff Game）有两堆物品，每堆各若干物品，两个人轮流从某堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们 称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a0=b0=0,ak 是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有如下三条性质： 1。任何自然数都包含在一个且仅有一个奇异局势中。 2。任意操作都可将奇异局势变为非奇异局势。 3。采用适当的方法，可以将非奇异局势变为奇异局势。 两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。 如何判定是否是奇异局势呢？ 有如下公式： ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，…,n 方括号表示取整函数) 其中（1+√5）/2 = 1.618…,即为黄金分割数。因此,由 ak，bk 组成的矩形近似为黄金矩形，由于 2/（1+√5）=（√5-1）/2，可以先求出 j=[a（√5-1）/2]，若a=[ j（1+√5）/2]，那么 a = aj，bj = aj + j，若不等于，那么 a = aj+1，bj+1 = aj+1 + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。 1234567891011121314151617181920#include &lt;stdio.h&gt; #include &lt;math.h&gt; const double ep1 = (sqrt(5.0) - 1.0) / 2.0;const double ep2 = (sqrt(5.0) + 1.0) / 2.0;int main() &#123; int m, n; while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) != EOF) &#123; if (m &gt; n) &#123; int tmp; tmp = m, m = n, n = tmp; &#125; int id = m * ep1; int tmp1 = ep2 * id, tmp2 = id + tmp1; int tmp3 = ep2 * (id + 1), tmp4 = id + 1 + tmp3; if (tmp1 == m &amp;&amp; tmp2 == n) printf(&quot;0\n&quot;); else if (tmp3 == m &amp;&amp; tmp4 == n) printf(&quot;0\n&quot;); else printf(&quot;1\n&quot;); &#125; return 0;&#125; 斐波那契博弈（Fibonacci Nim）有一堆个数为 n 的石子，游戏双方轮流取石子，满足 1)先手不能在第一次把所有的石子取完； 2)之后每次可以取的石子数介于 1 到对手刚取的石子数的 2 倍之间（包含 1 和对手刚取的石子数的 2 倍）。 约定取走最后一个石子的人为赢家，求必败态。 这个和之前的 Wythoff’s Game 和取石子游戏 有一个很大的不同点，就是游戏规则的动态化。之前的规则中，每次可以取的石子的策略集合是基本固定的，但是这次有规则 2：一方每次可以取的石子数依赖于对手刚才取的石子数。 胜利法则：先手胜当且 仅当 n 不是 Fibonacci 数。换句话说，必败态构成 Fibonacci 数列。 证明： 这里需要借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的 Fibonacci 数之和。 FIB 数列的必败证明： 1、当 i=2 时，先手只能取 1 颗，显然必败，结论成立。 2、假设当 i&lt;=k 时，结论成立。则当 i=k+1 时，f[i] = f[k]+f[k-1]。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std;long long int f[50];int main() &#123; int n, i; f[0] = f[1] = 1; for (i = 2; i &lt; 50; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; while (cin &gt;&gt; n) &#123; if (n == 0) break; for (i = 0; i &lt; 50; i++) &#123; if (f[i] == n) break; &#125; if (i &lt; 50) cout &lt;&lt; &quot;Second win&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;First win&quot; &lt;&lt; endl; &#125; return 0;&#125; K倍博弈共 n 个石子，两个人按顺序依次取石子。先手不能全部取完，之后每人取的个数不能超过另一个人上轮取的 K倍。 对于给定的 n, k， 先手是否有必胜的策略。 当 k=1 的时候 可知必败局面都是 2^i 将 n 分解成二进制，然后先手取掉最后一个 1，然后对方必然无法去掉更高的 1，而对方取完我方至少还能拿掉最后一 个 1 导致对方永远取不完。 当 k=2 的时候，必败局面都是斐波那契数列。利用“先手去掉最后一个 1，则后手必不能去掉更高阶的 1 导致取不完”的思想，斐波那契数列有一个非常好 的性质就是：任意一个整数可以写成斐波那契数列中的不相邻的项的和，于是将 n 写成这种形式，先取走最后一个 1，对方能取的数是这个数*2，小于高 2 位的 1，所以取不完。 当 K 的时候， 想办法构造数列，将 n 写成数列中一些项的和，使得这些被取到的项的相邻两个倍数差距&gt;k 那么每次去掉最后一个 1 还是符合上面的条件。 设这个数列已经被构造了 i 项，第 i 项为 a[ i ]，前 i 项可以完美对 1..b[ i ] 编码使得每个编码的任意两项倍数&gt;K 那么有 a[ i+1 ] = b[ i ] + 1;这是显然的 因为 b[ i ] + 1 没法构造出来，只能新建一项表示。然后计算 b[ i+1] 既然要使用 a[ i+1 ] 那么下一项最多只能是某个 a[ t ] 使得 a[ t ] * K &lt; a[ i+1 ] 于是b[ i ] = b[ t ] + a[ i+1 ] 然后判断 n 是否在这个数列里面如果在，那么先手必败。否则不停的减掉数列 a 中的项构造出 n 的分解，最后一位就是了。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; using namespace std;const int maxn = 2000000;int a[maxn], b[maxn];int main()&#123; int n, k; int cas = 0, cass; for (scanf(&quot;%d&quot;, &amp;cass); cass--;) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); ++cas; printf(&quot;Case %d: &quot;, cas); int i = 0, j = 0; a[0] = b[0] = 1; while (a[i]&lt;n) &#123; i++; a[i] = b[i - 1] + 1; while (a[j + 1] * k&lt;a[i]) j++; if (a[j] * k&lt;a[i]) b[i] = a[i] + b[j]; else b[i] = a[i]; &#125; if (a[i] == n) puts(&quot;lose&quot;); else puts(&quot;win&quot;); &#125; return 0;&#125; ＳＧ函数的求解(SG博弈）给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿有向边进行移动，无法移动者判负。 这个游戏可以认为是所有 Impartial Combinatorial Games 的抽象模型。也就是说，任何一个 ICG 都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成这个“有向图游戏”。 首先定义 mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。 对于一个给定的有向无环图，定义关于图的每个顶点的 Sprague-Grundy 函数 g如下：g(x)=mex{ g(y) | y 是 x 的后继 }。 SG 函数的性质。首先，所有的 terminal position 所对应的顶点，也就是没有出边的顶点，其 SG 值为 0，因为它的后继集合是空集。然后对于一个 g(x)=0 的顶点 x，它的所有后继 y 都满足 g(y)!=0。对于一个 g(x)!=0 的顶点，必定存在一个后继 y 满足 g(y)=0。 以上这三句话表明，顶点 x 所代表的 postion 是 P-position 当且仅当 g(x)=0。我们通过计算有向无环图的每个顶点的 SG 值，就可以对每种局面找到必胜策略了。 变形假设不是一枚棋子，而是n枚棋子，如何获胜 让我们再来考虑一下顶点的 SG 值的意义。当 g(x)=k 时，表明对于任意一个0&lt;=i&lt;k，都存在 x 的一个后继 y 满足 g(y)=i。也 就是说，当某枚棋子的 SG 值是 k 时，我们可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k 不变。 Nim 游戏的规则就是：每次选择 一堆数量为 k 的石子，可以把它变成 0、变成 1、……、变成 k-1，但绝对不能保持 k不变。这表明，如果将 n 枚棋子所在的顶 点的 SG 值看作 n 堆相应数量的石子，那么这个 Nim 游戏的每个必胜策略都对应于原来这 n 枚棋子的必胜策略！ 对于 n 个棋子，设它们对应的顶点的 SG 值分别为(a1,a2,…,an)，再设局面(a1,a2,…,an)时的 Nim 游戏的一种必胜策略是把 ai 变成 k，那么原游戏的一种必胜策略就是把第 i 枚棋子移动到一个 SG 值为 k 的顶点。 其实我们还是只要证明这种多棋子的有向图游戏的局面是 P-position 当且仅当所有棋子所在的位置的 SG 函数的异或为 0。这个证明与上节的 Bouton’s Theorem 几乎是完全相同的，只需要适当的改几个名词就行了。 SG 函数与“游戏的和”的概念不是让我们去组合、制造稀奇古怪的游戏，而是把遇到的看上去有些复杂的游戏试图分成若干个子游戏，对于每个比原游戏简化很多的子游戏找出它的 SG 函数，然后全部异或起来就得到了原游戏的 SG 函数，就可以解决原游戏了。 12345678910111213141516171819#include &lt;iostream&gt; using namespace std;int main() &#123; int iCase; cin &gt;&gt; iCase; while (iCase--) &#123; int n, cnt = 0, num; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; num; if (num % 4 == 0) num--; else if (num % 4 == 3) num++; cnt ^= num; &#125; if (cnt == 0) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Alice&quot; &lt;&lt; endl; &#125; return 0;&#125; 寻找必败态必败态就是“在对方使用最优策略时，无论做出什么决策都会导致失败的局面”。其他的局面称为胜态，值得注意的是在 胜态下做出错误的决策也有可能导致失败。此类博弈问题的精髓就是让对手永远面对必败态。 必败态和胜态有着如下性质： 1、若面临末状态者为获胜则末状态为胜态否则末状态为必败态。 2、一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态。 3、一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态。 这三条性质正是博弈树的原理，但博弈树是通过计算每一个局面是胜态还是必败态来解题，这样在局面数很多的情况下是很难做到的，此时，我们可以利用人脑的推演归纳能力找 到必败态的共性，就可以比较好的解决此类问题了。 解题思路分析初始局势是属于哪种形态，然后根据博弈中的些结论去推导当前状态是否是必败态。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论]数论与组合数学中的常用算法总结]]></title>
    <url>%2F2018%2F05%2F07%2F2018-05-07%2F</url>
    <content type="text"><![CDATA[数论欧几里得算法（gcd）欧几里得算法又称辗转相除法，设两个数为a,b,则a,b最大公约数为gcd(a,b)=gcd(b,a%b) 证明设a&gt;=b, c = gcd( a, b), a = kc, b = jc,则k,j互素（否则c不为a，b最大公约数），则设 r = a % b,则a = mb + r,则r = a - mb = kc - mjc = ( k - mj ) c，因为k,j互素，则k-mj与j互素，gcd(a,b) = gcd(b,a%b) 应用如果判断两个数是否互素(最大公约数为1)，这时辗转相除法就方便得多。因为每一步都是取模，保证了数据减小的速度特别快。能够在很短时间内找到最大公约数。 代码123456789101112131415//递归版int gcd(int a, int b) &#123; return b ? a : gcd(b, a%b);&#125;//非递归版int gcd(int a, int b) &#123; if (!a) return b; while (b) &#123; int temp = b; b = a%b; a = temp; &#125; return a;&#125; 扩展欧几里得算法（exgcd）若a , b 不全为 0，则存在整数 x,y 使得 gcd(a,b)=xa+yb对于辗转相除法的最后一项,此时 b=0,则 gcd(a,b)=1a+0b,因为 gcd(a,b)=gcd(b,a%b)则有 xa+yb=x1b+y1(a%b) 。将等式右边变形，bx1+(a%b)y1=bx1+(a-(a/b)b)y1=ay1+b(x1-(a/b)y1)则，x=y1,y=x1-(a/b)*y1 则可由后向前迭代得到 x,y 应用对于扩展欧几里德定理的题，一般都需要进行一定的推导之后得到一个形式为xa+yb=c 的方程，然后根据 c 确定解是否存在，如果 c 可以被 gcd(a,b)整除，那么方程有解，否则方程无解。而且所得的解释不唯一的，对于一组解 x0,y0 则其所有解可以表示为x=x0+b/gcd(a,b)t,y-y0-a/gcd(a,b)t,t=0,+1,+2……一般会要求找出 x 或者 y 的最小正整数解，这个时候需要做一些调整。 代码1234567891011121314int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a%b, x, y); int t = x; x = y; y = t - a / b*y; return d;&#125; 筛法求素数筛素数的基本方法是用来筛选出一定范围内的素数 原理利用素数只有1和本身两个约数，且约数一定不大于自身。首先筛掉1.剩下的数选择最小的数为素数，然后筛掉它范围内所有的倍数，以此类推，直到筛为空时结束。 123456789101112131415161718bool isprime[N];//N 表示范围int prime[N], cnt;void f()&#123; int i, j; cnt = 0; memset(isprime, true, sizeof(isprime)); isprime[1] = false; for (i = 2; i &lt;= N; i++) &#123; if (isprime[i]) &#123; prime[cnt++] = i;//记录素数 for (j = i*i; j &lt;= N; j += i)//因为小于 i 的所有的倍数都被筛过，所以直接从 i*i 开始，从这里也可以看出，筛素数时到 N^0.5就可以了 isprime[j] = false; &#125; &#125;&#125; 快速幂快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级别，快速幂能做到O(logn)。 原理 假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)。11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0a2^1a2^3，也就是a1 a2 a8，原来算11次，现在算三次，但是这三项貌似不好求的样子….不急，下面会有详细解释。由于是二进制，很自然地想到用位运算这个强大的工具：&amp;和&gt;&gt;。&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。>&gt;运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。 12345678910int poww(int a, int b) &#123; int ans = 1, base = a; while (b != 0) &#123; if (b &amp; 1 != 0) ans *= base; base *= base; b &gt;&gt;= 1; &#125; return ans;&#125; 以b==11为例，b=&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)a^(2^1)a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。 其中要理解base =base这一步：因为 base base==base2，下一步再乘，就是base2 base2==base4，然后同理 base4 base4=base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹= a1a2a8，这三项就可以完美解决了 矩阵快速幂矩阵乘法 简单的说矩阵就是二维数组，数存在里面，矩阵乘法的规则:A*B=C 其中c[i][j]为A的第i行与B的第j列对应乘积的和，即: 12345678910const int N=100; int c[N][N]; void multi(int a[][N],int b[][N],int n)//n是矩阵大小，n&lt;N &#123; memset(c,0,sizeof c); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; &#125; 方法很简单，把快速幂算法中的乘法改成矩阵的乘法就可以了。 1234567891011121314151617181920212223242526const int N=10; int tmp[N][N]; void multi(int a[][N],int b[][N],int n) &#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) tmp[i][j]+=a[i][k]*b[k][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) a[i][j]=tmp[i][j]; &#125; int res[N][N]; void Pow(int a[][N],int n) &#123; memset(res,0,sizeof res);//n是幂，N是矩阵大小 for(int i=0;i&lt;N;i++) res[i][i]=1; while(n) &#123; if(n&amp;1) multi(res,a,N);//res=res*a;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; &#125; &#125; 下面放一个求斐波那契数列的矩阵快速幂模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int mod = 10000;const int maxn = 35;int N;struct Matrix &#123; int mat[maxn][maxn]; int x, y; Matrix() &#123; memset(mat, 0, sizeof(mat)); for (int i = 1; i &lt;= maxn - 5; i++) mat[i][i] = 1; &#125;&#125;;inline void mat_mul(Matrix a, Matrix b, Matrix &amp;c) &#123; memset(c.mat, 0, sizeof(c.mat)); c.x = a.x; c.y = b.y; for (int i = 1; i &lt;= c.x; i++) &#123; for (int j = 1; j &lt;= c.y; j++) &#123; for (int k = 1; k &lt;= a.y; k++) &#123; c.mat[i][j] += (a.mat[i][k] * b.mat[k][j]) % mod; c.mat[i][j] %= mod; &#125; &#125; &#125; return ;&#125;inline void mat_pow(Matrix &amp;a, int z) &#123; Matrix ans, base = a; ans.x = a.x; ans.y = a.y; while (z) &#123; if (z &amp; 1 == 1) mat_mul(ans, base, ans); mat_mul(base, base, base); z &gt;&gt;= 1; &#125; a = ans;&#125;int main() &#123; while (cin &gt;&gt; N) &#123; switch (N) &#123; case -1: return 0; case 0: cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; case 1: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; case 2: cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; &#125; Matrix A, B; A.x = 2; A.y = 2; A.mat[1][1] = 1; A.mat[1][2] = 1; A.mat[2][1] = 1; A.mat[2][2] = 0; B.x = 2; B.y = 1; B.mat[1][1] = 1; B.mat[2][1] = 1; mat_pow(A, N - 1); mat_mul(A, B, B); cout &lt;&lt; B.mat[1][1] &lt;&lt; endl; &#125; return 0;&#125; 欧拉函数φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中 p1, p2……pn 为 x 的所有质因数。 设 p 是素数 a 是一个正整数 φ(p^a)=p^a-p^a-1; m 与 n 互素 φ(mn)=φ(m)φ(n); φ(n)=n sum(1-1/pi)/pi 是与 n 的质因子n 为奇数时 φ(2n)=φ(n)。 模运算基本的模运算(a + b)mod n=((a mod n) + (b mod n))mod n; (a - b)mod n=((a mod n) - (b mod n))mod n; (a b)mod n=((a mod n) (b mod n))mod n; 数论4大定理威尔逊定理若p为质数，则p可整除(p-1)!+1。 欧拉定理若n,a为正整数，且n,a互素，即gcd(a,n) = 1，则a^φ(n) ≡ 1 (mod n) 证明设x（1），x（2），…，x(φ(n))是一个以n为模的简系，则ax（1），ax（2），…，ax（φ(n) ）也是一个以n为模的简系（因为（a，n）=1）。 于是有ax（1）ax（2）…ax（φ(n) ）≡x（1）x（2）…x(φ(n))（mod n）， 所以a^φ(n) ≡ 1 (mod n)。 费马小定理假如p是质数，若p不能整除a，则 a^(p-1) ≡1（mod p），若p能整除a，则a^(p-1) ≡0（mod p）。 若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 证明因为p是质数，且（a，p)=1，所以φ(p)=p-1。由欧拉定理可得a^(p-1) ≡1（mod p）。证毕。对于该式又有a^p ≡a（mod p），所以，费马小定理的另一种表述为：假如p是质数，且(a,p)=1，那么a^p ≡a（mod p）。 孙子定理（中国剩余定理） 高斯消元高斯消元法，是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。利用矩阵化成的行阶梯型可以方便的得出未知数的解。 要用高斯消元，一般也会需要一定的推理，得出线性方程组，再利用高斯消元求解。 组合数学排列组合加法原理加法原理：做一件事，完成它可以有 n 类办法，第一类办法的方法属于集合 A1，第二类办法的方法属于集合 A2，……，第 n 类办法的方法属于集合 An，那么完成这件事的方法属于集合 A1UA2U…UAn。 分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏） 乘法原理乘法原理：做一件事，完成它需要分成 n 个步骤，做第一步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn 种不同的方法。 合理分步的要求,任何一步的一种方法都不能完成此任务，必须且只须连续完成这 n 步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。 公式排列的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n,m 与 n 均为自然数,下同）个元素按照一定的顺序排成一列，叫做从 n 个不同元素中取出 m 个元素的一个排列；从 n 个不同元素中取出 m(m≤n）个元素的所有排列的个数，叫做从 n 个不同元素中取出m 个元素的排列数，用符号 A(n,m）表示。A(n,m)=n(n-1)(n-2)……(n-m+1)= n!/(n-m)! 此外规定 0!=1 组合的定义及其计算公式：从 n 个不同元素中，任取 m(m≤n）个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个组合；从 n 个不同元素中取出 m(m≤n）个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的组合数。用符号 C(n,m) 表示。C(n,m)==A(n,m)/m！；C(n,m)=C(n,n-m）。（n&gt;=m) 其他排列与组合公式 从 n 个元素中取出 m 个元素的循环排列数=A(n,m)/m=n!/m(n-m)!. n 个元素被分成 k 类，每类的个数分别是 n1,n2,…nk 这 n 个元素的全排列数为 n!/(n1！×n2！×…×nk!). k 类元素，每类的个数无限，从中取出 m 个元素的组合数为 C(m+k-1,m）。 容斥原理设 A1,A2 为有限集合，其元素个数分别为|A1|，|A2|,则| A1∪A2|=| A1+A2|-| A1∩A2|这个定理，常称作包含排斥原理，也就是容斥原理。 对于需要用到容斥原理的题型，一般都比较容易看出来用的方法，而且一般采用深搜的方法进行运算]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>高斯消元</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]最短路三大算法——Dijkstra算法，Bellman-ford，floyed]]></title>
    <url>%2F2018%2F05%2F06%2F2018-05-06-1%2F</url>
    <content type="text"><![CDATA[Dijkstra算法（单源最短路径）步骤 初使时令 S={V0},T={其余顶点}，T中顶点对应的距离值， 若存在&lt;V0,Vi&gt;，为&lt;V0,Vi&gt;弧上的权值（和ＳＰＦＡ初始化方式不同），若不存在&lt;V0,Vi&gt;，为Inf。 从T中选取一个其距离值为最小的顶点W(贪心体现在此处)，加入S(注意不是直接从S集合中选取，理解这个对于理解vis数组的作用至关重要)，对T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值比不加W的路径要短，则修改此距离值（上面两个并列for循环，使用最小点更新）。 重复上述步骤，直到S中包含所有顶点，即S=V为止（说明最外层是除起点外的遍历）。 12345678910111213141516171819202122232425262728293031323334const int INF=0x3f3f3f3f;const int maxn=1200;int dist[maxn],g[maxn][maxn],N;bool vis[maxn];void dijkstra()&#123; for(int i=1;i&lt;=N;i++) dist[i]=(i==1)?0:INF; memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=N;i++) &#123; int mark=-1,mindis=INF; for(int j=1;j&lt;=N;j++) &#123; if(!vis[j]&amp;&amp;dist[j]&lt;mindis) &#123; mindis=dist[j]; mark=j; &#125; &#125; vis[mark]=1; for(int j=1;j&lt;=N;j++) &#123; if(!vis[j]) &#123; dist[j]=min(dist[j],dist[mark]+g[mark][j]); &#125; &#125; &#125;&#125; Bellman-ford（单元最短路径，可带负环）为了能够求解边上带有负值的单源最短路径问题，Bellman(贝尔曼，动态规划提出者)和Ford(福特)提出了从源点逐次绕过其他顶点，以缩短到达终点的最短路径长度的方法。Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellman-ford算法有一个小优化：每次松弛先设一个flag，初值为FALSE，若有边更新则赋值为TRUE，最终如果还是FALSE则直接成功退出。Bellman-ford算法浪费了许多时间做无必要的松弛，所以SPFA算法用队列进行了优化，效果十分显著，高效难以想象。SPFA还有SLF，LLL，滚动数组等优化。 递推公式(求顶点u到源点v的最短路径)：$$dist 1 [u] = Edge[v][u]$$ $$dist k [u] = min{ dist k-1 [u], min{ dist k-1 [j] + Edge[j][u] } }, j=0,1,…,n-1,j≠u$$ Dijkstra算法和Bellman算法思想有很大的区别：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改 的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。 使用条件 单源最短路径(从源点s到其它所有顶点v) 有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图) 边权可正可负(如有负权回路输出错误提示) 差分约束系统(至今貌似只看过一道题) 描述 初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次，看下面的描述性证明(当做树)） 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在d[v]中 Bellman-Ford算法是否一定要循环n-1次么？未必！其实只要在某次循环过程中，考虑每条边后，都没能改变当前源点到所有顶点的最短路径长度，那么Bellman-Ford算法就可以提前结束了(开篇提出的小优化就是这个)。 123456789101112131415161718192021222324252627282930313233343536373839bool Bellman_Ford()&#123; for(int i = 1; i &lt;= nodenum; ++i) //初始化 dis[i] = (i == original ? 0 : MAX); for(int i = 1; i &lt;= nodenum - 1; ++i) for(int j = 1; j &lt;= edgenum; ++j) if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost) //松弛（顺序一定不能反~） &#123; dis[edge[j].v] = dis[edge[j].u] + edge[j].cost; pre[edge[j].v] = edge[j].u; &#125; bool flag = 1; //判断是否含有负权回路 for(int i = 1; i &lt;= edgenum; ++i) if(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost) &#123; flag = 0; break; &#125; return flag;&#125; floyed（全源最短路径）Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 123456789for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) /* 实际中为防止溢出，往往需要选判断 dist[i][k]和dist[k][j] 都不是Inf ，只要一个是Inf，那么就肯定不必更新。 */ if (dist[i][k] + dist[k][j] &lt; dist[i][j] ) dist[i][j] = dist[i][k] + dist[k][j]; Floyd算法另一种理解DP，为理论爱好者准备的，上面这个形式的算法其实是Floyd算法的精简版，而真正的Floyd算法是一种基于DP(Dynamic Programming)的最短路径算法。设图G中n 个顶点的编号为1到n。令c [i, j, k]表示从i 到j 的最短路径的长度，其中k 表示该路径中的最大顶点，也就是说c[i,j,k]这条最短路径所通过的中间顶点最大不超过k。因此，如果G中包含边&lt;i, j&gt;，则c[i, j, 0] =边&lt;i, j&gt; 的长度；若i= j ，则c[i,j,0]=0；如果G中不包含边&lt;i, j&gt;，则c (i, j, 0)= +∞。c[i, j, n] 则是从i 到j 的最短路径的长度。对于任意的k&gt;0，通过分析可以得到：中间顶点不超过k 的i 到j 的最短路径有两种可能：该路径含或不含中间顶点k。若不含，则该路径长度应为c[i, j, k-1]，否则长度为 c[i, k, k-1] +c [k, j, k-1]。c[i, j, k]可取两者中的最小值。状态转移方程：c[i, j, k]=min{c[i, j, k-1], c [i, k, k-1]+c [k, j, k-1]}，k＞0。这样，问题便具有了最优子结构性质，可以用动态规划方法来求解。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]二分图匹配基本算法之KM算法解析]]></title>
    <url>%2F2018%2F05%2F06%2F2018-05-06%2F</url>
    <content type="text"><![CDATA[最佳匹配如果一个二分图，X部和Y部的顶点数相等，若存在一个匹配包含X部与Y部的所有顶点，则称为完美匹配。 如果一个二分图，X部中的每一个顶点都与Y部中的一个顶点匹配，或者Y部中的每一个顶点也与X部中的一个顶点匹配，则该匹配为完备匹配。 带权二分图的权值最大的完备匹配称为最佳匹配。二分图的最佳匹配不一定是二分图的最大权匹配。 可以添加一些权值为0的边，使得最佳匹配和最大权匹配统一起来。 如图所示： KM算法求二分图的最佳匹配有一个非常优秀的算法,可以做到O(N^3),这就是KM算法。 1.首先选择顶点数较少的为X部，初始时对X部的每一个顶点设置顶标，顶标的值为该点关联的最大边的权值，Y部的顶点顶标为0。 2.对于X部中的每个顶点，在相等子图中利用匈牙利算法找一条增广路径，如果没有找到，则修改顶标，扩大相等子图，继续找增广路径。当每个点都找到增广路径时，此时意味着每个点都在匹配中，即找到了二分图的完备匹配。该完备匹配即为二分图的最佳匹配。 3.当X部的所有顶点都找到了增广路径后，则找到了完备匹配，此完备匹配即为最佳匹配。 相等子图因为每个顶点有一个顶标，如果我们选择边权等于两端点的顶标之和的边，它们组成的图称为相等子图。 相等子图性质 在任意时刻，相等子图上的最大权匹配一定小于等于相等子图的顶标和。 在任意时刻，相等子图的顶标和即为所有顶点的顶标和。 扩充相等子图后，相等子图的顶标和将会减小。 当相等子图的最大匹配为原图的完备匹配时，匹配边的权值和等于所有顶点的顶标和，此匹配即为最佳匹配。 演示过程1.如图所示，1与a匹配权值为3，与c为4。2与a权值为2，与b权值为1，与c权值为3。3与c权值为5。 2.首先对每个顶点赋值，将左边的顶点赋值为最大权重，右边的顶点赋值为0。 3.进行匹配，我们匹配的原则是：只与权重相同的边匹配，若是找不到边匹配，对此条路径的所有左边顶点-1，右边顶点+1，再进行匹配，若还是匹配不到，重复+1和-1操作。对1进行匹配，符合匹配条件的边只有1-c边。 4.接着对2匹配，顶点2值为3，2-c边权重为3，但是，1已经匹配c了，发生了冲突，我们这时候第一时间应该想到的是，让2换个工作，但根据匹配原则，只有2-c边 3+0=0 满足要求，于是2不能换边了，那1能不能换边呢？对1来说，也是只有1-c边满足4+0=4的要求，于是1也不能换边，走投无路了，怎么办？ 5.从常识的角度思考：其实我们寻找最优匹配的过程，也就是帮每个X顶点找到他们权值最高的Y顶点，但是，有些顶点会冲突，比如现在，1，2和c的权值都是最高，这时我们应该让1或者3换顶点，但是这时候换的话我们只能换到降低权值的Y顶点，也就是说，如果令R=左边顶点所有值相加，若发生了冲突，则最终权值一定小于R，但是，我们现在只要求最优匹配，所以，如果1换顶点降低的权值比较少的话，我们是能接受的（对2同样如此）。 在KM算法中如何体现呢？ 现在参与到这个冲突的顶点是1,2和c，令所有左边顶点值-1，右边顶点值+1，即 1-1,2-1. c+1。 我们进行了上述操作后会发现，若是左边有n个顶点参与运算，则右边就有n-1个顶点参与运算，整体效率值下降了1*（n-（n-1））=1，而对于1来说，1-c本来为可匹配的边，现在仍为可匹配边（3+1=4），对于2来说，2-c本来为可匹配的边，现在仍为可匹配的边（2+1=4），我们通过上述操作，为1增加了一条可匹配的边1-a，为B增加了一条可匹配的边2-a。 现在我们再来匹配，对2来说，2-a边 2+0=2，满足条件，所以2换边，a现在为未匹配状态，2-a匹配！ 6.我们现在匹配最后一条边3，3-c 5+1！=5，3边无边能匹配，所以3-1。现在3-c边 4+1=5，可以匹配，但是c已匹配了，发生冲突，3此时不能换边，于是便去找1，对于1来说，1-a此时也为可匹配边，但是a已匹配，1又去找2。 7.2现在无边可以匹配了，2+0！=1 ，现在的路径是3→c→1→a→2，所以1-1,2-1,3-1,a+1，c+1。如下图所示。 8.对于2来说，现在2-b 1+0=1 可匹配！使用匈牙利算法，对此条路径上的边取反。 实现代码：12345678910111213141516171819202122232425262728293031323334353637bool dfs(int s) //匈牙利算法找增广路径&#123; visx[s]=1; for(int i=1;i&lt;=cnty;i++) if(!visy[i])&#123; int t=wx[s]+wy[i]-dis[s][i]; if(t==0) &#123; visy[i]=1; if(linky[i]==0||dfs(linky[i]))&#123; linkx[s]=i,linky[i]=s; return true; &#125; &#125; else if(t&gt;0) //找出边权与顶标和的最小的差值 &#123; if(t&lt;minz)minz=t; &#125; &#125; return false;&#125;void km()&#123; memset(linkx,0,sizeof linkx); //linkx[i]表示与X部中点i匹配的点 memset(linky,0,sizeof linky); for(int i=1;i&lt;=cntx;i++)&#123; while(1)&#123; minz=INF; memset(visx,0,sizeof visx); memset(visy,0,sizeof visy); if(dfs(i))break; for(int j=1;j&lt;=cntx;j++) //将交错树中X部的点的顶标减去minz if(visx[j])wx[j]-=minz; for(int j=1;j&lt;=cnty;j++) //将交错树中Y部的点的顶标加上minz if(visy[j])wy[j]+=minz; &#125; &#125;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
        <tag>KM算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论]二分图匹配基本算法之匈牙利算法解析]]></title>
    <url>%2F2018%2F05%2F05%2F2018-05-05%2F</url>
    <content type="text"><![CDATA[二分图概念二分图（二部图），图论一种特殊的模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（ i，j ）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。 简而言之，一个图所有的顶点被分成两部分，同一部分的顶点之间没有边。如图所示： 二分图匹配给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。极大匹配(Maximal Matching)是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。最大匹配(maximum matching)是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。 增广路经增广路径的定义：设M为二分图G已匹配边的集合，若P是图G中一条连通两个未匹配顶点的路径（P的起点在X部，终点在Y部，反之亦可），并且属M的边和不属M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。增广路径是一条“交错轨”。也就是说, 它的第一条边是目前还没有参与匹配的,第二条边参与了匹配,第三条边没有..最后一条边没有参与匹配,并且起点和终点还没有被选择过，这样交错进行,显然P有奇数条边 由增广路的定义可以推出下述三个结论： P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 P经过取反操作可以得到一个更大的匹配M’。 M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。 匈牙利算法基本模式： 初始时最大匹配为空 ​ while 找到增广路经 ​ do 把增广路径加入到最大匹配中去 具体过程如图所示： 1.如图所示，1可以与a，c匹配，2可以与a，b匹配，3可以与c匹配 2.首先将对1进行搜索，1可以与a匹配，则将1与a相连 3.再对2进行搜索，2可以与a匹配 4.但是a已经与1匹配了，那么顺着a-&gt;1这条路找到1，再对1进行搜索，发现1还可以与c进行匹配，并且当前c还未与任何X区顶点匹配，则将1与c相连 5.现在对3进行匹配，发现3可以与c匹配 6.这时发现c已经匹配了，则顺着c-&gt;1这条路找到1，再对1进行搜索，发现1还可以与a匹配 7.但a也已经匹配了，则顺着a-&gt;2这条路找到2，这时发现2还可以与b匹配，并且b当前还未与任何X顶点匹配，则将2与b匹配，之后得到的结果即为最大匹配 以下是实现代码 123456789101112bool find(int x) &#123; //寻找增广路 for (int i = 1; i &lt;= N; i++) &#123; //遍历Y部分顶点 if (road[x][i] &amp;&amp; !vis[i]) &#123; //Y某顶点与X有路且未标记 vis[i] = true; if (!link[i] || find(link[i])) &#123; //如果Y顶点当前未与其他X匹配则直接与该点匹配，否则寻找增广路，然后将Y顶点与该顶点匹配 link[i] = x; return true; &#125; &#125; &#125; return false;&#125; 主程序调用： 123456for(int i = 1; i &lt;= N; i++)&#123; //对每一个X部分顶点进行遍历 memset(vis,false,sizeof(vis)); if(find(i))&#123; //寻找增光路 ans++; //最大匹配数量加1 &#125;&#125; 例题：POJ3041 给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍， 最少要几次。这里将每行x看成一个X结点，每列Y看成一个Y结点，障碍的坐标x,y看成X到Y的 一条边，构建出图后，就变成了找最少的点，使得这些点与所有的边相邻，即最小点覆盖问题。 又继续敲了一遍匈牙利算法 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int N, K, ans;int road[520][520], head[520];bool vis[520];bool find(int x) &#123; for (int i = 1; i &lt;= N; i++) &#123; if (road[x][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!head[i] || find(head[i])) &#123; head[i] = x; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; while (cin &gt;&gt; N &gt;&gt; K) &#123; ans = 0; int x, y; memset(road, 0, sizeof(road)); memset(head, 0, sizeof(head)); for (int i = 1; i &lt;= K; i++) &#123; cin &gt;&gt; x &gt;&gt; y; road[x][y] = 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; memset(vis, false, sizeof(vis)); if (find(i)) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++实战qqHelper]C++打造qq消息一键群发工具]]></title>
    <url>%2F2018%2F05%2F03%2F2018-05-03%2F</url>
    <content type="text"><![CDATA[物联网时代，微信和qq带给我们生活诸多便利。如今办公学习交流通讯已经越来越离不开微信和qq了。但是目前仍存在一些缺陷，比如如果想某条消息发给全部好友，必须得一个一个的发送。尤其是节假日发送节日祝福时该缺陷越发明显。微信针对此现象推出了群发功能，但qq目前还没有该功能。因此此次借此小程序练习C++，用C++打造qq聊天一键群发功能。该小程序还在完善中。目前只能作用于电脑Windows操作系统，并且电脑聊天界面发送按钮需切换到按Enter直接发送，不要选择Ctrl+Enter。当前仅有发送功能，因此消息的对象是所有好友。之后有时间会陆续添加暂停，继续等操作。 具体代码以及实现过程在代码中逐条说明。这里就不具体说明了。 QQmessage.h 12345678910111213141516171819202122232425262728293031323334353637383940#pragma onceclass QQmessage&#123;public: QQmessage(); ~QQmessage(); //类的入口 static QQmessage *Instance() &#123; static QQmessage object; return &amp;object; &#125; //入口函数 void Start(const wchar_t *msg);private: //开始线程 static unsigned int WINAPI RunThreadproc(void* param); //发送主函数 void SendAll(); //找到QQ窗口 HWND FindQQWindow(); //模拟按键 void PressKey(BYTE vkey); //发送消息 void SendMsg(); //添加文本到剪贴板 void AddTextToClipboard();private: CString m_msg;&#125;; QQmessage.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &quot;stdafx.h&quot;#include &quot;QQmessage.h&quot;QQmessage::QQmessage()&#123;&#125;QQmessage::~QQmessage()&#123;&#125;//入口函数void QQmessage::Start(const wchar_t *msg)&#123; m_msg = CString(msg); //输入的文本 _beginthreadex(NULL, 0, QQmessage::RunThreadproc, NULL, 0, NULL);&#125;//开始线程unsigned int QQmessage::RunThreadproc(void* param)&#123; QQmessage::Instance()-&gt;SendAll(); return 0;&#125;//发送主函数void QQmessage::SendAll()&#123; int errorTimes = 0; //打开对话框错误的次数! //把text复制到剪贴板 AddTextToClipboard(); //技术到家. 做项目能力. while (errorTimes&lt;= 4) &#123; HWND hQQWnd = FindQQWindow(); HWND hFrontWnd = GetForegroundWindow(); if (hQQWnd != hFrontWnd) &#123; if (!SetForegroundWindow(hQQWnd)) &#123; MessageBox(NULL, L&quot;没有找到QQ窗口&quot;, NULL, NULL); break; &#125; &#125; if (errorTimes == 0) &#123; PressKey(VK_TAB); PressKey(VK_TAB); &#125; PressKey(VK_DOWN); PressKey(VK_RETURN); HWND hCurFrontWnd = GetForegroundWindow(); if (hCurFrontWnd == hQQWnd) // &#123; ++errorTimes; continue; &#125; errorTimes = 0; SendMsg(); &#125;&#125;//找到QQ窗口HWND QQmessage::FindQQWindow()&#123; HWND hWnd = FindWindow(L&quot;TXGuiFoundation&quot;,L&quot;QQ&quot;); //Find Window //获取QQ的窗口!!! //辅助工具就是这么做的 return hWnd;&#125;//模拟按键void QQmessage::PressKey(BYTE vkey)&#123; keybd_event(vkey, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(vkey, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100);&#125;//发送消息 16GU盘void QQmessage::SendMsg()&#123; //粘贴 + 发送 keybd_event(VK_CONTROL, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(0x56, 0, 0, 0); //按下(0)和弹起(KEYEVENTF_KEYUP) Sleep(100); keybd_event(0x56, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100); keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0); //敲击TAB Sleep(100); //你好 鲜花刷起来! //发送 PressKey(VK_RETURN); PressKey(VK_ESCAPE);&#125;//添加文本到剪贴板void QQmessage::AddTextToClipboard()&#123; //1.把文本拷贝到全局变量! int memLen = m_msg.GetLength() * sizeof(wchar_t) + 2; HANDLE hGloBal = GlobalAlloc(GHND,memLen); //malloc calloc relloc void* memAddr = GlobalLock(hGloBal); ZeroMemory(memAddr, memLen); memcpy(memAddr, (const void*)m_msg.GetBuffer(), memLen); GlobalUnlock(hGloBal); //操作剪贴板! 怎么把大象装进冰箱! OpenClipboard(NULL); EmptyClipboard(); SetClipboardData(CF_UNICODETEXT, hGloBal); CloseClipboard();&#125; QQHelperDlg.h 12345678910111213141516171819202122232425262728293031323334353637// QQHelperDlg.h : 头文件//#pragma once// CQQHelperDlg 对话框class CQQHelperDlg : public CDialogEx&#123;// 构造public: CQQHelperDlg(CWnd* pParent = NULL); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_QQHELPER_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: CString m_Msg; afx_msg void OnBnClickedButton1();&#125;; QQHelperDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// QQHelperDlg.cpp : 实现文件//#include &quot;stdafx.h&quot;#include &quot;QQHelper.h&quot;#include &quot;QQHelperDlg.h&quot;#include &quot;afxdialogex.h&quot;#include &quot;QQmessage.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CQQHelperDlg 对话框CQQHelperDlg::CQQHelperDlg(CWnd* pParent /*=NULL*/) : CDialogEx(IDD_QQHELPER_DIALOG, pParent) , m_Msg(_T(&quot;&quot;))&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CQQHelperDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Text(pDX, IDC_EDIT1, m_Msg);&#125;BEGIN_MESSAGE_MAP(CQQHelperDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON1, &amp;CQQHelperDlg::OnBnClickedButton1)END_MESSAGE_MAP()// CQQHelperDlg 消息处理程序BOOL CQQHelperDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CQQHelperDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CQQHelperDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CQQHelperDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;//发送void CQQHelperDlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); QQmessage::Instance()-&gt;Start(m_Msg.GetBuffer());//m_Msg实例编辑框的变量 文字&#125; QQHelper.h 1234567891011121314151617181920212223242526272829303132// QQHelper.h : PROJECT_NAME 应用程序的主头文件//#pragma once#ifndef __AFXWIN_H__ #error &quot;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&quot;#endif#include &quot;resource.h&quot; // 主符号// CQQHelperApp: // 有关此类的实现，请参阅 QQHelper.cpp//class CQQHelperApp : public CWinApp&#123;public: CQQHelperApp();// 重写public: virtual BOOL InitInstance();// 实现 DECLARE_MESSAGE_MAP()&#125;;extern CQQHelperApp theApp; QQHelper.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// QQHelper.cpp : 定义应用程序的类行为。//#include &quot;stdafx.h&quot;#include &quot;QQHelper.h&quot;#include &quot;QQHelperDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CQQHelperAppBEGIN_MESSAGE_MAP(CQQHelperApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CQQHelperApp 构造CQQHelperApp::CQQHelperApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的一个 CQQHelperApp 对象CQQHelperApp theApp;// CQQHelperApp 初始化BOOL CQQHelperApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CQQHelperDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != NULL) &#123; delete pShellManager; &#125;#ifndef _AFXDLL ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; stdafx.h 12345678910111213141516171819202122232425262728293031323334353637383940414243// stdafx.h : 标准系统包含文件的包含文件，// 或是经常使用但不常更改的// 特定于项目的包含文件#pragma once#ifndef VC_EXTRALEAN#define VC_EXTRALEAN // 从 Windows 头中排除极少使用的资料#endif#include &quot;targetver.h&quot;#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS // 某些 CString 构造函数将是显式的// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏#define _AFX_ALL_WARNINGS#include &lt;afxwin.h&gt; // MFC 核心组件和标准组件#include &lt;afxext.h&gt; // MFC 扩展#include &lt;afxdisp.h&gt; // MFC 自动化类#ifndef _AFX_NO_OLE_SUPPORT#include &lt;afxdtctl.h&gt; // MFC 对 Internet Explorer 4 公共控件的支持#endif#ifndef _AFX_NO_AFXCMN_SUPPORT#include &lt;afxcmn.h&gt; // MFC 对 Windows 公共控件的支持#endif // _AFX_NO_AFXCMN_SUPPORT#include &lt;afxcontrolbars.h&gt; // 功能区和控件条的 MFC 支持#ifdef _UNICODE#if defined _M_IX86#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;x86&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#elif defined _M_X64#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;amd64&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#else#pragma comment(linker,&quot;/manifestdependency:\&quot;type=&apos;win32&apos; name=&apos;Microsoft.Windows.Common-Controls&apos; version=&apos;6.0.0.0&apos; processorArchitecture=&apos;*&apos; publicKeyToken=&apos;6595b64144ccf1df&apos; language=&apos;*&apos;\&quot;&quot;)#endif#endif stdafx.cpp 123456// stdafx.cpp : 只包括标准包含文件的源文件// QQHelper.pch 将作为预编译头// stdafx.obj 将包含预编译类型信息#include &quot;stdafx.h&quot; Resource.h 12345678910111213141516171819202122//&#123;&#123;NO_DEPENDENCIES&#125;&#125;// Microsoft Visual C++ 生成的包含文件。// 供 QQHelper.rc 使用//#define IDM_ABOUTBOX 0x0010#define IDD_ABOUTBOX 100#define IDS_ABOUTBOX 101#define IDD_QQHELPER_DIALOG 102#define IDR_MAINFRAME 128#define IDC_EDIT1 1000#define IDC_BUTTON1 1001// Next default values for new objects// #ifdef APSTUDIO_INVOKED#ifndef APSTUDIO_READONLY_SYMBOLS#define _APS_NEXT_RESOURCE_VALUE 130#define _APS_NEXT_COMMAND_VALUE 32771#define _APS_NEXT_CONTROL_VALUE 1002#define _APS_NEXT_SYMED_VALUE 101#endif#endif targetver.h 12345678#pragma once// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。#include &lt;SDKDDKVer.h&gt; 资源文件]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[贪心+二分]HUST-Walking in the Forest+POJ-疯牛（求最小化最大值最大化最小值两道经典例题）]]></title>
    <url>%2F2018%2F05%2F01%2F2018-05-01%2F</url>
    <content type="text"><![CDATA[今天刚好做了一道关于最大值最小化的问题，这类问题的基本思路就是二分加贪心。那就针对该类问题举两道经典例题进行总结吧。 Walking in the Forest （最大值最小化例题）题目描述 It’s universally acknowledged that there’re innumerable trees in the campus of HUST. Now you’re going to walk through a large forest. There is a path consisting of N stones winding its way to the other side of the forest. Between every two stones there is a distance. Let di indicates the distance between the stone i and i+1.Initially you stand at the first stone, and your target is the N-th stone. You must stand in a stone all the time, and you can stride over arbitrary number of stones in one step. If you stepped from the stone i to the stone j, you stride a span of (di+di+1+…+dj-1). But there is a limitation. You’re so tired that you want to walk through the forest in no more than K steps. And to walk more comfortably, you have to minimize the distance of largest step. 输入描述:12The first line contains two integer N and K as described above.Then the next line N-1 positive integer followed, indicating the distance between two adjacent stone. 输出描述:1An integer, the minimum distance of the largest step. 示例1 输入126 31 3 2 2 5 输出15 题意： 有n颗石子，每相邻两颗石子间又一个距离，因此n颗石子共有n-1段距离。现在要求你最多用k步从第一颗石子跳到最后一颗石子。现在让你求最大的一步至少需要跨多少距离。 题解： 典型的最大值最小化问题。用贪心+二分解决即可。先选取一个标准值，然后从第一颗石子往后距离相加，如果加了之后大于标准值，则步数stemp加一，距离清零。最后比较stemp是否小于等于k值。标准值的范围在相邻石子距离最大值ld与第一颗石子到最后一颗石子距离之间rd，因此每次选取中间值作为标准，如果stemp&gt;k，右边界限rd=mid-1，否则ld=mid+1。但需注意有组样例过大容易超时，因此尽量用long long代替int。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;long long a[100010];int n, k;bool check(long long ld,long long rd,long long mind) &#123; long long cnt = 0; int stemp = 1; for (int i = 0; i &lt; n - 1; i++) &#123; if (cnt + a[i] &lt;= mind) &#123; cnt += a[i]; &#125; else &#123; cnt = a[i]; stemp++; &#125; if (stemp &gt; k) return false; &#125; if (stemp &lt;= k) return true; return false;&#125;int main() &#123; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123; long long maxn = 0, sumn = 0; for (int i = 0; i &lt; n - 1; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); sumn += a[i]; if (maxn &lt; a[i]) maxn = a[i]; &#125; long long ld = maxn; long long rd = sumn; long long mind = (ld + rd) / 2; while (ld &lt;= rd) &#123; bool flag = check(ld, rd, mind); if (!flag) &#123; ld = mind + 1; mind = (ld + rd) / 2; &#125; else &#123; rd = mind - 1; mind = (ld + rd) / 2; &#125; &#125; printf(&quot;%lld\n&quot;, ld); &#125; return 0;&#125; POJ2456疯牛 （最小值最大化例题）时间限制：1000 ms | 内存限制：65535 KB 难度：4 描述 农夫 John 建造了一座很长的畜栏，它包括N (2 &lt;= N &lt;= 100,000)个隔间，这些小隔间依次编号为x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).但是，John的C (2 &lt;= C &lt;= N)头牛们并不喜欢这种布局，而且几头牛放在一个隔间里，他们就要发生争斗。为了不让牛互相伤害。John决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是什么呢？输入有多组测试数据，以EOF结束。第一行：空格分隔的两个整数N和C第二行——第N+1行：分别指出了xi的位置输出每组测试数据输出一个整数，满足题意的最大的最小值，注意换行。样例输入5 312849样例输出3 题意：有n个牛栏，选m个放进牛，相当于一条线段上有 n 个点，选取 m 个点，使得相邻点之间的最小距离值最大。 题解：首先给出n个牛棚的位置，那么每个牛棚之间的最小距离是和相邻两个牛棚之间的距离。因此，先给牛棚的位置排个序。将第一头牛放在0号位置，二分法不断缩进距离d，如果前一头牛放到了xi处，就要将下一头放到满足xi+d&lt;=xj的最小的xj处。这样保证最近的两头牛之间的距离都不会比当前的最小值小，如果每个都能满足这样放就可以作为最小值。 代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int v[100005]; int n, c; int check(int d) &#123; int tmp = v[0], cnt = 1; for (int i = 1; i &lt; n; i++) &#123; if (v[i] - tmp &gt;= d) &#123; cnt++; tmp = v[i]; &#125; &#125; if (cnt &gt;= c) return 1; return 0; &#125; int main() &#123; while (cin &gt;&gt; n &gt;&gt; c) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; v[i]; sort(v, v + n); int l = 0, r = v[n - 1], mid; while (l &lt;= r) &#123; mid = (l + r) / 2; if (check(mid)) l = mid + 1; else r = mid - 1; &#125; printf(&quot;%d\n&quot;, r); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The 15ph Zhejiang Provincial Collegiate Programming Contest Sponsored by TuSimple题解]]></title>
    <url>%2F2018%2F04%2F29%2F2018-04-29%2F</url>
    <content type="text"><![CDATA[4月29日，13:30-18:30，浙江大学程序设计校赛 A-Peak题意： 有一串数字，问这串数字是否符合以下情况： 存在一个数在这串数的第k位置，即ak，以k为基准，k之前的数呈递增趋势，即ai-1 &lt; ai。k之后的数呈递减趋势，即ai-1 &gt; ai。ak不能为首元素和尾元素，且ak为最大的那个数。 题解： 水题，每输入一个数直接和前一个数进行比较，先递增判断直到比前一个数小，则递减判断。如果期间存在不符合情况的，则输出No,否则输出Yes。 B - King of Karaoke题意： 两个数组a，b，对a中的每个元素加k使得ai[i]=b[i]的个数最多。求k 题解： 只需用b中的每个元素减去a中的每个元素，即b[i]-a[i]，得到数组c，从中出现元素最多的那个数值的个数即为k。 D - Sequence Swapping Time Limit: 1 Second Memory Limit: 65536 KB BaoBao has just found a strange sequence {&lt;, &gt;, &lt;, &gt;, , &lt;, &gt;} of length in his pocket. As you can see, each element &lt;, &gt; in the sequence is an ordered pair, where the first element in the pair is the left parenthesis ‘(‘ or the right parenthesis ‘)’, and the second element in the pair is an integer. As BaoBao is bored, he decides to play with the sequence. At the beginning, BaoBao’s score is set to 0. Each time BaoBao can select an integer , swap the -th element and the -th element in the sequence, and increase his score by , if and only if , ‘(‘ and ‘)’. BaoBao is allowed to perform the swapping any number of times (including zero times). What’s the maximum possible score BaoBao can get? InputThere are multiple test cases. The first line of the input contains an integer , indicating the number of test cases. For each test case: The first line contains an integer (), indicating the length of the sequence. The second line contains a string () consisting of ‘(‘ and ‘)’. The -th character in the string indicates , of which the meaning is described above. The third line contains integers (). Their meanings are described above. It’s guaranteed that the sum of of all test cases will not exceed . OutputFor each test case output one line containing one integer, indicating the maximum possible score BaoBao can get. Sample Input1234567891011121346)())()1 3 5 -1 3 26)())()1 3 5 -100 3 23())1 -1 -13())-1 -1 -1 Sample Output1234242102 HintFor the first sample test case, the optimal strategy is to select in order. For the second sample test case, the optimal strategy is to select in order. 题意：一串由‘(’与‘)’组成的字符串，其中每一个字符都有一个权值，如果两个相邻的字符a,b为‘（’‘）’，则这两个字符可以进行交换，交换后可获得a和b权值之积的权值sum。求如何操作可以获得最大权值sum。 题解：由于权值存在负数，因此如果相邻两个可以交换的字符如果异号则需谨慎考虑。先从第一个字符进行判断，如果为‘（’，则cur为该字符权值，然后继续判断，如果出现”)”，如果权值相乘为正，则cur不变，权值sum加上cur乘当前权值即curweight[i]。否则将cur和curweight[i]压栈，然后cur变为0，继续下一次判断。如果之后以此方法得到的权值为负，则看和栈顶元素相加后是否为正，若为正则取栈顶元素合成新元素，栈顶pop，再继续取栈判断。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;stack&gt;using namespace std;struct node &#123; int cur; int cnt;&#125;;char str[1010];int wei[1010];int main() &#123; int t, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%s&quot;, &amp;n, str); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;wei[i]); &#125; stack&lt;node&gt;st; int sum = 0; int cur = 0; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (str[i] == &apos;(&apos;) &#123; if (cur == 0) &#123; cur = wei[i]; &#125; else if (abs(cur) &lt; abs(cur + wei[i])) &#123; cur = cur + wei[i]; &#125; else &#123; cur = wei[i]; &#125; &#125; else if (str[i] == &apos;)&apos;) &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt&gt;cur*wei[i]) &#123; cnt = 0; do &#123; cur += st.top().cur; cnt += st.top().cnt; st.pop(); &#125; while (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0 &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; cur*wei[i]); sum += cur*wei[i] + cnt; &#125; else if (cur*wei[i] &gt; 0) &#123; sum += wei[i] * cur; &#125; else &#123; if (!st.empty() &amp;&amp; (cur + st.top().cur)*wei[i] + st.top().cnt &gt; 0) &#123; cur += st.top().cur; sum += cur*wei[i] + st.top().cnt; st.pop(); &#125; else &#123; if (!cur&amp;&amp;!st.empty()) &#123; st.top().cnt += st.top().cur*wei[i]; &#125; else &#123; node tmp; tmp.cnt = cur*wei[i]; tmp.cur = cur; st.push(tmp); cur = 0; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;, sum); &#125; return 0;&#125; J - CONTINUE…? Time Limit: 1 Second Memory Limit: 65536 KB Special Judge DreamGrid has classmates numbered from to . Some of them are boys and the others are girls. Each classmate has some gems, and more specifically, the -th classmate has gems. DreamGrid would like to divide the classmates into four groups , , and such that: Each classmate belongs to exactly one group. Both and consist only of girls. Both and consist only of boys. The total number of gems in and is equal to the total number of gems in and . Your task is to help DreamGrid group his classmates so that the above conditions are satisfied. Note that you are allowed to leave some groups empty. InputThere are multiple test cases. The first line of input is an integer indicating the number of test cases. For each test case: The first line contains an integer () – the number of classmates. The second line contains a string () consisting of 0 and 1. Let be the -th character in the string . If , the -th classmate is a boy; If , the -th classmate is a girl. It is guaranteed that the sum of all does not exceed . OutputFor each test case, output a string consists only of {1, 2, 3, 4}. The -th character in the string denotes the group which the -th classmate belongs to. If there are multiple valid answers, you can print any of them; If there is no valid answer, output “-1” (without quotes) instead. Sample Input123456789101151121031014000071101001 Sample Output12345-1-131412213413214 题意： 有一串由0和1组成的数字，该串数字的长度是n，即n个数。这n个数1代表男生，0代表女生，每个人有一个权值。这n个数按次序权值依次为1到n，即第i个人权值为i。现将女生分两队，即1队2队，男生分两队，即3队4队，问如何分配队员使1队+3队的权值总和等于2队＋4队的权值总和。（每队人数可以为0，如果有多种符合情况的组队方法，只需选择其中一种即可） 题解： 看似复杂，其实仔细想想，只需将所有数的权值相加除以2得到half，以half这个数为基准，看哪些数相加为half，如果没有输出-1。思路大致是这样。将所有数的性别情况用a[i]存储。然后从1加到n，得到的数除以2，如果不能整除则表示1队+3队永远不会等于2队+4队，直接输出-1。如果能整除，则以half为基准，sum为每次加的数，初始值为0。把1队和3队归为一队，把2队4队归为一队。先从最大的即n开始进行比较，如果n &lt; half，sum加上n。然后进行判断half - sum=tmp是否小于n，如果小于n则证明tmp这个数一定在n之前，那直接将n以及tmp分为1个队，其他人则自然分为另一个队。如果 &gt;= n，则再从n-1开始比较，如果sum+n-1这个数大于half，则表示n-1和之前标记的数不是一个队，则从n-2继续比较。一直循环下去，直到加完之后刚好等于half，则标记过的是一队，未标记的是另一对，再分别对这两队进行性别判断，再细分即可。这样直接用贪心就解决了 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;int a[100010], vis[100010];using namespace std;int main() &#123; int t; scanf(&quot;%d&quot;, &amp;t); long long int sum = 0, half = 0; while (t--) &#123; int n; sum = 0; scanf(&quot;%d&quot;, &amp;n); memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%1d&quot;, &amp;a[i]); sum += i + 1; &#125; if (sum % 2 != 0) &#123; printf(&quot;-1\n&quot;); continue; &#125; else half = sum / 2; sum = 0; for (int i = n; i &gt; 0; i--) &#123; if (sum + i &lt;= half) &#123; sum += i; vis[i - 1] = 1; if (sum == half) break; else if (half - sum &lt; i) &#123; vis[half - sum - 1] = 1; break; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i]) &#123; if (vis[i]) printf(&quot;3&quot;); else printf(&quot;4&quot;); &#125; else if (!a[i]) &#123; if (vis[i]) printf(&quot;1&quot;); else printf(&quot;2&quot;); &#125; &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; L - Doki Doki Literature Club Time Limit: 1 Second Memory Limit: 65536 KB Doki Doki Literature Club! is a visual novel developed by Team Salvato. The protagonist is invited by his childhood friend, Sayori, to join their high school’s literature club. The protagonist then meets the other members of the club: Natsuki, Yuri, and the club president Monika. The protagonist starts to participate in the club’s activities such as writing and sharing poetry, and grows close to the four girls. What a lovely story! A very important feature of the game is its poetry writing mechanism. The player is given a list of various words to select from that will make up his poem. Each girl in the Literature Club has different word preferences, and will be very happy if the player’s poem is full of her favorite words. The poem writing mini-game (from wikipedia) BaoBao is a big fan of the game and likes Sayori the most, so he decides to write a poem to please Sayori. A poem of words is nothing more than a sequence of strings, and the happiness of Sayori after reading the poem is calculated by the formula Given a list of words and Sayori’s preference to each word, please help BaoBao select words from the list and finish the poem with these words to maximize the happiness of Sayori. Please note that each word can be used at most once! InputThere are multiple test cases. The first line of input contains an integer (about 100), indicating the number of test cases. For each test case: The first line contains two integers and (), indicating the number of words and the length of the poem. For the following lines, the -th line contains a string consisting of lowercased English letters () and an integer (), indicating the -th word and Sayori’s preference to this word. It’s guaranteed that for all . OutputFor each test case output one line containing an integer and strings separated by one space, indicating the maximum possible happiness and the corresponding poem. If there are multiple poems which can achieve the maximum happiness, print the lexicographically smallest one. Please, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect! A sequence of strings is lexicographically smaller than another sequence of strings , if there exists a () such that for all and is lexicographically smaller than . A string is lexicographically smaller than another string , if there exists a () such that for all and , or for all and . Sample Input1234567891011121314151617181920212223242526410 8hello 0world 0behind 0far 1be 2spring 10can 15comes 20winter 25if 2005 5collegiate 0programming -5zhejiang 10provincial 5contest -453 2bcda 1bcd 1bbbbb 13 2a 1aa 1aaa 1 Sample Output12342018 if winter comes can spring be far behind15 zhejiang provincial collegiate programming contest3 bbbbb bcd3 a aa 题意： 有n个字符串，每个字符串都有一个权值。现从n个字符串中选择m个字符串，其中m个字符串选取的第i个字符串的权值乘i。问如何选择使权值之和最大，并输出这些字符串。如果权值相同则输出字符串优先级高的。 题解：按权值从大到小进行排序，如果权值相同则按字符串的首字符优先级从大到小排序。排完序后选择前m个字符串，第i字符串的权值乘i之后相加，输出相加值之后，再输出前m大的字符串即可。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;struct node&#123; string str; long long int weight;&#125;;node level[110];bool cmp(node a,node b) &#123; if (a.weight != b.weight) return a.weight &gt; b.weight; else &#123; return a.str &lt; b.str; &#125;&#125;int main() &#123; int t, n, m; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; long long int h = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; level[i].str &gt;&gt; level[i].weight; &#125; sort(level, level + n, cmp); for (int i = m; i &gt; 0; i--) h += level[m - i].weight*i; printf(&quot;%lld &quot;, h); for (int i = 0; i &lt; m - 1; i++) cout &lt;&lt; level[i].str &lt;&lt; &quot; &quot;; cout &lt;&lt; level[m - 1].str &lt;&lt; endl; &#125; return 0;&#125; K - Lucky 7给一个数n和m，接下来n个数，问这n个数中是否存在一个数加m是7的倍数。 题解： 每输入一个数直接进行判断即可。]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>ACM/ICPC</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(高级篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-3%2F</url>
    <content type="text"><![CDATA[由于本人懒病又犯了，该部分后续再补上吧。大家不要介意啊。(#^.^#)]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客(进阶篇)]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-2%2F</url>
    <content type="text"><![CDATA[本文基于上篇文章基础篇所写。有许多基于hexo的主题，每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。我们可以根据自己的情况选择适合自己的主题。我们选取其中一款主题NextT为模板进行演示。以下是本文的基本流程。 基本流程1.安装主题 2.启用主题 3.验证主题 4.设置语言 5.设置菜单 6.侧栏设置 7.尾栏设置 8.附页 安装主题在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 以NexT为例，首先在hexo文件夹中右键点击Git Base Here，或者终端锁定hexo根目录，然后输入命令： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 即可获取最新版主题，后续更新只需输入指令： 1git pull 启用主题在hexo根目录（blog）中打开站点配置文件（_config.yml）,搜索theme字段。修改theme: next 1theme: next 注意中间有空格。到此，NexT 主题安装完成。 验证主题在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 1hexo clean 首先启动 Hexo 本地站点，并开启调试模式，整个命令是 1hexo s 在服务启动的过程，注意观察命令行输出是否有任何异常信息。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000/。 如果端口号被占用还是得先修改端口号，然后启动服务。即先输入 1hexo server -p 5000 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:5000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:5000/。 完成之后进行主题设定。借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。在next主题目录下的_config.yml文件中目前有四种模板，他们是： Muse - 默认 Scheme，初代 NexT ，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 双栏Scheme，简约淡雅的风尚 注释 # 即可。 以Pisce为例，选择 Pisce Scheme 设置语言在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans（简体中文） 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定实例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id 设置菜单菜单栏设置菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容。以简体中文为例，若你需要添加一个菜单项，那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml。以下是默认情况。 12345678menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 添加标签，分类添加标签页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面 1hexo new page tags 在新建的index.md文件中添加type: “tags” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可 添加分类页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加分类选项。此时我们要新建一个页面 1hexo new page categories 在新建的index.md文件中添加type: “categories” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的categories中添加分类即可。分类可按次序进行分级。 添加关于我页面，步骤和以上差不多 在新建的index.md文件中添加内容 侧栏设置设置侧栏位置，修改主题目录下sidebar的position值 设置头像，在站点根目录下载配置文件中新增avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source/images/ 目录下） 尾栏设置修改底部的官方logo，找到 \themes\next\layout\_partials\下面的footer.swig文件，打开会发现，如下的语句： 第一个框 是下面侧栏的“日期❤ XXX” 如果想像我一样加东西，一定要在双大括号外面写。如：xxx,当然你要是想改彻底可以变量都删掉，看个人意愿。 第二个，是图一当中 “由Hexo驱动” 的Hexo链接，先给删掉防止跳转，如果想跳转当然也可以自己写地址，至于中文一会处理。注意删除的时候格式不能错，只把&lt;a&gt;...&lt;/a&gt;标签这部分删除即可，留着两个单引号’’,否则会出错哦。 第三个框也是最后一个了，这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将&lt;a&gt;..&lt;/a&gt;都删掉，同样中文“主题”一会处理，删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西，不要显示敏感信息哟，请自重。 接下来，处理剩余的中文信息。找到这个地方\themes\next\languages\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可） 看到了吧，这个就是传值传过去的，你想显示什么就在这里面大肆的去改动吧。其实在第二个框中，就可以把值都改掉，不用接受传值的方式，完全自己可以重写。不过我不建议那样做，因为传值这样只要是后续页面需要这几个值那么就都会通过取值去传过去，要是在刚才footer文件中直接写死，后续不一定哪个页面需要传值，但是值为空了或者还是原来的，可就尴尬了。所以还是这样改动吧。 附页站点配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 网站title: 浅悠悠的个人博客 #网站标题subtitle: 。。。 #网站副标题description: 。。。 #网站描述author: 王骏 #您的名字language: zh-CN #网站使用的语言timezone: #网站时区。Hexo 默认使用您电脑的时区# URL 网址## 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。url: http://willxue.toppermalink: :year/:month/:day/:title/ #生成文件名字的格式我改成blog/:title:year:month:day/permalink_defaults:# Directory 目录配置source_dir: source #源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #nclude code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。# Writing 文章new_post_name: :title.md # 新建文章默认文件名default_layout: post # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # 在新标签中打开一个外部链接，默认为truefilename_case: 0 #转换文件名，1代表小写；2代表大写；默认为0，意思就是创建文章的时候，是否自动帮你转换文件名，默认就行，意义不大。render_drafts: false #是否渲染_drafts目录下的文章，默认为falsepost_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址，默认falsefuture: true #显示未来的文章，默认falsehighlight: #代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag 分类和标签的设置default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: nextfeed: type: atom #feed 类型 (atom/rss2) path: atom.xml #rss 路径 limit: 20 #在 rss 中最多生成的文章数(0显示所有)# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/imwillxue/imwillxue.github.com.git branch: master 主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Place your favicon.ico to /source directory.favicon: /favicon.ico #站标 可以放在hexo文件夹下的/source里# Set default keywords (Use a comma to separate)keywords: &quot;为学,willxue,willxue.top&quot; #网站关键字# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: #rss这里不设置 引文站点配置文件已经配置了 需要安装插件# Specify the date when the site was setupsince: 1990 #网站时间 从xx开始 类似 1990-2016# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running hexo in a subdirectory (e.g. domain.tld/blog)# Remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: #菜单路径设置 如果hexo在二级目录放置要去掉/ home: / archives: /archives #归档 tags: /tags #标签 categories: /categories #分类 about: /about #关于我 commonweal: /404.html #公益404# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwsome icon.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: #icon图标 enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes #next的三个scheme#scheme: Muse#scheme: Mistscheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social links #社交链接social: GitHub: Weibo: Others:# Social Icons #社交的图标social_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter Weibo: weibo# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpg# default : /images/default_avatar.jpgavatar: http://7xrz9n.com1.z0.glb.clouddn.com/logo.png #头像# TOC in the Sidebar #文章自动显示目录toc: enable: true # Automatically add list number to toc. #目录是否自动显示数字序号 number: false# Creative Commons 4.0 International License.# http://creativecommons.org/ #自由协议# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle icon. display: post #display: always #display: hide #display: remove# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically Excerptauto_excerpt: enable: false length: 150# Use Lato fontuse_font_lato: true# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax:# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortNameduoshuo_shortname: imwillxue# Disqus#disqus_shortname:# Baidu Share# Available value:# button | slide#baidushare:## type: button# Share#jiathis:#add_this_id:# Shareduoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# CNZZ count#cnzz_siteid:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: true user_id: 6262178932196377345 admin_nickname: 神# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: QImiFijLSOHYufsazlBVlwLg-gzGzoHsz app_key: AMcYaNHy9Y5OdH42k0d4uSED# Tencent analytics ID# tencent_analytics:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true## 文章末尾是否显示打赏按钮donate: enable: true text: Enjoy it ? Donate me ! 欣赏此文？求鼓励，求支持！ alipay: wechat: #! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.5.0]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于github搭建专属于自己的博客（基础篇）]]></title>
    <url>%2F2018%2F04%2F28%2F2018-04-28-1%2F</url>
    <content type="text"><![CDATA[以前学Django时，看的视频教程就是以搭建博客为案例讲解的。虽然最终也没搭建成功，但是当时就想搭建属于自己的博客。偶然间了解到了hexo搭建博客，恰好最近有空，索性就利用这段时间搭建一个属于自己的博客。首先，我先介绍一下用hexo搭建博客的基本流程： 基本流程：1.搭建前的准备（包括node.js，git，github账户的配置） 2.安装hexo 3.配置hexo 4.连接hexo与github page 5.发布文章 搭建前的准备1.安装node.js 2.安装git 3.github账户管理 配置Node.js下载node.js。根据自己电脑的配置自行安装。 安装完成后打开终端输入： 12node -vnpm -v 进行是否安装成功测试。如不正确，回头检查哪一步错误。 配置Gitgit官网。自行安装。 安装完成后打开终端输入： 1git --version 以上步骤进行是否安装成功。如果安装失败自行面壁。 github管理已拥有账号可跳过注册此步 打开github进行注册。 登录后点击右上角加号，选择New repository新建代码库。 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写描述（此步可忽略）。 注意：我的github名称是qianyouyou ,这里就填qianyouyou.github.io 建立后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages。点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 安装hexo在合适的地方创建文件夹，这里我以E:/blog 为例子讲解，首先在E盘目录下创建blog文件夹，终端锁定该文件夹 在命令行输入 1npm install hexo -g //进行安装 输入 1hexo -v //检验是否安装成功。 配置hexo输入 1hexo init //初始化该文件夹 看到后面的“Start blogging with Hexo！”证明正在执行。 输入 1npm install //安装所需要的组件 输入 1hexo g //生成 输入 1hexo s 开启服务器，访问该网址，正式体验Hexo 连接hexo与github page设置Git的user name和email（如果是第一次的话）在blog文件夹里面鼠标右键，点击Git Base Here。 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容 输入ssh-keygen -t rsa -C “xxxxxx@xx.com”，（你的邮箱）连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 发布文章新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在我的 电脑的目录下 E:\blog\source\ _posts 将会看到 article title.md 文件 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 当然你也可以执行下面的命令，相当于上面两条命令的效果 1hexo g -d //在部署前先生成 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章。 到此为止，最基本的也是最全面的hexo+github搭建博客完结。]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>node.js</tag>
        <tag>html/css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F24%2F2018-04-24%2F</url>
    <content type="text"><![CDATA[Welcome to My Blog! This is my very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server11$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>程序人生</category>
        <category>JavaScript</category>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据结构]堆的基本操作]]></title>
    <url>%2F2018%2F04%2F23%2F2018-04-23%2F</url>
    <content type="text"><![CDATA[堆（heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 1.堆总是一棵完全二叉树。 2.堆中某个节点的值总是不大于或不小于其父节点的值。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 本次操作具体以小根堆为例进行演示。 堆的存储一般采用树组存储，i结点的父结点下标为( i - 1 ) / 2。左子树的下标为2 i + 1,右子树的下标为2 i + 2。 堆的操作堆的插入每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。 1234567891011121314151617// 新加入i结点 其父结点为(i - 1) / 2 void MinHeapFixup(int a[], int i) &#123; int j, temp; temp = a[i]; j = (i - 1) / 2; //父结点 while (j &gt;= 0 &amp;&amp; i != 0) &#123; if (a[j] &lt;= temp) break; a[i] = a[j]; //把较大的子结点往下移动,替换它的子结点 i = j; j = (i - 1) / 2; &#125; a[i] = temp; 插入时 12345void MinHeapAddNumber(int a[], int n, int nNum) &#123; a[n] = nNum; MinHeapFixup(a, n); &#125; 堆的删除堆中每次都只能删除根结点，即第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。 123456789101112131415161718192021222324252627// 从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2 void MinHeapFixdown(int a[], int i, int n) &#123; int j, temp; temp = a[i]; j = 2 * i + 1; while (j &lt; n) &#123; if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的 j++; if (a[j] &gt;= temp) break; a[i] = a[j]; //把较小的子结点往上移动,替换它的父结点 i = j; j = 2 * i + 1; &#125; a[i] = temp; &#125; //在最小堆中删除数 void MinHeapDeleteNumber(int a[], int n) &#123; Swap(a[0], a[n - 1]); MinHeapFixdown(a, 0, n - 1); &#125; 构建堆有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。 123456//建立最小堆 void MakeMinHeap(int a[], int n) &#123; for (int i = n / 2 - 1; i &gt;= 0; i--) MinHeapFixdown(a, i, n); &#125; 堆排序首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。 由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。 12345678void MinheapsortTodescendarray(int a[], int n) &#123; for (int i = n - 1; i &gt;= 1; i--) &#123; Swap(a[i], a[0]); MinHeapFixdown(a, 0, i); &#125; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
        <category>堆</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[爬虫]python自动调用浏览器访问网页增加访问量]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22-1%2F</url>
    <content type="text"><![CDATA[该程序主要是为了增长访问量而写的，主要针对一些访问量与用户信息无关的网页，比如CSDN。当然前提是python安装相应的库。原理很简单，没有用到什么高端的爬虫技术，没有用到正则表达式什么的。其实就是调用你的浏览器，然后程序自动帮你打开你的博客网页，隔一段时间自动关闭，以此循环，刷访问量。不多说了，直接贴代码吧。 123456789101112131415161718192021import webbrowser as web import time import os import random count = random.randint(1, 2) j = 0 aa = [80042845,80025162,80035076,80025133,80025068,80024813,79986200,79935658,79933992,79783339,79747976,79747322,79734593,79734363,79706272,79700188,79725018,79724244] while j &lt; count: i = 0 while i &lt;= 8: k = random.randint(0,17) web.open_new_tab(&apos;https://blog.csdn.net/qian_youyou/article/details/&apos;+str(aa[k])) i = i + 1 time.sleep(3) else: time.sleep(20) os.system(&apos;taskkill /F /IM chrome.exe&apos;) # print &apos;time webbrower closed&apos; j = j + 1]]></content>
      <categories>
        <category>程序人生</category>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言打造智能AI小游戏——三子棋]]></title>
    <url>%2F2018%2F04%2F22%2F2018-04-22%2F</url>
    <content type="text"><![CDATA[三子棋具体就不多介绍了，AI棋用O表示，我们的棋用X表示。先手后手自己选。这里主要说一下AI算法。首先AI会对整个棋盘MAP[3][3]进行遍历，每个格子都有一个权值weight[i][j]。权值的第一次计算方法是对每一行i每一列j进行计算，计算基于这一格有几种获胜的路线。例如没有走时，9个格的权值为： [][][] 3 2 3 [][][] 2 4 2 [][][] 3 2 3 角落有横竖斜三种获胜方法，边有横竖两种方法，中心有横竖两斜4种方法。假如某格有X阻挡，那么权值会相应变化，例如 [][][] 2 1 2 []X[] 1 0 1 [][][] 2 1 2 由于有中心阻挡，那么角只有横竖两种方法赢，因此权值为2。但该AI还需继续优化。例如以下： []X[] 1 0 1 []0[] 1 0 2 XX0 0 0 0 AI面对这种情况，本来下在第一个格子就赢了，但他会选择权值为2的格子。因此我们可以在现有权值条件的情况下，在附加个权值。假如某一格子的路线上已经有AI的子了，那么该条路线上未落子的所有格子权值再加1，如果有两个已落子的AI格子权值就加2。例如以下情况： ​ 原权值 优化权值 []X[] 2 0 2 5 0 3 []0[] 2 0 2 3 0 4 []X0 2 0 0 3 0 0 第一个格子5是由于斜路线上有两个子，那在原有的基础2上先加1，再加2，所以权值为2+1+2。第2行第3列权值为4，因为横竖两条路线均有1个子，因此权值为2+1+1，其余格子路线上均有1个子，因此权值为2+1。这样落在权值5那个格子上AI就赢了。 但是仅仅这些判断是不够的。例如： ​ 初始 优化 X[]X 0 1 0 0 2 0 []0[] 1 0 1 2 0 2 [][]0 1 2 0 2 4 0 AI会选择权值为4的格子。那此时AI选择权值为2的格子时，你只需要走一步就赢了，AI就输了，因此该AI算法还得继续。 那么AI可以逆向思考一番，AI可以考虑一下当前情况在计算AI权值的同时再计算一次我们的权值。例如上面例子： ​ AI权值 你的权值 优化AI 优化你 X[]X 0 1 0 0 1 0 0 2 0 0 4 0 []0[] 1 0 1 1 0 0 2 0 2 2 0 0 [][]0 1 2 0 1 0 0 2 4 0 2 0 0 我们把两个权值相加（另外把AI的权值应该再加1，因为AI判断赢要优先于输或平，假如AI方有权值大的，代表一步能赢的，我方也有这种情况，那相加权值相同，AI既可以选择赢棋那一格，也可以选择堵你将要赢的那一格。但AI判断赢要优先于堵对方赢。例子就不举了）： ​ 相加权值 再加1权值 X[]X 0 6 0 0 7 0 []0[] 4 0 2 5 0 3 [][]0 4 4 0 5 4 0 因此AI判断到这里就会堵你了。 AI算法就介绍到这里，至于三子棋程序，由于过于简单，就不过多介绍了。主要介绍AI思想，Windows系统编译的程序。如果是Linux需要把以下代码改下。接下来我就贴上代码，供参考，如有不懂欢迎留言。 project.h 12345678910111213141516#pragma once #define COLUMN 3 #define ROW 3 #define GOON 0 #define WIN -1 #define DEFEAT 1 void init(char(*MAP)[COLUMN]); int victory(char(*MAP)[COLUMN]); bool check(char(*MAP)[COLUMN]); void show(char(*MAP)[COLUMN]); void check_stemp(char(*MAP)[COLUMN], int *x, int *y); void ai_auto(char(*MAP)[COLUMN]); int menu(); int first_hand(char(*MAP)[COLUMN]); int ai_hand(char(*MAP)[COLUMN]); void play(char(*MAP)[COLUMN]); project.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&quot;project.h&quot; int vis[ROW][COLUMN]; int weight[ROW][COLUMN]; int x, y; void init(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) &#123; MAP[i][j] = &apos; &apos;; vis[i][j] = 0; &#125; &#125; int victory(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] == &apos;X&apos;&amp;&amp;MAP[i][1] == &apos;X&apos;&amp;&amp;MAP[i][2] == &apos;X&apos;) return WIN; else if (MAP[i][0] == &apos;O&apos;&amp;&amp;MAP[i][1] == &apos;O&apos;&amp;&amp;MAP[i][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][i] == &apos;X&apos;&amp;&amp;MAP[1][i] == &apos;X&apos;&amp;&amp;MAP[2][i] == &apos;X&apos;) return WIN; else if (MAP[0][i] == &apos;O&apos;&amp;&amp;MAP[1][i] == &apos;O&apos;&amp;&amp;MAP[2][i] == &apos;O&apos;) return DEFEAT; &#125; if (MAP[0][0] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][2] == &apos;X&apos;) return WIN; else if (MAP[0][0] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][2] == &apos;O&apos;) return DEFEAT; if (MAP[0][2] == &apos;X&apos;&amp;&amp;MAP[1][1] == &apos;X&apos;&amp;&amp;MAP[2][0] == &apos;X&apos;) return WIN; else if (MAP[0][2] == &apos;O&apos;&amp;&amp;MAP[1][1] == &apos;O&apos;&amp;&amp;MAP[2][0] == &apos;O&apos;) return DEFEAT; return GOON; &#125; bool check(char(*MAP)[COLUMN]) &#123; for (int i = 0; i &lt; ROW; i++) for (int j = 0; j &lt; COLUMN; j++) if (!vis[i][j]) return false; return true; &#125; void show(char(*MAP)[COLUMN]) &#123; printf(&quot;-------------\n&quot;); for (int i = 0; i &lt; ROW; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt; COLUMN; j++) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; printf(&quot;\n&quot;); printf(&quot;-------------\n&quot;); &#125; &#125; void check_stemp(char(*MAP)[COLUMN], int *x, int *y) &#123; while (*x &gt; 3 || *x &lt;= 0 || *y&gt;3 || *y &lt;= 0 || MAP[*y - 1][*x - 1] != &apos; &apos;) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Input error, please reenter!\n&quot;); scanf(&quot;%d%d&quot;, x, y); &#125; MAP[*y - 1][*x - 1] = &apos;X&apos;; vis[*y - 1][*x - 1] = 1; &#125; void Empowerment(char(*MAP)[COLUMN], int(*weight)[COLUMN], char ai_X, char ai_0, int flag) &#123; for (int i = 0; i &lt; 3; i++) &#123; if (MAP[i][0] != ai_X&amp;&amp;MAP[i][1] != ai_X&amp;&amp;MAP[i][2] != ai_X) &#123; weight[i][0]++; weight[i][1]++; weight[i][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[i][j] == ai_0) &#123; weight[i][0] += tmp+flag; weight[i][1] += tmp+flag; weight[i][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][i] != ai_X&amp;&amp;MAP[1][i] != ai_X&amp;&amp;MAP[2][i] != ai_X) &#123; weight[0][i]++; weight[1][i]++; weight[2][i]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][i] == ai_0) &#123; weight[0][i] += tmp+flag; weight[1][i] += tmp+flag; weight[2][i] += tmp+flag; tmp += 10; &#125; &#125; &#125; if (MAP[0][0] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][2] != ai_X) &#123; weight[0][0]++; weight[1][1]++; weight[2][2]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][j] == ai_0) &#123; weight[0][0] += tmp+flag; weight[1][1] += tmp+flag; weight[2][2] += tmp+flag; tmp += 10; &#125; &#125; if (MAP[0][2] != ai_X&amp;&amp;MAP[1][1] != ai_X&amp;&amp;MAP[2][0] != ai_X) &#123; weight[0][2]++; weight[1][1]++; weight[2][0]++; int tmp = 1; for (int j = 0; j &lt; 3; j++) if (MAP[j][2 - j] == ai_0) &#123; weight[0][2] += tmp+flag; weight[1][1] += tmp+flag; weight[2][0] += tmp+flag; tmp += 10; &#125; &#125; &#125; void ai_auto(char(*MAP)[COLUMN]) &#123; int weight[3][3] = &#123; 0 &#125;; Empowerment(MAP, weight, &apos;X&apos;, &apos;O&apos;, 1); Empowerment(MAP, weight, &apos;O&apos;, &apos;X&apos;, 0); int maxn = -1; int maxm = -1; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) &#123; if (vis[i][j]) weight[i][j] = -1; if (maxn &lt; weight[i][j]) &#123; maxn = weight[i][j]; maxm = i * 3 + j; &#125; &#125; MAP[maxm / 3][maxm % 3] = &apos;O&apos;; vis[maxm / 3][maxm % 3] = 1; &#125; int menu() &#123; int tmp; printf(&quot;*************************************************************\n&quot;); printf(&quot;* Please enter: * 1:First hand * 2.Back hand * Others:Close *\n&quot;); printf(&quot;*************************************************************\n&quot;); scanf(&quot;%d&quot;, &amp;tmp); return tmp; &#125; int first_hand(char(*MAP)[COLUMN]) &#123; system(&quot;cls&quot;); show(MAP); printf(&quot;Please enter:x y\n&quot;); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); check_stemp(MAP, &amp;x, &amp;y); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == WIN) &#123; printf(&quot;Congratulations on your victory, you are as smart as Qianyouyou.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; system(&quot;pause&quot;); return 0; &#125; int ai_hand(char(*MAP)[COLUMN]) &#123; ai_auto(MAP); system(&quot;cls&quot;); show(MAP); if (victory(MAP) == DEFEAT) &#123; printf(&quot;You lose, you&apos;re as stupid as a pig.\n&quot;); return 1; &#125; else if (check(MAP)) &#123; printf(&quot;Draw.As smart as me.\n&quot;); return 1; &#125; return 0; &#125; void play(char(*MAP)[COLUMN]) &#123; while (!check(MAP) || victory(MAP) == GOON) &#123; if (first_hand(MAP)) break; if (ai_hand(MAP)) break; &#125; system(&quot;pause&quot;); &#125; main.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&quot;project.h&quot; char MAP[ROW][COLUMN]; int main() &#123; char str[2]; do &#123; init(MAP); switch (menu()) &#123; case 1: first_hand(MAP); case 2: &#123; ai_hand(MAP); play(MAP); &#125; default: &#123; printf(&quot;Do you need to start again?(Y/N)&quot;); scanf(&quot;%s&quot;, str); &#125;break; &#125; &#125; while (str[0] == &apos;Y&apos; || str[0] == &apos;y&apos;); printf(&quot;Thank you for using!\n&quot;); system(&quot;pause&quot;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>博弈论</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[排序]求解第k大分值]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21%2F</url>
    <content type="text"><![CDATA[描述： Arch0n老师is a rich man, 他靠自己的才华和智商年纪轻轻就赚了不少钱。为了训练自己的智商，他经常玩一些interesting的游戏来训练自己的智商，比如什么RGB游戏，还有和妹子一块玩Don’t Starve。 言归正传，今天他又发明了一个新的interesting game。Ar老师手上有一堆卡牌，然后卡牌上写了一个数字Ai(正整数)，当前他有n张牌，然后他总是随机取出两张来，然后他一眼就能看出这两牌中哪一张小（相同就取相同的，这操作好像对于Ar老师来说太简单了），作为这两张牌的有效分值，然后呢他陷入了沉思，对于n张牌取两张牌显然有确定的组合可能性，有n(n-1)/2对组合，然后他想知道所有这些组合中第k大的分值是多少。输入描述:输入一个t表示数据组数；(0&lt;t&lt;=10)接下来一行是n,k,表示n张牌和最后第k大的分值；（1&lt;n&lt;2500,保证0&lt;k&lt;=n(n-1)/2）接下来一行是n个值ai，表示第i张牌上的数字(0 &lt; ai &lt;= 10000000)。输出描述:每组数据输出一行，即第k大的分值为多少。 示例 输入 2 3 2 1 2 3 3 1 4 2 1 输出 1 2 题解： 首先将这n个数进行从大到小排序，a[0]储存第1大，a[1]储存第2大……第2个和第1个比较最小的是第2个，第3个和前两个比较较小的均是第3个，第4个和前3个比较均是第4个，以此递推，第n个数和n前n-1个比较均是n较小。将所有情况全排列很容易超时，因此我们可以从第k大这个k下手。由于a[0]最大，因此a[0]和任意比较都不会输出a[0]。那么首先k为1输出a[1],1&lt;k&lt;=1+2输出a[2],1+2&lt;k&lt;=1+2+3输出a[3]……现在应该很清楚了吧。可以设置一个变量cnt，和i,从1开始，cnt每次加1，i每次加cnt，直到i加到比k大或者等于时，那么此时的a[cnt]就是第k大的数。 1234567891011121314151617181920212223#include&lt;iostream&gt; #include&lt;algorithm&gt; int cmp(int a, int b) &#123; return a &gt; b; &#125; int T, N, k, a[100010]; using namespace std; int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; N &gt;&gt; k; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + N, cmp); int cnt = 1, i = 1; for (int i = 1; i &lt; k; i += cnt) &#123; cnt++; &#125; cout &lt;&lt; a[cnt] &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]C语言实现小游戏——控制台扫雷]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-3%2F</url>
    <content type="text"><![CDATA[程序比较简单，需要输入坐标x，y进行翻牌。当时现场演示时不到50分钟边讲边写的，实现了基本的扫雷功能，只是没有计分计时排名之类的辅助功能。由于程序较简单，也没必要再加工了。另外本程序的特点是第一次输入一定不会是雷。此外，如果翻牌后周围没有雷，即为0，将会搜索周围所以为0的牌。此处用到了dfs。仅供参考。 项目版： mine.h 1234567#pragma once #define BOOM 10 #define SIZE 10 void init(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b);//初始化扫雷页面void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j);//如果展开面为0，通过深搜将周围所以为0的区域展开 int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//判断胜利条件 void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y);//展示扫雷页面 mine.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; int stemp[8][2] = &#123; &#123; 0,1 &#125;,&#123; 0,-1 &#125;,&#123; 1,0 &#125;,&#123; -1,0 &#125;,&#123; 1,1 &#125;,&#123; -1,-1 &#125;,&#123; 1,-1 &#125;,&#123; -1,1 &#125; &#125;;//深搜时上下左右四个方向搜索 void init(char (*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(MAP, visit, i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(MAP, visit, x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show(char(*MAP)[SIZE + 2], int(*visit)[SIZE + 2], int x, int y) &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&quot;mine.h&quot; char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y;//坐标 int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(MAP, visit, x, y); scanf(&quot;%d%d&quot;, &amp;y, &amp;x); init(MAP,visit, x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;y, &amp;x); int res = check(MAP, visit, x, y); system(&quot;cls&quot;); show(MAP, visit, x, y); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125; 另附原始版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #define BOOM 10 #define SIZE 10 char MAP[SIZE + 2][SIZE + 2]; int visit[SIZE + 2][SIZE + 2]; int x, y; int stemp[8][2] = &#123; &#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;, &#123;-1,1&#125; &#125;; void init(int a, int b) &#123; int x, y; visit[a][b] = 0; for (int i = 0; i &lt; 10; i++) &#123; do &#123; x = rand() % SIZE + 1; y = rand() % SIZE + 1; &#125; while (visit[x][y] == 0); if (visit[x][y] == -1) &#123; visit[x][y] == 0; MAP[x][y] = &apos;*&apos;; &#125; &#125; for (int i = 1; i &lt;= SIZE; i++) &#123; for (int j = 1; j &lt;= SIZE; j++) &#123; if (MAP[i][j] != &apos;*&apos;) &#123; MAP[i][j] = &apos;0&apos;; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;*&apos;) MAP[i][j]++; &#125; &#125; &#125; &#125; &#125; void dfs(int i, int j) &#123; visit[i][j] = 1; for (int k = 0; k &lt; 8; k++) &#123; if (MAP[i + stemp[k][0]][j + stemp[k][1]] == &apos;0&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) dfs(i + stemp[k][0], j + stemp[k][1]); else if (MAP[i + stemp[k][0]][j + stemp[k][1]] != &apos;*&apos;&amp;&amp;visit[i + stemp[k][0]][j + stemp[k][1]] != 1) visit[i + stemp[k][0]][j + stemp[k][1]] = 1; &#125; &#125; int check() &#123; if (MAP[x][y] == &apos;*&apos;) &#123; visit[x][y] = 1; return 1; &#125; else if (MAP[x][y] == &apos;0&apos;) &#123; dfs(x, y); &#125; else visit[x][y] = 1; int temp = 0; for (int i = 1; i &lt;= SIZE; i++) for (int j = 1; j &lt;= SIZE; j++) &#123; if (visit[i][j] == -1) temp++; &#125; if (temp == BOOM) return 2; return 0; &#125; void show() &#123; printf(&quot;-------------------------------------------------\n&quot;); for (int i = 0; i &lt;= SIZE + 1; i++) &#123; printf(&quot;|&quot;); for (int j = 0; j &lt;= SIZE + 1; j++) &#123; if (visit[i][j] == 1) &#123; printf(&quot; %c &quot;, MAP[i][j]); printf(&quot;|&quot;); &#125; else &#123; printf(&quot; &quot;); printf(&quot;|&quot;); &#125; &#125; printf(&quot;\n&quot;); printf(&quot;-------------------------------------------------\n&quot;); &#125; &#125; int main() &#123; srand(time(0)); memset(visit, -1, sizeof(visit)); MAP[0][0] = &apos; &apos;; for (int i = 1; i &lt;= SIZE; i++) &#123; MAP[0][i] = &apos;A&apos; + i - 1; MAP[i][0] = &apos;a&apos; + i - 1; MAP[SIZE + 1][i] = &apos;A&apos; + i - 1; MAP[i][SIZE + 1] = &apos;a&apos; + i - 1; &#125; for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; show(); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); init(x, y); memset(visit, -1, sizeof(visit)); for (int i = 1; i &lt;= SIZE + 1; i++) &#123; visit[0][i] = 1; visit[i][0] = 1; visit[SIZE + 1][i] = 1; visit[i][SIZE + 1] = 1; &#125; check(); system(&quot;cls&quot;); show(); while (MAP[x][y] != &apos;*&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int res = check(); system(&quot;cls&quot;); show(); if (res == 2) &#123; printf(&quot;Win\n&quot;); system(&quot;pause&quot;); return 0; &#125; else if (res == 1) &#123; printf(&quot;Lose\n&quot;); system(&quot;pause&quot;); return 0; &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现随机生成数独九宫格]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-2%2F</url>
    <content type="text"><![CDATA[一年前的程序，可以生成一个数独的九宫格。当时想这种方法想了3天，终于实现了。由于当时刚熟悉指针，因此指针用的比较多。本人比较懒，先把代码贴出来，后序补充具体实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; void main() &#123; int a[9][9] = &#123; 0 &#125;; int *p[3][3], *m[3][6], *n[3][6], *r[9][4], *aa[9][9]; int **q[9]; int i, j, k, l, h, t, s = 0; void rank(int *x, int *y); bool check(int a[9][9], int n); srand((int)time(0)); for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 3; j++) p[i][j] = &amp;a[i * 3 + 1][j * 3 + 1]; for (k = 0; k &lt; 9; k++) q[k] = &amp;p[k / 3][k % 3]; for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; m[i][j] = &amp;a[i * 3 + 1][2 * j - j / 2]; n[i][j] = &amp;a[2 * j - j / 2][i * 3 + 1]; &#125; for (k = 0; k &lt; 9; k++) for (l = 0; l &lt; 4; l++) r[k][l] = &amp;a[(k / 3) * 3 + (l / 2) * 2][(k % 3) * 3 + (l % 2) * 2]; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) aa[i][j] = &amp;a[i][j]; step1: for (i = 0; i &lt; 9; i++) &#123; next1: **q[i] = rand() % 10; if (**q[i] == 0) goto next1; for (j = 0; j &lt; i; j++) if (**q[j] == **q[i]) goto next1; &#125; step2: for (i = 0; i &lt; 3; i++) for (j = 0; j &lt; 6; j++) &#123; next2: *m[i][j] = rand() % 10; if (*m[i][j] == 0) goto next2; for (k = 0; k &lt; 3; k++) if (*m[i][j] == *p[i][k]) goto next2; for (k = 0; k &lt; j; k++) if (*m[i][j] == *m[i][k]) goto next2; for (k = 0; k &lt; i; k++) if (*m[i][j] == *m[k][j]) goto step2; &#125; step3: for (i = 0; i &lt; 3; i++) &#123; next4: for (j = 0; j &lt; 6; j++) &#123; next3: *n[i][j] = rand() % 10; if (*n[i][j] == 0) goto next3; for (k = 0; k &lt; 3; k++) if (*n[i][j] == *p[k][i]) goto next3; for (k = 0; k &lt; j; k++) if (*n[i][j] == *n[i][k]) goto next3; for (l = 0; l &lt; 2; l++) &#123; if (*n[i][j] == *m[j / 2][i * 2 + l]) goto next4; &#125; for (k = 0; k &lt; i; k++) if (*n[i][j] == *n[k][j]) goto step3; &#125; &#125; step4: for (i = 0; i &lt; 3; i++) &#123; for (h = 0; h &lt; 2; h++) &#123; next6: for (l = 0; l &lt; 3; l++) for (j = 0; j &lt; 2; j++) &#123; next5: *r[i * 3 + l][h * 2 + j] = rand() % 10; if (*r[i * 3 + l][h * 2 + j] == 0) goto next5; if (*r[i * 3 + l][h * 2 + j] == **q[i * 3 + l]) goto next5; for (k = 0; k &lt; h * 2 + j; k++) if (*r[i * 3 + l][h * 2 + j] == *r[i * 3 + l][k]) goto next5; for (k = 0; k &lt; 2; k++) &#123; if (*r[i * 3 + l][h * 2 + j] == *m[i][l * 2 + k]) goto next5; if (*r[i * 3 + l][h * 2 + j] == *n[l][i * 2 + k]) goto next5; &#125; for (k = 0; k &lt;= l * 3 + j * 2; k++) for (t = 0; t &lt; k; t++) if (a[i * 3 + h * 2][k] == a[i * 3 + h * 2][t]) goto next6; &#125; &#125; &#125; step5: for (i = 0; i &lt; 3; i++) &#123; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); if (check(a, i) == false) rank(aa[j][i * 3], aa[j][i * 3 + 2]); else if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (j = 0; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 9; l++) &#123; for (j = l + 1; j &lt; 9; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) &#123; for (l = 0; l &lt; 6; l++) &#123; for (h = l + 1; h &lt; 7; h++) &#123; for (j = h + 1; j &lt; 8; j++) &#123; for (k = 8; k &gt; j; k--) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); if (check(a, i) == false) &#123; rank(aa[l][i * 3], aa[l][i * 3 + 2]); rank(aa[h][i * 3], aa[h][i * 3 + 2]); rank(aa[j][i * 3], aa[j][i * 3 + 2]); rank(aa[k][i * 3], aa[k][i * 3 + 2]); &#125; else if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; if (check(a, i) == true) break; &#125; &#125; if (check(a, i) == false) goto step4; &#125; printf(&quot;+---------------+---------------+---------------+\n&quot;); printf(&quot;| | | |\n&quot;); for (i = 0; i &lt; 9; i++) &#123; printf(&quot;| &quot;); for (j = 0; j &lt; 9; j++) &#123; printf(&quot;%-4d&quot;, a[i][j]); if ((j + 1) % 3 == 0) printf(&quot;| &quot;); &#125; printf(&quot;\n&quot;); printf(&quot;| | | |\n&quot;); if ((i + 1) % 3 == 0) &#123; printf(&quot;+---------------+---------------+---------------+\n&quot;); if (i &lt; 8) printf(&quot;| | | |\n&quot;); &#125; &#125; system(&quot;pause&quot;); &#125; void rank(int *x, int *y) &#123; int t; t = *x; *x = *y; *y = t; &#125; bool check(int a[9][9], int n) &#123; int i, j; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; i; j++) if (a[i][n * 3] == a[j][n * 3]) return false; return true; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂项项目]纯C语言实现控制台小游戏——数字拼图]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20%2F</url>
    <content type="text"><![CDATA[一年前写的小游戏，当时感觉小有成就，现在发现缺陷真的很多。不禁感叹，当时为什么会用那么多goto呢。在这里真的建议大家不要用goto。只是现在懒得改了，毕竟是小程序。贴出来供大家参考。如果有时间后序再添加注释。如有问题欢迎评论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include&lt;math.h&gt; #include &lt;time.h&gt; #define max 10 int x, y, step, label = 0; typedef struct score &#123; int steps, steps2; double times; char name[18]; &#125;score; score sco[max + 1]; char ch, buff[3]; bool flag, flag1 = false; clock_t start, finish; bool over()&#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t\t\t您共用了 %d 步 ,耗时 %.3f 分钟\n&quot;, step, (double)(finish - start) / 40000); system(&quot;pause&quot;); system(&quot;cls&quot;); printf(&quot;\n\n\n\n\n\n\n\n\t******************* 您是否重新开始游戏 (Y/N) ? *******************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch != &apos;n&apos;&amp;&amp;ch != &apos;N&apos;) &#123; return false; &#125; else &#123; printf(&quot;\n\n\n\n\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n&quot;); printf(&quot;\t+++++++++++++++++++++++++ 感谢您的使用 +++++++++++++++++++++++++\n&quot;, step); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); system(&quot;pause&quot;); exit(0); &#125; return true; &#125; void rank(score sco[],int n) &#123; int i, j; sco[0] = sco[n]; for (i = 0; i &lt; n; i++) if (sco[n].steps2&gt;sco[i].steps2) &#123; for (j = n; j &gt; i; j--) sco[j] = sco[j - 1]; sco[i] = sco[0]; break; &#125; for (j = i - 1; j &gt; 0; j--) if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps &lt; sco[j].steps) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; else if (sco[i].steps2 == sco[j].steps2&amp;&amp;sco[i].steps == sco[j].steps) if (sco[i].times &lt; sco[j].times) sco[0] = sco[i], sco[i] = sco[j], sco[j] = sco[0], i = j; &#125; int check2(int *p, int n) &#123; int i, j, flag2 = 0; for (i = 1; i &lt; n*n - 1; i++) for (j = 0; j &lt; i; j++) if (p[j] &gt; p[i]) flag2++; if (!flag2) return 0; else if (flag2 % 2 == 0) return 2; else return 1; &#125; bool check(int *p,int n) &#123; int i; flag = true; for (i = 0; i&lt;n*n - 1; i++) if (p[i] != i + 1) flag = false; if (flag) &#123; flag1 = false; return false; &#125; return true; &#125; int operation(int *p,int n) &#123; scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch &gt;= &apos;a&apos;&amp;&amp;ch &lt;= &apos;z&apos;) ch -= 32; switch (ch) &#123; case &apos;A&apos;: if (y == n - 1) return 1; p[x*n + y] = p[x*n + y + 1]; p[x*n + y + 1] = 0; y++; step++; return 1; case &apos;W&apos;: if (x == n - 1) return 1; p[x*n + y] = p[(x + 1)*n + y]; p[(x + 1)*n + y] = 0; x++; step++; return 1; case &apos;D&apos;: if (y == 0) return 1; p[x*n + y] = p[x*n + y - 1]; p[x*n + y - 1] = 0; y--; step++; return 1; case &apos;S&apos;: if (x == 0) return 1; p[x*n + y] = p[(x - 1)*n + y]; p[(x - 1)*n + y] = 0; x--; step++; return 1; case &apos;R&apos;: return 2; case &apos;M&apos;: return 3; case &apos;Q&apos;: printf(&quot;\n\n\t********************* 您是否要离开游戏 (Y/N) ? *********************\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; if (ch == &apos;y&apos; || ch == &apos;Y&apos;) return 4; else return 1; default: return 1; &#125; return 0; &#125; void map(int *p, int n) &#123; int i, j; system(&quot;cls&quot;); printf(&quot;\n\n\n&quot;); for (i = 0; i &lt; n; i++) &#123; printf(&quot;\t&quot;); for (j = 0; j &lt; n; j++) &#123; if (p[n*i + j] != 0) printf(&quot;%-4d&quot;, p[n*i + j]); else printf(&quot; &quot;); &#125; printf(&quot;\n\n&quot;); &#125; printf(&quot;\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); finish = clock(); printf(&quot;\n\t\t\t\t步数: %d\t 使用时间: %.3f 分钟 \n\n&quot;, step, (double)(finish - start) / 40000); &#125; void reset(int *p, int n) &#123; int i, j, flag2; system(&quot;cls&quot;); do &#123; for (i = 0; i &lt; n*n - 1; i++) &#123; do &#123; flag2 = 1; p[i] = rand() % (n*n - 1) + 1; for (j = 0; j &lt; i; j++) if (p[i] == p[j]) flag2 = 0; &#125; while (!flag2); &#125; flag2 = check2(p, n); if (flag2 == 1) &#123; flag2 = p[n*n - 2]; p[n*n - 2] = p[n*n - 3]; p[n*n - 3] = flag2; &#125; &#125; while (!flag2); p[n*n - 1] = 0; for (i = 0; i&lt;n; i++) for (j = 0; j&lt;n; j++) if (p[i*n + j] == 0)&#123; x = i; y = j; &#125; &#125; void help() &#123; int i = 0; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t--------------------------------+ 基本操作 +--------------------------------\n\n&quot;); printf(&quot;\n\n\t按方向键移动卡片至无卡片的地方 W:上 S:下 A:左 D:右 M:返回菜单 R:换图 Q:退出\n\n&quot;); printf(&quot;\n\n\t---------------------------+ 浅悠悠（王骏）制作 +---------------------------\n\n&quot;); if (label == 0) printf(&quot;\n\n\t--------------------------+ 暂时没有任何游戏记录 +--------------------------\n\n&quot;); else for (i = 1; i &lt;= label; i++) printf(&quot;\n\n\t 第%02d名：%-18s 步数：%-5d 阶数：%-5d 时间：%-6.3lf分钟\n\n&quot;, i, sco[i].name, sco[i].steps, sco[i].steps2, sco[i].times); printf(&quot;\n\n\t----------------------------+ 按任意键返回菜单 +----------------------------\n\n&quot;); system(&quot;pause&quot;); &#125; void game() &#123; int n, *p; int mark; do &#123; system(&quot;cls&quot;); printf(&quot;\n\n\n\n\t------------------+ 请输入阶数（推荐3——20阶） +------------------\n\n&quot;); scanf(&quot;%d&quot;, &amp;n); if (n &gt; 1) p = (int*)calloc(n*n, sizeof(int)); else printf(&quot;\t********************** 您输入有误，请重新输入 **********************\n\n&quot;), system(&quot;pause&quot;); &#125; while (n &lt;= 1); next1: step = 0; start = clock(); reset(p, n); next2: map(p, n); if (check(p, n) == false) &#123; printf(&quot;\n\n\t=================+ 恭喜您完成游戏，请输入您的姓名 +=================\n\n&quot;); scanf(&quot;%s&quot;, sco[++label].name); sco[label].steps = step; sco[label].steps2 = n; sco[label].times = (double)(finish - start) / 40000; rank(sco, label); if (over() == false) return; &#125; mark = operation(p, n); if (mark == 1) goto next2; else if (mark == 2) goto next1; else if (mark == 3) return; else if (mark == 4) if (over() == false) return; free(p); &#125; int main()&#123; srand((int)time(0)); do &#123; system(&quot;cls&quot;); printf(&quot;\t-------------+ 欢迎来到浅悠悠数字拼图，请选择您的操作 +-------------\n\n&quot;); printf(&quot;\t-----+ 1.开始游戏 +-----+ 2.帮助 +-----+ 0(或其他).退出 +-----\n\n&quot;); printf(&quot;\t++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n&quot;); scanf(&quot;%s&quot;, buff); ch = buff[0]; switch (ch)&#123; case&apos;1&apos;: game(); break; case&apos;2&apos;: help(); break; case&apos;0&apos;: exit(0); default: exit(0); &#125; &#125; while (ch != &apos;0&apos;); return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]正向BFS+hash解决八码问题]]></title>
    <url>%2F2018%2F04%2F18%2F2018-04-18%2F</url>
    <content type="text"><![CDATA[八数码问题，可以用单向广搜、双向广搜、A*、IDA等多种方法求解。具体可以参考：八数码的八境界 Description 1234567 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 x 123456789 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 12 13 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x r-&gt; d-&gt; r-&gt; Input 123451 2 3 x 4 6 7 5 8 11 2 3 x 4 6 7 5 8 Output You will print to standard output either the word unsolvable’’, if the puzzle has no solution, or a string consisting entirely of the letters ‘r’, ‘l’, ‘u’ and ‘d’ that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Sample Input 12 3 4 1 5 x 7 6 8 Sample Output 1ullddrurdllurdruldr 题解： 本题一共仅有9！种结果，因此求解方法很多。一开始采用stl进行存储，但一直超时，后来改用hash轻轻松松就过了。判重时9！个排列如果用数组直接保存，每一位保存一个维度，数组开不了那么大。因此可以根据康托展开进行判重，每一种排列对应成一个整形数字，9！种排列一共9！个数字，提高了hash效率。此外，对于x我们暂且当做9处理，而123456789的康托展开是1，因此bfs的终止条件就设为当前状态的康拓展开是否为1。此外，由于本次采用正向bfs，而输出结果时需要输出之前的状态，string储存太慢，queue队列会丢失之前的状态，因此用数组充当队列，用pre追溯上一个状态在队列中的下标。解决代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; using namespace std; const int MAXN = 400000; int fac[9] = &#123; 1, 1, 2, 6, 24, 120, 720, 5040, 40320&#125;; int dir[4][2] = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;; int opp[4] = &#123; &apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos; &#125;; bool vis[MAXN]; struct node &#123; int stadus; int cur[9]; int loc; char path; int pre; &#125;; node qu[MAXN]; int cantor(int s[]) &#123; int sum = 0; for (int i = 0; i&lt;9; i++) &#123; int num = 0; for (int j = i + 1; j&lt;9; j++) if (s[j]&lt;s[i]) num++; sum += num*fac[8 - i]; &#125; return sum + 1; &#125; int bfs(node now) &#123; memset(vis, false, sizeof(vis)); int x, y; int front = 0, end = 0; node no = now; qu[end++] = no; vis[now.stadus] = true; while (front &lt; end) &#123; no = qu[front++]; x = no.loc / 3; y = no.loc % 3; if (no.stadus == 1) return front - 1; for (int i = 0; i &lt; 4; i++) &#123; node cc = no; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 3 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; 3 &amp;&amp; yy &gt;= 0) &#123; cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.cur[xx * 3 + yy] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.cur[x * 3 + y] = cc.cur[x * 3 + y] ^ cc.cur[xx * 3 + yy]; cc.stadus = cantor(cc.cur); if (!vis[cc.stadus]) &#123; vis[cc.stadus] = true; cc.loc = xx * 3 + yy; cc.path = opp[i]; cc.pre = front - 1; qu[end++] = cc; &#125; &#125; &#125; &#125; return -1; &#125; void show(int a) &#123; if (qu[a].pre) &#123; show(qu[a].pre); &#125; printf(&quot;%c&quot;, qu[a].path); &#125; int main() &#123; string tmp; while (getline(cin, tmp)) &#123; int i = 0, cnt = 0; node temp; while (tmp[i]) &#123; if (tmp[i] == &apos; &apos;) &#123; i++; continue; &#125; else if (tmp[i] == &apos;x&apos;) &#123; temp.loc = cnt; temp.cur[cnt] = 9; cnt++; i++; &#125; else &#123; temp.cur[cnt] = tmp[i] - &apos;0&apos;; cnt++; i++; &#125; &#125; temp.stadus = cantor(temp.cur); int ans = bfs(temp); ans != -1 ? show(ans) : printf(&quot;-1&quot;); cout &lt;&lt; endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>康托展开</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[位运算]dfs+位运算解决N皇后问题]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13%2F</url>
    <content type="text"><![CDATA[在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。 你的任务是，对于给定的N，求出有多少种合法的放置方法。共有若干行，表示棋盘和皇后的数量；如果N=0，表示结束。 分析： 本篇文章重点介绍位运算解决N皇后的思想，并不是解决特定的问题。和普通算法一样，这是一个递归过程，程序一行一行地寻找可以放皇后的地方。过程带三个参数，row、ld和rd，分别表示在纵列和两个对角线方向的限制条件下这一行的哪些地方不能放。我们以6×6的棋盘为例，看看程序是怎么工作的。假设现在已经递归到第四层，前三层放的子已经标在左图上了。红色、蓝色和绿色的线分别表示三个方向上有冲突的位置，位于该行上的冲突位置就用row、ld和rd中的1来表示。把它们三个并起来，得到该行所有的禁位，取反后就得到所有可以放的位置。注意递归调用时三个参数的变化，每个参数都加上了一个禁位，但两个对角线方向的禁位对下一行的影响需要平移一位。最后，如果递归到某个时候发现row=111111了，说明六个皇后全放进去了，此时程序从第1行跳到第11行，找到的解的个数加一。 123456789101112131415161718192021#include&lt;stdio.h&gt; #include&lt;math.h&gt; int N, Count, res; void dfs(int row, int ld, int rd) &#123; if (row == res) &#123; Count++; return; &#125; for (int j = 1; j &lt;= res; j &lt;&lt;= 1) if (row != (row | j) &amp;&amp; ld != (ld | j) &amp;&amp; rd != (rd | j)) dfs(row | j, (ld | j) &lt;&lt; 1 &amp; res, (rd | j) &gt;&gt; 1); &#125; int main() &#123; while (~scanf(&quot;%d&quot;, &amp;N), N) &#123; Count = 0; res = pow(2, N) - 1; dfs(0, 0, 0); printf(&quot;%d\n&quot;, Count); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>DFS</tag>
        <tag>ACM/ICPC</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[位运算]位运算的4个简单应用]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13%20-%201%2F</url>
    <content type="text"><![CDATA[\1. 不用任何比较判断两个数中大的那个数 我们将两个数做差，得到另一个数，判断这个数的符号位就可以了。当然，不能直接使用判断语句，所以我们使用位运算来操作。 \2. 两个相同的数异或结果等于0。 就这道题而言，在运算过程中会产生一个中间值，即a与b的异或结果，a异或b再异或b就会等于a，如果第二次异或a就会等于b。 所以直接三个异或就可以搞定 \3. 整数的二进制中有多少个1 每次循环采用n&amp;=(n-1)，这样可以跳过二进制位是0的数。 \4. 数组中只有一个数出现了奇数次，其他数都出现偶数次，找出这个数 这道题还是使用了异或的性质，两个相同的数异或等于0，遍历一遍数组就可以得到出现奇数次的那个数。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言允许初始化列表中末尾出现多余的逗号]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-1%2F</url>
    <content type="text"><![CDATA[C语言允许初始化列表中出现多余的逗号，例如： 1int days[] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, &#125;; 为什么这种特性是有用的？ 123456789101112#include &lt;stdio.h&gt; int main(int argc,char** argv)&#123; enum qs&#123; Va = 5, Vb, Vc, &#125; s; printf(&quot;a=%d,b=%d,c=%d&quot;,Va,Vb,Vc); return 0; &#125; 像enum枚举中的条目有可能是根据其它资源来的，而程序员会制作代码生成工具来生成它，所以就允许enum中的多余逗号。像int i = 9,j = 0;这种用法完全可以拆成int i=9;int j=0;因此不会增加代码生成器的负担，所以不支持int i=9,j=0,; 像这种代码，如果用代码生成器去读资源然后写进去，那么每生成一行都需要在末尾加一个逗号来分隔。C允许最后一行有多余的逗号，那就可以不用单独去处理最后一行了，减轻了代码生成器的制作负担，同时因为不用自行删除最后一个逗号，代码生成器的编写也就更不容易出错了。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的遍历（根据后序遍历中序遍历推出层序遍历）]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%2F</url>
    <content type="text"><![CDATA[对于二叉树的遍历，分为深度优先遍历与广度优先遍历，广度优先遍历有时又称作层序遍历。而深度优先遍历又分为前序遍历，中序遍历和后序遍历。三者之间的区别主要在于根结点的遍历顺序。前序遍历的顺序是根结点-&gt;左子树-&gt;右子树，中序遍历顺序是左子树-&gt;根结点-&gt;右子树，后序遍历顺序是左子树-&gt;右子树-&gt;根结点。现在给出树的后序遍历与中序遍历，要求写出该树的层序遍历。以下是pat上的例题： 给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。 输入格式： 输入第一行给出一个正整数N（&lt;=30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。 输出格式： 在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例： 12372 3 1 5 7 6 41 2 3 4 5 6 7 输出样例： 14 1 6 3 5 7 2 分析： 树的后序遍历特点是最后一个遍历的永远是根结点，由样例很容易看到4即为该树的根结点。而中序遍历的特点是根结点的左边永远是根结点的左子树部分，右边永远是根结点的右子树部分。而树的每一个子树都可以作为新的根。因此二者结合起来很容易将整个树构建出来。以样例为例，首先可以从后序遍历确定4为根结点，然后对照着中序遍历找到4的中序位置为第4位，然后以4为界将树分为以左子树为根的树和以右子树为根的树。现在可以确定根的左子树与右子树的个数分别为m，n，而后序遍历先遍历左子树部分，因此可以确定左子树部分为第1~m位，右子树部分为m+1~m+n位，最后一位为根结点。而左子树部分最后一位即第n位为左子树部分的根即左子树，同理右子树也一样。由此我们只需建立一个树遍历的函数ergodic(int root, int start, int end, int index)即可。其中root为根结点，start与end为由该根结点所衍生出的所有子树的范围，index记录该树的位置。由后序遍历可知end即为根结点的位置，有start开始遍历中序，直到找到根结点在中序遍历中的位置i，在以i为界划分为（start，i-1）与（i+1，end）两部分，而root则为后序遍历中（start，end）中的end位置，即为root-end+i-1的位置。我们初始树的所有结点为-1，意味空值，因此最终搭建的树只需按顺序遍历所有有值部分即可。以下是代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;int&gt;post, in, level(100000, -1); int N; void ergodic(int root, int start, int end, int index) &#123; int i = start; if (start &gt; end) return; while (i &lt; end&amp;&amp;in[i] != post[root]) i++; level[index] = post[root]; //cout &lt;&lt; root &lt;&lt; start &lt;&lt; end &lt;&lt; i &lt;&lt; endl; ergodic(root - 1 - end + i, start, i - 1, 2 * index + 1); ergodic(root - 1, i + 1, end, 2 * index + 2); &#125; int main() &#123; cin &gt;&gt; N; post.resize(N); in.resize(N); for (int i = 0; i &lt; N; i++) cin &gt;&gt; post[i]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; in[i]; ergodic(N - 1, 0, N - 1, 0); for (int i = 0, cnt = 0; i &lt; level.size(); i++) &#123; if (level[i] != -1) &#123; cout &lt;&lt; level[i]; cnt != N - 1 ? cout &lt;&lt; &apos; &apos; : cout &lt;&lt; endl; cnt++; &#125; &#125; return 0; &#125; 对于前序遍历也一样，因为前序遍历的特点和后序遍历的特点刚好相反，前序遍历第第一位总是根结点。根据两种遍历即可推出整棵树的结构，搭建完树的结构，任何遍历都会很方便。]]></content>
      <categories>
        <category>程序人生</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++八进制赋值与输入常见陷阱]]></title>
    <url>%2F2018%2F03%2F29%2F2018-03-29%20-%201%2F</url>
    <content type="text"><![CDATA[在C语言及C++中，一个整形数值前如果有一个数字0，则代表该整形数值为八进制数。例如int a，a = 010，则a的十进制数值为8，八进制数值为10。但是在输入a的时候，输入010，如果用scanf（“%d”，&amp;a），则将会被当做十进制10识别。而在c++中使用cout&lt;&lt;a时，也将会被默认为十进制输入。以下是测试用例。 12345678910#include&lt;iostream&gt; using namespace std; int main() &#123; int a = 010; cout &lt;&lt;&quot;将010赋给a时：a = &quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;请输入a:&quot;; cin &gt;&gt; a; cout &lt;&lt; &quot;将010输入给a时：a = &quot; &lt;&lt; a; return 0; &#125; 由此可知，cout默认是以十进制进行输入的。因此，我们在赋值与输入时，得格外注意进制之间的转换。例如： 12345678struct temp&#123; int a; int b; int c; &#125;temp_1 = &#123; 001, 010, 222 &#125;; 我们经常会在赋值时为了将数值对齐显得美观而在数值之前添加0，这样往往会导致得到的结果错误，因为系统将之默认为八进制赋值。]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>进制</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>进制</tag>
        <tag>C陷阱与缺陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数据结构]L2-022. 重排链表]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-3%2F</url>
    <content type="text"><![CDATA[L2-022. 重排链表给定一个单链表 L1→L2→…→Ln-1→Ln，请编写程序将链表重新排列为 Ln→L1→Ln-1→L2→…。例如：给定L为1→2→3→4→5→6，则输出应该为6→1→5→2→4→3。 输入格式： 每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址和结点总个数，即正整数N (&lt;= 105)。结点的地址是5位非负整数，NULL地址用-1表示。 接下来有N行，每行格式为： Address Data Next 其中Address是结点地址；Data是该结点保存的数据，为不超过105的正整数；Next是下一结点的地址。题目保证给出的链表上至少有两个结点。 输出格式： 对每个测试用例，顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 输入样例： 123456700100 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 输出样例： 12345668237 6 0010000100 1 9999999999 5 1230912309 2 0000000000 4 3321833218 3 -1 分析： 一道数据结构链表题。由于每一次输出链表两边的元素，因此可以构建一个双向链表。即结构体中储存上一个元素pre，数据data，下一个元素next。然后设置一个根结点root和尾结点tail，分别指向第一个结点地址和最后一个结点地址。先输出tail，tail指向对应上一个元素pre。再输出root，root指向对应下一个元素next，以此循环。直到tail与root相遇时输出tail，终止循环。输出tail对应数据时，可以输出tail，data，root，输出root对应数据时，可以输出root，data，tail。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt; #define Maxn 100000 using namespace std; struct Lists &#123; int pre; int data; int next; Lists() &#123; pre = -1; data = 0; next = -1; &#125; &#125;List[Maxn]; int main() &#123; int root, N, tail; scanf(&quot;%d%d&quot;, &amp;root, &amp;N); for (int i = 0; i &lt; N; i++) &#123; int temp; scanf(&quot;%d&quot;, &amp;temp); scanf(&quot;%d%d&quot;, &amp;List[temp].data, &amp;List[temp].next); if (List[temp].next != -1) List[List[temp].next].pre = temp; else tail = temp; &#125; int flag = 0; while (root != tail) &#123; printf(&quot;%05d %d %05d\n&quot;, tail, List[tail].data, root); tail = List[tail].pre; if (root == tail) break; printf(&quot;%05d %d %05d\n&quot;, root, List[root].data, tail); root = List[root].next; &#125; printf(&quot;%05d %d -1\n&quot;, root, List[root].data); return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>pat天梯赛</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[并查集]L2-024. 部落]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-2%2F</url>
    <content type="text"><![CDATA[L2-024. 部落时间限制 120 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 在一个社区里，每个人都有自己的小圈子，还可能同时属于很多不同的朋友圈。我们认为朋友的朋友都算在一个部落里，于是要请你统计一下，在一个给定社区中，到底有多少个互不相交的部落？并且检查任意两个人是否属于同一个部落。 输入格式： 输入在第一行给出一个正整数N（&lt;= 104），是已知小圈子的个数。随后N行，每行按下列格式给出一个小圈子里的人： K P[1] P[2] … P[K] 其中K是小圈子里的人数，P[i]（i=1, .., K）是小圈子里每个人的编号。这里所有人的编号从1开始连续编号，最大编号不会超过104。 之后一行给出一个非负整数Q（&lt;= 104），是查询次数。随后Q行，每行给出一对被查询的人的编号。 输出格式： 首先在一行中输出这个社区的总人数、以及互不相交的部落的个数。随后对每一次查询，如果他们属于同一个部落，则在一行中输出“Y”，否则输出“N”。 输入样例： 1234567843 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 输出样例： 12310 2YN 分析： 本题又是一道并查集。我的做法是用映射，将所有人映射到对应的圈子中。例如第i个圈子共有k个人，分别为k1…kj…kk。则map[kj]=i。倘若kj已经有对应的圈子，那将两个圈子联系起来。即Union（map[kj]，i）。此外设置计数器sum，每一次执行完map[kj]=i之后sum++，即未重复的人加一。最后计算每一个圈子i是否等于pre[i]，计算独立圈子的个数。判断两个人是否是一个部落，只需查询他们映射的圈子是否相同，即root(map[a])是否等于root(map[b])。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt; #include&lt;cstdio&gt; #define MAXN 10005 using namespace std; int N, k; int pre[MAXN]; int maps[MAXN]; int root(int x) &#123; while (x != pre[x]) &#123; pre[x] = pre[pre[x]]; x = pre[x]; &#125; return x; &#125; void Union(int px,int py) &#123; px = root(px); py = root(py); if (px != py) pre[py] = px; &#125; int main() &#123; cin &gt;&gt; N; int sum = 0; for (int i = 0; i &lt; MAXN; i++) &#123; pre[i] = i; maps[i] = 0; &#125; for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; k; while (k--) &#123; int temp; cin &gt;&gt; temp; if (!maps[temp]) &#123; maps[temp] = i; sum++; &#125; else Union(maps[temp], i); &#125; &#125; int count = 0; for (int i = 1; i &lt;= N; i++) if (pre[i] == i) count++; printf(&quot;%d %d\n&quot;, sum, count); cin &gt;&gt; k; while (k--) &#123; int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; if (root(maps[xx]) == root(maps[yy])) printf(&quot;Y\n&quot;); else printf(&quot;N\n&quot;); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++结构体内部初始化]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-1%2F</url>
    <content type="text"><![CDATA[我都知道，c语言中结构体内部是不支持初始化的。如果要初始化结构体，可以在声明变量时进行初始化。例如： 123456struct Test&#123; int a; char b; double c; &#125;; Test test_1 = &#123; 1, &apos;a&apos;, 0 &#125;; 然而c++中结构体内部在声明变量的同时可以声明函数，这为结构体内部初始化提供了很大的便利。 因此上面用例可以写成： 12345678910struct Test&#123; int a; char b; double c; Test()&#123; a = 1; b = &apos;a&apos;; c = 0; &#125; &#125;; 这为定义结构体时关于初始化问题提供了很大的便利。 以下是代码及运行结果： 12345678910111213141516#include&lt;iostream&gt; using namespace std; struct Test &#123; int a; char b; double c; Test() &#123; a = 1; b = &apos;a&apos;; c = 0; &#125; &#125;Text_1; int main() &#123; cout &lt;&lt; Text_1.a &lt;&lt; endl &lt;&lt; Text_1.b &lt;&lt; endl &lt;&lt; Text_1.c; return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>结构体</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[模拟]来一瓶82年拉菲（酒杯问题）]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28%2F</url>
    <content type="text"><![CDATA[问题描述： 悠神最近过生日，朋友纷纷来贺。现有一瓶82年拉菲与若干酒杯。酒杯呈三角形酒塔摆放，即每一个酒杯摆放在下一层两个酒杯中间，最下面一层酒杯摆放在桌面上。共有N(1&lt;=N&lt;=20)层酒杯，第k层共有k个酒杯。悠神将拉菲倒进第一层的酒杯中，速度为1杯/s，倒满后酒会向左右两个方向溢出，假设会全部溢出到这个酒杯下面相邻的两个酒杯中。然而悠神有洁癖，他不喜欢浪费，更不喜欢浸湿他心爱的桌布，所以请你计算一下第几秒之后桌布会被浸湿。 eg：如图所示为3层时的情况。第一层倒满需要1s，第二次倒满需要2s，第三层首次倒满需要2s。所以共需1+2+2=5s。 输入： 输入N(1&lt;=N&lt;=20)。 输出： 桌布浸湿时至少所需时间（取整数）。 输入样例： 2 输出样例： 3 分析： 桌布浸湿只与最下层最中间位置何时倒满有关，因此只需计算最下层中间位置酒杯的状态。由于时间取整，所以只需模拟出第一杯共倒了多少杯酒，即为多少s。而每一个酒杯共倒了多少酒与上一层相邻两个酒杯相关，及第i层第j个酒杯的酒只与第i-1层第j-1个和第j个酒杯的酒相关。及wine[i][j]=wine[i-1][j-1]+wine[i-1][j];由于酒杯有两种状态，及未满状态和倒满状态，所以要判断wine[i-1]层的酒是否&gt;1。 12345678910111213141516171819202122#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define MAXN 20 int main() &#123; int N; while (~scanf(&quot;%d&quot;, &amp;N)) &#123; double wine[MAXN + 1][MAXN + 1] = &#123; 0 &#125;; double temp = 0; while (wine[N][N / 2 + 1] &lt; 1) &#123; memset(wine, 0, sizeof(wine)); temp++; wine[1][1] = temp; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; wine[i][j] += (wine[i - 1][j - 1] &gt; 1 ? (wine[i - 1][j - 1] - 1) / 2.0 : 0) + (wine[i - 1][j] &gt; 1 ? (wine[i - 1][j] - 1) / 2.0 : 0); &#125; &#125; &#125; printf(&quot;%g\n&quot;, wine[1][1]); &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>模拟</tag>
        <tag>ACM/ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BFS]愿天下有情人都是失散多年的兄妹]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26-2%2F</url>
    <content type="text"><![CDATA[题目概述：L2-016. 愿天下有情人都是失散多年的兄妹时间限制 200 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 陈越 呵呵。大家都知道五服以内不得通婚，即两个人最近的共同祖先如果在五代以内（即本人、父母、祖父母、曾祖父母、高祖父母）则不可通婚。本题就请你帮助一对有情人判断一下，他们究竟是否可以成婚？ 输入格式： 输入第一行给出一个正整数N（2 &lt;= N &lt;= 104），随后N行，每行按以下格式给出一个人的信息： 本人ID 性别 父亲ID 母亲ID 其中ID是5位数字，每人不同；性别M代表男性、F代表女性。如果某人的父亲或母亲已经不可考，则相应的ID位置上标记为-1。 接下来给出一个正整数K，随后K行，每行给出一对有情人的ID，其间以空格分隔。 注意：题目保证两个人是同辈，每人只有一个性别，并且血缘关系网中没有乱伦或隔辈成婚的情况。 输出格式： 对每一对有情人，判断他们的关系是否可以通婚：如果两人是同性，输出“Never Mind”；如果是异性并且关系出了五服，输出“Yes”；如果异性关系未出五服，输出“No”。 输入样例： 12345678910111213141516171819202122232425262728293031323334352400001 M 01111 -100002 F 02222 0333300003 M 02222 0333300004 F 04444 0333300005 M 04444 0555500006 F 04444 0555500007 F 06666 0777700008 M 06666 0777700009 M 00001 0000200010 M 00003 0000600011 F 00005 0000700012 F 00008 0888800013 F 00009 0001100014 M 00010 0999900015 M 00010 0999900016 M 10000 0001200017 F -1 0001200018 F 11000 0001300019 F 11100 0001800020 F 00015 1111000021 M 11100 0002000022 M 00016 -100023 M 10012 0001700024 M 00022 10013900021 0002400019 0002400011 0001200022 0001800001 0000400013 0001600017 0001500019 0002100010 00011 输出样例： 123456789Never MindYesNever MindNoYesNoYesNoNo 1分析： 利用广度优先搜索，将每个人及双亲放入集合mab中，假如集合长度为改变，则说明mab中已存在这个人，则证明双方是近亲。visit用来记录层数。五层时结束搜索。 AC代码BFS： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define MAXN 100005 using namespace std; struct inf &#123; int fa; int ma; char sex; &#125;; inf node[MAXN]; int visit[MAXN]; bool flag[MAXN]; int N; bool BFS(int x1,int x2) &#123; memset(visit, 0, sizeof(visit)); queue&lt;int&gt;family; set&lt;int&gt;mab; family.push(x1); family.push(x2); visit[x1] = 1; visit[x2] = 1; while (!family.empty()) &#123; int top = family.front(); family.pop(); int size = mab.size(); mab.insert(top); if (mab.size() == size) &#123; return true; break; &#125; if (visit[top] &lt;= 4) &#123; if (node[top].fa) &#123; family.push(node[top].fa); visit[node[top].fa] += visit[top] + 1; &#125; if (node[top].ma) &#123; family.push(node[top].ma); visit[node[top].ma] += visit[top] + 1; &#125; &#125; &#125; return false; &#125; int main() &#123; cin &gt;&gt; N; memset(node, 0, sizeof(node)); memset(flag, 0, sizeof(flag)); while (N--) &#123; int id, fa, ma; char ch[2]; scanf(&quot;%d%s%d%d&quot;, &amp;id, ch, &amp;fa, &amp;ma); node[id].sex = ch[0]; flag[id] = true; if (fa != -1) &#123; node[id].fa = fa; node[fa].sex = &apos;M&apos;; flag[fa] = true; &#125; if (ma != -1) &#123; node[id].ma = ma; node[ma].sex = &apos;F&apos;; flag[ma] = true; &#125; &#125; cin &gt;&gt; N; while (N--) &#123; int per1, per2; cin &gt;&gt; per1 &gt;&gt; per2; if (node[per1].sex == node[per2].sex) printf(&quot;Never Mind\n&quot;); else &#123; if (BFS(per1, per2)) printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>pat天梯赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector的嵌套实现二维数组，解决矩阵相乘问题]]></title>
    <url>%2F2018%2F03%2F26%2F2018-03-26%2F</url>
    <content type="text"><![CDATA[定义vector的元素可以是一个vector。比如， vector&lt;vector&gt; 即表示一个二维int数组，里层的vector表示第一维， 外层的vector表示第二维。 例题描述：L1-048. 矩阵A乘以B时间限制 400 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 给定两个矩阵A和B，要求你计算它们的乘积矩阵AB。需要注意的是，只有规模匹配的矩阵才可以相乘。即若A有Ra行、Ca列，B有Rb行、Cb列，则只有Ca与Rb相等时，两个矩阵才能相乘。 输入格式： 输入先后给出两个矩阵A和B。对于每个矩阵，首先在一行中给出其行数R和列数C，随后R行，每行给出C个整数，以1个空格分隔，且行首尾没有多余的空格。输入保证两个矩阵的R和C都是正数，并且所有整数的绝对值不超过100。 输出格式： 若输入的两个矩阵的规模是匹配的，则按照输入的格式输出乘积矩阵AB，否则输出“Error: Ca != Rb”，其中Ca是A的列数，Rb是B的行数。 输入样例1： 12345672 31 2 34 5 63 47 8 9 0-1 -2 -3 -45 6 7 8 输出样例1： 1232 420 22 24 1653 58 63 28 输入样例2： 123456783 238 2643 -50 173 2-11 5799 6881 72 输出样例2： 1Error: 2 != 3 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int M1, N1, M2, N2; int main() &#123; cin &gt;&gt; M1 &gt;&gt; N1; vector&lt;int&gt;alie(N1); vector&lt;vector&lt;int&gt;&gt;ahang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N1; j++) &#123; scanf(&quot;%d&quot;, &amp;alie[j]); &#125; ahang[i] = alie; &#125; cin &gt;&gt; M2 &gt;&gt; N2; vector&lt;int&gt;blie(N2); vector&lt;vector&lt;int&gt;&gt;bhang(M2); for (int i = 0; i &lt; M2; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; scanf(&quot;%d&quot;, &amp;blie[j]); &#125; bhang[i] = blie; &#125; if (N1 != M2) printf(&quot;Error: %d != %d\n&quot;, N1, M2); else &#123; vector&lt;int&gt;anslie(N2); vector&lt;vector&lt;int&gt;&gt;anshang(M1); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2; j++) &#123; anslie[j] = 0; for (int k = 0; k &lt; N1; k++) anslie[j] += ahang[i][k] * bhang[k][j]; &#125; anshang[i] = anslie; &#125; printf(&quot;%d %d\n&quot;, M1, N2); for (int i = 0; i &lt; M1; i++) &#123; for (int j = 0; j &lt; N2 - 1; j++) printf(&quot;%d &quot;, anshang[i][j]); printf(&quot;%d\n&quot;, anshang[i][N2 - 1]); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>训练之路</category>
        <category>算法</category>
        <category>stl</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>stl</tag>
        <tag>算法</tag>
        <tag>pat天梯赛</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS与DFS的用途与选择]]></title>
    <url>%2F2018%2F02%2F01%2F2018-02-01%2F</url>
    <content type="text"><![CDATA[1.BFS是用来搜索最短径路的解是比较合适的，比如求最少步数的解，最少交换次数的解，因为BFS搜索过程中遇到的解一定是离根最近的，所以遇到一个解，一定就是最优解，此时搜索算法可以终止。这个时候不适宜使用DFS，因为DFS搜索到的解不一定是离根最近的，只有全局搜索完毕，才能从所有解中找出离根的最近的解。（当然这个DFS的不足，可以使用迭代加深搜索ID-DFS去弥补）2.空间优劣上，DFS是有优势的，DFS不需要保存搜索过程中的状态，而BFS在搜索过程中需要保存搜索过的状态，而且一般情况需要一个队列来记录。3.DFS适合搜索全部的解，因为要搜索全部的解，那么BFS搜索过程中，遇到离根最近的解，并没有什么用，也必须遍历完整棵搜索树，DFS搜索也会搜索全部，但是相比DFS不用记录过多信息，所以搜素全部解的问题，DFS显然更加合适。]]></content>
      <categories>
        <category>程序人生</category>
        <category>算法</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类的3种继承方式]]></title>
    <url>%2F2018%2F01%2F24%2F2018-01-24%2F</url>
    <content type="text"><![CDATA[简单地说下C++类的3种继承方式，分别是public继承，protected继承，private继承。 最常用的还是public继承。class默认的是private继承，它的member如果没写权限也是默认 private。struct则相反，默认的是public继承。结合下面的图示和代码，对C++的继承就有了 比较清晰的认识了。 继承之后，derived class 继承过后的member的属性就是图中所示。 代码主要从： 1.基类成员对其对象的可见性： 基类成员对派生类的可见性： 基类成员对派生类对象的可见性： 这3个方面谈的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt; class base&#123; public: base()&#123; a = 0; b = 1; c = 2; &#125; int a; protected: int b; private: int c; &#125;; class derived1 : public base&#123;//public继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived2 : protected base&#123;//protected继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived3 : private base&#123;//private继承 public: void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b&lt;&lt;std::endl; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; class derived4 : public derived3&#123;//base的member不能被private继承的派生类的子类访问 public: void fun()&#123; // std::cout&lt;&lt;a; &#125; &#125;; class derived5 : base&#123;//默认private继承 void fun()&#123;//derived class可以访问public和protected member std::cout&lt;&lt;base::a&lt;&lt;base::b; // std::cout&lt;&lt;base::c;//不能访问 &#125; &#125;; int main(void) &#123; base b1; derived1 d1; derived2 d2; derived3 d3; d1.fun(); d2.fun(); d3.fun(); std::cout&lt;&lt;b1.a;//base class Object只能访问public member std::cout&lt;&lt;d1.a;//public继承时 derived class Object只能访问base class的public member //std::cout&lt;&lt;d1.b&lt;&lt;d1.c;//不能访问 //std::cout&lt;&lt;d2.a&lt;&lt;d2.b;//protected继承时 derived class Object不能问访base class的member //std::cout&lt;&lt;d3.a;//private继承时 derived class Object不能问访base class的member return 0; &#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>继承</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sstream和strstream的用法]]></title>
    <url>%2F2018%2F01%2F24%2F2018-01-24%20-%201%2F</url>
    <content type="text"><![CDATA[在C++有两种字符串流,也称为数组I/O流，一种在 strstream 中定义，另一种在 sstream 中定义。它们实现的东西基本一样。strstream里包含： 1234class strstreambuf;class istrstream;class ostrstream;class strstream; 它们是基于C类型字符串char*编写的 sstream中包含： 1234class stringbuf;class istringstream;class ostringstream;class stringstream; 它们是基于std::string编写的 因此ostrstream::str()返回的是char*类型的字符串而ostringstream::str()返回的是std::string类型的字符串在使用的时候要注意到二者的区别，一般情况下推荐使用std::string类型的字符串当然如果为了保持和C的兼容，使用strstream也是不错的选择。但要记住一点,strstream虽仍然是C++语言标准的一部分,但已被C++标准宣称为“deprecated”，也就是不再提倡使用了，也说不定以后干粹就没了。 先介绍一下sstream 123456789//strigstream流以空格为边界符,使用其须包含sstream头文件//istringstream 用法istringstream istring;string ss(&quot;ss 8346520&quot;);istring.str(ss);int i=0;string s;istring&gt;&gt;s&gt;&gt;i;cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; 或者 12345istringstream istring(&quot;ss 8346520&quot;);int i=0;string s;istring&gt;&gt;s&gt;&gt;i;cout&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; 都将打印：s内容是ss,i内容是8346520的结果; 1234567891011//ostringstream 用法string s=&quot;test&quot;;int i=8346520;int j=0;string s1;ostringstream ostring; //不能写成ostringstream ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;ostring&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;i;cout&lt;&lt;ostring.str()&lt;&lt;endl; //ostring流内保存内容是test 8346520istringstream istring(ostring.str());istring&gt;&gt;s1&gt;&gt;j;//要注意此处的顺序;cout&lt;&lt;s1&lt;&lt;&quot;――――&quot;&lt;&lt;j&lt;&lt;endl; 简单说说strstream:基于数组的类有istrstream、ostrstream和strstream。它们分别用来创建输入、输出和输入／输出流。这些类的基类之一是strstreambuf，它定义了派生类使用的几个底层的具体属性。除了strstreambuf以外，istream也是istrstream的基类。类ostrstream包括了类ostream。strstream也包括了类iostream。所以，所有基于数组的类和“普通”I／O类一样存取相同的成员函数。创建基于数组的输出流要将一个输出流和一个数组关联起来，可使用下列ostream的构造函数：ostrstream ostr（char＊buf，int size，int mode＝ios：：out）；其中，buf是指向数组的指针，该数组接收写入流的字符。数组的长度由参数size确定。缺省时，流以输出方式打开，但也可以将几项或在一起复合为所需的方式（例如，可以包含ios：：app使输出添加在数组中已存在的信息的尾部）。mode的缺省值可以满足大多数的要求。一旦打开了一个基于数组的输出流，所有对这个流的输出就放在数组中。但是，任何输出都不能写到数组的限界之外，任何这种企图都会导致错误。 下面是一个介绍基于数组的输出流的简单程序。 12345678910111213141516#include &lt;iostream&gt;#include &lt;strstream&gt;using namespace std;int main()&#123;int arraysize=50;char *pbuffer=new char[arraysize];ostrstream ostr(pbuffer,arraysize,ios::out);ostr&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot; &quot;;ostr&lt;&lt;99-14&lt;&lt;hex&lt;&lt;&quot; &quot;;ostr.setf(ios::showbase);ostr&lt;&lt;100&lt;&lt;ends; //使用ostrstream输出到流对象的时候,要用ends结束字符串cout&lt;&lt;pbuffer;delete[] pbuffer;return 0;&#125; 使用数组作输入:要将输入流和数组关联起来，可使用下列istrstream的构造函数： 1istrstream istr（char*buf）； 其中，buf是指向数组的指针，该数组作为每次向流输入的字符源。buf所指的数组必须以空结束。空结束符从不从数组中读取。 下面是一个用字符串输入的例子: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;strstream&gt;using namespace std;int main()&#123;const char s[]=&quot;10 Hello 15 12.23 done&quot;;istrstream ins(s);int i;char str[80];float f;//reading： 10 Helloins &gt;&gt;i;ins &gt;&gt;str;cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;str&lt;&lt;endl;// reading：f 12.23 done.ins&gt;&gt;i;ins&gt;&gt;f;ins&gt;&gt;str;cout&lt;&lt;hex&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;str;return 0;&#125;]]></content>
      <categories>
        <category>程序人生</category>
        <category>C/C++</category>
        <category>流</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>C/C++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式练习题集(附答案)]]></title>
    <url>%2F2018%2F01%2F21%2F2018-01-21%2F</url>
    <content type="text"><![CDATA[前言​ 好久到没有去写关于正则表达式的总结了，虽然自己写了一些关于正则表达式的东西。但是 ​ 感觉上对正则表达式还停留在网上查找的阶段，对于大部分的人来说，很难写自己的正则表达式 ​ 对于正则表达式笔者也做过相关的总结。呃，过了一段时间还是模糊了。因此找一些练习题来找 ​ 回自己的记忆。 ​ 需要说明的是这些练习题有的是网上的！ 初级练习​ 1、求非负整数 : ^\d+$ ​ Tips:需要注意的是这个匹配模式为多行模式下进行的 ​ ​ 2、匹配正整数： ^[1-9][1-9][0-9]$ 在网上也有这种写法的 ^[0-9][1-9][0-9]$ ​ 这里截图我也不贴了，前者指能匹配123012这种整数，而后者可以匹配001230。 ​ 取舍就看实际的需要了 ​ 3、非正整数：^(-\d+|(0+))$ ​ 4、负整数：^-[0-9][1-9][0-9]$ ​ 5、整数 ：^-?\d+$ ​ 6、非负浮点数 ：^\d+(.\d+)?$ ​ 7、正浮点数 ：^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ ​ 8、非正浮点数 ：^((-\d+(.\d+)?)|(0+(.0+)?))$ ​ 9、负浮点数：^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ ​ 10、浮点数：^(-?\d+)(.\d+)?$ ​ 11、有数字、26个英文字母组成的字符串：^[A-Za-z0-9]+$ 中级练习​ 1、长度为8-10的用户密码（以字母开头、数字、下划线） ​ ^[a-zA-Z]\w{7,10}$ ​ 2、验证输入只能是汉字 ： ^[\u4e00-\u9fa5]{0,}$ ​ 3、电子邮箱验证：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ ​ 4、URL地址验证：^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$ ​ 5、电话号码的验证：请参考：http://blog.csdn.net/kiritor/article/details/8733469 ​ 6、简单的身份证号验证：\d{15}|\d{18}$ ​ ………………………… 高级练习​ 1、提取并捕获html标签内容： ​ &lt;a(?: [^&gt;])+href=([^ &gt;])(?: [^&gt;])&gt; ​ ​ &lt;OPTION\s.*?&gt; ​]]></content>
      <categories>
        <category>程序人生</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
