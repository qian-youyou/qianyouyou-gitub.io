<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">
  <script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://qianyouyou.cn"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "28d5c19f"
    });
  daovoice('update');
  </script>















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=5.2.0" color="#222">





  <meta name="keywords" content="算法,数据结构,图论,数论,动态规划," />





  <link rel="alternate" href="/atom.xml" title="浅悠悠的个人博客" type="application/atom+xml" />






<meta name="description" content="标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，莫队，LCA，Trie树，BM，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Din">
<meta name="keywords" content="算法,数据结构,图论,数论,动态规划">
<meta property="og:type" content="article">
<meta property="og:title" content="ACM算法专用模板(持续更新中)">
<meta property="og:url" content="http://qianyouyou.cn/2018/10/05/2018-10-05/index.html">
<meta property="og:site_name" content="浅悠悠的个人博客">
<meta property="og:description" content="标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，莫队，LCA，Trie树，BM，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Din">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-10T15:30:09.601Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ACM算法专用模板(持续更新中)">
<meta name="twitter:description" content="标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，莫队，LCA，Trie树，BM，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Din">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.2.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qianyouyou.cn/2018/10/05/2018-10-05/"/>





  <title>ACM算法专用模板(持续更新中) | 浅悠悠的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

<a href="https://github.com/qian-youyou" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>   
	<header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">浅悠悠的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">When there is no sunshine,talking to the moon.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-notes">
          <a href="/notes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            随笔
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qianyouyou.cn/2018/10/05/2018-10-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王骏">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅悠悠的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ACM算法专用模板(持续更新中)</h1>
        

        <div class="post-meta">
		  
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-05T14:16:34+08:00">
                2018-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序人生/" itemprop="url" rel="index">
                    <span itemprop="name">程序人生</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序人生/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 热度
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>℃
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  25,979
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  151
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>标签：位运算，gcd，exgcd，欧拉筛，快速乘，矩阵快速幂，中国剩余定理，欧拉函数，逆元，高斯消元，生成函数，斯特林数，卡特兰数，SG函数与Nim博弈，奇异函数与威佐夫博弈，并查集，ST，线段树，主席树，树状数组，莫队，LCA，Trie树，BM，KMP，AC自动机，后缀自动机，匈牙利算法，KM算法，Floyd，dijkstra，dijkstra+heap优化，SPFA及LLL与SLF优化，Dinic，MCMF，Kruscal，Prim等等</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fa[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i = 0; i &lt; maxn; i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x==fa[x] ? x : x=root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void Union(int px, int py)&#123;</span><br><span class="line">    px = root(px);</span><br><span class="line">    py = root(py);</span><br><span class="line">    if(px != py)&#123;</span><br><span class="line">        fa[py] = px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集路径压缩按雉合并"><a href="#并查集路径压缩按雉合并" class="headerlink" title="并查集路径压缩按雉合并"></a>并查集路径压缩按雉合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int fa[maxn],r[maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">        r[i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int x)&#123;</span><br><span class="line">    return x==fa[x]?x:Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t1=Find(x),t2=Find(y);</span><br><span class="line">    if(t1==t2) return ;//已合并返回</span><br><span class="line">    if(r[t1]&gt;r[t2]) fa[t2]=t1;  //把y的祖先t2和并到x的祖先t1上。因以t1为根的树更高</span><br><span class="line">    else &#123;</span><br><span class="line">        fa[t1]=t2;</span><br><span class="line">        if(r[t1]==r[t2]) r[t2]++; //若两树一样高，那么合并后，高度加一。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int sum[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    init();</span><br><span class="line">    memset(sum,0,sizeof(sum));</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int flag,x,y,z;</span><br><span class="line">        cin&gt;&gt;flag;</span><br><span class="line">        if(flag==1)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            int cnt=0;</span><br><span class="line">            for(int j=y+1;j&lt;=z;j++)&#123;</span><br><span class="line">                Merge(j,j-1);</span><br><span class="line">                cnt+=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            Merge(x,y);</span><br><span class="line">            cnt+=a[y];</span><br><span class="line">            sum[fa[x]]+=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            sum[fa[x]]=sum[fa[x]]-a[x]+y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int minn=0x3f3f3f3f;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(fa[i]==i)&#123;</span><br><span class="line">            minn=min(minn,sum[fa[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">int n,m,s[N],p[N],ans;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    ans=0;</span><br><span class="line">    memset(s,0,sizeof(s));</span><br><span class="line">    for(int i=0;i&lt;N;i++)</span><br><span class="line">        p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fd(int x) &#123; ///此时find不单有查找任务，还有更新距离任务</span><br><span class="line">    if(x==p[x]) return x;</span><br><span class="line">    int t=p[x];</span><br><span class="line">    p[x]=fd(p[x]);</span><br><span class="line">    s[x]+=s[t]; ///记录到根节点的距离，一定要有一个思想，根节点是一个区间的一个端点而不是一个区间，输入的区间被合并成了两个点</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Union(int a,int b,int num) &#123;</span><br><span class="line">    int x=fd(a),y=fd(b);</span><br><span class="line">    if(x==y) &#123;</span><br><span class="line">        if(s[b]!=s[a]+num) ans++;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        p[y]=x;</span><br><span class="line">        s[y]=s[a]+num-s[b]; ///y到x的距离等于a到x的距离+b到a的距离-b到y的距离</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        init();</span><br><span class="line">        for(int i=0;i&lt;m;i++) &#123;</span><br><span class="line">            int a,b,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            Union(a-1,b,c);</span><br><span class="line">            ///等价于Union(a,b+1,c);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">int a[maxn];</span><br><span class="line">int maxq[maxn];</span><br><span class="line">int minq[maxn];</span><br><span class="line">int q[maxn];</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        int head,tail,t;</span><br><span class="line">        memset(q,0,sizeof(q));</span><br><span class="line">        head=1,tail=1;</span><br><span class="line">        q[tail]=1;</span><br><span class="line">        minq[1]=a[1];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            while(head&lt;=tail&amp;&amp;a[i]&lt;a[q[tail]])</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">            if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1)</span><br><span class="line">                head++;</span><br><span class="line">            minq[i]=a[q[head]];</span><br><span class="line">        &#125;</span><br><span class="line">        memset(q,0,sizeof(q));</span><br><span class="line">        head=1,tail=1;</span><br><span class="line">        q[tail]=1;</span><br><span class="line">        maxq[1]=a[1];</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            while(head&lt;=tail&amp;&amp;a[i]&gt;a[q[tail]])</span><br><span class="line">                tail--;</span><br><span class="line">            q[++tail]=i;</span><br><span class="line">            if(head&lt;=tail&amp;&amp;q[head]&lt;i-k+1)</span><br><span class="line">                head++;</span><br><span class="line">            maxq[i]=a[q[head]];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=k;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;minq[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;minq[n]&lt;&lt;endl;</span><br><span class="line">        for(int i=k;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;maxq[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;maxq[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int head[maxn], cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u, w;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,i,num[100001],t[200001],l,r;//num:原数组；t：树状数组</span><br><span class="line">int lowbit(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line">void change(int x,int p)//将第x个数加p</span><br><span class="line">&#123;</span><br><span class="line">    while(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=p;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int k)//前k个数的和</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(k&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[k];</span><br><span class="line">        k-=lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int ask(int l,int r)//求l-r区间和</span><br><span class="line">&#123;</span><br><span class="line">    return sum(r)-sum(l-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        change(i,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt;ask(l,r)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAXN 100010</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r;//区间[l,r]</span><br><span class="line">    int add;//区间的延时标记</span><br><span class="line">    int sum;//区间和</span><br><span class="line">    int mx; //区间最大值</span><br><span class="line">    int mn; //区间最小值</span><br><span class="line">&#125;tree[MAXN&lt;&lt;2];//一定要开到4倍多的空间</span><br><span class="line"></span><br><span class="line">void pushup(int index)&#123;</span><br><span class="line">    tree[index].sum = tree[index&lt;&lt;1].sum+tree[index&lt;&lt;1|1].sum;</span><br><span class="line">    tree[index].mx = max(tree[index&lt;&lt;1].mx,tree[index&lt;&lt;1|1].mx);</span><br><span class="line">    tree[index].mn = min(tree[index&lt;&lt;1].mn,tree[index&lt;&lt;1|1].mn);</span><br><span class="line">&#125;</span><br><span class="line">void pushdown(int index)&#123;</span><br><span class="line">    //说明该区间之前更新过</span><br><span class="line">    //要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新</span><br><span class="line">    if(tree[index].add)&#123;</span><br><span class="line">        //替换原来的值</span><br><span class="line">        /*</span><br><span class="line">        tree[index&lt;&lt;1].sum = (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].sum = (tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mx = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mx = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mn = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mn = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].add = tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].add = tree[index].add;</span><br><span class="line">        tree[index].add = 0;*/</span><br><span class="line">        //在原来的值的基础上加上val</span><br><span class="line"></span><br><span class="line">        tree[index&lt;&lt;1].sum += (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].sum +=(tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mx += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mx += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].mn += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].mn += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1].add += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;1|1].add += tree[index].add;</span><br><span class="line">        tree[index].add = 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void build(int l,int r,int index)&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    tree[index].add = 0;//刚开始一定要清0</span><br><span class="line">    if(l == r)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;tree[index].sum);</span><br><span class="line">        tree[index].mn = tree[index].mx = tree[index].sum;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l+r)&gt;&gt;1;</span><br><span class="line">    build(l,mid,index&lt;&lt;1);</span><br><span class="line">    build(mid+1,r,index&lt;&lt;1|1);</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line">void updata(int l,int r,int index,int val)&#123;</span><br><span class="line">    if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123;</span><br><span class="line">        /*把原来的值替换成val,因为该区间有tree[index].r-tree[index].l+1</span><br><span class="line">        个数，所以区间和 以及 最值为：</span><br><span class="line">        */</span><br><span class="line">        /*tree[index].sum = (tree[index].r-tree[index].l+1)*val;</span><br><span class="line">        tree[index].mn = val;</span><br><span class="line">        tree[index].mx = val;</span><br><span class="line">        tree[index].add = val;//延时标记*/</span><br><span class="line">        //在原来的值的基础上加上val,因为该区间有tree[index].r-tree[index].l+1</span><br><span class="line">        //个数，所以区间和 以及 最值为：</span><br><span class="line">        tree[index].sum += (tree[index].r-tree[index].l+1)*val;</span><br><span class="line">        tree[index].mn += val;</span><br><span class="line">        tree[index].mx += val;</span><br><span class="line">        tree[index].add += val;//延时标记</span><br><span class="line"></span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    int mid = (tree[index].l+tree[index].r)&gt;&gt;1;</span><br><span class="line">    if(l &lt;= mid)&#123;</span><br><span class="line">        updata(l,r,index&lt;&lt;1,val);</span><br><span class="line">    &#125;</span><br><span class="line">    if(r &gt; mid)&#123;</span><br><span class="line">        updata(l,r,index&lt;&lt;1|1,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line">int query(int l,int r,int index)&#123;</span><br><span class="line">    if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123;</span><br><span class="line">        //return tree[index].sum;</span><br><span class="line">        return tree[index].mx;</span><br><span class="line">        //return tree[index].mn;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    int mid = (tree[index].l+tree[index].r)&gt;&gt;1;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    int Max = 0;</span><br><span class="line">    int Min = inf;</span><br><span class="line">    if(l &lt;= mid)&#123;</span><br><span class="line">        ans += query(l,r,index&lt;&lt;1);</span><br><span class="line">        Max = max(query(l,r,index&lt;&lt;1),Max);</span><br><span class="line">        Min = min(query(l,r,index&lt;&lt;1),Min);</span><br><span class="line">    &#125;</span><br><span class="line">    if(r &gt; mid)&#123;</span><br><span class="line">        ans += query(l,r,index&lt;&lt;1|1);</span><br><span class="line">        Max = max(query(l,r,index&lt;&lt;1|1),Max);</span><br><span class="line">        Min = min(query(l,r,index&lt;&lt;1|1),Min);</span><br><span class="line">    &#125;</span><br><span class="line">    //return ans;</span><br><span class="line">    return Max;</span><br><span class="line">    //return Min;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,q,x,y,z;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        build(1,n,1);</span><br><span class="line">        while(m--)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">            if(q == 1)&#123;</span><br><span class="line">                cout&lt;&lt;&quot;查询:(x,y)&quot;&lt;&lt;endl;</span><br><span class="line">                scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">                cout&lt;&lt;query(x,y,1)&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cout&lt;&lt;&quot;更新(x,y)为z：&quot;&lt;&lt;endl;</span><br><span class="line">                scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">                updata(x,y,1,z);</span><br><span class="line">                for(int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">                    printf(&quot;a[%d] = %d\n&quot;,i,query(i,i,1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">// luogu-judger-enable-o2</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100010],hash[101000],tot,root[201000],cnt,n,m,tt,qll[200100],qrr[20000];</span><br><span class="line">int q1,q2,id[201000],b[201000];</span><br><span class="line">struct TREE</span><br><span class="line">&#123;</span><br><span class="line">    int ln,rn,zhi;</span><br><span class="line">&#125;t[10010000];</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,k,flag;</span><br><span class="line">&#125;q[100100];</span><br><span class="line">int lowbit(int x) &#123;return (x)&amp;(-x);&#125;</span><br><span class="line">void gai(int &amp;node,int l,int r,int hs,int v)</span><br><span class="line">&#123;</span><br><span class="line">    if(!node) node=++tot;</span><br><span class="line">    t[node].zhi+=v;</span><br><span class="line">    if(l==r) return;</span><br><span class="line">    int mid=(l+r)/2;</span><br><span class="line">    if(hs&lt;=mid) gai(t[node].ln,l,mid,hs,v);</span><br><span class="line">    else gai(t[node].rn,mid+1,r,hs,v);</span><br><span class="line">&#125;</span><br><span class="line">void add(int p,int v)</span><br><span class="line">&#123;</span><br><span class="line">    hash[p]=lower_bound(a+1,a+1+tt,hash[p])-a;</span><br><span class="line">    //cout&lt;&lt;hash[p]&lt;&lt;endl;</span><br><span class="line">    for(int i=p;i&lt;=n;i+=lowbit(i)) gai(root[i],1,tt,hash[p],v);</span><br><span class="line">&#125;</span><br><span class="line">char s[2];</span><br><span class="line">int SUM()</span><br><span class="line">&#123;</span><br><span class="line">    int ans1=0,ans2=0;</span><br><span class="line">    for(int i=1;i&lt;=q1;i++) ans1+=t[t[qrr[i]].ln].zhi;</span><br><span class="line">    for(int i=1;i&lt;=q2;i++) ans2+=t[t[qll[i]].ln].zhi;</span><br><span class="line">    return ans1-ans2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int cha(int qr,int ql,int l,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">    q1=0,q2=0;</span><br><span class="line">    for(int i=qr;i&gt;=1;i-=lowbit(i)) qrr[++q1]=root[i];</span><br><span class="line">    for(int i=ql;i&gt;=1;i-=lowbit(i)) qll[++q2]=root[i];</span><br><span class="line">    while(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        int lsiz=SUM(),mid=(l+r)/2;</span><br><span class="line">        if(k&lt;=lsiz) </span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].ln;</span><br><span class="line">            for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].ln;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i=1;i&lt;=q1;i++) qrr[i]=t[qrr[i]].rn;</span><br><span class="line">            for(int i=1;i&lt;=q2;i++) qll[i]=t[qll[i]].rn;</span><br><span class="line">            l=mid+1;k-=lsiz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);b[i]=a[i];</span><br><span class="line">        hash[++cnt]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        if(s[0]==&apos;Q&apos;)</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k),q[i].flag=1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">            a[++cnt]=q[i].r;hash[cnt]=a[cnt];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+cnt);</span><br><span class="line">    tt=unique(a+1,a+1+cnt)-a-1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    add(i,1);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(q[i].flag==1)</span><br><span class="line">        printf(&quot;%d\n&quot;,a[cha(q[i].r,q[i].l-1,1,tt,q[i].k)]);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hash[q[i].l]=b[q[i].l];</span><br><span class="line">            add(q[i].l,-1);</span><br><span class="line">            hash[q[i].l]=q[i].r;</span><br><span class="line">            b[q[i].l]=q[i].r;</span><br><span class="line">            add(q[i].l,1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">char s[maxn];</span><br><span class="line">int n,m;</span><br><span class="line">bool p;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int count;</span><br><span class="line">    node * next[26];</span><br><span class="line">&#125;*root;</span><br><span class="line">node * build()</span><br><span class="line">&#123;</span><br><span class="line">    node * k=new(node);</span><br><span class="line">    k-&gt;count=0;</span><br><span class="line">    memset(k-&gt;next,0,sizeof(k-&gt;next));</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">    node * r=root;</span><br><span class="line">    char * word=s;</span><br><span class="line">     while(*word)</span><br><span class="line">    &#123;</span><br><span class="line">        int id=*word-&apos;a&apos;;</span><br><span class="line">        if(r-&gt;next[id]==NULL) r-&gt;next[id]=build();</span><br><span class="line">        r=r-&gt;next[id];</span><br><span class="line">        r-&gt;count++;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int search()</span><br><span class="line">&#123;</span><br><span class="line">    node * r=root;</span><br><span class="line">    char * word=s;</span><br><span class="line">    while(*word)</span><br><span class="line">    &#123;</span><br><span class="line">        int id=*word-&apos;a&apos;;</span><br><span class="line">        r=r-&gt;next[id];</span><br><span class="line">        if(r==NULL) return 0;</span><br><span class="line">        word++;</span><br><span class="line">    &#125;</span><br><span class="line">    return r-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[11];</span><br><span class="line">	int i,j;</span><br><span class="line">	root=(struct dictree*)malloc(sizeof(struct dictree));</span><br><span class="line">	for(i=0;i&lt;26;i++)</span><br><span class="line">	root-&gt;child[i]=0;</span><br><span class="line">	root-&gt;n=2;</span><br><span class="line">	while(gets(str),strcmp(str,&quot;&quot;)!=0)&#123;</span><br><span class="line">		insert(str);</span><br><span class="line">	&#125;</span><br><span class="line">	while(scanf(&quot;%s&quot;,str)!=EOF)&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;,find(str));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">                 An implementation of top-down splaying</span><br><span class="line">                     D. Sleator &lt;sleator@cs.cmu.edu&gt;</span><br><span class="line">                              March 1992</span><br><span class="line">  */</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">  int size;  /* number of nodes in the tree */</span><br><span class="line">            /* Not actually needed for any of the operations */</span><br><span class="line"> typedef struct tree_node Tree;</span><br><span class="line">  struct tree_node</span><br><span class="line"> &#123;</span><br><span class="line">     Tree * left, * right;</span><br><span class="line">     int item;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> Tree * splay (int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line">  /* Simple top down splay, not requiring i to be in the tree t.  */</span><br><span class="line">  /* What it does is described above.                             */</span><br><span class="line">     Tree N, *l, *r, *y;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">         return t;</span><br><span class="line">     N.left = N.right = NULL;</span><br><span class="line">     l = r = &amp;N;</span><br><span class="line">     for (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         if (i &lt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;left == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             if (i &lt; t-&gt;left-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;left;                           /* rotate right */</span><br><span class="line">                 t-&gt;left = y-&gt;right;</span><br><span class="line">                 y-&gt;right = t;</span><br><span class="line">                 t = y;</span><br><span class="line">                 if (t-&gt;left == NULL)</span><br><span class="line">                 &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             r-&gt;left = t;                               /* link right */</span><br><span class="line">             r = t;</span><br><span class="line">             t = t-&gt;left;</span><br><span class="line">         &#125;     </span><br><span class="line">         else if (i &gt; t-&gt;item)</span><br><span class="line">         &#123;    </span><br><span class="line">             if (t-&gt;right == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             if (i &gt; t-&gt;right-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;right;                          /* rotate left */</span><br><span class="line">                 t-&gt;right = y-&gt;left;</span><br><span class="line">                 y-&gt;left = t;</span><br><span class="line">                 t = y;</span><br><span class="line">                 if (t-&gt;right == NULL)</span><br><span class="line">                 &#123;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             l-&gt;right = t;                              /* link left */</span><br><span class="line">             l = t;</span><br><span class="line">             t = t-&gt;right;</span><br><span class="line">         &#125;     </span><br><span class="line">         else    </span><br><span class="line">         &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     l-&gt;right = t-&gt;left;                                /* assemble */</span><br><span class="line">     r-&gt;left = t-&gt;right;</span><br><span class="line">     t-&gt;left = N.right;</span><br><span class="line">     t-&gt;right = N.left;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br><span class="line">  /* Here is how sedgewick would have written this.                    */</span><br><span class="line"> /* It does the same thing.                                           */</span><br><span class="line"> Tree * sedgewickized_splay (int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line">     Tree N, *l, *r, *y;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         return t;</span><br><span class="line">     &#125;</span><br><span class="line">     N.left = N.right = NULL;</span><br><span class="line">     l = r = &amp;N;</span><br><span class="line">     for (;;)</span><br><span class="line">     &#123;</span><br><span class="line">         if (i &lt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;left != NULL &amp;&amp; i &lt; t-&gt;left-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;left;</span><br><span class="line">                 t-&gt;left = y-&gt;right;</span><br><span class="line">                 y-&gt;right = t;</span><br><span class="line">                 t = y;</span><br><span class="line">             &#125;</span><br><span class="line">             if (t-&gt;left == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             r-&gt;left = t;</span><br><span class="line">             r = t;</span><br><span class="line">             t = t-&gt;left;</span><br><span class="line">         &#125;</span><br><span class="line">         else if (i &gt; t-&gt;item)</span><br><span class="line">         &#123;</span><br><span class="line">             if (t-&gt;right != NULL &amp;&amp; i &gt; t-&gt;right-&gt;item)</span><br><span class="line">             &#123;</span><br><span class="line">                 y = t-&gt;right;</span><br><span class="line">                 t-&gt;right = y-&gt;left;</span><br><span class="line">                 y-&gt;left = t;</span><br><span class="line">                 t = y;</span><br><span class="line">             &#125;</span><br><span class="line">             if (t-&gt;right == NULL)</span><br><span class="line">             &#123;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             l-&gt;right = t;</span><br><span class="line">             l = t;</span><br><span class="line">             t = t-&gt;right;</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     l-&gt;right=t-&gt;left;</span><br><span class="line">     r-&gt;left=t-&gt;right;</span><br><span class="line">     t-&gt;left=N.right;</span><br><span class="line">     t-&gt;right=N.left;</span><br><span class="line">     return t;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Tree * insert(int i, Tree * t)</span><br><span class="line"> &#123;</span><br><span class="line"> /* Insert i into the tree t, unless it&apos;s already there.    */</span><br><span class="line"> /* Return a pointer to the resulting tree.                 */</span><br><span class="line">     Tree * new;</span><br><span class="line">     </span><br><span class="line">     new = (Tree *) malloc (sizeof (Tree));</span><br><span class="line">     if (new == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         printf(&quot;Ran out of space\n&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     new-&gt;item = i;</span><br><span class="line">     if (t == NULL)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;left = new-&gt;right = NULL;</span><br><span class="line">         size = 1;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     t = splay(i,t);</span><br><span class="line">     if (i &lt; t-&gt;item)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;left = t-&gt;left;</span><br><span class="line">         new-&gt;right = t;</span><br><span class="line">         t-&gt;left = NULL;</span><br><span class="line">         size ++;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     else if (i &gt; t-&gt;item)</span><br><span class="line">     &#123;</span><br><span class="line">         new-&gt;right = t-&gt;right;</span><br><span class="line">         new-&gt;left = t;</span><br><span class="line">         t-&gt;right = NULL;</span><br><span class="line">         size++;</span><br><span class="line">         return new;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         /* We get here if it&apos;s already in the tree */</span><br><span class="line">         /* Don&apos;t add it again                      */</span><br><span class="line">         free(new);</span><br><span class="line">         return t;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree * delete(int i, Tree * t)</span><br><span class="line">&#123;</span><br><span class="line">/* Deletes i from the tree if it&apos;s there.               */</span><br><span class="line">/* Return a pointer to the resulting tree.              */</span><br><span class="line">    Tree * x;</span><br><span class="line">    if (t==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    t = splay(i,t);</span><br><span class="line">    if (i == t-&gt;item)</span><br><span class="line">    &#123;               /* found it */</span><br><span class="line">        if (t-&gt;left == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            x = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            x = splay(i, t-&gt;left);</span><br><span class="line">            x-&gt;right = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        free(t);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;                         /* It wasn&apos;t there */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argv, char *argc[])</span><br><span class="line">&#123;</span><br><span class="line">/* A sample use of these functions.  Start with the empty tree,         */</span><br><span class="line">/* insert some stuff into it, and then delete it                        */</span><br><span class="line">    Tree * root;</span><br><span class="line">    int i;</span><br><span class="line">    root = NULL;              /* the empty tree */</span><br><span class="line">    size = 0;</span><br><span class="line">    for (i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = insert((541*i) &amp; (1023), root);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size = %d\n&quot;, size);</span><br><span class="line">    for (i = 0; i &lt; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        root = delete((541*i) &amp; (1023), root);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size = %d\n&quot;, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA-Tarjan"><a href="#LCA-Tarjan" class="headerlink" title="LCA(Tarjan)"></a>LCA(Tarjan)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e4 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, head[maxn], fa[maxn], head_2[maxn], cnt, cnt_2, sx;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">struct QUERY&#123;</span><br><span class="line">    int next, to, u, lca;</span><br><span class="line">&#125;query[maxn];</span><br><span class="line">void add_edge(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add_query(int u, int v)&#123;</span><br><span class="line">    query[cnt_2].next = head_2[u];</span><br><span class="line">    query[cnt_2].to = v;</span><br><span class="line">    query[cnt_2].u = u;</span><br><span class="line">    head_2[u] = cnt_2++;</span><br><span class="line">    query[cnt_2].next = head_2[v];</span><br><span class="line">    query[cnt_2].to = u;</span><br><span class="line">    query[cnt_2].u = v;</span><br><span class="line">    head_2[v] = cnt_2++;</span><br><span class="line">&#125;</span><br><span class="line">void init_edge()&#123;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void init_query()&#123;</span><br><span class="line">    memset(head_2, -1, sizeof(head_2));</span><br><span class="line">    cnt_2 = 0;</span><br><span class="line">&#125;</span><br><span class="line">int root(int x)&#123;</span><br><span class="line">    return x = x == fa[x] ? x : root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void tarjan(int x) &#123;</span><br><span class="line">    fa[x] = x;</span><br><span class="line">    for (int i = head[x]; i != -1; i = edge[i].next) &#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        tarjan(v);</span><br><span class="line">        fa[root(v)] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = true;</span><br><span class="line">    for (int i = head_2[x]; i != -1; i = query[i].next) &#123;</span><br><span class="line">        int v = query[i].to;</span><br><span class="line">        if (vis[v]) &#123;</span><br><span class="line">            query[i].lca = query[i^1].lca = root(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    for(int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add_edge(u, v);</span><br><span class="line">        vis[v] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i&lt;=n; i++)&#123;</span><br><span class="line">        if(!vis[i])&#123;</span><br><span class="line">            sx = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">    add_query(u, v);</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    tarjan(sx);</span><br><span class="line">    for(int i = 0; i &lt; cnt_2; i+=2)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, query[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init_edge();</span><br><span class="line">        init_query();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">1 14</span><br><span class="line">8 5</span><br><span class="line">10 16</span><br><span class="line">5 9</span><br><span class="line">4 6</span><br><span class="line">8 4</span><br><span class="line">4 10</span><br><span class="line">1 13</span><br><span class="line">6 15</span><br><span class="line">10 11</span><br><span class="line">6 7</span><br><span class="line">10 2</span><br><span class="line">16 3</span><br><span class="line">8 1</span><br><span class="line">16 12</span><br><span class="line">16 7</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">*/</span><br><span class="line">//4 3</span><br></pre></td></tr></table></figure>
<h2 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h2><h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int stmax[maxn][30];</span><br><span class="line">int stmin[maxn][30];</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">void rmq_st(int n)&#123;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        stmax[i][0]=stmin[i][0]=a[i];</span><br><span class="line">    int m=(int)(double(log(n))/log(2.0));</span><br><span class="line">    for(int j=1;j&lt;=m;j++)</span><br><span class="line">    for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++)&#123;</span><br><span class="line">        stmax[i][j]=max(stmax[i][j-1],stmax[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">        stmin[i][j]=min(stmin[i][j-1],stmin[i+(1&lt;&lt;j-1)][j-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rmq_query(int l,int r)&#123;</span><br><span class="line">    int k=(int)((double)log(r-l+1)/log(2.0));</span><br><span class="line">    cout&lt;&lt;&quot;Max is : &quot;&lt;&lt;max(stmax[l][k],stmax[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;Min is : &quot;&lt;&lt;min(stmin[l][k],stmin[r-(1&lt;&lt;k)+1][k])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    rmq_st(n);</span><br><span class="line">    int l,r;</span><br><span class="line">    while(cin&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">        rmq_query(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*	解释：</span><br><span class="line">		belong[x]x属于分块后的哪一块，Q[i]每个询问</span><br><span class="line">		modify(p,t)对p位置进行t修改，一般只有增加或者缩减这两种操作，具体问题具体分析</span><br><span class="line">	注意：</span><br><span class="line">		最后也可以不对询问id排序，直接保存到一个数组里面输出即可</span><br><span class="line">*/</span><br><span class="line">int a[nmax], belong[nmax];</span><br><span class="line">ll ans = 0;</span><br><span class="line">struct node &#123;int l, r, id;ll ans;&#125; Q[nmax];</span><br><span class="line">bool cmp(node a, node b) &#123;</span><br><span class="line">	if (belong[a.l] != belong[b.l]) return a.l &lt; b.l;</span><br><span class="line">	else return a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">bool cmpid(node a, node b) &#123;return a.id &lt; b.id;&#125;</span><br><span class="line">void modify(int pos, int tag) &#123;</span><br><span class="line">	// ......... 增删操作</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int sz = sqrt(n);</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;</span><br><span class="line">		belong[i] = (i - 1) / sz + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q + 1, Q + 1 + m, cmp);</span><br><span class="line">	int l = 1, r = 0;</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">		while (l &lt; Q[i].l) modify(l++, -1);</span><br><span class="line">		while (l &gt; Q[i].l) modify(--l, 1);</span><br><span class="line">		while (r &gt; Q[i].r) modify(r--, -1);</span><br><span class="line">		while (r &lt; Q[i].r) modify(++r, 1);</span><br><span class="line">		Q[i].ans = ans;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(Q + 1, Q + 1 + m, cmpid);</span><br><span class="line">	for (int i = 1; i &lt;= m; ++i) printf(&quot;%I64d\n&quot;, Q[i].ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=3e5+5;//区间范围</span><br><span class="line">const int MAX=1e6+5;//最大数字</span><br><span class="line">int unit,cnt[MAX],arr[N],res[N],ans=0;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">    int l,r,id;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">    return a.l/unit!=b.l/unit?a.l/unit&lt;b.l/unit:a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int pos)&#123;</span><br><span class="line">    cnt[arr[pos]]++;</span><br><span class="line">    if(cnt[arr[pos]]==1)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void remove(int pos)&#123;</span><br><span class="line">    cnt[arr[pos]]--;</span><br><span class="line">    if(cnt[arr[pos]]==0)&#123;</span><br><span class="line">        ans--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    unit=sqrt(n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span><br><span class="line">        q[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(q+1,q+m+1,cmp);</span><br><span class="line"></span><br><span class="line">    int L=q[1].l,R=L-1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        while(L&gt;q[i].l)</span><br><span class="line">            add(--L);</span><br><span class="line">        while(L&lt;q[i].l)</span><br><span class="line">            remove(L++);</span><br><span class="line">        while(R&gt;q[i].r)</span><br><span class="line">            remove(R--);</span><br><span class="line">        while(R&lt;q[i].r)</span><br><span class="line">            add(++R);</span><br><span class="line">        res[q[i].id]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//01背包 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//stellar myself！</span><br><span class="line">const int maxn=1000;</span><br><span class="line">int m[maxn][maxn];</span><br><span class="line">int w[maxn],v[maxn];</span><br><span class="line">int C,N;</span><br><span class="line">void add(int i,int j)&#123;</span><br><span class="line">    if (j&lt;w[i])</span><br><span class="line">        m[i][j]=m[i-1][j];</span><br><span class="line">    else</span><br><span class="line">        m[i][j]=max(m[i-1][j],m[i-1][j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=C;j++)&#123;</span><br><span class="line">            add(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int big=m[1][1];</span><br><span class="line">    for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=C;j++)&#123;</span><br><span class="line">            if (m[i][j]&gt;big) big=m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;big&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int MAXN = 1005;</span><br><span class="line"> </span><br><span class="line">int DP[MAXN][MAXN];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string a;</span><br><span class="line">	string b;</span><br><span class="line">	while(cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">	&#123;</span><br><span class="line">		int l1 = a.size();</span><br><span class="line">		int l2 = b.size();</span><br><span class="line">		memset(DP, 0, sizeof(DP)); </span><br><span class="line">		for(int i = 1; i &lt;= l1; i++)</span><br><span class="line">			for(int j = 1; j &lt;= l2; j++)</span><br><span class="line">				if(a[i - 1] == b[j - 1])</span><br><span class="line">					DP[i][j] = max(DP[i][j], DP[i - 1][j - 1] + 1);</span><br><span class="line">				else</span><br><span class="line">					DP[i][j] = max(DP[i][j - 1], DP[i - 1][j]);</span><br><span class="line">		printf(&quot;%d\n&quot;, DP[l1][l2]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="概率dp"><a href="#概率dp" class="headerlink" title="概率dp"></a>概率dp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">POJ 2096</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">POJ 2096</span><br><span class="line">概率DP</span><br><span class="line">writed by kuangbin</span><br><span class="line"></span><br><span class="line">dp求期望</span><br><span class="line">逆着递推求解</span><br><span class="line">题意：（题意看题目确实比较难道，n和s都要找半天才能找到）</span><br><span class="line">   一个软件有s个子系统，会产生n种bug</span><br><span class="line">   某人一天发现一个bug,这个bug属于一个子系统，属于一个分类</span><br><span class="line">   每个bug属于某个子系统的概率是1/s,属于某种分类的概率是1/n</span><br><span class="line">   问发现n种bug,每个子系统都发现bug的天数的期望。</span><br><span class="line"></span><br><span class="line">求解：</span><br><span class="line">         dp[i][j]表示已经找到i种bug,j个系统的bug，达到目标状态的天数的期望</span><br><span class="line">         dp[n][s]=0;要求的答案是dp[0][0];</span><br><span class="line">         dp[i][j]可以转化成以下四种状态:</span><br><span class="line">              dp[i][j],发现一个bug属于已经有的i个分类和j个系统。概率为(i/n)*(j/s);</span><br><span class="line">              dp[i][j+1],发现一个bug属于已有的分类，不属于已有的系统.概率为 (i/n)*(1-j/s);</span><br><span class="line">              dp[i+1][j],发现一个bug属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(j/s);</span><br><span class="line">              dp[i+1][j+1],发现一个bug不属于已有的系统，不属于已有的分类,概率为 (1-i/n)*(1-j/s);</span><br><span class="line">        整理便得到转移方程</span><br><span class="line">*/</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=1010;</span><br><span class="line">double dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,s;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[n][s]=0;</span><br><span class="line">        for(int i=n;i&gt;=0;i--)</span><br><span class="line">          for(int j=s;j&gt;=0;j--)</span><br><span class="line">          &#123;</span><br><span class="line">              if(i==n&amp;&amp;j==s)continue;</span><br><span class="line">              dp[i][j]=(i*(s-j)*dp[i][j+1]+(n-i)*j*dp[i+1][j]+(n-i)*(s-j)*dp[i+1][j+1]+n*s)/(n*s-i*j);</span><br><span class="line">          &#125;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;,dp[0][0]);//POJ上G++要改成%.4f</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra-邻接矩阵"><a href="#Dijkstra-邻接矩阵" class="headerlink" title="Dijkstra(邻接矩阵)"></a>Dijkstra(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int road[maxn][maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(road, inf, sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int u = 1; u&lt;=n; u++)&#123;</span><br><span class="line">        int minD = inf, k = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(k == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[k] = true;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[k] + road[k][i] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = dis[k] + road[k][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        road[u][v] = min(road[u][v], w);</span><br><span class="line">        //road[v][u] = min(road[v][u], w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    for(int cas = 1; cas&lt;=n; cas++)&#123;</span><br><span class="line">        int minD = inf, kk = -1;</span><br><span class="line">        for(int i = 1; i&lt;= n; i++)&#123;</span><br><span class="line">            if(!vis[i] &amp;&amp; dis[i] &lt; minD)&#123;</span><br><span class="line">                kk = i;</span><br><span class="line">                minD = dis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //if(kk == ex)</span><br><span class="line">        //    return dis[ex];</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        //add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra-heap"><a href="#Dijkstra-heap" class="headerlink" title="Dijkstra+heap"></a>Dijkstra+heap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 3007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w;</span><br><span class="line">&#125;edge[maxn&lt;&lt;4];</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int dis;</span><br><span class="line">    NODE()&#123;&#125;</span><br><span class="line">    NODE(int x, int y) : u(x), dis(y)&#123;&#125;</span><br><span class="line">    bool operator &lt;(const NODE &amp;a)const&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">int dijkstra(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    priority_queue&lt;NODE&gt;que;</span><br><span class="line">    que.push(NODE(sx, 0));</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        NODE tmp = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        int kk = tmp.u;</span><br><span class="line">        if(vis[kk])&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[kk] = true;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(!vis[v] &amp;&amp; dis[kk] + edge[i].w &lt; dis[v])&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                que.push(NODE(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    int u, v, w;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);  //双向边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, dijkstra(sx, ex));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e3+7;</span><br><span class="line">int n, m, sx, ex;</span><br><span class="line">int head[maxn], dis[maxn], cnt;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, w, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void init()&#123;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">int SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            int v = edge[i].to;</span><br><span class="line">            if(dis[v] &gt; dis[kk] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[kk] + edge[i].w;</span><br><span class="line">                if(!vis[v])&#123;</span><br><span class="line">                    vis[v] = true;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[ex];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))&#123;</span><br><span class="line">        init();</span><br><span class="line">        sx = 1, ex = n;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            add(u, v, w);</span><br><span class="line">            //add(v, u, w);   //双向边</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, SPFA(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA-SLF优化"><a href="#SPFA-SLF优化" class="headerlink" title="SPFA+SLF优化"></a>SPFA+SLF优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=1e2;</span><br><span class="line"></span><br><span class="line">int phi[MAXN],n,tot;</span><br><span class="line">int pri[MAXN];</span><br><span class="line">bool mark[MAXN];</span><br><span class="line"></span><br><span class="line">void getphi()&#123;</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mark[i])&#123;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            int x=pri[j];</span><br><span class="line">            if(i*x&gt;n) break;</span><br><span class="line">            mark[i*x]=1;</span><br><span class="line">            if(i%x==0)&#123;</span><br><span class="line">                phi[i*x]=phi[i]*x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[i*x]=phi[i]*phi[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        getphi();</span><br><span class="line"></span><br><span class="line">            printf(&quot;%d\n&quot;,phi[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(k=1; k&lt;=n; k++)</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">        for(j=1; j&lt;=n; j++)</span><br><span class="line">            if(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">                e[i][j]=e[i][k]+e[k][j];</span><br></pre></td></tr></table></figure>
<h3 id="K短路"><a href="#K短路" class="headerlink" title="K短路"></a>K短路</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * poj</span><br><span class="line"> * Problem#2449</span><br><span class="line"> * Accepted</span><br><span class="line"> * Time: 438ms</span><br><span class="line"> * Memory: 15196k </span><br><span class="line"> */</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef bool boolean;</span><br><span class="line"></span><br><span class="line">#define pii pair&lt;int, int&gt;</span><br><span class="line">#define fi first</span><br><span class="line">#define sc second</span><br><span class="line"></span><br><span class="line">typedef class Node &#123;</span><br><span class="line">    public:</span><br><span class="line">        int val, ed;</span><br><span class="line">        Node *l, *r;</span><br><span class="line">        </span><br><span class="line">        Node()    &#123;        &#125;</span><br><span class="line">        Node(int val, int ed, Node *l, Node *r):val(val), ed(ed), l(l), r(r) &#123;        &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">#define Limit 1000000</span><br><span class="line"></span><br><span class="line">Node pool[Limit];</span><br><span class="line">Node* top = pool;</span><br><span class="line"></span><br><span class="line">Node* newnode(int val, int ed) &#123;</span><br><span class="line">    if(top &gt;= pool + Limit)</span><br><span class="line">        return new Node(val, ed, NULL, NULL);</span><br><span class="line">    top-&gt;val = val, top-&gt;ed = ed, top-&gt;l = top-&gt;r = NULL;</span><br><span class="line">    return top++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* merge(Node* a, Node* b) &#123;</span><br><span class="line">    if (!a)    return b;</span><br><span class="line">    if (!b)    return a;</span><br><span class="line">    if (a-&gt;val &gt; b-&gt;val)    swap(a, b);</span><br><span class="line">    Node* p = newnode(a-&gt;val, a-&gt;ed);</span><br><span class="line">    p-&gt;l = a-&gt;l, p-&gt;r = a-&gt;r;</span><br><span class="line">    p-&gt;r = merge(p-&gt;r, b);</span><br><span class="line">    swap(p-&gt;l, p-&gt;r);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef class Status &#123;</span><br><span class="line">    public:</span><br><span class="line">        int dist;</span><br><span class="line">        Node* p;</span><br><span class="line">        </span><br><span class="line">        Status(int dist = 0, Node* p = NULL):dist(dist), p(p) &#123;        &#125;</span><br><span class="line"></span><br><span class="line">        boolean operator &lt; (Status b) const &#123;</span><br><span class="line">            return dist &gt; b.dist;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;Status;</span><br><span class="line"></span><br><span class="line">typedef class Edge &#123;</span><br><span class="line">    public:</span><br><span class="line">        int end, next, w;</span><br><span class="line">        </span><br><span class="line">        Edge(int end = 0, int next = 0, int w = 0):end(end), next(next), w(w) &#123;        &#125;</span><br><span class="line">&#125;Edge;</span><br><span class="line"></span><br><span class="line">typedef class MapManager &#123;</span><br><span class="line">    public:</span><br><span class="line">        int ce;</span><br><span class="line">        int* h;</span><br><span class="line">        Edge* es;</span><br><span class="line">        </span><br><span class="line">        MapManager() &#123;            &#125;</span><br><span class="line">        MapManager(int n, int m):ce(0) &#123;</span><br><span class="line">            h = new int[(n + 1)];</span><br><span class="line">            es = new Edge[(m + 5)];</span><br><span class="line">            memset(h, 0, sizeof(int) * (n + 1));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        void addEdge(int u, int v, int w) &#123;</span><br><span class="line">            es[++ce] = Edge(v, h[u], w);</span><br><span class="line">            h[u] = ce;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Edge&amp; operator [] (int pos) &#123;</span><br><span class="line">            return es[pos];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;MapManager;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int s, t, k;</span><br><span class="line">MapManager g;</span><br><span class="line">MapManager rg;</span><br><span class="line">boolean *vis;</span><br><span class="line">int* f, *lase;</span><br><span class="line"></span><br><span class="line">inline void init() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    g = MapManager(n, m);</span><br><span class="line">    rg = MapManager(n, m);</span><br><span class="line">    for (int i = 1, u, v, w; i &lt;= m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        g.addEdge(u, v, w);</span><br><span class="line">        rg.addEdge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">void spfa(MapManager&amp; g, int s) &#123;</span><br><span class="line">    vis = new boolean[(n + 1)];</span><br><span class="line">    f = new int[(n + 1)];</span><br><span class="line">    lase = new int[(n + 1)];</span><br><span class="line">    memset(f, 0x7f, sizeof(int) * (n + 1));</span><br><span class="line">    memset(vis, false, sizeof(boolean) * (n + 1));</span><br><span class="line">    que.push(s);</span><br><span class="line">    f[s] = 0, lase[s] = 0;</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int e = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[e] = false;</span><br><span class="line">        for (int i = g.h[e]; i; i = g[i].next) &#123;</span><br><span class="line">            int eu = g[i].end, w = g[i].w;</span><br><span class="line">            if (f[e] + w &lt; f[eu]) &#123;</span><br><span class="line">                f[eu] = f[e] + w, lase[eu] = i;</span><br><span class="line">                if (!vis[eu]) &#123;</span><br><span class="line">                    vis[eu] = true;</span><br><span class="line">                    que.push(eu); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Node** hs;</span><br><span class="line">inline void rebuild() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = g.h[i]; j; j = g[j].next) &#123;</span><br><span class="line">            int e = g[j].end;</span><br><span class="line">            if (lase[i] != j)</span><br><span class="line">                g[j].w += f[e] - f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    hs = new Node*[(n + 1)];</span><br><span class="line">    que.push(t);</span><br><span class="line">    hs[t] = NULL;</span><br><span class="line">    while (!que.empty()) &#123;</span><br><span class="line">        int e = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        if (lase[e])</span><br><span class="line">            hs[e] = hs[g[lase[e]].end];</span><br><span class="line">        for (int i = g.h[e]; i; i = g[i].next)</span><br><span class="line">            if (lase[e] != i &amp;&amp; f[g[i].end] != 0x7f7f7f7f)</span><br><span class="line">                hs[e] = merge(hs[e], new Node(g[i].w, g[i].end, NULL, NULL));</span><br><span class="line">        for (int i = rg.h[e]; i; i = rg[i].next) &#123;</span><br><span class="line">            int eu = rg[i].end;</span><br><span class="line">            if (lase[eu] == i)</span><br><span class="line">                que.push(eu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int kthpath(int k) &#123;</span><br><span class="line">    if (s == t)</span><br><span class="line">        k++;</span><br><span class="line">    if (f[s] == 0x7f7f7f7f)</span><br><span class="line">        return -1;</span><br><span class="line">    if (k == 1)</span><br><span class="line">        return f[s];</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;Status&gt; q;</span><br><span class="line">    if (!hs[s])</span><br><span class="line">        return -1;</span><br><span class="line">        </span><br><span class="line">    q.push(Status(hs[s]-&gt;val, hs[s]));</span><br><span class="line">    while (--k &amp;&amp; !q.empty()) &#123;</span><br><span class="line">        Status e = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        if(k == 1)</span><br><span class="line">            return e.dist + f[s];</span><br><span class="line">        </span><br><span class="line">        int eu = e.p-&gt;ed;</span><br><span class="line">        if (hs[eu])</span><br><span class="line">            q.push(Status(e.dist + hs[eu]-&gt;val, hs[eu]));</span><br><span class="line">        if (e.p-&gt;l)</span><br><span class="line">            q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;l-&gt;val, e.p-&gt;l));</span><br><span class="line">        if (e.p-&gt;r)</span><br><span class="line">            q.push(Status(e.dist - e.p-&gt;val + e.p-&gt;r-&gt;val, e.p-&gt;r));</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void solve() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, kthpath(k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    spfa(rg, t);</span><br><span class="line">    rebuild();</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//最短路算法+可持久化堆</span><br></pre></td></tr></table></figure>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//并查集实现最小生成树</span><br><span class="line">vector&lt;int&gt; u, v, weights, w_r, father;</span><br><span class="line">int mycmp(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">    return weights[i] &lt; weights[j];</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return father[x] == x ? x : father[x] = find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line">void kruskal_test()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n));</span><br><span class="line">    for(int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int edges = 0;</span><br><span class="line">    // 共计n*(n - 1)/2条边</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">            u.push_back(i);</span><br><span class="line">            v.push_back(j);</span><br><span class="line">            weights.push_back(A[i][j]);</span><br><span class="line">            w_r.push_back(edges++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        father.push_back(i);    // 记录n个节点的根节点，初始化为各自本身</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(w_r.begin(), w_r.end(), mycmp); //以weight的大小来对索引值进行排序</span><br><span class="line"></span><br><span class="line">    int min_tree = 0, cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; edges; ++i) &#123;</span><br><span class="line">        int e = w_r[i];    //e代表排序后的权值的索引</span><br><span class="line">        int x = find(u[e]), y = find(v[e]);</span><br><span class="line">        //x不等于y表示u[e]和v[e]两个节点没有公共根节点，可以合并</span><br><span class="line">        if (x != y) &#123;</span><br><span class="line">            min_tree += weights[e];</span><br><span class="line">            father[x] = y;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &lt; n - 1) min_tree = 0;</span><br><span class="line">    cout &lt;&lt; min_tree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    kruskal_test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//Prim算法实现</span><br><span class="line">void prim_test()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; A(n, vector&lt;int&gt;(n));</span><br><span class="line">    for(int i = 0; i &lt; n ; ++i) &#123;</span><br><span class="line">        for(int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pos, minimum;</span><br><span class="line">    int min_tree = 0;</span><br><span class="line">    //lowcost数组记录每2个点间最小权值，visited数组标记某点是否已访问</span><br><span class="line">    vector&lt;int&gt; visited, lowcost;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        visited.push_back(0);    //初始化为0，表示都没加入</span><br><span class="line">    &#125;</span><br><span class="line">    visited[0] = 1;   //最小生成树从第一个顶点开始</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        lowcost.push_back(A[0][i]);    //权值初始化为0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;    //枚举n个顶点</span><br><span class="line">        minimum = max_int;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;    //找到最小权边对应顶点</span><br><span class="line">            if(!visited[j] &amp;&amp; minimum &gt; lowcost[j]) &#123;</span><br><span class="line">                minimum = lowcost[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (minimum == max_int)    //如果min = max_int表示已经不再有点可以加入最小生成树中</span><br><span class="line">            break;</span><br><span class="line">        min_tree += minimum;</span><br><span class="line">        visited[pos] = 1;     //加入最小生成树中</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if(!visited[j] &amp;&amp; lowcost[j] &gt; A[pos][j]) lowcost[j] = A[pos][j];   //更新可更新边的权值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; min_tree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    prim_test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const int MAXN = 500;</span><br><span class="line">const int MAXE = 500 * 500;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int pre[MAXN + 7];</span><br><span class="line"></span><br><span class="line">void initPre(int n)&#123; for(int i = 0; i &lt;= n; i++) pre[i] = i; &#125;</span><br><span class="line"></span><br><span class="line">//并查集</span><br><span class="line">int Find(int x)&#123; return x == pre[x] ? x : pre[x] = Find(pre[x]); &#125;</span><br><span class="line"></span><br><span class="line">void merge(int x, int y)&#123; int fx = Find(x), fy = Find(y); if(fx != fy) pre[fx] = fy; &#125;</span><br><span class="line"></span><br><span class="line">struct Edge&#123; //前向星存边</span><br><span class="line">    int u, v; //起点  终点 </span><br><span class="line">    int w;</span><br><span class="line">    bool select;</span><br><span class="line">&#125;edge[MAXE + 7];</span><br><span class="line"></span><br><span class="line">bool cmp(Edge a, Edge b)&#123;</span><br><span class="line">    if(a.w != b.w) return a.w &lt; b.w;</span><br><span class="line">    if(a.u != b.u) return a.u &lt; b.u;</span><br><span class="line">    return a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node&#123;//链式前向星 用于存储每个集合里面的边</span><br><span class="line">    int to;</span><br><span class="line">    int next;</span><br><span class="line">&#125;link[MAXN + 7];</span><br><span class="line"></span><br><span class="line">int head[MAXN + 7];//邻接表的头结点的位置</span><br><span class="line">int End[MAXN + 7];//邻接表的尾节点的位置</span><br><span class="line">int length[MAXN + 7][MAXN + 7];//最小生成树中任意两点路径上的最长边 </span><br><span class="line"></span><br><span class="line">int kruskal(int n, int m)&#123;</span><br><span class="line">    //初始化邻接表,对于每一个顶点添加一个指向自身的边,表示以i为代表元的集合中只有点i</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        link[i].to = i, link[i].next = head[i];</span><br><span class="line">        End[i] = i, head[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge + 1, edge + 1 + m, cmp);</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++)&#123;</span><br><span class="line">        if(cnt == n - 1) break;//当找到的边数等于节点数-1,说明mst已经找到</span><br><span class="line">        int fx = Find(edge[i].u);</span><br><span class="line">        int fy = Find(edge[i].v);</span><br><span class="line">        if(fx != fy)&#123;</span><br><span class="line">            for(int j = head[fx]; j != -1; j = link[j].next)//修改length数组 </span><br><span class="line">                for(int k = head[fy]; k != -1; k = link[k].next)</span><br><span class="line">                //每次合并两个等价类的之后,分别属于两个等价类的两个节点之间的最长边一定是当前加入的边</span><br><span class="line">                    length[link[j].to][link[k].to] = length[link[k].to][link[j].to] = edge[i].w;</span><br><span class="line">            //合并邻接表</span><br><span class="line">            link[End[fy]].next = head[fx];</span><br><span class="line">            End[fy] = End[fx];</span><br><span class="line">            merge(fx, fy);</span><br><span class="line">            cnt++;</span><br><span class="line">            edge[i].select = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cnt &lt; n - 1) return -1;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //初始化建图后执行以下操作</span><br><span class="line">    int flag = kruskal(n, m);</span><br><span class="line">    int mst = 0;</span><br><span class="line">    for(int i = 1; i &lt;= m; i++) if(edge[i].select) mst += edge[i].w;//计算出最小生成树</span><br><span class="line">    int secmst = INF;</span><br><span class="line">    //在 T/(u,v) + (x, y)中寻得次小生成树</span><br><span class="line">    for(int i = 1; i &lt;= m; i++) if(!edge[i].select) secmst = min(secmst, mst + edge[i].w - length[edge[i].u][edge[i].v]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*hdu1285--采用二维数组记录两者之间的关系*/</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int map[510][510];//前驱数量 </span><br><span class="line">int indegree[510];</span><br><span class="line">int queue[510];//保存拓扑序列 </span><br><span class="line">void topo(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,m,t=0;</span><br><span class="line">    for(j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(indegree[i]==0)&#123;//找出前驱数量为零的的点即每次找到第一名 </span><br><span class="line">                m=i;break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[t++]=m;indegree[m]=-1;//将第一名的前驱数量设为-1 </span><br><span class="line">        for(i=1;i&lt;=n;++i)&#123;//第二步将前驱中含有第一名的点前驱数量减1 </span><br><span class="line">            if(map[m][i])indegree[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,queue[0]);//输出拓扑序列 </span><br><span class="line">    for(i=1;i&lt;n;++i)&#123;</span><br><span class="line">        printf(&quot; %d&quot;,queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,a,b;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        memset(indegree,0,sizeof(indegree));//初始化 </span><br><span class="line">        memset(map,0,sizeof(map));</span><br><span class="line">        for(i=0;i&lt;m;++i)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">            if(map[a][b]==0)&#123; //避免重复的数据输入 </span><br><span class="line">                map[a][b]=1;indegree[b]++;//第一步记录关系和点的前驱数量 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        topo(n);//调用拓扑排序 </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="FF"><a href="#FF" class="headerlink" title="FF"></a>FF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#define maxn 1200</span><br><span class="line">#define INF 2e9</span><br><span class="line">using namespace std;</span><br><span class="line">int i,j,k,n,m,h,t,tot,ans,st,en;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int c,f;</span><br><span class="line">&#125;edge[maxn][maxn];</span><br><span class="line">int flag[maxn],pre[maxn],alpha[maxn],q[maxn],v;</span><br><span class="line">int read()&#123;</span><br><span class="line">    char c;int x;while(c=getchar(),c&lt;&apos;0&apos;||c&gt;&apos;9&apos;);x=c-&apos;0&apos;;</span><br><span class="line">    while(c=getchar(),c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) x=x*10+c-&apos;0&apos;;return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs()&#123;</span><br><span class="line">    memset(flag,0xff,sizeof(flag));memset(pre,0xff,sizeof(pre));memset(alpha,0xff,sizeof(alpha));</span><br><span class="line">    flag[st]=0;pre[st]=0;alpha[st]=INF;h=0,t=1;q[t]=st;</span><br><span class="line">    while(h&lt;t)&#123;</span><br><span class="line">        h++;v=q[h];</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(flag[i]==-1)&#123;</span><br><span class="line">                if(edge[v][i].c&lt;INF&amp;&amp;edge[v][i].f&lt;edge[v][i].c)&#123;</span><br><span class="line">                    flag[i]=0;pre[i]=v;alpha[i]=min(alpha[v],edge[v][i].c-edge[v][i].f);q[++t]=i;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(edge[i][v].c&lt;INF&amp;&amp;edge[i][v].f&gt;0)&#123;</span><br><span class="line">                    flag[i]=0;pre[i]=-v;alpha[i]=min(alpha[v],edge[i][v].f);q[++t]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[v]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ford_Fulkerson()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        bfs();</span><br><span class="line">        if(alpha[en]==0||flag[en]==-1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int k1=en,k2=abs(pre[k1]);int a=alpha[en];</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(edge[k2][k1].c&lt;INF) edge[k2][k1].f+=a;</span><br><span class="line">            else if(edge[k1][k2].c&lt;INF) edge[k1][k2].f-=a;</span><br><span class="line">            if(k2==st) break;</span><br><span class="line">            k1=k2;k2=abs(pre[k1]);</span><br><span class="line">        &#125;</span><br><span class="line">        alpha[en]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flow()&#123;</span><br><span class="line">    int maxflow=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        if(i==st&amp;&amp;edge[i][j].f&lt;INF) maxflow+=edge[i][j].f;</span><br><span class="line">      &#125;</span><br><span class="line">    printf(&quot;%d&quot;,maxflow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int u,v,c,f;</span><br><span class="line">    n=read();m=read();st=read();en=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      for(int j=1;j&lt;=n;j++) edge[i][j].c=INF,edge[i][j].f=0;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        u=read();v=read();c=read();</span><br><span class="line">        edge[u][v].c=c;</span><br><span class="line">    &#125;</span><br><span class="line">    Ford_Fulkerson();</span><br><span class="line">    flow();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EK"><a href="#EK" class="headerlink" title="EK"></a>EK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line">#define maxn 10005</span><br><span class="line"></span><br><span class="line">int n, m, st, en, flow[maxn][maxn], pre[maxn];</span><br><span class="line">int q[maxn], curr_pos, st_pos, end_pos;</span><br><span class="line">bool wh[maxn];</span><br><span class="line">int max_flow;</span><br><span class="line"></span><br><span class="line">void Init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">    int i, a, b, c;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;en);</span><br><span class="line">    for(i = 0; i != m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        flow[a][b] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Bfs(int st, int en)//广搜找源点</span><br><span class="line">&#123;</span><br><span class="line">    st_pos = -1, end_pos = 0;</span><br><span class="line">    memset(wh, 0, sizeof wh);</span><br><span class="line">    wh[st] = 1;</span><br><span class="line">    q[0] = st;</span><br><span class="line">    while(st_pos != end_pos)</span><br><span class="line">    &#123;</span><br><span class="line">        curr_pos = q[++st_pos];</span><br><span class="line">        for(int i = 1; i != n+1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!wh[i] &amp;&amp; flow[curr_pos][i] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                wh[i] = 1;</span><br><span class="line">                pre[i] = curr_pos;</span><br><span class="line">                if(i == en)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                q[++end_pos] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int EK(int start_pos, int end_pos)</span><br><span class="line">&#123;</span><br><span class="line">    int i, minn;</span><br><span class="line">    while(Bfs(start_pos, end_pos))//回溯</span><br><span class="line">    &#123;</span><br><span class="line">        minn = INF;</span><br><span class="line"></span><br><span class="line">        for(i = end_pos; i != start_pos; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            minn = min(minn, flow[pre[i]][i]);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        for(i = end_pos; i != start_pos; i = pre[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flow[pre[i]][i] -= minn;</span><br><span class="line">            flow[i][pre[i]] += minn;//反向弧加上该值（具体原因下文详解）</span><br><span class="line">        &#125; </span><br><span class="line">        max_flow += minn;</span><br><span class="line">    &#125;</span><br><span class="line">    return max_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    //freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line"></span><br><span class="line">    Init();</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;, EK(st, en));</span><br><span class="line"></span><br><span class="line">    //fclose(stdin);</span><br><span class="line">    //fclose(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC"><a href="#DINIC" class="headerlink" title="DINIC"></a>DINIC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC优化"><a href="#DINIC优化" class="headerlink" title="DINIC优化"></a>DINIC优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, sx, ex, cnt;</span><br><span class="line">int head[maxn], pre[maxn], cur[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int u, next, to, c;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add_edge(int u, int v, int c)&#123;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c)&#123;</span><br><span class="line">    add_edge(u, v, c);</span><br><span class="line">    add_edge(v, u, 0);//双向边容量为c</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    //memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    sx = 1, ex = n;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        int u, v, w;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, 0, sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int&amp; i = cur[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">                int v = edge[i].to;</span><br><span class="line">            if(!pre[v]&amp;&amp;edge[i].c)&#123;</span><br><span class="line">                pre[v] = pre[kk] + 1;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != 0;</span><br><span class="line">&#125;</span><br><span class="line">int DFS(int pos, int flow)&#123;</span><br><span class="line">    if(pos == ex || flow == 0)</span><br><span class="line">        return flow;</span><br><span class="line">    int f = flow;</span><br><span class="line">    for(int i = head[pos]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int tmp, v = edge[i].to;</span><br><span class="line">        if(edge[i].c &amp;&amp; pre[pos] + 1 == pre[v] &amp;&amp; (tmp = DFS(v, min(edge[i].c, flow)))&gt;0)&#123;</span><br><span class="line">            edge[i].c -= tmp;</span><br><span class="line">            edge[i^1].c += tmp;</span><br><span class="line">            flow -= tmp;</span><br><span class="line">            if(flow == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int Dinic(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0;</span><br><span class="line">    while(BFS(sx, ex))&#123;</span><br><span class="line">        memcpy(cur, head, sizeof(head));</span><br><span class="line">        flow += DFS(sx, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m, &amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, Dinic(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DINIC-邻接矩阵"><a href="#DINIC-邻接矩阵" class="headerlink" title="DINIC(邻接矩阵)"></a>DINIC(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 307;</span><br><span class="line">struct NODE&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int f;</span><br><span class="line">&#125;;</span><br><span class="line">int sx,ex;</span><br><span class="line">int pre[maxn];</span><br><span class="line">NODE road[maxn][maxn];</span><br><span class="line">int n, m, N;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">    memset(pre,0,sizeof(pre));</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    q.push(sx);</span><br><span class="line">    pre[sx] = 1;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int d = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i = 1;i&lt;=N;i++)&#123;</span><br><span class="line">            if(!pre[i]&amp;&amp;road[d][i].c-road[d][i].f)&#123;</span><br><span class="line">                pre[i] = pre[d] + 1;</span><br><span class="line">                q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex]!=0;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int pos, int flow)&#123;</span><br><span class="line">    int f = flow;</span><br><span class="line">    if(pos==ex)</span><br><span class="line">        return flow;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if(road[pos][i].c - road[pos][i].f &amp;&amp; pre[pos] + 1 == pre[i])&#123;</span><br><span class="line">            int a = road[pos][i].c - road[pos][i].f;</span><br><span class="line">            int t = dfs(i, min(a, flow));</span><br><span class="line">            road[pos][i].f += t;</span><br><span class="line">            road[i][pos].f -= t;</span><br><span class="line">            flow -= t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f - flow;</span><br><span class="line">&#125;</span><br><span class="line">int dinic()&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    while(BFS())&#123;</span><br><span class="line">        sum+=dfs(sx,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    N = n;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = N;</span><br><span class="line">    memset(road,0,sizeof(road));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u,v,w;</span><br><span class="line">    for(int i = 1;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        road[u][v].c+=w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,dinic());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int read() &#123;</span><br><span class="line">    int x=0,f=1;</span><br><span class="line">    char c=getchar();</span><br><span class="line">    for (;!isdigit(c);c=getchar()) if (c==&apos;-&apos;) f=-1;</span><br><span class="line">    for (;isdigit(c);c=getchar()) x=x*10+c-&apos;0&apos;;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line">const int maxn=205;</span><br><span class="line">const int maxm=205;</span><br><span class="line">const int inf=2e9+7;</span><br><span class="line">struct edge &#123;</span><br><span class="line">    int v,w,nxt;</span><br><span class="line">&#125; e[maxm&lt;&lt;1];</span><br><span class="line">int h[maxn],tot,n,m,gap[maxn],last[maxn],d[maxn],que[maxn],ql,qr;</span><br><span class="line">vector&lt;int&gt; inv[maxn];</span><br><span class="line">void add(int u,int v,int w) &#123;</span><br><span class="line">    e[++tot]=(edge)&#123;v,w,h[u]&#125;;</span><br><span class="line">    h[u]=tot;</span><br><span class="line">    e[++tot]=(edge)&#123;u,0,h[v]&#125;;</span><br><span class="line">    h[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void init(int s,int t) &#123;</span><br><span class="line">    memset(gap,0,sizeof gap),memset(d,0,sizeof d),++gap[d[t]=1];</span><br><span class="line">    for (int i=1;i&lt;=n;++i) last[i]=h[i];</span><br><span class="line">    que[ql=qr=1]=t;</span><br><span class="line">    while (ql&lt;=qr) &#123;</span><br><span class="line">        int x=que[ql++];</span><br><span class="line">        for (int i=h[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (!d[v]) ++gap[d[v]=d[x]+1],que[++qr]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int aug(int x,int s,int t,int mi) &#123;</span><br><span class="line">    if (x==t) return mi;</span><br><span class="line">    int flow=0;</span><br><span class="line">    for (int &amp;i=last[x],v=e[i].v;i;i=e[i].nxt,v=e[i].v) if (d[x]==d[v]+1) &#123;</span><br><span class="line">        int tmp=aug(v,s,t,min(mi,e[i].w));</span><br><span class="line">        flow+=tmp,mi-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;</span><br><span class="line">        if (!mi) return flow;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(--gap[d[x]])) d[s]=n+1;</span><br><span class="line">    ++gap[++d[x]],last[x]=h[x];</span><br><span class="line">    return flow;</span><br><span class="line">&#125;</span><br><span class="line">int maxflow(int s,int t) &#123;</span><br><span class="line">    init(s,t);</span><br><span class="line">    int ret=aug(s,s,t,inf);</span><br><span class="line">    while (d[s]&lt;=n) ret+=aug(s,s,t,inf);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">    freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">#endif</span><br><span class="line">    while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)) &#123;</span><br><span class="line">        tot=1,memset(h,0,sizeof h);</span><br><span class="line">        for (int i=1;i&lt;=n;++i) inv[i].clear();</span><br><span class="line">        for (int i=1;i&lt;=m;++i) &#123;</span><br><span class="line">            int u=read(),v=read(),w=read();</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            if (w) inv[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=maxflow(1,n);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm = 1e5+7;</span><br><span class="line">const int maxn = 1e4+7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m, cnt, sx, ex;</span><br><span class="line">int head[maxn], pre[maxn], dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">    int w;</span><br><span class="line">    int c;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line">void init()&#123;</span><br><span class="line">    sx = 0;</span><br><span class="line">    ex = 1;</span><br><span class="line">    cnt = 0;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">void add_edge(int u, int v, int c, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].c = c&lt;=inf ? c : inf;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u, int v, int c, int w)&#123;</span><br><span class="line">    add_edge(u, v, c, w);</span><br><span class="line">    add_edge(v, u, 0, -w);</span><br><span class="line">&#125;</span><br><span class="line">bool SPFA(int sx, int ex)&#123;</span><br><span class="line">    memset(pre, -1, sizeof(pre));</span><br><span class="line">    memset(dis, inf, sizeof(dis));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    dis[sx] = 0;</span><br><span class="line">    queue&lt;int&gt;que;</span><br><span class="line">    que.push(sx);</span><br><span class="line">    while(!que.empty())&#123;</span><br><span class="line">        int kk = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[kk] = false;</span><br><span class="line">        for(int i = head[kk]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">            EDGE tmp = edge[i];</span><br><span class="line">            if(tmp.c &amp;&amp; dis[tmp.to]&gt;dis[kk]+tmp.w)&#123;</span><br><span class="line">                dis[tmp.to] = dis[kk] + tmp.w;</span><br><span class="line">                pre[tmp.to] = i;</span><br><span class="line">                if(!vis[tmp.to])&#123;</span><br><span class="line">                    vis[tmp.to] = true;</span><br><span class="line">                    que.push(tmp.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre[ex] != -1;</span><br><span class="line">&#125;</span><br><span class="line">int MCMF(int sx, int ex)&#123;</span><br><span class="line">    int flow = 0, cost = 0;</span><br><span class="line">    while(SPFA(sx, ex))&#123;</span><br><span class="line">    	int min_flow = inf;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            min_flow = min(min_flow, edge[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pre[ex]; i != -1; i = pre[edge[i^1].to])&#123;</span><br><span class="line">            edge[i].c -= min_flow;</span><br><span class="line">            edge[i^1].c += min_flow;</span><br><span class="line">            cost += min_flow * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        flow += min_flow;</span><br><span class="line">    &#125;</span><br><span class="line">    return cost;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v, c, w;</span><br><span class="line">    ex = n+1;</span><br><span class="line">    for(int i = 0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;u,&amp;v,&amp;c,&amp;w);</span><br><span class="line">        add(u,v,c, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">        if(n+m==0)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;,MCMF(sx, ex));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h3 id="匈牙利算法-邻接矩阵"><a href="#匈牙利算法-邻接矩阵" class="headerlink" title="匈牙利算法(邻接矩阵)"></a>匈牙利算法(邻接矩阵)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int N, K;</span><br><span class="line">int edge[maxn][maxn], head[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(head, 0, sizeof(head));</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x) &#123;</span><br><span class="line">	for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">		if (edge[x][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">			vis[i] = true;</span><br><span class="line">			if (!head[i] || find_edge(head[i])) &#123;</span><br><span class="line">				head[i] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin &gt;&gt; N &gt;&gt; K) &#123;</span><br><span class="line">		int x, y;</span><br><span class="line">		for (int i = 1; i &lt;= K; i++)&#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			edge[x][y] = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; Magyar(N) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 107;</span><br><span class="line">int T, N, m;</span><br><span class="line">int head[maxn], link[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int cnt;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, u, to, w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line">void add(int u, int v, int w)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(edge, 0, sizeof(edge));</span><br><span class="line">    memset(link, 0, sizeof(link));</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">bool find_edge(int x)&#123;</span><br><span class="line">    for(int i = head[x]; i!= -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            vis[v] = true;</span><br><span class="line">            if (!link[v] || find_edge(link[v])) &#123;</span><br><span class="line">				link[v] = x;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int Magyar(int N)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        if (find_edge(i)) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int solve()&#123;</span><br><span class="line">    int ans = Magyar(N);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;N, &amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">        add(x, y, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        printf(&quot;%d\n&quot;, solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        memset(edge, 0, sizeof(edge));</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法最小权匹配"><a href="#KM算法最小权匹配" class="headerlink" title="KM算法最小权匹配"></a>KM算法最小权匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KM算法最小权匹配优化版"><a href="#KM算法最小权匹配优化版" class="headerlink" title="KM算法最小权匹配优化版"></a>KM算法最小权匹配优化版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 207;</span><br><span class="line">const int maxm = 30007;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int minD, cntx, cnty, edge[maxn][maxn];</span><br><span class="line">bool visx[maxn], visy[maxn];</span><br><span class="line">int linkx[maxn], link[maxn], wx[maxn], wy[maxn];</span><br><span class="line">bool dfs(int x)&#123; //匈牙利算法找增广路径</span><br><span class="line">    visx[x] = true;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i++)&#123;</span><br><span class="line">        if(!visy[i])&#123;</span><br><span class="line">            int t = wx[x] + wy[i] - edge[x][i];</span><br><span class="line">            if(t == 0) &#123;</span><br><span class="line">                visy[i] = true;</span><br><span class="line">                if(link[i] == 0 || dfs(link[i]))&#123;</span><br><span class="line">                    linkx[x] = i;</span><br><span class="line">                    link[i] = x;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(t &gt; 0)&#123;  //找出边权与顶标和的最小的差值</span><br><span class="line">                if(t &lt; minD)&#123;</span><br><span class="line">                    minD = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int km()&#123;</span><br><span class="line">    memset(linkx, 0, sizeof linkx); //linkx[i]表示与X部中点i匹配的点</span><br><span class="line">    memset(link, 0, sizeof link);</span><br><span class="line">    memset(wy, 0, sizeof(wy));</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        wx[i] = -inf;</span><br><span class="line">        for(int j = 1; j &lt;= cnty; j++)&#123;</span><br><span class="line">            if(wx[i] &lt; edge[i][j])&#123;</span><br><span class="line">                wx[i] = edge[i][j];//初始化为权值最大的边的权值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= cntx; i++)&#123;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            minD = inf;</span><br><span class="line">            memset(visx, false, sizeof visx);</span><br><span class="line">            memset(visy, false, sizeof visy);</span><br><span class="line">            if(dfs(i))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cntx; j++)&#123;  //将交错树中X部的点的顶标减去minz</span><br><span class="line">                if(visx[j])&#123;</span><br><span class="line">                    wx[j] -= minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 1; j &lt;= cnty; j++)&#123; //将交错树中Y部的点的顶标加上minz</span><br><span class="line">                if(visy[j])&#123;</span><br><span class="line">                    wy[j] += minD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i = 1; i &lt;= cnty; i ++)&#123;</span><br><span class="line">        if(link[i]!=0&amp;&amp;edge[link[i]][i]!=-inf)&#123;</span><br><span class="line">            ans += edge[link[i]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        cntx = cnty = n;</span><br><span class="line">        for(int i = 0; i &lt;= cntx; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt;= cnty; j++)&#123;</span><br><span class="line">                edge[i][j] = -inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            edge[u][v] = max(edge[u][v], -w);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, km());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h2><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 7;</span><br><span class="line">const int inf = 0x3f3f3f3f;</span><br><span class="line">int n, m;</span><br><span class="line">int head[maxn], cnt, top, dfs_num, col_num;</span><br><span class="line">int dfn[maxn], low[maxn], Stack[maxn], color[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int next, to, u;</span><br><span class="line">&#125;edge[maxn&lt;&lt;3];</span><br><span class="line">void add(int u, int v)&#123;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].u = u;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line">void Tarjan(int x)&#123;</span><br><span class="line">    dfn[x] = ++dfs_num;</span><br><span class="line">    low[x] = dfs_num;</span><br><span class="line">    vis[x] = true;  //是否在栈中</span><br><span class="line">    Stack[++top] = x;</span><br><span class="line">    for(int i = head[x]; i != -1; i = edge[i].next)&#123;</span><br><span class="line">        int v = edge[i].to;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[x] = min(low[x], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[v])&#123;</span><br><span class="line">            low[x] = min(low[x], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x] == low[x])&#123;   //构成强连通分量</span><br><span class="line">        vis[x] = false;</span><br><span class="line">        color[x] = ++col_num;   //染色</span><br><span class="line">        while(Stack[top] != x)&#123; //清空</span><br><span class="line">            color[Stack[top]] = col_num;</span><br><span class="line">            vis [ Stack[ top-- ] ] = false ;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    top = dfs_num = col_num = cnt = 0;</span><br><span class="line">    memset(head, -1, sizeof(head));</span><br><span class="line">    memset(dfn, 0, sizeof(dfn));</span><br><span class="line">    memset(low, 0, sizeof(low));</span><br><span class="line">    memset(color, 0, sizeof(color));</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">void read()&#123;</span><br><span class="line">    int u, v;</span><br><span class="line">    for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">        if(!color[i])&#123;</span><br><span class="line">            Tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(col_num != 1)&#123;</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n+m)&#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan缩点"><a href="#Tarjan缩点" class="headerlink" title="Tarjan缩点"></a>Tarjan缩点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define MAXE 100010</span><br><span class="line">using namespace std;</span><br><span class="line">int head[MAXN],tot1,tot2;</span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int u,v,next;</span><br><span class="line">&#125;e1[MAXE],e2[MAXN];</span><br><span class="line">void addEdge(int u,int v,Edge* edge,int&amp; tol)&#123;</span><br><span class="line">    edge[tol].u=u;edge[tol].v=v;</span><br><span class="line">    edge[tol].next=head[u];head[u]=tol++;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];</span><br><span class="line">bool instack[MAXN];</span><br><span class="line">int scc,top,INDEX;</span><br><span class="line">void Tarjan(int u)&#123;</span><br><span class="line">    int v;</span><br><span class="line">    low[u]=dfn[u]=++INDEX;</span><br><span class="line">    stack[top++]=u;</span><br><span class="line">    instack[u]=true;</span><br><span class="line">    for(int i=head[u];i!=-1;i=e1[i].next)&#123;</span><br><span class="line">        v=e1[i].v;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            if(low[u]&gt;low[v]) low[u]=low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(instack[v]&amp;&amp;low[u]&gt;dfn[v])</span><br><span class="line">            low[u]=dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    if(low[u]==dfn[u])&#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        do&#123;</span><br><span class="line">            v=stack[--top];</span><br><span class="line">            instack[v]=false;</span><br><span class="line">            belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;while(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int inde[MAXN],outde[MAXN];</span><br><span class="line">void solve()&#123;</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(instack,false,sizeof(instack));</span><br><span class="line">    memset(num,0,sizeof(num));</span><br><span class="line">    scc=top=INDEX=0;</span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">        if(!dfn[i]) Tarjan(i);</span><br><span class="line">    tot2=0;memset(head,-1,sizeof(head));</span><br><span class="line">    memset(inde,0,sizeof(inde));</span><br><span class="line">    memset(outde,0,sizeof(outde));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">        u=belong[e1[i].u];</span><br><span class="line">        v=belong[e1[i].v];</span><br><span class="line">        if(u!=v)&#123;</span><br><span class="line">            addEdge(u,v,e2,tot2);</span><br><span class="line">            inde[v]++;</span><br><span class="line">            outde[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=0,b=0;</span><br><span class="line">    for(int i=1;i&lt;=scc;++i)&#123;</span><br><span class="line">        if(!inde[i]) a++;</span><br><span class="line">        if(!outde[i]) b++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(scc==1)printf(&quot;0\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d\n&quot;,max(a,b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;   int zushu;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;zushu);</span><br><span class="line">    while(zushu--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        tot1=0;memset(head,-1,sizeof(head));</span><br><span class="line">        int u,v;</span><br><span class="line">        for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            addEdge(u,v,e1,tot1);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">HDU 3622</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">HDU 3622</span><br><span class="line">题意:给n对炸弹可以放置的位置(每个位置为一个二维平面上的点),</span><br><span class="line">每次放置炸弹是时只能选择这一对中的其中一个点,每个炸弹爆炸</span><br><span class="line">的范围半径都一样,控制爆炸的半径使得所有的爆炸范围都不相</span><br><span class="line">交(可以相切),求解这个最大半径.</span><br><span class="line">     首先二分最大半径值,然后2-sat构图判断其可行性,对于每</span><br><span class="line">     两队位置(u,uu)和(v,vv),如果u和v之间的距离小于2*id,也就</span><br><span class="line">     是说位置u和位置v处不能同时防止炸弹(两范围相交),所以连边(u,vv)</span><br><span class="line">     和(v,uu),求解强连通分量判断可行性.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意精度问题</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=210;</span><br><span class="line">const int MAXM=40005;//边的最大数</span><br><span class="line">const double eps=1e-5;</span><br><span class="line"></span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int to,next;</span><br><span class="line">&#125;edge1[MAXM],edge2[MAXM];</span><br><span class="line">int head1[MAXN];</span><br><span class="line">int head2[MAXN];</span><br><span class="line">int tol1,tol2;</span><br><span class="line">bool vis1[MAXN],vis2[MAXN];</span><br><span class="line">int Belong[MAXN];//连通分量标记</span><br><span class="line">int T[MAXN];//dfs结点结束时间</span><br><span class="line">int Bcnt,Tcnt;</span><br><span class="line">void add(int a,int b)//原图和逆图都要添加</span><br><span class="line">&#123;</span><br><span class="line">    edge1[tol1].to=b;</span><br><span class="line">    edge1[tol1].next=head1[a];</span><br><span class="line">    head1[a]=tol1++;</span><br><span class="line">    edge2[tol2].to=a;</span><br><span class="line">    edge2[tol2].next=head2[b];</span><br><span class="line">    head2[b]=tol2++;</span><br><span class="line">&#125;</span><br><span class="line">void init()//建图前初始化</span><br><span class="line">&#123;</span><br><span class="line">    memset(head1,-1,sizeof(head1));</span><br><span class="line">    memset(head2,-1,sizeof(head2));</span><br><span class="line">    memset(vis1,false,sizeof(vis1));</span><br><span class="line">    memset(vis2,false,sizeof(vis2));</span><br><span class="line">    tol1=tol2=0;</span><br><span class="line">    Bcnt=Tcnt=0;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int x)//对原图进行dfs,算出每个结点的结束时间，哪个点开始无所谓</span><br><span class="line">&#123;</span><br><span class="line">    vis1[x]=true;</span><br><span class="line">    int j;</span><br><span class="line">    for(int j=head1[x];j!=-1;j=edge1[j].next)</span><br><span class="line">      if(!vis1[edge1[j].to])</span><br><span class="line">        dfs1(edge1[j].to);</span><br><span class="line">    T[Tcnt++]=x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int x)</span><br><span class="line">&#123;</span><br><span class="line">    vis2[x]=true;</span><br><span class="line">    Belong[x]=Bcnt;</span><br><span class="line">    int j;</span><br><span class="line">    for(j=head2[x];j!=-1;j=edge2[j].next)</span><br><span class="line">       if(!vis2[edge2[j].to])</span><br><span class="line">         dfs2(edge2[j].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;s[MAXN];</span><br><span class="line">double dist(Point a,Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ok(int n)//判断可行性</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;2*n;i++)</span><br><span class="line">      if(!vis1[i])</span><br><span class="line">        dfs1(i);</span><br><span class="line">    for(int i=Tcnt-1;i&gt;=0;i--)</span><br><span class="line">      if(!vis2[T[i]])//这个别写错，是vis2[T[i]]</span><br><span class="line">      &#123;</span><br><span class="line">          dfs2(T[i]);</span><br><span class="line">          Bcnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    for(int i=0;i&lt;=2*n-2;i+=2)</span><br><span class="line">      if(Belong[i]==Belong[i+1])</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    int n;</span><br><span class="line">    double left,right,mid;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">          scanf(&quot;%d%d%d%d&quot;,&amp;s[2*i].x,&amp;s[2*i].y,&amp;s[2*i+1].x,&amp;s[2*i+1].y);</span><br><span class="line">        left=0;</span><br><span class="line">        right=40000.0;</span><br><span class="line">        while(right-left&gt;=eps)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/2;</span><br><span class="line">            init();</span><br><span class="line">            for(int i=0;i&lt;2*n-2;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int t;</span><br><span class="line">                if(i%2==0)t=i+2;</span><br><span class="line">                else t=i+1;</span><br><span class="line">                for(int j=t;j&lt;2*n;j++)</span><br><span class="line">                   if(dist(s[i],s[j])&lt;2*mid)//冲突了</span><br><span class="line">                   &#123;</span><br><span class="line">                       add(i,j^1);</span><br><span class="line">                       add(j,i^1);//注意顺序不能变的</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ok(n))left=mid;</span><br><span class="line">            else right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.2lf\n&quot;,right);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b)&#123;</span><br><span class="line">    return !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if (b==0)&#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int Extended_Euclid(int a,int b,int &amp;x,int &amp;y)    //扩展欧几里得算法</span><br><span class="line">&#123;</span><br><span class="line">	int d;</span><br><span class="line">	if(b==0)</span><br><span class="line">	&#123;</span><br><span class="line">		x=1;y=0;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	d=Extended_Euclid(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Chinese_Remainder(int a[],int w[],int len)    //中国剩余定理  a[]存放余数  w[]存放两两互质的数</span><br><span class="line">&#123;</span><br><span class="line">	int i,d,x,y,m,n,ret;</span><br><span class="line">	ret=0;</span><br><span class="line">	n=1;</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">		n*=w[i];</span><br><span class="line">	for (i=0;i&lt;len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m=n/w[i];</span><br><span class="line">		d=Extended_Euclid(w[i],m,x,y);</span><br><span class="line">		ret=(ret+y*m*a[i])%n;</span><br><span class="line">	&#125;</span><br><span class="line">	return (n+ret%n)%n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i;</span><br><span class="line">	int w[15],b[15];</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n),n)   </span><br><span class="line">	&#123;</span><br><span class="line">		for (i=0;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;,&amp;w[i],&amp;b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d/n&quot;,Chinese_Remainder(b,w,n));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int oula(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int rea=n;</span><br><span class="line">    for(int i=2; i&lt;=n; i++)</span><br><span class="line">        if(n%i==0)//第一次找到的必为素因子</span><br><span class="line">        &#123;</span><br><span class="line">            rea=rea-rea/i;</span><br><span class="line">            do</span><br><span class="line">                n/=i;//把该素因子全部约掉</span><br><span class="line">            while(n%i==0);</span><br><span class="line">        &#125;</span><br><span class="line">    return rea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int prime[maxn];</span><br><span class="line">int visit[maxn];</span><br><span class="line">void Prime()&#123;</span><br><span class="line">    mem(visit,0);</span><br><span class="line">    mem(prime, 0);</span><br><span class="line">    for (int i = 2;i &lt;= maxn; i++) &#123;</span><br><span class="line">        cout&lt;&lt;&quot; i = &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        if (!visit[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;      //纪录素数， 这个prime[0] 相当于 cnt，用来计数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;=prime[0] &amp;&amp; i*prime[j] &lt;= maxn; j++) &#123;</span><br><span class="line">            visit[i*prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><h3 id="卡特兰数打表"><a href="#卡特兰数打表" class="headerlink" title="卡特兰数打表"></a>卡特兰数打表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">unsigned long long ctl[34] = &#123;0,1&#125;;</span><br><span class="line">void calc()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 2; i &lt; 34; i ++)</span><br><span class="line">        ctl[i] = ctl[i-1]*(4*i-2)/(i+1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    calc();</span><br><span class="line">    for(i = 0; i &lt; 34; i ++)</span><br><span class="line">        printf(&quot;%d: %llu\n&quot;,i, ctl[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卡特兰数表"><a href="#卡特兰数表" class="headerlink" title="卡特兰数表"></a>卡特兰数表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string catalan[]=</span><br><span class="line">&#123;</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;5&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;42&quot;,</span><br><span class="line">    &quot;132&quot;,</span><br><span class="line">    &quot;429&quot;,</span><br><span class="line">    &quot;1430&quot;,</span><br><span class="line">    &quot;4862&quot;,</span><br><span class="line">    &quot;16796&quot;,</span><br><span class="line">    &quot;58786&quot;,</span><br><span class="line">    &quot;208012&quot;,</span><br><span class="line">    &quot;742900&quot;,</span><br><span class="line">    &quot;2674440&quot;,</span><br><span class="line">    &quot;9694845&quot;,</span><br><span class="line">    &quot;35357670&quot;,</span><br><span class="line">    &quot;129644790&quot;,</span><br><span class="line">    &quot;477638700&quot;,</span><br><span class="line">    &quot;1767263190&quot;,</span><br><span class="line">    &quot;6564120420&quot;,</span><br><span class="line">    &quot;24466267020&quot;,</span><br><span class="line">    &quot;91482563640&quot;,</span><br><span class="line">    &quot;343059613650&quot;,</span><br><span class="line">    &quot;1289904147324&quot;,</span><br><span class="line">    &quot;4861946401452&quot;,</span><br><span class="line">    &quot;18367353072152&quot;,</span><br><span class="line">    &quot;69533550916004&quot;,</span><br><span class="line">    &quot;263747951750360&quot;,</span><br><span class="line">    &quot;1002242216651368&quot;,</span><br><span class="line">    &quot;3814986502092304&quot;,</span><br><span class="line">    &quot;14544636039226909&quot;,</span><br><span class="line">    &quot;55534064877048198&quot;,</span><br><span class="line">    &quot;212336130412243110&quot;,</span><br><span class="line">    &quot;812944042149730764&quot;,</span><br><span class="line">    &quot;3116285494907301262&quot;,</span><br><span class="line">    &quot;11959798385860453492&quot;,</span><br><span class="line">    &quot;45950804324621742364&quot;,</span><br><span class="line">    &quot;176733862787006701400&quot;,</span><br><span class="line">    &quot;680425371729975800390&quot;,</span><br><span class="line">    &quot;2622127042276492108820&quot;,</span><br><span class="line">    &quot;10113918591637898134020&quot;,</span><br><span class="line">    &quot;39044429911904443959240&quot;,</span><br><span class="line">    &quot;150853479205085351660700&quot;,</span><br><span class="line">    &quot;583300119592996693088040&quot;,</span><br><span class="line">    &quot;2257117854077248073253720&quot;,</span><br><span class="line">    &quot;8740328711533173390046320&quot;,</span><br><span class="line">    &quot;33868773757191046886429490&quot;,</span><br><span class="line">    &quot;131327898242169365477991900&quot;,</span><br><span class="line">    &quot;509552245179617138054608572&quot;,</span><br><span class="line">    &quot;1978261657756160653623774456&quot;,</span><br><span class="line">    &quot;7684785670514316385230816156&quot;,</span><br><span class="line">    &quot;29869166945772625950142417512&quot;,</span><br><span class="line">    &quot;116157871455782434250553845880&quot;,</span><br><span class="line">    &quot;451959718027953471447609509424&quot;,</span><br><span class="line">    &quot;1759414616608818870992479875972&quot;,</span><br><span class="line">    &quot;6852456927844873497549658464312&quot;,</span><br><span class="line">    &quot;26700952856774851904245220912664&quot;,</span><br><span class="line">    &quot;104088460289122304033498318812080&quot;,</span><br><span class="line">    &quot;405944995127576985730643443367112&quot;,</span><br><span class="line">    &quot;1583850964596120042686772779038896&quot;,</span><br><span class="line">    &quot;6182127958584855650487080847216336&quot;,</span><br><span class="line">    &quot;24139737743045626825711458546273312&quot;,</span><br><span class="line">    &quot;94295850558771979787935384946380125&quot;,</span><br><span class="line">    &quot;368479169875816659479009042713546950&quot;,</span><br><span class="line">    &quot;1440418573150919668872489894243865350&quot;,</span><br><span class="line">    &quot;5632681584560312734993915705849145100&quot;,</span><br><span class="line">    &quot;22033725021956517463358552614056949950&quot;,</span><br><span class="line">    &quot;86218923998960285726185640663701108500&quot;,</span><br><span class="line">    &quot;337485502510215975556783793455058624700&quot;,</span><br><span class="line">    &quot;1321422108420282270489942177190229544600&quot;,</span><br><span class="line">    &quot;5175569924646105559418940193995065716350&quot;,</span><br><span class="line">    &quot;20276890389709399862928998568254641025700&quot;,</span><br><span class="line">    &quot;79463489365077377841208237632349268884500&quot;,</span><br><span class="line">    &quot;311496878311103321137536291518809134027240&quot;,</span><br><span class="line">    &quot;1221395654430378811828760722007962130791020&quot;,</span><br><span class="line">    &quot;4790408930363303911328386208394864461024520&quot;,</span><br><span class="line">    &quot;18793142726809884575211361279087545193250040&quot;,</span><br><span class="line">    &quot;73745243611532458459690151854647329239335600&quot;,</span><br><span class="line">    &quot;289450081175264899454283846029490767264392230&quot;,</span><br><span class="line">    &quot;1136359577947336271931632877004667456667613940&quot;,</span><br><span class="line">    &quot;4462290049988320482463241297506133183499654740&quot;,</span><br><span class="line">    &quot;17526585015616776834735140517915655636396234280&quot;,</span><br><span class="line">    &quot;68854441132780194707888052034668647142985206100&quot;,</span><br><span class="line">    &quot;270557451039395118028642463289168566420671280440&quot;,</span><br><span class="line">    &quot;1063353702922273835973036658043476458723103404520&quot;,</span><br><span class="line">    &quot;4180080073556524734514695828170907458428751314320&quot;,</span><br><span class="line">    &quot;16435314834665426797069144960762886143367590394940&quot;,</span><br><span class="line">    &quot;64633260585762914370496637486146181462681535261000&quot;,</span><br><span class="line">    &quot;254224158304000796523953440778841647086547372026600&quot;,</span><br><span class="line">    &quot;1000134600800354781929399250536541864362461089950800&quot;,</span><br><span class="line">    &quot;3935312233584004685417853572763349509774031680023800&quot;,</span><br><span class="line">    &quot;15487357822491889407128326963778343232013931127835600&quot;,</span><br><span class="line">    &quot;60960876535340415751462563580829648891969728907438000&quot;,</span><br><span class="line">    &quot;239993345518077005168915776623476723006280827488229600&quot;,</span><br><span class="line">    &quot;944973797977428207852605870454939596837230758234904050&quot;,</span><br><span class="line">    &quot;3721443204405954385563870541379246659709506697378694300&quot;,</span><br><span class="line">    &quot;14657929356129575437016877846657032761712954950899755100&quot;,</span><br><span class="line">    &quot;57743358069601357782187700608042856334020731624756611000&quot;,</span><br><span class="line">    &quot;227508830794229349661819540395688853956041682601541047340&quot;,</span><br><span class="line">    &quot;896519947090131496687170070074100632420837521538745909320&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;i)!=EOF)&#123;</span><br><span class="line">		cout&lt;&lt;catalan[i-1]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h2><h3 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define RI register int</span><br><span class="line">const int N=200005,mod=998244353,G=3;</span><br><span class="line">int n,A,B,ans,a[18][N],rev[N];</span><br><span class="line">int ksm(int x,int y) &#123;</span><br><span class="line">	int re=1;</span><br><span class="line">	for(RI i=y;i;i&gt;&gt;=1,x=1LL*x*x%mod) if(i&amp;1) re=1LL*re*x%mod;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">void NTT(int *a,int n,int x) &#123;</span><br><span class="line">	for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">	for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123;</span><br><span class="line">		int gn=ksm(G,(mod-1)/(i&lt;&lt;1));</span><br><span class="line">		for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123;</span><br><span class="line">			int g=1,t1,t2;</span><br><span class="line">			for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123;</span><br><span class="line">				t1=a[j+k],t2=1LL*g*a[j+i+k]%mod;</span><br><span class="line">				a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x==1) return;</span><br><span class="line">	int inv=ksm(n,mod-2);reverse(a+1,a+n);//a+1!!!</span><br><span class="line">	for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">void work(int s,int t,int d) &#123;</span><br><span class="line">	if(s==t) &#123;a[d][0]=s,a[d][1]=1;return;&#125;</span><br><span class="line">	int mid=(s+t)&gt;&gt;1,len=0,kn=1;</span><br><span class="line">	work(s,mid,d+1);</span><br><span class="line">	for(RI i=0;i&lt;=mid-s+1;++i) a[d][i]=a[d+1][i];</span><br><span class="line">	work(mid+1,t,d+1);</span><br><span class="line">	while(kn&lt;=t-s+1) kn&lt;&lt;=1,++len;</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1));</span><br><span class="line">	for(RI i=mid-s+2;i&lt;kn;++i) a[d][i]=0;</span><br><span class="line">	for(RI i=t-mid+1;i&lt;kn;++i) a[d+1][i]=0;</span><br><span class="line">	NTT(a[d],kn,1),NTT(a[d+1],kn,1);</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) a[d][i]=1LL*a[d][i]*a[d+1][i]%mod;</span><br><span class="line">	NTT(a[d],kn,-1);</span><br><span class="line">&#125;</span><br><span class="line">int C(int d,int u) &#123;</span><br><span class="line">	int k1=1,k2=1;</span><br><span class="line">	for(RI i=d-u+1;i&lt;=d;++i) k1=1LL*k1*i%mod;</span><br><span class="line">	for(RI i=1;i&lt;=u;++i) k2=1LL*k2*i%mod;</span><br><span class="line">	return 1LL*k1*ksm(k2,mod-2)%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;A,&amp;B);</span><br><span class="line">	if(!A||!B||A+B-2&gt;n-1) &#123;puts(&quot;0&quot;);return 0;&#125;</span><br><span class="line">	if(n==1) &#123;puts(&quot;1&quot;);return 0;&#125;</span><br><span class="line">	work(0,n-2,0);</span><br><span class="line">	ans=1LL*a[0][A+B-2]*C(A+B-2,B-1)%mod;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define RI register int</span><br><span class="line">const int mod=998244353,G=3,N=262150;</span><br><span class="line">int n,kn,len,ans;</span><br><span class="line">int a[N],b[N],fac[N],ni[N],rev[N];</span><br><span class="line">int ksm(int x,int y) &#123;</span><br><span class="line">	int re=1;</span><br><span class="line">	for(;y;y&gt;&gt;=1,x=1LL*x*x%mod) if(y&amp;1) re=1LL*re*x%mod;</span><br><span class="line">	return re;</span><br><span class="line">&#125;</span><br><span class="line">void NTT(int *a,int n,int x) &#123;</span><br><span class="line">    for(RI i=0;i&lt;n;++i) if(rev[i]&gt;i) swap(a[i],a[rev[i]]);</span><br><span class="line">    for(RI i=1;i&lt;n;i&lt;&lt;=1) &#123;</span><br><span class="line">        int gn=ksm(G,(mod-1)/(i&lt;&lt;1));</span><br><span class="line">        for(RI j=0;j&lt;n;j+=(i&lt;&lt;1)) &#123;</span><br><span class="line">            int g=1,t1,t2;</span><br><span class="line">            for(RI k=0;k&lt;i;++k,g=1LL*g*gn%mod) &#123;</span><br><span class="line">                t1=a[j+k],t2=1LL*g*a[j+i+k]%mod;</span><br><span class="line">                a[j+k]=(t1+t2)%mod,a[j+i+k]=(t1-t2+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==1) return;</span><br><span class="line">    int inv=ksm(n,mod-2);reverse(a+1,a+n);</span><br><span class="line">    for(RI i=0;i&lt;n;++i) a[i]=1LL*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	fac[0]=1;for(RI i=1;i&lt;=n;++i) fac[i]=1LL*fac[i-1]*i%mod;</span><br><span class="line">	ni[n]=ksm(fac[n],mod-2);</span><br><span class="line">	for(RI i=n-1;i&gt;=0;--i) ni[i]=1LL*ni[i+1]*(i+1)%mod;</span><br><span class="line">	for(RI i=0;i&lt;=n;++i) &#123;</span><br><span class="line">		a[i]=1LL*(1-2*(i&amp;1)+mod)%mod*ni[i]%mod;</span><br><span class="line">		if(i!=1) b[i]=1LL*(ksm(i,n+1)-1+mod)%mod*ni[i]%mod*ksm(i-1+mod,mod-2)%mod;</span><br><span class="line">		else b[i]=n+1;</span><br><span class="line">	&#125;</span><br><span class="line">	kn=1;while(kn&lt;=n+n) kn&lt;&lt;=1,++len;</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(len-1));</span><br><span class="line">	NTT(a,kn,1),NTT(b,kn,1);</span><br><span class="line">	for(RI i=0;i&lt;kn;++i) a[i]=1LL*a[i]*b[i]%mod;</span><br><span class="line">	NTT(a,kn,-1);</span><br><span class="line">	for(RI i=0,j=1;i&lt;=n;++i,j=(j+j)%mod)</span><br><span class="line">		ans=(ans+1LL*j*fac[i]%mod*a[i]%mod)%mod;</span><br><span class="line">	printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>逆元(Inverse element)就是在mod意义下，不能直接除以一个数，而要乘以它的逆元。<br>比如a∗b≡1(modp)a∗b≡1(modp)，那么a，b互为模n意义下的逆元，比如你要算x/a，就可以改成x*b%p</p>
<p>观察a∗b≡1(modp)a∗b≡1(modp),变形为a∗b+k∗p=1a∗b+k∗p=1，就可以用扩展欧几里得算法求a了，同时这里也说明了a和p只有在互素的情况下才存在逆元。</p>
<p>注意<br>在下面所有的算法中，最好先把除数取个模再运算。</p>
<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>原理<br>a∗b≡1(modp)a∗b≡1(modp)<br>a∗b+k∗p=1a∗b+k∗p=1<br>然后a就是我们要求的逆元，最终得到一个正数a的话就要对a mod p，因为a加上mp的时侯k减少mb可以使得等式依然成立。</p>
<p>如果你不想让逆元为正数，那么直接返回x也是可以正确的逆元</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y)//扩展欧几里得算法 </span><br><span class="line">&#123;</span><br><span class="line">    if(b==0)</span><br><span class="line">    &#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(int a,int mod)//求a在mod下的逆元，不存在逆元返回-1 </span><br><span class="line">&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL d=exgcd(a,mod,x,y);</span><br><span class="line">    return d==1?(x%mod+mod)%mod:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：返回的时候可以改成(x+mod)%mod，因为扩展欧几里得算法算出来的x应该不会太大.</p>
<p>性能分析:</p>
<p>时间复杂度:O(logn)（实际是斐波那契数列）<br>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</p>
<h3 id="费马小定理-欧拉定理"><a href="#费马小定理-欧拉定理" class="headerlink" title="费马小定理/欧拉定理"></a>费马小定理/欧拉定理</h3><p>原理<br>费马小定理：若p为素数，则有ap−1≡1(modp)ap−1≡1(modp)<br>ap−2∗a≡1(modp)ap−2∗a≡1(modp)<br>ap−2ap−2就是a在mod p意义下的逆元啦。</p>
<p>欧拉定理：若a、p互素，则有aφ(p)≡1(modp)aφ(p)≡1(modp)(费马小定理的一般形式)<br>aφ(p)∗a≡1(modp)aφ(p)∗a≡1(modp)<br>aφ(p)−1aφ(p)−1就是a在mod p意义下的逆元啦。</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL qkpow(LL a,LL p,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    LL t=1,tt=a%mod;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p&amp;1)t=t*tt%mod;</span><br><span class="line">        tt=tt*tt%mod;</span><br><span class="line">        p&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line">LL getInv(LL a,LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    return qkpow(a,mod-2,mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<p>O(logmod)<br>适用范围：一般在mod是个素数的时候用，比扩欧快一点而且好写。<br>但是如果是合数，相信一般没人无聊到去算个欧拉函数。</p>
<h3 id="递推求逆元"><a href="#递推求逆元" class="headerlink" title="递推求逆元"></a>递推求逆元</h3><p>原理<br>p是模数，i是待求的逆元，我们求的是i−1i−1在mod p意义下的值<br>p=k∗i+rp=k∗i+r令 r &lt; i,则k=p/i,r=p%i<br>k∗i+r≡0(modp)k∗i+r≡0(modp)<br>k∗r−1+i−1≡0(modp)k∗r−1+i−1≡0(modp)<br>i−1≡−k∗r−1(modp)i−1≡−k∗r−1(modp)<br>i−1≡−p/i∗inv[pmodi]i−1≡−p/i∗inv[pmodi]<br>嗯。。好难看的公式<br>说白了就是:inv[i]=-(mod/i)*inv[i%mod]<br>然后边界是inv[1]=1<br>这不仅为我们提供了一个线性求逆元的方法，也提供了一种O(logmod)求逆元的方法</p>
<p>代码<br>线性求逆元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LL inv[mod+5];</span><br><span class="line">void getInv(LL mod)</span><br><span class="line">&#123;</span><br><span class="line">    inv[1]=1;</span><br><span class="line">    for(int i=2;i&lt;mod;i++)</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>调用前要先预处理<br>调用的时候要先对除数取mod<br>性能分析：</p>
<p>时间复杂度O(n)<br>适用范围：mod数是不大的素数而且多次调用，比如卢卡斯定理。<br>递归求逆元</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LL inv(LL i)</span><br><span class="line">&#123;</span><br><span class="line">    if(i==1)return 1;</span><br><span class="line">    return (mod-mod/i)*inv(mod%i)%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析</p>
<p>时间复杂度:O(logmod)<br>好像找到了最简单的算法了！！</p>
<p>适用范围： mod数是素数，所以并不好用，比如中国剩余定理中就不好使，因为很多时候可能会忘记考虑mod数是不是素数。</p>
<h2 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><h3 id="费马小定理实现"><a href="#费马小定理实现" class="headerlink" title="费马小定理实现"></a>费马小定理实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll mulit(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=0;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll quick_mod(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans=mulit(ans,a,m);</span><br><span class="line">        &#125;</span><br><span class="line">        a=mulit(a,a,m);</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll comp(ll a,ll b,ll m)&#123;</span><br><span class="line">    if(a&lt;b) return 0;</span><br><span class="line">    if(a==b) return 1;</span><br><span class="line">    if(b&gt;a-b) b=a-b;</span><br><span class="line">    ll ans=1,ca=1,cb=1;</span><br><span class="line">    for(int i=0;i&lt;b;i++)&#123;</span><br><span class="line">        ca=ca*(a-i)%m;</span><br><span class="line">        cb=cb*(b-i)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=ca*quick_mod(cb,m-2,m)%m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lucas(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(a&amp;&amp;b)&#123;</span><br><span class="line">        ans=(ans*comp(a%m,b%m,m))%m;</span><br><span class="line">        a/=m;</span><br><span class="line">        b/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,m;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;m)&#123;</span><br><span class="line">        cout&lt;&lt;lucas(a,b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exgcd实现"><a href="#exgcd实现" class="headerlink" title="exgcd实现"></a>exgcd实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll exgcd(ll a,ll b,ll&amp; x,ll&amp; y)&#123;</span><br><span class="line">    if(a%b==0)&#123;</span><br><span class="line">        x=0,y=1;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r,tx,ty;</span><br><span class="line">    r=exgcd(b,a%b,tx,ty);</span><br><span class="line">    x=ty;</span><br><span class="line">    y=tx-a/b*ty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll comp(ll a,ll b,ll m)&#123;</span><br><span class="line">    if(a&lt;b) return 0;</span><br><span class="line">    if(a==b) return 1;</span><br><span class="line">    if(b&gt;a-b) b=a-b;</span><br><span class="line">    ll ans=1,ca=1,cb=1;</span><br><span class="line">    for(int i=0;i&lt;b;i++)&#123;</span><br><span class="line">        ca=ca*(a-i)%m;</span><br><span class="line">        cb=cb*(b-i)%m;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x,y;</span><br><span class="line">    exgcd(cb,m,x,y);</span><br><span class="line">    x=(x%m+m)%m;</span><br><span class="line">    ans=ca*x%m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll lucas(ll a,ll b,ll m)&#123;</span><br><span class="line">    ll ans=1;</span><br><span class="line">    while(a&amp;&amp;b)&#123;</span><br><span class="line">        ans=(ans*comp(a%m,b%m,m))%m;</span><br><span class="line">        a/=m;</span><br><span class="line">        b/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a,b,m;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">        cout&lt;&lt;lucas(a+b,b,m)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 1000000;</span><br><span class="line">bool check[MAXN+10];</span><br><span class="line">int prime[MAXN+10];</span><br><span class="line">int mu[MAXN+10];</span><br><span class="line">void Moblus()</span><br><span class="line">&#123;</span><br><span class="line">    memset(check,false,sizeof(check));</span><br><span class="line">    mu[1] = 1;</span><br><span class="line">    int tot = 0;</span><br><span class="line">    for(int i = 2; i &lt;= MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if( !check[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            prime[tot++] = i;</span><br><span class="line">            mu[i] = −1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt; tot; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i * prime[j] &gt; MAXN)</span><br><span class="line">                break;</span><br><span class="line">            check[i * prime[j]] = true;</span><br><span class="line">            if( i % prime[j] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * prime[j]] = −mu[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="莫比乌斯Euler打表"><a href="#莫比乌斯Euler打表" class="headerlink" title="莫比乌斯Euler打表"></a>莫比乌斯Euler打表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN=1e2;</span><br><span class="line"></span><br><span class="line">int phi[MAXN],n,tot;</span><br><span class="line">int pri[MAXN];</span><br><span class="line">bool mark[MAXN];</span><br><span class="line"></span><br><span class="line">void getphi()&#123;</span><br><span class="line">    phi[1]=1;</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!mark[i])&#123;</span><br><span class="line">            phi[i]=i-1;</span><br><span class="line">            pri[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=tot;j++)&#123;</span><br><span class="line">            int x=pri[j];</span><br><span class="line">            if(i*x&gt;n) break;</span><br><span class="line">            mark[i*x]=1;</span><br><span class="line">            if(i%x==0)&#123;</span><br><span class="line">                phi[i*x]=phi[i]*x;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else phi[i*x]=phi[i]*phi[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))&#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        getphi();</span><br><span class="line"></span><br><span class="line">            printf(&quot;%d\n&quot;,phi[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="miller-rabin，Pollard-rho算法"><a href="#miller-rabin，Pollard-rho算法" class="headerlink" title="miller-rabin，Pollard_rho算法"></a>miller-rabin，Pollard_rho算法</h2><h3 id="大素数判断和素因子分解"><a href="#大素数判断和素因子分解" class="headerlink" title="大素数判断和素因子分解"></a>大素数判断和素因子分解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//****************************************************************</span><br><span class="line">// Miller_Rabin 算法进行素数测试</span><br><span class="line">//速度快，而且可以判断 &lt;2^63的数</span><br><span class="line">//****************************************************************</span><br><span class="line">const int S=20;//随机算法判定次数，S越大，判错概率越小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的</span><br><span class="line">//  a,b,c &lt;2^63</span><br><span class="line">long long mult_mod(long long a,long long b,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    a%=c;</span><br><span class="line">    b%=c;</span><br><span class="line">    long long ret=0;</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(b&amp;1)&#123;ret+=a;ret%=c;&#125;</span><br><span class="line">        a&lt;&lt;=1;</span><br><span class="line">        if(a&gt;=c)a%=c;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//计算  x^n %c</span><br><span class="line">long long pow_mod(long long x,long long n,long long mod)//x^n%c</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1)return x%mod;</span><br><span class="line">    x%=mod;</span><br><span class="line">    long long tmp=x;</span><br><span class="line">    long long ret=1;</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1) ret=mult_mod(ret,tmp,mod);</span><br><span class="line">        tmp=mult_mod(tmp,tmp,mod);</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数</span><br><span class="line">//一定是合数返回true,不一定返回false</span><br><span class="line">bool check(long long a,long long n,long long x,long long t)</span><br><span class="line">&#123;</span><br><span class="line">    long long ret=pow_mod(a,x,n);</span><br><span class="line">    long long last=ret;</span><br><span class="line">    for(int i=1;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=mult_mod(ret,ret,n);</span><br><span class="line">        if(ret==1&amp;&amp;last!=1&amp;&amp;last!=n-1) return true;//合数</span><br><span class="line">        last=ret;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ret!=1) return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Miller_Rabin()算法素数判定</span><br><span class="line">//是素数返回true.(可能是伪素数，但概率极小)</span><br><span class="line">//合数返回false;</span><br><span class="line"></span><br><span class="line">bool Miller_Rabin(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;2)return false;</span><br><span class="line">    if(n==2)return true;</span><br><span class="line">    if((n&amp;1)==0) return false;//偶数</span><br><span class="line">    long long x=n-1;</span><br><span class="line">    long long t=0;</span><br><span class="line">    while((x&amp;1)==0)&#123;x&gt;&gt;=1;t++;&#125;</span><br><span class="line">    for(int i=0;i&lt;S;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件</span><br><span class="line">        if(check(a,n,x,t))</span><br><span class="line">            return false;//合数</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//************************************************</span><br><span class="line">//pollard_rho 算法进行质因数分解</span><br><span class="line">//************************************************</span><br><span class="line">long long factor[100];//质因数分解结果（刚返回时是无序的）</span><br><span class="line">int tol;//质因数的个数。数组小标从0开始</span><br><span class="line"></span><br><span class="line">long long gcd(long long a,long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a==0)return 1;//???????</span><br><span class="line">    if(a&lt;0) return gcd(-a,b);</span><br><span class="line">    while(b)</span><br><span class="line">    &#123;</span><br><span class="line">        long long t=a%b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Pollard_rho(long long x,long long c)</span><br><span class="line">&#123;</span><br><span class="line">    long long i=1,k=2;</span><br><span class="line">    long long x0=rand()%x;</span><br><span class="line">    long long y=x0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        x0=(mult_mod(x0,x0,x)+c)%x;</span><br><span class="line">        long long d=gcd(y-x0,x);</span><br><span class="line">        if(d!=1&amp;&amp;d!=x) return d;</span><br><span class="line">        if(y==x0) return x;</span><br><span class="line">        if(i==k)&#123;y=x0;k+=k;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对n进行素因子分解</span><br><span class="line">void findfac(long long n)</span><br><span class="line">&#123;</span><br><span class="line">    if(Miller_Rabin(n))//素数</span><br><span class="line">    &#123;</span><br><span class="line">        factor[tol++]=n;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    long long p=n;</span><br><span class="line">    while(p&gt;=n)p=Pollard_rho(p,rand()%(n-1)+1);</span><br><span class="line">    findfac(p);</span><br><span class="line">    findfac(n/p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话</span><br><span class="line">    long long n;</span><br><span class="line">    while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tol=0;</span><br><span class="line">        findfac(n);</span><br><span class="line">        for(int i=0;i&lt;tol;i++)printf(&quot;%I64d &quot;,factor[i]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        if(Miller_Rabin(n))printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int pow_mod(int a, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1)&#123;</span><br><span class="line">            ans = (ans * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, n, m;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; pow_mod(a, n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int N=10;  </span><br><span class="line">int tmp[N][N];  </span><br><span class="line">void multi(int a[][N],int b[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(tmp,0,sizeof tmp);  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        for(int k=0;k&lt;n;k++)  </span><br><span class="line">        tmp[i][j]+=a[i][k]*b[k][j];  </span><br><span class="line">    for(int i=0;i&lt;n;i++)  </span><br><span class="line">        for(int j=0;j&lt;n;j++)  </span><br><span class="line">        a[i][j]=tmp[i][j];  </span><br><span class="line">&#125;  </span><br><span class="line">int res[N][N];  </span><br><span class="line">void Pow(int a[][N],int n)  </span><br><span class="line">&#123;  </span><br><span class="line">    memset(res,0,sizeof res);//n是幂，N是矩阵大小  </span><br><span class="line">    for(int i=0;i&lt;N;i++) res[i][i]=1;  </span><br><span class="line">    while(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(n&amp;1)  </span><br><span class="line">            multi(res,a,N);//res=res*a;复制直接在multi里面实现了；  </span><br><span class="line">        multi(a,a,N);//a=a*a  </span><br><span class="line">        n&gt;&gt;=1;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><p>如果要求模的常数是一个64bit整数，那么在做乘法时，就没有扩展类型使用，必须手写一个高精度整数运算。</p>
<h3 id="O-logn-快速乘"><a href="#O-logn-快速乘" class="headerlink" title="O(logn)快速乘"></a>O(logn)快速乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline LL quick_mul(LL a,LL n,LL m)&#123;</span><br><span class="line">    LL ans=0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) ans=(ans+a)%m;</span><br><span class="line">        a=(a&lt;&lt;1)%m;</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-1-快速乘"><a href="#O-1-快速乘" class="headerlink" title="O(1)快速乘"></a>O(1)快速乘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">#define MOL 123456789012345LL</span><br><span class="line">inline ll mul_mod_ll(ll a,ll b)&#123;</span><br><span class="line">    ll d=(ll)floor(a*(long double)b/MOL+0.5);</span><br><span class="line">    ll ret=a*b-d*MOL;</span><br><span class="line">    if(ret&lt;0)   ret+=MOL;</span><br><span class="line">    return   ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，使用浮点数计算 a<em>b/MOL 的值，关键在于第二句，显然 a</em>b - d*MOL 两个乘法都可能溢出，不过没关系，因为可以预见，其差是一个64bit可以容纳的正整数，那么溢出部分的差仅可能是0或者1。最后一句符号的特判用来处理溢出部分差为1的情况。</p>
<p>考虑到计算 a*b/MOL 使用了浮点数计算，误差是不可避免的，故建议不要用太大的MOL使用这个方法。</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline ll ksc(ll x,ll y,ll mod)&#123;</span><br><span class="line">    return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为x,y都是mod意义下的，保证了x*y/mod不会爆long long。</p>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 高斯消元法</span><br><span class="line">* Description : 求解线性方程组</span><br><span class="line">*</span><br><span class="line">* void exchange_col(int p1,int p2,int n)</span><br><span class="line">* 交换 p1 行和 p2 行的所有数据</span><br><span class="line">*</span><br><span class="line">* bool gauss(int n)</span><br><span class="line">* 求解系数矩阵为 n 的线性方程组，方程组无解返回 false，否则 true</span><br><span class="line">*</span><br><span class="line">* x1 = x0 - f(x0)/f&apos;(x0) 牛顿迭代法</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">const int num = 100;</span><br><span class="line">double matrix[num][num + 1]; //系数矩阵，从 0 开始</span><br><span class="line">double ans[num]; //结果数组</span><br><span class="line">void exchange_col(int p1,int p2,int n) //交换 p1 行和 p2 行的所有数据</span><br><span class="line">&#123;</span><br><span class="line">    double t;</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0 ; i &lt;= n ; i++)</span><br><span class="line">        t = matrix[p1][i],matrix[p1][i] = matrix[p2][i],matrix[p2][i] = t;</span><br><span class="line">&#125;</span><br><span class="line">bool gauss(int n) //求解系数矩阵为 n 的线性方程组</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    int p;</span><br><span class="line">    double r;</span><br><span class="line">    for(i = 0 ; i &lt; n - 1 ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = i;</span><br><span class="line">        for(j = i + 1 ; j &lt; n ; j++)   //寻找 i 列绝对值最大值位置</span><br><span class="line">        &#123;</span><br><span class="line">            if(abs(matrix[j][i]) &gt; abs(matrix[p][i]))</span><br><span class="line">                p = j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p != i)</span><br><span class="line">            exchange_col(i,p,n);</span><br><span class="line">        if(matrix[i][i] == 0)</span><br><span class="line">            return false;</span><br><span class="line">        for(j = i + 1 ; j &lt; n ; j++)   //剩余列进行消元</span><br><span class="line">        &#123;</span><br><span class="line">            r = matrix[j][i] / matrix[i][i];</span><br><span class="line">            for(k = i ; k &lt;= n ; k++)</span><br><span class="line">                matrix[j][k] -= r * matrix[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = n - 1 ; i &gt;= 0 ; i--)   //获得结果</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = matrix[i][n];</span><br><span class="line">        for(j = n - 1 ; j &gt; i ; j--)</span><br><span class="line">            ans[i] -= matrix[i][j] * ans[j];</span><br><span class="line">        if(matrix[i][i] == 0)</span><br><span class="line">            return false;</span><br><span class="line">        ans[i] /= matrix[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全排列全组合"><a href="#全排列全组合" class="headerlink" title="全排列全组合"></a>全排列全组合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 全排列,全组合</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">void createper(int n) //全排列</span><br><span class="line">&#123;</span><br><span class="line">    int total,i,j,k,t,*a=new int[n],top;</span><br><span class="line">    total=1;</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=i;</span><br><span class="line">        total*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1; i&lt;n; i++)</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    for(i=1; i&lt;total; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j=n;</span><br><span class="line">        while(a[j]&lt;a[j-1])</span><br><span class="line">            j--;</span><br><span class="line">        k=n;</span><br><span class="line">        while(a[j-1]&gt;a[k])</span><br><span class="line">            k--;</span><br><span class="line">        t=a[j-1];</span><br><span class="line">        a[j-1]=a[k];</span><br><span class="line">        a[k]=t;</span><br><span class="line">        top=(j+n-1)/2;</span><br><span class="line">        for(k=j; k&lt;=top; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            t=a[k];</span><br><span class="line">            a[k]=a[n-k+j];</span><br><span class="line">            a[n-k+j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=1; j&lt;n; j++)</span><br><span class="line">            printf(&quot;%d &quot;,a[j]);</span><br><span class="line">        printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void createfab(int m,int n) //全组合</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,lcount,*a=new int[n+2];</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">        a[i]=i;</span><br><span class="line">    a[n+1]=m+1;</span><br><span class="line">    for(j=1; j&lt;n; j++)</span><br><span class="line">        printf(&quot;%d &quot;,a[j]);</span><br><span class="line">    printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">    lcount=1;</span><br><span class="line">    while(a[1]&lt;m-n+1)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=n; i&gt;0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i]&lt;a[i+1]-1)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i]++;</span><br><span class="line">                for(j=i; j&lt;n; j++)</span><br><span class="line">                    a[j+1]=a[j]+1;</span><br><span class="line">                for(j=1; j&lt;n; j++)</span><br><span class="line">                    printf(&quot;%d &quot;,a[j]);</span><br><span class="line">                printf(&quot;%d\n&quot;,a[n]);</span><br><span class="line">                lcount++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// Author: Tanky Woo</span><br><span class="line">// www.wutianqi.com</span><br><span class="line">const int _max = 10001; </span><br><span class="line">// c1是保存各项质量砝码可以组合的数目</span><br><span class="line">// c2是中间量，保存每一次的情况</span><br><span class="line">int c1[_max], c2[_max];   </span><br><span class="line">int main()</span><br><span class="line">&#123;	//int n,i,j,k;</span><br><span class="line">	int nNum;   // </span><br><span class="line">	int i, j, k;</span><br><span class="line"> </span><br><span class="line">	while(cin &gt;&gt; nNum)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0; i&lt;=nNum; ++i)   // ---- ①</span><br><span class="line">		&#123;</span><br><span class="line">			c1[i] = 1;</span><br><span class="line">			c2[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		for(i=2; i&lt;=nNum; ++i)   // ----- ②</span><br><span class="line">		&#123;</span><br><span class="line"> </span><br><span class="line">			for(j=0; j&lt;=nNum; ++j)   // ----- ③</span><br><span class="line">				for(k=0; k+j&lt;=nNum; k+=i)  // ---- ④</span><br><span class="line">				&#123;</span><br><span class="line">					c2[j+k] += c1[j];</span><br><span class="line">				&#125;</span><br><span class="line">				for(j=0; j&lt;=nNum; ++j)     // ---- ⑤</span><br><span class="line">				&#123;</span><br><span class="line">					c1[j] = c2[j];</span><br><span class="line">					c2[j] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; c1[nNum] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[10]=&#123;0&#125;;</span><br><span class="line">int k;</span><br><span class="line">void getp(int n)</span><br><span class="line">&#123;</span><br><span class="line">	k=0;</span><br><span class="line">	for(int i=2;i*i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(n%i==0)</span><br><span class="line">		&#123;</span><br><span class="line">			p[k++]=i;	</span><br><span class="line">		&#125;</span><br><span class="line">		while(n%i==0)</span><br><span class="line">			n/=i;</span><br><span class="line">	&#125;</span><br><span class="line">	if(n&gt;1) p[k++]=n;</span><br><span class="line">&#125;</span><br><span class="line">int nop(int m)</span><br><span class="line">&#123;</span><br><span class="line">	int que[1000];</span><br><span class="line">	int top=0;</span><br><span class="line">	que[top++]=-1;</span><br><span class="line">	for(int i=0;i&lt;k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int t=top;</span><br><span class="line">		for(int j=0;j&lt;t;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			que[top++]=que[j]*p[i]*(-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=1;i&lt;top;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=m/que[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	getp(n);</span><br><span class="line">	printf(&quot;%d\n&quot;,m-nop(m));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;</span><br><span class="line">    if (!b) &#123;x = 1; y = 0; return a;&#125;</span><br><span class="line">    long long d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long inv(long long a, long long n) &#123;</span><br><span class="line">    long long x, y;</span><br><span class="line">    exgcd(a, n, x, y);</span><br><span class="line">    return (x + n) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long pow_mod(long long x, long long k, long long n) &#123;</span><br><span class="line">    if (k == 0) return 1;</span><br><span class="line">    long long ans = pow_mod(x * x % n, k&gt;&gt;1, n);</span><br><span class="line">    if (k&amp;1)</span><br><span class="line">    ans = ans * x % n;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long log_mod(long long a, long long b, long long n) &#123;</span><br><span class="line">    long long m = (long long)sqrt(n + 0.5), v, e = 1, i;</span><br><span class="line">    v = inv(pow_mod(a, m, n), n);</span><br><span class="line">    map&lt;long long, long long&gt; x;</span><br><span class="line">    x[1] = 0;</span><br><span class="line">    for (long long i = 1; i &lt; m; i++) &#123;</span><br><span class="line">    e = e * a % n;</span><br><span class="line">    if (!x.count(e)) x[e] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (long long i = 0; i &lt; m; i++) &#123;</span><br><span class="line">    if (x.count(b)) return i * m + x[b];</span><br><span class="line">    b = b * v % n;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const long long MOD = 100000007;</span><br><span class="line">long long n, k, b, r, Max, x[505], y[505];</span><br><span class="line">typedef pair&lt;long long, long long&gt; pii;</span><br><span class="line"></span><br><span class="line">set&lt;pii&gt; beats;</span><br><span class="line"></span><br><span class="line">long long cal() &#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++) &#123;</span><br><span class="line">    if (x[i] != Max &amp;&amp; !beats.count(make_pair(x[i] + 1, y[i])))</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += n;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++) if (x[i] == 1) ans--;</span><br><span class="line">    return pow_mod(k, ans,  MOD) * pow_mod(k - 1, Max * n - b - ans, MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long solve() &#123;</span><br><span class="line">    long long m = cal();</span><br><span class="line">    if (m == r) return Max;</span><br><span class="line">    long long tmp = n;</span><br><span class="line">    for (long long i = 0; i &lt; b; i++)</span><br><span class="line">    if (x[i] == Max) tmp--;</span><br><span class="line">    long long ans = pow_mod(k - 1, tmp, MOD) * pow_mod(k, n - tmp, MOD) % MOD;</span><br><span class="line">    m = m * ans % MOD;</span><br><span class="line">    if (m == r) return Max + 1;</span><br><span class="line">    return log_mod(pow_mod(k - 1, n, MOD), r * inv(m, MOD) % MOD, MOD) + Max + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    while (~scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;k, &amp;b, &amp;r)) &#123;</span><br><span class="line">    beats.clear();</span><br><span class="line">    Max = 1;</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i &lt; b; i++) &#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line">        beats.insert(make_pair(x[i], y[i]));</span><br><span class="line">        Max = max(Max, x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld\n&quot;,solve());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自适应-simpson-积分"><a href="#自适应-simpson-积分" class="headerlink" title="自适应 simpson 积分"></a>自适应 simpson 积分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">double simpson(double a,double b)</span><br><span class="line">&#123;</span><br><span class="line">    double c = a + (b−a)/2;</span><br><span class="line">    return (F(a) + 4*F(c) + F(b))*(b−a)/6</span><br><span class="line">&#125;</span><br><span class="line">double asr(double a,double b,double eps,double A)</span><br><span class="line">&#123;</span><br><span class="line">    double c = a + (b−a)/2;</span><br><span class="line">    double L = simpson(a,c), R = simpson(c,b);</span><br><span class="line">    if(fabs(L + R − A) &lt;= 15*eps)</span><br><span class="line">        return L + R + (L + R − A)/15.0;</span><br><span class="line">    return asr(a,c,eps/2,L) + asr(c,b,eps/2,R)</span><br><span class="line">&#125;</span><br><span class="line">double asr(double a,double b,double eps)return asr(a,b,eps,simpson(a,b));</span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">const int HASH = 10007;</span><br><span class="line">const int MAXN = 2010;</span><br><span class="line">struct HASHMAP</span><br><span class="line">&#123;</span><br><span class="line">    int head[HASH],next[MAXN],size;</span><br><span class="line">    unsigned long long state[MAXN];</span><br><span class="line">    int f[MAXN];</span><br><span class="line">    void init()</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        memset(head,−1,sizeof(head));</span><br><span class="line">    &#125; int insert(unsigned long long val,int _id)</span><br><span class="line">    &#123;</span><br><span class="line">        int h = val%HASH;</span><br><span class="line">        for(int i = head[h]; i != −1; i = next[i])</span><br><span class="line">            if(val == state[i])</span><br><span class="line">            &#123;</span><br><span class="line">                int tmp = f[i];</span><br><span class="line">                f[i] = _id;</span><br><span class="line">                return tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        f[size] = _id;</span><br><span class="line">        state[size] = val;</span><br><span class="line">        next[size] = head[h];</span><br><span class="line">        head[h] = size++;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; H;</span><br><span class="line">const int SEED = 13331;</span><br><span class="line">unsigned long long P[MAXN];</span><br><span class="line">unsigned long long S[MAXN];</span><br><span class="line">char str[MAXN];</span><br><span class="line">int ans[MAXN][MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    P[0] = 1;</span><br><span class="line">    for(int i = 1; i &lt; MAXN; i++)</span><br><span class="line">        P[i] = P[i−1] * SEED;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T−−)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        int n = strlen(str);</span><br><span class="line">        S[0] = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)</span><br><span class="line">            S[i] = S[i−1]*SEED + str[i−1];</span><br><span class="line">        memset(ans,0,sizeof(ans));</span><br><span class="line">        for(int L = 1; L &lt;= n; L++)</span><br><span class="line">        &#123;</span><br><span class="line">            H.init();</span><br><span class="line">            for(int i = 1; i + L − 1 &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                int l = H.insert(S[i+L−1] − S[i−1]*P[L],i);</span><br><span class="line">                ans[i][i+L−1] ++;</span><br><span class="line">                ans[l][i+L−1]−−;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = n; i &gt;= 0; i−−)</span><br><span class="line">            for(int j = i; j &lt;= n; j++)</span><br><span class="line">                ans[i][j] += ans[i+1][j] + ans[i][j−1] − ans[i−1];</span><br><span class="line">        int m,u,v;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">        while(m−−)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            printf(&quot;%d\n&quot;,ans[u][v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串和数值hash"><a href="#字符串和数值hash" class="headerlink" title="字符串和数值hash"></a>字符串和数值hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 整数hash</span><br><span class="line">// 104729, 224737, 350377, 479909, 611953, 882377</span><br><span class="line">// 1020379, 1299709, 1583539, 1870667, 2015177</span><br><span class="line">// 4256233,5800079,7368787, 10570841, 15485863</span><br><span class="line">const int MOD = 20023;</span><br><span class="line">bool bhash[MOD];</span><br><span class="line">int vhash[MOD];</span><br><span class="line">int cnt[MOD];</span><br><span class="line">bool find_hash(int &amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    int val = pos;</span><br><span class="line">    pos %= MOD;</span><br><span class="line">    for (; bhash[pos]; pos=(pos+1)%MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        if (vhash[pos] == val)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int make_hash(int val)</span><br><span class="line">&#123;</span><br><span class="line">    int pos = val;</span><br><span class="line">    if (! find_hash(pos))</span><br><span class="line">    &#123;</span><br><span class="line">        bhash[pos] = true;</span><br><span class="line">        vhash[pos] = val;</span><br><span class="line">        cnt[pos] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[pos] ++;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br><span class="line">//字符串hash</span><br><span class="line">const int MOD = 20023;</span><br><span class="line">bool bhash[MOD];</span><br><span class="line">char vhash[MOD][45];</span><br><span class="line">char str[45];</span><br><span class="line">int cal_str()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, pos;</span><br><span class="line">    for (i=pos=0,j=1; str[i]; i++,j=(j*27)&amp;INT_MAX,pos&amp;=INT_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        int num = str[i] - &apos;a&apos;;</span><br><span class="line">        if (str[i] == &apos; &apos;)</span><br><span class="line">            num = 26;</span><br><span class="line">        pos += j*num;</span><br><span class="line">    &#125;</span><br><span class="line">    return pos % MOD;</span><br><span class="line">&#125;</span><br><span class="line">bool find_hash(int &amp; pos)</span><br><span class="line">&#123;</span><br><span class="line">    pos = cal_str();</span><br><span class="line">    for (; bhash[pos]; pos=(pos+1)%MOD)</span><br><span class="line">    &#123;</span><br><span class="line">        if (strcmp(vhash[pos], str) == 0)</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int make_hash()</span><br><span class="line">&#123;</span><br><span class="line">    int pos;</span><br><span class="line">    if (! find_hash(pos))</span><br><span class="line">    &#123;</span><br><span class="line">        bhash[pos] = true;</span><br><span class="line">        strcpy(vhash[pos], str);</span><br><span class="line">    &#125;</span><br><span class="line">    return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">int* CreateBC(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* bc = new int[256];</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; 256; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bc[i] = -1;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		bc[pattern[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; 256; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if(bc[i] != -1)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;bc[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; bc[i] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int* CreateSuffix(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* suffix = new int[len];</span><br><span class="line">	suffix[len - 1] = len;</span><br><span class="line"> </span><br><span class="line">	for(int i = len - 2; i &gt;= 0; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		int j = i;</span><br><span class="line">		for(; pattern[j] == pattern[len - 1 - i + j] &amp;&amp; j &gt;= 0; --j);</span><br><span class="line">		suffix[i] = i - j;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;suffix[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; suffix[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return suffix;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int* CreateGS(char* pattern, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int* suffix = CreateSuffix(pattern, len);</span><br><span class="line">	int* gs = new int[len];</span><br><span class="line">	/*</span><br><span class="line">	在计算gs数组时，从移动数最大的情况依次到移动数最少的情况赋值，</span><br><span class="line">	确保在合理的移动范围内，移动最少的距离，避免失配的情况。</span><br><span class="line">	*/</span><br><span class="line"> </span><br><span class="line">    //第三种情况</span><br><span class="line">	for(int i = 1; i &lt; len; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		gs[i] = len;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //第二种情况</span><br><span class="line">	for(int i = len - 1; i &gt;= 0; --i) //从右往左扫描，确保模式串移动最少。</span><br><span class="line">	&#123;</span><br><span class="line">		if(suffix[i] == i + 1) //是一个与好后缀匹配的最大前缀</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; len - 1 - i; ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				if(gs[j] == len) //gs[j]初始值为len, 这样确保gs[j]只被修改一次</span><br><span class="line">				&#123;</span><br><span class="line">					gs[j] = len - 1 - i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    //第一种情况</span><br><span class="line">	for(int i = 0; i &lt; len - 1; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		gs[len - 1 - suffix[i]] = len - 1 - i;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return gs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int bm_search(char* text, int text_len, char* pattern, int pattern_len)</span><br><span class="line">&#123;</span><br><span class="line">	int* bc = CreateBC(pattern, pattern_len);</span><br><span class="line">	int* gs = CreateGS(pattern, pattern_len);</span><br><span class="line"> </span><br><span class="line">	for(int i = 0; i &lt;= text_len - pattern_len; )</span><br><span class="line">	&#123;</span><br><span class="line">		int j = pattern_len - 1;</span><br><span class="line">		for(; j &gt;= 0 &amp;&amp; pattern[j] == text[i+j]; --j);</span><br><span class="line"> </span><br><span class="line">		if(j &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int bad_char_index = j;</span><br><span class="line">		char bad_char = text[i + j];</span><br><span class="line"> </span><br><span class="line">		int bc_move = bad_char_index - bc[bad_char];</span><br><span class="line">		if(bc_move &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			bc_move = bad_char_index + 1;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		int gs_move = gs[bad_char_index];</span><br><span class="line"> </span><br><span class="line">		int move = (bc_move &gt; gs_move ? bc_move : gs_move);</span><br><span class="line"> </span><br><span class="line">		i += move;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if(bc != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete bc;</span><br><span class="line">		bc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if(gs != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete bc;</span><br><span class="line">		gs = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**** **** **** **** **** ****</span><br><span class="line">* Function Name : 字符串匹配(KMP 算法)</span><br><span class="line">* Description : O(N+M)</span><br><span class="line">**** **** **** **** **** ****/</span><br><span class="line">void get_nextval(const string &amp; s, int * p)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0,j = -1;</span><br><span class="line">    p[0] = -1;</span><br><span class="line">    while(i &lt; s.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(j == -1 || s[i] == s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i,++j;</span><br><span class="line">            if(s[i] != s[j])</span><br><span class="line">                p[i] = j;</span><br><span class="line">            else</span><br><span class="line">                p[i] = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = p[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Index_KMP(const string &amp; s, const string &amp; s1, int pos)</span><br><span class="line">&#123;</span><br><span class="line">    int i = pos - 1,j = 0;</span><br><span class="line">    int * next = new int[s1.size()];</span><br><span class="line">    get_nextval(s1,next);</span><br><span class="line">    while(i &lt;= s.size() &amp;&amp; j &lt;= s1.size())</span><br><span class="line">    &#123;</span><br><span class="line">        if(j == -1 || s[i] == s1[j])</span><br><span class="line">            ++i,++j;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &gt; s1.size())</span><br><span class="line">        return i - s1.size();</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm=500006;    //maxm是总结点数：约为字母数+++</span><br><span class="line"></span><br><span class="line">char s[1000005],word[55];</span><br><span class="line">int nxt[maxm][26],tail[maxm],f[maxm],size;    //nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数</span><br><span class="line"></span><br><span class="line">int newnode()&#123;    //初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号</span><br><span class="line">    memset(nxt[size],0,sizeof(nxt[size]));</span><br><span class="line">    f[size]=tail[size]=0;</span><br><span class="line">    return size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(char s[])&#123;    //构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作</span><br><span class="line">    int i,p=0;</span><br><span class="line">    for(i=0;s[i];i++)&#123;</span><br><span class="line">        int &amp;x=nxt[p][s[i]-&apos;a&apos;];</span><br><span class="line">        p=x?x:x=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    tail[p]++;    //此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void makenxt()&#123;    //利用bfs来构造失配指针</span><br><span class="line">    int i;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    f[0]=0;    //先将0结点挂的字母加入队列，失配指针指向0结点</span><br><span class="line">    for(i=0;i&lt;26;i++)&#123;</span><br><span class="line">        int v=nxt[0][i];</span><br><span class="line">        if(v)&#123;</span><br><span class="line">            f[v]=0;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(i=0;i&lt;26;i++)&#123;</span><br><span class="line">            int v=nxt[u][i];</span><br><span class="line">            if(!v)nxt[u][i]=nxt[f[u]][i];    //当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母</span><br><span class="line">            else&#123;</span><br><span class="line">                q.push(v);    //u结点存在指向i的结点，则将所指向的结点下标加入队列</span><br><span class="line">                f[v]=nxt[f[u]][i];    //失配指针指向上个结点失配指针指向结点所挂当前字母的结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(char s[])&#123;    //查询s串中模式串出现了多少种/次</span><br><span class="line">    int ans=0,v=0;</span><br><span class="line">    for(int i=0;s[i];i++)&#123;</span><br><span class="line">        while(v&amp;&amp;!nxt[v][s[i]-&apos;a&apos;])v=f[v];    //先匹配直到没有失配</span><br><span class="line">        v=nxt[v][s[i]-&apos;a&apos;];</span><br><span class="line">        int tmp=v;</span><br><span class="line">        while(tmp)&#123;</span><br><span class="line">            ans+=tail[tmp];</span><br><span class="line">            tail[tmp]=0;    //这里加这句是为了仅计算出现多少种模式链，而若不加这句则可以计算累计出现多少次</span><br><span class="line">            tmp=f[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        int n;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        size=0,newnode();</span><br><span class="line">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%s&quot;,word);</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        makenxt();</span><br><span class="line">        scanf(&quot;%s&quot;,s);</span><br><span class="line">        printf(&quot;%d\n&quot;,query(s));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">const int CHAR = 26;</span><br><span class="line">const int MAXN = 250010;</span><br><span class="line">struct SAM_Node</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node *fa,*next[CHAR];</span><br><span class="line">    int len;</span><br><span class="line">    long long cnt;</span><br><span class="line">    void clear()</span><br><span class="line">    &#123;</span><br><span class="line">        fa = 0;</span><br><span class="line">        memset(next,0,sizeof(next));</span><br><span class="line">        cnt = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN*2];</span><br><span class="line">SAM_Node *root,*tail;</span><br><span class="line">SAM_Node* newnode(int len)</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node* cur = tail++;</span><br><span class="line">    cur−&gt;clear();</span><br><span class="line">    cur−&gt;len = len;</span><br><span class="line">    return cur;</span><br><span class="line">&#125;</span><br><span class="line">void SAM_init()</span><br><span class="line">&#123;</span><br><span class="line">    tail = pool;</span><br><span class="line">    root = newnode(0);</span><br><span class="line">&#125;</span><br><span class="line">SAM_Node* extend(SAM_Node* last,int x)</span><br><span class="line">&#123;</span><br><span class="line">    SAM_Node *p = last, *np = newnode(p−&gt;len+1);</span><br><span class="line">    while(p &amp;&amp; !p−&gt;next[x])</span><br><span class="line">        p−&gt;next[x] = np, p = p−&gt;fa;</span><br><span class="line">    if(!p)</span><br><span class="line">        np−&gt;fa = root;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        SAM_Node* q = p−&gt;next[x];</span><br><span class="line">        if(q−&gt;len == p−&gt;len+1)</span><br><span class="line">            np−&gt;fa = q;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            SAM_Node* nq = newnode(p−&gt;len+1);</span><br><span class="line">            memcpy(nq−&gt;next,q−&gt;next,sizeof(q−&gt;nextnq−&gt;fa = q−&gt;fa; q−&gt;fa = np−&gt;fa = nq;</span><br><span class="line">                                               while(p &amp;&amp; p−&gt;next[x] == q)p−&gt;next[x] = nq, p = p−&gt;fa;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">return np;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="Nim博弈"><a href="#Nim博弈" class="headerlink" title="Nim博弈"></a>Nim博弈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;cstring&gt;  </span><br><span class="line">#include &lt;cstdio&gt;  </span><br><span class="line">#define LL long long  </span><br><span class="line">#define mod 1000000007  </span><br><span class="line">#define sz 100005  </span><br><span class="line">using namespace std;  </span><br><span class="line">int sg[sz];  </span><br><span class="line">bool vis[sz];  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    //´ò±í³ÌÐò  </span><br><span class="line">    /*int tmp; </span><br><span class="line">    sg[0]=0; </span><br><span class="line">    for(int i=1;i&lt;=50;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        memset(vis,0,sizeof(vis)); </span><br><span class="line">        for(int j=0;j&lt;i;j++) </span><br><span class="line">            vis[sg[j]]=1; </span><br><span class="line">        for(int k=1;k&lt;i;k++) </span><br><span class="line">        &#123; </span><br><span class="line">            for(int m=1;m&lt;i;m++) </span><br><span class="line">            &#123; </span><br><span class="line">                int u=i-k-m; </span><br><span class="line">                if(u&gt;0) </span><br><span class="line">                &#123; </span><br><span class="line">                    tmp=sg[k]^sg[m]^sg[u]; </span><br><span class="line">                    vis[tmp]=1; </span><br><span class="line">                &#125; </span><br><span class="line">                else </span><br><span class="line">                    break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        for(int x=0;;x++) </span><br><span class="line">            if(!vis[x]) </span><br><span class="line">            &#123; </span><br><span class="line">                sg[i]=x; </span><br><span class="line">                printf(&quot;sg[%d]: %d\n&quot;,i,x); </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;*/  </span><br><span class="line">    int t,n,tmp,s;  </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);  </span><br><span class="line">    while(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        s=0;  </span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);  </span><br><span class="line">        while(n--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            scanf(&quot;%d&quot;,&amp;tmp);  </span><br><span class="line">            if(tmp%8==7)  </span><br><span class="line">                s^=(tmp+1);  </span><br><span class="line">            else if(tmp%8==0)  </span><br><span class="line">                s^=(tmp-1);  </span><br><span class="line">            else  </span><br><span class="line">                s^=tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if(s)  </span><br><span class="line">            printf(&quot;First player wins.\n&quot;);  </span><br><span class="line">        else  </span><br><span class="line">            printf(&quot;Second player wins.\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int wzf(int a,int b)&#123;</span><br><span class="line">        if(a&lt;b)&#123;</span><br><span class="line">            a^=b;</span><br><span class="line">            b^=a;</span><br><span class="line">            a^=b;</span><br><span class="line">        &#125;</span><br><span class="line">        int k=a-b;</span><br><span class="line">        a=(int)(k*(1+sqrt(5))/2.0);</span><br><span class="line">        if(a==b)</span><br><span class="line">            return 1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	for(int i=1;i&lt;100;i++)</span><br><span class="line">		for(int j=1;j&lt;100;j++)</span><br><span class="line">		if(wzf(i,j)) printf(&quot;(%d,%d) %d\n&quot;,i,j,i-j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int d[1000][10], n, k;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"> </span><br><span class="line">	d[0][0] = 1;</span><br><span class="line"> </span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">		d[i][1] = 1;</span><br><span class="line"> </span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line"> </span><br><span class="line">		for (int j = 1; j &lt;= k; j++)</span><br><span class="line"> </span><br><span class="line">			if (i &gt;= j)</span><br><span class="line"> </span><br><span class="line">				d[i][j] = d[i - j][j] + d[i - 1][j - 1];</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; d[n][k]&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间K大数"><a href="#区间K大数" class="headerlink" title="区间K大数"></a>区间K大数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#define MAXN 10010</span><br><span class="line">#define MAXE 100010</span><br><span class="line">using namespace std;</span><br><span class="line">int head[MAXN],tot1,tot2;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int u,v,next;</span><br><span class="line">&#125; e1[MAXE],e2[MAXN];</span><br><span class="line">void addEdge(int u,int v,Edge* edge,int&amp; tol)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tol].u=u;</span><br><span class="line">    edge[tol].v=v;</span><br><span class="line">    edge[tol].next=head[u];</span><br><span class="line">    head[u]=tol++;</span><br><span class="line">&#125;</span><br><span class="line">int n,m;</span><br><span class="line">int low[MAXN],dfn[MAXN],stack[MAXN],belong[MAXN],num[MAXN];</span><br><span class="line">bool instack[MAXN];</span><br><span class="line">int scc,top,INDEX;</span><br><span class="line">void Tarjan(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int v;</span><br><span class="line">    low[u]=dfn[u]=++INDEX;</span><br><span class="line">    stack[top++]=u;</span><br><span class="line">    instack[u]=true;</span><br><span class="line">    for(int i=head[u]; i!=-1; i=e1[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v=e1[i].v;</span><br><span class="line">        if(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            if(low[u]&gt;low[v])</span><br><span class="line">                low[u]=low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(instack[v]&amp;&amp;low[u]&gt;dfn[v])</span><br><span class="line">            low[u]=dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    if(low[u]==dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        ++scc;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            v=stack[--top];</span><br><span class="line">            instack[v]=false;</span><br><span class="line">            belong[v]=scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int inde[MAXN],outde[MAXN];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(instack,false,sizeof(instack));</span><br><span class="line">    memset(num,0,sizeof(num));</span><br><span class="line">    scc=top=INDEX=0;</span><br><span class="line">    for(int i=1; i&lt;=n; ++i)</span><br><span class="line">        if(!dfn[i])</span><br><span class="line">            Tarjan(i);</span><br><span class="line">    tot2=0;</span><br><span class="line">    memset(head,-1,sizeof(head));</span><br><span class="line">    memset(inde,0,sizeof(inde));</span><br><span class="line">    memset(outde,0,sizeof(outde));</span><br><span class="line">    int u,v;</span><br><span class="line">    for(int i=0; i&lt;m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=belong[e1[i].u];</span><br><span class="line">        v=belong[e1[i].v];</span><br><span class="line">        if(u!=v)</span><br><span class="line">        &#123;</span><br><span class="line">            addEdge(u,v,e2,tot2);</span><br><span class="line">            inde[v]++;</span><br><span class="line">            outde[u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int a=0,b=0;</span><br><span class="line">    for(int i=1; i&lt;=scc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!inde[i])</span><br><span class="line">            a++;</span><br><span class="line">        if(!outde[i])</span><br><span class="line">            b++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(scc==1)</span><br><span class="line">        printf(&quot;0\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d\n&quot;,max(a,b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int zushu;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;zushu);</span><br><span class="line">    while(zushu--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">        tot1=0;</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        int u,v;</span><br><span class="line">        for(int i=0; i&lt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">            addEdge(u,v,e1,tot1);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">22. 22. 22. 22. 区间 KKKK 大数</span><br><span class="line">//POJ 2104</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int NMAX = 100000;</span><br><span class="line">const int LOGNMAX = 17 +1;</span><br><span class="line">int sortseq[LOGNMAX][NMAX];</span><br><span class="line">int num[NMAX];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int l,r,d;</span><br><span class="line">    node * pl,* pr;</span><br><span class="line">&#125; mem[(NMAX&lt;&lt;1)+100];</span><br><span class="line">int mempos,n,m;</span><br><span class="line">node * root;</span><br><span class="line">node * make_tree(int l,int r,int d)</span><br><span class="line">&#123;</span><br><span class="line">    node * rt = mem+(mempos ++);</span><br><span class="line">    rt-&gt;l = l;</span><br><span class="line">    rt-&gt;r = r;</span><br><span class="line">    rt-&gt;d = d;</span><br><span class="line">    if (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        sortseq[d][l] = num[l];</span><br><span class="line">        return rt;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (l+r) &gt;&gt; 1;</span><br><span class="line">    rt-&gt;pl = make_tree(l,mid,d+1);</span><br><span class="line">    rt-&gt;pr = make_tree(mid+1,r,d+1);</span><br><span class="line">    int i=l,j=mid+1,k=l;</span><br><span class="line">    while (i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        if (sortseq[d+1][i] &lt; sortseq[d+1][j])</span><br><span class="line">            sortseq[d][k++] =</span><br><span class="line">                sortseq[d+1][i++];</span><br><span class="line">        else</span><br><span class="line">            sortseq[d][k++] = sortseq[d+1][j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (i&lt;=mid)</span><br><span class="line">        sortseq[d][k++] = sortseq[d+1][i++];</span><br><span class="line">    while (j&lt;=r)</span><br><span class="line">        sortseq[d][k++] = sortseq[d+1][j++];</span><br><span class="line">    return rt;</span><br><span class="line">&#125;</span><br><span class="line">int s,t,rank;</span><br><span class="line">int query(node * rt,int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i,mid,ret;</span><br><span class="line">    if (s &lt;= rt-&gt;l &amp;&amp; rt-&gt;r &lt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (val &lt;= sortseq[rt-&gt;d][rt-&gt;l])</span><br><span class="line">            return 0;</span><br><span class="line">        else if (sortseq[rt-&gt;d][rt-&gt;r] &lt; val)</span><br><span class="line">            return rt-&gt;r - rt-&gt;l +1;</span><br><span class="line">        else if (sortseq[rt-&gt;d][rt-&gt;r] == val)</span><br><span class="line">            return rt-&gt;r - rt-&gt;l;</span><br><span class="line">        int l = rt-&gt;l, r = rt-&gt;r, mid;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r) &gt;&gt; 1;</span><br><span class="line">            if (val &lt;= sortseq[rt-&gt;d][mid])</span><br><span class="line">                r = mid-1;</span><br><span class="line">            else</span><br><span class="line">                l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l - rt-&gt;l;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ret = 0;</span><br><span class="line">        mid = (rt-&gt;l+rt-&gt;r) &gt;&gt; 1;</span><br><span class="line">        if (s &lt;= mid)</span><br><span class="line">            ret += query(rt-&gt;pl,val);</span><br><span class="line">        if (mid+1 &lt;= t)</span><br><span class="line">            ret += query(rt-&gt;pr,val);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 二分查找时遇到相同值的处理非常重要</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,l,r;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        scanf(&quot;%d&quot;,num+i);</span><br><span class="line">    mempos = 0;</span><br><span class="line">    root = make_tree(0,n-1,0);</span><br><span class="line">    while (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        s = get_val()-1;</span><br><span class="line">        t = get_val()-1;</span><br><span class="line">        rank = get_val()-1;</span><br><span class="line">        l = 0, r = n-1;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (l+r) &gt;&gt; 1;</span><br><span class="line">// 二分查找sortseq[0][mid]在区间[s,t]中的排名</span><br><span class="line">            int pos = query(root,sortseq[0][mid]);</span><br><span class="line">            if (rank &lt; pos)</span><br><span class="line">                r = mid-1;</span><br><span class="line">            else</span><br><span class="line">                l = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,sortseq[0][r]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getid(int x)&#123;</span><br><span class="line">	return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;</span><br><span class="line">&#125;</span><br><span class="line">	for(int i = 1;i&lt;=n;++i)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    	v.push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end());</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="统计1的个数"><a href="#统计1的个数" class="headerlink" title="统计1的个数"></a>统计1的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int NumberOfOne(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">    	n &amp;= (n-1);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    
	
	  <div>
    
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;"><hr>纸短情长啊<i class="fa fa-paw"></i>文章结束了<i class="fa fa-paw"></i>但我们的故事还在继续</div>
    
</div>
    
	  </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="王骏 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay-reward-image.jpg" alt="王骏 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
          
            <a href="/tags/数据结构/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
          
            <a href="/tags/图论/" rel="tag"><i class="fa fa-tag"></i> 图论</a>
          
            <a href="/tags/数论/" rel="tag"><i class="fa fa-tag"></i> 数论</a>
          
            <a href="/tags/动态规划/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/02/2018-10-02/" rel="next" title="NAIPC2016-F.Mountain Scenes">
                <i class="fa fa-chevron-left"></i> NAIPC2016-F.Mountain Scenes
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/08/2018-10-08/" rel="prev" title="强连通图经典算法——Tarjan算法">
                强连通图经典算法——Tarjan算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjA4NC8xMjYxOQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="王骏" />
            
              <p class="site-author-name" itemprop="name">王骏</p>
              <p class="site-description motion-element" itemprop="description">浪打浮沉惊白昼，沧海一笑浅悠悠。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">143</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qian-youyou" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.15249144478@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://vjudge.net/user/15249144478" target="_blank" title="vjduge">
                      
                        <i class="fa fa-fw fa-globe"></i>vjduge</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5264080143/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.baidu.com/" target="_blank" title="baidu">
                      
                        <i class="fa fa-fw fa-globe"></i>baidu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qian_youyou" target="_blank" title="csdn">
                      
                        <i class="fa fa-fw fa-globe"></i>csdn</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qian_youyou" title="浅悠悠CSDN" target="_blank">浅悠悠CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://my.csdn.net/por_una_cabze" title="渣渣灰CSDN" target="_blank">渣渣灰CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://my.csdn.net/messhiro" title="赵神CSDN" target="_blank">赵神CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.matrix67.com/" title="matrix67博客" target="_blank">matrix67博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://amon1997.com/" title="曹静的博客" target="_blank">曹静的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/sophia__yu" title="杨祥钰CSDN" target="_blank">杨祥钰CSDN</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>
	  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66"></iframe>
	  
      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集"><span class="nav-number">1.1.1.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集路径压缩按雉合并"><span class="nav-number">1.1.2.</span> <span class="nav-text">并查集路径压缩按雉合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加权并查集"><span class="nav-number">1.1.3.</span> <span class="nav-text">加权并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单调队列"><span class="nav-number">1.1.4.</span> <span class="nav-text">单调队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链式前向星"><span class="nav-number">1.1.5.</span> <span class="nav-text">链式前向星</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树结构"><span class="nav-number">1.2.</span> <span class="nav-text">树结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树状数组"><span class="nav-number">1.2.1.</span> <span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树"><span class="nav-number">1.2.2.</span> <span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主席树"><span class="nav-number">1.2.3.</span> <span class="nav-text">主席树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie树"><span class="nav-number">1.2.4.</span> <span class="nav-text">Trie树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伸展树"><span class="nav-number">1.2.5.</span> <span class="nav-text">伸展树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCA-Tarjan"><span class="nav-number">1.2.6.</span> <span class="nav-text">LCA(Tarjan)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RMQ"><span class="nav-number">1.3.</span> <span class="nav-text">RMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ST表"><span class="nav-number">1.3.1.</span> <span class="nav-text">ST表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通莫队"><span class="nav-number">1.3.2.</span> <span class="nav-text">普通莫队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#莫队"><span class="nav-number">1.3.3.</span> <span class="nav-text">莫队</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-number">2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01背包"><span class="nav-number">2.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCS"><span class="nav-number">2.2.</span> <span class="nav-text">LCS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概率dp"><span class="nav-number">2.3.</span> <span class="nav-text">概率dp</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图论"><span class="nav-number">3.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路"><span class="nav-number">3.1.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-邻接矩阵"><span class="nav-number">3.1.1.</span> <span class="nav-text">Dijkstra(邻接矩阵)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra"><span class="nav-number">3.1.2.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-heap"><span class="nav-number">3.1.3.</span> <span class="nav-text">Dijkstra+heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA"><span class="nav-number">3.1.4.</span> <span class="nav-text">SPFA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPFA-SLF优化"><span class="nav-number">3.1.5.</span> <span class="nav-text">SPFA+SLF优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd"><span class="nav-number">3.1.6.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K短路"><span class="nav-number">3.1.7.</span> <span class="nav-text">K短路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成树"><span class="nav-number">3.2.</span> <span class="nav-text">生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal"><span class="nav-number">3.2.1.</span> <span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim"><span class="nav-number">3.2.2.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#次小生成树"><span class="nav-number">3.2.3.</span> <span class="nav-text">次小生成树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序"><span class="nav-number">3.3.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络流"><span class="nav-number">3.4.</span> <span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FF"><span class="nav-number">3.4.1.</span> <span class="nav-text">FF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EK"><span class="nav-number">3.4.2.</span> <span class="nav-text">EK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DINIC"><span class="nav-number">3.4.3.</span> <span class="nav-text">DINIC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DINIC优化"><span class="nav-number">3.4.4.</span> <span class="nav-text">DINIC优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DINIC-邻接矩阵"><span class="nav-number">3.4.5.</span> <span class="nav-text">DINIC(邻接矩阵)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISAP"><span class="nav-number">3.4.6.</span> <span class="nav-text">ISAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCMF"><span class="nav-number">3.4.7.</span> <span class="nav-text">MCMF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配"><span class="nav-number">3.5.</span> <span class="nav-text">匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法-邻接矩阵"><span class="nav-number">3.5.1.</span> <span class="nav-text">匈牙利算法(邻接矩阵)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法"><span class="nav-number">3.5.2.</span> <span class="nav-text">匈牙利算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KM算法"><span class="nav-number">3.5.3.</span> <span class="nav-text">KM算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KM算法最小权匹配"><span class="nav-number">3.5.4.</span> <span class="nav-text">KM算法最小权匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KM算法最小权匹配优化版"><span class="nav-number">3.5.5.</span> <span class="nav-text">KM算法最小权匹配优化版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强连通"><span class="nav-number">3.6.</span> <span class="nav-text">强连通</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan"><span class="nav-number">3.6.1.</span> <span class="nav-text">Tarjan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tarjan缩点"><span class="nav-number">3.6.2.</span> <span class="nav-text">Tarjan缩点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SAT"><span class="nav-number">3.7.</span> <span class="nav-text">2-SAT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数学"><span class="nav-number">4.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#gcd"><span class="nav-number">4.1.</span> <span class="nav-text">gcd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exgcd"><span class="nav-number">4.2.</span> <span class="nav-text">exgcd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中国剩余定理"><span class="nav-number">4.3.</span> <span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#欧拉函数"><span class="nav-number">4.4.</span> <span class="nav-text">欧拉函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#欧拉筛"><span class="nav-number">4.5.</span> <span class="nav-text">欧拉筛</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卡特兰数"><span class="nav-number">4.6.</span> <span class="nav-text">卡特兰数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#卡特兰数打表"><span class="nav-number">4.6.1.</span> <span class="nav-text">卡特兰数打表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卡特兰数表"><span class="nav-number">4.6.2.</span> <span class="nav-text">卡特兰数表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#斯特林数"><span class="nav-number">4.7.</span> <span class="nav-text">斯特林数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一类斯特林数"><span class="nav-number">4.7.1.</span> <span class="nav-text">第一类斯特林数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二类斯特林数"><span class="nav-number">4.7.2.</span> <span class="nav-text">第二类斯特林数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逆元"><span class="nav-number">4.8.</span> <span class="nav-text">逆元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展欧几里得算法"><span class="nav-number">4.8.1.</span> <span class="nav-text">扩展欧几里得算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#费马小定理-欧拉定理"><span class="nav-number">4.8.2.</span> <span class="nav-text">费马小定理/欧拉定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递推求逆元"><span class="nav-number">4.8.3.</span> <span class="nav-text">递推求逆元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lucas定理"><span class="nav-number">4.9.</span> <span class="nav-text">Lucas定理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#费马小定理实现"><span class="nav-number">4.9.1.</span> <span class="nav-text">费马小定理实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exgcd实现"><span class="nav-number">4.9.2.</span> <span class="nav-text">exgcd实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#莫比乌斯反演"><span class="nav-number">4.10.</span> <span class="nav-text">莫比乌斯反演</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#莫比乌斯Euler打表"><span class="nav-number">4.11.</span> <span class="nav-text">莫比乌斯Euler打表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#miller-rabin，Pollard-rho算法"><span class="nav-number">4.12.</span> <span class="nav-text">miller-rabin，Pollard_rho算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大素数判断和素因子分解"><span class="nav-number">4.12.1.</span> <span class="nav-text">大素数判断和素因子分解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速幂"><span class="nav-number">4.13.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵快速幂"><span class="nav-number">4.14.</span> <span class="nav-text">矩阵快速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速乘"><span class="nav-number">4.15.</span> <span class="nav-text">快速乘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#O-logn-快速乘"><span class="nav-number">4.15.1.</span> <span class="nav-text">O(logn)快速乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#O-1-快速乘"><span class="nav-number">4.15.2.</span> <span class="nav-text">O(1)快速乘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模板"><span class="nav-number">4.15.2.1.</span> <span class="nav-text">模板</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高斯消元"><span class="nav-number">4.16.</span> <span class="nav-text">高斯消元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全排列全组合"><span class="nav-number">4.17.</span> <span class="nav-text">全排列全组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#母函数"><span class="nav-number">4.18.</span> <span class="nav-text">母函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容斥原理"><span class="nav-number">4.19.</span> <span class="nav-text">容斥原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离散对数"><span class="nav-number">4.20.</span> <span class="nav-text">离散对数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自适应-simpson-积分"><span class="nav-number">4.21.</span> <span class="nav-text">自适应 simpson 积分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串hash"><span class="nav-number">5.1.</span> <span class="nav-text">字符串hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和数值hash"><span class="nav-number">5.2.</span> <span class="nav-text">字符串和数值hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BM"><span class="nav-number">5.3.</span> <span class="nav-text">BM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-number">5.4.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AC自动机"><span class="nav-number">5.5.</span> <span class="nav-text">AC自动机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后缀自动机"><span class="nav-number">5.6.</span> <span class="nav-text">后缀自动机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#博弈论"><span class="nav-number">6.</span> <span class="nav-text">博弈论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nim博弈"><span class="nav-number">6.1.</span> <span class="nav-text">Nim博弈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#威佐夫博弈"><span class="nav-number">6.2.</span> <span class="nav-text">威佐夫博弈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">7.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整数划分"><span class="nav-number">7.1.</span> <span class="nav-text">整数划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间K大数"><span class="nav-number">7.2.</span> <span class="nav-text">区间K大数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离散化"><span class="nav-number">7.3.</span> <span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算"><span class="nav-number">7.4.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#统计1的个数"><span class="nav-number">7.4.1.</span> <span class="nav-text">统计1的个数</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王骏</span>

  
</div>


  <div class="powered-by">
版权由 <a class="theme-link" target="_blank" href="https://qian-youyou.github.io">王骏</a> 所有</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/qian-youyou">wj.Mist.5.2.0</a></div>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 光顾人数：前世
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次邂逅
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 浏览次数：今生
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次回眸
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.2.0"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "middleRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

  
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>